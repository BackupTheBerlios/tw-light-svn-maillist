From yurand at sheep.berlios.de  Sat Sep 18 01:42:46 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 18 Sep 2004 01:42:46 +0200
Subject: [Tw-light-svn] r52 - trunk/gamedata
Message-ID: <200409172342.i8HNgkjG003812@sheep.berlios.de>

Author: yurand
Date: 2004-09-18 01:42:17 +0200 (Sat, 18 Sep 2004)
New Revision: 52

Modified:
   trunk/gamedata/readme.html
Log:
removing unused ships from readme


/usr/local/bin/commit-email.pl: `/usr/bin/svnlook diff /svnroot/repos/tw-light -r 52' failed with this output:
Modified: trunk/gamedata/readme.html
===================================================================


From yurand at sheep.berlios.de  Sat Sep 18 01:47:24 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 18 Sep 2004 01:47:24 +0200
Subject: [Tw-light-svn] r53 - trunk/gamedata
Message-ID: <200409172347.i8HNlOsR003987@sheep.berlios.de>

Author: yurand
Date: 2004-09-18 01:46:56 +0200 (Sat, 18 Sep 2004)
New Revision: 53

Modified:
   trunk/gamedata/readme.html
Log:
svn mail list test


/usr/local/bin/commit-email.pl: `/usr/bin/svnlook diff /svnroot/repos/tw-light -r 53' failed with this output:
Modified: trunk/gamedata/readme.html
===================================================================


From yurand at sheep.berlios.de  Sat Sep 18 02:01:51 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 18 Sep 2004 02:01:51 +0200
Subject: [Tw-light-svn] r54 - trunk/gamedata/ships
Message-ID: <200409180001.i8I01pj7004418@sheep.berlios.de>

Author: yurand
Date: 2004-09-18 02:01:38 +0200 (Sat, 18 Sep 2004)
New Revision: 54

Modified:
   trunk/gamedata/ships/shpalabc.txt
Log:
list test


/usr/local/bin/commit-email.pl: `/usr/bin/svnlook diff /svnroot/repos/tw-light -r 54' failed with this output:
Modified: trunk/gamedata/ships/shpalabc.txt
===================================================================


From yurand at sheep.berlios.de  Sat Sep 18 02:12:20 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 18 Sep 2004 02:12:20 +0200
Subject: [Tw-light-svn] r55 - trunk/source
Message-ID: <200409180012.i8I0CKGM004763@sheep.berlios.de>

Author: yurand
Date: 2004-09-18 02:12:07 +0200 (Sat, 18 Sep 2004)
New Revision: 55

Modified:
   trunk/source/scp.cpp
Log:
test


/usr/local/bin/commit-email.pl: `/usr/bin/svnlook diff /svnroot/repos/tw-light -r 55' failed with this output:
Modified: trunk/source/scp.cpp
===================================================================


From yurand at sheep.berlios.de  Sat Sep 18 13:58:15 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 18 Sep 2004 13:58:15 +0200
Subject: [Tw-light-svn] r56 - trunk/gamedata/sound/ships/shpalabc
Message-ID: <200409181158.i8IBwFeI022544@sheep.berlios.de>

Author: yurand
Date: 2004-09-18 13:58:14 +0200 (Sat, 18 Sep 2004)
New Revision: 56

Added:
   trunk/gamedata/sound/ships/shpalabc/WAVE_C02_WAV.wav
Removed:
   trunk/gamedata/sound/ships/shpalabc/WAVE_D01_WAV.wav
Log:
Fixed Alary sound


/usr/local/bin/commit-email.pl: `/usr/bin/svnlook diff /svnroot/repos/tw-light -r 56' failed with this output:
Copied: trunk/gamedata/sound/ships/shpalabc/WAVE_C02_WAV.wav (from rev 53, trunk/gamedata/sound/ships/shpalabc/WAVE_D01_WAV.wav)

Deleted: trunk/gamedata/sound/ships/shpalabc/WAVE_D01_WAV.wav
===================================================================
(Binary files differ)



From yurand at sheep.berlios.de  Sat Sep 18 16:35:06 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 18 Sep 2004 16:35:06 +0200
Subject: [Tw-light-svn] r57 - in trunk/source: . melee other util
Message-ID: <200409181435.i8IEZ6K3028198@sheep.berlios.de>

Author: yurand
Date: 2004-09-18 16:35:04 +0200 (Sat, 18 Sep 2004)
New Revision: 57

Modified:
   trunk/source/gui.cpp
   trunk/source/input.cpp
   trunk/source/melee/manim.cpp
   trunk/source/melee/mcontrol.cpp
   trunk/source/melee/mgame.cpp
   trunk/source/melee/mship.cpp
   trunk/source/melee/msprite.cpp
   trunk/source/other/twconfig.cpp
   trunk/source/scp.cpp
   trunk/source/util/aastr.c
   trunk/source/util/errors.cpp
   trunk/source/util/errors.h
   trunk/source/util/sound.cpp
   trunk/source/util/sound.h
Log:
bug #101 was hidden,
fixed bug with using free memory in version string


/usr/local/bin/commit-email.pl: `/usr/bin/svnlook diff /svnroot/repos/tw-light -r 57' failed with this output:
Modified: trunk/source/gui.cpp
===================================================================


From yurand at sheep.berlios.de  Sun Sep 19 15:38:06 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 19 Sep 2004 15:38:06 +0200
Subject: [Tw-light-svn] r58 - in trunk/source: . melee util
Message-ID: <200409191338.i8JDc6Hf010305@sheep.berlios.de>

Author: yurand
Date: 2004-09-19 15:38:04 +0200 (Sun, 19 Sep 2004)
New Revision: 58

Modified:
   trunk/source/melee.h
   trunk/source/melee/mframe.cpp
   trunk/source/melee/mframe.h
   trunk/source/melee/msprite.cpp
   trunk/source/scp.cpp
   trunk/source/util/aastr.c
   trunk/source/util/errors.h
Log:
enabled Anti-aliasing (the game suck without it)
bug #101 is still valid, I only mask it

Some comments were turned in doxygen style 



/usr/local/bin/commit-email.pl: `/usr/bin/svnlook diff /svnroot/repos/tw-light -r 58' failed with this output:
Modified: trunk/source/melee/mframe.cpp
===================================================================


From yurand at sheep.berlios.de  Sun Sep 19 21:09:08 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 19 Sep 2004 21:09:08 +0200
Subject: [Tw-light-svn] r59 - in trunk/source: . melee
Message-ID: <200409191909.i8JJ98bG027248@sheep.berlios.de>

Author: yurand
Date: 2004-09-19 21:09:06 +0200 (Sun, 19 Sep 2004)
New Revision: 59

Modified:
   trunk/source/melee.h
   trunk/source/melee/mshpdata.cpp
   trunk/source/melee/msprite.cpp
Log:
Fixed memory waisting bug


/usr/local/bin/commit-email.pl: `/usr/bin/svnlook diff /svnroot/repos/tw-light -r 59' failed with this output:
Modified: trunk/source/melee/mshpdata.cpp
===================================================================


From yurand at sheep.berlios.de  Mon Sep 20 23:05:00 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Mon, 20 Sep 2004 23:05:00 +0200
Subject: [Tw-light-svn] r60 - in trunk: . Util gamedata/images source source/ais source/games source/melee source/other source/sc1ships source/sc2ships source/ships source/twgui source/util web
Message-ID: <200409202105.i8KL50rm023543@sheep.berlios.de>

Author: yurand
Date: 2004-09-20 23:04:58 +0200 (Mon, 20 Sep 2004)
New Revision: 60

Added:
   trunk/Util/addStackTrace.pl
   trunk/gamedata/images/bspab.jpg
   trunk/gamedata/images/stangrop.jpg
Removed:
   trunk/gamedata/images/logo.bmp
Modified:
   trunk/makefile
   trunk/source/ais/c_input.cpp
   trunk/source/ais/c_other.cpp
   trunk/source/frame.cpp
   trunk/source/games/gflmelee.cpp
   trunk/source/gui.cpp
   trunk/source/melee/manim.cpp
   trunk/source/melee/mcbodies.cpp
   trunk/source/melee/mcontrol.cpp
   trunk/source/melee/mfleet.cpp
   trunk/source/melee/mframe.cpp
   trunk/source/melee/mgame.cpp
   trunk/source/melee/mhelpers.cpp
   trunk/source/melee/mitems.cpp
   trunk/source/melee/mlog.cpp
   trunk/source/melee/mmain.cpp
   trunk/source/melee/mnet1.cpp
   trunk/source/melee/mship.cpp
   trunk/source/melee/mshot.cpp
   trunk/source/melee/mshpdata.cpp
   trunk/source/melee/mshppan.cpp
   trunk/source/melee/msprite.cpp
   trunk/source/melee/mtarget.cpp
   trunk/source/melee/mview.cpp
   trunk/source/other/nullphas.cpp
   trunk/source/other/objanim.cpp
   trunk/source/other/orbit.cpp
   trunk/source/other/planet3d.cpp
   trunk/source/other/radar.cpp
   trunk/source/other/shippart.cpp
   trunk/source/other/vbodies.cpp
   trunk/source/other/vtarget.cpp
   trunk/source/sc1ships/shpandgu.cpp
   trunk/source/sc1ships/shparisk.cpp
   trunk/source/sc1ships/shpchebr.cpp
   trunk/source/sc1ships/shpearcr.cpp
   trunk/source/sc1ships/shpilwav.cpp
   trunk/source/sc1ships/shpkzedr.cpp
   trunk/source/sc1ships/shpmmrxf.cpp
   trunk/source/sc1ships/shpmycpo.cpp
   trunk/source/sc1ships/shpshosc.cpp
   trunk/source/sc1ships/shpspael.cpp
   trunk/source/sc1ships/shpsyrpe.cpp
   trunk/source/sc1ships/shpumgdr.cpp
   trunk/source/sc1ships/shpvuxin.cpp
   trunk/source/sc1ships/shpyehte.cpp
   trunk/source/sc2ships/shpchmav.cpp
   trunk/source/sc2ships/shpdruma.cpp
   trunk/source/sc2ships/shpkohma.cpp
   trunk/source/sc2ships/shpmeltr.cpp
   trunk/source/sc2ships/shporzne.cpp
   trunk/source/sc2ships/shppkufu.cpp
   trunk/source/sc2ships/shpslypr.cpp
   trunk/source/sc2ships/shpsupbl.cpp
   trunk/source/sc2ships/shpthrto.cpp
   trunk/source/sc2ships/shputwju.cpp
   trunk/source/sc2ships/shpzfpst.cpp
   trunk/source/scp.cpp
   trunk/source/ships/shpaktgu.cpp
   trunk/source/ships/shpalabc.cpp
   trunk/source/ships/shpbahbu.cpp
   trunk/source/ships/shpbipka.cpp
   trunk/source/ships/shpbogce.cpp
   trunk/source/ships/shpchoex.cpp
   trunk/source/ships/shpconca.cpp
   trunk/source/ships/shpconho.cpp
   trunk/source/ships/shpdragr.cpp
   trunk/source/ships/shpearc3.cpp
   trunk/source/ships/shpforsh.cpp
   trunk/source/ships/shpgarty.cpp
   trunk/source/ships/shpilwsp.cpp
   trunk/source/ships/shpkahbo.cpp
   trunk/source/ships/shprogsq.cpp
   trunk/source/ships/shpstaba.cpp
   trunk/source/ships/shptauar.cpp
   trunk/source/ships/shptauda.cpp
   trunk/source/ships/shptaume.cpp
   trunk/source/ships/shptausl.cpp
   trunk/source/ships/shptaust.cpp
   trunk/source/ships/shptauto.cpp
   trunk/source/ships/shpwolmi.cpp
   trunk/source/ships/shpyusra.cpp
   trunk/source/ships/shpzeksh.cpp
   trunk/source/twgui/twbutton.cpp
   trunk/source/twgui/twbuttontypes.cpp
   trunk/source/twgui/twgui.cpp
   trunk/source/twgui/twhelpers.cpp
   trunk/source/twgui/twmenuexamples.cpp
   trunk/source/twgui/twpopup.cpp
   trunk/source/twgui/twwindow.cpp
   trunk/source/twgui/utils.cpp
   trunk/source/util/base.cpp
   trunk/source/util/errors.cpp
   trunk/source/util/errors.h
   trunk/source/util/history.cpp
   trunk/source/util/random.cpp
   trunk/source/util/sound.cpp
   trunk/source/util/vector2.cpp
   trunk/web/index.html
   trunk/web/style.css
Log:
Added Jhon stacktrace script
Sources was patched using this script
Added 2 loading screen



Added: trunk/Util/addStackTrace.pl
===================================================================
--- trunk/Util/addStackTrace.pl	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/Util/addStackTrace.pl	2004-09-20 21:04:58 UTC (rev 60)
@@ -0,0 +1,107 @@
+#!/usr/bin/perl -w
+
+# $Id$
+# Original Author: John Cataldo aka jodiamonds at imap dot cc
+# Modified by Yura Semashko aka Yurand
+
+# Put the text 'STACKTRACE;' at the beginning of each C++ function.
+# This only recognizes functions which look like: text :: text (
+# not_close_paren ) { So non-class functions will never be recognized.
+# This is really a two line script, turned into a much larger
+# program. =)
+
+# All affected files are backed up to name~~ (similar to emacs backup file names).
+# You can set BACKUP='' to turn this behavior off.
+
+# This script will first delete all existing STACKTRACE mentions and
+# replace them.  Ones with are on the same line are likely to be
+# placed onto the next line.
+
+use strict;
+{#create a lexical scope, so these variables are accessible to the subroutines (but not global per se)
+
+  ########################################
+  ### CONFIGURATION VARIABLES ###
+  my( $BACKUP ) = ''; #SET THIS TO '' STOP THIS SCRIPT FROM BACKING UP FILES
+
+  ########################################
+  ### CHECK THE ARGUMENTS ###
+  #each and every argument should be a filename to do the replacements on, readable and writable
+  my( @args ) = @ARGV;
+  my( $filename );
+  my( $test );
+  my( $invalidArguments ) = 0;
+  my( $fExists, $fReadable, $fWritable );
+  foreach $filename ( @args )
+    {
+      $fExists = -f $filename;
+      $fReadable = -r _;        #using _ means to use the stat() from the previous file stat(), which is better than checking it again
+      $fWritable = -w _;
+
+      warn "$filename doesn't exist!" unless $fExists;
+      warn "$filename isn't readable by $0!" unless $fReadable;
+      warn "$filename isn't writable by $0!" unless $fWritable;
+
+      $invalidArguments = 1 unless ( $fExists && $fReadable && $fWritable );
+    }
+  die "\n\nAborting $0: One or more filenames aren't valid.  Usage: $0 filename filename ..." if $invalidArguments;
+
+
+  foreach $filename( @args ) #process each file
+    {
+      print "Processing $filename\n";
+
+      ########################################
+      ### GET ENTIRE FILE AS ONE STRING ###
+      #necessary for doing regex on the whole thing
+      open( INPUT, "<", $filename ) or die "can't open $filename for input";
+      my( @file ) = <INPUT>;	#the raw input
+      my( $line );
+      my( $blob ) = "";		#wholefile
+      foreach $line (@file) {
+	$blob .= $line;
+      }
+      close( INPUT );
+      @file = (); #just frees up some memory
+
+      my( $originalFile ) = $blob; #we save a copy of the file just to
+                                   #see if it changed.  this isn't
+                                   #particularly memory efficient, but
+                                   #is the simplest way to see if
+                                   #anything actually changed
+
+      ### THE MEAT OF THE FILE: TWO REGEXs ###
+      # Pretty much all of the actual changes happen on these two lines: 
+
+      # There's a couple weird things going on, like the \s* before
+      # STACKTRACE, which are just done to improve readability
+      # (i.e. try to put the new STACKTRACE in a place where it's most
+      # legible, which I define as on a line by itself at the same
+      # indentation as the NEXT line that's already in the function)
+
+      #the ';' after STACKTRACE appears to be optional, but this script will put it in afterwards.
+      #using /x at the end allows for commenting and whitespace!
+
+      ##### Delete all existing "STACKTRACE" instances (but only in the exact places where we will put it back in!) #####
+      $blob =~ s/(\s*\w+\s*::\s*\w+[(][^)]*[)]\s*(?:[:][^{]*)?\s*[{])\s*STACKTRACE;?/$1/xg;
+
+      ##### FIND THE PLACES STACKTRACE SHOULD SHOW UP, AND SHOVE IT IN THERE. #####
+      $blob =~ s/(\s*\w+\s*::\s*\w+[(][^)]*[)]\s*(?:[:][^{]*)?\s*[{])(\s*)/${1}\n  STACKTRACE;${2}/mg;
+      #/mg: multiline, since we have the whole file here, and global, meaning replace not just the first instance
+
+      #if the file changed, back it up and spit it out to disk
+      if ( $blob ne $originalFile )
+	{
+	  if ( $BACKUP )
+	    {
+	      rename $filename, "${filename}~~" or warn "couldn't backup $filename to ${filename}~~\n";
+	      print "\tBacked up $filename to ${filename}~~\n";
+	    }
+
+	  open( OUTPUT, ">", $filename ) or die "couldn't open $filename for output";
+	  print OUTPUT $blob;
+	  close OUTPUT;
+	  print "\tWrote out new $filename.\n";
+	}
+    }
+}


Property changes on: trunk/Util/addStackTrace.pl
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gamedata/images/bspab.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/bspab.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Deleted: trunk/gamedata/images/logo.bmp
===================================================================
(Binary files differ)

Added: trunk/gamedata/images/stangrop.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stangrop.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/makefile
===================================================================
--- trunk/makefile	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/makefile	2004-09-20 21:04:58 UTC (rev 60)
@@ -195,6 +195,10 @@
 
 update_source_list:
 	find source -type f "(" -name "*.c" -o -name "*.cpp" ")" >sources.lst
+
+add_stacktrace:
+	find source -name '*.cpp'|grep -v 'libraries'|grep -v 'errors.cpp'|grep -v 'utils.cpp'|xargs ./Util/addStackTrace.pl 
+
 install:
 	./install-sh $(NAME) $(EXECPATH)/$(NAME)
 	./install-sh gamedata $(DATAPATH)

Modified: trunk/source/ais/c_input.cpp
===================================================================
--- trunk/source/ais/c_input.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ais/c_input.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -215,12 +215,14 @@
 /*! \brief Get control name */
 const char *ControlHuman::getTypeName() 
 {
+  STACKTRACE;
   return "Keyboard/Joystick";
 }
 
 /*! \brief Process get input from player */
 int ControlHuman::think() 
 {
+  STACKTRACE;
   int r = 0;
   if (key_pressed(thrust))  r |= keyflag::thrust;
   if (key_pressed(back))    r |= keyflag::back;
@@ -243,10 +245,11 @@
 
 ControlHuman::ControlHuman(const char *name, int channel) : Control(name, channel, ai_index_human) 
 {
+  STACKTRACE;
 };
 
 int ControlHuman::choose_ship(VideoWindow *window, char * prompt, Fleet *fleet) {
-	STACKTRACE;
+  STACKTRACE;
 	int ret = -1, slot = 0;
 	if (fleet->getSize() == 0) {tw_error ("Empty fleet! (prompt:%s)", prompt);}
 	selectDialog[SELECT_DIALOG_LIST].dp3 = fleet;
@@ -277,6 +280,7 @@
 
 /*! returns help text for this controller ie keys to use this controller*/
 void ControlHuman::getHelpText(char * text) {
+  STACKTRACE;
 	char line[80] = "";
 	char desc[80] = "";
 
@@ -297,6 +301,7 @@
 /*! \brief setap players keys */
 void ControlHuman::setup() 
 {
+  STACKTRACE;
   int i, t = 0;
   int last = 0;
   while (true) 

Modified: trunk/source/ais/c_other.cpp
===================================================================
--- trunk/source/ais/c_other.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ais/c_other.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -24,11 +24,13 @@
 /*! \brief Get control name */
 const char *ControlVegetable::getTypeName() 
 {
+  STACKTRACE;
   return "VegetableBot";
 }
 /*! \brief This AI do nothing */
 int ControlVegetable::think() 
 {
+  STACKTRACE;
   return 0;
 }
 /*! \brief This function do nothing
@@ -36,6 +38,7 @@
 */
 int ControlVegetable::choose_ship(VideoWindow *window, char * prompt, class Fleet *fleet ) 
 {
+  STACKTRACE;
   return -1;
 }
 
@@ -45,6 +48,7 @@
 
 const char *ControlMoron::getTypeName() 
 {
+  STACKTRACE;
   return "MoronBot";
 }
 
@@ -90,6 +94,7 @@
 /*! \brief Summon stupid_bot() */
 int ControlMoron::think()
 {
+  STACKTRACE;
   if (ship)
     return stupid_bot(ship);
   else
@@ -98,6 +103,7 @@
 
 ControlMoron::ControlMoron(const char *name, int channel) : Control(name, channel, ai_index_moron) 
 {
+  STACKTRACE;
 }
 
 

Modified: trunk/source/frame.cpp
===================================================================
--- trunk/source/frame.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/frame.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -125,6 +125,7 @@
 
 Frame::Frame(int max_items) 
 {
+  STACKTRACE;
   window = new VideoWindow();
   window->preinit();
   surface = NULL;
@@ -165,6 +166,7 @@
 /*! \brief weild code to enlarge amount of items */
 void Frame::enlarge_list(int increment) 
 {
+  STACKTRACE;
   DirtyItem *temp;
   
   temp = item;
@@ -222,42 +224,49 @@
 /*! \brief Add pixel item to item list */
 void Frame::add_pixel(int x, int y)
 {
+  STACKTRACE;
   add_to_list(x, y, 0, 0, erase_pixel, draw_pixel);
 }
 
 /*! \brief Add box item to item list */
 void Frame::add_box(double x, double y, double w, double h)
 {
+  STACKTRACE;
   add_to_list((int)x, (int)y, (int)w, (int)h, erase_box, draw_box);
 }
 
 /*! \brief Add circle item to item list */
 void Frame::add_circle(int x, int y, int a, int b)
 {
+  STACKTRACE;
   add_to_list(x, y, a, b, erase_circle, draw_circle);
 }
 
 /*! \brief to be deleted? */
 void Frame::add_old_circle(int x, int y, int a, int b)
 {
+  STACKTRACE;
   add_to_old_list(x, y, a, b, erase_circle, draw_circle);
 }
 
 /*! \brief to be deleted? */
 void Frame::add_line(int x, int y, int a, int b)
 {
+  STACKTRACE;
   add_to_list(x, y, a, b, erase_line, draw_line);
 }
 
 /*! \brief to be deleted? */
 void Frame::add_old_pixel(int x, int y)
 {
+  STACKTRACE;
   add_to_old_list(x, y, 0, 0, erase_pixel, draw_pixel);
 }
 
 /*! \brief to be deleted? */
 void Frame::add_old_box(int x, int y, int a, int b)
 {
+  STACKTRACE;
   add_to_old_list(
 		  x, 
 		  y, 
@@ -270,6 +279,7 @@
 /*! \brief to be deleted? */
 void Frame::add_old_line(int x, int y, int a, int b)
 {
+  STACKTRACE;
   add_to_old_list(x, y, a, b, erase_line, draw_line);
 }
 

Modified: trunk/source/games/gflmelee.cpp
===================================================================
--- trunk/source/games/gflmelee.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/games/gflmelee.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -180,6 +180,7 @@
 
 StatsManager::StatsManager()
 {
+  STACKTRACE;
   Nships = 0;
   // no stats yet :)
 
@@ -465,6 +466,7 @@
 
 YRadar::YRadar(Control *ocontroller, double Size, TeamCode hteam, char *datafilename, bool rel, int shape)
 {
+  STACKTRACE;
   relative_angle = rel;
   display_shape = shape;
   
@@ -532,11 +534,13 @@
 
 void YRadar::toggleActive()
 {
+  STACKTRACE;
   active^=1;
 }
 
 void YRadar::setSize(double Size)
 {
+  STACKTRACE;
   size=Size;
 }
 
@@ -684,6 +688,7 @@
 
 ImIndicator::ImIndicator(SpaceLocation *o)
 {
+  STACKTRACE;
   showme = o;
   
   bmp = create_bitmap_ex( bitmap_color_depth(screen), ImIndicatorSize, ImIndicatorSize);

Modified: trunk/source/gui.cpp
===================================================================
--- trunk/source/gui.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/gui.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -90,6 +90,7 @@
 
 void TW_Dialog_Player::redraw() 
 {
+  STACKTRACE;
   int i;
   if (!player) return;
   for (i = 0; player->dialog[i].proc; i++) player->dialog[i].flags |= D_DIRTY;
@@ -99,6 +100,7 @@
 
 void TW_Dialog_Player::_event( Event * e) 
 {
+  STACKTRACE;
   switch (e->type) 
     {
     case Event::VIDEO: {
@@ -110,6 +112,7 @@
 
 void TW_Dialog_Player::init(VideoWindow *w, DIALOG *d, int focus) 
 {
+  STACKTRACE;
   dialog = d;
   window = w;
   ifocus = focus;
@@ -162,6 +165,7 @@
 }
 void TW_Dialog_Player::deinit() 
 {
+  STACKTRACE;
   int i;
   window->remove_callback(this);
   dialog[length].d2 -= 1;
@@ -188,6 +192,7 @@
 }
 int TW_Dialog_Player::update() 
 {
+  STACKTRACE;
   videosystem.poll_redraw();
   BITMAP *old = screen;
   screen = subscreen;

Modified: trunk/source/melee/manim.cpp
===================================================================
--- trunk/source/melee/manim.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/manim.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -53,7 +53,7 @@
 }
 
 void Animation::calculate() 
-{ 
+{
   STACKTRACE;
   frame_step -= frame_time;
   while (frame_step < 0) 
@@ -101,6 +101,7 @@
 
 void FixedAnimation::calculate() 
 {
+  STACKTRACE;
   if (follow->exists()) 
     {
       pos = follow->normal_pos();
@@ -120,6 +121,7 @@
   FixedAnimation(creator, opos, osprite, first_frame, num_frames, frame_length, depth),
   relative_pos(rel_pos)
 {
+  STACKTRACE;
   if (!follow || !follow->exists()) 
     {
       state = 0;
@@ -130,6 +132,7 @@
 
 void PositionedAnimation::calculate() 
 {
+  STACKTRACE;
   FixedAnimation::calculate();
   if (!exists()) 
     return;

Modified: trunk/source/melee/mcbodies.cpp
===================================================================
--- trunk/source/melee/mcbodies.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mcbodies.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -35,6 +35,7 @@
 Asteroid::Asteroid() 
 :	SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite), explosion(meleedata.asteroidExplosionSprite)
 {
+  STACKTRACE;
   collide_flag_sameteam = ALL_LAYERS;
   collide_flag_sameship = ALL_LAYERS;
   layer = LAYER_CBODIES;
@@ -51,6 +52,7 @@
 
 void Asteroid::calculate()
 {
+  STACKTRACE;
   step-= frame_time;
   while(step <= 0) 
     {
@@ -64,6 +66,7 @@
 
 int Asteroid::handle_damage(SpaceLocation *source, double normal, double direct) 
 {
+  STACKTRACE;
   if (!exists()) 
     return 0;
   if (!normal && !direct) 
@@ -77,7 +80,8 @@
 }
 
 void Asteroid::death() 
-{		  
+{
+  STACKTRACE;		  
   Animation *a = new Animation(this, pos,
 			       explosion, 0, explosion->frames(), time_ratio, get_depth());
   a->match_velocity(this);
@@ -91,6 +95,7 @@
   :
   SpaceObject(NULL, loc, 0.0, sprite) 
 {
+  STACKTRACE;
   collide_flag_sameship = ALL_LAYERS;
   layer = LAYER_CBODIES;
   set_depth(DEPTH_PLANETS);
@@ -110,6 +115,7 @@
 
 void Planet::inflict_damage(SpaceObject *other) 
 {
+  STACKTRACE;
   int i = 1;
   if (other->isShip()) 
     {
@@ -147,6 +153,7 @@
 
 void Planet::calculate() 
 {
+  STACKTRACE;
   SpaceObject::calculate();
   SpaceObject *o;
   Query a;
@@ -329,10 +336,12 @@
 
 void Stars::select_view( View **view) 
 {
+  STACKTRACE;
   v = view;
 }
 
 void Stars::_event( Event *e) {
+  STACKTRACE;
   if (e->type == Event::TW_CONFIG) 
     {
       ConfigEvent *ce = (ConfigEvent *) e;
@@ -358,6 +367,7 @@
 
 Stars::Stars()
 {
+  STACKTRACE;
   int i;
   v = NULL;
   set_depth(DEPTH_STARS);
@@ -404,6 +414,7 @@
 
 void Stars::animate(Frame *space) 
 {
+  STACKTRACE;
   if (v && (space_view != *v)) return;
 
   double d = space_zoom;

Modified: trunk/source/melee/mcontrol.cpp
===================================================================
--- trunk/source/melee/mcontrol.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mcontrol.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -85,14 +85,17 @@
 
 int Control::rand() 
 {
+  STACKTRACE;
   if (channel == Game::channel_none) 
     return random();
   return (::rand() ^ ((::rand() << 12) + (::rand() <<24))) & 0x7fffffff;
 }
 
-void Control::setup() {}
+void Control::setup() {
+  STACKTRACE;}
 void Control::select_ship(Ship* ship_pointer, const char* ship_name) 
 {
+  STACKTRACE;
   ship = ship_pointer;
   if (ship) 
     {
@@ -108,14 +111,17 @@
 
 void Control::load(const char* inifile, const char* inisection) 
 {
+  STACKTRACE;
   return;
 }
 void Control::save(const char* inifile, const char* inisection) 
 {
+  STACKTRACE;
   return;
 }
 SpaceLocation *Control::get_focus() 
 {
+  STACKTRACE;
   if (ship) 
     return ship->get_focus();
   else return NULL;
@@ -124,6 +130,7 @@
 
 int Control::choose_ship(VideoWindow *window, char * prompt, Fleet *fleet) 
 {
+  STACKTRACE;
 	//automatically select a random ship, without interrupting the user.
 	// HumanControl is where a user can select a ship herself.
 		
@@ -135,6 +142,7 @@
 }
 void Control::set_target(int i) 
 {
+  STACKTRACE;
   if (i >= targets->N) {tw_error("oscar hamburger!!!!!!!!!");}
   if (i == -1) 
     {
@@ -150,6 +158,7 @@
 
 void Control::target_stuff() 
 {
+  STACKTRACE;
   if (index == -1) 
     {
       if (targets->N) 
@@ -214,7 +223,8 @@
 }
 
 void Control::calculate() 
-{ 
+{
+  STACKTRACE; 
   if (!exists()) 
     return;
 
@@ -276,14 +286,17 @@
 
 int Control::think()
 {
+  STACKTRACE;
   return 0;
 }
 char *Control::getDescription() 
 {
+  STACKTRACE;
    return iname;
 }
 void Control::_event(Event *e) 
 {
+  STACKTRACE;
    //add code for lag increase / decrease here
   return;
 }
@@ -292,6 +305,7 @@
 						   target(NULL), index(-1), always_random(0), _prediction_keys(NULL),
 						   _controlType(controlType)
 {
+  STACKTRACE;
   id |= ID_CONTROL;
   attributes |= ATTRIB_SYNCHED;
   if (channel != Game::channel_none) 
@@ -312,6 +326,7 @@
 }
 bool Control::die() 
 {
+  STACKTRACE;
   if (channel == Game::channel_none) 
     return Presence::die();
   // controls CANNOT arbitrarily be killed off, because the deal with networking directly
@@ -324,6 +339,7 @@
 
 bool Control::valid_target(SpaceObject *t) 
 {
+  STACKTRACE;
   // GEO: this error sometimes occur, unknown why.
   // speculation: it happened with a wasx clone; perhaps its mother died before
   // and since it shared control, and didn't check for a dead mother before the

Modified: trunk/source/melee/mfleet.cpp
===================================================================
--- trunk/source/melee/mfleet.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mfleet.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -76,14 +76,15 @@
 	reference_fleet->Sort();
 }
 
-    Fleet::Fleet() {STACKTRACE
+    Fleet::Fleet() {
+  STACKTRACE;
         cost = 0;
         maxFleetCost = (FleetCost)FLEET_COST_DEFAULT;
         memset(title, '\0', MAX_TITLE_LENGTH);
     };
 
     void Fleet::reset() {
-		STACKTRACE;
+  STACKTRACE;
         ships.clear();
         this->cost = 0;
         memset(title, '\0', MAX_TITLE_LENGTH);
@@ -120,7 +121,8 @@
 #define READ(a) if (int(s+sizeof(a))>psize) {delete k;tw_error ("deserialize_fleet - bad!");}memcpy(&a, &buffy[s], sizeof(a)); s += sizeof(a);
 #define READ2(a,b) if (b+s>psize) {delete k;tw_error ("deserialize_fleet - bad!");}memcpy(&a, &buffy[s], b); s += b;
 
-void Fleet::deserialize(void *data, int psize) {        
+void Fleet::deserialize(void *data, int psize) {
+  STACKTRACE;        
   unsigned char *buffy = (unsigned char *) data;
   int s = 0;
   int j;
@@ -176,6 +178,7 @@
        
 
     int Fleet::addShipType(ShipType * type) {
+  STACKTRACE;
         if ( (getSize() >= MAX_FLEET_SIZE) || (type == NULL))
             return -1;
 
@@ -186,6 +189,7 @@
     }
 
     void Fleet::addFleet(Fleet * fleetToAdd) {
+  STACKTRACE;
         for (int i=0; i<fleetToAdd->getSize(); i++)
             addShipType(fleetToAdd->getShipType(i));
     }
@@ -198,14 +202,16 @@
     
     }
 
-    ShipType * Fleet::getShipType(int slot) {STACKTRACE
+    ShipType * Fleet::getShipType(int slot) {
+  STACKTRACE;
         if ( (slot<0) || (slot>=(int)ships.size()))
             return NULL;
 
         return ships[slot];
     }
 
-    void Fleet::save(const char *filename, const char *section) {STACKTRACE
+    void Fleet::save(const char *filename, const char *section) {
+  STACKTRACE;
         int count = 0;
         char slot_str[8];
     
@@ -227,7 +233,8 @@
         set_config_int(section, "MaxFleetCost", getMaxCost());
     }
 
-    void Fleet::load(const char *filename, const char *section) {STACKTRACE
+    void Fleet::load(const char *filename, const char *section) {
+  STACKTRACE;
         int i, count;
         ShipType *type;
         char slot_str[8];
@@ -385,6 +392,7 @@
 };
 
 void Fleet::Sort(SortingMethod sortMethod, bool ascending, int startIndex, int endIndex) {
+  STACKTRACE;
   MyFleetListType::iterator _begin, _end;
   int _size = ships.size();
   
@@ -464,6 +472,7 @@
 }
 
 int Fleet::getNextFleetEntryByCharacter(unsigned int currentShip, char c) {
+  STACKTRACE;
         
         ASSERT(ships.at(currentShip) != NULL);
         ASSERT(currentShip < ships.size());

Modified: trunk/source/melee/mframe.cpp
===================================================================
--- trunk/source/melee/mframe.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mframe.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -174,7 +174,8 @@
 	return;
 	}
 
-void Query::end() {STACKTRACE
+void Query::end() {
+  STACKTRACE;
 	}
 
 
@@ -294,11 +295,13 @@
 	return;
 	}
 
-void Query2::end() {STACKTRACE
+void Query2::end() {
+  STACKTRACE;
 	}
 
 
-Presence::Presence() {STACKTRACE
+Presence::Presence() {
+  STACKTRACE;
 	total_presences += 1;
 	attributes = 0;
 	state = 1;
@@ -365,10 +368,12 @@
 	return ((attributes & ATTRIB_SYNCHED) != 0);
 	}
 
-SpaceLocation *Presence::get_focus() {STACKTRACE
+SpaceLocation *Presence::get_focus() {
+  STACKTRACE;
 	return NULL;
 	}
-SpaceLocation *SpaceLocation::get_focus() {STACKTRACE
+SpaceLocation *SpaceLocation::get_focus() {
+  STACKTRACE;
 	return this;
 	}
 
@@ -383,7 +388,8 @@
 	collide_flag_sameteam(0),
 	collide_flag_sameship(0)
 
-{STACKTRACE
+{
+  STACKTRACE;
 	id |= SPACE_LOCATION;
 	attributes |= ATTRIB_SYNCHED;
 	attributes |= ATTRIB_LOCATION;
@@ -408,7 +414,8 @@
 
 	}
 
-bool SpaceLocation::change_owner(SpaceLocation *new_owner) {STACKTRACE
+bool SpaceLocation::change_owner(SpaceLocation *new_owner) {
+  STACKTRACE;
 	if (new_owner) {
 		ally_flag = new_owner->ally_flag;
 		ship = new_owner->ship;
@@ -422,7 +429,8 @@
 	return true;
 	}
 
-void SpaceLocation::death() {STACKTRACE
+void SpaceLocation::death() {
+  STACKTRACE;
 }
 
 double SpaceLocation::get_angle_ex() const
@@ -456,7 +464,8 @@
 }
 
 double SpaceLocation::distance(SpaceLocation *l)
-{STACKTRACE
+{
+  STACKTRACE;
   return(distance_from(normal_pos(), l->normal_pos()));
 }
 
@@ -474,6 +483,7 @@
 
 void SpaceLocation::change_vel(Vector2 dvel)
 {
+  STACKTRACE;
 	vel += dvel;
 }
 
@@ -481,6 +491,7 @@
 */
 void SpaceLocation::change_pos(Vector2 dpos)
 {
+  STACKTRACE;
 	pos = normalize(pos + dpos);
 }
 
@@ -488,23 +499,28 @@
 */
 void SpaceLocation::change_pos(double scale)
 {
+  STACKTRACE;
 	pos *= scale;
 }
 
-void SpaceLocation::ship_died() {STACKTRACE
+void SpaceLocation::ship_died() {
+  STACKTRACE;
 	ship = NULL;
 }
 void SpaceLocation::target_died() {
+  STACKTRACE;
 	target = NULL;
 }
 
-double SpaceLocation::trajectory_angle(SpaceLocation *l) {STACKTRACE
+double SpaceLocation::trajectory_angle(SpaceLocation *l) {
+  STACKTRACE;
 	return ::trajectory_angle(pos, l->normal_pos());
 }
 
 
 bool inline SpaceLocation::detectable()
 {
+  STACKTRACE;
 	int i;
 	i = attributes & ATTRIB_UNDETECTABLE;
 
@@ -515,6 +531,7 @@
 
 
 int SpaceLocation::canCollide(SpaceLocation *other) {
+  STACKTRACE;
 	if (!detectable()) return 0;
 	if (sameShip(other)) return ((1 << other->layer) & collide_flag_sameship);
 	else if (sameTeam(other)) return ((1 << other->layer) & collide_flag_sameteam);
@@ -528,6 +545,7 @@
 
 void SpaceLocation::set_team(TeamCode k)
 {
+  STACKTRACE;
 	ally_flag &= ~team_mask;
 	ally_flag |= k << team_shift;
 }
@@ -545,14 +563,17 @@
 }
 
 void Presence::set_depth(double d) {
+  STACKTRACE;
 	_depth = int(floor(ldexp(d, 8)));
 }
 
 double Presence::get_depth() {
+  STACKTRACE;
 	return ldexp((double)_depth, -8);
 }
 
-Planet *SpaceLocation::nearest_planet() {STACKTRACE
+Planet *SpaceLocation::nearest_planet() {
+  STACKTRACE;
 	Planet *p = NULL;
 	double r = 99999999;
 	Query q;
@@ -572,22 +593,26 @@
 
 int SpaceLocation::translate( Vector2 delta) 
 {
+  STACKTRACE;
   pos = normalize ( pos + delta, map_size );
   return true;
 }
 
 int SpaceLocation::accelerate(SpaceLocation *source, double angle, double velocity, double max_speed) 
 {
+  STACKTRACE;
   _accelerate(angle, velocity, max_speed);
   return true;
 }
 int SpaceLocation::accelerate(SpaceLocation *source, Vector2 delta_v, double max_speed) 
 {
+  STACKTRACE;
   _accelerate(delta_v, max_speed);
   return true;
 }
 void SpaceLocation::_accelerate(double angle, double velocity, double max_speed) 
 {
+  STACKTRACE;
   double ovm, nvm;
   Vector2 nv;
 
@@ -609,6 +634,7 @@
 
 void SpaceLocation::_accelerate(Vector2 delta_v, double max_speed) 
 {
+  STACKTRACE;
   double ovm, nvm;
   Vector2 nv;
 
@@ -637,6 +663,7 @@
 				       double velocity, 
 				       double max_speed) 
 {
+  STACKTRACE;
 	Planet *p = nearest_planet();
 	if (!p) return SpaceLocation::accelerate(source, angle, velocity, max_speed);
 	double tmp;
@@ -650,10 +677,12 @@
 
 void SpaceLocation::animate(Frame* f) 
 {
+  STACKTRACE;
 }
 
 void SpaceLocation::calculate() 
 {
+  STACKTRACE;
   if (target && !target->exists()) 
     {
       target_died();
@@ -667,12 +696,14 @@
 
 void SpaceObject::set_sprite(SpaceSprite *new_sprite) 
 {
+  STACKTRACE;
   sprite = new_sprite;
   size = new_sprite->size();
 }
 
 void SpaceObject::calculate() 
 {
+  STACKTRACE;
   SpaceLocation::calculate();
   if ((attributes & ATTRIB_STANDARD_INDEX) && sprite) 
     {
@@ -690,6 +721,7 @@
   sprite(osprite),
   sprite_index(0)
 {
+  STACKTRACE;
   attributes |= ATTRIB_OBJECT;
   if (game && game->friendly_fire) collide_flag_sameteam = ALL_LAYERS;
   collide_flag_sameship = 0;
@@ -701,12 +733,14 @@
 
 void SpaceObject::animate(Frame *space) 
 {
+  STACKTRACE;
   sprite->animate(pos, sprite_index, space);
   return;
 }
 
 void SpaceObject::collide(SpaceObject *other) 
 {
+  STACKTRACE;
   double tmp;
   
   if (this == other) {tw_error("SpaceObject::collide - self!");}
@@ -778,6 +812,7 @@
 
 double SpaceObject::collide_ray(Vector2 lp1, Vector2 lp2, double llength)
 {
+  STACKTRACE;
 	int collide_x = (int)(lp2.x);
 	int collide_y = (int)(lp2.y);
 	Vector2 d;
@@ -796,6 +831,7 @@
 
 void SpaceObject::inflict_damage(SpaceObject *other) 
 {
+  STACKTRACE;
   int i;
   if (damage_factor > 0) 
     {
@@ -831,6 +867,7 @@
 }
 
 void SpaceObject::death() {
+  STACKTRACE;
 	if (attributes & ATTRIB_NOTIFY_ON_DEATH) {
 		physics->object_died(this, NULL);
 		attributes &= ~ ATTRIB_NOTIFY_ON_DEATH;
@@ -843,7 +880,8 @@
 	SpaceLocation(creator, lpos, langle),
 	length(llength),
 	color(lcolor)
-	{STACKTRACE
+	{
+  STACKTRACE;
 	id = SPACE_LINE;
 	attributes |= ATTRIB_LINE;// | ATTRIB_COLLIDE_STATIC;
 	layer = LAYER_LINES;
@@ -908,6 +946,7 @@
 
 void SpaceLine::animate(Frame *space) 
 {
+  STACKTRACE;
   
   Vector2 p1 = corner( pos );
   Vector2 p2 = p1 + edge() * space_zoom;
@@ -962,10 +1001,12 @@
 }
 
 unsigned int Physics::new_ship() {
+  STACKTRACE;
 	last_ship += 1;
 	return last_ship;
 	}
 TeamCode Physics::new_team() {
+  STACKTRACE;
 	last_team += 1;
 	return last_team;
 	}
@@ -1012,7 +1053,7 @@
 
 
 void Physics::add(SpaceLocation *o) {
-	STACKTRACE;
+  STACKTRACE;
 	if (o->attributes & ATTRIB_INGAME) {tw_error("addItem - already added");}
 	if (!o->isLocation()) {tw_error("addItem - catastrophic");}
 	//if (!o->_serial) _list(o);
@@ -1102,8 +1143,9 @@
     return false;
 }
 
-void Physics::calculate() {
-  _STACKTRACE("Physics::calculate()");
+void Physics::calculate() 
+{
+  STACKTRACE;
   int i;
   
   //adjust time
@@ -1242,8 +1284,9 @@
 }
 
 
-void Physics::collide() {
-  _STACKTRACE("Physics::collide()");
+void Physics::collide() 
+{
+  STACKTRACE;
   PMASKDATA_FLOAT *tmp;
   int l = 0;
   tmp = new PMASKDATA_FLOAT[item.size()];
@@ -1297,7 +1340,8 @@
   return;
 }
 
-void Physics::prepare() {STACKTRACE
+void Physics::prepare() {
+  STACKTRACE;
 	::physics_time = this->game_time;
 	::render_time = this->game_time;
 	::frame_time = this->frame_time;
@@ -1306,7 +1350,7 @@
 	return;
 }
 int Physics::checksum() {
-  _STACKTRACE("Physics::checksum");
+  STACKTRACE;
   Uint32 g = 0;
   for(std::list<SpaceLocation*>::iterator i=item.begin();i!=item.end();i++)
     {
@@ -1332,12 +1376,14 @@
 
 void Physics::ship_died(Ship *who, SpaceLocation *source)
 {
+  STACKTRACE;
 	// nothing ...
 }
 
 
 void Physics::object_died(SpaceObject *who, SpaceLocation *source)
 {
+  STACKTRACE;
   if (who && who->isShip())
     {
       ship_died((Ship*)who, source);

Modified: trunk/source/melee/mgame.cpp
===================================================================
--- trunk/source/melee/mgame.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mgame.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -56,6 +56,7 @@
 
 MeleeData::MeleeData()
 {
+  STACKTRACE;
 	panelSprite             = NULL;
 	kaboomSprite            = NULL;
 	hotspotSprite           = NULL;
@@ -72,6 +73,7 @@
 
 void MeleeData::init()
 {
+  STACKTRACE;
   melee = load_datafile(data_full_path("melee.dat").c_str());
   if (!melee) tw_error("Error loading melee data\n");
 
@@ -101,6 +103,7 @@
 
 void MeleeData::deinit()
 {
+  STACKTRACE;
 	panelSprite             = NULL;
 	kaboomSprite            = NULL;
 	hotspotSprite           = NULL;
@@ -152,6 +155,7 @@
 
 Game *GameType::new_game() 
 {
+  STACKTRACE;
   Game *tmp = _new_game();
   tmp->preinit();
   tmp->type = this;
@@ -183,6 +187,7 @@
 
 void Game::_event(Event *e) 
 {
+  STACKTRACE;
   switch (e->type) 
     {
     case Event::VIDEO: 
@@ -223,6 +228,7 @@
 
 void Game::add_focus(Presence *new_focus, int channel) 
 {
+  STACKTRACE;
   if ((channel != -1) && !log->playback && !(log->get_direction(channel) & Log::direction_write))
     return;
   num_focuses += 1;
@@ -235,6 +241,7 @@
 
 
 void Game::prepare() {
+  STACKTRACE;
 #ifdef _MSC_VER
   _asm { finit }
 #elif defined(__GCC__) && defined(__i386__)
@@ -248,6 +255,7 @@
 
 void Game::set_resolution(int screen_x, int screen_y) 
 {
+  STACKTRACE;
   int view_x, view_y;
   view_x = screen_x;
   view_y = screen_y;
@@ -257,6 +265,7 @@
 
 void Game::redraw() 
 {
+  STACKTRACE;
   if (!window->surface) return;
   scare_mouse();
   window->lock();
@@ -272,6 +281,7 @@
 
 Ship *Game::create_ship(const char *id, Control *c, Vector2 pos, double angle, int team) 
 {
+  STACKTRACE;
   ShipType *type = shiptype(id);
   if (!type)
     {tw_error("Game::create_ship - bad ship id (%s)", id);}
@@ -287,6 +297,7 @@
 
 Ship *Game::create_ship(int channel, const char *id, const char *control, Vector2 pos, double angle, int team) 
 {
+  STACKTRACE;
   Control *c = create_control(channel, control);
   if (!c)
     {tw_error("bad Control type!");}
@@ -297,6 +308,7 @@
 
 void Game::increase_latency() 
 {
+  STACKTRACE;
   if (CHECKSUM_CHANNEL) {
     log->buffer(channel_server + Game::_channel_buffered, NULL, 2);
     log->buffer(channel_client + Game::_channel_buffered, NULL, 2);
@@ -309,6 +321,7 @@
 
 void Game::decrease_latency() 
 {
+  STACKTRACE;
   if (lag_frames <= 1) {tw_error("latency decreased too far");}
   if (CHECKSUM_CHANNEL) {
     log->unbuffer(channel_server + Game::_channel_buffered, NULL, 2);
@@ -330,6 +343,7 @@
 
 void Game::log_fleet(int channel, Fleet *fleet) 
 {
+  STACKTRACE;
   int fl;
   void *tmpdata = fleet->serialize(&fl);
   char buffer[16384];
@@ -361,12 +375,14 @@
 }
 
 void Game::log_char(int channel, char &data) {
+  STACKTRACE;
 	if (!log) return;
 	log->log  (channel, &data, 1);
 	return;
 }
 
 void Game::log_short(int channel, short &data) {
+  STACKTRACE;
 	if (!log) return;
 	data = intel_ordering_short(data);	
 	log->log  (channel, &data, sizeof(short));
@@ -375,6 +391,7 @@
 }
 
 void Game::log_int(int channel, int &data) {
+  STACKTRACE;
 	if (!log) return;
 	data = intel_ordering(data);
 	log->log  (channel, &data, sizeof(int));
@@ -382,13 +399,15 @@
 	return;
 }
 
-void Game::log_data(int channel, void *data, int size) {STACKTRACE
+void Game::log_data(int channel, void *data, int size) {
+  STACKTRACE;
 	if (!log) return;
 	log->log  (channel, data, size);
 	return;
 }
 
-void Game::idle(int time) {STACKTRACE
+void Game::idle(int time) {
+  STACKTRACE;
 	if (log->listen()) return;
 	::idle(time);
 	return;
@@ -396,11 +415,13 @@
 
 void Game::animate(Frame *frame) 
 {
+  STACKTRACE;
   Physics::animate(frame);
 }
 
 void Game::animate() 
 {
+  STACKTRACE;
   double t = get_time();
   paused_time = 0;
   view->animate(this);
@@ -409,7 +430,8 @@
   return;
 }
 
-bool Game::game_ready() {STACKTRACE
+bool Game::game_ready() {
+  STACKTRACE;
 	if (CHECKSUM_CHANNEL == 0) return 1;
 	if (log->playback) {
 		return (log->ready(channel_server + Game::_channel_buffered) != 0);
@@ -456,6 +478,7 @@
 
 void Game::compare_checksums() 
 {
+  STACKTRACE;
   unsigned char local_checksum = checksum() & 255;
   unsigned char client_checksum = local_checksum;
   unsigned char server_checksum = local_checksum;
@@ -483,115 +506,126 @@
     }
 }
 
-void Game::do_game_events() {_STACKTRACE("Game::do_game_events()")
-	int i;
+void Game::do_game_events() 
+{
+  STACKTRACE;
+  int i;
 
-	//transmit from server
-	if (log->get_direction(channel_server) & Log::direction_write) {
-		COMPILE_TIME_ASSERT(sizeof(events_waiting) == sizeof(char));
-		log->buffer( channel_server + _channel_buffered, &events_waiting, sizeof(events_waiting) );
-		for (i = 0; i < events_waiting; i += 1) {
-			log->buffer ( channel_server + _channel_buffered, waiting_events[i], waiting_events[i]->size );
-		}
-		//deallocate transmitted events
-		for (i = 0; i < events_waiting; i += 1) free(waiting_events[i]);
-		events_waiting = 0;
-	}
-
-	//transmit from client
-	if (log->get_direction(channel_client) & Log::direction_write) {
-		COMPILE_TIME_ASSERT(sizeof(events_waiting) == sizeof(char));
-		log->buffer( channel_client + _channel_buffered, &events_waiting, sizeof(events_waiting) );
-		for (i = 0; i < events_waiting; i += 1) {
-			log->buffer ( channel_client + _channel_buffered, waiting_events[i], waiting_events[i]->size );
-		}
-		//deallocate transmitted events
-		for (i = 0; i < events_waiting; i += 1) free(waiting_events[i]);
-		events_waiting = 0;
-	}
-
-	//double-check transmission
-	if (events_waiting) {
-		tw_error("Game::do_game_events - events weren't sent properly");
-		for (i = 0; i < events_waiting; i += 1) free(waiting_events[i]);
-		events_waiting = 0;
-	}
-
-	//recieve
-	char ne;
-	COMPILE_TIME_ASSERT(sizeof(events_waiting) == sizeof(ne));
-	char buffy[1024];
-
-	//recieve from server
-	log->unbuffer(channel_server + _channel_buffered, &ne, sizeof(ne));
-	for (i = 0; i < ne; i += 1) {
-		char *tmp = buffy;
-		log->unbuffer(channel_server + _channel_buffered, &buffy, sizeof(GameEvent));
-		int s = ((GameEvent*)tmp)->size;
-		if (s > 1024) {
-			tmp = (char *)malloc(s);
-			memcpy(tmp, buffy, sizeof(GameEvent));
-		}
+  //transmit from server
+  if (log->get_direction(channel_server) & Log::direction_write) {
+    COMPILE_TIME_ASSERT(sizeof(events_waiting) == sizeof(char));
+    log->buffer( channel_server + _channel_buffered, &events_waiting, sizeof(events_waiting) );
+    for (i = 0; i < events_waiting; i += 1) {
+      log->buffer ( channel_server + _channel_buffered, waiting_events[i], waiting_events[i]->size );
+    }
+    //deallocate transmitted events
+    for (i = 0; i < events_waiting; i += 1) free(waiting_events[i]);
+    events_waiting = 0;
+  }
+  
+  //transmit from client
+  if (log->get_direction(channel_client) & Log::direction_write) {
+    COMPILE_TIME_ASSERT(sizeof(events_waiting) == sizeof(char));
+    log->buffer( channel_client + _channel_buffered, &events_waiting, sizeof(events_waiting) );
+    for (i = 0; i < events_waiting; i += 1) {
+      log->buffer ( channel_client + _channel_buffered, waiting_events[i], waiting_events[i]->size );
+    }
+    //deallocate transmitted events
+    for (i = 0; i < events_waiting; i += 1) free(waiting_events[i]);
+    events_waiting = 0;
+  }
+  
+  //double-check transmission
+  if (events_waiting) {
+    tw_error("Game::do_game_events - events weren't sent properly");
+    for (i = 0; i < events_waiting; i += 1) free(waiting_events[i]);
+    events_waiting = 0;
+  }
+  
+  //recieve
+  char ne;
+  COMPILE_TIME_ASSERT(sizeof(events_waiting) == sizeof(ne));
+  char buffy[1024];
+  
+  //recieve from server
+  log->unbuffer(channel_server + _channel_buffered, &ne, sizeof(ne));
+  for (i = 0; i < ne; i += 1) {
+    char *tmp = buffy;
+    log->unbuffer(channel_server + _channel_buffered, &buffy, sizeof(GameEvent));
+    int s = ((GameEvent*)tmp)->size;
+    if (s > 1024) {
+      tmp = (char *)malloc(s);
+      memcpy(tmp, buffy, sizeof(GameEvent));
+    }
 		log->unbuffer(channel_server + _channel_buffered, tmp + sizeof(GameEvent), s - sizeof(GameEvent));
 		handle_game_event ( channel_server, ((GameEvent*)tmp));
 		if (tmp != buffy) free(tmp);
-	}
-
-
-	//recieve from client
-	log->unbuffer(channel_client + _channel_buffered, &ne, sizeof(ne));
-	for (i = 0; i < ne; i += 1) {
-		char *tmp = buffy;
-		log->unbuffer(channel_client + _channel_buffered, &buffy, sizeof(GameEvent));
-		int s = ((GameEvent*)tmp)->size;
-		if (s > 1024) {
-			tmp = (char *)malloc(s);
-			memcpy(tmp, buffy, sizeof(GameEvent));
+  }
+  
+  
+  //recieve from client
+  log->unbuffer(channel_client + _channel_buffered, &ne, sizeof(ne));
+  for (i = 0; i < ne; i += 1) {
+    char *tmp = buffy;
+    log->unbuffer(channel_client + _channel_buffered, &buffy, sizeof(GameEvent));
+    int s = ((GameEvent*)tmp)->size;
+    if (s > 1024) {
+      tmp = (char *)malloc(s);
+      memcpy(tmp, buffy, sizeof(GameEvent));
 		}
-		log->unbuffer(channel_client + _channel_buffered, tmp + sizeof(GameEvent), s - sizeof(GameEvent));
-		handle_game_event ( channel_client, ((GameEvent*)tmp));
-		if (tmp != buffy) free(tmp);
-	}
+    log->unbuffer(channel_client + _channel_buffered, tmp + sizeof(GameEvent), s - sizeof(GameEvent));
+    handle_game_event ( channel_client, ((GameEvent*)tmp));
+    if (tmp != buffy) free(tmp);
+  }
 }
 
-void Game::handle_game_event ( int source, class GameEvent *event ) {STACKTRACE
-	if ((event->type <= event_invalid) || (event->type >= event_last)) {
-		tw_error("Game::handle_game_event - Bad event type: %d", event->type);
-	}
-	switch (event->type) {
-		case event_change_lag: ((GameEventChangeLag*)event)->execute(source);
-		break;
-		case event_message: ((GameEventMessage*)event)->execute(source);
-		break;
-	}
+void Game::handle_game_event ( int source, class GameEvent *event ) 
+{
+  STACKTRACE;
+  if ((event->type <= event_invalid) || (event->type >= event_last)) 
+    {
+      tw_error("Game::handle_game_event - Bad event type: %d", event->type);
+    }
+  switch (event->type) 
+    {
+    case event_change_lag: ((GameEventChangeLag*)event)->execute(source);
+      break;
+    case event_message: ((GameEventMessage*)event)->execute(source);
+      break;
+    }
 }
 
-void Game::send_game_event ( class GameEvent *event ) {STACKTRACE
-	if (events_waiting == maximum_events_waiting) {
-		tw_error("too many GameEvents");
-		return;
-	}
-	if (!waiting_events) waiting_events = new GameEvent*[maximum_events_waiting];
-	waiting_events[events_waiting] = event;
-	events_waiting += 1;
+void Game::send_game_event ( class GameEvent *event ) 
+{
+  STACKTRACE;
+  if (events_waiting == maximum_events_waiting) 
+    {
+      tw_error("too many GameEvents");
+      return;
+    }
+  if (!waiting_events) waiting_events = new GameEvent*[maximum_events_waiting];
+  waiting_events[events_waiting] = event;
+  events_waiting += 1;
 }
 
 
-void Game::calculate() {_STACKTRACE("Game::calculate")
-	int i;
-	double t = get_time();
-	int active_focus_destroyed = false;
-
-
-	paused_time = 0;
-	compare_checksums();
-	do_game_events();
-
-	for (i = 0; i < num_focuses; i += 1) {
-		if (!focus[i]->exists()) {
-			num_focuses -= 1;
-			if (focus_index == i) {
-				focus[i]->attributes &= ~ATTRIB_ACTIVE_FOCUS;
+void Game::calculate() 
+{
+  STACKTRACE;
+  int i;
+  double t = get_time();
+  int active_focus_destroyed = false;
+  
+  
+  paused_time = 0;
+  compare_checksums();
+  do_game_events();
+  
+  for (i = 0; i < num_focuses; i += 1) {
+    if (!focus[i]->exists()) {
+      num_focuses -= 1;
+      if (focus_index == i) {
+	focus[i]->attributes &= ~ATTRIB_ACTIVE_FOCUS;
 				active_focus_destroyed = 1;
 				focus_index -= 1;
 				if (num_focuses && (focus_index < 0))
@@ -622,6 +656,7 @@
 
 void Game::play() 
 {
+  STACKTRACE;
   set_resolution(window->w, window->h);
   prepare();
   if (is_paused()) 
@@ -700,6 +735,7 @@
 
 void Game::ship_died(Ship *who, SpaceLocation *source)
 {
+  STACKTRACE;
   if (source && source->data) 
     {
       std::string tmp = "";
@@ -721,13 +757,15 @@
 
 void Game::object_died(SpaceObject *who, SpaceLocation *source)
 {
+  STACKTRACE;
 	if (who && who->isShip())
 	{
 		ship_died((Ship*)who, source);
 	}
 }
 
-void Game::fps() {STACKTRACE
+void Game::fps() {
+  STACKTRACE;
 	if ((!log->playback) && ((log->type == Log::log_net1server) || (log->type == Log::log_net1client))) {
 		int ping = ((NetLog*)log)->ping;
 		char *tt = "good";
@@ -782,6 +820,7 @@
 
 void Game::preinit() 
 {
+  STACKTRACE;
   Physics::preinit();
   //	meleedata.planetSprite = meleedata.asteroidSprite = meleedata.asteroidExplosionSprite = meleedata.hotspotSprite = meleedata.kaboomSprite = meleedata.panelSprite = meleedata.sparkSprite = meleedata.xpl1Sprite = NULL;
   // you should reset it here (again), cause there can be subgames of this type.
@@ -804,75 +843,77 @@
   music = "";
 }
 
-void Game::init(Log *_log) {_STACKTRACE("Game::init")
-	int i;
+void Game::init(Log *_log) 
+{
+  STACKTRACE;
+  int i;
 
-	game_done = false;
-	log = _log;
-	if (!log) {
-		log = new Log();
-		log->init();
-	}
-
-	lag_frames = 0;
-	show_fps = 0;
-	game_time = 0;
-	frame_time = 1;
-	frame_number = 0;
-	hiccup_margin = 100;
-	next_tic_time = get_time();
-	next_render_time = game_time;
-	next_fps_time = game_time;
-	view_locked = false;
-	physics_locked = false;
-	if (log->type != Log::log_normal || log->playback) physics_locked = true;
-	local_checksum = client_checksum = server_checksum = 0;
-
-	Physics::init();
-	prepare();
-
-	if (!window) {
-		window = new VideoWindow();
-		window->preinit();
-	}
-
-	tw_set_config_file("client.ini");
-	change_view(get_config_string("View", "View", "Hero")); 
-
-	window->add_callback(this);
-
-	if (!log->playback) {
-		switch (log->type) {
-			case Log::log_normal: {
-			}
+  game_done = false;
+  log = _log;
+  if (!log) {
+    log = new Log();
+    log->init();
+  }
+  
+  lag_frames = 0;
+  show_fps = 0;
+  game_time = 0;
+  frame_time = 1;
+  frame_number = 0;
+  hiccup_margin = 100;
+  next_tic_time = get_time();
+  next_render_time = game_time;
+  next_fps_time = game_time;
+  view_locked = false;
+  physics_locked = false;
+  if (log->type != Log::log_normal || log->playback) physics_locked = true;
+  local_checksum = client_checksum = server_checksum = 0;
+  
+  Physics::init();
+  prepare();
+  
+  if (!window) {
+    window = new VideoWindow();
+    window->preinit();
+  }
+  
+  tw_set_config_file("client.ini");
+  change_view(get_config_string("View", "View", "Hero")); 
+  
+  window->add_callback(this);
+  
+  if (!log->playback) {
+    switch (log->type) {
+    case Log::log_normal: {
+    }
+      break;
+    case Log::log_net1server: {
+    }
+      break;
+    case Log::log_net1client: {
+    }
 			break;
-			case Log::log_net1server: {
-			}
-			break;
-			case Log::log_net1client: {
-			}
-			break;
-			default: {
-				tw_error("Knee!");
-			}
-			break;
-		}
-	}
-
-/* CONTENTS OF CHANNEL channel_init :
-
-offset	size	format		data
-0		4		int			log type number
+    default: {
+      tw_error("Knee!");
+    }
+      break;
+    }
+  }
+  
+  /* CONTENTS OF CHANNEL channel_init :
+     
+  offset	size	format		data
+  0		4		int			log type number
 4		4		int			size of game type name
 8		?		char[]		game type name
 ?		4		int			lag frames
 
-*/
-	int tmp = log->type;
-	log_int(channel_init, tmp);
-	if (log->playback) log->type = tmp;
+  */
+  int tmp = log->type;
+  log_int(channel_init, tmp);
+  if (log->playback) log->type = tmp;
 
-	char buffy[128];
+  char buffy[128];
 	i = strlen(type->name);
 	memcpy(buffy, type->name, i);
 	if (i > 127) {tw_error("long gamename1");}
@@ -928,7 +969,8 @@
 	return;
 }
 
-void Game::init_lag() {STACKTRACE
+void Game::init_lag() {
+  STACKTRACE;
 	if ((log->type == Log::log_net1server) || (log->type == Log::log_net1client)) {
 		int lag_time = 0;//get_config_int("Network", "Lag", 200);
 		char blah = 0;
@@ -960,7 +1002,8 @@
 	}
 }
 
-void Game::change_view(View *new_view) {STACKTRACE//this function looks wrong to me
+void Game::change_view(View *new_view) {
+  STACKTRACE;//this function looks wrong to me
 	View *v = new_view;
 	v->preinit();
 	v->init(view);
@@ -979,7 +1022,8 @@
 	return;
 }
 
-void Game::change_view(const char * name) {STACKTRACE
+void Game::change_view(const char * name) {
+  STACKTRACE;
 	View *v = get_view(name, view);
 	if (!v)	{tw_error("Game::change_view - invalid view name");}
 	if (view)
@@ -1023,6 +1067,7 @@
 
 bool Game::is_paused() 
 {
+  STACKTRACE;
   if (time_paused != -1) 
     return true;
   return false;
@@ -1030,6 +1075,7 @@
 
 void Game::pause() 
 {
+  STACKTRACE;
   if (time_paused != -1) 
     tw_error ("can't pause -- already paused");
   time_paused = get_time();
@@ -1037,6 +1083,7 @@
 
 void Game::unpause() 
 {
+  STACKTRACE;
   if (time_paused == -1) 
     tw_error ("can't unpause -- not paused");
   redraw();
@@ -1047,6 +1094,7 @@
 
 void Game::save_screenshot() 
 {
+  STACKTRACE;
   static int shot_index = 0;
   char path[80];
 
@@ -1076,6 +1124,7 @@
 
 bool Game::handle_key(int k) 
 {
+  STACKTRACE;
   switch (k >> 8) 
     {
 #if !defined _DEBUG
@@ -1207,6 +1256,7 @@
 }
 
 int Game::set_frame_time(int t) {
+  STACKTRACE;
 	this->frame_time = t;
 	prepare();
 	return 1;
@@ -1214,6 +1264,7 @@
 
 int Game::set_turbo(double t) 
 {
+  STACKTRACE;
   this->normal_turbo = t;
   prepare();
   return 1;
@@ -1221,17 +1272,20 @@
 
 double Game::get_turbo() 
 {
+  STACKTRACE;
   return this->normal_turbo;
 }
 
 void Game::play_music() 
 {
+  STACKTRACE;
   tw_sound.play_music(data_full_path("music/Robeter-battle-music-remix.ogg"));
   return;
 }
 
 void Game::quit(const char *message) 
-{ 
+{
+  STACKTRACE; 
   game_done = true;
 }
 

Modified: trunk/source/melee/mhelpers.cpp
===================================================================
--- trunk/source/melee/mhelpers.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mhelpers.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -160,6 +160,7 @@
 
 int VideoSystem::poll_redraw() 
 {
+  STACKTRACE;
   last_poll = get_time();
   if (screen_corrupted) 
     {
@@ -172,6 +173,7 @@
 
 void VideoSystem::preinit() 
 {
+  STACKTRACE;
   int i;
   surface = NULL;
   width = -1;
@@ -206,6 +208,7 @@
 
 FONT *VideoSystem::get_font(int s) 
 {
+  STACKTRACE;
   if (!font_data) 
     {
       if (basic_font) 
@@ -223,6 +226,7 @@
 
 void VideoSystem::set_palette(RGB *new_palette) 
 {
+  STACKTRACE;
   memcpy(palette, new_palette, sizeof(RGB) * 256);
   update_colors();
   return;
@@ -230,6 +234,7 @@
 
 void VideoSystem::update_colors() 
 {
+  STACKTRACE;
   RGB tmp[256];
   if (!palette) return;
   memcpy(tmp, palette, sizeof(RGB) * 256);
@@ -249,6 +254,7 @@
 
 void VideoSystem::redraw() 
 {
+  STACKTRACE;
   VideoEvent ve;
   ve.type = Event::VIDEO;
   ve.subtype = VideoEvent::REDRAW;
@@ -416,12 +422,14 @@
 
 void VideoWindow::hide() 
 {
+  STACKTRACE;
   locate(0,0,0,0,0,0,0,0);
   return;
 }
 
 void VideoWindow::add_callback( BaseClass *callee ) 
 {
+  STACKTRACE;
   std::list<BaseClass*>::iterator cb = std::find(callback_list.begin(),callback_list.end(), callee);
   if(cb != callback_list.end())
     {
@@ -433,12 +441,14 @@
 
 void VideoWindow::remove_callback( BaseClass *callee ) 
 {
+  STACKTRACE;
   callback_list.remove(callee);
   return;
 }
 
 void VideoWindow::event(int subtype) 
 {
+  STACKTRACE;
   if (lock_level) 
     {tw_error("VideoWindow - illegal while locked");}
   VideoEvent ve;
@@ -451,6 +461,7 @@
 
 void VideoWindow::update_pos() 
 {
+  STACKTRACE;
   if (lock_level) 
     {tw_error("VideoWindow - illegal while locked");}
   int nx = 0, ny = 0, nw = 0, nh = 0;
@@ -488,6 +499,7 @@
 
 void VideoWindow::_event( Event *e ) 
 {
+  STACKTRACE;
   if (e->type == Event::VIDEO) 
     {
       const VideoEvent *ve = (const VideoEvent *) e;
@@ -577,6 +589,7 @@
 
 void VideoWindow::deinit() 
 {
+  STACKTRACE;
   if (lock_level) {tw_error("VideoWindow - illegal while locked");}
   if (parent) {
     parent->remove_callback( this );

Modified: trunk/source/melee/mitems.cpp
===================================================================
--- trunk/source/melee/mitems.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mitems.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -30,6 +30,7 @@
 
 HealthBar::HealthBar(Ship *creator, int *toggle)
 {
+  STACKTRACE;
 	scale = 2.0;
 	bartoggle = toggle;
 	mother = creator;
@@ -37,7 +38,7 @@
 
 void HealthBar::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if ( !(mother && mother->exists()) )
 	{
@@ -50,7 +51,7 @@
 
 void HealthBar::draw_bar(Ship *s, double yoffs, int len, double H, double fraction, int col1, int col2, Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	Vector2 center;
 	int d;
@@ -86,7 +87,7 @@
 
 void HealthBar::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if (!*bartoggle)
 		return;
@@ -111,10 +112,12 @@
 
 
 
-Indicator::Indicator() : Presence() {STACKTRACE
+Indicator::Indicator() : Presence() {
+  STACKTRACE;
 	}
 
-bool Indicator::coords(Frame *space, SpaceLocation *l, Vector2 *pos, Vector2 *a_pos) {STACKTRACE
+bool Indicator::coords(Frame *space, SpaceLocation *l, Vector2 *pos, Vector2 *a_pos) {
+  STACKTRACE;
 	Vector2 p = corner(l->normal_pos());
 	Vector2 op = p;
 
@@ -145,12 +148,14 @@
 	return true;
 	}
 
-BlinkyIndicator::BlinkyIndicator(SpaceObject *target, int color) : Indicator() {STACKTRACE
+BlinkyIndicator::BlinkyIndicator(SpaceObject *target, int color) : Indicator() {
+  STACKTRACE;
 	this->target = target;
 	this->color = color;
 	}
 
 void BlinkyIndicator::animate(Frame *space) {
+  STACKTRACE;
 	if ((game->game_time >> 8) & 1) return;
 	Vector2 p;
 	int a = coords(space, target, &p);
@@ -175,17 +180,20 @@
 	}
 	return;
 	}
-void BlinkyIndicator::calculate() {STACKTRACE
+void BlinkyIndicator::calculate() {
+  STACKTRACE;
 	if (!target->exists()) die();
 	}
 
-WedgeIndicator::WedgeIndicator(SpaceLocation *target, int length, int color) : Indicator() {STACKTRACE
+WedgeIndicator::WedgeIndicator(SpaceLocation *target, int length, int color) : Indicator() {
+  STACKTRACE;
 	this->target = target;
 	this->length = length;
 	this->color = color;
 	}
 
 void WedgeIndicator::animate(Frame *space) {
+  STACKTRACE;
 	double a, a2;
 	Vector2 p, p2, tmp;
 	if (target->isInvisible() > 0.5) return;
@@ -207,6 +215,7 @@
 	return;
 	}
 void WedgeIndicator::calculate() {
+  STACKTRACE;
 	if (!target->exists()) die();
 	}
 
@@ -223,7 +232,8 @@
 	accelerate(this, angle + PI/2 + PI*(random()&1), 0.15, MAX_SPEED);
 	}
 
-void Orbiter::calculate() {STACKTRACE
+void Orbiter::calculate() {
+  STACKTRACE;
 	angle = trajectory_angle(center) + PI;
 	sprite_index = get_index(angle);
 	double r = distance(center) / radius;

Modified: trunk/source/melee/mlog.cpp
===================================================================
--- trunk/source/melee/mlog.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mlog.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -30,7 +30,8 @@
 //				Logging stuff
 ////////////////////////////////////////////////////////////////////////
 
-void Log::init() {STACKTRACE
+void Log::init() {
+  STACKTRACE;
 	log_len  = NULL;
 	log_size = NULL;
 	log_pos  = NULL;
@@ -93,7 +94,8 @@
 	if (log_dir[channel] & direction_read) _unlog ( channel, data, size);
 	return;
 }
-void Log::_log(int channel, const void *data, int size) {STACKTRACE
+void Log::_log(int channel, const void *data, int size) {
+  STACKTRACE;
 	log_len[channel] += size;
 	while (log_len[channel] > log_size[channel]) {
 		if (log_size[channel]) log_size[channel] = log_size[channel] * 2;
@@ -104,7 +106,7 @@
 	return;
 }
 void Log::_unlog(int channel, void *data, int size) {
-	STACKTRACE;
+  STACKTRACE;
 	if (log_len[channel] < log_pos[channel] + size) {tw_error ("Game::_unlog - went past end (%d+%d/%d on %d)", log_pos[channel], size, log_len[channel], channel);}
 	memcpy(data, log_data[channel]+log_pos[channel], size);
 	log_pos[channel] += size;
@@ -158,7 +160,7 @@
 	return;
 }
 void Log::expand_logs(int num_channels) {
-	STACKTRACE;
+  STACKTRACE;
 	int old_log_num = log_num;
 	if (num_channels <= log_num) { tw_error ("Log::expand_logs - shrinking logs?"); }
 	log_num = num_channels;
@@ -177,12 +179,13 @@
 	return;
 }
 int Log::ready(int channel) {
+  STACKTRACE;
 	if (channel < 0) { tw_error ("log_ready - negative channel!"); }
 	if (channel >= log_num) return 0;
 	return log_len[channel] - log_pos[channel];
 }
 int Log::file_ready(const char *fname, void **location) {
-	STACKTRACE;
+  STACKTRACE;
 	if (log_num <= channel_file_data) return -1;
 	int i = 0, j = 0;
 	while (i < log_len[channel_file_names]) {
@@ -208,6 +211,7 @@
 	return -1;
 }
 void Log::log_file(const char *fname) {
+  STACKTRACE;
 	void *loc;
 	if (!(log_dir[channel_file_data] & direction_read)) {
 		set_config_file(home_ini_full_path(fname).c_str());
@@ -250,7 +254,8 @@
 	return;
 }
 
-void Log::deinit() {STACKTRACE
+void Log::deinit() {
+  STACKTRACE;
 	return;
 }
 
@@ -296,14 +301,17 @@
 }
 
 void Log::flush() {
+  STACKTRACE;
 	return;
 }
 
 bool Log::listen() {
+  STACKTRACE;
 	return false;
 }
 
 void Log::reset() {
+  STACKTRACE;
 	int i;
 	for (i = 0 ; i < this->log_num; i += 1) {
 		log_pos[i] = 0;
@@ -313,7 +321,8 @@
 
 
 
-void PlaybackLog::init() {STACKTRACE
+void PlaybackLog::init() {
+  STACKTRACE;
 	Log::init();
 	playback = true;
 	default_direction = Log::direction_read;
@@ -329,7 +338,7 @@
 }
 
 void PlaybackLog::set_all_directions( char direction ) {
-	STACKTRACE;
+  STACKTRACE;
 	tw_error("set_all_directions - your not supposed to do that in a demo playback!");
 	return;
 }

Modified: trunk/source/melee/mmain.cpp
===================================================================
--- trunk/source/melee/mmain.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mmain.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -95,7 +95,8 @@
 	return i;
 	}
 
-void NormalGame::init_objects() {STACKTRACE
+void NormalGame::init_objects() {
+  STACKTRACE;
 	int i;
 	add(new Stars());
 	Planet *planet = create_planet();
@@ -106,7 +107,8 @@
 	for (i = 0; i < num_asteroids; i += 1) add(new Asteroid());
 	}
 
-void NormalGame::init_players() {STACKTRACE
+void NormalGame::init_players() {
+  STACKTRACE;
 	switch (log->type) {
 		case Log::log_normal: {
 			for (int i = 0; true; i += 1) {
@@ -195,6 +197,7 @@
 }
 
 void NormalGame::set_resolution(int screen_x, int screen_y) {
+  STACKTRACE;
 	int view_x, view_y;
 	view_x = screen_x;
 	view_y = screen_y;
@@ -208,6 +211,7 @@
 	}
 
 void NormalGame::preinit() {
+  STACKTRACE;
 	Game::preinit();
 	player_control = NULL;
 	player_name = NULL;
@@ -223,7 +227,8 @@
 	gameEnding = false;
 	gameEndingTime = DefaultEndingTime;
 	}
-void NormalGame::init(Log *_log) {STACKTRACE
+void NormalGame::init(Log *_log) {
+  STACKTRACE;
 	Game::init(_log);
 
 	team_table_size = 0;
@@ -281,7 +286,8 @@
 	}
 
 static int kill_all_delay_counter = 0;
-void NormalGame::calculate() {STACKTRACE
+void NormalGame::calculate() {
+  STACKTRACE;
 	Game::calculate();
 	if (next_choose_new_ships_time <= game_time) {
 		choose_new_ships();
@@ -317,7 +323,8 @@
 	return;
 	}
 
-void NormalGame::ship_died(Ship *who, SpaceLocation *source) {STACKTRACE
+void NormalGame::ship_died(Ship *who, SpaceLocation *source) {
+  STACKTRACE;
 	char victimName[80] = "";
 	char killerName[80] = "";
 	int victimID = -1;
@@ -379,7 +386,8 @@
 	return;
 	}
 
-void NormalGame::display_stats() {STACKTRACE
+void NormalGame::display_stats() {
+  STACKTRACE;
 	pause();
 	int i;
 	for (i = 0; i < num_players; i += 1) {
@@ -404,7 +412,7 @@
 }
 bool NormalGame::handle_key(int k)
 {
-	STACKTRACE;
+  STACKTRACE;
 	switch (k >> 8) {
 		default: {
 			return Game::handle_key(k);
@@ -456,6 +464,7 @@
 
 void NormalGame::choose_new_ships() 
 {
+  STACKTRACE;
   char tmp[40];
   int i;
   pause();
@@ -557,6 +566,7 @@
 
 bool NormalGame::isGameDone() 
 {
+  STACKTRACE;
   /*! we'll only check this every now and again, to avoid bogging down the engine.  */  
   enum { IterationsToSkip = 30 };
   static long iterationsToSkip = IterationsToSkip;
@@ -628,12 +638,14 @@
 // this should be places elsewhere I think ...
 TeamIndicator::TeamIndicator(Ship *s, int *atoggle)
 {
+  STACKTRACE;
 	indtoggle = atoggle;
 	mother = s;
 }
 
 void TeamIndicator::calculate()
 {
+  STACKTRACE;
 	if ( !(mother && mother->exists()) )
 	{
 		mother = 0;
@@ -643,6 +655,7 @@
 }
 
 void TeamIndicator::animate(Frame *space) {
+  STACKTRACE;
   if (!*indtoggle)
     return;
   
@@ -667,6 +680,7 @@
   
 }
 void NormalGame::showHelpText() {
+  STACKTRACE;
 	const char * file = data_full_path("ingame.txt").c_str();
 	char text[10000] = "";
 	char controlHelp[3000] = "";

Modified: trunk/source/melee/mnet1.cpp
===================================================================
--- trunk/source/melee/mnet1.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mnet1.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -33,7 +33,8 @@
 	size = sizeof(GameEvent) + l;
 	type = Game::event_message;
 }
-void GameEventMessage::execute( int source ) {STACKTRACE
+void GameEventMessage::execute( int source ) {
+  STACKTRACE;
 	char buffy[64+max_message_length];
 	char *tmp = buffy;
 	int c = 15;
@@ -47,7 +48,8 @@
 	::message.out(buffy, 6000, c);
 }
 
-void GameEventChangeLag::execute( int source ) {STACKTRACE
+void GameEventChangeLag::execute( int source ) {
+  STACKTRACE;
 	if (source != Game::channel_server) return;
 	if (old_lag != game->lag_frames) return;
 	int i;
@@ -111,39 +113,50 @@
 		}
 	}
 
-void NetLog::init() {STACKTRACE
+void NetLog::init() {
+  STACKTRACE;
 	}
-void NetLog::deinit() {STACKTRACE
+void NetLog::deinit() {
+  STACKTRACE;
 	}
 
 NetLog::~NetLog() {STACKTRACE
 	}
 
 void NetLog::send_packet() {
+  STACKTRACE;
 	}
 void NetLog::recv_packet() {
+  STACKTRACE;
 	}
 
 void NetLog::expand_logs(int num_channels) {
+  STACKTRACE;
 	return;
 	}
 
 void NetLog::_log(int channel, const void *data, int size) {
+  STACKTRACE;
 }
 void NetLog::_unlog(int channel, void *data, int size) {
+  STACKTRACE;
 	return;
 	}
 
 void NetLog::log_file(const char *fname) {
+  STACKTRACE;
 }
 
 void NetLog::flush() {
+  STACKTRACE;
 }
 
 bool NetLog::listen() {
+  STACKTRACE;
 return false;
 }
 
 int NetLog::ready(int channel) {
+  STACKTRACE;
 return 0;
 }

Modified: trunk/source/melee/mship.cpp
===================================================================
--- trunk/source/melee/mship.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mship.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -59,6 +59,7 @@
 }
 
 Ship *ShipClass::get_ship(Vector2 pos, double angle, ShipData *dat, unsigned int team) {
+  STACKTRACE;
 	dat->lock();
 	Ship *s = _get_ship(pos, angle, dat, team);
 	dat->unlock();
@@ -86,6 +87,7 @@
 
 
 Ship *ShipType::get_ship(Vector2 pos, double angle, unsigned int team) {
+  STACKTRACE;
 	game->log_file(file);
 	Ship *s = code->get_ship(pos, angle, data, team);
 	s->type = this;
@@ -244,6 +246,7 @@
 	target_pressed(false),
 	control(NULL)
 {
+  STACKTRACE;
   attributes |= ATTRIB_SHIP;
   layer = LAYER_SHIPS;
   set_depth(DEPTH_SHIPS);
@@ -284,6 +287,7 @@
   target_pressed(false),
   control(NULL)
 {
+  STACKTRACE;
   shipData->lock();
   attributes |= ATTRIB_SHIP;
   layer = LAYER_SHIPS;
@@ -376,6 +380,7 @@
 
 void Ship::death() 
 {
+  STACKTRACE;
   if (attributes & ATTRIB_NOTIFY_ON_DEATH) 
     {
       game->ship_died(this, NULL);
@@ -391,28 +396,33 @@
 
 double Ship::getCrew()
 {
+  STACKTRACE;
   return(crew);
 }
 
 double Ship::getBatt()
 {
+  STACKTRACE;
   return(batt);
 }
 
 RGB Ship::crewPanelColor(int k)
 {
+  STACKTRACE;
 	RGB c = {0,225,0};
 	return c;
 }
 
 RGB Ship::battPanelColor(int k)
 {
+  STACKTRACE;
   RGB c = {225,0,0};
   return c;
 }
 
 void Ship::locate() 
 {
+  STACKTRACE;
   int tries = 0;
   double mindist = 1000;
   while (tries < 15) {
@@ -430,6 +440,7 @@
 
 void Ship::calculate()
 {
+  STACKTRACE;
   
   //added by Tau - start
   if (exists() && death_counter >= 0) 
@@ -668,6 +679,7 @@
 
 int Ship::handle_fuel_sap(SpaceLocation *source, double normal) 
 {
+  STACKTRACE;
   if (death_counter >= 0) 
     return 0; //added by Tau
 
@@ -690,6 +702,7 @@
 
 double Ship::handle_speed_loss(SpaceLocation *source, double normal) 
 {
+  STACKTRACE;
   double speed_loss = normal;
   if(speed_loss > 0.0) 
     {
@@ -708,6 +721,7 @@
 
 int Ship::handle_damage(SpaceLocation *source, double normal, double direct) 
 {
+  STACKTRACE;
   if (death_counter >= 0) 
     return 0; //added by Tau
 
@@ -748,34 +762,40 @@
 }
 
 void Ship::materialize() {
+  STACKTRACE;
 }
 
 
 void Ship::assigntarget(SpaceObject *otarget)
 {
+  STACKTRACE;
 	target = otarget;
 }
 
 
-void Ship::calculate_thrust() {STACKTRACE
+void Ship::calculate_thrust() {
+  STACKTRACE;
 	if (thrust)
 		accelerate_gravwhip(this, angle, accel_rate * frame_time, speed_max);
 	return;
 }
 
 void Ship::calculate_turn_left()
-{STACKTRACE
+{
+  STACKTRACE;
   if(turn_left)
 		turn_step -= turn_rate * frame_time;
 }
 
 void Ship::calculate_turn_right()
-{STACKTRACE
+{
+  STACKTRACE;
   if(turn_right)
 		turn_step += turn_rate * frame_time;
 }
 
-void Ship::calculate_fire_weapon() {STACKTRACE
+void Ship::calculate_fire_weapon() {
+  STACKTRACE;
 	weapon_low = FALSE;
 
 	if (fire_weapon) {
@@ -806,6 +826,7 @@
 
 void Ship::calculate_fire_special()
 {
+  STACKTRACE;
   special_low = FALSE;
 
   if(fire_special) {
@@ -833,6 +854,7 @@
 
 void Ship::calculate_hotspots() 
 {
+  STACKTRACE;
   if((thrust) && (hotspot_frame <= 0)) 
     {
       game->add(new Animation(this,
@@ -847,15 +869,18 @@
 
 int Ship::activate_weapon()
 {
+  STACKTRACE;
   return(TRUE);
 }
 
 int Ship::activate_special()
 {
+  STACKTRACE;
   return(TRUE);
 }
 
 void Ship::animate(Frame *frame) {
+  STACKTRACE;
 	SpaceObject::animate(frame);
 }
 
@@ -866,6 +891,7 @@
 
 ShipType *Ship::get_shiptype()
 {
+  STACKTRACE;
 	return type;
 }
 
@@ -886,7 +912,8 @@
 	phaser_step_position(0),
 	phaser_steps(steps),
 	phaser_step_size(step_size)
-{STACKTRACE
+{
+  STACKTRACE;
 	layer = LAYER_HOTSPOTS;
 	set_depth(DEPTH_HOTSPOTS);
 	collide_flag_anyone = 0;
@@ -903,12 +930,14 @@
 }
 
 void Phaser::animate(Frame *space) {
+  STACKTRACE;
 	sprite->animate_character(pos, 
 		sprite_index, pallete_color[colors[color_index]], space);
 	return;
 }
 
-void Phaser::calculate() {STACKTRACE
+void Phaser::calculate() {
+  STACKTRACE;
 	if (!exists())
 		return;
 	frame_step -= frame_time;
@@ -939,7 +968,8 @@
 	SpaceObject::calculate();
 }
 
-SpaceLocation *Ship::get_ship_phaser() {STACKTRACE
+SpaceLocation *Ship::get_ship_phaser() {
+  STACKTRACE;
 	return new Phaser(this,
 		pos - unit_vector(angle ) * PHASE_MAX * size.x,
 		unit_vector(angle ) * PHASE_MAX * size.x,

Modified: trunk/source/melee/mshot.cpp
===================================================================
--- trunk/source/melee/mshot.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mshot.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -42,6 +42,7 @@
   explosionFrameCount(SPARK_FRAMES),
   explosionFrameSize(scale_frames(0))
 {
+  STACKTRACE;
 	layer = LAYER_SHOTS;
 	set_depth(DEPTH_SHOTS);
 	attributes |= ATTRIB_SHOT;
@@ -62,6 +63,7 @@
 }
 
 void Shot::calculate() {
+  STACKTRACE;
 	SpaceObject::calculate();
 
 	if (!(ship && ship->exists()))
@@ -76,11 +78,13 @@
 }
 
 void Shot::animate(Frame *space) {
+  STACKTRACE;
   SpaceObject::animate(space);
   return;
 }
 
 int Shot::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	if (!exists()) return 0;
 	if ((normal > 0) || (direct > 0)) {
 		armour -= normal;
@@ -97,6 +101,7 @@
 }
 
 void Shot::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if (!other->exists()) return;
 	damage(other, damage_factor);
 	//if (!other->isShot()) state = 0;
@@ -109,9 +114,11 @@
 }
 
 void Shot::death() {
+  STACKTRACE;
 }
 
 void Shot::animateExplosion() {
+  STACKTRACE;
 	game->add(new Animation(this, normal_pos(),
 			explosionSprite, 0, explosionFrameCount,
 			explosionFrameSize, DEPTH_EXPLOSIONS));
@@ -120,6 +127,7 @@
 
 void Shot::soundExplosion() 
 {
+  STACKTRACE;
   if(!explosionSample.empty()) 
     {
       tw_sound.play_sound(data_full_path(explosionSample));
@@ -155,11 +163,13 @@
 }
 
 void Shot::stop() {
+  STACKTRACE;
 	vel = Vector2(0,0);
 	return;
 }
 
 void Shot::destroy() {
+  STACKTRACE;
 	state = 0;
 	return;
 }
@@ -174,6 +184,7 @@
 }
 
 int Shot::isHomingMissile() {
+  STACKTRACE;
 	return ((id & BASE_MASK3) == SPACE_HOMING_MISSILE);
 }
 
@@ -186,9 +197,11 @@
 	frame_size(ofsize),
 	frame_step(ofsize)
 {
+  STACKTRACE;
 }
 
 void AnimatedShot::calculate() {
+  STACKTRACE;
 	Shot::calculate();
 	frame_step -= frame_time;
 	while (frame_step < 0) {
@@ -205,6 +218,7 @@
 :
 	Shot(creator, rpos, oangle, ov, odamage, orange, oarmour, opos, osprite, relativity)
 {
+  STACKTRACE;
 	sprite_index = get_index(angle);
 }
 
@@ -222,11 +236,13 @@
 	turn_rate(otrate),
 	turn_step(0.0)
 {
+  STACKTRACE;
 	target = otarget;
 	id = SPACE_HOMING_MISSILE;
 }
 
 void HomingMissile::calculate() {
+  STACKTRACE;
 	Missile::calculate();
 	if (target && !target->isInvisible()) {
 		double d_a = normalize(trajectory_angle(target) - (angle + turn_step), PI2);
@@ -256,6 +272,7 @@
 }
 
 void HomingMissile::animate(Frame *space) {
+  STACKTRACE;
 	int old_sprite_index = sprite_index;
 	Vector2 old_vel = vel;
 
@@ -292,6 +309,7 @@
   rel_pos(rpos),
   sinc_angle(osinc_angle)
 {
+  STACKTRACE;
 
 // angle conventions fucked up??
 	rel_pos.x *= -1;
@@ -319,6 +337,7 @@
 
 
 void Laser::calculate() {
+  STACKTRACE;
 	if((frame < frame_count) && (lpos->exists())) {
 		pos = lpos->normal_pos() + rotate(rel_pos, lpos->get_angle() - PI/2);
 		vel = lpos->get_vel();
@@ -335,6 +354,7 @@
   Laser(creator, lsource->trajectory_angle(ltarget), lcolor, lsource->distance(ltarget), ldamage, lfcount, lsource, rel_pos),
   target(ltarget)
 {
+  STACKTRACE;
 	collide_flag_anyone = bit(target->layer);
 	collide_flag_sameteam = bit(target->layer);
 	collide_flag_sameship = bit(target->layer);
@@ -346,11 +366,13 @@
 }
 
 int PointLaser::canCollide(SpaceObject *other) {
+  STACKTRACE;
 	if (other != target) return false;
 	return Laser::canCollide(other);
 }
 
 void PointLaser::calculate() {
+  STACKTRACE;
 	double alpha;
 	alpha = (lpos->get_angle());
 	Laser::calculate();

Modified: trunk/source/melee/mshpdata.cpp
===================================================================
--- trunk/source/melee/mshpdata.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mshpdata.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -122,6 +122,7 @@
 
 void ShipData::lock() 
 {
+  STACKTRACE;
   if (references == 0) 
     {
       push_config_state();//can screw up badly if an error occurs while loading...
@@ -133,6 +134,7 @@
 
 void ShipData::unlock() 
 {
+  STACKTRACE;
   references -= 1;
   if ((references == 0) && auto_unload) 
     {
@@ -142,6 +144,7 @@
 
 void ShipData::unload() 
 {
+  STACKTRACE;
   if (status != LOADED_FULL) 
     return;
 
@@ -205,6 +208,7 @@
   spriteExtra(NULL),
   spriteExtraExplosion(NULL)
 {
+  STACKTRACE;
   file = filename;
   ini  = inifile;
   references = 0;
@@ -250,6 +254,7 @@
 
 void ShipData::load() 
 {
+  STACKTRACE;
   int i, index = 0, count;
   
   if (status != LOADED_NONE) 

Modified: trunk/source/melee/mshppan.cpp
===================================================================
--- trunk/source/melee/mshppan.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mshppan.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -37,7 +37,8 @@
 int batt_y = 53;
 
 
-ShipPanel::ShipPanel(Ship *_ship) {STACKTRACE
+ShipPanel::ShipPanel(Ship *_ship) {
+  STACKTRACE;
 	id |= ID_SHIP_PANEL;
 
 	panel   = create_bitmap(64, 100);
@@ -80,13 +81,15 @@
   delete window;
 }
 
-void ShipPanel::refresh() {STACKTRACE
+void ShipPanel::refresh() {
+  STACKTRACE;
 	panel_needs_update = 1;
 	captain_needs_update = 1;
 	return;
 	}
 
-void ShipPanel::calculate() {STACKTRACE
+void ShipPanel::calculate() {
+  STACKTRACE;
 	if (!ship) {
 		deathframe -= frame_time;
 		if (deathframe <= 0) this->die();
@@ -115,7 +118,7 @@
 	}
 
 void ShipPanel::animate(Frame *space) {
-	STACKTRACE;
+  STACKTRACE;
 
 	BITMAP *screen = window->surface;
 	if (!screen) return;

Modified: trunk/source/melee/msprite.cpp
===================================================================
--- trunk/source/melee/msprite.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/msprite.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -607,6 +607,7 @@
 
 SpaceSprite::SpaceSprite(SpaceSprite &old) 
 {
+  STACKTRACE;
   int i, l;
   BITMAP *bmp;
   count = old.count;
@@ -804,12 +805,14 @@
 
 void SpaceSprite::lock() 
 {
+  STACKTRACE;
   highest_mip = 0;
   return;
 }
 
 void SpaceSprite::unlock() 
 {
+  STACKTRACE;
   int i, j;
   for (i = 0; i < MAX_MIP_LEVELS; i += 1) 
     {
@@ -849,6 +852,7 @@
 
 BITMAP *SpaceSprite::get_bitmap(int index, int miplevel)
 {
+  STACKTRACE;
   if (general_attributes & MIPMAPED) 
     if (miplevel > highest_mip) 
       {tw_error ("get_bitmap on undefined mipmap level");}
@@ -859,6 +863,7 @@
 
 BITMAP *SpaceSprite::get_bitmap_readonly(int index)
 {
+  STACKTRACE;
   if (index >= count) 
     {
       tw_error("SpaceSprite::get_bitmap_readonly - index %d >= count %d", index, count); index = 0;
@@ -872,6 +877,7 @@
 
 void SpaceSprite::animate_character(Vector2 pos, int index, int color, Frame *space, double scale) 
 {
+  STACKTRACE;
   if (index >= count) 
     {
       tw_error("SpaceSprite::animate_character - index %d >= count %d", index, count);
@@ -959,6 +965,7 @@
 
 void SpaceSprite::draw(Vector2 pos, Vector2 size, int index, BITMAP *surface) 
 {
+  STACKTRACE;
   if (index >= count) 
     {
       tw_error("SpaceSprite::draw - index %d > count %d", index, count); index = 0;
@@ -989,6 +996,7 @@
 
 void SpaceSprite::draw(Vector2 pos, Vector2 size, int index, Frame *frame) 
 {
+  STACKTRACE;
   if (index >= count) 
     {
       tw_error("SpaceSprite::draw - index %d > count %d", index, count); index = 0;
@@ -1034,12 +1042,14 @@
 
 void SpaceSprite::draw(int x, int y, int index, BITMAP *surface) 
 {
+  STACKTRACE;
   draw(Vector2(x,y), Vector2(b[0][index]->w, b[0][index]->h), index, surface);
   return;
 }
 
 void SpaceSprite::animate(Vector2 pos, int index, Frame *space, double scale) 
 {
+  STACKTRACE;
   if (index >= count) 
     {
       tw_error("SpaceSprite::animate - index %d >= count %d", index, count);
@@ -1057,6 +1067,7 @@
 
 void SpaceSprite::draw_character(int x, int y, int index, int color, BITMAP *bmp) 
 {
+  STACKTRACE;
   if (index >= count) 
     {
       tw_error("SpaceSprite::draw_character - index %d >= count %d", index, count); index = 0;
@@ -1071,18 +1082,21 @@
 
 void SpaceSprite::draw_character(int x, int y, int index, int color, Frame *space) 
 {
+  STACKTRACE;
   draw_character(x, y, index, color, space->surface);
   space->add_box(x, y, w, h);
 }
 
 void SpaceSprite::draw_character(int x, int y, int w, int h, int index, int color, Frame *space) 
 {
+  STACKTRACE;
   draw_character(x, y, w, h, index, color, space->surface);
   space->add_box(x, y, w, h);
 }
 
 void SpaceSprite::draw_character(int x, int y, int w, int h, int index, int color, BITMAP *bmp) 
 {
+  STACKTRACE;
   if (index >= count) 
     {
       tw_error("SpaceSprite::draw_character_stretch - index %d >= count %d", index, count); index = 0;
@@ -1098,6 +1112,7 @@
 int SpaceSprite::collide(int x, int y, int i, int ox, int oy, int oi,
 			 SpaceSprite *other)
 {
+  STACKTRACE;
   if (i >= count) 
     { 
       tw_error("SpaceSprite::collide - index1 %d >= count1 %d", i, count); 
@@ -1152,6 +1167,7 @@
 int SpaceSprite::collide_ray(int lx1, int ly1, int *lx2, int *ly2,
   int sx, int sy, int sindex)
 {
+  STACKTRACE;
   line_collide = FALSE;
   rect_x = sx - (w / 2);
   rect_y = sy - (h / 2);

Modified: trunk/source/melee/mtarget.cpp
===================================================================
--- trunk/source/melee/mtarget.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mtarget.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -24,6 +24,7 @@
 
 Targets::Targets()
 {
+  STACKTRACE;
 	N = 0;
 	item = 0;
 }
@@ -36,6 +37,7 @@
 
 void Targets::reset()
 {
+  STACKTRACE;
 	if (item)
 		free(item);
 	item = 0;
@@ -43,7 +45,8 @@
 }
 
 
-void Targets::add(SpaceObject *a) {STACKTRACE
+void Targets::add(SpaceObject *a) {
+  STACKTRACE;
 	N += 1;
 	item = (SpaceObject **) realloc(item, sizeof(SpaceObject *) * N);
 	item[N - 1] = a;
@@ -53,6 +56,7 @@
 
 void Targets::rem(int i)
 {
+  STACKTRACE;
 	-- N;
 	item[i]->attributes &= ~ATTRIB_TARGET;
 	item[i] = item[N];
@@ -61,6 +65,7 @@
 
 void Targets::rem(SpaceObject *r)
 {
+  STACKTRACE;
 	int i;
 	for ( i = 0; i < N; ++i )
 		if (item[i] == r)
@@ -76,6 +81,7 @@
 
 void Targets::calculate()
 {
+  STACKTRACE;
 	int i;
 	
 	for (i = 0; i < N; i += 1)
@@ -93,6 +99,7 @@
 
 int Targets::findindex(SpaceObject *o)
 {
+  STACKTRACE;
 	int i;
 
 	for (i = 0; i < N; i += 1)
@@ -109,5 +116,6 @@
 
 bool Targets::isintargetlist(SpaceObject *o)
 {
+  STACKTRACE;
 	return findindex(o) >= 0;
 }

Modified: trunk/source/melee/mview.cpp
===================================================================
--- trunk/source/melee/mview.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mview.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -58,7 +58,8 @@
 
 
 
-View * ViewType::create( View * old ) {STACKTRACE
+View * ViewType::create( View * old ) {
+  STACKTRACE;
 	View * r = _create();
 	r->preinit();
 	r->type = this;
@@ -111,7 +112,8 @@
 
 
 
-void View::preinit() {STACKTRACE
+void View::preinit() {
+  STACKTRACE;
 	frame = NULL;
 	window = NULL;
 	type = NULL;
@@ -152,7 +154,8 @@
 }
 
 
-void View::animate(Game *game) {STACKTRACE
+void View::animate(Game *game) {
+  STACKTRACE;
 	if (FULL_REDRAW) frame->full_redraw = true;
 	frame->erase();
 	prepare(frame, 0);
@@ -168,11 +171,12 @@
 	return;
 	}
 
-void View::config() {STACKTRACE
+void View::config() {
+  STACKTRACE;
 	return;
 	}
 bool View::screen2game(Vector2 *_pos) {
-	STACKTRACE
+  STACKTRACE;
 	Vector2 pos = *_pos;
 	Vector2 opos = pos;
 
@@ -192,7 +196,7 @@
 	return true;
 	}
 double View::in_view(Vector2 pos, Vector2 size) {
-	STACKTRACE
+  STACKTRACE;
 	pos = corner(pos, size);
 	size = size * space_zoom;
 
@@ -211,7 +215,7 @@
 	return a * b / (size.x * size.y);
 }
 int View::focus(CameraPosition *pos, SpaceLocation *la, SpaceLocation *lb) {
-	STACKTRACE
+  STACKTRACE;
 	if (!la && !lb) return 0;
 	if (!la) la = lb;
 	if (!lb) lb = la;
@@ -241,6 +245,7 @@
 }
 
 /*void View::see_also(SpaceLocation *o) {
+  STACKTRACE;
 	if (!o) return;
 	double x2, y2;
 	x2 = b->normal_x();
@@ -316,7 +321,8 @@
 	return;
 }
 
-void View::init(View *old) {STACKTRACE
+void View::init(View *old) {
+  STACKTRACE;
 	if (window || frame) {
 		tw_error("View::init - hmm...");
 	}
@@ -372,9 +378,11 @@
 		delete frame;
 	}
 }
-void View::calculate(Game *game) {}
+void View::calculate(Game *game) {
+  STACKTRACE;}
 
-void message_type::out(char *string, int dur, int c) {STACKTRACE
+void message_type::out(char *string, int dur, int c) {
+  STACKTRACE;
 	ASSERT (c < 256);
 	if (num_messages == max_messages - 1) {
 		messages[0].end_time = -1;
@@ -390,7 +398,8 @@
 	clean();
 	return;
 	}
-void message_type::print(int dur, int c, const char *format, ...) {STACKTRACE
+void message_type::print(int dur, int c, const char *format, ...) {
+  STACKTRACE;
 	char buf[1024];
 	va_list those_dots;
 	va_start (those_dots, format);
@@ -407,7 +416,8 @@
 	out(buf, dur, c);
 	return;
 	}
-void message_type::clean() {STACKTRACE
+void message_type::clean() {
+  STACKTRACE;
 	int kill_time;
 	if (game) kill_time = game->game_time;
 	else kill_time = 0;
@@ -421,7 +431,8 @@
 		}
 	return;
 	}
-void message_type::flush() {STACKTRACE
+void message_type::flush() {
+  STACKTRACE;
 	for (int i = 0; i < num_messages; i += 1) {
 		if (messages[i].string)
 			free (messages[i].string);
@@ -430,7 +441,8 @@
 	return;
 	}
 
-void message_type::animate(Frame *frame) {STACKTRACE
+void message_type::animate(Frame *frame) {
+  STACKTRACE;
 
 	if (num_messages <= 0)
 		return;
@@ -462,7 +474,8 @@
 	}
 message_type message;
 
-void View::_event( Event *e ) {STACKTRACE
+void View::_event( Event *e ) {
+  STACKTRACE;
 	if ( e->type == Event::VIDEO ) {
 		const VideoEvent *ve = (const VideoEvent*) e;
 		const VideoWindow *w = ve->window;
@@ -502,7 +515,8 @@
 	virtual void init(View *old);
 	//virtual void set_window (BITMAP *dest, int x, int y, int w, int h);
 	};
-void View_Hero::init(View *old) {STACKTRACE
+void View_Hero::init(View *old) {
+  STACKTRACE;
 	View::init(old);
 	f = 0;
 	min = 30;//480;
@@ -609,7 +623,8 @@
 	virtual void animate(Game *game);
 	virtual ~View_Split2a();
 	};
-void View_Split2a::init(View *old) {STACKTRACE
+void View_Split2a::init(View *old) {
+  STACKTRACE;
 	View::init(old);
 
 	min = 480;
@@ -707,7 +722,8 @@
 	virtual void animate(Game *game);
 	virtual ~View_Split2b();
 	};
-void View_Split2b::init(View *old) {STACKTRACE
+void View_Split2b::init(View *old) {
+  STACKTRACE;
 	View::init(old);
 
 	min = 480;
@@ -807,7 +823,8 @@
 	virtual void animate(Game *game);
 	virtual ~View_Split3();
 	};
-void View_Split3::init(View *old) {STACKTRACE
+void View_Split3::init(View *old) {
+  STACKTRACE;
 	View::init(old);
 
 	min = 480;
@@ -828,7 +845,8 @@
 		delete frames[i];
 	}
 }
-void View_Split3::animate(Game *game) {STACKTRACE
+void View_Split3::animate(Game *game) {
+  STACKTRACE;
 	VideoWindow *tmpw;
 	Frame *tmpf;
 	CameraPosition tmpc;
@@ -906,7 +924,8 @@
 	virtual void animate(Game *game);
 	virtual ~View_Split4();
 	};
-void View_Split4::init(View *old) {STACKTRACE
+void View_Split4::init(View *old) {
+  STACKTRACE;
 	View::init(old);
 
 	min = 480;
@@ -928,7 +947,8 @@
 		delete frames[i];
 	}
 }
-void View_Split4::animate(Game *game) {STACKTRACE
+void View_Split4::animate(Game *game) {
+  STACKTRACE;
 	VideoWindow *tmpw;
 	Frame *tmpf;
 	CameraPosition tmpc;

Modified: trunk/source/other/nullphas.cpp
===================================================================
--- trunk/source/other/nullphas.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/other/nullphas.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -24,11 +24,13 @@
   oship->size, unit_vector( oship->get_angle()) * PHASE_MAX * oship->size,
   oship, oship->get_sprite(), oship->get_sprite_index(), hot_color, HOT_COLORS,
   PHASE_DELAY, PHASE_MAX, PHASE_DELAY ){
+  STACKTRACE;
 }
 
-void NullPhaser::animate( Frame* space ){}
+void NullPhaser::animate( Frame* space ){
+  STACKTRACE;}
 void NullPhaser::calculate(){
-	STACKTRACE
+  STACKTRACE;
 
   if( state > 0 ){
     game->add( ship );

Modified: trunk/source/other/objanim.cpp
===================================================================
--- trunk/source/other/objanim.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/other/objanim.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -25,6 +25,7 @@
 Animation( creator, opos, osprite, first_frame, num_frames, frame_size, depth ),
   angle(oangle)
 {
+  STACKTRACE;
   vel = ovel;
 
   sprite_index = get_index(angle);
@@ -32,7 +33,7 @@
 }
 
 void ObjectAnimation::calculate(){
-	STACKTRACE
+  STACKTRACE;
 
   sprite_index >>= 6;
   Animation::calculate();

Modified: trunk/source/other/orbit.cpp
===================================================================
--- trunk/source/other/orbit.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/other/orbit.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -45,7 +45,7 @@
 
 int SpaceStation::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	Crew-=(int)(normal+direct);
 	if(Crew<=0) state=0;
@@ -54,7 +54,7 @@
 
 void SpaceStation::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	//Healing beam code
 
@@ -74,6 +74,7 @@
 SpaceStation::SpaceStation(SpaceLocation *creator, Vector2 opos,
 	SpaceSprite *oSprite):SpaceObject(creator,opos,0.,oSprite)
 {
+  STACKTRACE;
 //	layer=LAYER_SPECIAL;
 	mass=10.;
 	Crew=2000;
@@ -86,6 +87,7 @@
 	double lrad, double lspeed, int iLock):SpaceLocation(creator,
 	lpos, 0.)
 {
+  STACKTRACE;
 	id=ORBIT_ID;
 	ipos=lpos;
 	Lock=iLock;
@@ -103,7 +105,7 @@
 
 void OrbitHandler::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if((sun==NULL)||(plan==NULL))
 		return;
@@ -142,6 +144,7 @@
 
 int OrbitHandler::canCollide(SpaceLocation *other)
 {
+  STACKTRACE;
 	return FALSE;
 }
 
@@ -149,6 +152,7 @@
 	:
 	SpaceObject(NULL, opos, 0.0, sprite)
 	{
+  STACKTRACE;
 
 	layer = LAYER_SHOTS;
 	set_depth(LAYER_EXPLOSIONS);
@@ -175,7 +179,7 @@
 
 int Sun::canCollide(SpaceLocation *other)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if(other->id==COMET_ID) return FALSE;
 	return(!other->isPlanet());
@@ -183,7 +187,7 @@
 
 void Sun::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	double d = distance(other);
 	if (d >= Range) return;
@@ -195,7 +199,7 @@
 }
 
 void Sun::calculate() {
-	STACKTRACE
+  STACKTRACE;
 
 	SpaceObject::calculate();
 	SpaceObject *o;

Modified: trunk/source/other/planet3d.cpp
===================================================================
--- trunk/source/other/planet3d.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/other/planet3d.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -30,6 +30,7 @@
 
 SpaceSprite::SpaceSprite(BITMAP *image, int _attributes)
 {
+  STACKTRACE;
   if (_attributes == -1) 
     _attributes = string_to_sprite_attributes(NULL);
   general_attributes = _attributes;

Modified: trunk/source/other/radar.cpp
===================================================================
--- trunk/source/other/radar.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/other/radar.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -32,16 +32,19 @@
 
 void ZRadar::toggleActive()
 {
+  STACKTRACE;
 	active^=1;
 }
 
 void ZRadar::setSize(double Size)
 {
+  STACKTRACE;
 	size=Size;
 }
 
 void ZRadar::setTarget(SpaceLocation *target)
 {
+  STACKTRACE;
 	t=target;
 }
 
@@ -52,6 +55,7 @@
 
 ZRadar::ZRadar(BITMAP *BlankSlate, Presence *target, double Size)
 {
+  STACKTRACE;
 	Blank=BlankSlate;
 	Painted = create_bitmap_ex(bitmap_color_depth(screen),Blank->w,Blank->h);
 	t=target;
@@ -62,13 +66,14 @@
 
 double ZRadar::shiftscale(double r_center, double v_center, double scale, double n)
 {
+  STACKTRACE;
 	//Used to scale game coordinates onto RADAR screen coordinates
 	return(((n - r_center)*scale)+v_center);
 }
 
 void ZRadar::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	//If the radar is disabled, don't do anything.
 	if(active==FALSE) return;

Modified: trunk/source/other/shippart.cpp
===================================================================
--- trunk/source/other/shippart.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/other/shippart.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -33,6 +33,7 @@
 :
 Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 	// remove this from the physics interaction
 	//mass = 0;
 	collide_flag_anyone = 0;
@@ -45,7 +46,7 @@
 
 void BigShip::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	// make sure the "ship" is not a real target
 	if (targets->isintargetlist(this))
@@ -70,7 +71,7 @@
 // change velocities of the ship and all its parts
 void BigShip::change_vel(Vector2 dvel)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	int i;
 
@@ -88,7 +89,7 @@
 // change positions of the ship and all its parts
 void BigShip::change_pos(Vector2 dpos)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	int i;
 
@@ -106,6 +107,7 @@
 
 void BigShip::animate(Frame *space)
 {
+  STACKTRACE;
 	return;
 }
 
@@ -120,6 +122,7 @@
 :
 Ship(aowner, 0, 0, spr)
 {
+  STACKTRACE;
 	owner = aowner;
 	relpos = orelpos;
 	relangle = orelangle;
@@ -164,7 +167,7 @@
 
 void BigShipPart::syncpos()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	// maintain (relative) position wrt the ship
 	angle = owner->angle + relangle;	// this is the discrete angle (64 values).
@@ -186,7 +189,7 @@
 
 void BigShipPart::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if ( !(owner && owner->exists()) )
 	{
@@ -232,7 +235,7 @@
 
 int BigShipPart::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	// by default, transmit damage to the ship owner ...
 	return owner->handle_damage(source, normal, direct);
@@ -242,7 +245,7 @@
 
 void BigShipPart::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	Ship::inflict_damage(other);
 
@@ -254,6 +257,7 @@
 
 bool BigShipPart::isdisabled()
 {
+  STACKTRACE;
 	return false;
 }
 
@@ -262,7 +266,7 @@
 // change velocities of the ship and all its parts
 void BigShipPart::change_vel(Vector2 dvel)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	owner->change_vel(dvel);
 }
@@ -270,7 +274,7 @@
 // change positions of the ship and all its parts
 void BigShipPart::change_pos(Vector2 dpos)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	owner->change_pos(dpos);
 }
@@ -282,6 +286,7 @@
 :
 SpaceObject(aownerpart, aownerpart->pos, aownerpart->angle, ospr)
 {
+  STACKTRACE;
 	ownerpart = aownerpart;
 
 	layer = LAYER_SHIPS;
@@ -300,7 +305,7 @@
 
 void BigShipPartDevice::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if ( !(ownerpart && ownerpart->exists()) )
 	{
@@ -322,7 +327,7 @@
 
 void BigShipPartDevice::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if (ownerpart->isdisabled())
 		return;
@@ -334,7 +339,7 @@
 
 int BigShipPart::handle_fuel_sap(SpaceLocation *source, double normal)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	return owner->handle_fuel_sap(source, normal);
 }
@@ -343,6 +348,7 @@
 
 ShipType *BigShipPart::get_shiptype()
 {
+  STACKTRACE;
 	// this is necessary, otherwise the Kat Poly ship crashes.
 	// also, "type" cannot be redirected inside the constructor, cause the
 	// parents' type is declared outside of its constructor (bad?).

Modified: trunk/source/other/vbodies.cpp
===================================================================
--- trunk/source/other/vbodies.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/other/vbodies.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -208,15 +208,18 @@
 
 VSpaceInstallation::VSpaceInstallation():SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite)
 {
+  STACKTRACE;
 	collide_flag_sameteam = ALL_LAYERS;
 	collide_flag_sameship = ALL_LAYERS;
 	layer = LAYER_CBODIES;
 	set_depth(DEPTH_ASTEROIDS);
 }
 
-void VSpaceInstallation::Initialize(void) {;}
+void VSpaceInstallation::Initialize(void) {
+  STACKTRACE;;}
 
 void VSpaceInstallation::Initialize(const char* nameInIni) {
+  STACKTRACE;
 	game->log_file ("vobject.ini");
   this->armour = get_config_float(nameInIni, "Armour", 0);
   this->mass = get_config_float(nameInIni, "Mass", 0);
@@ -224,6 +227,7 @@
 }
 
 bool VSpaceInstallation::AddInstallation(VGroundInstallation* oGI) {
+  STACKTRACE;
   int i;
   for(i=0;i<12;i++) {
     if(this->Installation[i]==NULL) {
@@ -237,10 +241,12 @@
 }
 
 void VSpaceInstallation::calculate(void) {
+  STACKTRACE;
 	this->vel *= (1 - this->friction * game->frame_time);
 }
 
 void VSpaceInstallation::death() {
+  STACKTRACE;
   int i;
   for(i=0;i<12;i++)
     if(this->Installation[i]!=NULL)
@@ -248,6 +254,7 @@
 }
 
 int VSpaceInstallation::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   message.print(500,5,"Installation armour=%d", (long int)armour);
   if(source->isAsteroid()) return(0);
   armour -= (normal + direct);
@@ -257,45 +264,54 @@
 
 
 VDefSat::VDefSat() {
+  STACKTRACE;
   this->set_sprite(VDefSat::mySprite);
   this->Initialize();
 }
 
 void VDefSat::Initialize(void) {
+  STACKTRACE;
   VSpaceInstallation::Initialize("DefSat");
 }
 
 VDeepSpaceOutpost::VDeepSpaceOutpost() {
+  STACKTRACE;
   this->set_sprite(VDeepSpaceOutpost::mySprite);
   this->Initialize();
 }
 
 void VDeepSpaceOutpost::Initialize() {
+  STACKTRACE;
   VSpaceInstallation::Initialize("DeepSpaceOutpost");
 
 }
 
 VDeepSpaceColony::VDeepSpaceColony() {
+  STACKTRACE;
   this->set_sprite(VDeepSpaceColony::mySprite);
   this->Initialize();
 }
 
 void VDeepSpaceColony::Initialize() {
+  STACKTRACE;
   VSpaceInstallation::Initialize("DeepSpaceColony");
 }
 
 VDeepSpaceStation::VDeepSpaceStation() {
+  STACKTRACE;
   this->set_sprite(VDeepSpaceStation::mySprite);
   this->Initialize();
 }
 
 void VDeepSpaceStation::Initialize() {
+  STACKTRACE;
   VSpaceInstallation::Initialize("DeepSpaceStation");
 }
 
 
 VGroundInstallation::VGroundInstallation(SpaceLocation* olocation):Presence()
 {
+  STACKTRACE;
   this->totalDamageTaken = 0;
   this->location = olocation;
   actionCounter = 0;
@@ -308,11 +324,13 @@
 
 void VGroundInstallation::Initialize(void)
 {
+  STACKTRACE;
   ;
 }
 
 void VGroundInstallation::Initialize(const char* nameInIni)
 {
+  STACKTRACE;
 	game->log_file ("vobject.ini");
   this->damageToDisable = get_config_float(nameInIni, "DamageToDisable", 0);
   this->damageToDestroy = get_config_float(nameInIni, "DamageToDestroy", 0);
@@ -322,6 +340,7 @@
 
 int VGroundInstallation::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   if(source->isPlanet()||source->isAsteroid()) return(0);
   this->totalDamageTaken += (normal + direct);
   message.print(350,5,"DamageTaken=%d", (long int)this->totalDamageTaken);
@@ -342,6 +361,7 @@
 
 void VGroundInstallation::calculate(void)
 {
+  STACKTRACE;
   if(!this->isFunctioning)return;
   Presence::calculate();
   actionCounter += ((double)frame_time / 1000.0) * this->actionsPerSecond;
@@ -355,47 +375,57 @@
 
 bool VGroundInstallation::BattleAction(void)
 {
+  STACKTRACE;
   return(false);
 }
 
 VWilderness::VWilderness(SpaceLocation* olocation):VGroundInstallation(olocation) {
+  STACKTRACE;
   this->Initialize();
 }
 
 void VWilderness::Initialize(void)
 {
+  STACKTRACE;
   VGroundInstallation::Initialize("Wilderness");
 }
 
 
 VColony::VColony(SpaceLocation* olocation):VGroundInstallation(olocation) {
+  STACKTRACE;
   this->Initialize();
 }
 
 void VColony::Initialize(void)
 {
+  STACKTRACE;
   VGroundInstallation::Initialize("Colony");
 }
 
 VMine::VMine(SpaceLocation* olocation):VGroundInstallation(olocation) {
+  STACKTRACE;
   this->Initialize();
 }
 
 void VMine::Initialize(void)
 {
+  STACKTRACE;
   VGroundInstallation::Initialize("Mine");
 }
 
 VFortification::VFortification(SpaceLocation* olocation):VGroundInstallation(olocation) {
+  STACKTRACE;
   this->Initialize();
 }
 
 void VFortification::Initialize(void)
 {
+  STACKTRACE;
   VGroundInstallation::Initialize("Fortification");
 }
 
 VPlanetaryShield::VPlanetaryShield(SpaceLocation* olocation):VGroundInstallation(olocation) {
+  STACKTRACE;
   this->Initialize();
   this->isFunctioning = true;
   this->isDestroyed = false;
@@ -405,6 +435,7 @@
 
 void VPlanetaryShield::Initialize(void)
 {
+  STACKTRACE;
   VGroundInstallation::Initialize("PlanetaryShield");
   this->maxShield = get_config_float("PlanetaryShield", "Shield", 0);
   this->currentShield = maxShield;
@@ -412,6 +443,7 @@
 }
 
 int VPlanetaryShield::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   if(this->currentShield>0) {
     this->currentShield -= (normal + direct);
     message.print(500,5,"Shield level=%d", (long int)this->currentShield);
@@ -422,6 +454,7 @@
 }
 
 void VPlanetaryShield::calculate(void) {
+  STACKTRACE;
   this->currentShield += ((double)frame_time / 1000) * this->shieldRegenerationPerSecond;
   if(this->currentShield>this->maxShield) this->currentShield=this->maxShield;
   if(this->currentShield<0) this->isShield = false;
@@ -430,6 +463,7 @@
 
 VGroundDefenseLaser::VGroundDefenseLaser(SpaceLocation* olocation):VGroundInstallation(olocation)
 {
+  STACKTRACE;
   this->Initialize();
   this->isFunctioning = true;
   this->isDestroyed = false;
@@ -438,6 +472,7 @@
 }
 
 void VGroundDefenseLaser::Initialize() {
+  STACKTRACE;
   VGroundInstallation::Initialize("PlanetaryDefenseLaser");
   weaponRange = scale_range(get_config_float("PlanetaryDefenseLaser", "LaserRange", 0));
   weaponColor = get_config_int("PlanetaryDefenseLaser", "LaserColor", 0);
@@ -446,6 +481,7 @@
 }
 
 bool VGroundDefenseLaser::BattleAction() {
+  STACKTRACE;
   Vector2 RelLoc;
   double ta;
 	SpaceObject *o = NULL;
@@ -483,6 +519,7 @@
 
 VGroundIonCannon::VGroundIonCannon(SpaceLocation* olocation):VGroundInstallation(olocation)
 {
+  STACKTRACE;
   this->Initialize();
   this->isFunctioning = true;
   this->isDestroyed = false;
@@ -492,6 +529,7 @@
 }
 
 void VGroundIonCannon::Initialize() {
+  STACKTRACE;
   VGroundInstallation::Initialize("PlanetaryIonCannon");
   weaponRange = scale_range(get_config_float("PlanetaryIonCannon", "CannonRange", 0));
   weaponVelocity = scale_velocity(get_config_float("PlanetaryIonCannon", "CannonSpeed", 0));
@@ -500,6 +538,7 @@
 }
 
 bool VGroundIonCannon::BattleAction(void) {
+  STACKTRACE;
   //double rAnticipated;
   Vector2 RelLoc;
 
@@ -529,6 +568,7 @@
 
 VGroundMissileLauncher::VGroundMissileLauncher(SpaceLocation* olocation):VGroundInstallation(olocation)
 {
+  STACKTRACE;
   this->Initialize();
   this->isFunctioning = true;
   this->isDestroyed = false;
@@ -538,6 +578,7 @@
 }
 
 void VGroundMissileLauncher::Initialize() {
+  STACKTRACE;
   VGroundInstallation::Initialize("PlanetaryMissileLauncher");
   weaponRange = scale_range(get_config_float("PlanetaryMissileLauncher", "MissileRange", 0));
   weaponVelocity = scale_velocity(get_config_float("PlanetaryMissileLauncher", "MissileSpeed", 0));
@@ -547,6 +588,7 @@
 }
 
 bool VGroundMissileLauncher::BattleAction(void) {
+  STACKTRACE;
   Vector2 RelLoc;
 
 	SpaceObject *o = NULL;
@@ -572,6 +614,7 @@
 
 VSpaceMine::VSpaceMine():SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite)
 {
+  STACKTRACE;
   this->set_sprite(VSpaceMine::mySprite);
   this->explosionSprite = VSpaceMine::explosionSprite;
   Initialize();
@@ -585,12 +628,14 @@
 }
 
 void VSpaceMine::death(void) {
+  STACKTRACE;
   this->animateExplosion();
   SpaceObject::death();
   if(this->willRespawn) game->add(new VSpaceMine());
 }
 
 void VSpaceMine::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   Vector2 V;
   if(!other->isShip()) return; //only damages ships!!!
   this->damage_factor = this->damage;
@@ -602,6 +647,7 @@
 
 int VSpaceMine::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   if(source->isLine()||source->isShot()) {
     armour -= normal + direct;
     if(armour<0) state = 0;
@@ -612,6 +658,7 @@
 }
 
 void VSpaceMine::Initialize() {
+  STACKTRACE;
 	game->log_file ("vobject.ini");
   this->sprite_index = 0;
   this->armour = get_config_float("SpaceMine", "Armour", 0);
@@ -620,6 +667,7 @@
 }
 
 void VSpaceMine::animateExplosion(void) {
+  STACKTRACE;
 //	Animation(SpaceLocation *creator, Vector2 opos, SpaceSprite *osprite, 
 //			int first_frame, int num_frames, int frame_size, double depth, double scale = 1.0) ;
 	game->add(new Animation(this, normal_pos(),
@@ -630,6 +678,7 @@
 
 void VSpaceMine::soundExplosion(void) 
 {
+  STACKTRACE;
   if(damage_factor > 0) 
     {
       int i = iround_down(damage_factor / 2);
@@ -661,6 +710,7 @@
 
 VNebula::VNebula():Presence()
 {
+  STACKTRACE;
 //  game->all_damage_direct = true;
 //  game->is_nebula = true;
   friction = 0.0004;
@@ -670,6 +720,7 @@
 
 VNebula::VNebula(double ofriction):Presence()
 {
+  STACKTRACE;
 //  game->all_damage_direct = true;
   friction = ofriction;
 	videosystem.color_effects = VNebulaColorEffects;
@@ -679,6 +730,7 @@
 
 VNebula::VNebula(double ofriction, int oionStorms):Presence()
 {
+  STACKTRACE;
 //  game->all_damage_direct = true;
   friction = ofriction; 
   ionStorms = oionStorms;
@@ -687,6 +739,7 @@
 }
 
 void VNebula::calculate(void) {
+  STACKTRACE;
   Presence::calculate();
   
   for(std::list<SpaceLocation*>::iterator i=game->item.begin();i!=game->item.end();i++)
@@ -710,6 +763,7 @@
 }
 
 VIonStorm::VIonStorm(void):SpaceObject(NULL, Vector2(0,0), 0, NULL) {
+  STACKTRACE;
 //	SpaceObject(SpaceLocation *creator, Vector2 opos, double oangle, 
 //			SpaceSprite *osprite);
 
@@ -721,6 +775,7 @@
 :
 SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite)
 {
+  STACKTRACE;
   double speed, angle;
   this->velocityRestoreFactor = 0.00;
   this->mass = 0;
@@ -739,6 +794,7 @@
 }
 
 void VDustCloud::Initialize(const char* nameInIni) {
+  STACKTRACE;
 	game->log_file ("vobject.ini");
   this->sprite_index = 0;
 	mass = get_config_int(nameInIni, "Mass", 0);
@@ -752,10 +808,12 @@
 }
 
 void VDustCloud::Initialize(void) {
+  STACKTRACE;
   Initialize("DustCloud");
 }
 
 int VDustCloud::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   if(source->isAsteroid()) return(0);
   if(source->isLine()||source->isShot()) {
     armour -= (normal + direct);
@@ -766,6 +824,7 @@
 }
 
 void VDustCloud::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   Vector2 relV;
   double excessSpeed;
   double d;
@@ -789,11 +848,13 @@
 }
 
 void VDustCloud::death(void) {
+  STACKTRACE;
   SpaceObject::death();
   if(this->willRespawn) game->add(new VDustCloud());
 }
 
 void VDustCloud::calculate(void) {
+  STACKTRACE;
   double x;
   x = (double)frame_time * this->velocityRestoreFactor;
   if(x>1)x=1;
@@ -806,6 +867,7 @@
 :
 SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite)
 {
+  STACKTRACE;
   double speed, angle;
   this->velocityRestoreFactor = 0.00;
   this->mass = 0;
@@ -825,6 +887,7 @@
 }
 
 void VGasCloud::Initialize(const char* nameInIni) {
+  STACKTRACE;
 	game->log_file ("vobject.ini");
   this->sprite_index = 0;
 	mass = get_config_int(nameInIni, "Mass", 0);
@@ -843,10 +906,12 @@
 }
 
 void VGasCloud::Initialize(void) {
+  STACKTRACE;
   Initialize("GasCloud");
 }
 
 int VGasCloud::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   if(isEnergized = false) {
     this->damageFactor=0;
     this->damage_factor=0;
@@ -868,6 +933,7 @@
 }
 
 void VGasCloud::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   if(this->damageFactor>0.001) {
     //message.print(500,5,"energizing damage");
     damage(other, this->energizingDamageFactor * this->damageFactor / 2, this->energizingDamageFactor * this->damageFactor / 2);
@@ -884,6 +950,7 @@
 }
 
 void VGasCloud::calculate(void) {
+  STACKTRACE;
   double x;
   if(this->isEnergized) {
     this->isEnergized = false;
@@ -901,6 +968,7 @@
 }
 
 void VGasCloud::death(void) {
+  STACKTRACE;
   SpaceObject::death();
   if(this->willRespawn) game->add(new VGasCloud());
 }
@@ -910,6 +978,7 @@
 :
 Planet(Vector2(0,0), VMoon::mySprite, 0) // a sprite is needed to avoid a crash...WTF?
 {
+  STACKTRACE;
   int i;
   for(i=0; i<12; i++) this->Installation[i]=NULL;
   this->id = ID_PLANET;
@@ -917,16 +986,19 @@
 }
 
 double VPlanet::getRadius(void) {
+  STACKTRACE;
   return(((this->size.x + this->size.y) / 4) / 1000);
 }
 
 
 void VPlanet::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   Planet::inflict_damage(other);
 }
 
 int VPlanet::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   int i,j;
   for(i=0;i<12;i++) {
     if(this->Installation[i]!=NULL)
@@ -966,6 +1038,7 @@
 
 void VPlanet::Initialize(const char* nameInIni)
 {
+  STACKTRACE;
 	game->log_file ("vobject.ini");
   this->sprite_index = 0;
 	gravity_mindist = scale_range(get_config_float(nameInIni, "GravityMinDist", 0));
@@ -978,6 +1051,7 @@
 }
 
 bool VPlanet::AddInstallation(VGroundInstallation* oGI) {
+  STACKTRACE;
   int i;
   for(i=0;i<12;i++) {
     if(this->Installation[i]==NULL) {
@@ -990,6 +1064,7 @@
 }
 
 void VPlanet::death() {
+  STACKTRACE;
   int i;
   for(i=0;i<12;i++)
     if(this->Installation[i]!=NULL)
@@ -997,6 +1072,7 @@
 }
 
 void VStar::AttractShots(int warping_power, double intensity) {
+  STACKTRACE;
   //sort of like gravity, but no minimum distance
   //and only changes direction, not speed.
   //only affects massless objects.
@@ -1057,6 +1133,7 @@
 :
 Planet(Vector2(0,0), VBrownDwarf::mySprite, 0) //sprite problem?
 {
+  STACKTRACE;
   this->id = ID_PLANET; // done for grav-whip purposes!!!!
   this->starEnergy = 0.0;
   this->angle = 0;
@@ -1074,11 +1151,13 @@
 }
 
 double VStar::getRadius(void) {
+  STACKTRACE;
   return((this->size.x + this->size.y) / 4);
 }
 
 
 void VStar::calculate() {
+  STACKTRACE;
   double r;
   double maxFlares;
   double flareFactor;
@@ -1114,6 +1193,7 @@
 }
 
 void VStar::LaunchFlare(double oangle, double oinitialVelocity, double orange, double odamage, double ofinalVelocity) {
+  STACKTRACE;
   ;// this SHOULD be overridden as needed by individual stars...?
   VRedFlare* VRF;
   VRF = new VRedFlare(this, oangle, oinitialVelocity, orange, odamage, ofinalVelocity);
@@ -1124,12 +1204,14 @@
 
 int VStar::canCollide(SpaceLocation *other)
 {
+  STACKTRACE;
   return(TRUE);
 	if(other->id==COMET_ID) return FALSE;
 	return(!other->isPlanet());
 }
 
 void VStar::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   double percentCoreDamage;
 
   double totalDamage;
@@ -1145,6 +1227,7 @@
 }
 
 int VStar::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return(0);
   /*int x;
   x = VStar::handle_damage(source, normal, direct);
@@ -1157,6 +1240,7 @@
 
 void VStar::Initialize(const char* nameInIni)
 {
+  STACKTRACE;
   starEnergy = 0.0;
 	game->log_file ("vobject.ini");
   this->sprite_index = 0;
@@ -1187,6 +1271,7 @@
 }
 
 bool VStar::isPlanet(void) {
+  STACKTRACE;
   return(true); // a kludge, should help grav-whip???
 }
 
@@ -1195,6 +1280,7 @@
 :
 Asteroid()
 {
+  STACKTRACE;
   this->set_sprite(mySprite);
   armour = VMetalShard::myArmour;
   damage_factor = VMetalShard::myDamage;
@@ -1208,6 +1294,7 @@
 :
 Asteroid()
 {
+  STACKTRACE;
   if(VMetalShard::mySprite==NULL) {
     ;
   }
@@ -1223,6 +1310,7 @@
 
 
 int VMetalShard::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	if (!exists()) return 0;
 	if ((normal > 0) || (direct > 0)) {
 		armour -= normal;
@@ -1239,6 +1327,7 @@
 }
 
 void VMetalShard::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if (!other->exists()) return;
 	damage(other, 0, damage_factor);
   if(other->isShip()) ((Ship*)other)->update_panel=1;
@@ -1249,6 +1338,7 @@
 }
 
 void VMetalShard::animateExplosion(void) {
+  STACKTRACE;
 	game->add(new Animation(this, normal_pos(),
     explosionSprite, 0, 10,
     scale_frames(0), DEPTH_EXPLOSIONS));
@@ -1256,6 +1346,7 @@
 }
 
 void VMetalShard::soundExplosion(void) {
+  STACKTRACE;
   if(damage_factor > 0) 
     {
       int i = iround_down(damage_factor / 2);
@@ -1285,11 +1376,13 @@
 }
 
 void VMetalShard::death(void) {
+  STACKTRACE;
   SpaceObject::death();
   if(this->willRespawn) game->add(new VMetalShard());
 }
 
 void VMetalShard::compareSprites(void) {
+  STACKTRACE;
   if(this->sprite==this->mySprite) {
     tw_error("Identical sprites");
   }
@@ -1302,6 +1395,7 @@
 :
 Asteroid()
 {
+  STACKTRACE;
   this->set_sprite(mySprite);
   armour = VMetalAsteroid::myArmour;
   damage_factor = VMetalAsteroid::myDamage;
@@ -1310,7 +1404,8 @@
   this->willRespawn = TRUE;
 }
 
-int VMetalAsteroid::handle_damage(SpaceLocation *source, double normal, double direct) {STACKTRACE
+int VMetalAsteroid::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
   Vector2 V;
   //tw_error("about to handle damage");
 	if (!exists()) return 0;
@@ -1335,7 +1430,8 @@
 	return 1;
 }
 
-void VMetalAsteroid::inflict_damage(SpaceObject *other) {STACKTRACE
+void VMetalAsteroid::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
   //tw_error("about to inflict damage");
 	if (!other->exists()) return;
 	damage(other, 0, damage_factor);
@@ -1347,6 +1443,7 @@
 }
 
 void VMetalAsteroid::animateExplosion(void) {
+  STACKTRACE;
 	game->add(new Animation(this, normal_pos(),
     explosionSprite, 0, 10,
     scale_frames(0), DEPTH_EXPLOSIONS));
@@ -1356,6 +1453,7 @@
 
 void VMetalAsteroid::soundExplosion(void) 
 {
+  STACKTRACE;
   if(damage_factor > 0) 
     {
       int i = iround_down(damage_factor / 2);
@@ -1384,6 +1482,7 @@
 }
 
 void VMetalAsteroid::death(void) {
+  STACKTRACE;
   VMetalShard* VS;
   Vector2 Loc, UV;
   int i;
@@ -1413,6 +1512,7 @@
 :
 Asteroid()
 {
+  STACKTRACE;
   this->set_sprite(mySprite);
   armour = VSmallAsteroid::myArmour;
   damage_factor = VSmallAsteroid::damage_factor;
@@ -1425,6 +1525,7 @@
 :
 Asteroid()
 {
+  STACKTRACE;
   this->set_sprite(mySprite);
   armour = 10;
   damage_factor = 0;
@@ -1437,6 +1538,7 @@
 
 
 int VSmallAsteroid::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	Vector2 V;
   if (!exists()) return 0;
 	if ((normal > 0) || (direct > 0)) {
@@ -1461,6 +1563,7 @@
 }
 
 void VSmallAsteroid::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if (!other->exists()) return;
 	damage(other, 0, damage_factor);
   if(other->isShip()) ((Ship*)other)->update_panel=1;
@@ -1471,6 +1574,7 @@
 }
 
 void VSmallAsteroid::animateExplosion(void) {
+  STACKTRACE;
 	game->add(new Animation(this, normal_pos(),
     explosionSprite, 0, 10,
     scale_frames(0), DEPTH_EXPLOSIONS));
@@ -1479,6 +1583,7 @@
 }
 
 void VSmallAsteroid::soundExplosion(void) {
+  STACKTRACE;
   if(damage_factor > 0) 
     {
       int i = iround_down(damage_factor / 2);
@@ -1507,6 +1612,7 @@
 }
 
 void VSmallAsteroid::death(void) {
+  STACKTRACE;
   SpaceObject::death();
   if(this->willRespawn) game->add(new VSmallAsteroid());
 
@@ -1516,6 +1622,7 @@
 :
 Asteroid()
 {
+  STACKTRACE;
   this->set_sprite(mySprite);
   armour = VLargeAsteroid::myArmour;
   damage_factor = VLargeAsteroid::myDamage;
@@ -1525,6 +1632,7 @@
 }
 
 int VLargeAsteroid::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
   Vector2 V;
 	if (!exists()) return 0;
 	if ((normal > 0) || (direct > 0)) {
@@ -1551,6 +1659,7 @@
 }
 
 void VLargeAsteroid::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if (!other->exists()) return;
 	damage(other, 0, damage_factor);
   if(other->isShip()) ((Ship*)other)->update_panel=1;
@@ -1561,6 +1670,7 @@
 }
 
 void VLargeAsteroid::animateExplosion(void) {
+  STACKTRACE;
 	game->add(new Animation(this, normal_pos(),
     explosionSprite, 0, 10,
     scale_frames(0), DEPTH_EXPLOSIONS));
@@ -1570,6 +1680,7 @@
 
 void VLargeAsteroid::soundExplosion(void) 
 {
+  STACKTRACE;
   if(damage_factor > 0) {
     int i = iround_down(damage_factor / 2);
     if(i >= BOOM_SAMPLES) i = BOOM_SAMPLES - 1;
@@ -1597,6 +1708,7 @@
 }
 
 void VLargeAsteroid::death(void) {
+  STACKTRACE;
   VSmallAsteroid* VS;
   Vector2 Loc, UV;
   int i;
@@ -1616,11 +1728,13 @@
 :
 VPlanet()
 {
+  STACKTRACE;
   this->set_sprite(VMoon::mySprite);
   this->Initialize("Moon");
 }
 
 void VMoon::calculate() {
+  STACKTRACE;
   VPlanet::calculate();
 }
 
@@ -1629,6 +1743,7 @@
 :
 VPlanet()
 {
+  STACKTRACE;
   this->set_sprite(VRockballPlanet::mySprite);
   this->Initialize("RockballPlanet");
 }
@@ -1639,6 +1754,7 @@
 :
 VPlanet()
 {
+  STACKTRACE;
   this->set_sprite(VInhospitablePlanet::mySprite);
   this->Initialize("InhospitablePlanet");
 }
@@ -1647,6 +1763,7 @@
 :
 VPlanet()
 {
+  STACKTRACE;
   this->set_sprite(VHabitablePlanet::mySprite);
   this->Initialize("HabitablePlanet");
 }
@@ -1655,6 +1772,7 @@
 :
 VPlanet()
 {
+  STACKTRACE;
   this->set_sprite(VGasGiant::mySprite);
   this->Initialize("GasGiant");
 
@@ -1664,15 +1782,18 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VBrownDwarf::mySprite);
   this->Initialize("BrownDwarf");
 }
 
 void VBrownDwarf::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VBrownDwarf::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
@@ -1681,15 +1802,18 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VRedDwarf::mySprite);
   this->Initialize("RedDwarf");
 }
 
 void VRedDwarf::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VRedDwarf::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
@@ -1697,15 +1821,18 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VWhiteDwarf::mySprite);
   this->Initialize("WhiteDwarf");
 }
 
 void VWhiteDwarf::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 void VWhiteDwarf::LaunchFlare(VStar* osource, double oangle, double oinitialVelocity, double orange, double odamage, double ofinalVelocity) {
+  STACKTRACE;
   VWhiteFlare* VRF;
   VRF = new VWhiteFlare(this, oangle, oinitialVelocity, orange, odamage, ofinalVelocity);
   game->add(VRF);
@@ -1714,6 +1841,7 @@
 
 
 int VWhiteDwarf::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
@@ -1722,15 +1850,18 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VRedStar::mySprite);
   this->Initialize("RedStar");
 }
 
 void VRedStar::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VRedStar::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
@@ -1738,20 +1869,24 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VOrangeStar::mySprite);
   this->Initialize("OrangeStar");
 
 }
 
 void VOrangeStar::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VOrangeStar::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
 void VOrangeStar::LaunchFlare(VStar* osource, double oangle, double oinitialVelocity, double orange, double odamage, double ofinalVelocity) {
+  STACKTRACE;
   VOrangeFlare* VRF;
   VRF = new VOrangeFlare(this, oangle, oinitialVelocity, orange, odamage, ofinalVelocity);
   game->add(VRF);
@@ -1763,20 +1898,24 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VYellowStar::mySprite);
   this->Initialize("YellowStar");
 }
 
 
 void VYellowStar::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VYellowStar::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
 void VYellowStar::LaunchFlare(double oangle, double oinitialVelocity, double orange, double odamage, double ofinalVelocity) {
+  STACKTRACE;
   VYellowFlare* VRF;
   VRF = new VYellowFlare(this, oangle, oinitialVelocity, orange, odamage, ofinalVelocity);
   game->add(VRF);
@@ -1788,19 +1927,23 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VWhiteStar::mySprite);
   this->Initialize("WhiteStar");
 }
 
 void VWhiteStar::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VWhiteStar::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
 void VWhiteStar::LaunchFlare(VStar* osource, double oangle, double oinitialVelocity, double orange, double odamage, double ofinalVelocity) {
+  STACKTRACE;
   VWhiteFlare* VRF;
   VRF = new VWhiteFlare(this, oangle, oinitialVelocity, orange, odamage, ofinalVelocity);
   game->add(VRF);
@@ -1811,15 +1954,18 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VRedGiant::mySprite);
   this->Initialize("RedGiant");
 }
 
 void VRedGiant::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VRedGiant::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
@@ -1828,19 +1974,23 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VBlueGiant::mySprite);
   this->Initialize("BlueGiant");
 }
 
 void VBlueGiant::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VBlueGiant::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
 void VBlueGiant::LaunchFlare(double oangle, double oinitialVelocity, double orange, double odamage, double ofinalVelocity) {
+  STACKTRACE;
   VWhiteFlare* VRF;
   VRF = new VWhiteFlare(this, oangle, oinitialVelocity, orange, odamage, ofinalVelocity);
   game->add(VRF);
@@ -1852,6 +2002,7 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VNeutronStar::mySprite);
   this->Initialize("NeutronStar");
 	/*game->log_file ("vobject.ini");
@@ -1864,13 +2015,16 @@
 }
 
 void VNeutronStar::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VNeutronStar::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return(0);
 }
 void VNeutronStar::calculate(void) {
+  STACKTRACE;
   this->sprite_index += 1;
   while(this->sprite_index>63) this->sprite_index -=64;
   while(this->sprite_index<0) this->sprite_index +=64;
@@ -1883,19 +2037,23 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VHypermass::mySprite);
   this->Initialize("Hypermass");
 }
 
 void VHypermass::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VHypermass::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return(0);
 }
 
 void VHypermass::calculate(void) {
+  STACKTRACE;
   this->sprite_index += 1;
   while(this->sprite_index>63) this->sprite_index -=64;
   while(this->sprite_index<0) this->sprite_index +=64;
@@ -1908,6 +2066,7 @@
 Missile(source, source->pos, angle, initialVelocity, 
         odamage, range, odamage, source, VRedFlare::mySprite, 0)
 {
+  STACKTRACE;
   creator = (SpaceLocation*)source;
   pos = source->pos;
   originalVelocity = initialVelocity;
@@ -1919,6 +2078,7 @@
 }
 
 void VFlare::calculate() {
+  STACKTRACE;
   double amountFlown, amountToFly, currentAngle, calcVelocity;
   amountToFly = ((double)this->range - (double)this->d) / (double)this->range;
   amountToFly = amountToFly * amountToFly * amountToFly;
@@ -1931,11 +2091,13 @@
 }
 
 void VFlare::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   if((SpaceLocation*)other == (SpaceLocation*)creator) return;
   Missile::inflict_damage(other);
 }
 
 int VFlare::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
   if((SpaceLocation*)source == (SpaceLocation*)creator) return(0);
   return(Missile::handle_damage(source, normal, direct));
 }
@@ -1944,6 +2106,7 @@
 :
 VFlare(source, angle, initialVelocity, range, odamage, ofinalVelocity)
 {
+  STACKTRACE;
   this->set_sprite(VRedFlare::mySprite);
 }
 
@@ -1951,6 +2114,7 @@
 :
 VFlare(source, angle, initialVelocity, range, odamage, ofinalVelocity)
 {
+  STACKTRACE;
   this->set_sprite(VOrangeFlare::mySprite);
 }
 
@@ -1958,6 +2122,7 @@
 :
 VFlare(source, angle, initialVelocity, range, odamage, ofinalVelocity)
 {
+  STACKTRACE;
   this->set_sprite(VYellowFlare::mySprite);
 }
 
@@ -1965,6 +2130,7 @@
 :
 VFlare(source, angle, initialVelocity, range, odamage, ofinalVelocity)
 {
+  STACKTRACE;
   this->set_sprite(VWhiteFlare::mySprite);
 }
 

Modified: trunk/source/other/vtarget.cpp
===================================================================
--- trunk/source/other/vtarget.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/other/vtarget.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -40,6 +40,7 @@
 			   double WeaponOffsetY, double WeaponAngle,
 			   double MaxRange,
 			   double DegTolerance, int LagSetting) {
+  STACKTRACE;
 	AimSys::SetupDefaults();
 	source = sourceP; target = targetP;
 	relativity = Relativity;
@@ -60,6 +61,7 @@
 
 
 AimSys::AimSys(SpaceLocation* sourceP, SpaceLocation* targetP, double WeaponSpeed, double Relativity) {
+  STACKTRACE;
 	//not anti-aliased here
 	AimSys::SetupDefaults();
 	source = sourceP; target = targetP;
@@ -75,6 +77,7 @@
 }
 
 AimSys::AimSys(SpaceLocation* sourceP, SpaceLocation* targetP, double WeaponSpeed) {
+  STACKTRACE;
 	//not anti-aliased here
 	AimSys::SetupDefaults();
     source = sourceP; target = targetP;
@@ -88,6 +91,7 @@
 }
 
 AimSys::AimSys(SpaceLocation* sourceP, SpaceLocation* targetP) {
+  STACKTRACE;
 	//not anti-aliased here
 	//use with caution -- weapon speed is taken to be the
 	//current ship speed.  Would work for the Tau Bomber.
@@ -102,7 +106,8 @@
   AimSys::CalcWeaponOffset();
 }
 
-void AimSys::SetupDefaults(void) { //sets up defaults
+void AimSys::SetupDefaults(void) {
+  STACKTRACE; //sets up defaults
 	relativity = 0.5;
 	source = NULL; target = NULL;
   nx1center = 0; ny1center = 0;
@@ -116,6 +121,7 @@
 }
 
 void AimSys::CalcWeaponOffset(void) {
+  STACKTRACE;
   
   double dx, dy;
 	gamma = CalcVectorAngle(0,0,-weaponOffsetY, weaponOffsetX);
@@ -130,12 +136,14 @@
 }
 
 void AimSys::CalcWeaponOffset(double xOff, double yOff) {
+  STACKTRACE;
   weaponOffsetX = xOff;
   weaponOffsetY = yOff;
   AimSys::CalcWeaponOffset();
 }
 
 void AimSys::SetSpaceLine(SpaceLine* SL) {
+  STACKTRACE;
   SL->pos.x = nx1;
   SL->pos.y = ny1;
   SL->angle = gamma+source->angle;
@@ -146,16 +154,19 @@
 
 
 double AimSys::RawDistance(double x1, double y1, double x2, double y2) {
+  STACKTRACE;
 	return sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2 - y1));
 	//not anti-aliased here
 }
 
 double AimSys:: CalcVectorAngle(void) {
+  STACKTRACE;
 	return AimSys::CalcVectorAngle(nx1, ny1, nx2, ny2);
 }
 
 
 double AimSys:: CalcVectorAngle(double x1, double y1, double x2, double y2) {
+  STACKTRACE;
 	//angle of the line from source to target, in normal cartesian coordinates
 	//zero degrees is going straight up.
 	//the computer uses X+ across, Y+ down.
@@ -182,6 +193,7 @@
 }
 
 int AimSys::CalcTrialValues(void) {
+  STACKTRACE;
 	//HERE is where the anti-ailasing happens!
 	//all 8 wrap-around positions are tested, along with the non
 	//wrapped one.
@@ -229,26 +241,32 @@
 }
 
 double AimSys::getPursuitAngle() {
+  STACKTRACE;
 	return pursuitAngle;
 }
 
 double AimSys::getBestTrialAlpha() {
+  STACKTRACE;
 	return bestTrialAlpha;
 }
 
 double AimSys::getBestTrialTheta() {
+  STACKTRACE;
 	return bestTrialTheta;
 }
 
 double AimSys::getAngleOfShortestDistance() {
+  STACKTRACE;
   return bestTrialEpsilon;
 }
 
 void AimSys::setNewTarget(SpaceObject* newTarget) {
+  STACKTRACE;
 	target = newTarget;
 }
 
 void AimSys::Update(void) {
+  STACKTRACE;
 	if(source==NULL||target==NULL) return;
 	nx1center = source->pos.x; ny1center = source->pos.y; 
 	nx2 = target->pos.x; ny2 = target->pos.y;
@@ -265,6 +283,7 @@
 }
 
 double AimSys::absAngleDifference(double A1, double A2) {
+  STACKTRACE;
 	double x;
 	x = fabs(A2 - A1);
 	if(x>180)
@@ -275,6 +294,7 @@
 
 
 int AimSys::shouldFireNow(void) {
+  STACKTRACE;
 	// at the moment, just checks for current angle
 	//within tolerance
 	//the quick and dirty answer
@@ -292,6 +312,7 @@
 }
 
 int AimSys::shouldTurnLeft(void) {
+  STACKTRACE;
 	int x1, x2;
 	x1 = iround(source->angle-weaponAngle);
 	x2 = iround(pursuitAngle);
@@ -304,6 +325,7 @@
 }
 
 int AimSys::shouldTurnRight(void) {
+  STACKTRACE;
 	int x1, x2;
 	x1 = iround(source->angle-weaponAngle);
 	x2 = iround(pursuitAngle);

Modified: trunk/source/sc1ships/shpandgu.cpp
===================================================================
--- trunk/source/sc1ships/shpandgu.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpandgu.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -35,6 +35,7 @@
 AndrosynthGuardian::AndrosynthGuardian(Vector2 opos, double angle, ShipData *data, unsigned int code) :
   Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 	weaponDamage       = get_config_int("Weapon", "Damage", 1);
 	weaponArmour       = get_config_int("Weapon", "Armour", 1);
 	weaponRange        = scale_range(get_config_float("Weapon", "Range", 10));
@@ -59,6 +60,7 @@
 
 void AndrosynthGuardian::calculate()
 {
+  STACKTRACE;
 	Ship::calculate();
 	if(specialActive && (batt == -1)) {
 		set_sprite(shipSprite);
@@ -74,6 +76,7 @@
 	}
 
 void AndrosynthGuardian::calculate_thrust() {
+  STACKTRACE;
 	if(specialActive) {
 		double dv;
 		if (bounce_status > 0) {
@@ -94,6 +97,7 @@
 
 void AndrosynthGuardian::calculate_hotspots()
 {
+  STACKTRACE;
   if(specialActive)
     return;
   Ship::calculate_hotspots();
@@ -101,6 +105,7 @@
 
 void AndrosynthGuardian::inflict_damage(SpaceObject *other) 
 {
+  STACKTRACE;
   if (damage_factor > 0) 
     {
       if (other->mass) 
@@ -139,6 +144,7 @@
 }
 
 int AndrosynthGuardian::activate_weapon() {
+  STACKTRACE;
   
   if(specialActive)
 	  return FALSE;
@@ -151,6 +157,7 @@
 
 int AndrosynthGuardian::activate_special() 
 {
+  STACKTRACE;
   if(specialActive)
     return(FALSE);
   
@@ -181,6 +188,7 @@
     osprite, ofcount, ofsize),
   courseFrames(0)
 {
+  STACKTRACE;
   explosionSprite     = data->spriteWeaponExplosion;
   explosionFrameCount = 6;
   explosionFrameSize  = 50;
@@ -188,6 +196,7 @@
 
 void AndrosynthBubble::calculate()
 {
+  STACKTRACE;
 	if (!(ship && ship->exists()))
 	{
 		state = 0;

Modified: trunk/source/sc1ships/shparisk.cpp
===================================================================
--- trunk/source/sc1ships/shparisk.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shparisk.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -23,6 +23,7 @@
 	:
 	Ship(opos, angle, data, code)
 	{
+  STACKTRACE;
 	specialSprite = data->spriteSpecial;
 
 	weaponColor  = get_config_int("Weapon", "Color", 0);
@@ -36,6 +37,7 @@
 	}
 
 void ArilouSkiff::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if (just_teleported && other->mass) {
 		damage(this, 0, 999);
 		}
@@ -44,6 +46,7 @@
 	}
 
 int ArilouSkiff::activate_weapon() {
+  STACKTRACE;
 	SpaceObject *o = NULL;
 
 	double r = 99999;  
@@ -63,6 +66,7 @@
 	}
 
 int ArilouSkiff::activate_special() {
+  STACKTRACE;
 
 	game->add(new Animation(this, pos,
 			specialSprite, 0, 40, iround(specialFrames/40), DEPTH_HOTSPOTS-0.1));
@@ -80,6 +84,7 @@
 	}
 
 void ArilouSkiff::calculate() {
+  STACKTRACE;
 	just_teleported = 0;
 	Ship::calculate();
 
@@ -88,10 +93,12 @@
 		}
 	}
 
-void ArilouSkiff::calculate_gravity() {}
+void ArilouSkiff::calculate_gravity() {
+  STACKTRACE;}
 
 int ArilouSkiff::accelerate(SpaceLocation *source, double angle, double velocity, 
 		double max_speed) {
+  STACKTRACE;
 	if (source == this) 
 		return Ship::accelerate(source, angle, velocity, max_speed);
 	return false;
@@ -99,6 +106,7 @@
 
 int ArilouSkiff::accelerate_gravwhip(SpaceLocation *source, double angle, double velocity, 
 		double max_speed) {
+  STACKTRACE;
 	if (source == this) 
 		return Ship::accelerate(source, angle, velocity, max_speed);
 	return false;

Modified: trunk/source/sc1ships/shpchebr.cpp
===================================================================
--- trunk/source/sc1ships/shpchebr.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpchebr.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -53,6 +53,7 @@
 ChenjesuBroodhome::ChenjesuBroodhome(Vector2 opos, double angle, ShipData *data, unsigned int code) :
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 	weaponDamage		= get_config_int("Weapon", "Damage", 0);
 	shardRange			= scale_range(get_config_int("Weapon", "ShardRange", 0));
 	shardDamage			= get_config_int("Weapon", "ShardDamage", 0);
@@ -76,6 +77,7 @@
 
 int ChenjesuBroodhome::activate_weapon()
 {
+  STACKTRACE;
 	if(weaponFired)
 		return(FALSE);
 	weaponObject = new ChenjesuShot(Vector2(0.0, (size.y / 2.0)), angle,
@@ -87,6 +89,7 @@
 
 int ChenjesuBroodhome::activate_special()
 {
+  STACKTRACE;
 	if(specialNumDOGIs >= MAX_DOGIS)
 		return(FALSE);
 	ChenjesuDOGI* DOGI; //added by Varith
@@ -102,6 +105,7 @@
 
 void ChenjesuBroodhome::calculate()
 {
+  STACKTRACE;
 	int i;
 
 	Ship::calculate();
@@ -130,6 +134,7 @@
 	int odamage, int oarmour, SpaceLocation *creator, SpaceSprite *osprite) :
 	Missile(creator, opos, oangle, ov, odamage, -1.0, oarmour, creator, osprite)
 {
+  STACKTRACE;
 	collide_flag_sameship = bit(LAYER_SPECIAL);
 	explosionSprite     = data->spriteWeaponExplosion;
 	explosionFrameCount = 20;
@@ -138,6 +143,7 @@
 
 void ChenjesuShot::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
 	Shot::inflict_damage(other);
 	if ((other->mass > 0) && !exists())
 		if (other-exists())
@@ -152,6 +158,7 @@
 
 void ChenjesuShot::animateExplosion()
 {
+  STACKTRACE;
 	return;
 }
 
@@ -161,6 +168,7 @@
 	AnimatedShot(oship, opos, ov, oangle, 0, -1.0, oarmour, oship, osprite, 64, 50),
 	sap_factor(fuel_sap), accel_rate(accel), num_dogis(onum_dogis)
 {
+  STACKTRACE;
 	layer = LAYER_SPECIAL;
 	set_depth(DEPTH_SPECIAL);
 	mass = omass;
@@ -170,6 +178,7 @@
 
 void ChenjesuDOGI::calculate()
 {
+  STACKTRACE;
 	AnimatedShot::calculate();
 
 	if (ship && ship->exists()) {
@@ -195,6 +204,7 @@
 
 void ChenjesuDOGI::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   tw_sound.play_sound(data_full_path(data->sampleExtra[1]));
 
   if(sameTeam(other)) 
@@ -210,11 +220,13 @@
 
 void ChenjesuDOGI::death()
 {
+  STACKTRACE;
 	if (num_dogis) (*num_dogis)--;
 }
 
 void ChenjesuDOGI::ship_died()
 {
+  STACKTRACE;
 	num_dogis = NULL;
 	SpaceObject::ship_died();
 	state = 0;
@@ -223,12 +235,14 @@
 
 void ChenjesuDOGI::animateExplosion()
 {
+  STACKTRACE;
 	game->add(new Animation(this, pos,
 		data->spriteSpecialExplosion, 0, 20, 25, DEPTH_EXPLOSIONS));
 }
 
 void ChenjesuDOGI::soundExplosion()
 {
+  STACKTRACE;
   tw_sound.stop_sound(data_full_path(data->sampleExtra[2]));
   tw_sound.play_sound(data_full_path(data->sampleExtra[2]));
   return;

Modified: trunk/source/sc1ships/shpearcr.cpp
===================================================================
--- trunk/source/sc1ships/shpearcr.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpearcr.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -32,6 +32,7 @@
 	:
 	Ship(opos, angle, data, code)
 	{
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -48,6 +49,7 @@
 }
 
 int EarthlingCruiser::activate_weapon() {
+  STACKTRACE;
 	game->add(new EarthlingMissile(
 		Vector2(0.0, (size.y * 1.0)), angle, weaponVelocity, weaponDamage, weaponRange,
 		weaponArmour, weaponTurnRate, this, data->spriteWeapon));
@@ -56,6 +58,7 @@
 
 int EarthlingCruiser::activate_special() 
 {
+  STACKTRACE;
   int fire = FALSE;
   SpaceObject *o;
   
@@ -90,6 +93,7 @@
   HomingMissile(oship, opos, oangle, ov, odamage, orange, oarmour, otrate, 
 		oship, osprite, oship->target)
 {
+  STACKTRACE;
 	collide_flag_sameship = bit(LAYER_SHIPS) | bit(LAYER_SHOTS);
   explosionSprite     = data->spriteWeaponExplosion;
   explosionFrameCount = 10;

Modified: trunk/source/sc1ships/shpilwav.cpp
===================================================================
--- trunk/source/sc1ships/shpilwav.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpilwav.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -25,6 +25,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
   weaponDamage   = get_config_int("Weapon", "Damage", 0);
@@ -41,6 +42,7 @@
 	}
 
 int IlwrathAvenger::activate_weapon() {
+  STACKTRACE;
 	// note that target=0 is only set after this routine is called in ship::calculate
 	// so we need to check if it exists ...
 	if (cloak && target && target->exists()) {
@@ -60,6 +62,7 @@
 
 void IlwrathAvenger::calculate_fire_special()
 {
+  STACKTRACE;
   special_low = FALSE;
 
   if(fire_special) {
@@ -89,12 +92,14 @@
 
 void IlwrathAvenger::calculate_hotspots()
 {
+  STACKTRACE;
   if(!cloak)
     Ship::calculate_hotspots();
 }
 
 void IlwrathAvenger::calculate()
 {
+  STACKTRACE;
   if((cloak) && (cloak_frame < 300))
     cloak_frame += frame_time;
   if((!cloak) && (cloak_frame > 0))
@@ -104,6 +109,7 @@
 }
 
 void IlwrathAvenger::animate(Frame *space) {
+  STACKTRACE;
 	if((cloak_frame > 0) && (cloak_frame < 300))
 		sprite->animate_character( pos, sprite_index, 
 				pallete_color[cloak_color[cloak_frame / 100]], space);

Modified: trunk/source/sc1ships/shpkzedr.cpp
===================================================================
--- trunk/source/sc1ships/shpkzedr.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpkzedr.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -51,6 +51,7 @@
 	:
 	Ship(opos, angle, data, code) 
 	{
+  STACKTRACE;
 	weaponRange         = scale_range(get_config_float("Weapon", "Range", 0));
 	weaponVelocity      = scale_velocity(get_config_float("Weapon", "Velocity", 0));
 	weaponDamage        = get_config_int("Weapon", "Damage", 0);
@@ -68,6 +69,7 @@
 	}
 
 int KzerZaDreadnought::activate_weapon() {
+  STACKTRACE;
 	game->add( new KzerZaMissile(
 			Vector2(0.0, (size.y / 2.0)), angle, weaponVelocity, weaponDamage, weaponRange,
 			weaponArmour, this, data->spriteWeapon) );
@@ -75,6 +77,7 @@
 	}
 
 int KzerZaDreadnought::activate_special() {
+  STACKTRACE;
 	if(crew > 1) {
 		game->add( new KzerZaFighter(Vector2(-25.0, -50.0),
 				angle - PI*7.0/8 , specialVelocity, specialRange, specialArmour,
@@ -101,6 +104,7 @@
 	:
 	Missile(oship, opos, oangle, ov, odamage, orange, oarmour, oship,osprite) 
 	{
+  STACKTRACE;
 	explosionSprite     = data->spriteWeaponExplosion;
 	explosionFrameCount = 20;
 	explosionFrameSize  = 50;
@@ -127,6 +131,7 @@
 
 void KzerZaFighter::calculate() 
 {
+  STACKTRACE;
   Missile::calculate();
 
   if (!(ship && ship->exists()))
@@ -199,6 +204,7 @@
 
 int KzerZaFighter::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   if (source->isPlanet()) 
     {
       state = 1;
@@ -210,6 +216,7 @@
 
 void KzerZaFighter::inflict_damage(SpaceObject *other) 
 {
+  STACKTRACE;
   if (other == ship) 
     {
       tw_sound.stop_sound(data_full_path(data->sampleExtra[1]));

Modified: trunk/source/sc1ships/shpmmrxf.cpp
===================================================================
--- trunk/source/sc1ships/shpmmrxf.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpmmrxf.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -30,6 +30,7 @@
 	laser2(NULL),
 	laserSpark(0)
 	{
+  STACKTRACE;
 	form_data[T_FORM].speed_max       = speed_max;
 	form_data[T_FORM].accel_rate      = accel_rate;
 	form_data[T_FORM].turn_rate       = turn_rate;
@@ -78,6 +79,7 @@
 
 void MmrnmhrmXForm::calculate()
 {
+  STACKTRACE;
   if(laserSpark > 0) {
     laserSpark-= frame_time;
     if((laserSpark <= 0) && (laserSpark > -frame_time)) {
@@ -95,6 +97,7 @@
 
 int MmrnmhrmXForm::activate_weapon()
 {
+  STACKTRACE;
   if(form == T_FORM) {
     add(laser1 = new Laser(this, angle + laserAngle,
       pallete_color[laserColor], laserRange, laserDamage, weapon_rate, this,
@@ -117,6 +120,7 @@
 
 int MmrnmhrmXForm::activate_special()
 {
+  STACKTRACE;
 	form_data[form].speed_max       = speed_max;
 	form_data[form].accel_rate      = accel_rate;
 	form_data[form].turn_rate       = turn_rate;
@@ -141,6 +145,7 @@
 }
 
 double MmrnmhrmXForm::handle_speed_loss(SpaceLocation *source, double normal) {
+  STACKTRACE;
 	Ship::handle_speed_loss(source, normal);
 	if (normal) {
 		activate_special();

Modified: trunk/source/sc1ships/shpmycpo.cpp
===================================================================
--- trunk/source/sc1ships/shpmycpo.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpmycpo.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -41,6 +41,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
   weaponDamage   = get_config_int("Weapon", "Damage", 0);
@@ -50,6 +51,7 @@
 
 int MyconPodship::activate_weapon()
 {
+  STACKTRACE;
   add(new MyconPlasma(Vector2(0.0, size.y),
     angle, weaponVelocity, weaponDamage, weaponRange, weaponHome, this,
     data->spriteWeapon, 64));
@@ -58,6 +60,7 @@
 
 int MyconPodship::activate_special()
 {
+  STACKTRACE;
   if(crew >= crew_max)
     return(FALSE);
   damage(this, 0, -4);
@@ -74,6 +77,7 @@
   frame_count(ofcount),
   max_damage(odamage)
 {
+  STACKTRACE;
 	spriteWeaponExplosion = data->spriteWeaponExplosion;
 	collide_flag_sameship |= bit(LAYER_SHIPS);
 	collide_flag_sameteam |= bit(LAYER_SHIPS);
@@ -81,6 +85,7 @@
 
 void MyconPlasma::calculate()
 {
+  STACKTRACE;
   HomingMissile::calculate();
 
   sprite_index = (int)((d / range) * (double)(frame_count - 1));
@@ -89,6 +94,7 @@
 
 void MyconPlasma::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   SpaceObject::inflict_damage(other);
   //if (!other->isShot()) {
   if (other->isblockingweapons)
@@ -106,6 +112,7 @@
 }
 
 int MyconPlasma::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	double total = normal + direct;
 
 	if (total) {

Modified: trunk/source/sc1ships/shpshosc.cpp
===================================================================
--- trunk/source/sc1ships/shpshosc.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpshosc.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -23,6 +23,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
   weaponDamage   = get_config_int("Weapon", "Damage", 0);
@@ -39,6 +40,7 @@
 
 int ShofixtiScout::activate_weapon()
 {
+  STACKTRACE;
   add(new Missile(this, Vector2(0.0, size.y / 2.0),
     angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
     this, data->spriteWeapon));
@@ -47,6 +49,7 @@
 
 void ShofixtiScout::calculate_fire_special() 
 {
+  STACKTRACE;
   int gloryDamage;
   
   if(fire_special) 

Modified: trunk/source/sc1ships/shpspael.cpp
===================================================================
--- trunk/source/sc1ships/shpspael.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpspael.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -23,6 +23,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 
 	weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
 	weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -38,6 +39,7 @@
 
 int SpathiEluder::activate_weapon()
 {
+  STACKTRACE;
 	add(new Missile( this, Vector2(0.0, size.y / 2.0),
 		angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
 		this, data->spriteWeapon));
@@ -46,6 +48,7 @@
 
 int SpathiEluder::activate_special()
 {
+  STACKTRACE;
 	SpaceLocation *tmp = new HomingMissile( this, 
 		Vector2(0.0, -size.y / 1.5), angle + PI, specialVelocity, specialDamage, specialRange, 
 		specialArmour, specialTurnRate, this, data->spriteSpecial, target);

Modified: trunk/source/sc1ships/shpsyrpe.cpp
===================================================================
--- trunk/source/sc1ships/shpsyrpe.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpsyrpe.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -43,6 +43,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 
 	weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
 	weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -57,6 +58,7 @@
 
 int SyreenPenetrator::activate_weapon()
 {
+  STACKTRACE;
 	Missile *m;
 	m = new Missile(this, Vector2(0.0, size.y / 2.0 + 10),
 			angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
@@ -68,6 +70,7 @@
 }
 
 int SyreenPenetrator::activate_special() {
+  STACKTRACE;
 	double minDist;
 	minDist = specialRange + (size.x / 2.0);
 	int j;
@@ -112,6 +115,7 @@
   life(0),
   lifetime(oLifeTime)
 {
+  STACKTRACE;
 	collide_flag_sameship = ALL_LAYERS;
 	collide_flag_sameteam = ALL_LAYERS;
 	layer = LAYER_SPECIAL;
@@ -121,10 +125,12 @@
 }
 
 int CrewPod::sameTeam(SpaceLocation *other) {
+  STACKTRACE;
 	return true;
 	}
 
 void CrewPod::calculate() {
+  STACKTRACE;
 	frame_step += frame_time;
 	while (frame_step >= frame_size) {
 		frame_step -= frame_size;
@@ -148,6 +154,7 @@
 
 void CrewPod::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   if (other->isShip() && other->damage_factor == 0) 
     {
       tw_sound.stop_sound(data_full_path(data->sampleExtra[0]));
@@ -159,6 +166,7 @@
 
 int CrewPod::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
 	state = 0;
 	return 0;
 }

Modified: trunk/source/sc1ships/shpumgdr.cpp
===================================================================
--- trunk/source/sc1ships/shpumgdr.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpumgdr.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -43,6 +43,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 
   weaponDamage   = get_config_int("Weapon", "Damage", 0);
   specialRate    = special_rate;
@@ -53,12 +54,14 @@
 }
 
 int UmgahDrone::activate_weapon() {
+  STACKTRACE;
   firing = true;
   return(TRUE);
 }
 
 int UmgahDrone::activate_special()
 {
+  STACKTRACE;
   special_rate = specialRate;
   vel = 0;
   pos -= (unit_vector(angle) * size.x * 2.0);
@@ -68,12 +71,14 @@
 
 void UmgahDrone::calculate_thrust()
 {
+  STACKTRACE;
   if(special_recharge <= 0)
     Ship::calculate_thrust();
 }
 
 void UmgahDrone::calculate()
 {
+  STACKTRACE;
   if (fire_weapon)
     recharge_step = recharge_rate;
   else
@@ -87,6 +92,7 @@
   SpaceObject(oship, oship->normal_pos(), 0.0, osprite),
   dist(odist)
 {
+  STACKTRACE;
 	layer = LAYER_SHOTS;
 	set_depth(DEPTH_SHIPS - 0.1);
 
@@ -109,11 +115,13 @@
 }
 
 bool UmgahCone::change_owner(SpaceLocation *new_owner) {
+  STACKTRACE;
 	return false;
 	}
 
 void UmgahCone::calculate()
 {
+  STACKTRACE;
 	SpaceObject::calculate();
 
 	if(!(ship && ship->exists()))
@@ -140,6 +148,7 @@
 
 void UmgahCone::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   switch (damage_type) {
     case 0: {
             residual_damage = damage * frame_time / 2.0;
@@ -168,6 +177,7 @@
 }
 
 int UmgahCone::canCollide(SpaceLocation* other) {
+  STACKTRACE;
 //  calc_base();
   if (umgahship && umgahship->exists())
 	return (umgahship->firing & !other->isPlanet());
@@ -176,6 +186,7 @@
 }
 
 void UmgahCone::animate(Frame* space) {
+  STACKTRACE;
 //  calc_base();
   if (!umgahship || !umgahship->exists() || !umgahship->firing) return;
   int si = sprite_index;

Modified: trunk/source/sc1ships/shpvuxin.cpp
===================================================================
--- trunk/source/sc1ships/shpvuxin.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpvuxin.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -35,6 +35,7 @@
 	Ship(opos, angle, data, code)
 
 {
+  STACKTRACE;
   weaponColor  = get_config_int("Weapon", "Color", 0);
   weaponRange  = scale_range(get_config_float("Weapon", "Range", 0));
   weaponDamage = get_config_int("Weapon", "Damage", 0);
@@ -47,6 +48,7 @@
 
 int VuxIntruder::activate_weapon()
 {
+  STACKTRACE;
   add(new Laser(this, angle,
     pallete_color[weaponColor], weaponRange, weaponDamage, weapon_rate,
     this, Vector2(size.x/11, (size.y / 2.07)), true));
@@ -55,6 +57,7 @@
 
 int VuxIntruder::activate_special()
 {
+  STACKTRACE;
   add(new VuxLimpet(Vector2(0, -size.y / 2.8),
     specialVelocity, specialSlowdown, specialRange, specialArmour, this,
     data->spriteSpecial, 100, 5));
@@ -68,6 +71,7 @@
     ofcount, ofsize),
   slowdown_factor(slowdown)
 {
+  STACKTRACE;
   if((ship->target) && (!ship->target->isInvisible()))
     angle = trajectory_angle(ship->target);
   else
@@ -84,6 +88,7 @@
 
 void VuxLimpet::calculate()
 {
+  STACKTRACE;
 	if(!(ship && ship->exists())) {
 		state = 0;
 		return;
@@ -98,6 +103,7 @@
 
 void VuxLimpet::inflict_damage(SpaceObject *other) 
 {
+  STACKTRACE;
   if(!other->isShip()) 
     {
       if (other->damage_factor || other->mass) state = 0;
@@ -142,6 +148,7 @@
 
 void VuxIntruder::relocate() 
 {
+  STACKTRACE;
   if ( control ) target = control->target; 
   if (target && (distance(target) > 500)) {
     pos = target->normal_pos() + (unit_vector(angle) * 125.0);
@@ -157,6 +164,7 @@
 
 void VuxIntruder::animate(Frame *space)
 {
+  STACKTRACE;
   
   double back_x=size.x/3.60, back_y=-size.y/2.33,
     frnt_x=size.x/5.55, frnt_y=+size.y/17.01,
@@ -215,10 +223,12 @@
 :
 Phaser(ship, opos, _n, ship, sprite, osprite_index, ocolors, onum_colors, ofsize, steps, step_size)
 {
+  STACKTRACE;
 	vuxship = ship;
 }
 
 void VuxPhaser::calculate() {
+  STACKTRACE;
 	Phaser::calculate();
 	if (!ship) return;
 	if( !(ship->attributes & ATTRIB_INGAME )) vuxship->relocate();//((VuxIntruder*)ship)->relocate();
@@ -230,6 +240,7 @@
 	}
 
 SpaceLocation *VuxIntruder::get_ship_phaser() {
+  STACKTRACE;
 	return new VuxPhaser(
 			pos - unit_vector(angle) * PHASE_MAX * size.x,
 			unit_vector(angle) * PHASE_MAX * size.x,

Modified: trunk/source/sc1ships/shpyehte.cpp
===================================================================
--- trunk/source/sc1ships/shpyehte.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpyehte.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -25,6 +25,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -37,6 +38,7 @@
 
 int YehatTerminator::activate_weapon()
 {
+  STACKTRACE;
   add(new Missile(this, Vector2(-24.0, 14),
     angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
     this, data->spriteWeapon));
@@ -48,12 +50,14 @@
 
 int YehatTerminator::activate_special()
 {
+  STACKTRACE;
   shieldFrames = (shieldFrames % frame_time) + specialFrames;
   return(TRUE);
 }
 
 void YehatTerminator::calculate()
 {
+  STACKTRACE;
    if(shieldFrames > 0)
      shieldFrames-= frame_time;
    Ship::calculate();
@@ -61,6 +65,7 @@
 
 void YehatTerminator::animate(Frame *space)
 {
+  STACKTRACE;
   if(shieldFrames > 0)
     data->spriteSpecial->animate( pos, sprite_index, space);
   else
@@ -68,6 +73,7 @@
 }
 
 int YehatTerminator::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	if (shieldFrames > 0) normal = 0;
 	return Ship::handle_damage(source, normal, direct);
 	}

Modified: trunk/source/sc2ships/shpchmav.cpp
===================================================================
--- trunk/source/sc2ships/shpchmav.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shpchmav.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -66,6 +66,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code) 
 	{
+  STACKTRACE;
 
 	weaponRange  = scale_range(get_config_float("Weapon", "Range", 0));
 	weaponDamage = get_config_int("Weapon", "Damage", 0);
@@ -86,6 +87,7 @@
 
 void ChmmrAvatar::calculate()
 {
+  STACKTRACE;
 	Ship::calculate();
 	
 	if ((uninterrupted_fire) && ((!fire_weapon) || weapon_low))
@@ -101,6 +103,7 @@
 
 int ChmmrAvatar::activate_weapon()
 {
+  STACKTRACE;
 	add(new ChmmrLaser(angle, weaponRange, weaponDamage, weapon_rate, this, Vector2(0.0, 25.0) ));
 	if (tw_random(150) < frame_time) {
 		add(new Animation(this, 
@@ -122,6 +125,7 @@
 
 int ChmmrAvatar::activate_special()
 {
+  STACKTRACE;
 	if (target && target->exists() && (!target->isInvisible()) && (target->mass > 0) && (distance(target) < specialRange)) {
 		add(new ChmmrBeam(this, special_rate));
 		target->accelerate(this, target->trajectory_angle(this), specialForce / target->mass, MAX_SPEED);
@@ -132,6 +136,7 @@
 
 void ChmmrAvatar::materialize()
 {
+  STACKTRACE;
 	Ship::materialize();
 	add(new ChmmrZapSat(0.0, extraRange,
 		extraDamage, extraFrames, extraRechargeRate, extraColor, extraArmour, this,
@@ -150,6 +155,7 @@
 	Laser(opos, langle, pallete_color[hot_color[random() % HOT_COLORS]], lrange,
 	ldamage, lfcount, opos, rel_pos, true)
 {
+  STACKTRACE;
 }
 
 ChmmrBeam::ChmmrBeam(Ship *oship, int oframes) :
@@ -160,6 +166,7 @@
 	ship(oship),
 	target(oship->target)
 {
+  STACKTRACE;
 	set_depth(DEPTH_HOTSPOTS);
 	collide_flag_anyone = 0;
 	if(!(ship && ship->exists())) {
@@ -176,6 +183,7 @@
 
 void ChmmrBeam::calculate()
 {
+  STACKTRACE;
 
 	SpaceLocation::calculate();
 
@@ -201,6 +209,7 @@
 
 void ChmmrBeam::animate(Frame *space)
 {
+  STACKTRACE;
 	const int beam_color[5] = { 80, 81, 82, 83, 84 };
 	int i;//, old_trans;
 	double length = target->get_vel().length() + (target->get_size().x / 4.0);
@@ -235,6 +244,7 @@
   lColor(ocolor),
   armour(oarmour)
 {
+  STACKTRACE;
 	layer = LAYER_SPECIAL;
 	set_depth(DEPTH_SPECIAL);
 	collide_flag_anyone = ALL_LAYERS &~ bit(LAYER_CBODIES);
@@ -254,6 +264,7 @@
 }
 
 void ChmmrZapSat::calculate() {
+  STACKTRACE;
 
 	SpaceObject::calculate();
 
@@ -298,11 +309,13 @@
 	return;
 	}
 int ChmmrZapSat::canCollide(SpaceLocation *other) {
+  STACKTRACE;
 	if (!other->damage_factor) return false;
 	return SpaceObject::canCollide(other);
 	}
 
 int ChmmrZapSat::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	int total = iround(normal + direct);
 	if (total) {
 		armour -= total;

Modified: trunk/source/sc2ships/shpdruma.cpp
===================================================================
--- trunk/source/sc2ships/shpdruma.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shpdruma.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -36,6 +36,7 @@
 	ShipData *shipData, unsigned int code)
 	:
 	Ship(opos, shipAngle, shipData, code) {
+  STACKTRACE;
 
   weaponRange         = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity      = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -46,6 +47,7 @@
 
 
 int DruugeMauler::activate_weapon() {
+  STACKTRACE;
 	accelerate (this, angle + PI, weaponDriftVelocity / mass, MAX_SPEED);
 	add(new DruugeMissile(
 			Vector2(0.0, (get_size().y /*height()*/ / 2.0)), angle, weaponVelocity, weaponDamage,
@@ -56,6 +58,7 @@
 
 
 void DruugeMauler::calculate_fire_special() {
+  STACKTRACE;
   if((fire_special) && (crew > 1) && (batt < batt_max) &&
     (special_recharge <= 0)) {
 
@@ -77,6 +80,7 @@
   Missile(oship, opos, oangle, ov, odamage, orange, oarmour, oship, osprite),
   kick(weaponDriftVelocity)
 {
+  STACKTRACE;
   explosionSprite     = data->spriteWeaponExplosion;
   explosionFrameCount = 5;
   explosionFrameSize  = 50;

Modified: trunk/source/sc2ships/shpkohma.cpp
===================================================================
--- trunk/source/sc2ships/shpkohma.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shpkohma.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -55,6 +55,7 @@
 };
 
 void KohrAhFRIED::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if ((other->getID() &~ SPACE_MASK) == CHMMR_SPEC) other->state = 0;
 	Shot::inflict_damage(other);
 	return;
@@ -64,6 +65,7 @@
 	ShipData *shipData, unsigned int code)
 	:
 	Ship(opos, shipAngle, shipData, code) {
+  STACKTRACE;
 	weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
 	weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
 	weaponDamage   = get_config_int("Weapon", "Damage", 0);
@@ -85,6 +87,7 @@
 	}
 
 int KohrAhMarauder::activate_weapon() {
+  STACKTRACE;
 	if (weaponFired) return(FALSE);
 	if (numblades == maxblades) {
 		weaponObject[0]->state = 0;
@@ -104,6 +107,7 @@
 	}
 
 int KohrAhMarauder::activate_special() {
+  STACKTRACE;
 	int i;
 	for(i = 0; i < 16; i++) {
 		add(new KohrAhFRIED(
@@ -114,6 +118,7 @@
 	}
 
 void KohrAhMarauder::calculate() {
+  STACKTRACE;
 	Ship::calculate();
 	
 	if (!fire_weapon) {
@@ -145,12 +150,14 @@
   passive(FALSE),
   passiveRange(orange)
 {
+  STACKTRACE;
   explosionSprite     = data->spriteWeaponExplosion;
   explosionFrameCount = 20;
   explosionFrameSize  = 40;
 }
 
 void KohrAhBlade::calculate() {
+  STACKTRACE;
 	SpaceObject *o, *t = NULL;
 	double oldrange = 999999;
 
@@ -185,12 +192,14 @@
 
 void KohrAhBlade::animateExplosion()
 {
+  STACKTRACE;
   add(new KohrAhBladeDecay(this, pos,
     vel, explosionSprite, explosionFrameCount, explosionFrameSize));
 }
 
 void KohrAhBlade::disengage()
 {
+  STACKTRACE;
   passive = TRUE;
 }
 
@@ -198,6 +207,7 @@
   SpaceSprite *osprite, int ofcount, int ofsize) :
   Animation(creator, opos, osprite, 0, ofcount, ofsize, DEPTH_EXPLOSIONS)
 {
+  STACKTRACE;
 //  vx = ovx / 2;
 //  vy = ovy / 2;
   vel = 0.5 * ovel;
@@ -209,12 +219,14 @@
   Shot(oship, Vector2(0.0, 0.0), oangle, ov, odamage, orange, oarmour, oship, osprite, 1.0),
   frame_count(ofcount)
 {
+  STACKTRACE;
 //  x += cos(angle) * 50.0;
 //  y += sin(angle) * 50.0;
   pos += 50.0 * unit_vector(angle);
 }
 
 void KohrAhFRIED::calculate() {
+  STACKTRACE;
   sprite_index = (int)((d / range) * (double)(frame_count - 1));
   Shot::calculate();
 }

Modified: trunk/source/sc2ships/shpmeltr.cpp
===================================================================
--- trunk/source/sc2ships/shpmeltr.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shpmeltr.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -75,6 +75,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponRangeUp  = scale_range(get_config_float("Weapon", "RangeUp", 0));
@@ -91,6 +92,7 @@
 
 void MelnormeTrader::calculate()
 {
+  STACKTRACE;
   Ship::calculate();
   if (weaponObject) {
     if (!weaponObject->exists()) weaponObject = NULL;
@@ -100,6 +102,7 @@
 
 int MelnormeTrader::activate_weapon()
 {
+  STACKTRACE;
   if(weaponObject)
     return(FALSE);
   add(weaponObject = new MelnormeShot(
@@ -109,6 +112,7 @@
 }
 
 int MelnormeTrader::activate_special() {
+  STACKTRACE;
   add( new MelnormeSpecial(
     Vector2(0.0, get_size().y /*(height()*/ / 2.0), angle, specialVelocity, specialFrames,
     specialRange, specialArmour, this, data->spriteSpecial, 20, 50));
@@ -128,7 +132,8 @@
   charge_phase(0),
   released(FALSE),
 	RangeUp(rangeup)
-{  
+{
+  STACKTRACE;  
 //  vx = ship->get_vx();
 //  vy = ship->get_vy();
   vel = ship->get_vel();
@@ -137,6 +142,7 @@
 
 void MelnormeShot::calculate() 
 {
+  STACKTRACE;
   if(released) 
     {
       Shot::calculate();
@@ -191,6 +197,7 @@
 
 void MelnormeShot::animateExplosion()
 {
+  STACKTRACE;
   add( new Animation(this, pos,
     data->spriteWeaponExplosion, (charge_phase * 20), 20, 25, 
     DEPTH_EXPLOSIONS));
@@ -198,6 +205,7 @@
 
 int MelnormeShot::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   int old = iround(armour);
   Shot::handle_damage(source, normal, direct);
   if (!released && (armour > 0)) armour = old;
@@ -206,6 +214,7 @@
 
 void MelnormeShot::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
 	if (!other->exists()) return;
 	damage(other, damage_factor);
 
@@ -230,11 +239,13 @@
   frame_size(ofsize),
   frame_count(ofcount)
 {
+  STACKTRACE;
 	collide_flag_anyone = 0;
 	set_depth(DEPTH_EXPLOSIONS);
 }
 
 void MelnormeDisable::calculate() {
+  STACKTRACE;
 	frame_step+= frame_time;
 	while (frame_step >= frame_size) {
 		frame_step -= frame_size;
@@ -266,12 +277,15 @@
   disableFrames(oframes),
   disableSprite(data->spriteExtra)
 {
+  STACKTRACE;
 	collide_flag_anyone = bit(LAYER_SHIPS);
 }
 
-void MelnormeSpecial::animateExplosion() {}
+void MelnormeSpecial::animateExplosion() {
+  STACKTRACE;}
 
 void MelnormeSpecial::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if (other->isShip()) add(new MelnormeDisable( ship, 
 			(Ship *)(other), disableSprite, 20, 50, disableFrames));
 	state = 0;

Modified: trunk/source/sc2ships/shporzne.cpp
===================================================================
--- trunk/source/sc2ships/shporzne.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shporzne.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -58,6 +58,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   int i;
 
 	absorption = 0;
@@ -91,18 +92,21 @@
 
 void OrzNemesis::calculate_turn_left()
 {
+  STACKTRACE;
   if(!fire_special)
     Ship::calculate_turn_left();
 }
 
 void OrzNemesis::calculate_turn_right()
 {
+  STACKTRACE;
   if(!fire_special)
     Ship::calculate_turn_right();
 }
 
 int OrzNemesis::activate_weapon()
 {
+  STACKTRACE;
   if(fire_special)
     return(FALSE);
   add(new OrzMissile(
@@ -116,6 +120,7 @@
 
 int OrzNemesis::activate_special()
 {
+  STACKTRACE;
   if(turn_left && (recoil<=0))
     turret_turn_step -= frame_time * turret_turn_rate;
   if(turn_right && (recoil<=0))
@@ -151,6 +156,7 @@
 
 void OrzNemesis::calculate()
 {
+  STACKTRACE;
   int i;
 
   for(i = 0; i < MAX_MARINES; i++)
@@ -164,6 +170,7 @@
 
 void OrzNemesis::animate(Frame *space)
 {
+  STACKTRACE;
 	double rec;
 	int turret_index;
 	/*
@@ -193,6 +200,7 @@
   Missile(oship, Vector2(0.0, 0.0), oangle, ov, odamage, orange, oarmour, oship,
     osprite)
 {
+  STACKTRACE;
 //  x += cos(angle) * 30.0;
 //  y += sin(angle) * 30.0;
   pos += 30.0 * unit_vector(angle);
@@ -219,6 +227,7 @@
   slot(oSlot),
   damage_frame(-1)
 {
+  STACKTRACE;
 		layer = LAYER_SPECIAL;
 		set_depth(DEPTH_SPECIAL);
         mass = 0.001;
@@ -230,6 +239,7 @@
 
 void OrzMarine::calculate() 
 {
+  STACKTRACE;
   int    chance;
 
   if (!(orzship && orzship->exists()))
@@ -365,11 +375,13 @@
 
 void OrzMarine::animate(Frame *space)
 {
+  STACKTRACE;
   if (!invading) SpaceObject::animate(space);
 }
 
 void OrzMarine::inflict_damage(SpaceObject *other) 
 {
+  STACKTRACE;
   if (other->isShip() && (!returning) && (!other->sameTeam(this)) && (!other->isProtected()))
     {
       invading = (Ship *) other;
@@ -396,6 +408,7 @@
 
 int OrzMarine::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   int total = iround(normal + direct);
   armour -= total;
   if(armour <= 0)

Modified: trunk/source/sc2ships/shppkufu.cpp
===================================================================
--- trunk/source/sc2ships/shppkufu.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shppkufu.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -30,6 +30,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -42,6 +43,7 @@
 
 int PkunkFury::handle_damage(SpaceLocation *source, double normal, double direct) 
 {
+  STACKTRACE;
   int r = iround(normal + direct);
   crew -= r;
   if (crew > 0) 
@@ -146,6 +148,7 @@
 
 int PkunkFury::activate_weapon()
 {
+  STACKTRACE;
   add(new AnimatedShot(this, 
     Vector2(0.0, (get_size().y / 2.0)), angle, weaponVelocity, weaponDamage, weaponRange,
     weaponArmour, this, data->spriteWeapon, 10, 1, 1.0));
@@ -161,6 +164,7 @@
 
 void PkunkFury::calculate_fire_special()
 {
+  STACKTRACE;
   if(fire_special) 
     {
       if((special_recharge > 0) || (batt >= batt_max))

Modified: trunk/source/sc2ships/shpslypr.cpp
===================================================================
--- trunk/source/sc2ships/shpslypr.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shpslypr.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -25,6 +25,7 @@
 
 int SlylandroProbe::accelerate_gravwhip(SpaceLocation *source, double angle, double velocity, 
 										 double max_speed) {
+  STACKTRACE;
 	if (source == this) 
 		return Ship::accelerate(source, angle, velocity, max_speed);
 	return false;
@@ -67,6 +68,7 @@
 thrustActive(FALSE),
 thrustForward(TRUE)
 {
+  STACKTRACE;
 	sprite_index2 = random() & 63;
 	segment_length = get_config_int("Weapon", "SegmentLength",0);
 	segment_dispersion = get_config_int("Weapon", "SegmentLengthDispersion",0);
@@ -86,12 +88,14 @@
 
 RGB SlylandroProbe::crewPanelColor(int k)
 {
+  STACKTRACE;
 	RGB c = {64,64,64};
 	return c;
 }
 
 void SlylandroProbe::calculate_turn_left()
 {
+  STACKTRACE;
 	if ( turn_left )
 	{
 		if (!last_turn_left)
@@ -110,6 +114,7 @@
 
 void SlylandroProbe::calculate_turn_right()
 {
+  STACKTRACE;
 	if ( turn_right )
 	{
 	if (!last_turn_right)
@@ -129,6 +134,7 @@
 
 void SlylandroProbe::calculate()
 {
+  STACKTRACE;
   if (!(SlyLaser && SlyLaser->exists()) )
     SlyLaser = 0;
 
@@ -177,11 +183,14 @@
 }
 
 void SlylandroProbe::calculate_hotspots() {
+  STACKTRACE;
 }
 void SlylandroProbe::calculate_fire_special() {
+  STACKTRACE;
 	return;
 }
 void SlylandroProbe::calculate_thrust() {
+  STACKTRACE;
 	if (thrust && !thrustActive) {
 		angle = angle + PI;
 		if (angle > PI2) angle -= PI2;
@@ -194,7 +203,8 @@
 }
 
 int SlylandroProbe::activate_weapon()
-{	
+{
+  STACKTRACE;	
 	SpaceLocation *t = NULL;
 	double r = 99999;
 	int i;
@@ -220,6 +230,7 @@
 
 SlylandroLaserNew::SlylandroLaserNew(SpaceLocation *lroot, SpaceLocation *ltarget)
 {
+  STACKTRACE;
 	
 	max_length = 400.0;
 	existtime = 1200.0;		// in milliseconds ?
@@ -245,6 +256,7 @@
 
 void SlylandroLaserNew::calculate()
 {
+  STACKTRACE;
 	lifetime += frame_time;
 
 	if ( lifetime > existtime || !(mother && mother->exists()) )
@@ -452,6 +464,7 @@
 
 void SlylandroLaserNew::animate(Frame *frame)
 {
+  STACKTRACE;
 	int i, iline;
 	
 	if ( !(mother && mother->exists()) )

Modified: trunk/source/sc2ships/shpsupbl.cpp
===================================================================
--- trunk/source/sc2ships/shpsupbl.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shpsupbl.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -24,6 +24,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -33,6 +34,7 @@
 
 void SupoxBlade::calculate_thrust()
 {
+  STACKTRACE;
 
   if(thrust || ((fire_special) && (turn_left || turn_right || thrust))) {
     if((fire_special) && (turn_left)) {
@@ -53,31 +55,36 @@
 
 void SupoxBlade::calculate_turn_left()
 {
+  STACKTRACE;
   if(!fire_special)
     Ship::calculate_turn_left();
 }
 
 void SupoxBlade::calculate_turn_right()
 {
+  STACKTRACE;
   if(!fire_special)
     Ship::calculate_turn_right();
 }
 
 void SupoxBlade::calculate_hotspots()
 {
+  STACKTRACE;
   if(!fire_special)
     Ship::calculate_hotspots();
 }
 
 int SupoxBlade::activate_weapon()
 {
+  STACKTRACE;
   add(new Missile(this, Vector2(0.0, 0.5*get_size().y / 2.0),
     angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
     this, data->spriteWeapon));
   return(TRUE);
 }
 
-void SupoxBlade::calculate_fire_special() {}
+void SupoxBlade::calculate_fire_special() {
+  STACKTRACE;}
 
 
 

Modified: trunk/source/sc2ships/shpthrto.cpp
===================================================================
--- trunk/source/sc2ships/shpthrto.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shpthrto.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -35,6 +35,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -47,6 +48,7 @@
 }
 
 int ThraddashTorch::activate_weapon() {
+  STACKTRACE;
   add(new Missile(this, Vector2(0.0, 0.5*get_size().y),
     angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
     this, data->spriteWeapon));
@@ -54,6 +56,7 @@
 }
 
 int ThraddashTorch::activate_special() {
+  STACKTRACE;
 	accelerate(this, angle, specialThrust, MAX_SPEED);
   add(new ThraddashFlame(
 //    x ,//- cos(angle) * (width() / 2.0),
@@ -65,6 +68,7 @@
 
 void ThraddashTorch::calculate_thrust()
 {
+  STACKTRACE;
 	if(special_recharge <= 0) Ship::calculate_thrust();
 }
 
@@ -73,6 +77,7 @@
   Animation(oship, opos, osprite, 0, ofcount, ofsize, DEPTH_SHOTS),
   armour(oarmour)
 {
+  STACKTRACE;
 	  layer = LAYER_SHOTS;
 	collide_flag_anyone = ALL_LAYERS;
 	collide_flag_sameteam = ALL_LAYERS;
@@ -89,10 +94,12 @@
 
 void ThraddashFlame::calculate()
 {
+  STACKTRACE;
 	Animation::calculate();
 }
 
 int ThraddashFlame::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	int total = iround(normal + direct);
 	armour -= total;
 

Modified: trunk/source/sc2ships/shputwju.cpp
===================================================================
--- trunk/source/sc2ships/shputwju.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shputwju.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -26,6 +26,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -36,6 +37,7 @@
 
 void UtwigJugger::calculate()
 {
+  STACKTRACE;
         Ship::calculate();
         if (!fire_special)
                 special_recharge = 0;
@@ -43,6 +45,7 @@
 
 void UtwigJugger::calculate_fire_weapon()
 {
+  STACKTRACE;
   weapon_low = FALSE;
 
   if(fire_weapon) {
@@ -78,6 +81,7 @@
 
 void UtwigJugger::animate(Frame *space) 
 {
+  STACKTRACE;
   if (special_recharge > 0) 
     {
       sprite->animate_character(pos, sprite_index, 
@@ -90,6 +94,7 @@
 
 int UtwigJugger::handle_damage(SpaceLocation *source, double normal, double direct) 
 {
+  STACKTRACE;
   if (special_recharge > 0) 
     {
       batt += normal;

Modified: trunk/source/sc2ships/shpzfpst.cpp
===================================================================
--- trunk/source/sc2ships/shpzfpst.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shpzfpst.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -55,6 +55,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -65,6 +66,7 @@
 }
 
 int ZoqFotPikStinger::activate_weapon() {
+  STACKTRACE;
   add(new ZoqFotPikShot(
     Vector2(0.0, 0.5*get_size().y), angle + ANGLE_RATIO * random(-10.0, 10.0),
     weaponVelocity, weaponDamage, weaponRange, weaponArmour, this,
@@ -74,6 +76,7 @@
 
 int ZoqFotPikStinger::activate_special()
 {
+  STACKTRACE;
   add(new ZoqFotPikTongue(
     39, specialDamage, this, data->spriteSpecial, 6, 50));
   return(TRUE);
@@ -85,10 +88,12 @@
   Shot(oship, opos, oangle, ov, odamage, orange, oarmour, oship, osprite),
   frame_count(num_frames)
 {
+  STACKTRACE;
 }
 
 void ZoqFotPikShot::calculate()
 {
+  STACKTRACE;
   Shot::calculate();
   sprite_index = (int)((d / range) * (double)(frame_count - 1));
 }
@@ -105,6 +110,7 @@
   frame_count(ofcount),
   frame_step(0)
 {
+  STACKTRACE;
   layer = LAYER_SHOTS;
   set_depth(DEPTH_SHOTS);
   damage_factor = abs(lick_factor);
@@ -121,6 +127,7 @@
 
 void ZoqFotPikTongue::calculate()
 {
+  STACKTRACE;
   int current_frame = frame;
 
   if (!(ship && ship->exists()))
@@ -153,6 +160,7 @@
 
 void ZoqFotPikTongue::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   SpaceObject::inflict_damage(other); 
   damage_factor = 0;
 

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/scp.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -60,6 +60,7 @@
 
 std::string tw_version() 
 {
+  STACKTRACE;
   std::string tw_version_string;
 	
   tw_version_string += std::string(APPLICATION_NAME) + " "  + std::string(TW_MAJOR_VERSION) 
@@ -121,6 +122,7 @@
 
 Log *new_log (int logtype) 
 {
+  STACKTRACE;
   union 
   { 
     Log *log; 
@@ -153,6 +155,7 @@
 
 char *detect_gametype( Log *_log ) 
 {
+  STACKTRACE;
   int ltype;
   _log->unbuffer(Game::channel_init, &ltype, sizeof(int));
   ltype = intel_ordering(ltype);
@@ -186,6 +189,7 @@
 */
 void prepareTitleScreenAssets() 
 {
+  STACKTRACE;
   titleMusic = data_full_path("music/Robeter-Space-Gods-Loop.ogg");
   tw_sound.play_music(titleMusic);
 
@@ -197,60 +201,36 @@
   titlePic = load_bitmap(data_full_path("images/scptitle.jpg").c_str(), NULL);
 }
 
-/*! \brief clears the screen, and displays a loading message to the user.
-*/
-void showLoadingScreen() {
+/// clears the screen, and displays a loading message to the user.
+void showLoadingScreen() 
+{
   STACKTRACE;
-
-  static BITMAP * logo = NULL;
-  static int depth = bitmap_color_depth(screen);
   
+  std::vector<std::string> waitpics;
+  waitpics.push_back(data_full_path("images/bspab.jpg"));
+  waitpics.push_back(data_full_path("images/stangrop.jpg"));
+  
   acquire_screen(); 
   clear_to_color(screen, 0);
-  
-  if (NULL == logo || bitmap_color_depth(screen) != depth) 
-    {
-      depth = bitmap_color_depth(screen);
-      
-      BITMAP * temp = load_bitmap(data_full_path("images/logo.bmp").c_str(),NULL);
-      logo = create_bitmap(temp->w, temp->h);
-      blit(temp, logo, 0,0, 0,0, temp->w, temp->h);
-      destroy_bitmap(temp);
-    }
-  
-  if (logo != NULL ) {
-    if (screen->w/2 >= logo->w) {
-      draw_sprite(screen, logo, screen->w/2 - logo->w/2, screen->h/2 - logo->h/2);
-    }
-    else {
-      float ratio = logo->w / logo->h;
-      
-      int h = screen->h/4;
-      int w = iround(ratio * h);                
-      
-      stretch_blit(logo, screen, 
-		   0,0, 
-		   logo->w, logo->h,
-		   screen->w/2 - w/2, screen->h/2 - h/2,
-		   w, h);
-    }
-  }
+ 
+  int pic = rand()%waitpics.size();
 
-  const char * loadString = "Loading...";
-  textout_right(screen, font, loadString, 
-		screen->w - 1*text_length(font, loadString), screen->h - 4*text_height(font), 
-		palette_color[15]);
+  BITMAP * temp = load_bitmap(waitpics[pic].c_str(), NULL);
+  stretch_blit(temp, screen, 0, 0, temp->w, temp->h, 0, 0, screen->w, screen->h);
+  destroy_bitmap(temp);
   release_screen();
 }
 
 int is_escape_pressed() 
 {
+  STACKTRACE;
   poll_keyboard();
   return key[KEY_ESC];
 }
 
 void play_game(const char *_gametype_name, Log *_log) 
 {
+  STACKTRACE;
   char gametype_name[1024];
   char *c;
   Game *new_game = NULL;
@@ -357,7 +337,9 @@
 int *player_config = NULL;
 int *player_team = NULL;
 
-Control *load_player(int i) {STACKTRACE
+Control *load_player(int i) 
+{
+  STACKTRACE;
 	char tmp[32];
 	Control *r = NULL;
 
@@ -371,7 +353,8 @@
 }
 
 
-class MainMenu : public BaseClass {
+class MainMenu : public BaseClass 
+{
 	public:
 	virtual void _event(Event * e);
 	virtual void preinit();
@@ -384,99 +367,117 @@
 	VideoWindow *window;
 } mainmenu;
 
-void MainMenu::_event(Event *e) {
+void MainMenu::_event(Event *e) 
+{
   STACKTRACE;
+		   
 	if (e->type == Event::VIDEO) {
 		if (e->subtype == VideoEvent::REDRAW) if (state & 1) showTitle();
 	}
 }
 
-void MainMenu::enable() {STACKTRACE
+void MainMenu::enable() 
+{
+  STACKTRACE;
+		   
 	if (!(state & 2)) window->add_callback(this);
 	state |= 3;
 }
 
-void MainMenu::disable() {STACKTRACE
-	state &=~ 1;
+void MainMenu::disable() 
+{
+  STACKTRACE;
+		   
+  state &=~ 1;
 }
 
-void MainMenu::preinit() {
-	window = NULL;
-	state = 0;
+void MainMenu::preinit() 
+{
+  STACKTRACE; 
+  window = NULL;
+  state = 0;
 }
 
-void MainMenu::init(VideoWindow *parent) {
-	if (window) window->init(parent);
-	else {
+void MainMenu::init(VideoWindow *parent) 
+{
+  STACKTRACE; 
+  if (window) window->init(parent);
+  else {
 		window = new VideoWindow();
 		window->preinit();
 		window->init(parent);
 	}
 }
 
-void MainMenu::deinit() {
-	STACKTRACE
-	if (state & 2) {
-		window->remove_callback(this);
-		window->deinit();
-		delete window;
-		window = NULL;
-	}
+void MainMenu::deinit() 
+{
+  STACKTRACE;   
+		   
+  if (state & 2) 
+    {
+      window->remove_callback(this);
+      window->deinit();
+      delete window;
+      window = NULL;
+    }
 }
 
-void MainMenu::doit() {STACKTRACE
-	int i;
-	char tmp[32];
-
-	tw_set_config_file("scp.ini");
-	if (!player_type) {		
-		MAX_PLAYERS        = get_config_int("Limits", "MaxPlayers", 12);
-		MAX_CONFIGURATIONS = get_config_int("Limits", "MaxConfigurations", 4);
-		MAX_TEAMS          = get_config_int("Limits", "MaxTeams", 6);
-		player_type = new char*[MAX_PLAYERS];
-		player_config = new int[MAX_PLAYERS];
-		player_team   = new int[MAX_PLAYERS];
-	}
-	for (i = 0; i < MAX_PLAYERS; i += 1) {
-		sprintf(tmp, "Player%d", i+1);
-		player_type[i] = strdup(get_config_string(tmp, "Type", "Human"));
-		player_config[i] = get_config_int (tmp, "Config", i % MAX_CONFIGURATIONS);
-		player_team[i] = get_config_int (tmp, "Team", 0);
-	}
-
-    prepareTitleScreenAssets();
-	showTitle();
-	enable();
-
-	int mainRet;
-	do {
-		//mainRet = popup_dialog(mainDialog, MAIN_DIALOG_MELEE);
-		mainRet = tw_do_dialog(window, mainDialog, MAIN_DIALOG_MELEE);
-		switch (mainRet) {
-			case MAIN_DIALOG_MELEE:
-				disable();
-				play_game("Melee");
-				enable();
-				break;
-			case MAIN_DIALOG_MELEE_EXTENDED:
-				disable();
-				extended_menu();
-				enable();
-				break;
-			case MAIN_DIALOG_OPTIONS:
-				showTitle();
-				options_menu(NULL);
-				break;
-			case MAIN_DIALOG_HELP:
-				show_file(data_full_path("ingame.txt").c_str());
-				break;
-			case MAIN_DIALOG_TEAMS:
-				change_teams();
-				showTitle();
-				break;
-		}
-	} while((mainRet != MAIN_DIALOG_EXIT) && (mainRet != -1));
-
+void MainMenu::doit() 
+{
+  STACKTRACE;
+		   
+  int i;
+  char tmp[32];
+  
+  tw_set_config_file("scp.ini");
+  if (!player_type) {		
+    MAX_PLAYERS        = get_config_int("Limits", "MaxPlayers", 12);
+    MAX_CONFIGURATIONS = get_config_int("Limits", "MaxConfigurations", 4);
+    MAX_TEAMS          = get_config_int("Limits", "MaxTeams", 6);
+    player_type = new char*[MAX_PLAYERS];
+    player_config = new int[MAX_PLAYERS];
+    player_team   = new int[MAX_PLAYERS];
+  }
+  for (i = 0; i < MAX_PLAYERS; i += 1) {
+    sprintf(tmp, "Player%d", i+1);
+    player_type[i] = strdup(get_config_string(tmp, "Type", "Human"));
+    player_config[i] = get_config_int (tmp, "Config", i % MAX_CONFIGURATIONS);
+    player_team[i] = get_config_int (tmp, "Team", 0);
+  }
+  
+  prepareTitleScreenAssets();
+  showTitle();
+  enable();
+  
+  int mainRet;
+  do {
+    //mainRet = popup_dialog(mainDialog, MAIN_DIALOG_MELEE);
+    mainRet = tw_do_dialog(window, mainDialog, MAIN_DIALOG_MELEE);
+    switch (mainRet) {
+    case MAIN_DIALOG_MELEE:
+      disable();
+      play_game("Melee");
+      enable();
+      break;
+    case MAIN_DIALOG_MELEE_EXTENDED:
+      disable();
+      extended_menu();
+      enable();
+      break;
+    case MAIN_DIALOG_OPTIONS:
+      showTitle();
+      options_menu(NULL);
+      break;
+    case MAIN_DIALOG_HELP:
+      show_file(data_full_path("ingame.txt").c_str());
+      break;
+    case MAIN_DIALOG_TEAMS:
+      change_teams();
+      showTitle();
+      break;
+    }
+  } while((mainRet != MAIN_DIALOG_EXIT) && (mainRet != -1));
+  
 }
 
 int tw_main(int argc, char *argv[]);
@@ -511,7 +512,7 @@
   strncpy(datapath, argv[0], i);
   chdir(datapath);
 #endif
-  
+
   log_debug(NULL);
   time_t start_time = time(NULL);
   log_debug("Log started at %s\n", asctime(localtime(&start_time)));

Modified: trunk/source/ships/shpaktgu.cpp
===================================================================
--- trunk/source/ships/shpaktgu.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpaktgu.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -89,6 +89,7 @@
 Ship(opos, shipAngle, shipData, shipCollideFlag)
 
 {
+  STACKTRACE;
 	weaponColor  = get_config_int("Weapon", "Color", 0);
 	weaponRange1  = scale_range(get_config_float("Weapon", "Range1", 0));
 	weaponDamage = get_config_int("Weapon", "Damage", 0);
@@ -119,6 +120,7 @@
 
 int AktunGunner::activate_weapon()
 {
+  STACKTRACE;
 	if(fire_special)
 		return(FALSE);
 
@@ -141,6 +143,7 @@
 
 int AktunGunner::activate_special()
 {
+  STACKTRACE;
 //	if ((fire_weapon) && (batt >= extraDrain))
 //	{
 		if (num_ComSats == max_ComSats) {
@@ -174,10 +177,12 @@
 	  ldamage, lfcount, opos, relpos, true),
 	  owner(lowner)
 {
+  STACKTRACE;
 }
 
 void AktunLaser::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   tw_sound.stop_sound(data_full_path(owner->data->sampleWeapon[0]));
   Laser::inflict_damage(other);
   tw_sound.play_sound(data_full_path(owner->data->sampleWeapon[1]));
@@ -197,6 +202,7 @@
   lColor(ocolor),
   armour(oarmour)
 {
+  STACKTRACE;
   layer = LAYER_SPECIAL;
   collide_flag_anyone = ALL_LAYERS - bit(LAYER_CBODIES);
   angle = oangle;
@@ -205,6 +211,7 @@
 }
 
 void AktunComSat::calculate() {
+  STACKTRACE;
   
   if(!(ship && ship->exists())) 
     {
@@ -254,11 +261,13 @@
 
 int AktunComSat::canCollide(SpaceLocation *other) 
 {
+  STACKTRACE;
   return SpaceObject::canCollide(other);
 }
 
 int AktunComSat::handle_damage(SpaceLocation* source, double normal, double direct)
 {
+  STACKTRACE;
   double tot;
   tot = normal+direct;
   if ( tot > 0 ) 
@@ -280,6 +289,7 @@
 
 void AktunComSat::death() 
 {
+  STACKTRACE;
   for (int i = 0; i < ((AktunGunner*)ship)->num_ComSats; i++ ) 
     {
       if (((AktunGunner*)ship)->ComSat[i] == this) 

Modified: trunk/source/ships/shpalabc.cpp
===================================================================
--- trunk/source/ships/shpalabc.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpalabc.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -218,6 +218,7 @@
 
 void AlaryBC::calculate()
 {
+  STACKTRACE;
   update_panel = true;
 
   if (crew <= 0) 
@@ -323,6 +324,7 @@
 
 int AlaryBC::activate_weapon()
 {
+  STACKTRACE;
   if (crew <= 0) return false;
   
   game->add(new AlaryBCTorpedo(this, 30*side, 0, angle, 
@@ -338,6 +340,7 @@
 
 void AlaryBC::calculate_fire_special()
 {
+  STACKTRACE;
   if (crew <= 0) return;
   
   if (fire_special && can_switch) 
@@ -350,6 +353,7 @@
 
 void AlaryBC::calculate_thrust()
 {
+  STACKTRACE;
   if (crew <= 0) 
     return;
   Ship::calculate_thrust();
@@ -357,6 +361,7 @@
 
 void AlaryBC::calculate_turn_left()
 {
+  STACKTRACE;
   if (crew <= 0) 
     return;
   if ((turn_left)&&(!turn_right))
@@ -365,6 +370,7 @@
 
 void AlaryBC::calculate_turn_right()
 {
+  STACKTRACE;
   if (crew <= 0) 
     return;
   if ((turn_right)&&(!turn_left))
@@ -373,6 +379,7 @@
 
 void AlaryBC::calculate_hotspots()
 {
+  STACKTRACE;
   if (crew <= 0) 
     return;
   if (engines_armour > 0) 
@@ -391,6 +398,7 @@
 
 void AlaryBC::animate(Frame *space)
 {
+  STACKTRACE;
   if (state == 0) 
     return;
   
@@ -462,6 +470,7 @@
 
 int AlaryBC::handle_damage(SpaceLocation* source, double normal, double direct)
 {
+  STACKTRACE;
   double total = 0;
   
   //	check for "repair"
@@ -598,12 +607,14 @@
 
 int AlaryBC::handle_fuel_sap(SpaceLocation *source, double normal)
 {
+  STACKTRACE;
   normal = (normal / extraFuelSapReduction);
   return Ship::handle_fuel_sap(source, normal);
 }
 
 double AlaryBC::handle_speed_loss(SpaceLocation *source, double normal)
 {
+  STACKTRACE;
   normal = normal / extraSpeedLossReduction;
   return Ship::handle_speed_loss(source, normal);
 }
@@ -623,6 +634,7 @@
   wh_damage(iround(wdamage)), wh_armour(iround(warmour)), wh_v(wv),
   wh_turn_rate(wtr), wh_range(wrange)
 {
+  STACKTRACE;
   target = otarget;
   layer = LAYER_SHOTS;
   set_depth(DEPTH_SHOTS);
@@ -641,6 +653,7 @@
 
 void AlaryBCTorpedo::calculate()
 {
+  STACKTRACE;
   SpaceObject::calculate();
   lifetime -= frame_time;
   if (lifetime < 0) 
@@ -711,6 +724,7 @@
 
 void AlaryBCTorpedo::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   if (other->isblockingweapons)
     {
       game->add(new Animation(this, pos, data->spriteWeaponExplosion, 0, 10, 50, DEPTH_EXPLOSIONS));
@@ -721,6 +735,7 @@
 
 int AlaryBCTorpedo::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   if (direct+normal > 0) 
     armour -= iround(direct+normal);
   if (armour <= 0) 
@@ -739,6 +754,7 @@
   HomingMissile(creator, Vector2(ox,oy), oangle, ov, odamage, orange, oarmour, 
 		otrate, creator, osprite, otarget)
 {
+  STACKTRACE;
   explosionSprite     = data->spriteExtraExplosion;
   explosionFrameCount = 10;
   explosionFrameSize  = 50;
@@ -750,6 +766,7 @@
 
 void AlaryBCWarhead::calculate()
 {
+  STACKTRACE;
   HomingMissile::calculate();
   
   while (smoke_frame <= 0) 
@@ -765,6 +782,7 @@
 
 void AlaryBCTurret::sinc_it()
 {
+  STACKTRACE;
   pos = normalize(ship->normal_pos() + rotate(Vector2(-rel_x, rel_y), -PI/2+ship->get_angle()));
   vel = ship->get_vel();
 }
@@ -801,6 +819,7 @@
 
 double AlaryBCTurret::get_aim(SpaceObject *tgt)
 {
+  STACKTRACE;
   if (tgt == NULL)
     return (-1);
   
@@ -853,6 +872,7 @@
 
 SpaceObject *AlaryBCTurret::get_target(SpaceObject *tgt)
 {
+  STACKTRACE;
   double d_a, prix=-1, prix_c, aim; //!!!
   Query q;
   SpaceObject *tgt0=tgt;
@@ -904,6 +924,7 @@
 
 void AlaryBCTurret::calculate()
 {
+  STACKTRACE;
   if (!(ship && ship->exists()))
     {
       ship = 0;
@@ -1030,6 +1051,7 @@
   Missile(creator, Vector2(ox,oy), oangle, ov, odamage, orange, oarmour, 
 	  creator, osprite, relativity)
 {
+  STACKTRACE;
   set_depth(DEPTH_SHIPS+0.25);
   collide_flag_sameship = 0;
   collide_flag_sameteam = 0;

Modified: trunk/source/ships/shpbahbu.cpp
===================================================================
--- trunk/source/ships/shpbahbu.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpbahbu.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -78,6 +78,7 @@
 BahaoidBuzzsaw::BahaoidBuzzsaw(Vector2 opos, double shipAngle, ShipData *shipData, int shipCollideFlag) :
 	Ship(opos, shipAngle, shipData, shipCollideFlag)
 {
+  STACKTRACE;
 
 	weaponRange		= scale_range(get_config_float("Weapon", "Range", 0));
 	weaponSpeed		= get_config_float("Weapon", "Speed", 1) * ANGLE_RATIO;
@@ -94,6 +95,7 @@
 
 void BahaoidBuzzsaw::calculate_turn_left()
 {
+  STACKTRACE;
 	if(can_turn)
 	{
 		Ship::calculate_turn_left();
@@ -102,6 +104,7 @@
 
 void BahaoidBuzzsaw::calculate_turn_right()
 {
+  STACKTRACE;
 	if(can_turn)
 	{
 		Ship::calculate_turn_right();
@@ -110,6 +113,7 @@
 
 int BahaoidBuzzsaw::activate_weapon()
 {
+  STACKTRACE;
 	double xone = 0.8660254038;
 	double yone = 0.5;
 
@@ -144,6 +148,7 @@
 
 int BahaoidBuzzsaw::activate_special()
 {
+  STACKTRACE;
 	if(nummines>=specialNumber) return(FALSE);
 
 	game->add(new BahaoidBabyBuzzsaw(0, 0, angle, 0, specialArmour, this,
@@ -155,6 +160,7 @@
 
 void BahaoidBuzzsaw::calculate()
 {
+  STACKTRACE;
 
 	if(fire_weapon)
 	{
@@ -176,6 +182,7 @@
     AnimatedShot(oship, opos, oangle, ov, odamage, -1.0, oarmour, oship,
       osprite, ofcount, ofsize)
 {
+  STACKTRACE;
 	weaponRange		= rangey;
 	weaponSpeed		= speedy;
 	weaponDamage	= damagey;
@@ -191,6 +198,7 @@
 
 int BahaoidBabyBuzzsaw::handle_damage(SpaceLocation* source, double normal, double direct)
 {
+  STACKTRACE;
 	armour -= normal + direct;
 	
 	if(armour <= 0)
@@ -203,6 +211,7 @@
 
 void BahaoidBabyBuzzsaw::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
 	if((ship) && (other == ship))
 	{
 		state = 0;
@@ -216,6 +225,7 @@
 
 void BahaoidBabyBuzzsaw::calculate()
 {
+  STACKTRACE;
 	SpaceObject *o, *t = NULL;
 	double oldrange = 999999;
 

Modified: trunk/source/ships/shpbipka.cpp
===================================================================
--- trunk/source/ships/shpbipka.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpbipka.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -106,6 +106,7 @@
 };
 
 SpaceLocation* BipoleKatamaran::get_ship_phaser() {
+  STACKTRACE;
   return new NullPhaser( this );
 }
 
@@ -113,6 +114,7 @@
   ShipData *shipData, unsigned int code) :
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   collide_flag_anyone = 0;
   collide_flag_sameteam = 0;
   collide_flag_sameship = 0;
@@ -157,7 +159,7 @@
 }
 
 int BipoleKatamaran::activate_weapon(){
-	STACKTRACE
+  STACKTRACE;
   if( !left || !right ) return FALSE;
   weapon_sample = random(11);
   int left_w = left->activate_weapon();
@@ -166,7 +168,7 @@
 }
 
 int BipoleKatamaran::activate_special(){
-	STACKTRACE
+  STACKTRACE;
   if( !left || !right ) return FALSE;
   if( range >= specialMaxRange ){
     range = specialMaxRange;
@@ -177,12 +179,13 @@
 }
 
 void BipoleKatamaran::animate(Frame* space){
+  STACKTRACE;
   /* we do not show */
   return;
 }
 
 void BipoleKatamaran::calculate(){
-	STACKTRACE
+  STACKTRACE;
   if( left ) if( !left->exists() ){
     left = NULL;
     if( right ){
@@ -320,7 +323,7 @@
 }
 
 void BipoleKatamaran::calculate_thrust(){
-	STACKTRACE
+  STACKTRACE;
   if( !left || !right ) return;
   if( left->thrust && !left->turn_left && !left->turn_right ){
     left->accelerate(this, angle, accel_rate * frame_time, speed_max);
@@ -330,7 +333,7 @@
   }
 }
 void BipoleKatamaran::calculate_turn_left(){
-	STACKTRACE
+  STACKTRACE;
   if( !left || !right ) return;
   if( left->turn_left ){
     left->nextkeys &= ~keyflag::thrust;
@@ -342,7 +345,7 @@
   }
 }
 void BipoleKatamaran::calculate_turn_right(){
-	STACKTRACE
+  STACKTRACE;
   if( !left || !right ) return;
   if( left->turn_right ){
     left->nextkeys |= keyflag::thrust;
@@ -355,11 +358,12 @@
 }
 
 void BipoleKatamaran::calculate_hotspots(){
+  STACKTRACE;
   return;
 }
 
 void BipoleKatamaran::materialize(){
-	STACKTRACE;
+  STACKTRACE;
 	
 //  int i;
 //  for( i = 0; game->target[i] != this; i++ );
@@ -373,7 +377,7 @@
 }
 
 void BipoleKatamaran::death(){
-	STACKTRACE
+  STACKTRACE;
 	// bug fix Geo.
 	// added exists(), because I *think* that the "invisible" ships can be destroyed
 	// by some field weapon ? At the same time, this field weapon can destroy the
@@ -387,6 +391,7 @@
   ShipData *shipData, unsigned int code, Ship* oparent, SpaceSprite* osprite) :
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   parent = oparent;
   sprite = osprite;
 
@@ -402,7 +407,7 @@
 }
 
 int BipoleShip::activate_weapon(){
-	STACKTRACE
+  STACKTRACE;
   shooting = !shooting;
   if( !shooting ) return FALSE;  // if we would return TRUE single ship would fire slower
 
@@ -414,7 +419,7 @@
 }
 
 int BipoleShip::activate_special(){
-	STACKTRACE
+  STACKTRACE;
 
 	if ( vel != 0 )
 	{
@@ -429,27 +434,28 @@
 }
 
 void BipoleShip::calculate_fire_weapon(){
-	STACKTRACE
+  STACKTRACE;
   if( !sibling ) Ship::calculate_fire_weapon();
 }
 void BipoleShip::calculate_fire_special(){
-	STACKTRACE
+  STACKTRACE;
   if( !sibling ) Ship::calculate_fire_special();
 }
 void BipoleShip::calculate_thrust(){
-	STACKTRACE
+  STACKTRACE;
   if( !sibling ) Ship::calculate_thrust();
 }
 void BipoleShip::calculate_turn_left(){
-	STACKTRACE
+  STACKTRACE;
   if( !sibling ) Ship::calculate_turn_left();
 }
 void BipoleShip::calculate_turn_right(){
-	STACKTRACE
+  STACKTRACE;
   if( !sibling ) Ship::calculate_turn_right();
 }
 
 /*void BipoleShip::calculate_hotspots() {
+  STACKTRACE;
   if( thrust &&( hotspot_frame <= 0 )){
     game->addItem(new Animation( this, 
       normal_x() - (cos(angle ) * w / 2.5),
@@ -461,7 +467,7 @@
 }*/
 
 int BipoleShip::handle_damage(SpaceLocation *source, double normal, double direct) {
-	STACKTRACE
+  STACKTRACE;
 	int s = exists();
 	int i = Ship::handle_damage(source, normal, direct);
 	if (s && !exists()) destroyed( source );
@@ -470,6 +476,7 @@
 
 void BipoleShip::destroyed( SpaceLocation* source )
 {
+  STACKTRACE;
   tw_sound.play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
   game->add(new Animation(this, pos,
 			  meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, LAYER_EXPLOSIONS));
@@ -478,6 +485,7 @@
 
 ShipType *BipoleShip::get_shiptype()
 {
+  STACKTRACE;
   // this is necessary, otherwise the Kat Poly ship crashes.
   // also, "type" cannot be redirected inside the constructor, cause the
   // parents' type is declared outside of its constructor (bad?).

Modified: trunk/source/ships/shpbogce.cpp
===================================================================
--- trunk/source/ships/shpbogce.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpbogce.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -179,6 +179,7 @@
 
 int BoggCenturion::activate_weapon()
 {
+  STACKTRACE;
   if ((gun_phase >= old_gun_phase) || (!gun_full_speed) || (delay_count < startup_delay))
     return false;
   
@@ -198,6 +199,7 @@
 
 void BoggCenturion::calculate_fire_special()
 {
+  STACKTRACE;
   special_low = FALSE;
   
   if(fire_special) 
@@ -239,6 +241,7 @@
 
 void BoggCenturion::calculate()
 {
+  STACKTRACE;
   Ship::calculate();
   
   if ((fire_weapon) && !( (batt < weapon_drain) || slowing_down)  ) {
@@ -280,6 +283,7 @@
 
 void BoggCenturion::animate(Frame* space)
 {
+  STACKTRACE;
   BITMAP *bmp;
   bmp = sprite->get_bitmap(64, 0);
   clear_to_color( bmp, makecol(255,0,255));
@@ -330,6 +334,7 @@
 
 void BoggCenturion::calculate_hotspots()
 {
+  STACKTRACE;
   if (draw_hotspots)
     Ship::calculate_hotspots();
   
@@ -356,6 +361,7 @@
 int BoggCenturion::handle_damage(SpaceLocation *source, double normal, double direct)
 //void BoggCenturion::handle_damage(SpaceLocation *source)
 {
+  STACKTRACE;
   if (source == this) {
     return Ship::handle_damage(source, normal, direct);
   }
@@ -425,6 +431,7 @@
 
 void BoggCenturionMissile::calculate()
 {
+  STACKTRACE;
   SpaceObject::calculate();
   if (lifetime > 0) 
     lifetime -= frame_time;
@@ -449,6 +456,7 @@
 
 void  BoggCenturionMissile::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   if ((!other->isPlanet()) && (other->mass))
     other->accelerate(this, normalize(trajectory_angle(other), 360), blast_accel/other->mass, blast_maxspeed);
   Missile::inflict_damage(other);
@@ -472,6 +480,7 @@
 
 void BoggCenturionExhaust::calculate()
 {
+  STACKTRACE;
   Animation::calculate();
   double gamma = exp( - slowdown * frame_time);
   vel *= gamma;
@@ -489,6 +498,7 @@
 
 void BoggCenturionExhaustShot::calculate()
 {
+  STACKTRACE;
   Shot::calculate();
   if (!amt->exists()) 
     state = 0;
@@ -499,10 +509,12 @@
 
 void BoggCenturionExhaustShot::animate(Frame *space)
 {
+  STACKTRACE;
 }
 
 void BoggCenturionExhaustShot::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   other->handle_damage(this, 1);
   if (!s.empty())  
     {
@@ -522,10 +534,12 @@
 
 void BoggCenturionShot::animate(Frame *space)
 {
+  STACKTRACE;
 }
 
 void BoggCenturionShot::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   pos += edge();
   tw_sound.play_sound(data_full_path(ex_sample)); // was vol 240
   game->add(new Animation(this, pos, ex_sprite, 0, 10, 50, LAYER_EXPLOSIONS));
@@ -535,6 +549,7 @@
 
 void BoggCenturionShot::calculate()
 {
+  STACKTRACE;
   if (frame > 0) 
     {
       state = 0;

Modified: trunk/source/ships/shpchoex.cpp
===================================================================
--- trunk/source/ships/shpchoex.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpchoex.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -50,6 +50,7 @@
 AsteroidDebris::AsteroidDebris(Ship *creator1, Vector2 new_pos, int tforce)
 : Asteroid()
 {
+  STACKTRACE;
   creator=creator1;
   translate(new_pos - pos);
   frame_born=(int)(game->frame_number);
@@ -60,7 +61,7 @@
 }
 void AsteroidDebris::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
   step-= frame_time;
   while(step <= 0) {
     step += speed * time_ratio;
@@ -82,7 +83,7 @@
 }
 int AsteroidDebris::canCollide(SpaceLocation *other) 
 {
-	STACKTRACE
+  STACKTRACE;
   if (collide_flag)
     { return SpaceObject::canCollide(other);
     }
@@ -106,13 +107,14 @@
 AsteroidCenter::AsteroidCenter(Ship *creator1, Vector2 new_pos) 
 : AsteroidDebris(creator1, new_pos, 0)
 {
+  STACKTRACE;
   layer = LAYER_SHOTS;
   collide_flag_anyone = ALL_LAYERS &~ bit(LAYER_CBODIES);
   creator=creator1;
 }
 void AsteroidCenter::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
   if (creator == NULL)
     {
       this->~AsteroidCenter();
@@ -126,16 +128,18 @@
 }
 int AsteroidCenter::canCollide(SpaceLocation *other) 
 {
-	STACKTRACE
+  STACKTRACE;
   if (!other->damage_factor) return false;
   return SpaceObject::canCollide(other);
 }
 int AsteroidCenter::handle_damage(SpaceLocation *source, double normal, double direct) 
 {
+  STACKTRACE;
 	return iround(normal + direct);
 }
 int AsteroidCenter::isAsteroid()
 {
+  STACKTRACE;
   return 0;
 }
 
@@ -161,6 +165,7 @@
 Laser(creator1, langle, lcolor, lrange, 
        ldamage, lfcount, opos, Vector2(rel_x,rel_y), osinc_angle)
 {
+  STACKTRACE;
   tractorForce = tForce;
   tractorPushForce = tPushForce;
   creator=creator1;
@@ -168,7 +173,7 @@
 
 void ChoraliTractorBeam::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
   // SpaceObject::inflict_damage(other);
  if(other != NULL)
   {
@@ -258,6 +263,7 @@
 		oship, osprite, oship->target), 
   explosion(meleedata.asteroidExplosionSprite), frame_count(oframe_count) 
 {
+  STACKTRACE;
 	collide_flag_sameship = bit(LAYER_SHIPS) | bit(LAYER_SHOTS);
 	//	explosionSprite     = game->asteroidExplosionSprite;
 	
@@ -282,7 +288,7 @@
 
 void AsteroidMissile::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
   HomingMissile::calculate();
   if(sprite_index_count<63)
@@ -305,7 +311,7 @@
 
 void AsteroidMissile::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
   SpaceObject::inflict_damage(other);
   add(new Animation(this, pos, explosion, 0, explosion->frames(), time_ratio, LAYER_CBODIES));
   state=0;
@@ -313,7 +319,7 @@
 
 int AsteroidMissile::handle_damage(SpaceLocation *source, double normal, double direct) 
 {
-	STACKTRACE
+  STACKTRACE;
   if (!exists()) return 0;
   if (!normal && !direct) return 0;
   
@@ -325,7 +331,7 @@
 }
 void AsteroidMissile::death()
 {
-	STACKTRACE
+  STACKTRACE;
   HomingMissile::death();
   add(new Animation(this, pos, explosion, 0, explosion->frames(), time_ratio, LAYER_CBODIES));
 }
@@ -415,6 +421,7 @@
 	Ship(opos, shipAngle, shipData, code)
 
 {
+  STACKTRACE;
   weaponFrames = get_config_int("Weapon", "Frames", 0);
   drillFrames  = 0;
   weaponDamage   = get_config_int("Weapon", "Damage", 0);
@@ -455,7 +462,7 @@
 
 void ChoraliExtractor::death()
 {
-	STACKTRACE
+  STACKTRACE;
   Ship::death();
 
   // dangerous, this is a memory leak:
@@ -464,26 +471,26 @@
 }
 void ChoraliExtractor::materialize()
 {
-	STACKTRACE
+  STACKTRACE;
 	Ship::materialize();
 	add(asteroid_center = new AsteroidCenter(this, this->normal_pos()));
 }
 
 void ChoraliExtractor::calculate_turn_left()
 {
-	STACKTRACE
+  STACKTRACE;
   Ship::calculate_turn_left();
 }
 
 void ChoraliExtractor::calculate_turn_right()
 {
-	STACKTRACE
+  STACKTRACE;
   Ship::calculate_turn_right();
 }
 
 int ChoraliExtractor::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
   if (drillFrames > 0)
     {
       count=0;      
@@ -515,7 +522,7 @@
 
 int ChoraliExtractor::activate_special()
 {
-	STACKTRACE
+  STACKTRACE;
 
   if(this->nearest_planet() != NULL)
     {
@@ -540,6 +547,7 @@
 
 void ChoraliExtractor::calculate()
 {
+  STACKTRACE;
   if(drillFrames > 0) 
     {
       if(grabbed == NULL)
@@ -651,6 +659,7 @@
 
 int ChoraliExtractor::canCollide(SpaceObject *other)
 {
+  STACKTRACE;
   if ((latched) && (grabbed!=NULL) && (grabbed->exists()))
     {
       if (grabbed == other)
@@ -661,12 +670,14 @@
  
 void ChoraliExtractor::animate(Frame *space)
 {
+  STACKTRACE;
   sprite->animate( pos, sprite_index, space);
 }
 
 
 void ChoraliExtractor::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   if (drillFrames > 0)
     {
       if (!latched)

Modified: trunk/source/ships/shpconca.cpp
===================================================================
--- trunk/source/ships/shpconca.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpconca.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -71,6 +71,7 @@
 	SpaceObject *Next_Object):SpaceObject(creator,
 	opos,oangle,osprite)
 {
+  STACKTRACE;
 	Prev_Link=(Link *)Prev_Object;
 	Next_Link=(Link *)Next_Object;
 }
@@ -119,7 +120,7 @@
 
 void CargoLink::do_area_damage()
 {
-	STACKTRACE
+  STACKTRACE;
 	Query q;
 	for (q.begin(this, OBJECT_LAYERS, explosionRange); q.currento; q.next())
 	{
@@ -135,6 +136,7 @@
 
 int CargoLink::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   int  totalDamage = int( normal+direct + 0.5);
 
   if (totalDamage == 0) 
@@ -177,7 +179,7 @@
 
 void CargoLink::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	Link::calculate();
 	sprite_index = get_index(angle);
 	if (Prev_Link && !Prev_Link->exists()) Prev_Link = NULL;
@@ -190,6 +192,7 @@
 :
 Link(creator,opos,oangle,osprite,Prev_Object,Next_Object)
 {
+  STACKTRACE;
 	mass=omass;
 	layer = LAYER_SPECIAL;
 
@@ -206,7 +209,7 @@
 
 void Chain::Pull_Last_Link()
 {
-	STACKTRACE
+  STACKTRACE;
 	Link *l=this;
 
 	//Seek to the end of the list
@@ -218,13 +221,13 @@
 
 int Chain::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE
+  STACKTRACE;
 	return damage(Prev_Link, 0, normal+direct);
 }
 
 void Chain::Uncouple()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	for(Link *l=this->Next_Link ; l!=NULL; l=l->Next_Link)
 	{
@@ -269,6 +272,7 @@
 :
 Link(creator,opos, oangle,osprite,NULL,NULL)
 {
+  STACKTRACE;
 		
 	Prev_Link=(Link *)creator;	//Attach the first link to the ship
 	
@@ -307,7 +311,7 @@
 
 void Chain::addlink(SpaceLocation *creator, double oangle, SpaceSprite *osprite, double ospacing, double omass)
 {
-	STACKTRACE
+  STACKTRACE;
 	// first, find the last link in the list:
 	
 	Link *Cur_Link = this;					// Chain is also of type Link.
@@ -352,7 +356,7 @@
 //backwards.
 void Chain::ChainRecur(Link *other,int num)
 {
-	STACKTRACE
+  STACKTRACE;
 	//Call ChainRecur for the next link UNLESS you're at the last link
 	if(other->Next_Link!=NULL) ChainRecur(other->Next_Link,num+1);
 
@@ -363,7 +367,7 @@
 
 void Chain::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	if( !(ship && ship->exists()) )
 	{	//If the mothership is killed, the chain dies.
 		Uncouple();		//Shatters chain, links become independent
@@ -382,7 +386,7 @@
 
 void Chain::ChainPhysics(SpaceObject *first, SpaceObject *second)
 {
-	STACKTRACE
+  STACKTRACE;
 
 
 	// first = towards the head, second = towards the tail
@@ -502,6 +506,7 @@
 	Ship(opos, angle, data, code)
 
 {
+  STACKTRACE;
 	weaponColor   =  get_config_int("Weapon", "Color", 0);
 	weaponRange   =  scale_range(get_config_float("Weapon", "Range", 0));
 	weaponDamage  =  get_config_int("Weapon", "Damage", 0);
@@ -515,7 +520,7 @@
 
 int ConfedCargotran::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
 	if(fire_special) return(FALSE);
 
 	//Add weapon code here
@@ -528,7 +533,7 @@
 
 int ConfedCargotran::activate_special()
 {
-	STACKTRACE
+  STACKTRACE;
 	//Cuts loose all links and remembers that it did so.
 	if(Head==NULL)
 		return(FALSE);
@@ -550,7 +555,7 @@
 
 void ConfedCargotran::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 	double back_x=size.x/3.60, back_y=-size.y/2.33,
 	       frnt_x=size.x/5.55, frnt_y=+size.y/17.01,
 	       back_y_1=-size.y/2.06;
@@ -587,7 +592,7 @@
 
 void ConfedCargotran::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	Ship::calculate();
 
 }
@@ -595,7 +600,7 @@
 
 void ConfedCargotran::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE;
+  STACKTRACE;
 	if (!(other && other->exists()))
 		return;
 

Modified: trunk/source/ships/shpconho.cpp
===================================================================
--- trunk/source/ships/shpconho.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpconho.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -77,6 +77,7 @@
 		ShipData *shipData, unsigned int code) :
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   regenrateFrames = get_config_int("Extra", "Frames", 0);
   regenrating     = FALSE;
   regenrateAmount = get_config_int("Extra", "RechargeAmount", 0);
@@ -113,7 +114,7 @@
 }
 
 int ConfederationHornet::activate_weapon() {
-	STACKTRACE
+  STACKTRACE;
   add(new Missile(this, Vector2(7,35),
     angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
     this, data->spriteWeapon));
@@ -125,7 +126,7 @@
 
 int ConfederationHornet::activate_special()
 {
-	STACKTRACE
+  STACKTRACE;
   add(new TorpedoMissile(0.0, (size.y / 2.0),
     angle, specialVelocity, specialDamage, specialDDamage, specialRange, specialArmour, specialTurnRate, this, this, data->spriteSpecial, target));
   return(TRUE);
@@ -133,7 +134,7 @@
 
 void ConfederationHornet::calculate()
 {
-	STACKTRACE;
+  STACKTRACE;
 
 //   int shield_color = 9; // Blue
 //   int i, bar_x, bar_y, shield_panel;
@@ -182,7 +183,7 @@
 }
 
 int ConfederationHornet::handle_damage(SpaceLocation *source, double normal, double direct) {
-	STACKTRACE
+  STACKTRACE;
    if ((normal - shield) <= 0) {
      shield -= iround(normal);
 	 normal = 0;
@@ -196,6 +197,7 @@
 
 RGB ConfederationHornet::crewPanelColor(int k)
 {
+  STACKTRACE;
 	RGB c1 = {0,255,0};
 	RGB c2 = {0,0,255};		// blue
 
@@ -208,6 +210,7 @@
 // returns the "real" live crew (this can fool the Syreen).
 double ConfederationHornet::getCrew()
 {
+  STACKTRACE;
 	if (crew)
 		return 1;
 	else
@@ -224,10 +227,11 @@
   HomingMissile(creator, Vector2(ox,oy), oangle, ov, odamage, orange, oarmour, otrate, opos, osprite, otarget),
   Direct_Damage(oddamage)
 {
+  STACKTRACE;
 }
 
 void TorpedoMissile::inflict_damage(SpaceObject *other) {
-	STACKTRACE
+  STACKTRACE;
 	damage(other, 0, Direct_Damage);
   HomingMissile::inflict_damage(other);
 }

Modified: trunk/source/ships/shpdragr.cpp
===================================================================
--- trunk/source/ships/shpdragr.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpdragr.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -75,6 +75,7 @@
 						 ShipData *shipData, unsigned int code) :
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -101,7 +102,7 @@
 
 int DraxGryphon::activate_weapon()
 {
-	STACKTRACE;
+  STACKTRACE;
   weaponoffset++;
 
   if (weaponoffset > 3)
@@ -118,9 +119,8 @@
 
 int DraxGryphon::activate_special()
 {
+  STACKTRACE;
 
-	STACKTRACE;
-
 	if (numMines == maxMines) {
 	  weaponObject[0]->state = 0;
 	  numMines -= 1;
@@ -139,7 +139,7 @@
 
 void DraxGryphon::calculate()
 {
-STACKTRACE;
+  STACKTRACE;
 
    int j = 0;
    for (int i = 0; i < numMines; i += 1) {
@@ -160,6 +160,7 @@
     AnimatedShot(oship, Vector2(ox,oy), oangle, ov, odamage, -1.0, oarmour, oship,
       osprite, ofcount, ofsize)
 {
+  STACKTRACE;
   MineMoving = TRUE;
   MineRange = miner;
   MineTimer = minet;
@@ -171,9 +172,8 @@
 }
 
 void DraxMine::calculate() {
+  STACKTRACE;
 
-	STACKTRACE;
-
 	AnimatedShot::calculate();
 
 	if (!exists()) return;
@@ -240,8 +240,7 @@
 }
 
 void DraxMine::inflict_damage(SpaceObject *other) {
-
-	STACKTRACE;
+  STACKTRACE;
   if (other->isShip())
      damage_factor = 0;
 

Modified: trunk/source/ships/shpearc3.cpp
===================================================================
--- trunk/source/ships/shpearc3.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpearc3.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -79,6 +79,7 @@
 		ShipData *shipData, unsigned int code) :
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 	weaponRange			= scale_range(get_config_float("Weapon", "Range", 0));
 	weaponVelocity		= scale_velocity(get_config_float("Weapon", "Velocity", 0));
 	weaponDamage		= get_config_int("Weapon", "Damage", 0);
@@ -101,7 +102,7 @@
 
 void EarthlingCruiserMk3::calculate()
 {
-	STACKTRACE;
+  STACKTRACE;
 	Ship::calculate();
 
 	double track_angle = 0;
@@ -148,7 +149,7 @@
 
 int EarthlingCruiserMk3::activate_weapon()
 {
-	STACKTRACE;
+  STACKTRACE;
 	add(new EarthlingCruiserMk3Shot(this, Vector2(0.0, 28.0),
 		normalize(angle + launch_angle + turn_step + tw_random(-weaponSpread, +weaponSpread), PI2),
 		weaponVelocity,	weaponDamage, weaponRange, weaponArmour, data->spriteWeapon));
@@ -157,6 +158,7 @@
 
 int EarthlingCruiserMk3::activate_special()
 {
+  STACKTRACE;
   bool fire = false;;
   SpaceObject *o;
   double rng = 1e40;
@@ -193,6 +195,7 @@
 		double ov, double odamage, double orange, double oarmour, SpaceSprite *osprite) :
 	Shot(creator, opos, oangle, ov, odamage, orange, oarmour, creator, osprite)
 {
+  STACKTRACE;
 	explosionSprite     = data->spriteWeaponExplosion;
 	explosionFrameCount = 20;
 	explosionFrameSize  = 25;
@@ -206,12 +209,14 @@
 
 void EarthlingCruiserMk3Shot::animate(Frame *space)
 {
+  STACKTRACE;
   if (exists())
     sprite->animate(pos, sprite_index = (int)(31.99 * d / range), space);
 }
 
 void EarthlingCruiserMk3Shot::soundExplosion()
 {
+  STACKTRACE;
   tw_sound.play_sound(data_full_path(explosionSample));
   return;
 }
@@ -224,6 +229,7 @@
 	frame(0), frame_count(lfcount), lpos(creator), rel_pos(rpos), damage_shots(sdamage)
 
 {
+  STACKTRACE;
 	set_depth(DEPTH_EXPLOSIONS);
 	target = tgt;
 	base_length = length;
@@ -248,7 +254,7 @@
 
 void EarthlingCruiserMk3Beam::calculate()
 {
-	STACKTRACE;
+  STACKTRACE;
 	if(!(lpos && lpos->exists()))
 	{
 		lpos = 0;
@@ -303,7 +309,7 @@
 
 void EarthlingCruiserMk3Beam::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE;
+  STACKTRACE;
 	if (other->isShot())
 		damage(other, damage_shots*frame_time/frame_count);
 	else
@@ -321,7 +327,7 @@
 
 void EarthlingCruiserMk3Beam::animate(Frame *space)
 {
-	STACKTRACE;
+  STACKTRACE;
 	int aa = get_tw_aa_mode();
 	SpaceLine::animate(space);
 	if ((aa & AA_BLEND) && (aa & AA_ALPHA) && !(aa & AA_NO_AA) && (length < base_length*0.9999) && (target)) {

Modified: trunk/source/ships/shpforsh.cpp
===================================================================
--- trunk/source/ships/shpforsh.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpforsh.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -58,6 +58,7 @@
 ForevianShocker::ForevianShocker(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code) :
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 	weaponRange		= scale_range(get_config_float("Weapon", "Range", 0)); 
 	weaponVelocity	= scale_velocity(get_config_float("Weapon", "Velocity", 0));
 	weaponDamage	= get_config_int("Weapon", "Damage", 0); 
@@ -90,6 +91,7 @@
 
 int ForevianShocker::activate_weapon()
 {
+  STACKTRACE;
   SpaceSprite *tmp_s = data->spriteWeapon;
   if (weapon_type==2)	
     tmp_s = data->spriteExtra;
@@ -119,6 +121,7 @@
 
 int ForevianShocker::activate_special()
 {
+  STACKTRACE;
   if(shockingFrames == 0) 
     {
       tw_sound.stop_sound(data_full_path(data->sampleSpecial[0]));
@@ -132,6 +135,7 @@
 
 void ForevianShocker::calculate()
 {
+  STACKTRACE;
   if(shockVar == 1)
     {
       if(shockingFrames > 0)
@@ -193,7 +197,8 @@
 				     int ofsize, int ol) :
   AnimatedShot(oship, Vector2(ox,oy), oangle, ov, odamage, orange, 
 	       oarmour, oship, osprite, ofcount, ofsize)
-{ 
+{
+  STACKTRACE; 
   collide_flag_anyone = OBJECT_LAYERS&~bit(LAYER_SHOTS);
   collide_flag_sameship = collide_flag_anyone;
   last_hit = oship;
@@ -201,7 +206,8 @@
 }
 
 void ForevianShockwave::inflict_damage(SpaceObject *other)
-{	
+{
+  STACKTRACE;	
   if (other==last_hit)
     return;
   

Modified: trunk/source/ships/shpgarty.cpp
===================================================================
--- trunk/source/ships/shpgarty.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpgarty.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -116,6 +116,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
 	weaponDamage					 = get_config_int("Weapon", "Damage", 8);
 	weaponArmour					 = get_config_int("Weapon", "Armour", 8);
@@ -145,7 +146,7 @@
 
 void GarashTyrant::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 if (!fire_weapon  &&
 		!fire_special &&
@@ -225,7 +226,7 @@
 }
 
 void GarashTyrant::stun_ship(SpaceObject *other){
-	STACKTRACE
+  STACKTRACE;
   GarashRepulsarStun* GRS;
   if (other->state==0) return;
 	if (other->isShip()) {
@@ -242,7 +243,7 @@
 
 void GarashTyrant::calculate_fire_weapon()
 	{
-	STACKTRACE
+  STACKTRACE;
 	weapon_low = FALSE;
 
 	if (fire_weapon) {
@@ -268,7 +269,7 @@
 
 int GarashTyrant::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
   if(weaponObject)
     return(FALSE);
 
@@ -281,6 +282,7 @@
 }
 
 int GarashTyrant::activate_special() {
+  STACKTRACE;
 
 	repulse = true;
 
@@ -294,6 +296,7 @@
   ship(oship), stunframe(0), stunframe_count(stunFrames),
   frame_step(0), frame_size(ofsize), frame_count(ofcount)
 {
+  STACKTRACE;
   targetIsDead = FALSE;
 	collide_flag_anyone = 0;
 	layer = LAYER_EXPLOSIONS;
@@ -301,7 +304,7 @@
 }
 
 void GarashRepulsarStun::calculate() {
-	STACKTRACE
+  STACKTRACE;
   if(!ship) targetIsDead = TRUE;
   else {
     if(!ship->exists()) targetIsDead = TRUE;
@@ -360,6 +363,7 @@
 	CD(oChargingDistance),
 	CDD(oChargingDistanceDamage)
 {
+  STACKTRACE;
 	  vel = ship->get_vel();
 
 	Timer  = 0;
@@ -378,6 +382,7 @@
 
 void GarashShot::calculate() 
 {
+  STACKTRACE;
   if(released) 
     Shot::calculate();
   else SpaceObject::calculate();
@@ -464,11 +469,13 @@
 
 void GarashShot::animateExplosion()
 {
+  STACKTRACE;
   return;
 }
 
 void GarashShot::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   int Distance_Travelled = iround(distance_from(StartC, other->normal_pos()));
   int AddDamage = iround((Distance_Travelled / CD) * CDD);
   
@@ -513,6 +520,7 @@
 
 int GarashShot::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   armour += damage_factor + direct ; // nullify damage
   if (((!ship_hit && !source->isShip()) ||
        (ship_hit && source->isShip())) && !released)
@@ -523,6 +531,7 @@
 
 int GarashShot::canCollide(SpaceLocation *other)
 {
+  STACKTRACE;
   return(TRUE);
 }
 REGISTER_SHIP(GarashTyrant)

Modified: trunk/source/ships/shpilwsp.cpp
===================================================================
--- trunk/source/ships/shpilwsp.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpilwsp.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -82,6 +82,7 @@
 		ShipData *shipData, unsigned int code) :
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange       = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity    = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -98,7 +99,7 @@
 
 int IlwrathSpider::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
   game->add( new AnimatedShot( this, Vector2(size.x*0.12, size.y*0.35),
     angle + weaponAngle, weaponVelocity, weaponDamage, weaponRange, weaponArmour, this,
     data->spriteWeapon, data->spriteWeapon->frames(), ILWRATH_FIRE_ANIM_RATE, 1 ));
@@ -111,7 +112,7 @@
 
 int IlwrathSpider::activate_special()
 {
-	STACKTRACE;
+  STACKTRACE;
     double alpha = specialSpread / specialNumber;
     double beta = normalize( angle + PI - 0.5 * specialSpread + random(alpha), PI2 );
     double tx = cos( angle );
@@ -130,13 +131,13 @@
 
 void IlwrathSpider::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
     Ship::calculate();
 }
 
 void IlwrathSpiderMine::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
   double alpha = (-10 + random(21)) * ANGLE_RATIO;
   alpha *= randomness;
   angle += alpha * frame_time;
@@ -169,6 +170,7 @@
 
 void IlwrathSpiderMine::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   state = 0;
   
   int freq;
@@ -202,6 +204,7 @@
   step( 0 ), life( olife ), inc( 1 ),
   randomness( orandomness ), stoptime( ostoptime )
 {
+  STACKTRACE;
   layer = LAYER_SPECIAL;
   vel = unit_vector(angle) * v;
 }
@@ -210,6 +213,7 @@
   SpaceLocation( creator, 0, 0 ),
   victim( ovictim ), life( olife )
 {
+  STACKTRACE;
   if( victim )
     {
       if( !victim->exists() )
@@ -234,6 +238,7 @@
 
 void IlwrathStop::calculate()
 {
+  STACKTRACE;
   SpaceLocation::calculate();
   if( !(victim && victim->exists()) )
     {

Modified: trunk/source/ships/shpkahbo.cpp
===================================================================
--- trunk/source/ships/shpkahbo.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpkahbo.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -141,6 +141,7 @@
 	:
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   weapon1Range    = scale_range(get_config_float("WeaponS", "Range", 0));
   weapon1Turn     = scale_turning(get_config_float("WeaponS","Turn", 0));
   weapon1Velocity = scale_velocity(get_config_float("WeaponS", "Velocity", 0));
@@ -174,7 +175,7 @@
 
 int KahrBoomerang::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
   int chance;
   int answer = FALSE;
   if (weaponChoice == SMALL_BOOMERANG) {
@@ -209,7 +210,7 @@
 
 int KahrBoomerang::activate_special()
 {
-	STACKTRACE
+  STACKTRACE;
   int answer;
   if (weaponChoice == SMALL_BOOMERANG) {
     weapon_drain = weapon2Drain;
@@ -232,7 +233,7 @@
 
 void KahrBoomerang::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
   if ((boomerangL != NULL) && (!boomerangL->exists()))
     boomerangL=NULL;
   Ship::calculate();
@@ -248,7 +249,7 @@
 
 void KahrBoomerang::calculate_fire_special()
 {
-	STACKTRACE
+  STACKTRACE;
   if (weaponChoice == SMALL_BOOMERANG) {
     blit(this->spritePanel->get_bitmap(7), this->spritePanel->get_bitmap(1), 36, 0, 36, 0, 19, 30);
     blit(this->spritePanel->get_bitmap(7), this->spritePanel->get_bitmap(2), 36, 0, 36, 0, 19, 30);
@@ -279,6 +280,7 @@
 	Shot(oship, Vector2(ox,oy), oangle, ov, odamage, -1.0 , oarmour, oship, osprite)
 
 {
+  STACKTRACE;
   mass = 0.25;
   frame = 0;
   frame_step = 0;
@@ -293,7 +295,7 @@
 
 void KahrSmall::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	if (!(ship && ship->exists()))
 	{
 		state = 0;
@@ -334,7 +336,7 @@
 
 void KahrSmall::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 	if (other == ship) {
 		state = 0;
 		mass = 0;
@@ -353,6 +355,7 @@
 	Shot(oship, Vector2(ox,oy), oangle, ov, odamage, -1.0 , oarmour, oship, osprite)
 
 {
+  STACKTRACE;
   mass = 3.0;
   frame = 0;
   frame_step = 0;
@@ -368,13 +371,13 @@
 }
 
 void KahrMedium::death() {
-	STACKTRACE;
+  STACKTRACE;
 	if (kahrship) (kahrship)->num_medium_boomerangs -= 1;
 	Shot::death();
 	}
 
 void KahrMedium::calculate() {
-	STACKTRACE
+  STACKTRACE;
 	if (!(ship && ship->exists()))
 	{
 		state = 0;
@@ -418,7 +421,7 @@
 
 void KahrMedium::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 	if (other == ship) {
 		state = 0;
 		mass = 0;
@@ -437,6 +440,7 @@
 	Shot(oship, Vector2(ox,oy), oangle, ov, odamage, -1.0 , oarmour, oship, osprite)
 
 {
+  STACKTRACE;
   mass =5.0;
   frame = 0;
   frame_step = 0;
@@ -451,7 +455,7 @@
 
 void KahrLarge::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	if (!(ship && ship->exists()))
 	{
 		state = 0;
@@ -490,7 +494,7 @@
 
 void KahrLarge::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 	if (other == ship) {
 		state = 0;
 		mass = 0;
@@ -505,7 +509,7 @@
 
 int KahrLarge::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE
+  STACKTRACE;
   return Shot::handle_damage(source, 0, 0);
 }
 

Modified: trunk/source/ships/shprogsq.cpp
===================================================================
--- trunk/source/ships/shprogsq.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shprogsq.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -144,6 +144,7 @@
 :
 Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 	
 	weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
 	weaponDamage   = get_config_int("Weapon", "Damage", 0);
@@ -215,7 +216,7 @@
 // This is called just before the first calculate(), after the ship phases into battle
 void RogueSquadron::materialize()
 {
-	STACKTRACE
+  STACKTRACE;
 	int i;
 
 	formation = 0;
@@ -266,6 +267,7 @@
 
 int RogueSquadron::activate_weapon()
 {
+  STACKTRACE;
 	// all ships fire a pulse laser:
 	fire_main = 1;
 	return TRUE;
@@ -274,8 +276,7 @@
 
 int RogueSquadron::activate_special()
 {
-
-	STACKTRACE
+  STACKTRACE;
 	int	i;
 
 	// first of all, clean up the old formation.
@@ -324,8 +325,8 @@
 
 
 void RogueSquadron::calculate()
-{	
-	STACKTRACE
+{
+  STACKTRACE;
 	fire_main = 0;	// reset this first.
 
 	int i;
@@ -440,7 +441,7 @@
 
 void RogueSquadron::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 	int a;
 	a = aa_get_trans();
 	aa_set_trans(100);
@@ -452,6 +453,7 @@
 
 int RogueSquadron::handle_damage(SpaceLocation* source, double normal, double direct)
 {
+  STACKTRACE;
 	// the Syreen, and maybe other area-effect weapons, can do damage to
 	// the virtual ship, which I don't want. So, I'll disable all damage
 	// taking by this ship
@@ -463,6 +465,7 @@
 
 void RogueSquadron::calculate_hotspots()
 {
+  STACKTRACE;
 	// do nothing: no hotspots for this virtual thing
 }
 
@@ -472,6 +475,7 @@
 :
 Ship(creator, creator->pos, creator->angle, osprite)
 {
+  STACKTRACE;
 	mother = creator;
 	pos = mother->pos;
 
@@ -502,7 +506,7 @@
 
 SpaceObject* RogueFighter::nearest_location()
 {
-	STACKTRACE
+  STACKTRACE;
 	SpaceObject *p = NULL;
 	double r = 99999999;
 	Query q;
@@ -526,7 +530,7 @@
 // should be added to SpaceLocation I think !
 void RogueFighter::avoid_location(SpaceObject *o)
 {
-	STACKTRACE
+  STACKTRACE;
 	double t_a = trajectory_angle(o);
 	double d_a = normalize(t_a - angle, PI2);
 	
@@ -548,7 +552,7 @@
 
 void RogueFighter::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	if ( !(mother && mother->exists()) )
 	{
 		state = 0;
@@ -639,7 +643,7 @@
 
 int RogueFighter::handle_damage(SpaceLocation* source, double normal, double direct)
 {
-	STACKTRACE
+  STACKTRACE;
 	if (!state)
 		return 0;	// to avoid an infinite feedback with enemy rogue.
 
@@ -690,6 +694,7 @@
   lpos(opos),
   rel_pos(rpos)
 {
+  STACKTRACE;
 
 // angle conventions fucked up??
 	rel_pos.x *= -1;
@@ -709,7 +714,7 @@
 
 
 void PulseLaser::calculate() {
-	STACKTRACE
+  STACKTRACE;
 	if((frame < frame_count) && (lpos->exists())) {
 //		pos = lpos->normal_pos() + rotate(rel_pos, lpos->get_angle() - PI/2);
 //		vel = lpos->get_vel();
@@ -723,6 +728,7 @@
 
 void PulseLaser::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   // copied from space_line:
   int i;
   i = iround_down(damage_factor / 2);

Modified: trunk/source/ships/shpstaba.cpp
===================================================================
--- trunk/source/ships/shpstaba.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpstaba.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -48,6 +48,7 @@
 	:
 	Ship(opos, angle, data, code)
 	{
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -67,7 +68,7 @@
 }
 
 int StarBase::activate_weapon() {
-	STACKTRACE
+  STACKTRACE;
    
 	double a;
 	if (target) {
@@ -96,7 +97,7 @@
 }
 
 int StarBase::activate_special() {
-	STACKTRACE
+  STACKTRACE;
   int fire = FALSE;
   SpaceObject *o;
 
@@ -123,6 +124,7 @@
 
 void StarBase::calculate() 
 {
+  STACKTRACE;
   int fire = FALSE;
   Ship *o;
 
@@ -154,6 +156,7 @@
 
 int StarBase::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   batt -= normal;
   if (batt < 0) 
     {
@@ -164,6 +167,7 @@
   return Ship::handle_damage(source, normal, direct);
 }
 
-void StarBase::calculate_gravity() {}
+void StarBase::calculate_gravity() {
+  STACKTRACE;}
 
 REGISTER_SHIP ( StarBase )

Modified: trunk/source/ships/shptauar.cpp
===================================================================
--- trunk/source/ships/shptauar.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shptauar.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -120,6 +120,7 @@
 TauArchon::TauArchon(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code) :
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 	weaponChargeTime	= (int)(get_config_float("Weapon", "ChargeTime", 0) * 1000);
 	weapon_charge_counter	= 0;
 	weaponVelocity		= scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -167,6 +168,7 @@
 
 bool TauArchon::ShotTakeBatt()
 {
+  STACKTRACE;
 	if(numDamage_steps > 0)
 	{
 		bool bWhat2Do;
@@ -216,7 +218,7 @@
 
 void TauArchon::calculate_fire_weapon()
 {
-STACKTRACE
+  STACKTRACE;
   weapon_low = FALSE;
 
  if ((fire_weapon || fire_special) && (weapon_charge_counter >= weaponChargeTime))
@@ -269,7 +271,7 @@
 
 void TauArchon::calculate_fire_special()
 {
-STACKTRACE
+  STACKTRACE;
 	special_low = false;
 	return;
 }
@@ -277,7 +279,7 @@
 
 void TauArchon::animate(Frame *space)
 {
-STACKTRACE
+  STACKTRACE;
 	int aa = get_tw_aa_mode();
 	if ((weapon_charge_counter > 0) && (aa & AA_BLEND) && !(aa & AA_NO_AA)) 
 	{
@@ -302,6 +304,7 @@
 /*	Removed by Jad
 RGB TauArchon::crewPanelColor(int k)
 {
+  STACKTRACE;
 	RGB c = {255, 255, 255};
 	return c;
 }
@@ -309,6 +312,7 @@
 
 RGB TauArchon::battPanelColor(int k)
 {
+  STACKTRACE;
 	RGB c = {85, 85, 255};
 	return c;
 }
@@ -316,7 +320,7 @@
 
 void TauArchon::calculate_hotspots()
 {
-STACKTRACE
+  STACKTRACE;
 	if((thrust) && (hotspot_frame <= 0)) {
 		game->add(new Animation( this, 
 				normal_pos() - unit_vector(angle) * 15,
@@ -335,6 +339,7 @@
 	Shot(creator, opos, oangle, ov, odamage, orange, oarmour, creator, osprite),
 	min_damage(omindamage), fuel_sap(ofsap)
 {
+  STACKTRACE;
 	do_reactive_damage = oreactive;
 	explosionSprite     = data->spriteWeaponExplosion;
 	explosionFrameCount = 10;
@@ -379,7 +384,7 @@
 
 void TauArchonShot::calculate()
 {
-STACKTRACE
+  STACKTRACE;
 	Shot::calculate();
 
 	if (rotation_base) {
@@ -402,14 +407,14 @@
 
 void TauArchonShot::animate(Frame *space)
 {
-STACKTRACE
+  STACKTRACE;
 	if (exists())
 		sprite->animate(pos, index_base + (int)(19.89 * d / range), space);
 }
 
 void TauArchonShot::inflict_damage(SpaceObject *other)
 {
-STACKTRACE
+  STACKTRACE;
 	double d_f = damage_factor;
 
 	if (other->isShip()) 
@@ -496,6 +501,7 @@
 TauArchonFrozen::TauArchonFrozen(SpaceLocation *creator, SpaceObject *source, SpaceSprite *osprite) :
 	Shot(creator, 0, source->get_angle(), 0, 0, 999, source->mass, source, osprite, 1.0)
 {
+  STACKTRACE;
 	collide_flag_anyone = collide_flag_sameteam = collide_flag_sameship = ALL_LAYERS;
 	ally_flag = 0;
 	mass = source->mass;
@@ -528,11 +534,12 @@
 
 void TauArchonFrozen::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
 }
 
 void TauArchonFrozen::calculate()
 {
-STACKTRACE
+  STACKTRACE;
 
 	Shot::calculate();
 	if (length(vel-old_vel) > scale_velocity(15+tw_random()%20))
@@ -545,7 +552,7 @@
 
 void TauArchonFrozen::animateExplosion()
 {
-	STACKTRACE
+  STACKTRACE;
 	if (!exploded_already) {
 		exploded_already = true;	
 		game->add(new Animation(this, normal_pos(),

Modified: trunk/source/ships/shptauda.cpp
===================================================================
--- trunk/source/ships/shptauda.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shptauda.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -71,6 +71,7 @@
 TauDagger::TauDagger(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code) :
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
 	weaponRange			= scale_range(get_config_float("Weapon", "Range", 0));
 	weaponDamage		= get_config_float("Weapon", "Damage", 0);
@@ -86,14 +87,14 @@
 
 int TauDagger::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
 	game->add(new TauDaggerBeam(this, Vector2(0,30), weaponRange, weaponDamage, iround(weaponFrameCount), angle));
 	return true;
 }
 
 int TauDagger::activate_special()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	game->add(new TauDaggerShot(this, Vector2(0,55), angle, specialVelocity,
 			specialDamage, specialRange, specialArmour, data->spriteSpecial));
@@ -110,6 +111,7 @@
 	frame(0), frame_count(lfcount), lpos(creator), rel_pos(rpos)
 
 {
+  STACKTRACE;
 	if (ldamage <= 0) collide_flag_anyone = 0;
 	set_depth(DEPTH_SHOTS);
 	base_length = length;
@@ -129,7 +131,7 @@
 
 void TauDaggerBeam::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	if((frame < frame_count) && (lpos->exists())) {
 		length = base_length;
 		pos = lpos->normal_pos() + rotate(rel_pos, lpos->get_angle() - PI/2);
@@ -148,7 +150,7 @@
 
 void TauDaggerBeam::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 	damage(other, damage_factor*frame_time/frame_count);
 
 	int aa = get_tw_aa_mode();
@@ -163,7 +165,7 @@
 
 void TauDaggerBeam::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 	int aa = get_tw_aa_mode();
 	SpaceLine::animate(space);
 	if ((aa & AA_BLEND) && (aa & AA_ALPHA) && !(aa & AA_NO_AA) && (length < base_length*0.9999) && (target)) {
@@ -180,6 +182,7 @@
 		double ov, double odamage, double orange, double oarmour, SpaceSprite *osprite) :
 	Missile(creator, opos, oangle, ov, odamage, orange, oarmour, creator, osprite)
 {
+  STACKTRACE;
 	explosionSprite     = data->spriteSpecialExplosion;
 	explosionFrameCount = 20;
 	explosionFrameSize  = 25;
@@ -192,7 +195,7 @@
 
 void TauDaggerShot::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 	sprite->animate(pos, sprite_index + 64 * s_ind, space);
 	s_ind = (s_ind + 1) % 2;
 }

Modified: trunk/source/ships/shptaume.cpp
===================================================================
--- trunk/source/ships/shptaume.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shptaume.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -75,6 +75,7 @@
 TauMercury::TauMercury(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code) :
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 	weaponRange		= scale_range(get_config_float("Weapon", "Range", 0));
 	weaponVelocity	= scale_velocity(get_config_float("Weapon", "Velocity", 0));
     weaponDamage	= get_config_float("Weapon", "Damage", 0);
@@ -106,7 +107,7 @@
 
 int TauMercury::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
 	double da = (1-0.002*(random()%1001));
 	if (da >= 0)
 		da *= da;
@@ -121,7 +122,7 @@
 
 void TauMercury::calculate_turn_right()
 {
-	STACKTRACE
+  STACKTRACE;
 	if (turn_right) {
 		bank_position += bank_max * frame_time / bank_time;
 		if (!turn_lag)
@@ -130,7 +131,7 @@
 
 void TauMercury::calculate_turn_left()
 {
-	STACKTRACE
+  STACKTRACE;
 	if (turn_left) {
 		bank_position -= bank_max * frame_time / bank_time;
 		if (!turn_lag)
@@ -139,7 +140,7 @@
 
 void TauMercury::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	double vl;
 	bool locked_rail = false;
 
@@ -214,7 +215,7 @@
 
 int TauMercury::accelerate(SpaceLocation *source, double angle, double velocity, double max_speed)
 {
-	STACKTRACE
+  STACKTRACE;
 	double ov;
 	double nvs, nvl;
 
@@ -240,7 +241,7 @@
 
 void TauMercury::calculate_hotspots()
 {
-	STACKTRACE
+  STACKTRACE;
 	if((thrust) && (hotspot_frame <= 0)) {
 		game->add(new Animation( this, 
 				normal_pos() - unit_vector(angle) * 14,
@@ -252,11 +253,12 @@
 
 void TauMercury::calculate_thrust()
 {
+  STACKTRACE;
 }
 
 void TauMercury::calculate_fire_special()
 {
-	STACKTRACE
+  STACKTRACE;
 	special_low = FALSE;
 	if (!fire_special)
 		return;
@@ -301,6 +303,7 @@
 	AnimatedShot(creator, Vector2(ox,oy), oangle, ov, odamage, orange, oarmour, creator, osprite, 10, 50, relativity),
 	sparks(osparks), frags(ofrags)
 {
+  STACKTRACE;
 		if (frags)
 		  {
 		    //			explosionSample = data->sampleWeapon[1];
@@ -310,7 +313,7 @@
 
 void TauMercuryShot::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	int si = sprite_index;
 	AnimatedShot::calculate();
 	
@@ -343,7 +346,7 @@
 
 void TauMercuryShot::animateExplosion()
 {
-	STACKTRACE
+  STACKTRACE;
 	if (!frags) {
 		Shot::animateExplosion();
 		return; }
@@ -389,7 +392,7 @@
 
 void TauMercurySpark::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	lifetime -= frame_time;
 	if (lifetime <= 0)
 		state = 0;
@@ -399,14 +402,14 @@
 
 void TauMercurySpark::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 	SpaceLine::inflict_damage(other);
 	state =0;
 }
 
 void TauMercurySpark::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 	drawing_mode(DRAW_MODE_TRANS, NULL, 0, 0);
 
 	double c = lifetime/(double)lifetime_max;

Modified: trunk/source/ships/shptausl.cpp
===================================================================
--- trunk/source/ships/shptausl.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shptausl.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -125,6 +125,7 @@
 
 int TauSlider::activate_weapon()
 {
+  STACKTRACE;
         if (in_jump) return false;
         add(new TauSliderLaser(+21, 15, angle - 15*ANGLE_RATIO,
                           weaponVelocity, weaponRange, weaponLength, this));
@@ -140,6 +141,7 @@
 
 void TauSlider::calculate_fire_special()
 {
+  STACKTRACE;
   special_low = false;
 
   if (fire_special) 
@@ -181,6 +183,7 @@
 
 int TauSlider::activate_special()
 {
+  STACKTRACE;
   if (special_charge >= critical_charge) 
     {
       in_jump = true;
@@ -207,6 +210,7 @@
 
 void TauSlider::calculate()
 {
+  STACKTRACE;
         just_exited = false;
         Ship::calculate();
         if (in_jump) {
@@ -228,6 +232,7 @@
 }
 
 int TauSlider::handle_damage(SpaceLocation *source, int normal, int direct) {
+  STACKTRACE;
         if (in_jump) {
                 return 0; }
         if (just_exited && source->isPlanet())
@@ -237,23 +242,27 @@
 
 int TauSlider::canCollide(SpaceLocation *other)
 {
+  STACKTRACE;
         return ((!in_jump)&&Ship::canCollide(other));
 }
 
 int TauSlider::translate(double dx, double dy)
 {
+  STACKTRACE;
         if (!in_jump) return Ship::translate(dx, dy);
 				return false;
 }
 
 int TauSlider::accelerate(SpaceLocation *source, double oangle, double vel, double omax_speed)
 {
+  STACKTRACE;
         if (!in_jump) return Ship::accelerate(source, oangle, vel, omax_speed);
 				return false;
 }
 
 void TauSlider::animate(Frame* space)
 {
+  STACKTRACE;
         int i,j,r,g,b;
         double a;
         for (i=max_trace_number; i>=0; i--) {
@@ -280,11 +289,13 @@
 
 int TauSlider::isProtected()
 {
+  STACKTRACE;
         return (in_jump);
 }
 
 void TauSlider::calculate_hotspots()
 {
+  STACKTRACE;
         if (!in_jump) Ship::calculate_hotspots();
 }
 
@@ -308,6 +319,7 @@
 
 void TauSliderLaser::calculate()
 {
+  STACKTRACE;
         double a = (d) / range;
         int r = (int)floor(255 - a*400);
         if (r < 0) r = 0;
@@ -323,6 +335,7 @@
 
 void TauSliderLaser::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
         SpaceLine::inflict_damage(other);
         state = 0;
 }
@@ -331,6 +344,7 @@
 TauSliderTrace::TauSliderTrace(Ship* oship) :
         SpaceLocation(oship, oship->normal_pos(), oship->get_angle())
 {
+  STACKTRACE;
         collide_flag_anyone = 0;
         lifetime = 0;
         //vx = oship->get_vx();
@@ -341,6 +355,7 @@
 
 void TauSliderTrace::calculate()
 {
+  STACKTRACE;
         if ((lifetime += frame_time) >= trace_lifetime)
                 state = 0;
 }

Modified: trunk/source/ships/shptaust.cpp
===================================================================
--- trunk/source/ships/shptaust.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shptaust.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -70,6 +70,7 @@
 TauStorm::TauStorm(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code) :
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   
   weaponMass = get_config_float("Weapon", "Mass", 0.01);
   
@@ -105,6 +106,7 @@
 
 int TauStorm::activate_weapon()
 {
+  STACKTRACE;
   int rx;
   if (slot<2)	
     rx = 9;
@@ -123,6 +125,7 @@
 
 int TauStorm::activate_special()
 {
+  STACKTRACE;
   int rx;
   if (slot<2)	rx = 9;
   else rx = 13;
@@ -141,6 +144,7 @@
 
 void TauStorm::animate(Frame *space)
 {
+  STACKTRACE;
   if (thrust)
     sprite->animate(pos, sprite_index + 64, space);
   else
@@ -177,6 +181,7 @@
 
 void TauStormMissile::calculate()
 {
+  STACKTRACE;
   if (latched) 
     {
       if (!latched->exists())
@@ -247,6 +252,7 @@
 
 int TauStormMissile::canCollide(SpaceLocation *other)
 {
+  STACKTRACE;
   if (other == latched) return false;
   return Shot::canCollide(other);
 }

Modified: trunk/source/ships/shptauto.cpp
===================================================================
--- trunk/source/ships/shptauto.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shptauto.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -77,6 +77,7 @@
         Ship(opos, shipAngle, shipData, code)
 
 {
+  STACKTRACE;
         weaponRange     = scale_range(get_config_float("Weapon", "Range", 0));
         weaponVelocity  = scale_velocity(get_config_float("Weapon", "Velocity", 0));
         weaponDamage    = get_config_int("Weapon", "Damage", 0);
@@ -106,6 +107,7 @@
 
 int TauTor::activate_weapon()
 {
+  STACKTRACE;
         if (transition_count > 0) return false;
 
         if (TauTor_state) {
@@ -125,6 +127,7 @@
 
 void TauTor::calculate_fire_special()
 {
+  STACKTRACE;
   special_low = false;
   if (fire_special && can_switch && (transition_count <=0)) 
     {
@@ -155,6 +158,7 @@
 
 void TauTor::calculate()
 {
+  STACKTRACE;
   if (transition_count > 0) 
     {
       if ((transition_count -= frame_time) <= 0) 
@@ -188,6 +192,7 @@
 
 void TauTor::calculate_thrust()
 {
+  STACKTRACE;
   if (thrust && (transition_count <=0)) 
     {
       if (TauTor_state && (batt > 0)) 
@@ -226,6 +231,7 @@
   AnimatedShot(creator, opos, oangle, ov, odamage, orange, oarmour,
 	       lpos, osprite, ofcount, ofsize, relativity)
 {
+  STACKTRACE;
   explosionSprite     = data->spriteWeaponExplosion;
   explosionFrameCount = 12;
   explosionFrameSize  = 50;
@@ -238,6 +244,7 @@
         AnimatedShot(creator, opos, oangle, ov, odamage, orange, oarmour,
 		     lpos, osprite, ofcount, ofsize, relativity)
 {
+  STACKTRACE;
   explosionSprite     = data->spriteSpecialExplosion;
   explosionFrameCount = 12;
   explosionFrameSize  = 50;

Modified: trunk/source/ships/shpwolmi.cpp
===================================================================
--- trunk/source/ships/shpwolmi.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpwolmi.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -74,6 +74,7 @@
 :
 Ship(opos,  shipAngle, shipData, code)
 {
+  STACKTRACE;
 	
 	weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
 	weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -87,8 +88,8 @@
 
 
 int Wolly::activate_weapon()
-{	
-	STACKTRACE;
+{
+  STACKTRACE;
 	
 
 	Vector2 rpos;
@@ -105,7 +106,7 @@
 
 int Wolly::activate_special()
 {
-	STACKTRACE;
+  STACKTRACE;
 
 	WollyMine *o;
 	Vector2 rpos;
@@ -129,6 +130,7 @@
 :
 Shot(creator, rpos, oangle, ov, odamage, orange, oarmour, opos, osprite, relativity)
 {
+  STACKTRACE;
 	default_range = orange;
 
 	collide_flag_anyone = ALL_LAYERS;
@@ -140,7 +142,7 @@
 
 int WollyPlasma::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE;
+  STACKTRACE;
 
 	armour += normal + direct;
 
@@ -164,7 +166,7 @@
 
 void WollyPlasma::calculate()
 {
-	STACKTRACE;
+  STACKTRACE;
 	
 	Shot::calculate();
 
@@ -191,6 +193,7 @@
 
 int WollyPlasma::canCollide(SpaceLocation *other)
 {
+  STACKTRACE;
 	if (other->id == ID_WOLLYPLASMA)
 		return FALSE;
 		
@@ -206,6 +209,7 @@
 :
 SpaceObject(creator, opos, oangle, osprite)
 {
+  STACKTRACE;
 	lifetime = olifetime;
 	existtime = 0;
 
@@ -225,6 +229,7 @@
 
 void WollyMine::calculate()
 {
+  STACKTRACE;
 	SpaceObject::calculate();
 
 	existtime += frame_time * 1E-3;
@@ -239,6 +244,7 @@
 
 int WollyMine::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
 	state = 0;
 	return true;
 }

Modified: trunk/source/ships/shpyusra.cpp
===================================================================
--- trunk/source/ships/shpyusra.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpyusra.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -68,6 +68,7 @@
   ShipData *shipData, unsigned int code ):
   Ship( opos, shipAngle, shipData, code )
 {
+  STACKTRACE;
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
   weaponDamage   = get_config_int("Weapon", "Damage", 0);
@@ -77,7 +78,7 @@
 }
 
 int YushRanger::activate_weapon(){
-	STACKTRACE
+  STACKTRACE;
   if( weaponObject ) return FALSE;
   game->add( weaponObject = new YushSpear( this, Vector2(0, 0.5*get_size().y), angle, weaponVelocity,
     weaponDamage, weaponRange, weaponArmour, weaponControl, this, data->spriteWeapon ));
@@ -85,7 +86,7 @@
 }
 
 int YushRanger::activate_special(){
-	STACKTRACE;
+  STACKTRACE;
 	double alpha = atan3(vel.y, vel.x);
 	alpha = normalize(alpha, PI2);
 	double v = vel.length();		//sqrt( vx*vx + vy*vy );
@@ -106,17 +107,17 @@
 }
 
 void YushRanger::calculate_turn_left(){
-	STACKTRACE;
+  STACKTRACE;
 	if( !fire_weapon ) Ship::calculate_turn_left();
 }
 
 void YushRanger::calculate_turn_right(){
-	STACKTRACE;
+  STACKTRACE;
   if( !fire_weapon ) Ship::calculate_turn_right();
 }
 
 void YushRanger::calculate(){
-	STACKTRACE;
+  STACKTRACE;
   Ship::calculate();
   if( weaponObject ){
     if( !weaponObject->exists() || weaponObject->released ){
@@ -136,11 +137,12 @@
 control( ocontrol ), 
 released( false )
 {
+  STACKTRACE;
 }
 
 void YushSpear::calculate()
 {
-	STACKTRACE;
+  STACKTRACE;
 
 	if (latched)
 	{
@@ -190,11 +192,13 @@
 }
 
 void YushSpear::release(){
+  STACKTRACE;
 	released = true;
 }
 
 void YushSpear::inflict_damage( SpaceObject* other )
 {
+  STACKTRACE;
   if( latched || other->isShot() ) return;
   if( !other->isAsteroid() ) Shot::inflict_damage( other );
   state = 1;                   // don't want to die on contact
@@ -212,6 +216,7 @@
 
 int YushSpear::handle_damage( SpaceLocation* other, double normal, double direct )
 {
+  STACKTRACE;
   if( latched )
     {
       latched->handle_damage( other, normal, direct );

Modified: trunk/source/ships/shpzeksh.cpp
===================================================================
--- trunk/source/ships/shpzeksh.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpzeksh.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -60,6 +60,7 @@
 	:
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
   weaponDamage   = get_config_int("Weapon", "Damage", 0);
@@ -76,6 +77,7 @@
 
 int ZekfahanShocker::activate_weapon()
 {
+  STACKTRACE;
   tw_sound.stop_sound(data_full_path(data->sampleWeapon[0]));
   tw_sound.play_sound(data_full_path(data->sampleWeapon[0]));
   
@@ -88,6 +90,7 @@
 
 int ZekfahanShocker::activate_special() 
 {
+  STACKTRACE;
   if(shockingFrames == 0)
     {
       tw_sound.stop_sound(data_full_path(data->sampleSpecial[0]));
@@ -101,7 +104,8 @@
 }
 
 void ZekfahanShocker::calculate()
-{ 
+{
+  STACKTRACE; 
   if(shockVar == 1)
   {
     if(shockingFrames > 0) 
@@ -133,11 +137,13 @@
   SpaceSprite *osprite, int ofcount, int ofsize) :
   AnimatedShot(oship, oposvec, oangle, ov, odamage, orange, oarmour, oship, osprite, ofcount, ofsize)
 {
+  STACKTRACE;
   collide_flag_anyone = (ALL_LAYERS);
 }
 
 void Shockwave::inflict_damage(SpaceObject *other) 
 {
+  STACKTRACE;
   tw_sound.stop_sound(data_full_path(data->sampleSpecial[2]));
   tw_sound.play_sound(data_full_path(data->sampleSpecial[2]));
  

Modified: trunk/source/twgui/twbutton.cpp
===================================================================
--- trunk/source/twgui/twbutton.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/twgui/twbutton.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -31,6 +31,7 @@
 
 EmptyButton::EmptyButton(TWindow *menu, char *identbranch, int asciicode, bool akeepkey)
 {
+  STACKTRACE;
   prev = 0;
   next = 0;
   selected = false;
@@ -78,6 +79,7 @@
 
 bool EmptyButton::hasmouse()
 {
+  STACKTRACE;
   return (mainwindow->mpos.x >= pos.x &&
 	  mainwindow->mpos.y >= pos.y &&
 	  mainwindow->mpos.x < (pos+size).x &&
@@ -88,11 +90,13 @@
 
 bool EmptyButton::haskey()
 {
+  STACKTRACE;
   return flag.haskey;
 }
 
 bool EmptyButton::haskeypress()
 {
+  STACKTRACE;
   return flag.haskeypress;
 }
 
@@ -102,6 +106,7 @@
 // made for the detection flag
 void EmptyButton::check_key()
 {
+  STACKTRACE;
   // this is usually the case.
   flag.haskey = false;
   flag.haskeypress = false;
@@ -157,7 +162,8 @@
 
 
 void EmptyButton::handle_focus()
-{	
+{
+  STACKTRACE;	
   //mainwindow->setfocus(this);
   
   //focus = 1;
@@ -169,7 +175,8 @@
 
 
 void EmptyButton::handle_defocus()
-{	
+{
+  STACKTRACE;	
   flag.focus = false;
   
   //	if (button_event)
@@ -179,6 +186,7 @@
 
 void EmptyButton::check_focus()
 {
+  STACKTRACE;
   flag.lastfocus = flag.focus;
   
   if (haskey())
@@ -215,6 +223,7 @@
 // calls to calculate aren't made...
 void EmptyButton::handle_menu_focus_loss()
 {
+  STACKTRACE;
   selected = 0;
   //update_key();
   flag.reset();
@@ -222,6 +231,7 @@
 
 void EmptyButton::calculate()
 {
+  STACKTRACE;
   
   // copy information from the TWindow manager
   //	update_mouse();
@@ -297,12 +307,14 @@
 
 void EmptyButton::animate()
 {
+  STACKTRACE;
 }
 	
 
 
 EmptyButton::flag_struct::flag_struct()
 {
+  STACKTRACE;
 	// these flags are updated by the area's calculate function.
 //	focus = 0;
 //	left_mouse_press = left_mouse_release = left_mouse_hold = 0;
@@ -313,6 +325,7 @@
 
 void EmptyButton::flag_struct::reset()
 {
+  STACKTRACE;
   // these flags are updated by the area's calculate function.
   focus = 0;
   left_mouse_press = left_mouse_release = left_mouse_hold = 0;
@@ -323,6 +336,7 @@
 
 bool EmptyButton::isvalid()
 {
+  STACKTRACE;
   return true;
 }
 
@@ -338,11 +352,13 @@
 :
 EmptyButton(menu, identbranch, asciicode, akeepkey)
 {
+  STACKTRACE;
 //	mainwindow->scalepos(&x, &y);
 }
 
 void GraphicButton::locate(int ax, int ay)
 {
+  STACKTRACE;
   pos.x = ax;
   pos.y = ay;
   mainwindow->scalepos(&pos);
@@ -355,6 +371,7 @@
 
 void GraphicButton::animate()
 {
+  STACKTRACE;
   // check if button 1 (left) releases -> clicks for this item
   // unconditional drawing:
   if (flag.focus)
@@ -372,14 +389,17 @@
 
 void GraphicButton::draw_default()
 {
+  STACKTRACE;
 }
 
 void GraphicButton::draw_focus()
 {
+  STACKTRACE;
 }
 
 void GraphicButton::draw_selected()
 {
+  STACKTRACE;
 }
 
 
@@ -404,6 +424,7 @@
 // check a square area to see if it has the mouse on it.
 bool GraphicButton::hasmouse(BITMAP *bmpref)
 {
+  STACKTRACE;
   // first, check the square bitmap area
   if (EmptyButton::hasmouse())
     {
@@ -420,6 +441,7 @@
 
 void GraphicButton::draw_rect()
 {
+  STACKTRACE;
   BITMAP *b = mainwindow->drawarea;
   int x1, y1, x2, y2;
   
@@ -458,6 +480,7 @@
 
 void GraphicButton::draw_rect_fancy()
 {
+  STACKTRACE;
   BITMAP *b = mainwindow->drawarea;
   int x1, y1, x2, y2;
   
@@ -528,6 +551,7 @@
 
 void GraphicButton::draw_boundaries(BITMAP *bmpref)
 {
+  STACKTRACE;
   BITMAP *b = mainwindow->drawarea;
   
   int i, j;
@@ -574,6 +598,7 @@
 */
 void GraphicButton::locate_by_backgr(char *strid)
 {
+  STACKTRACE;
   char stron[128];
   strcpy(stron,  ident);
   strcat(stron,  strid);
@@ -629,6 +654,7 @@
 // obtain a bitmap, specific to this "object" :
 BITMAP *GraphicButton::getbmp(char *name)
 {
+  STACKTRACE;
   char streditbox[128];
   strcpy(streditbox,  ident);
   strcat(streditbox,  name);
@@ -641,6 +667,7 @@
 // obtain a bitmap using "absolute" path, so that it can come from anywhere...
 BITMAP *GraphicButton::getbmp_nobutton(char *name)
 {
+  STACKTRACE;
   // a background image is needed of course.
   return mainwindow->bmp(name);
 }
@@ -650,6 +677,7 @@
 
 void GraphicButton::init_pos_size(BITMAP **bmp_default, char *idstr)
 {
+  STACKTRACE;
   *bmp_default = getbmp(idstr);
   
   if (*bmp_default)
@@ -675,6 +703,7 @@
 
 bool GraphicButton::draw(BITMAP *b)
 {
+  STACKTRACE;
   if (b)
     {
       masked_blit(b, mainwindow->drawarea, 0, 0, pos.x, pos.y, b->w, b->h);

Modified: trunk/source/twgui/twbuttontypes.cpp
===================================================================
--- trunk/source/twgui/twbuttontypes.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/twgui/twbuttontypes.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -36,6 +36,7 @@
 :
 GraphicButton(menu, identbranch, asciicode, akeepkey)
 {
+  STACKTRACE;
 	init_pos_size(&bmp_default, "default");
 
 	bmp_focus = getbmp("focus");
@@ -54,11 +55,13 @@
 // this is the default drawing (at rest):
 void Button::draw_default()
 {
+  STACKTRACE;
 	draw(bmp_default);
 }
 
 void Button::draw_focus()
 {
+  STACKTRACE;
 	if (!draw(bmp_focus))
 	{
 		draw_default();
@@ -68,6 +71,7 @@
 
 void Button::draw_selected()
 {
+  STACKTRACE;
 	if (!draw(bmp_selected))
 		draw_default();
 }
@@ -75,12 +79,14 @@
 
 bool Button::hasmouse()
 {
+  STACKTRACE;
 	return GraphicButton::hasmouse(bmp_default);
 }
 
 
 bool Button::isvalid()
 {
+  STACKTRACE;
 	return bmp_default != 0;
 };
 
@@ -91,6 +97,7 @@
 :
 GraphicButton(menu, identbranch, asciicode, akeepkey)
 {
+  STACKTRACE;
 	init_pos_size(&backgr, "backgr");
 
 	markfordeletion = true;
@@ -105,6 +112,7 @@
 
 void Area::changebackgr(char *fname)
 {
+  STACKTRACE;
 	BITMAP *newb;
 	//newb = getbmp(fname);
 	newb = getbmp_nobutton(fname);
@@ -122,6 +130,7 @@
 
 void Area::changebackgr(BITMAP *newb)
 {
+  STACKTRACE;
 	if (newb)
 	{
 		if (markfordeletion)
@@ -134,6 +143,7 @@
 
 void Area::overwritebackgr(BITMAP *newb, double scale, int col)
 {
+  STACKTRACE;
 	if (newb && backgr)
 	{
 		clear_to_color(backgr, col);
@@ -146,12 +156,14 @@
 
 void Area::animate()
 {
+  STACKTRACE;
 	draw(backgr);
 }
 
 
 bool Area::hasmouse()
 {
+  STACKTRACE;
 	// the first rough check whether it's in the boxed bitmap area
 	return GraphicButton::hasmouse(backgr);
 }
@@ -159,6 +171,7 @@
 
 bool Area::isvalid()
 {
+  STACKTRACE;
 	return backgr != 0;
 };
 
@@ -175,6 +188,7 @@
 :
 Area(menu, identbranch, asciicode, akeepkey)
 {
+  STACKTRACE;
 
 	//init_pos_size(&backgr, "backgr");
 
@@ -196,6 +210,7 @@
 
 void AreaTablet::animate()
 {
+  STACKTRACE;
 	blit(backgr, drawarea, 0, 0, 0, 0, iround(size.x), iround(size.y));
 
 	subanimate();
@@ -207,6 +222,7 @@
 
 void AreaTablet::subanimate()
 {
+  STACKTRACE;
 	// nothing; you can put extra drawing commands here, stuff that's drawn onto
 	// the background before being blitted onto the reserved area.
 }
@@ -214,6 +230,7 @@
 
 bool AreaTablet::hasmouse()
 {
+  STACKTRACE;
 	// the first rough check whether it's in the boxed bitmap area
 	return GraphicButton::hasmouse(backgr);
 }
@@ -221,6 +238,7 @@
 
 bool AreaTablet::isvalid()
 {
+  STACKTRACE;
 	return backgr != 0;
 };
 
@@ -237,6 +255,7 @@
 :
 GraphicButton(menu, identbranch, asciicode)
 {
+  STACKTRACE;
 	init_pos_size(&bmp_on, "on");
 	bmp_off = getbmp("off");
 
@@ -251,6 +270,7 @@
 
 void SwitchButton::draw_default()
 {
+  STACKTRACE;
 	if (state)
 		draw(bmp_on);
 	else
@@ -259,6 +279,7 @@
 
 void SwitchButton::draw_focus()
 {
+  STACKTRACE;
 	draw_default();
 	draw_rect_fancy();
 }
@@ -266,12 +287,14 @@
 // is the same as focus, cause a switch cannot be selected all the time !!
 void SwitchButton::draw_selected()
 {
+  STACKTRACE;
 	draw_focus();
 }
 
 
 void SwitchButton::calculate()
 {
+  STACKTRACE;
 	GraphicButton::calculate();
 
 	// determine if the state of the button is being changed by (some) interaction:
@@ -282,6 +305,7 @@
 
 bool SwitchButton::hasmouse()
 {
+  STACKTRACE;
 	// the first rough check whether it's in the boxed bitmap area
 	return GraphicButton::hasmouse(bmp_on);
 }
@@ -289,6 +313,7 @@
 
 bool SwitchButton::isvalid()
 {
+  STACKTRACE;
 	return bmp_on != 0;
 };
 
@@ -301,6 +326,7 @@
 :
 EmptyButton(menu)
 {
+  STACKTRACE;
 	passive = true;
 }
 GhostButton::~GhostButton()
@@ -315,6 +341,7 @@
 :
 AreaTablet(menu, identbranch, 255)
 {
+  STACKTRACE;
 	relpos = 0.0;	// between 0 and 1
 
 	button = getbmp("button");
@@ -354,6 +381,7 @@
 
 void ScrollBar::handle_lhold()
 {
+  STACKTRACE;
 	if (direction == ver)
 		pbutton = iround(mainwindow->mpos.y - pos.y);		// mouse pos relative in the little bar area
 	else
@@ -371,6 +399,7 @@
 
 void ScrollBar::subanimate()
 {
+  STACKTRACE;
 	AreaTablet::subanimate();
 
 	if (direction == ver)
@@ -382,6 +411,7 @@
 
 void ScrollBar::setrelpos(double arelpos)
 {
+  STACKTRACE;
 	if (relpos == arelpos)
 		return;
 
@@ -394,6 +424,7 @@
 
 void ScrollBar::calculate()
 {
+  STACKTRACE;
 	AreaTablet::calculate();
 }
 

Modified: trunk/source/twgui/twgui.cpp
===================================================================
--- trunk/source/twgui/twgui.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/twgui/twgui.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -38,18 +38,21 @@
 :
 AreaTablet(menu, identbranch, asciicode, akeepkey)
 {
+  STACKTRACE;
 	scroll.setup(mainwindow, identbranch);//, &scroll);
 }
 
 
 int AreaTabletScrolled::gety()
 {
+  STACKTRACE;
 	return scroll.yselect;
 }
 
 
 void AreaTabletScrolled::calculate()
 {
+  STACKTRACE;
 	AreaTablet::calculate();
 
 	scroll.calculate();
@@ -67,6 +70,7 @@
 :
 AreaTablet(menu, identbranch, 255)
 {
+  STACKTRACE;
 	usefont = afont;
 	text = 0;
 
@@ -81,6 +85,7 @@
 
 void TextButton::set_text(char *newtext, int color)
 {
+  STACKTRACE;
 	if (newtext)
 	{
 		if (text && strlen(text) < strlen(newtext))
@@ -100,6 +105,7 @@
 
 void TextButton::subanimate()
 {
+  STACKTRACE;
 	int xcentre, ycentre;
 
 	xcentre = iround(size.x / 2);
@@ -125,6 +131,7 @@
 :
 AreaTabletScrolled(menu, identbranch, 255)
 {
+  STACKTRACE;
 	usefont = afont;
 	Htxt = text_height(usefont);
 	text_color = makecol(0,0,0);
@@ -154,6 +161,7 @@
 
 void TextList::calculate()
 {
+  STACKTRACE;
 	AreaTablet::calculate();
 
 	scroll.calculate();
@@ -170,6 +178,7 @@
 
 void TextList::set_selected(int iy)
 {
+  STACKTRACE;
 //	yselected = iy;
 	if ( iy >= 0 && iy < N )
 		scroll.yselect = iy;
@@ -179,6 +188,7 @@
 
 void TextList::clear_optionlist()
 {
+  STACKTRACE;
 	int i;
 
 	if (optionlist)			// delete an existing set of strings first.
@@ -200,6 +210,7 @@
 
 void TextList::set_optionlist(char **aoptionlist, int color)
 {
+  STACKTRACE;
 	int aN;
 
 	// in this case, where the number of elements in the list isn't explicitly
@@ -216,6 +227,7 @@
 
 void TextList::set_optionlist(char **aoptionlist, int aN, int color)
 {
+  STACKTRACE;
 	int i;
 
 	clear_optionlist();		// note that this resets N .
@@ -249,6 +261,7 @@
 
 void TextList::add_optionlist(char *newstr)
 {
+  STACKTRACE;
 	if (!optionlist)
 	{
 		Nreserved = 128;
@@ -277,6 +290,7 @@
 // if the mouse is clicked within the window:
 void TextList::handle_lpress()
 {
+  STACKTRACE;
 
 	int iy;
 	
@@ -304,12 +318,14 @@
 
 int TextList::getk()
 {
+  STACKTRACE;
 	return scroll.yselect;
 }
 
 // select and center the list on "that" item
 void TextList::handle_rpress()
 {
+  STACKTRACE;
 	
 	int iy;
 	
@@ -329,6 +345,7 @@
 
 void TextList::subanimate()
 {
+  STACKTRACE;
 
 	if (!optionlist || N == 0)
 		return;				// if it's an empty list
@@ -392,6 +409,7 @@
 :
 AreaTabletScrolled(menu, identbranch, 255)
 {
+  STACKTRACE;
 	usefont = afont;
 //	Htxt = text_height(usefont);
 	text_color = makecol(0,0,0);
@@ -425,6 +443,7 @@
 // the following could be used for editing text that's stored elsewhere
 void TextInfoArea::set_textinfo_unbuffered(char *newtext, int Nchars)
 {
+  STACKTRACE;
 	if (textinfo)
 		delete textinfo;
 
@@ -439,6 +458,7 @@
 // other external factors.
 void TextInfoArea::set_textinfo(char *newtext, int Nchars)
 {
+  STACKTRACE;
 
 	if (localcopy)
 		delete localcopy;
@@ -457,6 +477,7 @@
 
 void TextInfoArea::set_textinfo(char *atextinfo)
 {
+  STACKTRACE;
 	set_textinfo(atextinfo, strlen(atextinfo));
 }
 
@@ -464,6 +485,7 @@
 
 void TextInfoArea::subanimate()
 {
+  STACKTRACE;
 
 	text_mode(-1);
 
@@ -528,6 +550,7 @@
 :
 TextInfoArea(menu, identbranch, afont, atext, amaxtext)
 {
+  STACKTRACE;
 	//usefont = afont;
 	text = atext;
 	maxchars = amaxtext;	// a short line?
@@ -574,6 +597,7 @@
 
 void TextEditBox::set_textcolor(int c)
 {
+  STACKTRACE;
 	text_color = c;
 }
 
@@ -583,6 +607,7 @@
 // if the mouse button was pressed .. update text pos to current mouse cursor pos.
 void TextEditBox::handle_lpress()
 {
+  STACKTRACE;
 	// but only if the enter-key wasn't pressed (that can also intiate this?)
 	if (keyhandler.keyhit[KEY_ENTER])
 		return;
@@ -615,6 +640,7 @@
 
 void TextEditBox::text_reset(char *newtext, int N)
 {
+  STACKTRACE;
 	textinfo->textinfo = newtext;
 	text = newtext;
 	textinfo->Nchars = N;
@@ -624,6 +650,7 @@
 
 void TextEditBox::text_reset()
 {
+  STACKTRACE;
 
 	textinfo->reset(&scroll);
 
@@ -643,6 +670,7 @@
 // this is, where text is detected and entered ... I think ....
 void TextEditBox::calculate()
 {
+  STACKTRACE;
 	if (textinfo->textinfo != text) {tw_error("text mismatch");}
 
 	TextInfoArea::calculate();
@@ -813,6 +841,7 @@
 
 void TextEditBox::subanimate()
 {
+  STACKTRACE;
 
 //	TextInfoArea::subanimate();
 
@@ -879,6 +908,7 @@
 
 char *TextEditBox::get_text()
 {
+  STACKTRACE;
 	return text;
 }
 
@@ -906,6 +936,7 @@
 :
 AreaTabletScrolled(menu, identbranch, akey)
 {
+  STACKTRACE;
 
 	scroll.set(0, 0, 1, 1, 1, 1);
 
@@ -945,6 +976,7 @@
 
 void MatrixIcons::set_iconinfo(BITMAP **alistIcon, double ascale)
 {
+  STACKTRACE;
 	listIcon = alistIcon;
 
 	// do nothing, if there are no data (doh)
@@ -990,6 +1022,7 @@
 // this is done just after mouse/key update, but before the handle* routines.
 void MatrixIcons::subcalculate()
 {
+  STACKTRACE;
 
 	// additionally, if there's mouse movement within this region, you should
 	// override settings of the scroll menu, namely, which particular icon is
@@ -1005,6 +1038,7 @@
 
 void MatrixIcons::subanimate()
 {
+  STACKTRACE;
 
 	int i, j;
 	int ix, iy;
@@ -1065,6 +1099,7 @@
 // this action is used to scroll left/right/up/down
 void MatrixIcons::handle_rpress()
 {
+  STACKTRACE;
 	int mx, my;
 	
 	// mouse position relative to the center of the item window:
@@ -1079,12 +1114,14 @@
 // select some icon :
 void MatrixIcons::handle_lpress()
 {
+  STACKTRACE;
 	selected = true;
 }
 
 
 int MatrixIcons::getk()
 {
+  STACKTRACE;
 	int k;
 	k = scroll.xselect + scroll.yselect * Nx;
 

Modified: trunk/source/twgui/twhelpers.cpp
===================================================================
--- trunk/source/twgui/twhelpers.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/twgui/twhelpers.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -32,6 +32,7 @@
 
 ScrollControl::ScrollControl()
 {
+  STACKTRACE;
 	x = 0;
 	y = 0;
 
@@ -47,6 +48,7 @@
 void ScrollControl::set(int xscroll, int yscroll, int Nxscroll, int Nyscroll,
 						int Nx_show, int Ny_show)
 {
+  STACKTRACE;
 	x = xscroll;	// this is top-left corner item of the visible screen
 	y = yscroll;
 
@@ -74,6 +76,7 @@
 
 void ScrollControl::check_pos()
 {
+  STACKTRACE;
 	// check the scroll position
 	if (x > Nx-1)
 		x = Nx-1;
@@ -106,6 +109,7 @@
 
 void ScrollControl::add(int dx, int dy)
 {
+  STACKTRACE;
 	x += dx;
 	y += dy;
 
@@ -116,6 +120,7 @@
 
 void ScrollControl::check_sel()
 {
+  STACKTRACE;
 	if (xselect < x)
 		x = xselect;
 
@@ -133,6 +138,7 @@
 
 void ScrollControl::set_sel(int xsel, int ysel)
 {
+  STACKTRACE;
 	xselect = xsel;
 	yselect = ysel;
 
@@ -145,18 +151,21 @@
 // alpha is a value between 0 and 1
 void ScrollControl::set_percent_pos_x(double alpha)
 {
+  STACKTRACE;
 	x = iround( (Nx-1) * alpha );
 	check_pos();
 }
 
 void ScrollControl::set_percent_pos_y(double alpha)
 {
+  STACKTRACE;
 	y = iround( (Ny-1) * alpha );
 	check_pos();
 }
 
 void ScrollControl::set_pos(int xnew, int ynew)
 {
+  STACKTRACE;
 	if ( xnew >= 0 && xnew < Nx && ynew >= 0 && ynew < Ny )
 	{
 		x = xnew;
@@ -175,6 +184,7 @@
 // vertical, or a default value.
 double ScrollControl::get_relpos()
 {
+  STACKTRACE;
 	if (scrollhor)
 		return scrollhor->relpos;
 	if (scrollvert)
@@ -186,6 +196,7 @@
 
 void ScrollControl::calculate()
 {
+  STACKTRACE;
 	int xold, yold;
 
 	xold = x;
@@ -247,6 +258,7 @@
 								EmptyButton *aup, EmptyButton *adown,
 								ScrollBar *ascrollhor, ScrollBar *ascrollvert)
 {
+  STACKTRACE;
 	left = aleft;
 	right = aright;
 	up = aup;
@@ -355,6 +367,7 @@
 
 TextInfo::TextInfo(FONT *afont, BITMAP *abmp, char *atextinfo, int aNchars)
 {
+  STACKTRACE;
 	bmp = abmp;
 	usefont = afont;
 	textinfo = atextinfo;
@@ -374,6 +387,7 @@
 
 void TextInfo::reset(ScrollControl *scroll)
 {
+  STACKTRACE;
 
 	// "initialize" the text:
 	int n, len;
@@ -458,6 +472,7 @@
 // go from line-coordinate to bitmap coordinate
 void TextInfo::getxy(int charpos, int *x, int *y)
 {
+  STACKTRACE;
 	int iline;
 
 	iline = 0;
@@ -493,6 +508,7 @@
 // map (x) coordinate to character number
 int TextInfo::getcharpos(char *scantxt, int x, int max)
 {
+  STACKTRACE;
 	int i;
 	i = 0;
 
@@ -523,6 +539,7 @@
 // map (x,y) coordinate to character number
 int TextInfo::getcharpos(int x, int y)
 {
+  STACKTRACE;
 	int iline;
 
 	iline = y / Htxt;
@@ -563,6 +580,7 @@
 
 void TextInfo::changeline(int *charpos, int line1, int line2)
 {
+  STACKTRACE;
 
 	if (line2 > Nlines-1)
 		line2 = Nlines-1;

Modified: trunk/source/twgui/twmenuexamples.cpp
===================================================================
--- trunk/source/twgui/twmenuexamples.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/twgui/twmenuexamples.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -40,6 +40,7 @@
 :
 PopupT(creator, ident, axshift, ayshift)
 {
+  STACKTRACE;
 	// add a text list box
 	tia = new TextInfoArea(this, id2, afont, atext, aNchar);//, &scroll);
 	//tia->set_textinfo(atext, aNchar);
@@ -62,6 +63,7 @@
 
 void PopupTextInfo::check_end()
 {
+  STACKTRACE;
 	if (closebutton->flag.left_mouse_press)
 		close(-1);
 }
@@ -75,12 +77,14 @@
 :
 PopupTextInfo(creator, ident, id2, axshift, ayshift, afont, atext, aNchar)
 {
+  STACKTRACE;
 };
 
 
 
 void PopupTextInfo_toggle::calculate()
 {
+  STACKTRACE;
 	PopupTextInfo::calculate();
 }
 
@@ -104,6 +108,7 @@
 :
 PopupT(ident, axshift, ayshift, outputscreen)
 {
+  STACKTRACE;
 	tbl = new TextList(this, id2, afont);
 	tbl->set_optionlist(aoptionslist, makecol(0,0,0));
 
@@ -116,6 +121,7 @@
 :
 PopupT(atrigger, ident, axshift, ayshift)
 {
+  STACKTRACE;
 	//optionslist = aoptionslist;
 
 	// add a text list box
@@ -140,6 +146,7 @@
 // this calls close with return value
 void PopupList::check_end()
 {
+  STACKTRACE;
 	PopupT::check_end();		// this is also a way to end (without choosing anything)
 
 	if (tbl->selected)
@@ -164,6 +171,7 @@
 :
 Popup(ident, axshift, ayshift, outputscreen)
 {
+  STACKTRACE;
 
 	icons = new MatrixIcons(this, "icon_", KEY_ENTER);
 
@@ -198,6 +206,7 @@
 // (the general close is ok, it closes and hides the menu).
 void PopupFleetSelection::check_end()
 {
+  STACKTRACE;
 	if (icons->selected)
 		close(icons->getk());
 }
@@ -206,6 +215,7 @@
 
 void PopupFleetSelection::newscan(BITMAP **alistIcon, double ascale, char *txt)
 {
+  STACKTRACE;
 	Popup::newscan();
 	icons->set_iconinfo(alistIcon, ascale);
 	info->set_text(txt, makecol(255,255,0));
@@ -218,6 +228,7 @@
 // let the "main" routine determine whether to stop or not ;)
 void PopupFleetSelection::check_end()
 {
+  STACKTRACE;
 	if (icons->selected)
 		close(icons->getk());
 }
@@ -238,6 +249,7 @@
 			xcenter, ycenter,
 			outputscreen)
 {
+  STACKTRACE;
 	yes = new Button(this, "yes_",KEY_Y);
 
 	no = new Button(this, "no_", KEY_N);
@@ -251,6 +263,7 @@
 
 void PopupYN::check_end()
 {
+  STACKTRACE;
 	if (yes->flag.left_mouse_press)
 		close(1);
 	if (no->flag.left_mouse_press)
@@ -272,6 +285,7 @@
 			xcenter, ycenter,
 			outputscreen)
 {
+  STACKTRACE;
 	ok = new Button(this, "ok_", KEY_ENTER);
 
 	exclusive = true;
@@ -283,6 +297,7 @@
 
 void PopupOk::check_end()
 {
+  STACKTRACE;
 	if (ok->flag.left_mouse_press)
 		close(1);
 }
@@ -300,6 +315,7 @@
 :
 PopupList(creator, ident, "list_", axshift, ayshift, afont, 0)
 {
+  STACKTRACE;
 	strcpy(dir, ".");	// you can't get below this (which is the game directory)
 	strcpy(fname, "none");
 
@@ -321,6 +337,7 @@
 
 void FileBrowser::set_dir(char *newdir)
 {
+  STACKTRACE;
 	strcpy(dir, newdir);
 	reset_dirlist();
 }
@@ -329,6 +346,7 @@
 
 void FileBrowser::set_ext(char *ext)
 {
+  STACKTRACE;
 	strcpy(required_ext, ".");
 	strcat(required_ext, ext);
 }
@@ -336,6 +354,7 @@
 
 void FileBrowser::reset_dirlist()
 {
+  STACKTRACE;
 	int err;
 	al_ffblk info;
 	
@@ -388,6 +407,7 @@
 
 void FileBrowser::calculate()
 {
+  STACKTRACE;
 	PopupList::calculate();
 
 	if (disabled)
@@ -438,6 +458,7 @@
 // this calls close with return value
 void FileBrowser::check_end()
 {
+  STACKTRACE;
 	if (selection)
 	{
 		selection = false;
@@ -465,6 +486,7 @@
 
 void ValueStr::set(valuetypes atype, char *adescr, double amin, double amax)
 {
+  STACKTRACE;
 	type = atype;
 	strncpy(descr, adescr, sizeof(descr)-1);
 	min = amin;
@@ -480,6 +502,7 @@
 
 double ValueStr::getval()
 {
+  STACKTRACE;
 	if (type == vtype_float)
 		return value;
 	else
@@ -493,6 +516,7 @@
 :
 EmptyButton(menu, identbranch)
 {
+  STACKTRACE;
 	Nmax = aNmax;
 	values = new ValueStr* [Nmax];
 
@@ -538,12 +562,14 @@
 
 void ValueEdit::edit_update()
 {
+  STACKTRACE;
 	sprintf(edit->text, values[isel]->format, values[isel]->value);
 }
 
 
 void ValueEdit::calculate()
 {
+  STACKTRACE;
 	EmptyButton::calculate();
 
 	// the scrollbar:

Modified: trunk/source/twgui/twpopup.cpp
===================================================================
--- trunk/source/twgui/twpopup.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/twgui/twpopup.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -37,6 +37,7 @@
 :
 TWindow(ident, xcenter, ycenter, outputscreen)
 {
+  STACKTRACE;
 	movingthereserve = false;
 
 	center(xcenter, ycenter);		// center around this position, in relative coordinates
@@ -51,6 +52,7 @@
 
 void Popup::doneinit()
 {
+  STACKTRACE;
 	TWindow::doneinit();
 
 	hide();
@@ -61,12 +63,14 @@
 // (the general close is ok, it closes and hides the menu).
 void Popup::check_end()
 {
+  STACKTRACE;
 	// nothing
 }
 
 
 void Popup::calculate()
 {
+  STACKTRACE;
 	// must be called before the "return", otherwise focus-loss isn't called
 	TWindow::calculate();
 
@@ -119,6 +123,7 @@
 
 void Popup::close(int areturnstatus)
 {
+  STACKTRACE;
 	hide();
 
 	returnstatus = areturnstatus;
@@ -130,6 +135,7 @@
 // resets its "ready" status as well.
 bool Popup::ready()
 {
+  STACKTRACE;
 	if (returnvalueready)
 	{
 		returnvalueready = false;
@@ -141,6 +147,7 @@
 // call this to get a int-value from some selection mechanism (eg a list)
 int Popup::getvalue()
 {
+  STACKTRACE;
 //	if (!returnvalueready)
 //		return -1;				// otherwise it's undefined
 
@@ -152,6 +159,7 @@
 // restore the ability to do calculations and actions
 void Popup::enable()
 {
+  STACKTRACE;
 	TWindow::enable();
 	returnvalueready = false;
 }
@@ -160,6 +168,7 @@
 
 void Popup::newscan()
 {
+  STACKTRACE;
 	show();	// (more general than enable)
 	ready();
 }
@@ -192,6 +201,7 @@
 :
 Popup(identbranch, axshift, ayshift, outputscreen)
 {
+  STACKTRACE;
 	trigger = 0;
 
 	init_components(identbranch);
@@ -206,6 +216,7 @@
 			axshift, ayshift,
 			atrigger->mainwindow->screen)
 {
+  STACKTRACE;
 	trigger = atrigger;
 
 	init_components(identbranch);
@@ -218,6 +229,7 @@
 
 void PopupT::init_components(char *id)
 {
+  STACKTRACE;
 	returnvalueready = false;
 
 	// and default option settings:
@@ -254,6 +266,7 @@
 
 void PopupT::calculate()
 {
+  STACKTRACE;
 	// must be called before the "return", otherwise focus-loss isn't called
 	Popup::calculate();
 
@@ -319,6 +332,7 @@
 
 void PopupT::handle_focus_loss()
 {
+  STACKTRACE;
 	/*
 	if (!close_on_defocus)
 		return;
@@ -335,6 +349,7 @@
 
 void PopupT::close(int areturnstatus)
 {
+  STACKTRACE;
 	if (trigger)
 	{
 		// give back focus/control to the window that called this window.
@@ -353,6 +368,7 @@
 // you can (and should) replace this routine with one suited for your own purposes
 void PopupT::check_end()
 {
+  STACKTRACE;
 //	if (!hidden && !hasfocus && close_on_defocus)	// to prevent this from being called twice, due to recursive call to handle_focus() in hide()
 //	{
 		//tw_error("PopupList : Losing focus !!");

Modified: trunk/source/twgui/twwindow.cpp
===================================================================
--- trunk/source/twgui/twwindow.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/twgui/twwindow.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -47,6 +47,7 @@
 // this is used to scale them to other screen resolutions.
 TWindow::TWindow(char *identbase, int dx, int dy, BITMAP *outputscreen, bool vidwin)
 {
+  STACKTRACE;
 	prev = 0;
 	next = 0;
 
@@ -224,6 +225,7 @@
 
 TWindow *TWindow::tree_root()
 {
+  STACKTRACE;
 	TWindow *current;
 	current = this;
 	while (current->prev)
@@ -235,6 +237,7 @@
 
 TWindow *TWindow::tree_last()
 {
+  STACKTRACE;
 	TWindow *current;
 	current = this;
 	while (current->next)
@@ -247,6 +250,7 @@
 
 void TWindow::tree_calculate()
 {
+  STACKTRACE;
 	TWindow *current;
 	current = tree_root();
 
@@ -273,6 +277,7 @@
 
 void TWindow::tree_animate()
 {
+  STACKTRACE;
 	TWindow *current;
 	current = tree_last();
 
@@ -292,6 +297,7 @@
 
 void TWindow::focus()
 {
+  STACKTRACE;
 	// no need if this already is the root ... cause then it already has the focus.
 	if (!prev)
 		return;
@@ -323,6 +329,7 @@
 
 void TWindow::tree_setscreen(BITMAP *scr)
 {
+  STACKTRACE;
 	TWindow *current;
 	current = tree_root();
 
@@ -338,6 +345,7 @@
 // add a window at the end of the window list
 void TWindow::add(TWindow *newwindow)
 {
+  STACKTRACE;
 	TWindow *current;
 	current = this;
 	while (current->next)
@@ -351,6 +359,7 @@
 // call all the clean up routines for all the menus
 void TWindow::tree_doneinit()
 {
+  STACKTRACE;
 	TWindow *current;
 	current = tree_root();
 
@@ -365,6 +374,7 @@
 
 bool TWindow::hasfocus()
 {
+  STACKTRACE;
 	// only the root has primary focus...
 	return (prev != 0);
 }
@@ -387,6 +397,7 @@
 
 BITMAP* TWindow::bmp(char *bmpname, bool vidmem)
 {
+  STACKTRACE;
 	BITMAP *bmp, *tmpbmp;
 	int bpp;
 
@@ -417,12 +428,14 @@
 
 void TWindow::doneinit()
 {
+  STACKTRACE;
 	del_bitmap(&backgr_forsearch);
 	//if (datafile)			unload_datafile(datafile);
 }
 
 void TWindow::setscreen(BITMAP *scr)
 {
+  STACKTRACE;
 	screen = scr;
 }
 
@@ -430,6 +443,7 @@
 
 void TWindow::center(int xcenter, int ycenter)
 {
+  STACKTRACE;
 	// put back the background
 	//blit(originalscreen, screen, 0, 0, x, y, W, H);
 
@@ -446,6 +460,7 @@
 
 void TWindow::center_abs(int xcenter, int ycenter)
 {
+  STACKTRACE;
 	// put back the background
 	//blit(originalscreen, screen, 0, 0, x, y, W, H);
 
@@ -459,6 +474,7 @@
 
 void TWindow::center()
 {
+  STACKTRACE;
 	ASSERT(screen)
 	center(screen->w/2, screen->h/2);
 }
@@ -467,12 +483,14 @@
 // changes the "disabled" flag, and possibly does other stuff as well?
 void TWindow::enable()
 {
+  STACKTRACE;
 	disabled = false;
 //	mouse.reset();		// reset the mouse to the newest values.
 }
 
 void TWindow::disable()
 {
+  STACKTRACE;
 	if (!disabled)				// to prevent possible recursive call (disable can be called within focus loss in some cases...)
 	{
 		disabled = true;
@@ -484,6 +502,7 @@
 
 void TWindow::show()
 {
+  STACKTRACE;
 	hidden = false;	// allow animation
 	enable();		// allow calculation
 	focus();		// bring this window to the front of the list, so that it draws on top of the rest
@@ -491,6 +510,7 @@
 
 void TWindow::hide()
 {
+  STACKTRACE;
 	hidden = true;
 	disable();
 	//blit(originalscreen, screen, 0, 0, 0, 0, W, H);
@@ -500,6 +520,7 @@
 
 void TWindow::add(EmptyButton *newbutton)
 {
+  STACKTRACE;
 	if (!button_first)
 	{
 		button_first = newbutton;
@@ -515,6 +536,7 @@
 
 void TWindow::rem(EmptyButton *newbutton)
 {
+  STACKTRACE;
 	if (! newbutton)
 		return;
 
@@ -542,6 +564,7 @@
 
 bool TWindow::checkmouse()
 {
+  STACKTRACE;
 	if (!(prev && prev->grabbedmouse))
 	{
 		// If the mouse hasn't been "grabbed" by a window above this window
@@ -569,6 +592,7 @@
 
 void TWindow::setfocus(EmptyButton *newbutton)
 {
+  STACKTRACE;
 	if (button_focus)
 		button_focus->handle_defocus();
 
@@ -582,6 +606,7 @@
 
 void TWindow::calculate()
 {
+  STACKTRACE;
 
 	if (disabled)
 	{
@@ -712,6 +737,7 @@
 
 void TWindow::animate()
 {
+  STACKTRACE;
 
 	if (hidden)
 		return;
@@ -761,6 +787,7 @@
 
 void TWindow::handle_focus()
 {
+  STACKTRACE;
 	// bring it first in the list ...
 	focus();
 }
@@ -768,6 +795,7 @@
 
 void TWindow::handle_focus_loss()
 {
+  STACKTRACE;
 	//for (int i = 0; i < Nareas; ++i )
 	//	area[i]->handle_menu_focus_loss();
 	EmptyButton *button;
@@ -783,12 +811,14 @@
 
 void TWindow::scalepos(int *ax, int *ay)
 {
+  STACKTRACE;
 	(*ax) = iround( (*ax) * scale );
 	(*ay) = iround( (*ay) * scale );
 }
 
 void TWindow::scalepos(Vector2 *apos)
 {
+  STACKTRACE;
 	(apos->x) = iround( (apos->x) * scale );
 	(apos->y) = iround( (apos->y) * scale );
 }
@@ -838,6 +868,7 @@
 
 bool TWindow::search_bmp_location(BITMAP *bmp_default, Vector2 *apos)
 {
+  STACKTRACE;
 	ASSERT(bmp_default);
 	ASSERT(apos);
 	
@@ -908,6 +939,7 @@
 /*
 void TWindow::focus2other(TWindow *other)
 {
+  STACKTRACE;
 	disable();			// this menu won't generate signals now, but it'll be drawn still
 	other->show();
 	other->prev = this;
@@ -915,6 +947,7 @@
 
 void TWindow::back2other()
 {
+  STACKTRACE;
 	prev->enable();			// switch control back to the meleemenu
 	hide();					// this menu is disabled, and won't be drawn
 	prev = 0;
@@ -924,17 +957,20 @@
 
 void TWindow::update_time()
 {
+  STACKTRACE;
 	menu_time = get_time() - menu_starttime;
 }
 
 /*
 void TWindow::clear_keys()
 {
+  STACKTRACE;
 	keybuff_count = 0;
 }
 
 void TWindow::add_key(int akey)
 {
+  STACKTRACE;
 	if (disabled)
 		return;
 
@@ -948,6 +984,7 @@
 
 void TWindow::add_keys()
 {
+  STACKTRACE;
 	if (keyboard_needs_poll())
 		poll_keyboard();
 

Modified: trunk/source/twgui/utils.cpp
===================================================================
--- trunk/source/twgui/utils.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/twgui/utils.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -42,138 +42,128 @@
 // note, separated are the "key" and the extra "control" key (ctrl, alt)
 int mapkey(int scancode_key, int scancode_ctrl)
 {
-	int k;
+  int k;
 
-	k = scancode_key;
+  k = scancode_key;
 
-	k |= scancode_ctrl << 8;
-	
-	// thus we have 2 scan codes, no more needed.
-	return k;
+  k |= scancode_ctrl << 8;
+  
+  // thus we have 2 scan codes, no more needed.
+  return k;
 }
 
 int unmapkey1(int k)
 {
-	// return the 1st scancode
-	return k & 0x0FF;
+  // return the 1st scancode
+  return k & 0x0FF;
 }
 
 int unmapkey2(int k)
 {
-	// return the 1st scancode
-	return (k >> 8) & 0x0FF;
+  // return the 1st scancode
+  return (k >> 8) & 0x0FF;
 }
 
 
 BITMAP *find_datafile_bmp(DATAFILE *datafile, char *identif)
 {
-	char objname[128];
+  char objname[128];
+  
+  if (strlen(identif) > 120)
+    {
+      tw_error("string exceeds max length");
+    }
+  
+  strcpy(objname, identif);
+  strcat(objname, "_BMP");	// default extension for .bmp files.
 
-	if (strlen(identif) > 120)
-	{
-		tw_error("string exceeds max length");
-	}
+  DATAFILE *dat = find_datafile_object(datafile, objname);
 
-	strcpy(objname, identif);
-	strcat(objname, "_BMP");	// default extension for .bmp files.
-
-	DATAFILE *dat = find_datafile_object(datafile, objname);
-
-	if (!dat)
-	{
-		//char txt[512];
-		//sprintf(txt, "Could not find %s", objname);
-		//tw_error(txt);
-		return 0;
-	}
-
-	if (dat->type == DAT_BITMAP)
-		return (BITMAP*) dat->dat;
-	else
-		return 0;
+  if (!dat)
+    {
+      //char txt[512];
+      //sprintf(txt, "Could not find %s", objname);
+      //tw_error(txt);
+      return 0;
+    }
+  
+  if (dat->type == DAT_BITMAP)
+    return (BITMAP*) dat->dat;
+  else
+    return 0;
 }
 
 
 BITMAP *clone_bitmap(int bpp, BITMAP *src, double scale, bool vidmem)
 {
-	BITMAP *dest, *convert;
+  BITMAP *dest, *convert;
+  
+  if ( !src )
+    return 0;
 
-	if ( !src )
-		return 0;
+  int W, H;
+  
+  W = iround( src->w * scale );
+  H = iround( src->h * scale );
+  
+  dest = create_bitmap_ex(bpp, W, H);
+  
+  convert = create_bitmap_ex(bpp, src->w, src->h);
+  blit(src, convert, 0, 0, 0, 0, src->w, src->h);		// use this to convert color depth
+  
+  if (W != src->w || H != src->h )
+    stretch_blit(convert, dest, 0, 0, convert->w, convert->h, 0, 0, dest->w, dest->h);
+  else
+    blit(convert, dest, 0, 0, 0, 0, W, H);
+  
+  del_bitmap(&convert);
 
-	int W, H;
 
-	W = iround( src->w * scale );
-	H = iround( src->h * scale );
-
-	dest = create_bitmap_ex(bpp, W, H);
-
-	convert = create_bitmap_ex(bpp, src->w, src->h);
-	blit(src, convert, 0, 0, 0, 0, src->w, src->h);		// use this to convert color depth
-
-	if (W != src->w || H != src->h )
-		stretch_blit(convert, dest, 0, 0, convert->w, convert->h, 0, 0, dest->w, dest->h);
-	else
-		blit(convert, dest, 0, 0, 0, 0, W, H);
-
-	del_bitmap(&convert);
-
-
 	
-	// try to store this in memory, if there's enough room for it
-	// cause the menu-bitmaps are pretty large, and take lotsa time to draw ...
-	if (vidmem)
+  // try to store this in memory, if there's enough room for it
+  // cause the menu-bitmaps are pretty large, and take lotsa time to draw ...
+  if (vidmem)
+    {
+      convert = create_video_bitmap(W, H);
+      if (convert)
 	{
-		convert = create_video_bitmap(W, H);
-		if (convert)
-		{
-			blit(dest, convert, 0, 0, 0, 0, W, H);
-			del_bitmap(&dest);
-			dest = convert;
-		}
+	  blit(dest, convert, 0, 0, 0, 0, W, H);
+	  del_bitmap(&dest);
+	  dest = convert;
 	}
+    }
 	
-
-	return dest;
+  
+  return dest;
 }
 
-
-
-
-
-
-
-
-
-
-
 normalmouse::normalmouse()
 {
-	bmp.original_mouse_sprite = mouse_sprite;
-	bmp.newmousebmp = 0;
+  bmp.original_mouse_sprite = mouse_sprite;
+  bmp.newmousebmp = 0;
 
-	reset();
+  reset();
 }
 
 
 void normalmouse::reset()
 {
-	update();		// initialize with current mouse values.
-	pos2 = pos;
-	oldpos = pos;
+  update();		// initialize with current mouse values.
+  pos2 = pos;
+  oldpos = pos;
 }
 
 
 void normalmouse::copyinfo(normalmouse *othermouse)
 {
-	pos    = othermouse->pos;
-	oldpos = othermouse->oldpos;
-	pos2 = othermouse->pos2;
-	left   = othermouse->left;
-	mid    = othermouse->mid;
-	right  = othermouse->right;
-	bmp.newmousebmp = othermouse->bmp.newmousebmp;
-	bmp.original_mouse_sprite = othermouse->bmp.original_mouse_sprite;
+  pos    = othermouse->pos;
+  oldpos = othermouse->oldpos;
+  pos2 = othermouse->pos2;
+  left   = othermouse->left;
+  mid    = othermouse->mid;
+  right  = othermouse->right;
+  bmp.newmousebmp = othermouse->bmp.newmousebmp;
+  bmp.original_mouse_sprite = othermouse->bmp.original_mouse_sprite;
 }
 
 
@@ -182,134 +172,133 @@
 // (unmoved) position every iteration.
 void normalmouse::move(int dx, int dy)
 {
-	pos.x += dx;
-	pos.y += dy;
-
-	oldpos.x += dx;
-	oldpos.y += dy;
+  pos.x += dx;
+  pos.y += dy;
+	
+  oldpos.x += dx;
+  oldpos.y += dy;
 }
 
 int normalmouse::vx()
 {
-	return pos.x - oldpos.x;
+  return pos.x - oldpos.x;
 }
 
 int normalmouse::vy()
 {
-	return pos.y - oldpos.y;
+  return pos.y - oldpos.y;
 }
 
 
 void normalmouse::update()
 {
-	if (mouse_needs_poll())
-		poll_mouse();
+  if (mouse_needs_poll())
+    poll_mouse();
 	
-	oldpos = pos2;	// this is exactly the "old" position, unmoved
-	pos.set(mouse_x, mouse_y, mouse_z);
-	pos2 = pos;
-
-	int b = mouse_b;
-
-	left.update(bool(b & 1));		// make distinction here; individual buttons shouldn't know of each other
-	mid.update(bool(b & 4));
-	right.update(bool(b & 2));
+  oldpos = pos2;	// this is exactly the "old" position, unmoved
+  pos.set(mouse_x, mouse_y, mouse_z);
+  pos2 = pos;
+  
+  int b = mouse_b;
+  
+  left.update(bool(b & 1));		// make distinction here; individual buttons shouldn't know of each other
+  mid.update(bool(b & 4));
+  right.update(bool(b & 2));
 }
 
 
 void normalmouse::mousebutton::update(bool newstatus)
 {
-	// we are mainly interested in changes in the button status.
-	if (newstatus != button.status)
-	{
-		oldbutton = button;
-	
-		button.status = newstatus;	// on or of ;)
+  // we are mainly interested in changes in the button status.
+  if (newstatus != button.status)
+    {
+      oldbutton = button;
+      
+      button.status = newstatus;	// on or of ;)
 
-		if (button.status != oldbutton.status)
-			button.time = get_time() * 1E-3;				// detect timing of a change in button status
-
-		button.change = true;
-
-	} else
-		button.change = false;
+      if (button.status != oldbutton.status)
+	button.time = get_time() * 1E-3;				// detect timing of a change in button status
+      
+      button.change = true;
+      
+    } else
+      button.change = false;
 }
 
 
 
 bool normalmouse::mousebutton::press()
 {
-	if (!button.change)
-		return false;
-
-	if (button.status && (!oldbutton.status))
-		return true;
-	else 
-		return false;
-
+  if (!button.change)
+    return false;
+  
+  if (button.status && (!oldbutton.status))
+    return true;
+  else 
+    return false;
 }
 
 bool normalmouse::mousebutton::release()
 {
-	if (!button.change)
-		return false;
-
-	if ((!button.status) && oldbutton.status)
-		return true;
-	else 
-		return false;
+  if (!button.change)
+    return false;
+  
+  if ((!button.status) && oldbutton.status)
+    return true;
+  else 
+    return false;
 }
 
 bool normalmouse::mousebutton::dclick()
 {
-	if (!button.change)		// check if the mouse is clicked
-		return false;
+  if (!button.change)		// check if the mouse is clicked
+    return false;
+  
+  if (!button.status)		// check if the mouse button is pressed
+    return false;
+  
+  if (button.time - oldbutton.time < 0.2)	// check time between release and press
+    return true;
+  
 
-	if (!button.status)		// check if the mouse button is pressed
-		return false;
-
-	if (button.time - oldbutton.time < 0.2)	// check time between release and press
-		return true;
-	
-
-	return false;
+  return false;
 }
 
 bool normalmouse::mousebutton::hold()
 {
-	return button.status;
+  return button.status;
 }
 
 
 void normalmouse::bmpstr::init(BITMAP *newbmp)
 {
-	newmousebmp = newbmp;
+  newmousebmp = newbmp;
 }
 
 void normalmouse::bmpstr::set()
 {
-	if (newmousebmp)
-	{
-		set_mouse_sprite(newmousebmp);
-	}
+  if (newmousebmp)
+    {
+      set_mouse_sprite(newmousebmp);
+    }
 }
 
 void normalmouse::bmpstr::restore()
 {
-	set_mouse_sprite(original_mouse_sprite);
+  set_mouse_sprite(original_mouse_sprite);
 }
 
 void normalmouse::posstr::set(int xnew, int ynew, int znew)
 {
-	x = xnew;
-	y = ynew;
-	wheel = znew;
+  x = xnew;
+  y = ynew;
+  wheel = znew;
 }
 
 void normalmouse::posstr::move(int dx, int dy)
 {
-	x += dx;
-	y += dy;
+  x += dx;
+  y += dy;
 }
 
 
@@ -332,42 +321,42 @@
 // just make a copy of the input.
 static int my_callback(int key)
 {
-	keyhandler.add(key);
-	return key;
+  keyhandler.add(key);
+  return key;
 }
 
 
 
 TKeyHandler::TKeyHandler()
 {
-	keyboard_callback = my_callback;
-
-	clear();
+  keyboard_callback = my_callback;
+  
+  clear();
 }
 
 
 void TKeyHandler::clear()
 {
-	Nbuf = 0;
-	Nbackbuf = 0;
-
-	int i;
-	for ( i = 0; i < KEY_MAX; ++i )
-	{
-		keynew[i] = key[i];
-		keyold[i] = key[i];
-	}
+  Nbuf = 0;
+  Nbackbuf = 0;
+  
+  int i;
+  for ( i = 0; i < KEY_MAX; ++i )
+    {
+      keynew[i] = key[i];
+      keyold[i] = key[i];
+    }
 }
 
 
 void TKeyHandler::add(int key)
 {
-	if (Nbackbuf >= buffmax)
-		return;
-
-	keybackbuf[Nbackbuf] = key;
-
-	++Nbackbuf;
+  if (Nbackbuf >= buffmax)
+    return;
+  
+  keybackbuf[Nbackbuf] = key;
+  
+  ++Nbackbuf;
 }
 
 void TKeyHandler::clearbuf()
@@ -378,64 +367,64 @@
 
 void TKeyHandler::update()
 {
-	if (keyboard_needs_poll())
-		poll_keyboard();
-
-	// detect key changes ...
-	// (note that changes in-between updates are not seen by this so it's not 100% accurate)
-	int i;
-	for ( i = 0; i < KEY_MAX; ++i )
+  if (keyboard_needs_poll())
+    poll_keyboard();
+  
+  // detect key changes ...
+  // (note that changes in-between updates are not seen by this so it's not 100% accurate)
+  int i;
+  for ( i = 0; i < KEY_MAX; ++i )
+    {
+      // keep record of prev and new states
+      keyold[i] = keynew[i];
+      keynew[i] = key[i];
+      
+      // detect changes
+      keyhit[i] = 0;
+      keyreleased[i] = 0;
+      
+      if (keynew[i] != keyold[i])
 	{
-		// keep record of prev and new states
-		keyold[i] = keynew[i];
-		keynew[i] = key[i];
-
-		// detect changes
-		keyhit[i] = 0;
-		keyreleased[i] = 0;
-
-		if (keynew[i] != keyold[i])
-		{
-			if (keynew[i])
-				keyhit[i] = 1;
-			else
-				keyreleased[i] = 1;
-		}
-
+	  if (keynew[i])
+	    keyhit[i] = 1;
+	  else
+	    keyreleased[i] = 1;
 	}
-
-
-	Nbuf = Nbackbuf;
-	for ( i = 0; i < Nbuf; ++i )
-	{
-		keybuf[i] = keybackbuf[i];
-	}
-	// reset the back-buffer for reading new stuf.
-	Nbackbuf = 0;
-
+      
+    }
+  
+  
+  Nbuf = Nbackbuf;
+  for ( i = 0; i < Nbuf; ++i )
+    {
+      keybuf[i] = keybackbuf[i];
+    }
+  // reset the back-buffer for reading new stuf.
+  Nbackbuf = 0;
+  
 }
 
 
 bool TKeyHandler::pressed(char key)
 {
-	// only compare if the key != 0, otherwise you can get matches with
-	// wierd key combos or something. So, key==0 has the meaning of, don't compare me!
-	if (key == 0)
-		return false;
-
-	//char teststring[128];
-	int i;
-	for (i = 0; i < Nbuf; ++i)
-	{
-		//teststring[i] = keybuf[i] & 0x0FF;
-
-		if ( (keybuf[i] & 0x0FF) == key )	// only compare by ascii code...
-			return true;
-	}
-
-	//teststring[i] = 0;
-	//message.out(teststring);
-
-	return false;
+  // only compare if the key != 0, otherwise you can get matches with
+  // wierd key combos or something. So, key==0 has the meaning of, don't compare me!
+  if (key == 0)
+    return false;
+  
+  //char teststring[128];
+  int i;
+  for (i = 0; i < Nbuf; ++i)
+    {
+      //teststring[i] = keybuf[i] & 0x0FF;
+      
+      if ( (keybuf[i] & 0x0FF) == key )	// only compare by ascii code...
+	return true;
+    }
+  
+  //teststring[i] = 0;
+  //message.out(teststring);
+  
+  return false;
 }
 

Modified: trunk/source/util/base.cpp
===================================================================
--- trunk/source/util/base.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/util/base.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -44,6 +44,7 @@
 ------------------------------*/
 
 void BaseClass::preinit() {
+  STACKTRACE;
 	return;
 }
 BaseClass::~BaseClass() {
@@ -55,12 +56,14 @@
 	return ((void**)this);
 }
 int BaseClass::serialize(void *stream) {
+  STACKTRACE;
 	return 0;
 }
 int BaseClass::_get_size() const {
 	return 0;
 }
 void BaseClass::_event( Event *e) {
+  STACKTRACE;
 	return;
 }
 void BaseClass::issue_event ( std::list<BaseClass*>& recipients, Event *e) {

Modified: trunk/source/util/errors.cpp
===================================================================
--- trunk/source/util/errors.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/util/errors.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -243,8 +243,8 @@
 	return;
 }
 
-std::stack<SOURCE_LINE> UserStackTraceHelper::call_stack;
-UserStackTraceHelper::UserStackTraceHelper( SOURCE_LINE srcline)
+std::stack<SOURCE_LINE*> UserStackTraceHelper::call_stack;
+UserStackTraceHelper::UserStackTraceHelper( SOURCE_LINE* srcline)
 {
   #ifdef DEBUG
   //  debug_log(GetStackNodeString(srcline).c_str());
@@ -258,32 +258,32 @@
   call_stack.pop();
 }
 
-std::string UserStackTraceHelper::GetStackNodeString(SOURCE_LINE stNode)
+std::string UserStackTraceHelper::GetStackNodeString(SOURCE_LINE* stNode)
 {
   std::string strFile;
-  char *_file = strstr(stNode.file, "source");
+  char *_file = strstr(stNode->file, "source");
   if (_file) 
     strFile = _file;
   
   char line[20] = {0};
-  sprintf(line, "%d", stNode.line);
+  sprintf(line, "%d", stNode->line);
       
   std::string strName;
-  if(stNode.name!=NULL)
-    strName = std::string(" ") + stNode.name;
+  if(stNode->name!=NULL)
+    strName = std::string(" ") + stNode->name;
   
-  return std::string("from: ") + strFile + ", line " + line + " funct: " + stNode.funct + strName + "\n";
+  return std::string("from: ") + strFile + ", line " + line + " funct: " + stNode->funct + strName + "\n";
 }
 
 std::string UserStackTraceHelper::get_stack_trace_string()
 {
   std::string stack_string = "";
   
-  std::stack<SOURCE_LINE> tmp;
+  std::stack<SOURCE_LINE*> tmp;
   tmp = call_stack;
   while(!tmp.empty())
     {
-      SOURCE_LINE stNode = tmp.top();
+      SOURCE_LINE* stNode = tmp.top();
       stack_string += GetStackNodeString(stNode);
       tmp.pop();
     }

Modified: trunk/source/util/errors.h
===================================================================
--- trunk/source/util/errors.h	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/util/errors.h	2004-09-20 21:04:58 UTC (rev 60)
@@ -43,10 +43,10 @@
 /// be used to manage  call stack. 
 class UserStackTraceHelper 
 {
-  static std::stack<SOURCE_LINE> call_stack;
-  static std::string GetStackNodeString(SOURCE_LINE stNode);
+  static std::stack<SOURCE_LINE*> call_stack;
+  static std::string GetStackNodeString(SOURCE_LINE* stNode);
  public:
-  UserStackTraceHelper( SOURCE_LINE srcline);
+  UserStackTraceHelper( SOURCE_LINE* srcline);
   ~UserStackTraceHelper();
   
   /// \brief get stack trace string 
@@ -54,8 +54,8 @@
 };
 
 
-#define STACKTRACE SOURCE_LINE _srcline = { __LINE__, __FILE__, __FUNCTION__, 0 }; UserStackTraceHelper _stacktrace_ ( _srcline );
-#define _STACKTRACE(A) SOURCE_LINE _srcline = { __LINE__, __FILE__, __FUNCTION__, A }; UserStackTraceHelper _stacktrace_ ( _srcline );
+#define STACKTRACE static SOURCE_LINE _srcline = { __LINE__, __FILE__, __FUNCTION__, 0 }; UserStackTraceHelper _stacktrace_ ( &_srcline );
+#define _STACKTRACE(A) static SOURCE_LINE _srcline = { __LINE__, __FILE__, __FUNCTION__, A }; UserStackTraceHelper _stacktrace_ ( &_srcline );
 
 
 extern "C" {

Modified: trunk/source/util/history.cpp
===================================================================
--- trunk/source/util/history.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/util/history.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -2,8 +2,8 @@
 #include <math.h>
 #include "base.h"
 #include "history.h"
+#include "errors.h"
 
-
 ////////////////////////////////////////////////////////////////////////
 //				Histograph stuff
 ////////////////////////////////////////////////////////////////////////
@@ -30,6 +30,7 @@
 */
 
 Histograph::Histograph(Uint16 max) {
+  STACKTRACE;
 	num = 0;
 	base = 0;
 	this->max = max;
@@ -42,9 +43,11 @@
 	delete[] element;
 }
 void Histograph::add_element(double v) {
+  STACKTRACE;
 	_add(v);
 }
 void Histograph::_add(double v) {
+  STACKTRACE;
 	int i;
 	if (num == max) {
 		num -= next_ratio;

Modified: trunk/source/util/random.cpp
===================================================================
--- trunk/source/util/random.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/util/random.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -41,9 +41,11 @@
 	ADDITIVE   = 123456789
 };
 Uint32 RNG_lcg64a::randi(Uint32 max) {
+  STACKTRACE;
 	return _rng_dist_32_flat(max, raw32());
 }
 Uint32 RNG_lcg64a::raw32() {
+  STACKTRACE;
 #	if defined(_MSC_VER) && defined(__i386__) && !defined(NO_ASM)
 		split_int_64 i64 = s64;
 		_asm { mov eax, [i64.s.high] } 
@@ -73,6 +75,7 @@
 	return s64.s.high;
 }
 Uint64 RNG_lcg64a::raw64() {
+  STACKTRACE;
 	Uint64 bob = raw32();
 	bob = (bob << 32) | raw32();
 	return bob;
@@ -95,11 +98,13 @@
 }
 
 void RNG_lcg64a::seed( int s ) {
+  STACKTRACE;
 	s64.s.low = s;
 	s64.s.high = 0;
 	return;
 }
 void RNG_lcg64a::seed_more( int s ) {
+  STACKTRACE;
 	if (s64.s.high & 0x80000000) raw32();
 	raw32();
 	s64.s.low += ((s64.s.high >> 27) | (s64.s.high << 5)) ^ s;

Modified: trunk/source/util/sound.cpp
===================================================================
--- trunk/source/util/sound.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/util/sound.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -24,11 +24,12 @@
 
 #include <allegro.h>
 #include "other/twconfig.h"
+#include "errors.h"
 
-
 SoundSystem tw_sound;
 SoundSystem::SoundSystem(bool sound_on)
 {
+  STACKTRACE;
   mix_ok = false;
   current_music = "";
   
@@ -96,6 +97,7 @@
   
 void SoundSystem::play_music(const std::string file, int loops)
 {
+  STACKTRACE;
   if(!mix_ok || current_music == file)
     return;
   
@@ -141,6 +143,7 @@
 
 void SoundSystem::play_sound(const std::string file, double vol)
 {
+  STACKTRACE;
   if(!mix_ok || sound_off)
     return;
   
@@ -180,6 +183,7 @@
 
 void SoundSystem::stop_sound(const std::string file)
 {
+  STACKTRACE;
   if(!mix_ok || sound_off)
     return;
   
@@ -201,6 +205,7 @@
 
 void SoundSystem::set_music_volume(double vol)
 {
+  STACKTRACE;
   if(!mix_ok)
     return;
   
@@ -230,6 +235,7 @@
 
 void SoundSystem::set_sound_volume(double vol)
 {
+  STACKTRACE;
   if(!mix_ok)
     return;
   
@@ -249,17 +255,20 @@
 
 double SoundSystem::load_music_volume()
 {
+  STACKTRACE;
   tw_set_config_file("client.ini");
   return get_config_float("Sound", "MusicVolume", 0.5);
 }
 
 double SoundSystem::load_sound_volume()
 {
+  STACKTRACE;
   tw_set_config_file("client.ini");
   return get_config_float("Sound", "SoundVolume", 0.5);
 }
 
 bool SoundSystem::playing_music()
 {
+  STACKTRACE;
   return Mix_PlayingMusic();
 }

Modified: trunk/source/util/vector2.cpp
===================================================================
--- trunk/source/util/vector2.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/util/vector2.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -4,15 +4,21 @@
 #include "vector2.h"
 #include "random.h"
 #include "round.h"
+#include "errors.h"
 //#include "../melee.h"
 
-Vector2::Vector2(Vector2i v2i) : x(v2i.x), y(v2i.y) {}
+Vector2::Vector2(Vector2i v2i) : x(v2i.x), y(v2i.y) 
+{
+  STACKTRACE;
+}
 Vector2i Vector2::round()
 {
+  STACKTRACE;
 	return Vector2i(iround(x), iround(y));
 }
 Vector2i Vector2::truncate()
 {
+  STACKTRACE;
 	return Vector2i(int(x), int(y));
 }
 
@@ -71,6 +77,7 @@
 
 Vector3D::Vector3D(double ax, double ay, double az)
 {
+  STACKTRACE;
 	x = ax;
 	y = ay;
 	z = az;
@@ -78,16 +85,19 @@
 
 double Vector3D::dot(Vector3D v)
 {
+  STACKTRACE;
 	return x*v.x + y*v.y + z*v.z;
 }
 
 Vector3D Vector3D::cross(Vector3D b)
 {
+  STACKTRACE;
 	return Vector3D(y*b.z - z*b.y, -x*b.z + z*b.x, x*b.y - y*b.x);
 }
 
 void Vector3D::normalize()
 {
+  STACKTRACE;
 	double r;
 	r = sqrt(x*x + y*y + z*z);
 	x /= r;

Modified: trunk/web/index.html
===================================================================
--- trunk/web/index.html	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/web/index.html	2004-09-20 21:04:58 UTC (rev 60)
@@ -24,7 +24,6 @@
 </div>
 
 <div class="main">
-  <h2>About</h2>
   <h3 class="important">TW-Light</h3>
   <p class="indented">
   TW-Light is an open source clone/sequel to the epic cross-genre game

Modified: trunk/web/style.css
===================================================================
--- trunk/web/style.css	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/web/style.css	2004-09-20 21:04:58 UTC (rev 60)
@@ -106,7 +106,7 @@
 .main {
   color: #ffffff;
   background-color: #001133;
-  background-image: url(./_background.jpg);
+/*  background-image: url(./bluepurplenebula2.jpg);*/
   margin-left: 1em;
   margin-right: 1em;
   margin-top: 1em;



From yurand at sheep.berlios.de  Sat Sep 25 16:18:44 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 25 Sep 2004 16:18:44 +0200
Subject: [Tw-light-svn] r61 - in trunk: gamedata/default_ini/ships gamedata/ships source source/ais source/melee
Message-ID: <200409251418.i8PEIiXE026991@sheep.berlios.de>

Author: yurand
Date: 2004-09-25 16:18:41 +0200 (Sat, 25 Sep 2004)
New Revision: 61

Removed:
   trunk/gamedata/ships/shpalabc.dat
   trunk/gamedata/ships/shpandgu.dat
   trunk/gamedata/ships/shparisk.dat
   trunk/gamedata/ships/shpbahbu.dat
   trunk/gamedata/ships/shpbipka.dat
   trunk/gamedata/ships/shpchebr.dat
   trunk/gamedata/ships/shpchmav.dat
   trunk/gamedata/ships/shpchoex.dat
   trunk/gamedata/ships/shpconca.dat
   trunk/gamedata/ships/shpconho.dat
   trunk/gamedata/ships/shpdragr.dat
   trunk/gamedata/ships/shpdruma.dat
   trunk/gamedata/ships/shpearc3.dat
   trunk/gamedata/ships/shpearcr.dat
   trunk/gamedata/ships/shpforsh.dat
   trunk/gamedata/ships/shpgarty.dat
   trunk/gamedata/ships/shpilwav.dat
   trunk/gamedata/ships/shpilwsp.dat
   trunk/gamedata/ships/shpkahbo.dat
   trunk/gamedata/ships/shpkohma.dat
   trunk/gamedata/ships/shpkzedr.dat
   trunk/gamedata/ships/shpmeltr.dat
   trunk/gamedata/ships/shpmmrxf.dat
   trunk/gamedata/ships/shpmycpo.dat
   trunk/gamedata/ships/shporzne.dat
   trunk/gamedata/ships/shppkufu.dat
   trunk/gamedata/ships/shprogsq.dat
   trunk/gamedata/ships/shpshosc.dat
   trunk/gamedata/ships/shpslypr.dat
   trunk/gamedata/ships/shpspael.dat
   trunk/gamedata/ships/shpstaba.dat
   trunk/gamedata/ships/shpsupbl.dat
   trunk/gamedata/ships/shpsyrpe.dat
   trunk/gamedata/ships/shptauar.dat
   trunk/gamedata/ships/shptauda.dat
   trunk/gamedata/ships/shptausl.dat
   trunk/gamedata/ships/shptauto.dat
   trunk/gamedata/ships/shpthrto.dat
   trunk/gamedata/ships/shpumgdr.dat
   trunk/gamedata/ships/shputwju.dat
   trunk/gamedata/ships/shpvuxin.dat
   trunk/gamedata/ships/shpyehte.dat
   trunk/gamedata/ships/shpzeksh.dat
   trunk/gamedata/ships/shpzfpst.dat
Modified:
   trunk/gamedata/default_ini/ships/shpalabc.ini
   trunk/gamedata/default_ini/ships/shpandgu.ini
   trunk/gamedata/default_ini/ships/shparisk.ini
   trunk/gamedata/default_ini/ships/shpbahbu.ini
   trunk/gamedata/default_ini/ships/shpbipka.ini
   trunk/gamedata/default_ini/ships/shpchebr.ini
   trunk/gamedata/default_ini/ships/shpchmav.ini
   trunk/gamedata/default_ini/ships/shpchoex.ini
   trunk/gamedata/default_ini/ships/shpconca.ini
   trunk/gamedata/default_ini/ships/shpconho.ini
   trunk/gamedata/default_ini/ships/shpdragr.ini
   trunk/gamedata/default_ini/ships/shpdruma.ini
   trunk/gamedata/default_ini/ships/shpearc3.ini
   trunk/gamedata/default_ini/ships/shpearcr.ini
   trunk/gamedata/default_ini/ships/shpforsh.ini
   trunk/gamedata/default_ini/ships/shpgarty.ini
   trunk/gamedata/default_ini/ships/shpilwav.ini
   trunk/gamedata/default_ini/ships/shpilwsp.ini
   trunk/gamedata/default_ini/ships/shpkahbo.ini
   trunk/gamedata/default_ini/ships/shpkohma.ini
   trunk/gamedata/default_ini/ships/shpkzedr.ini
   trunk/gamedata/default_ini/ships/shpmeltr.ini
   trunk/gamedata/default_ini/ships/shpmmrxf.ini
   trunk/gamedata/default_ini/ships/shpmycpo.ini
   trunk/gamedata/default_ini/ships/shporzne.ini
   trunk/gamedata/default_ini/ships/shppkufu.ini
   trunk/gamedata/default_ini/ships/shprogsq.ini
   trunk/gamedata/default_ini/ships/shpshosc.ini
   trunk/gamedata/default_ini/ships/shpslypr.ini
   trunk/gamedata/default_ini/ships/shpspael.ini
   trunk/gamedata/default_ini/ships/shpstaba.ini
   trunk/gamedata/default_ini/ships/shpsupbl.ini
   trunk/gamedata/default_ini/ships/shpsyrpe.ini
   trunk/gamedata/default_ini/ships/shptauar.ini
   trunk/gamedata/default_ini/ships/shptauda.ini
   trunk/gamedata/default_ini/ships/shptausl.ini
   trunk/gamedata/default_ini/ships/shptauto.ini
   trunk/gamedata/default_ini/ships/shpthrto.ini
   trunk/gamedata/default_ini/ships/shpumgdr.ini
   trunk/gamedata/default_ini/ships/shputwju.ini
   trunk/gamedata/default_ini/ships/shpvuxin.ini
   trunk/gamedata/default_ini/ships/shpyehte.ini
   trunk/gamedata/default_ini/ships/shpzeksh.ini
   trunk/gamedata/default_ini/ships/shpzfpst.ini
   trunk/gamedata/ships/COPYING.txt
   trunk/source/ais/c_input.cpp
   trunk/source/melee.h
   trunk/source/melee/mmain.cpp
   trunk/source/melee/mship.cpp
   trunk/source/melee/mship.h
   trunk/source/melee/mshpdata.cpp
   trunk/source/melee/msprite.cpp
Log:
Ship datafiles were removed.
Raw datas used instead


Modified: trunk/gamedata/default_ini/ships/shpalabc.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpalabc.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpalabc.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -114,13 +114,122 @@
 ExtraSprites     = 1r +alpha
 ExtraSamples     = 2
 ExtraExplosion   = 10 +alpha
-ExtraExtraSprites0 = 1r128 +alpha
-ExtraExtraSprites1 = 1r128 +alpha
-ExtraExtraSprites2 = 4 +alpha
-ExtraExtraSprites3 = 2 +alpha
-ExtraExtraSprites4 = 2 +alpha
-ExtraExtraSprites5 = 2 +alpha
-ExtraExtraSprites6 = 2 +alpha
-ExtraExtraSprites7 = 12 +alpha
-ExtraExtraSprites8 = 12 +alpha
+ExtraExtraSprites0_ = 1r128 +alpha
+ExtraExtraSprites1_ = 1r128 +alpha
+ExtraExtraSprites2_ = 4 +alpha
+ExtraExtraSprites3_ = 2 +alpha
+ExtraExtraSprites4_ = 2 +alpha
+ExtraExtraSprites5_ = 2 +alpha
+ExtraExtraSprites6_ = 2 +alpha
+ExtraExtraSprites7_ = 12 +alpha
+ExtraExtraSprites8_ = 12 +alpha
 PanelBitmaps     = 15
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpalabc/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpalabc/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpalabc/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpalabc/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpalabc/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpalabc/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpalabc/SHIP_P06_PCX.bmp
+PanelBitmaps7  = images/ships/shpalabc/ship_p10.bmp
+PanelBitmaps8  = images/ships/shpalabc/ship_p11.bmp
+PanelBitmaps9  = images/ships/shpalabc/ship_p12.bmp
+PanelBitmaps10 = images/ships/shpalabc/ship_p13.bmp
+PanelBitmaps11 = images/ships/shpalabc/ship_p20.bmp
+PanelBitmaps12 = images/ships/shpalabc/ship_p21.bmp
+PanelBitmaps13 = images/ships/shpalabc/ship_p22.bmp
+PanelBitmaps14 = images/ships/shpalabc/ship_p23.bmp
+
+
+ShipSprites0 = images/ships/shpalabc/SHIP_S_000_TGA.bmp
+
+WeaponSprites0 = images/ships/shpalabc/SHOT_A_00_TGA.bmp
+
+WeaponExplosion0 = images/ships/shpalabc/SHOT_B_00.bmp
+WeaponExplosion1 = images/ships/shpalabc/SHOT_B_01.bmp
+WeaponExplosion2 = images/ships/shpalabc/SHOT_B_02.bmp
+WeaponExplosion3 = images/ships/shpalabc/SHOT_B_03.bmp
+WeaponExplosion4 = images/ships/shpalabc/SHOT_B_04.bmp
+WeaponExplosion5 = images/ships/shpalabc/SHOT_B_05.bmp
+WeaponExplosion6 = images/ships/shpalabc/SHOT_B_06.bmp
+WeaponExplosion7 = images/ships/shpalabc/SHOT_B_07.bmp
+WeaponExplosion8 = images/ships/shpalabc/SHOT_B_08.bmp
+WeaponExplosion9 = images/ships/shpalabc/SHOT_B_09.bmp
+
+
+SpecialSprites0 = images/ships/shpalabc/SHOT_C_00_TGA.bmp
+
+SpecialExplosion0 = images/ships/shpalabc/SHOT_D_00_TGA.bmp
+SpecialExplosion1 = images/ships/shpalabc/SHOT_D_01_TGA.bmp
+SpecialExplosion2 = images/ships/shpalabc/SHOT_D_02_TGA.bmp
+SpecialExplosion3 = images/ships/shpalabc/SHOT_D_03_TGA.bmp
+SpecialExplosion4 = images/ships/shpalabc/SHOT_D_04_TGA.bmp
+SpecialExplosion5 = images/ships/shpalabc/SHOT_D_05_TGA.bmp
+SpecialExplosion6 = images/ships/shpalabc/SHOT_D_06_TGA.bmp
+SpecialExplosion7 = images/ships/shpalabc/SHOT_D_07_TGA.bmp
+SpecialExplosion8 = images/ships/shpalabc/SHOT_D_08_TGA.bmp
+SpecialExplosion9 = images/ships/shpalabc/SHOT_D_09_TGA.bmp
+
+ExtraSprites0 = images/ships/shpalabc/SHOT_E_00_TGA.bmp
+
+ExtraExplosion0 = images/ships/shpalabc/SHOT_F_00.bmp
+ExtraExplosion1 = images/ships/shpalabc/SHOT_F_01.bmp
+ExtraExplosion2 = images/ships/shpalabc/SHOT_F_02.bmp
+ExtraExplosion3 = images/ships/shpalabc/SHOT_F_03.bmp
+ExtraExplosion4 = images/ships/shpalabc/SHOT_F_04.bmp
+ExtraExplosion5 = images/ships/shpalabc/SHOT_F_05.bmp
+ExtraExplosion6 = images/ships/shpalabc/SHOT_F_06.bmp
+ExtraExplosion7 = images/ships/shpalabc/SHOT_F_07.bmp
+ExtraExplosion8 = images/ships/shpalabc/SHOT_F_08.bmp
+ExtraExplosion9 = images/ships/shpalabc/SHOT_F_09.bmp
+
+
+ExtraExtraSprites0_0 = images/ships/shpalabc/SHOT_T0_000_TGA.bmp
+
+ExtraExtraSprites1_0 = images/ships/shpalabc/SHOT_T1_000_TGA.bmp
+
+ExtraExtraSprites2_0 = images/ships/shpalabc/SHOT_X2_0.bmp
+ExtraExtraSprites2_1 = images/ships/shpalabc/SHOT_X2_1.bmp
+ExtraExtraSprites2_2 = images/ships/shpalabc/SHOT_X2_2.bmp
+ExtraExtraSprites2_3 = images/ships/shpalabc/SHOT_X2_3.bmp
+
+ExtraExtraSprites3_0 = images/ships/shpalabc/SHOT_X3_E1.bmp
+ExtraExtraSprites3_1 = images/ships/shpalabc/SHOT_X3_E2.bmp
+
+ExtraExtraSprites4_0 = images/ships/shpalabc/SHOT_X4_E1.bmp
+ExtraExtraSprites4_1 = images/ships/shpalabc/SHOT_X4_E2.bmp
+
+ExtraExtraSprites5_0 = images/ships/shpalabc/SHOT_X5_E1.bmp
+ExtraExtraSprites5_1 = images/ships/shpalabc/SHOT_X5_E2.bmp
+
+ExtraExtraSprites6_0 = images/ships/shpalabc/SHOT_X6_E1.bmp
+ExtraExtraSprites6_1 = images/ships/shpalabc/SHOT_X6_E2.bmp
+
+ExtraExtraSprites7_0 = images/ships/shpalabc/SHOT_X7_00.bmp
+ExtraExtraSprites7_1 = images/ships/shpalabc/SHOT_X7_01.bmp
+ExtraExtraSprites7_2 = images/ships/shpalabc/SHOT_X7_02.bmp
+ExtraExtraSprites7_3 = images/ships/shpalabc/SHOT_X7_03.bmp
+ExtraExtraSprites7_4 = images/ships/shpalabc/SHOT_X7_04.bmp
+ExtraExtraSprites7_5 = images/ships/shpalabc/SHOT_X7_05.bmp
+ExtraExtraSprites7_6 = images/ships/shpalabc/SHOT_X7_06.bmp
+ExtraExtraSprites7_7 = images/ships/shpalabc/SHOT_X7_07.bmp
+ExtraExtraSprites7_8 = images/ships/shpalabc/SHOT_X7_08.bmp
+ExtraExtraSprites7_9 = images/ships/shpalabc/SHOT_X7_09.bmp
+ExtraExtraSprites7_10 = images/ships/shpalabc/SHOT_X7_10.bmp
+ExtraExtraSprites7_11 = images/ships/shpalabc/SHOT_X7_11.bmp
+
+ExtraExtraSprites8_0 = images/ships/shpalabc/SHOT_X8_00.bmp
+ExtraExtraSprites8_1 = images/ships/shpalabc/SHOT_X8_01.bmp
+ExtraExtraSprites8_2 = images/ships/shpalabc/SHOT_X8_02.bmp
+ExtraExtraSprites8_3 = images/ships/shpalabc/SHOT_X8_03.bmp
+ExtraExtraSprites8_4 = images/ships/shpalabc/SHOT_X8_04.bmp
+ExtraExtraSprites8_5 = images/ships/shpalabc/SHOT_X8_05.bmp
+ExtraExtraSprites8_6 = images/ships/shpalabc/SHOT_X8_06.bmp
+ExtraExtraSprites8_7 = images/ships/shpalabc/SHOT_X8_07.bmp
+ExtraExtraSprites8_8 = images/ships/shpalabc/SHOT_X8_08.bmp
+ExtraExtraSprites8_9 = images/ships/shpalabc/SHOT_X8_09.bmp
+ExtraExtraSprites8_10 = images/ships/shpalabc/SHOT_X8_10.bmp
+ExtraExtraSprites8_11 = images/ships/shpalabc/SHOT_X8_11.bmp
+

Modified: trunk/gamedata/default_ini/ships/shpandgu.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpandgu.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpandgu.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -98,3 +98,29 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpandgu/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpandgu/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpandgu/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpandgu/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpandgu/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpandgu/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpandgu/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpandgu/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpandgu/SHOT_A01_PCX.bmp
+
+WeaponExplosion0 = images/ships/shpandgu/SHOT_B01_PCX.bmp
+WeaponExplosion1 = images/ships/shpandgu/SHOT_B02_PCX.bmp
+WeaponExplosion2 = images/ships/shpandgu/SHOT_B03_PCX.bmp
+WeaponExplosion3 = images/ships/shpandgu/SHOT_B04_PCX.bmp
+WeaponExplosion4 = images/ships/shpandgu/SHOT_B05_PCX.bmp
+WeaponExplosion5 = images/ships/shpandgu/SHOT_B06_PCX.bmp
+
+
+SpecialSprites0 = images/ships/shpandgu/SHOT_C01_PCX.bmp
+
+ExtraSprites0 = images/ships/shpandgu/SHOT_EXX_BMP.bmp

Modified: trunk/gamedata/default_ini/ships/shparisk.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shparisk.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shparisk.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -82,3 +82,56 @@
 ExtraExplosion   = 0
 PanelBitmaps     = 7
 
+[Graphic]
+PanelBitmaps0  = images/ships/shparisk/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shparisk/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shparisk/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shparisk/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shparisk/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shparisk/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shparisk/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shparisk/SHIP_S01_PCX.bmp
+
+SpecialSprites0 = images/ships/shparisk/SHOT_A01_PCX.bmp
+SpecialSprites1 = images/ships/shparisk/SHOT_A02_PCX.bmp
+SpecialSprites2 = images/ships/shparisk/SHOT_A03_PCX.bmp
+SpecialSprites3 = images/ships/shparisk/SHOT_A04_PCX.bmp
+SpecialSprites4 = images/ships/shparisk/SHOT_A05_PCX.bmp
+SpecialSprites5 = images/ships/shparisk/SHOT_A06_PCX.bmp
+SpecialSprites6 = images/ships/shparisk/SHOT_A07_PCX.bmp
+SpecialSprites7 = images/ships/shparisk/SHOT_A08_PCX.bmp
+SpecialSprites8 = images/ships/shparisk/SHOT_A09_PCX.bmp
+SpecialSprites9 = images/ships/shparisk/SHOT_A10_PCX.bmp
+SpecialSprites10 = images/ships/shparisk/SHOT_A11_PCX.bmp
+SpecialSprites11 = images/ships/shparisk/SHOT_A12_PCX.bmp
+SpecialSprites12 = images/ships/shparisk/SHOT_A13_PCX.bmp
+SpecialSprites13 = images/ships/shparisk/SHOT_A14_PCX.bmp
+SpecialSprites14 = images/ships/shparisk/SHOT_A15_PCX.bmp
+SpecialSprites15 = images/ships/shparisk/SHOT_A16_PCX.bmp
+SpecialSprites16 = images/ships/shparisk/SHOT_A17_PCX.bmp
+SpecialSprites17 = images/ships/shparisk/SHOT_A18_PCX.bmp
+SpecialSprites18 = images/ships/shparisk/SHOT_A19_PCX.bmp
+SpecialSprites19 = images/ships/shparisk/SHOT_A20_PCX.bmp
+SpecialSprites20 = images/ships/shparisk/SHOT_A21_PCX.bmp
+SpecialSprites21 = images/ships/shparisk/SHOT_A22_PCX.bmp
+SpecialSprites22 = images/ships/shparisk/SHOT_A23_PCX.bmp
+SpecialSprites23 = images/ships/shparisk/SHOT_A24_PCX.bmp
+SpecialSprites24 = images/ships/shparisk/SHOT_A25_PCX.bmp
+SpecialSprites25 = images/ships/shparisk/SHOT_A26_PCX.bmp
+SpecialSprites26 = images/ships/shparisk/SHOT_A27_PCX.bmp
+SpecialSprites27 = images/ships/shparisk/SHOT_A28_PCX.bmp
+SpecialSprites28 = images/ships/shparisk/SHOT_A29_PCX.bmp
+SpecialSprites29 = images/ships/shparisk/SHOT_A30_PCX.bmp
+SpecialSprites30 = images/ships/shparisk/SHOT_A31_PCX.bmp
+SpecialSprites31 = images/ships/shparisk/SHOT_A32_PCX.bmp
+SpecialSprites32 = images/ships/shparisk/SHOT_A33_PCX.bmp
+SpecialSprites33 = images/ships/shparisk/SHOT_A34_PCX.bmp
+SpecialSprites34 = images/ships/shparisk/SHOT_A35_PCX.bmp
+SpecialSprites35 = images/ships/shparisk/SHOT_A36_PCX.bmp
+SpecialSprites36 = images/ships/shparisk/SHOT_A37_PCX.bmp
+SpecialSprites37 = images/ships/shparisk/SHOT_A38_PCX.bmp
+SpecialSprites38 = images/ships/shparisk/SHOT_A39_PCX.bmp
+SpecialSprites39 = images/ships/shparisk/SHOT_A40_PCX.bmp
+

Modified: trunk/gamedata/default_ini/ships/shpbahbu.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpbahbu.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpbahbu.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -72,3 +72,16 @@
 ExtraExplosion   = 0
 PanelBitmaps     = 7
 
+[Graphic]
+PanelBitmaps0  = images/ships/shpbahbu/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpbahbu/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpbahbu/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpbahbu/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpbahbu/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpbahbu/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpbahbu/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpbahbu/SHIP_S01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpbahbu/SHOT_B01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpbipka.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpbipka.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpbipka.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -80,3 +80,21 @@
 ExtraExplosion   = 0
 PanelBitmaps     = 9
 
+[Graphic]
+PanelBitmaps0  = images/ships/shpbipka/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpbipka/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpbipka/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpbipka/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpbipka/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpbipka/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpbipka/SHIP_P06_PCX.bmp
+PanelBitmaps7  = images/ships/shpbipka/SHIP_P07_PCX.bmp
+PanelBitmaps8  = images/ships/shpbipka/SHIP_P08_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpbipka/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpbipka/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpbipka/SHOT_B01_PCX.bmp
+

Modified: trunk/gamedata/default_ini/ships/shpchebr.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpchebr.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpchebr.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -93,3 +93,63 @@
 ExtraSamples     = 3
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpchebr/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpchebr/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpchebr/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpchebr/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpchebr/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpchebr/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpchebr/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpchebr/SHIP_S_00_TGA.bmp
+
+WeaponSprites0 = images/ships/shpchebr/SHOT_A_00_TGA.bmp
+
+WeaponExplosion0 = images/ships/shpchebr/SHOT_B_00_TGA.bmp
+WeaponExplosion1 = images/ships/shpchebr/SHOT_B_01_TGA.bmp
+WeaponExplosion2 = images/ships/shpchebr/SHOT_B_02_TGA.bmp
+WeaponExplosion3 = images/ships/shpchebr/SHOT_B_03_TGA.bmp
+WeaponExplosion4 = images/ships/shpchebr/SHOT_B_04_TGA.bmp
+WeaponExplosion5 = images/ships/shpchebr/SHOT_B_05_TGA.bmp
+WeaponExplosion6 = images/ships/shpchebr/SHOT_B_06_TGA.bmp
+WeaponExplosion7 = images/ships/shpchebr/SHOT_B_07_TGA.bmp
+WeaponExplosion8 = images/ships/shpchebr/SHOT_B_08_TGA.bmp
+WeaponExplosion9 = images/ships/shpchebr/SHOT_B_09_TGA.bmp
+WeaponExplosion10 = images/ships/shpchebr/SHOT_B_10_TGA.bmp
+WeaponExplosion11 = images/ships/shpchebr/SHOT_B_11_TGA.bmp
+WeaponExplosion12 = images/ships/shpchebr/SHOT_B_12_TGA.bmp
+WeaponExplosion13 = images/ships/shpchebr/SHOT_B_13_TGA.bmp
+WeaponExplosion14 = images/ships/shpchebr/SHOT_B_14_TGA.bmp
+WeaponExplosion15 = images/ships/shpchebr/SHOT_B_15_TGA.bmp
+WeaponExplosion16 = images/ships/shpchebr/SHOT_B_16_TGA.bmp
+WeaponExplosion17 = images/ships/shpchebr/SHOT_B_17_TGA.bmp
+WeaponExplosion18 = images/ships/shpchebr/SHOT_B_18_TGA.bmp
+WeaponExplosion19 = images/ships/shpchebr/SHOT_B_19_TGA.bmp
+
+SpecialSprites0 = images/ships/shpchebr/SHOT_C_00_TGA.bmp
+
+SpecialExplosion0 = images/ships/shpchebr/SHOT_D_00_TGA.bmp
+SpecialExplosion1 = images/ships/shpchebr/SHOT_D_01_TGA.bmp
+SpecialExplosion2 = images/ships/shpchebr/SHOT_D_02_TGA.bmp
+SpecialExplosion3 = images/ships/shpchebr/SHOT_D_03_TGA.bmp
+SpecialExplosion4 = images/ships/shpchebr/SHOT_D_04_TGA.bmp
+SpecialExplosion5 = images/ships/shpchebr/SHOT_D_05_TGA.bmp
+SpecialExplosion6 = images/ships/shpchebr/SHOT_D_06_TGA.bmp
+SpecialExplosion7 = images/ships/shpchebr/SHOT_D_07_TGA.bmp
+SpecialExplosion8 = images/ships/shpchebr/SHOT_D_08_TGA.bmp
+SpecialExplosion9 = images/ships/shpchebr/SHOT_D_09_TGA.bmp
+SpecialExplosion10 = images/ships/shpchebr/SHOT_D_10_TGA.bmp
+SpecialExplosion11 = images/ships/shpchebr/SHOT_D_11_TGA.bmp
+SpecialExplosion12 = images/ships/shpchebr/SHOT_D_12_TGA.bmp
+SpecialExplosion13 = images/ships/shpchebr/SHOT_D_13_TGA.bmp
+SpecialExplosion14 = images/ships/shpchebr/SHOT_D_14_TGA.bmp
+SpecialExplosion15 = images/ships/shpchebr/SHOT_D_15_TGA.bmp
+SpecialExplosion16 = images/ships/shpchebr/SHOT_D_16_TGA.bmp
+SpecialExplosion17 = images/ships/shpchebr/SHOT_D_17_TGA.bmp
+SpecialExplosion18 = images/ships/shpchebr/SHOT_D_18_TGA.bmp
+SpecialExplosion19 = images/ships/shpchebr/SHOT_D_19_TGA.bmp
+
+ExtraSprites0 = images/ships/shpchebr/SHOT_E_00_TGA.bmp
\ No newline at end of file

Modified: trunk/gamedata/default_ini/ships/shpchmav.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpchmav.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpchmav.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -86,3 +86,121 @@
 ExtraSamples     = 1
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpchmav/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpchmav/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpchmav/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpchmav/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpchmav/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpchmav/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpchmav/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpchmav/SHIP_S01_PCX.bmp
+
+WeaponExplosion0 = images/ships/shpchmav/SHOT_A0_00_BMP.bmp
+WeaponExplosion1 = images/ships/shpchmav/SHOT_A0_01_BMP.bmp
+WeaponExplosion2 = images/ships/shpchmav/SHOT_A0_02_BMP.bmp
+WeaponExplosion3 = images/ships/shpchmav/SHOT_A0_03_BMP.bmp
+WeaponExplosion4 = images/ships/shpchmav/SHOT_A0_04_BMP.bmp
+WeaponExplosion5 = images/ships/shpchmav/SHOT_A0_05_BMP.bmp
+WeaponExplosion6 = images/ships/shpchmav/SHOT_A0_06_BMP.bmp
+WeaponExplosion7 = images/ships/shpchmav/SHOT_A0_07_BMP.bmp
+WeaponExplosion8 = images/ships/shpchmav/SHOT_A0_08_BMP.bmp
+WeaponExplosion9 = images/ships/shpchmav/SHOT_A0_09_BMP.bmp
+WeaponExplosion10 = images/ships/shpchmav/SHOT_A1_00_BMP.bmp
+WeaponExplosion11 = images/ships/shpchmav/SHOT_A1_01_BMP.bmp
+WeaponExplosion12 = images/ships/shpchmav/SHOT_A1_02_BMP.bmp
+WeaponExplosion13 = images/ships/shpchmav/SHOT_A1_03_BMP.bmp
+WeaponExplosion14 = images/ships/shpchmav/SHOT_A1_04_BMP.bmp
+WeaponExplosion15 = images/ships/shpchmav/SHOT_A1_05_BMP.bmp
+WeaponExplosion16 = images/ships/shpchmav/SHOT_A1_06_BMP.bmp
+WeaponExplosion17 = images/ships/shpchmav/SHOT_A1_07_BMP.bmp
+WeaponExplosion18 = images/ships/shpchmav/SHOT_A1_08_BMP.bmp
+WeaponExplosion19 = images/ships/shpchmav/SHOT_A1_09_BMP.bmp
+WeaponExplosion20 = images/ships/shpchmav/SHOT_A2_00_BMP.bmp
+WeaponExplosion21 = images/ships/shpchmav/SHOT_A2_01_BMP.bmp
+WeaponExplosion22 = images/ships/shpchmav/SHOT_A2_02_BMP.bmp
+WeaponExplosion23 = images/ships/shpchmav/SHOT_A2_03_BMP.bmp
+WeaponExplosion24 = images/ships/shpchmav/SHOT_A2_04_BMP.bmp
+WeaponExplosion25 = images/ships/shpchmav/SHOT_A2_05_BMP.bmp
+WeaponExplosion26 = images/ships/shpchmav/SHOT_A2_06_BMP.bmp
+WeaponExplosion27 = images/ships/shpchmav/SHOT_A2_07_BMP.bmp
+WeaponExplosion28 = images/ships/shpchmav/SHOT_A2_08_BMP.bmp
+WeaponExplosion29 = images/ships/shpchmav/SHOT_A2_09_BMP.bmp
+WeaponExplosion30 = images/ships/shpchmav/SHOT_A3_00_BMP.bmp
+WeaponExplosion31 = images/ships/shpchmav/SHOT_A3_01_BMP.bmp
+WeaponExplosion32 = images/ships/shpchmav/SHOT_A3_02_BMP.bmp
+WeaponExplosion33 = images/ships/shpchmav/SHOT_A3_03_BMP.bmp
+WeaponExplosion34 = images/ships/shpchmav/SHOT_A3_04_BMP.bmp
+WeaponExplosion35 = images/ships/shpchmav/SHOT_A3_05_BMP.bmp
+WeaponExplosion36 = images/ships/shpchmav/SHOT_A3_06_BMP.bmp
+WeaponExplosion37 = images/ships/shpchmav/SHOT_A3_07_BMP.bmp
+WeaponExplosion38 = images/ships/shpchmav/SHOT_A3_08_BMP.bmp
+WeaponExplosion39 = images/ships/shpchmav/SHOT_A3_09_BMP.bmp
+
+ExtraSprites0 = images/ships/shpchmav/SHOT_B01_PCX.bmp
+ExtraSprites1 = images/ships/shpchmav/SHOT_B02_PCX.bmp
+ExtraSprites2 = images/ships/shpchmav/SHOT_B03_PCX.bmp
+ExtraSprites3 = images/ships/shpchmav/SHOT_B04_PCX.bmp
+ExtraSprites4 = images/ships/shpchmav/SHOT_B05_PCX.bmp
+ExtraSprites5 = images/ships/shpchmav/SHOT_B06_PCX.bmp
+ExtraSprites6 = images/ships/shpchmav/SHOT_B07_PCX.bmp
+ExtraSprites7 = images/ships/shpchmav/SHOT_B08_PCX.bmp
+ExtraSprites8 = images/ships/shpchmav/SHOT_B09_PCX.bmp
+ExtraSprites9 = images/ships/shpchmav/SHOT_B10_PCX.bmp
+ExtraSprites10 = images/ships/shpchmav/SHOT_B11_PCX.bmp
+ExtraSprites11 = images/ships/shpchmav/SHOT_B12_PCX.bmp
+ExtraSprites12 = images/ships/shpchmav/SHOT_B13_PCX.bmp
+ExtraSprites13 = images/ships/shpchmav/SHOT_B14_PCX.bmp
+ExtraSprites14 = images/ships/shpchmav/SHOT_B15_PCX.bmp
+ExtraSprites15 = images/ships/shpchmav/SHOT_B16_PCX.bmp
+ExtraSprites16 = images/ships/shpchmav/SHOT_B17_PCX.bmp
+ExtraSprites17 = images/ships/shpchmav/SHOT_B18_PCX.bmp
+ExtraSprites18 = images/ships/shpchmav/SHOT_B19_PCX.bmp
+ExtraSprites19 = images/ships/shpchmav/SHOT_B20_PCX.bmp
+ExtraSprites20 = images/ships/shpchmav/SHOT_B21_PCX.bmp
+ExtraSprites21 = images/ships/shpchmav/SHOT_B22_PCX.bmp
+ExtraSprites22 = images/ships/shpchmav/SHOT_B23_PCX.bmp
+ExtraSprites23 = images/ships/shpchmav/SHOT_B24_PCX.bmp
+ExtraSprites24 = images/ships/shpchmav/SHOT_B25_PCX.bmp
+ExtraSprites25 = images/ships/shpchmav/SHOT_B26_PCX.bmp
+ExtraSprites26 = images/ships/shpchmav/SHOT_B27_PCX.bmp
+ExtraSprites27 = images/ships/shpchmav/SHOT_B28_PCX.bmp
+ExtraSprites28 = images/ships/shpchmav/SHOT_B29_PCX.bmp
+ExtraSprites29 = images/ships/shpchmav/SHOT_B30_PCX.bmp
+ExtraSprites30 = images/ships/shpchmav/SHOT_B31_PCX.bmp
+ExtraSprites31 = images/ships/shpchmav/SHOT_B32_PCX.bmp
+ExtraSprites32 = images/ships/shpchmav/SHOT_B33_PCX.bmp
+ExtraSprites33 = images/ships/shpchmav/SHOT_B34_PCX.bmp
+ExtraSprites34 = images/ships/shpchmav/SHOT_B35_PCX.bmp
+ExtraSprites35 = images/ships/shpchmav/SHOT_B36_PCX.bmp
+ExtraSprites36 = images/ships/shpchmav/SHOT_B37_PCX.bmp
+ExtraSprites37 = images/ships/shpchmav/SHOT_B38_PCX.bmp
+ExtraSprites38 = images/ships/shpchmav/SHOT_B39_PCX.bmp
+ExtraSprites39 = images/ships/shpchmav/SHOT_B40_PCX.bmp
+ExtraSprites40 = images/ships/shpchmav/SHOT_B41_PCX.bmp
+ExtraSprites41 = images/ships/shpchmav/SHOT_B42_PCX.bmp
+ExtraSprites42 = images/ships/shpchmav/SHOT_B43_PCX.bmp
+ExtraSprites43 = images/ships/shpchmav/SHOT_B44_PCX.bmp
+ExtraSprites44 = images/ships/shpchmav/SHOT_B45_PCX.bmp
+ExtraSprites45 = images/ships/shpchmav/SHOT_B46_PCX.bmp
+ExtraSprites46 = images/ships/shpchmav/SHOT_B47_PCX.bmp
+ExtraSprites47 = images/ships/shpchmav/SHOT_B48_PCX.bmp
+ExtraSprites48 = images/ships/shpchmav/SHOT_B49_PCX.bmp
+ExtraSprites49 = images/ships/shpchmav/SHOT_B50_PCX.bmp
+ExtraSprites50 = images/ships/shpchmav/SHOT_B51_PCX.bmp
+ExtraSprites51 = images/ships/shpchmav/SHOT_B52_PCX.bmp
+ExtraSprites52 = images/ships/shpchmav/SHOT_B53_PCX.bmp
+ExtraSprites53 = images/ships/shpchmav/SHOT_B54_PCX.bmp
+ExtraSprites54 = images/ships/shpchmav/SHOT_B55_PCX.bmp
+ExtraSprites55 = images/ships/shpchmav/SHOT_B56_PCX.bmp
+ExtraSprites56 = images/ships/shpchmav/SHOT_B57_PCX.bmp
+ExtraSprites57 = images/ships/shpchmav/SHOT_B58_PCX.bmp
+ExtraSprites58 = images/ships/shpchmav/SHOT_B59_PCX.bmp
+ExtraSprites59 = images/ships/shpchmav/SHOT_B60_PCX.bmp
+ExtraSprites60 = images/ships/shpchmav/SHOT_B61_PCX.bmp
+ExtraSprites61 = images/ships/shpchmav/SHOT_B62_PCX.bmp
+ExtraSprites62 = images/ships/shpchmav/SHOT_B63_PCX.bmp
+ExtraSprites63 = images/ships/shpchmav/SHOT_B64_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpchoex.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpchoex.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpchoex.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -91,3 +91,29 @@
 ExtraExplosion   = 0
 PanelBitmaps     = 7
 
+[Graphic]
+PanelBitmaps0  = images/ships/shpchoex/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpchoex/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpchoex/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpchoex/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpchoex/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpchoex/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpchoex/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpchoex/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpchoex/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpchoex/SHOT_B01_PCX.bmp
+SpecialSprites1 = images/ships/shpchoex/SHOT_B02_PCX.bmp
+SpecialSprites2 = images/ships/shpchoex/SHOT_B03_PCX.bmp
+SpecialSprites3 = images/ships/shpchoex/SHOT_B04_PCX.bmp
+SpecialSprites4 = images/ships/shpchoex/SHOT_B05_PCX.bmp
+SpecialSprites5 = images/ships/shpchoex/SHOT_B06_PCX.bmp
+SpecialSprites6 = images/ships/shpchoex/SHOT_B07_PCX.bmp
+SpecialSprites7 = images/ships/shpchoex/SHOT_B08_PCX.bmp
+SpecialSprites8 = images/ships/shpchoex/SHOT_B09_PCX.bmp
+SpecialSprites9 = images/ships/shpchoex/SHOT_B10_PCX.bmp
+
+ExtraSprites0 = images/ships/shpchoex/SHOT_C01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpconca.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpconca.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpconca.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -62,3 +62,24 @@
 ExtraExplosion   = 0
 PanelBitmaps     = 7
 
+[Graphic]
+PanelBitmaps0  = images/ships/shpconca/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpconca/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpconca/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpconca/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpconca/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpconca/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpconca/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpconca/SHIP_X00_BMP.bmp
+
+WeaponSprites0 = images/ships/shpconca/SHOT_000_PCX.bmp
+WeaponSprites1 = images/ships/shpconca/SHOT_001_PCX.bmp
+WeaponSprites2 = images/ships/shpconca/SHOT_002_PCX.bmp
+
+SpecialSprites0 = images/ships/shpconca/SHOT_A01_PCX.bmp
+
+ExtraSprites0 = images/ships/shpconca/SHOT_E00_PCX.bmp
+ExtraSprites1 = images/ships/shpconca/SHOT_E01_PCX.bmp
+ExtraSprites2 = images/ships/shpconca/SHOT_E02_PCS.bmp

Modified: trunk/gamedata/default_ini/ships/shpconho.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpconho.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpconho.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -77,3 +77,29 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 17
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpconho/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpconho/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpconho/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpconho/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpconho/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpconho/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpconho/SHIP_P06_PCX.bmp
+PanelBitmaps7  = images/ships/shpconho/SHIP_P07_PCX.bmp
+PanelBitmaps8  = images/ships/shpconho/SHIP_P08_PCX.bmp
+PanelBitmaps9  = images/ships/shpconho/SHIP_P09_PCX.bmp
+PanelBitmaps10  = images/ships/shpconho/SHIP_P10_PCX.bmp
+PanelBitmaps11  = images/ships/shpconho/SHIP_P11_PCX.bmp
+PanelBitmaps12  = images/ships/shpconho/SHIP_P12_PCX.bmp
+PanelBitmaps13  = images/ships/shpconho/SHIP_P13_PCX.bmp
+PanelBitmaps14  = images/ships/shpconho/SHIP_P14_PCX.bmp
+PanelBitmaps15  = images/ships/shpconho/SHIP_P15_PCX.bmp
+PanelBitmaps16  = images/ships/shpconho/SHIP_P16_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpconho/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpconho/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpconho/SHOT_B01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpdragr.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpdragr.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpdragr.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -75,3 +75,19 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpdragr/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpdragr/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpdragr/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpdragr/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpdragr/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpdragr/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpdragr/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpdragr/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpdragr/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpdragr/SHOT_B01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpdruma.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpdruma.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpdruma.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -76,3 +76,21 @@
 ExtraExplosion   = 0
 PanelBitmaps     = 7
 
+[Graphic]
+PanelBitmaps0  = images/ships/shpdruma/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpdruma/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpdruma/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpdruma/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpdruma/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpdruma/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpdruma/SHIP_P06_PCX.bmp
+
+ShipSprites0 = images/ships/shpdruma/SHIP_S00_PCX.bmp
+
+WeaponSprites0 = images/ships/shpdruma/SHOT_A01_PCX.bmp
+
+WeaponExplosion0 = images/ships/shpdruma/SHOT_B01_PCX.bmp
+WeaponExplosion1 = images/ships/shpdruma/SHOT_B02_PCX.bmp
+WeaponExplosion2 = images/ships/shpdruma/SHOT_B03_PCX.bmp
+WeaponExplosion3 = images/ships/shpdruma/SHOT_B04_PCX.bmp
+WeaponExplosion4 = images/ships/shpdruma/SHOT_B05_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpearc3.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpearc3.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpearc3.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -85,3 +85,74 @@
 ExtraSamples     = 1
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpearc3/ship_p00.bmp
+PanelBitmaps1  = images/ships/shpearc3/ship_p01.bmp
+PanelBitmaps2  = images/ships/shpearc3/ship_p02.bmp
+PanelBitmaps3  = images/ships/shpearc3/ship_p03.bmp
+PanelBitmaps4  = images/ships/shpearc3/ship_p04.bmp
+PanelBitmaps5  = images/ships/shpearc3/ship_p05.bmp
+PanelBitmaps6  = images/ships/shpearc3/ship_p06.bmp
+
+ShipSprites0 = images/ships/shpearc3/SHIP_S0_00_BMP.bmp
+
+WeaponSprites0 = images/ships/shpearc3/SHOT_A0_00_TGA.bmp
+WeaponSprites1 = images/ships/shpearc3/SHOT_A0_01_TGA.bmp
+WeaponSprites2 = images/ships/shpearc3/SHOT_A0_02_TGA.bmp
+WeaponSprites3 = images/ships/shpearc3/SHOT_A0_03_TGA.bmp
+WeaponSprites4 = images/ships/shpearc3/SHOT_A0_04_TGA.bmp
+WeaponSprites5 = images/ships/shpearc3/SHOT_A0_05_TGA.bmp
+WeaponSprites6 = images/ships/shpearc3/SHOT_A0_06_TGA.bmp
+WeaponSprites7 = images/ships/shpearc3/SHOT_A0_07_TGA.bmp
+WeaponSprites8 = images/ships/shpearc3/SHOT_A0_08_TGA.bmp
+WeaponSprites9 = images/ships/shpearc3/SHOT_A0_09_TGA.bmp
+WeaponSprites10 = images/ships/shpearc3/SHOT_A0_10_TGA.bmp
+WeaponSprites11 = images/ships/shpearc3/SHOT_A0_11_TGA.bmp
+WeaponSprites12 = images/ships/shpearc3/SHOT_A0_12_TGA.bmp
+WeaponSprites13 = images/ships/shpearc3/SHOT_A0_13_TGA.bmp
+WeaponSprites14 = images/ships/shpearc3/SHOT_A0_14_TGA.bmp
+WeaponSprites15 = images/ships/shpearc3/SHOT_A0_15_TGA.bmp
+WeaponSprites16 = images/ships/shpearc3/SHOT_A0_16_TGA.bmp
+WeaponSprites17 = images/ships/shpearc3/SHOT_A0_17_TGA.bmp
+WeaponSprites18 = images/ships/shpearc3/SHOT_A0_18_TGA.bmp
+WeaponSprites19 = images/ships/shpearc3/SHOT_A0_19_TGA.bmp
+WeaponSprites20 = images/ships/shpearc3/SHOT_A0_20_TGA.bmp
+WeaponSprites21 = images/ships/shpearc3/SHOT_A0_21_TGA.bmp
+WeaponSprites22 = images/ships/shpearc3/SHOT_A0_22_TGA.bmp
+WeaponSprites23 = images/ships/shpearc3/SHOT_A0_23_TGA.bmp
+WeaponSprites24 = images/ships/shpearc3/SHOT_A0_24_TGA.bmp
+WeaponSprites25 = images/ships/shpearc3/SHOT_A0_25_TGA.bmp
+WeaponSprites26 = images/ships/shpearc3/SHOT_A0_26_TGA.bmp
+WeaponSprites27 = images/ships/shpearc3/SHOT_A0_27_TGA.bmp
+WeaponSprites28 = images/ships/shpearc3/SHOT_A0_28_TGA.bmp
+WeaponSprites29 = images/ships/shpearc3/SHOT_A0_29_TGA.bmp
+WeaponSprites30 = images/ships/shpearc3/SHOT_A0_30_TGA.bmp
+WeaponSprites31 = images/ships/shpearc3/SHOT_A0_31_TGA.bmp
+WeaponSprites32 = images/ships/shpearc3/SHOT_A0_XX_TGA.bmp
+
+WeaponExplosion0 = images/ships/shpearc3/SHOT_B0_00_TGA.bmp
+WeaponExplosion1 = images/ships/shpearc3/SHOT_B0_01_TGA.bmp
+WeaponExplosion2 = images/ships/shpearc3/SHOT_B0_02_TGA.bmp
+WeaponExplosion3 = images/ships/shpearc3/SHOT_B0_03_TGA.bmp
+WeaponExplosion4 = images/ships/shpearc3/SHOT_B0_04_TGA.bmp
+WeaponExplosion5 = images/ships/shpearc3/SHOT_B0_05_TGA.bmp
+WeaponExplosion6 = images/ships/shpearc3/SHOT_B0_06_TGA.bmp
+WeaponExplosion7 = images/ships/shpearc3/SHOT_B0_07_TGA.bmp
+WeaponExplosion8 = images/ships/shpearc3/SHOT_B0_08_TGA.bmp
+WeaponExplosion9 = images/ships/shpearc3/SHOT_B0_09_TGA.bmp
+WeaponExplosion10 = images/ships/shpearc3/SHOT_B0_10_TGA.bmp
+WeaponExplosion11 = images/ships/shpearc3/SHOT_B0_11_TGA.bmp
+WeaponExplosion12 = images/ships/shpearc3/SHOT_B0_12_TGA.bmp
+WeaponExplosion13 = images/ships/shpearc3/SHOT_B0_13_TGA.bmp
+WeaponExplosion14 = images/ships/shpearc3/SHOT_B0_14_TGA.bmp
+WeaponExplosion15 = images/ships/shpearc3/SHOT_B0_15_TGA.bmp
+WeaponExplosion16 = images/ships/shpearc3/SHOT_B0_16_TGA.bmp
+WeaponExplosion17 = images/ships/shpearc3/SHOT_B0_17_TGA.bmp
+WeaponExplosion18 = images/ships/shpearc3/SHOT_B0_18_TGA.bmp
+WeaponExplosion19 = images/ships/shpearc3/SHOT_B0_19_TGA.bmp
+
+SpecialSprites0 = images/ships/shpearc3/SHOT_C0_00_TGA.bmp
+
+SpecialExplosion0 = images/ships/shpearc3/SHOT_D0_00_TGA.bmp

Modified: trunk/gamedata/default_ini/ships/shpearcr.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpearcr.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpearcr.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -82,3 +82,28 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpearcr/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpearcr/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpearcr/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpearcr/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpearcr/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpearcr/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpearcr/SHIP_P06_PCX.bmp
+
+ShipSprites0 = images/ships/shpearcr/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpearcr/SHOT_A01_PCX.bmp
+
+WeaponExplosion0 = images/ships/shpearcr/SHOT_B01_BMP.bmp
+WeaponExplosion1 = images/ships/shpearcr/SHOT_B02_BMP.bmp
+WeaponExplosion2 = images/ships/shpearcr/SHOT_B03_BMP.bmp
+WeaponExplosion3 = images/ships/shpearcr/SHOT_B04_BMP.bmp
+WeaponExplosion4 = images/ships/shpearcr/SHOT_B05_BMP.bmp
+WeaponExplosion5 = images/ships/shpearcr/SHOT_B06_BMP.bmp
+WeaponExplosion6 = images/ships/shpearcr/SHOT_B07_BMP.bmp
+WeaponExplosion7 = images/ships/shpearcr/SHOT_B08_BMP.bmp
+WeaponExplosion8 = images/ships/shpearcr/SHOT_B09_BMP.bmp
+WeaponExplosion9 = images/ships/shpearcr/SHOT_B10_BMP.bmp
+

Modified: trunk/gamedata/default_ini/ships/shpforsh.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpforsh.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpforsh.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -68,3 +68,126 @@
 ExtraSamples     = 0
 ExtraExplosion   = 32
 PanelBitmaps     = 7
+
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpforsh/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpforsh/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpforsh/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpforsh/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpforsh/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpforsh/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpforsh/SHIP_P06_PCX.bmp
+
+ShipSprites0 = images/ships/shpforsh/SHIP_SS_000_BMP.bmp
+
+WeaponSprites0 = images/ships/shpforsh/SHOT_AR_PRIMARY_0001_BMP.bmp
+WeaponSprites1 = images/ships/shpforsh/SHOT_AR_PRIMARY_0002_BMP.bmp
+WeaponSprites2 = images/ships/shpforsh/SHOT_AR_PRIMARY_0003_BMP.bmp
+WeaponSprites3 = images/ships/shpforsh/SHOT_AR_PRIMARY_0004_BMP.bmp
+WeaponSprites4 = images/ships/shpforsh/SHOT_AR_PRIMARY_0005_BMP.bmp
+WeaponSprites5 = images/ships/shpforsh/SHOT_AR_PRIMARY_0006_BMP.bmp
+WeaponSprites6 = images/ships/shpforsh/SHOT_AR_PRIMARY_0007_BMP.bmp
+WeaponSprites7 = images/ships/shpforsh/SHOT_AR_PRIMARY_0008_BMP.bmp
+WeaponSprites8 = images/ships/shpforsh/SHOT_AR_PRIMARY_0009_BMP.bmp
+WeaponSprites9 = images/ships/shpforsh/SHOT_AR_PRIMARY_0010_BMP.bmp
+WeaponSprites10 = images/ships/shpforsh/SHOT_AR_PRIMARY_0011_BMP.bmp
+WeaponSprites11 = images/ships/shpforsh/SHOT_AR_PRIMARY_0012_BMP.bmp
+WeaponSprites12 = images/ships/shpforsh/SHOT_AR_PRIMARY_0013_BMP.bmp
+WeaponSprites13 = images/ships/shpforsh/SHOT_AR_PRIMARY_0014_BMP.bmp
+WeaponSprites14 = images/ships/shpforsh/SHOT_AR_PRIMARY_0015_BMP.bmp
+WeaponSprites15 = images/ships/shpforsh/SHOT_AR_PRIMARY_0016_BMP.bmp
+WeaponSprites16 = images/ships/shpforsh/SHOT_AR_PRIMARY_0017_BMP.bmp
+WeaponSprites17 = images/ships/shpforsh/SHOT_AR_PRIMARY_0018_BMP.bmp
+WeaponSprites18 = images/ships/shpforsh/SHOT_AR_PRIMARY_0019_BMP.bmp
+WeaponSprites19 = images/ships/shpforsh/SHOT_AR_PRIMARY_0020_BMP.bmp
+WeaponSprites20 = images/ships/shpforsh/SHOT_AR_PRIMARY_0021_BMP.bmp
+WeaponSprites21 = images/ships/shpforsh/SHOT_AR_PRIMARY_0022_BMP.bmp
+WeaponSprites22 = images/ships/shpforsh/SHOT_AR_PRIMARY_0023_BMP.bmp
+WeaponSprites23 = images/ships/shpforsh/SHOT_AR_PRIMARY_0024_BMP.bmp
+WeaponSprites24 = images/ships/shpforsh/SHOT_AR_PRIMARY_0025_BMP.bmp
+WeaponSprites25 = images/ships/shpforsh/SHOT_AR_PRIMARY_0026_BMP.bmp
+WeaponSprites26 = images/ships/shpforsh/SHOT_AR_PRIMARY_0027_BMP.bmp
+WeaponSprites27 = images/ships/shpforsh/SHOT_AR_PRIMARY_0028_BMP.bmp
+WeaponSprites28 = images/ships/shpforsh/SHOT_AR_PRIMARY_0029_BMP.bmp
+WeaponSprites29 = images/ships/shpforsh/SHOT_AR_PRIMARY_0030_BMP.bmp
+WeaponSprites30 = images/ships/shpforsh/SHOT_AR_PRIMARY_0031_BMP.bmp
+WeaponSprites31 = images/ships/shpforsh/SHOT_AR_PRIMARY_0032_BMP.bmp
+
+SpecialSprites0 = images/ships/shpforsh/SHOT_B01_PCX.bmp
+SpecialSprites1 = images/ships/shpforsh/SHOT_B02_PCX.bmp
+SpecialSprites2 = images/ships/shpforsh/SHOT_B03_PCX.bmp
+SpecialSprites3 = images/ships/shpforsh/SHOT_B04_PCX.bmp
+SpecialSprites4 = images/ships/shpforsh/SHOT_B05_PCX.bmp
+SpecialSprites5 = images/ships/shpforsh/SHOT_B06_PCX.bmp
+SpecialSprites6 = images/ships/shpforsh/SHOT_B07_PCX.bmp
+SpecialSprites7 = images/ships/shpforsh/SHOT_B08_PCX.bmp
+SpecialSprites8 = images/ships/shpforsh/SHOT_B09_PCX.bmp
+SpecialSprites9 = images/ships/shpforsh/SHOT_B10_PCX.bmp
+
+ExtraSprites0 = images/ships/shpforsh/SHOT_ER_PRIMARY0001_BMP.bmp
+ExtraSprites1 = images/ships/shpforsh/SHOT_ER_PRIMARY0002_BMP.bmp
+ExtraSprites2 = images/ships/shpforsh/SHOT_ER_PRIMARY0003_BMP.bmp
+ExtraSprites3 = images/ships/shpforsh/SHOT_ER_PRIMARY0004_BMP.bmp
+ExtraSprites4 = images/ships/shpforsh/SHOT_ER_PRIMARY0005_BMP.bmp
+ExtraSprites5 = images/ships/shpforsh/SHOT_ER_PRIMARY0006_BMP.bmp
+ExtraSprites6 = images/ships/shpforsh/SHOT_ER_PRIMARY0007_BMP.bmp
+ExtraSprites7 = images/ships/shpforsh/SHOT_ER_PRIMARY0008_BMP.bmp
+ExtraSprites8 = images/ships/shpforsh/SHOT_ER_PRIMARY0009_BMP.bmp
+ExtraSprites9 = images/ships/shpforsh/SHOT_ER_PRIMARY0010_BMP.bmp
+ExtraSprites10 = images/ships/shpforsh/SHOT_ER_PRIMARY0011_BMP.bmp
+ExtraSprites11 = images/ships/shpforsh/SHOT_ER_PRIMARY0012_BMP.bmp
+ExtraSprites12 = images/ships/shpforsh/SHOT_ER_PRIMARY0013_BMP.bmp
+ExtraSprites13 = images/ships/shpforsh/SHOT_ER_PRIMARY0014_BMP.bmp
+ExtraSprites14 = images/ships/shpforsh/SHOT_ER_PRIMARY0015_BMP.bmp
+ExtraSprites15 = images/ships/shpforsh/SHOT_ER_PRIMARY0016_BMP.bmp
+ExtraSprites16 = images/ships/shpforsh/SHOT_ER_PRIMARY0017_BMP.bmp
+ExtraSprites17 = images/ships/shpforsh/SHOT_ER_PRIMARY0018_BMP.bmp
+ExtraSprites18 = images/ships/shpforsh/SHOT_ER_PRIMARY0019_BMP.bmp
+ExtraSprites19 = images/ships/shpforsh/SHOT_ER_PRIMARY0020_BMP.bmp
+ExtraSprites20 = images/ships/shpforsh/SHOT_ER_PRIMARY0021_BMP.bmp
+ExtraSprites21 = images/ships/shpforsh/SHOT_ER_PRIMARY0022_BMP.bmp
+ExtraSprites22 = images/ships/shpforsh/SHOT_ER_PRIMARY0023_BMP.bmp
+ExtraSprites23 = images/ships/shpforsh/SHOT_ER_PRIMARY0024_BMP.bmp
+ExtraSprites24 = images/ships/shpforsh/SHOT_ER_PRIMARY0025_BMP.bmp
+ExtraSprites25 = images/ships/shpforsh/SHOT_ER_PRIMARY0026_BMP.bmp
+ExtraSprites26 = images/ships/shpforsh/SHOT_ER_PRIMARY0027_BMP.bmp
+ExtraSprites27 = images/ships/shpforsh/SHOT_ER_PRIMARY0028_BMP.bmp
+ExtraSprites28 = images/ships/shpforsh/SHOT_ER_PRIMARY0029_BMP.bmp
+ExtraSprites29 = images/ships/shpforsh/SHOT_ER_PRIMARY0030_BMP.bmp
+ExtraSprites30 = images/ships/shpforsh/SHOT_ER_PRIMARY0031_BMP.bmp
+ExtraSprites31 = images/ships/shpforsh/SHOT_ER_PRIMARY0032_BMP.bmp
+
+ExtraExplosion0 = images/ships/shpforsh/SHOT_FR_LIGHTNING0000_BMP.bmp 
+ExtraExplosion1 = images/ships/shpforsh/SHOT_FR_LIGHTNING0001_BMP.bmp 
+ExtraExplosion2 = images/ships/shpforsh/SHOT_FR_LIGHTNING0002_BMP.bmp 
+ExtraExplosion3 = images/ships/shpforsh/SHOT_FR_LIGHTNING0003_BMP.bmp 
+ExtraExplosion4 = images/ships/shpforsh/SHOT_FR_LIGHTNING0004_BMP.bmp 
+ExtraExplosion5 = images/ships/shpforsh/SHOT_FR_LIGHTNING0005_BMP.bmp 
+ExtraExplosion6 = images/ships/shpforsh/SHOT_FR_LIGHTNING0006_BMP.bmp 
+ExtraExplosion7 = images/ships/shpforsh/SHOT_FR_LIGHTNING0007_BMP.bmp 
+ExtraExplosion8 = images/ships/shpforsh/SHOT_FR_LIGHTNING0008_BMP.bmp 
+ExtraExplosion9 = images/ships/shpforsh/SHOT_FR_LIGHTNING0009_BMP.bmp 
+ExtraExplosion10 = images/ships/shpforsh/SHOT_FR_LIGHTNING0010_BMP.bmp 
+ExtraExplosion11 = images/ships/shpforsh/SHOT_FR_LIGHTNING0011_BMP.bmp 
+ExtraExplosion12 = images/ships/shpforsh/SHOT_FR_LIGHTNING0012_BMP.bmp 
+ExtraExplosion13 = images/ships/shpforsh/SHOT_FR_LIGHTNING0013_BMP.bmp 
+ExtraExplosion14 = images/ships/shpforsh/SHOT_FR_LIGHTNING0014_BMP.bmp 
+ExtraExplosion15 = images/ships/shpforsh/SHOT_FR_LIGHTNING0015_BMP.bmp 
+ExtraExplosion16 = images/ships/shpforsh/SHOT_FR_LIGHTNING0016_BMP.bmp 
+ExtraExplosion17 = images/ships/shpforsh/SHOT_FR_LIGHTNING0017_BMP.bmp 
+ExtraExplosion18 = images/ships/shpforsh/SHOT_FR_LIGHTNING0018_BMP.bmp 
+ExtraExplosion19 = images/ships/shpforsh/SHOT_FR_LIGHTNING0019_BMP.bmp 
+ExtraExplosion20 = images/ships/shpforsh/SHOT_FR_LIGHTNING0020_BMP.bmp 
+ExtraExplosion21 = images/ships/shpforsh/SHOT_FR_LIGHTNING0021_BMP.bmp 
+ExtraExplosion22 = images/ships/shpforsh/SHOT_FR_LIGHTNING0022_BMP.bmp 
+ExtraExplosion23 = images/ships/shpforsh/SHOT_FR_LIGHTNING0023_BMP.bmp 
+ExtraExplosion24 = images/ships/shpforsh/SHOT_FR_LIGHTNING0024_BMP.bmp 
+ExtraExplosion25 = images/ships/shpforsh/SHOT_FR_LIGHTNING0025_BMP.bmp 
+ExtraExplosion26 = images/ships/shpforsh/SHOT_FR_LIGHTNING0026_BMP.bmp 
+ExtraExplosion27 = images/ships/shpforsh/SHOT_FR_LIGHTNING0027_BMP.bmp 
+ExtraExplosion28 = images/ships/shpforsh/SHOT_FR_LIGHTNING0028_BMP.bmp 
+ExtraExplosion29 = images/ships/shpforsh/SHOT_FR_LIGHTNING0029_BMP.bmp 
+ExtraExplosion30 = images/ships/shpforsh/SHOT_FR_LIGHTNING0030_BMP.bmp 
+ExtraExplosion31 = images/ships/shpforsh/SHOT_FR_LIGHTNING0031_BMP.bmp 
+              
\ No newline at end of file

Modified: trunk/gamedata/default_ini/ships/shpgarty.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpgarty.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpgarty.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -87,3 +87,36 @@
 ExtraSamples     = 3
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpgarty/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpgarty/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpgarty/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpgarty/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpgarty/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpgarty/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpgarty/SHIP_P06_PCX.bmp
+
+ShipSprites0 = images/ships/shpgarty/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpgarty/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shpgarty/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shpgarty/SHOT_A03_PCX.bmp
+
+WeaponExplosion0 = images/ships/shpgarty/SHOT_B01_PCX.bmp
+WeaponExplosion1 = images/ships/shpgarty/SHOT_B02_PCX.bmp
+WeaponExplosion2 = images/ships/shpgarty/SHOT_B03_PCX.bmp
+WeaponExplosion3 = images/ships/shpgarty/SHOT_B04_PCX.bmp
+WeaponExplosion4 = images/ships/shpgarty/SHOT_B05_PCX.bmp
+WeaponExplosion5 = images/ships/shpgarty/SHOT_B06_PCX.bmp
+WeaponExplosion6 = images/ships/shpgarty/SHOT_B07_PCX.bmp
+
+SpecialSprites0 = images/ships/shpgarty/SHOT_C01_PCX.bmp
+SpecialSprites1 = images/ships/shpgarty/SHOT_C02_PCX.bmp
+SpecialSprites2 = images/ships/shpgarty/SHOT_C03_PCX.bmp
+SpecialSprites3 = images/ships/shpgarty/SHOT_C04_PCX.bmp
+SpecialSprites4 = images/ships/shpgarty/SHOT_C05_PCX.bmp
+SpecialSprites5 = images/ships/shpgarty/SHOT_C06_PCX.bmp
+SpecialSprites6 = images/ships/shpgarty/SHOT_C07_PCX.bmp
+
+ExtraSprites0 = images/ships/shpgarty/SHOT_D01_PCX.bmp
\ No newline at end of file

Modified: trunk/gamedata/default_ini/ships/shpilwav.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpilwav.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpilwav.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -76,3 +76,67 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpilwav/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpilwav/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpilwav/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpilwav/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpilwav/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpilwav/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpilwav/SHIP_P06_PCX.bmp
+
+ShipSprites0 = images/ships/shpilwav/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpilwav/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shpilwav/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shpilwav/SHOT_A03_PCX.bmp
+WeaponSprites3 = images/ships/shpilwav/SHOT_A04_PCX.bmp
+WeaponSprites4 = images/ships/shpilwav/SHOT_A05_PCX.bmp
+WeaponSprites5 = images/ships/shpilwav/SHOT_A06_PCX.bmp
+WeaponSprites6 = images/ships/shpilwav/SHOT_A07_PCX.bmp
+WeaponSprites7 = images/ships/shpilwav/SHOT_A08_PCX.bmp
+WeaponSprites8 = images/ships/shpilwav/SHOT_A09_PCX.bmp
+WeaponSprites9 = images/ships/shpilwav/SHOT_A10_PCX.bmp
+WeaponSprites10 = images/ships/shpilwav/SHOT_A11_PCX.bmp
+WeaponSprites11 = images/ships/shpilwav/SHOT_A12_PCX.bmp
+WeaponSprites12 = images/ships/shpilwav/SHOT_A13_PCX.bmp
+WeaponSprites13 = images/ships/shpilwav/SHOT_A14_PCX.bmp
+WeaponSprites14 = images/ships/shpilwav/SHOT_A15_PCX.bmp
+WeaponSprites15 = images/ships/shpilwav/SHOT_A16_PCX.bmp
+WeaponSprites16 = images/ships/shpilwav/SHOT_A17_PCX.bmp
+WeaponSprites17 = images/ships/shpilwav/SHOT_A18_PCX.bmp
+WeaponSprites18 = images/ships/shpilwav/SHOT_A19_PCX.bmp
+WeaponSprites19 = images/ships/shpilwav/SHOT_A20_PCX.bmp
+WeaponSprites20 = images/ships/shpilwav/SHOT_A21_PCX.bmp
+WeaponSprites21 = images/ships/shpilwav/SHOT_A22_PCX.bmp
+WeaponSprites22 = images/ships/shpilwav/SHOT_A23_PCX.bmp
+WeaponSprites23 = images/ships/shpilwav/SHOT_A24_PCX.bmp
+WeaponSprites24 = images/ships/shpilwav/SHOT_A25_PCX.bmp
+WeaponSprites25 = images/ships/shpilwav/SHOT_A26_PCX.bmp
+WeaponSprites26 = images/ships/shpilwav/SHOT_A27_PCX.bmp
+WeaponSprites27 = images/ships/shpilwav/SHOT_A28_PCX.bmp
+WeaponSprites28 = images/ships/shpilwav/SHOT_A29_PCX.bmp
+WeaponSprites29 = images/ships/shpilwav/SHOT_A30_PCX.bmp
+WeaponSprites30 = images/ships/shpilwav/SHOT_A31_PCX.bmp
+WeaponSprites31 = images/ships/shpilwav/SHOT_A32_PCX.bmp
+WeaponSprites32 = images/ships/shpilwav/SHOT_A33_PCX.bmp
+WeaponSprites33 = images/ships/shpilwav/SHOT_A34_PCX.bmp
+WeaponSprites34 = images/ships/shpilwav/SHOT_A35_PCX.bmp
+WeaponSprites35 = images/ships/shpilwav/SHOT_A36_PCX.bmp
+WeaponSprites36 = images/ships/shpilwav/SHOT_A37_PCX.bmp
+WeaponSprites37 = images/ships/shpilwav/SHOT_A38_PCX.bmp
+WeaponSprites38 = images/ships/shpilwav/SHOT_A39_PCX.bmp
+WeaponSprites39 = images/ships/shpilwav/SHOT_A40_PCX.bmp
+WeaponSprites40 = images/ships/shpilwav/SHOT_A41_PCX.bmp
+WeaponSprites41 = images/ships/shpilwav/SHOT_A42_PCX.bmp
+WeaponSprites42 = images/ships/shpilwav/SHOT_A43_PCX.bmp
+WeaponSprites43 = images/ships/shpilwav/SHOT_A44_PCX.bmp
+WeaponSprites44 = images/ships/shpilwav/SHOT_A45_PCX.bmp
+WeaponSprites45 = images/ships/shpilwav/SHOT_A46_PCX.bmp
+WeaponSprites46 = images/ships/shpilwav/SHOT_A47_PCX.bmp
+WeaponSprites47 = images/ships/shpilwav/SHOT_A48_PCX.bmp
+WeaponSprites48 = images/ships/shpilwav/SHOT_A49_PCX.bmp
+WeaponSprites49 = images/ships/shpilwav/SHOT_A50_PCX.bmp
+                                              
+

Modified: trunk/gamedata/default_ini/ships/shpilwsp.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpilwsp.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpilwsp.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -68,3 +68,80 @@
 ExtraSamples     = 1
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpilwsp/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpilwsp/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpilwsp/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpilwsp/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpilwsp/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpilwsp/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpilwsp/SHIP_P06_PCX.bmp
+
+ShipSprites0 = images/ships/shpilwsp/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpilwsp/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shpilwsp/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shpilwsp/SHOT_A03_PCX.bmp
+WeaponSprites3 = images/ships/shpilwsp/SHOT_A04_PCX.bmp
+WeaponSprites4 = images/ships/shpilwsp/SHOT_A05_PCX.bmp
+WeaponSprites5 = images/ships/shpilwsp/SHOT_A06_PCX.bmp
+WeaponSprites6 = images/ships/shpilwsp/SHOT_A07_PCX.bmp
+WeaponSprites7 = images/ships/shpilwsp/SHOT_A08_PCX.bmp
+WeaponSprites8 = images/ships/shpilwsp/SHOT_A09_PCX.bmp
+WeaponSprites9 = images/ships/shpilwsp/SHOT_A10_PCX.bmp
+                                              
+SpecialSprites0 = images/ships/shpilwsp/SHOT_B01_PCX.bmp
+SpecialSprites1 = images/ships/shpilwsp/SHOT_B02_PCX.bmp
+SpecialSprites2 = images/ships/shpilwsp/SHOT_B03_PCX.bmp
+SpecialSprites3 = images/ships/shpilwsp/SHOT_B04_PCX.bmp
+SpecialSprites4 = images/ships/shpilwsp/SHOT_B05_PCX.bmp
+SpecialSprites5 = images/ships/shpilwsp/SHOT_B06_PCX.bmp
+SpecialSprites6 = images/ships/shpilwsp/SHOT_B07_PCX.bmp
+SpecialSprites7 = images/ships/shpilwsp/SHOT_B08_PCX.bmp
+SpecialSprites8 = images/ships/shpilwsp/SHOT_B09_PCX.bmp
+SpecialSprites9 = images/ships/shpilwsp/SHOT_B10_PCX.bmp
+SpecialSprites10 = images/ships/shpilwsp/SHOT_B11_PCX.bmp
+SpecialSprites11 = images/ships/shpilwsp/SHOT_B12_PCX.bmp
+SpecialSprites12 = images/ships/shpilwsp/SHOT_B13_PCX.bmp
+SpecialSprites13 = images/ships/shpilwsp/SHOT_B14_PCX.bmp
+SpecialSprites14 = images/ships/shpilwsp/SHOT_B15_PCX.bmp
+SpecialSprites15 = images/ships/shpilwsp/SHOT_B16_PCX.bmp
+SpecialSprites16 = images/ships/shpilwsp/SHOT_B17_PCX.bmp
+SpecialSprites17 = images/ships/shpilwsp/SHOT_B18_PCX.bmp
+SpecialSprites18 = images/ships/shpilwsp/SHOT_B19_PCX.bmp
+SpecialSprites19 = images/ships/shpilwsp/SHOT_B20_PCX.bmp
+SpecialSprites20 = images/ships/shpilwsp/SHOT_B21_PCX.bmp
+SpecialSprites21 = images/ships/shpilwsp/SHOT_B22_PCX.bmp
+SpecialSprites22 = images/ships/shpilwsp/SHOT_B23_PCX.bmp
+SpecialSprites23 = images/ships/shpilwsp/SHOT_B24_PCX.bmp
+SpecialSprites24 = images/ships/shpilwsp/SHOT_B25_PCX.bmp
+SpecialSprites25 = images/ships/shpilwsp/SHOT_B26_PCX.bmp
+SpecialSprites26 = images/ships/shpilwsp/SHOT_B27_PCX.bmp
+SpecialSprites27 = images/ships/shpilwsp/SHOT_B28_PCX.bmp
+SpecialSprites28 = images/ships/shpilwsp/SHOT_B29_PCX.bmp
+SpecialSprites29 = images/ships/shpilwsp/SHOT_B30_PCX.bmp
+SpecialSprites30 = images/ships/shpilwsp/SHOT_B31_PCX.bmp
+SpecialSprites31 = images/ships/shpilwsp/SHOT_B32_PCX.bmp
+
+ExtraSprites0 = images/ships/shpilwsp/SHOT_C01_PCX.bmp
+ExtraSprites1 = images/ships/shpilwsp/SHOT_C02_PCX.bmp
+ExtraSprites2 = images/ships/shpilwsp/SHOT_C03_PCX.bmp
+ExtraSprites3 = images/ships/shpilwsp/SHOT_C04_PCX.bmp
+ExtraSprites4 = images/ships/shpilwsp/SHOT_C05_PCX.bmp
+ExtraSprites5 = images/ships/shpilwsp/SHOT_C06_PCX.bmp
+ExtraSprites6 = images/ships/shpilwsp/SHOT_C07_PCX.bmp
+ExtraSprites7 = images/ships/shpilwsp/SHOT_C08_PCX.bmp
+ExtraSprites8 = images/ships/shpilwsp/SHOT_C09_PCX.bmp
+ExtraSprites9 = images/ships/shpilwsp/SHOT_C10_PCX.bmp
+ExtraSprites10 = images/ships/shpilwsp/SHOT_C11_PCX.bmp
+ExtraSprites11 = images/ships/shpilwsp/SHOT_C12_PCX.bmp
+ExtraSprites12 = images/ships/shpilwsp/SHOT_C13_PCX.bmp
+ExtraSprites13 = images/ships/shpilwsp/SHOT_C14_PCX.bmp
+ExtraSprites14 = images/ships/shpilwsp/SHOT_C15_PCX.bmp
+ExtraSprites15 = images/ships/shpilwsp/SHOT_C16_PCX.bmp
+ExtraSprites16 = images/ships/shpilwsp/SHOT_C17_PCX.bmp
+ExtraSprites17 = images/ships/shpilwsp/SHOT_C18_PCX.bmp
+ExtraSprites18 = images/ships/shpilwsp/SHOT_C19_PCX.bmp
+ExtraSprites19 = images/ships/shpilwsp/SHOT_C20_PCX.bmp
+

Modified: trunk/gamedata/default_ini/ships/shpkahbo.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpkahbo.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpkahbo.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -102,3 +102,24 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 10
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpkahbo/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpkahbo/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpkahbo/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpkahbo/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpkahbo/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpkahbo/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpkahbo/SHIP_P06_PCX.bmp
+PanelBitmaps7  = images/ships/shpkahbo/SHIP_P07_PCX.bmp
+PanelBitmaps8  = images/ships/shpkahbo/SHIP_P08_PCX.bmp
+PanelBitmaps9  = images/ships/shpkahbo/SHIP_P09_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpkahbo/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpkahbo/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpkahbo/SHOT_B01_PCX.bmp
+
+ExtraSprites0 = images/ships/shpkahbo/SHOT_C01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpkohma.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpkohma.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpkohma.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -86,3 +86,69 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpkohma/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpkohma/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpkohma/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpkohma/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpkohma/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpkohma/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpkohma/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpkohma/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpkohma/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shpkohma/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shpkohma/SHOT_A03_PCX.bmp
+WeaponSprites3 = images/ships/shpkohma/SHOT_A04_PCX.bmp
+WeaponSprites4 = images/ships/shpkohma/SHOT_A05_PCX.bmp
+WeaponSprites5 = images/ships/shpkohma/SHOT_A06_PCX.bmp
+WeaponSprites6 = images/ships/shpkohma/SHOT_A07_PCX.bmp
+WeaponSprites7 = images/ships/shpkohma/SHOT_A08_PCX.bmp
+WeaponSprites8 = images/ships/shpkohma/SHOT_A09_PCX.bmp
+WeaponSprites9 = images/ships/shpkohma/SHOT_A10_PCX.bmp
+
+                   
+WeaponExplosion0 = images/ships/shpkohma/SHOT_B01_PCX.bmp
+WeaponExplosion1 = images/ships/shpkohma/SHOT_B02_PCX.bmp
+WeaponExplosion2 = images/ships/shpkohma/SHOT_B03_PCX.bmp
+WeaponExplosion3 = images/ships/shpkohma/SHOT_B04_PCX.bmp
+WeaponExplosion4 = images/ships/shpkohma/SHOT_B05_PCX.bmp
+WeaponExplosion5 = images/ships/shpkohma/SHOT_B06_PCX.bmp
+WeaponExplosion6 = images/ships/shpkohma/SHOT_B07_PCX.bmp
+WeaponExplosion7 = images/ships/shpkohma/SHOT_B08_PCX.bmp
+WeaponExplosion8 = images/ships/shpkohma/SHOT_B09_PCX.bmp
+WeaponExplosion9 = images/ships/shpkohma/SHOT_B10_PCX.bmp
+WeaponExplosion10 = images/ships/shpkohma/SHOT_B11_PCX.bmp
+WeaponExplosion11 = images/ships/shpkohma/SHOT_B12_PCX.bmp
+WeaponExplosion12 = images/ships/shpkohma/SHOT_B13_PCX.bmp
+WeaponExplosion13 = images/ships/shpkohma/SHOT_B14_PCX.bmp
+WeaponExplosion14 = images/ships/shpkohma/SHOT_B15_PCX.bmp
+WeaponExplosion15 = images/ships/shpkohma/SHOT_B16_PCX.bmp
+WeaponExplosion16 = images/ships/shpkohma/SHOT_B17_PCX.bmp
+WeaponExplosion17 = images/ships/shpkohma/SHOT_B18_PCX.bmp
+WeaponExplosion18 = images/ships/shpkohma/SHOT_B19_PCX.bmp
+WeaponExplosion19 = images/ships/shpkohma/SHOT_B20_PCX.bmp
+
+SpecialSprites0 = images/ships/shpkohma/SHOT_C01_PCX.bmp
+SpecialSprites1 = images/ships/shpkohma/SHOT_C02_PCX.bmp
+SpecialSprites2 = images/ships/shpkohma/SHOT_C03_PCX.bmp
+SpecialSprites3 = images/ships/shpkohma/SHOT_C04_PCX.bmp
+SpecialSprites4 = images/ships/shpkohma/SHOT_C05_PCX.bmp
+SpecialSprites5 = images/ships/shpkohma/SHOT_C06_PCX.bmp
+SpecialSprites6 = images/ships/shpkohma/SHOT_C07_PCX.bmp
+SpecialSprites7 = images/ships/shpkohma/SHOT_C08_PCX.bmp
+SpecialSprites8 = images/ships/shpkohma/SHOT_C09_PCX.bmp
+SpecialSprites9 = images/ships/shpkohma/SHOT_C10_PCX.bmp
+SpecialSprites10 = images/ships/shpkohma/SHOT_C11_PCX.bmp
+SpecialSprites11 = images/ships/shpkohma/SHOT_C12_PCX.bmp
+SpecialSprites12 = images/ships/shpkohma/SHOT_C13_PCX.bmp
+SpecialSprites13 = images/ships/shpkohma/SHOT_C14_PCX.bmp
+SpecialSprites14 = images/ships/shpkohma/SHOT_C15_PCX.bmp
+SpecialSprites15 = images/ships/shpkohma/SHOT_C16_PCX.bmp
+SpecialSprites16 = images/ships/shpkohma/SHOT_C17_PCX.bmp
+SpecialSprites17 = images/ships/shpkohma/SHOT_C18_PCX.bmp
+SpecialSprites18 = images/ships/shpkohma/SHOT_C19_PCX.bmp
+SpecialSprites19 = images/ships/shpkohma/SHOT_C20_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpkzedr.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpkzedr.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpkzedr.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -86,3 +86,40 @@
 ExtraSamples     = 2
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpkzedr/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpkzedr/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpkzedr/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpkzedr/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpkzedr/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpkzedr/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpkzedr/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpkzedr/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpkzedr/SHOT_A01_PCX.bmp
+
+WeaponExplosion0 = images/ships/shpkzedr/SHOT_B01_PCX.bmp
+WeaponExplosion1 = images/ships/shpkzedr/SHOT_B02_PCX.bmp
+WeaponExplosion2 = images/ships/shpkzedr/SHOT_B03_PCX.bmp
+WeaponExplosion3 = images/ships/shpkzedr/SHOT_B04_PCX.bmp
+WeaponExplosion4 = images/ships/shpkzedr/SHOT_B05_PCX.bmp
+WeaponExplosion5 = images/ships/shpkzedr/SHOT_B06_PCX.bmp
+WeaponExplosion6 = images/ships/shpkzedr/SHOT_B07_PCX.bmp
+WeaponExplosion7 = images/ships/shpkzedr/SHOT_B08_PCX.bmp
+WeaponExplosion8 = images/ships/shpkzedr/SHOT_B09_PCX.bmp
+WeaponExplosion9 = images/ships/shpkzedr/SHOT_B10_PCX.bmp
+WeaponExplosion10 = images/ships/shpkzedr/SHOT_B11_PCX.bmp
+WeaponExplosion11 = images/ships/shpkzedr/SHOT_B12_PCX.bmp
+WeaponExplosion12 = images/ships/shpkzedr/SHOT_B13_PCX.bmp
+WeaponExplosion13 = images/ships/shpkzedr/SHOT_B14_PCX.bmp
+WeaponExplosion14 = images/ships/shpkzedr/SHOT_B15_PCX.bmp
+WeaponExplosion15 = images/ships/shpkzedr/SHOT_B16_PCX.bmp
+WeaponExplosion16 = images/ships/shpkzedr/SHOT_B17_PCX.bmp
+WeaponExplosion17 = images/ships/shpkzedr/SHOT_B18_PCX.bmp
+WeaponExplosion18 = images/ships/shpkzedr/SHOT_B19_PCX.bmp
+WeaponExplosion19 = images/ships/shpkzedr/SHOT_B20_PCX.bmp
+
+SpecialSprites0 = images/ships/shpkzedr/SHOT_C01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpmeltr.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpmeltr.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpmeltr.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -86,3 +86,181 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpmeltr/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpmeltr/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpmeltr/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpmeltr/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpmeltr/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpmeltr/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpmeltr/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpmeltr/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpmeltr/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shpmeltr/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shpmeltr/SHOT_A03_PCX.bmp
+WeaponSprites3 = images/ships/shpmeltr/SHOT_A04_PCX.bmp
+WeaponSprites4 = images/ships/shpmeltr/SHOT_A05_PCX.bmp
+WeaponSprites5 = images/ships/shpmeltr/SHOT_A06_PCX.bmp
+WeaponSprites6 = images/ships/shpmeltr/SHOT_A07_PCX.bmp
+WeaponSprites7 = images/ships/shpmeltr/SHOT_A08_PCX.bmp
+WeaponSprites8 = images/ships/shpmeltr/SHOT_A09_PCX.bmp
+WeaponSprites9 = images/ships/shpmeltr/SHOT_A10_PCX.bmp
+WeaponSprites10 = images/ships/shpmeltr/SHOT_B01_PCX.bmp
+WeaponSprites11 = images/ships/shpmeltr/SHOT_B02_PCX.bmp
+WeaponSprites12 = images/ships/shpmeltr/SHOT_B03_PCX.bmp
+WeaponSprites13 = images/ships/shpmeltr/SHOT_B04_PCX.bmp
+WeaponSprites14 = images/ships/shpmeltr/SHOT_B05_PCX.bmp
+WeaponSprites15 = images/ships/shpmeltr/SHOT_B06_PCX.bmp
+WeaponSprites16 = images/ships/shpmeltr/SHOT_B07_PCX.bmp
+WeaponSprites17 = images/ships/shpmeltr/SHOT_B08_PCX.bmp
+WeaponSprites18 = images/ships/shpmeltr/SHOT_B09_PCX.bmp
+WeaponSprites19 = images/ships/shpmeltr/SHOT_B10_PCX.bmp
+WeaponSprites20 = images/ships/shpmeltr/SHOT_C01_PCX.bmp
+WeaponSprites21 = images/ships/shpmeltr/SHOT_C02_PCX.bmp
+WeaponSprites22 = images/ships/shpmeltr/SHOT_C03_PCX.bmp
+WeaponSprites23 = images/ships/shpmeltr/SHOT_C04_PCX.bmp
+WeaponSprites24 = images/ships/shpmeltr/SHOT_C05_PCX.bmp
+WeaponSprites25 = images/ships/shpmeltr/SHOT_C06_PCX.bmp
+WeaponSprites26 = images/ships/shpmeltr/SHOT_C07_PCX.bmp
+WeaponSprites27 = images/ships/shpmeltr/SHOT_C08_PCX.bmp
+WeaponSprites28 = images/ships/shpmeltr/SHOT_C09_PCX.bmp
+WeaponSprites29 = images/ships/shpmeltr/SHOT_C10_PCX.bmp
+WeaponSprites30 = images/ships/shpmeltr/SHOT_D01_PCX.bmp
+WeaponSprites31 = images/ships/shpmeltr/SHOT_D02_PCX.bmp
+WeaponSprites32 = images/ships/shpmeltr/SHOT_D03_PCX.bmp
+WeaponSprites33 = images/ships/shpmeltr/SHOT_D04_PCX.bmp
+WeaponSprites34 = images/ships/shpmeltr/SHOT_D05_PCX.bmp
+WeaponSprites35 = images/ships/shpmeltr/SHOT_D06_PCX.bmp
+WeaponSprites36 = images/ships/shpmeltr/SHOT_D07_PCX.bmp
+WeaponSprites37 = images/ships/shpmeltr/SHOT_D08_PCX.bmp
+WeaponSprites38 = images/ships/shpmeltr/SHOT_D09_PCX.bmp
+WeaponSprites39 = images/ships/shpmeltr/SHOT_D10_PCX.bmp
+
+
+
+WeaponExplosion0 = images/ships/shpmeltr/SHOT_E01_PCX.bmp
+WeaponExplosion1 = images/ships/shpmeltr/SHOT_E02_PCX.bmp
+WeaponExplosion2 = images/ships/shpmeltr/SHOT_E03_PCX.bmp
+WeaponExplosion3 = images/ships/shpmeltr/SHOT_E04_PCX.bmp
+WeaponExplosion4 = images/ships/shpmeltr/SHOT_E05_PCX.bmp
+WeaponExplosion5 = images/ships/shpmeltr/SHOT_E06_PCX.bmp
+WeaponExplosion6 = images/ships/shpmeltr/SHOT_E07_PCX.bmp
+WeaponExplosion7 = images/ships/shpmeltr/SHOT_E08_PCX.bmp
+WeaponExplosion8 = images/ships/shpmeltr/SHOT_E09_PCX.bmp
+WeaponExplosion9 = images/ships/shpmeltr/SHOT_E10_PCX.bmp
+WeaponExplosion10 = images/ships/shpmeltr/SHOT_E11_PCX.bmp
+WeaponExplosion11 = images/ships/shpmeltr/SHOT_E12_PCX.bmp
+WeaponExplosion12 = images/ships/shpmeltr/SHOT_E13_PCX.bmp
+WeaponExplosion13 = images/ships/shpmeltr/SHOT_E14_PCX.bmp
+WeaponExplosion14 = images/ships/shpmeltr/SHOT_E15_PCX.bmp
+WeaponExplosion15 = images/ships/shpmeltr/SHOT_E16_PCX.bmp
+WeaponExplosion16 = images/ships/shpmeltr/SHOT_E17_PCX.bmp
+WeaponExplosion17 = images/ships/shpmeltr/SHOT_E18_PCX.bmp
+WeaponExplosion18 = images/ships/shpmeltr/SHOT_E19_PCX.bmp
+WeaponExplosion19 = images/ships/shpmeltr/SHOT_E20_PCX.bmp
+WeaponExplosion20 = images/ships/shpmeltr/SHOT_F01_PCX.bmp
+WeaponExplosion21 = images/ships/shpmeltr/SHOT_F02_PCX.bmp
+WeaponExplosion22 = images/ships/shpmeltr/SHOT_F03_PCX.bmp
+WeaponExplosion23 = images/ships/shpmeltr/SHOT_F04_PCX.bmp
+WeaponExplosion24 = images/ships/shpmeltr/SHOT_F05_PCX.bmp
+WeaponExplosion25 = images/ships/shpmeltr/SHOT_F06_PCX.bmp
+WeaponExplosion26 = images/ships/shpmeltr/SHOT_F07_PCX.bmp
+WeaponExplosion27 = images/ships/shpmeltr/SHOT_F08_PCX.bmp
+WeaponExplosion28 = images/ships/shpmeltr/SHOT_F09_PCX.bmp
+WeaponExplosion29 = images/ships/shpmeltr/SHOT_F10_PCX.bmp
+WeaponExplosion30 = images/ships/shpmeltr/SHOT_F11_PCX.bmp
+WeaponExplosion31 = images/ships/shpmeltr/SHOT_F12_PCX.bmp
+WeaponExplosion32 = images/ships/shpmeltr/SHOT_F13_PCX.bmp
+WeaponExplosion33 = images/ships/shpmeltr/SHOT_F14_PCX.bmp
+WeaponExplosion34 = images/ships/shpmeltr/SHOT_F15_PCX.bmp
+WeaponExplosion35 = images/ships/shpmeltr/SHOT_F16_PCX.bmp
+WeaponExplosion36 = images/ships/shpmeltr/SHOT_F17_PCX.bmp
+WeaponExplosion37 = images/ships/shpmeltr/SHOT_F18_PCX.bmp
+WeaponExplosion38 = images/ships/shpmeltr/SHOT_F19_PCX.bmp
+WeaponExplosion39 = images/ships/shpmeltr/SHOT_F20_PCX.bmp
+WeaponExplosion40 = images/ships/shpmeltr/SHOT_G01_PCX.bmp
+WeaponExplosion41 = images/ships/shpmeltr/SHOT_G02_PCX.bmp
+WeaponExplosion42 = images/ships/shpmeltr/SHOT_G03_PCX.bmp
+WeaponExplosion43 = images/ships/shpmeltr/SHOT_G04_PCX.bmp
+WeaponExplosion44 = images/ships/shpmeltr/SHOT_G05_PCX.bmp
+WeaponExplosion45 = images/ships/shpmeltr/SHOT_G06_PCX.bmp
+WeaponExplosion46 = images/ships/shpmeltr/SHOT_G07_PCX.bmp
+WeaponExplosion47 = images/ships/shpmeltr/SHOT_G08_PCX.bmp
+WeaponExplosion48 = images/ships/shpmeltr/SHOT_G09_PCX.bmp
+WeaponExplosion49 = images/ships/shpmeltr/SHOT_G10_PCX.bmp
+WeaponExplosion50 = images/ships/shpmeltr/SHOT_G11_PCX.bmp
+WeaponExplosion51 = images/ships/shpmeltr/SHOT_G12_PCX.bmp
+WeaponExplosion52 = images/ships/shpmeltr/SHOT_G13_PCX.bmp
+WeaponExplosion53 = images/ships/shpmeltr/SHOT_G14_PCX.bmp
+WeaponExplosion54 = images/ships/shpmeltr/SHOT_G15_PCX.bmp
+WeaponExplosion55 = images/ships/shpmeltr/SHOT_G16_PCX.bmp
+WeaponExplosion56 = images/ships/shpmeltr/SHOT_G17_PCX.bmp
+WeaponExplosion57 = images/ships/shpmeltr/SHOT_G18_PCX.bmp
+WeaponExplosion58 = images/ships/shpmeltr/SHOT_G19_PCX.bmp
+WeaponExplosion59 = images/ships/shpmeltr/SHOT_G20_PCX.bmp
+WeaponExplosion60 = images/ships/shpmeltr/SHOT_H01_PCX.bmp
+WeaponExplosion61 = images/ships/shpmeltr/SHOT_H02_PCX.bmp
+WeaponExplosion62 = images/ships/shpmeltr/SHOT_H03_PCX.bmp
+WeaponExplosion63 = images/ships/shpmeltr/SHOT_H04_PCX.bmp
+WeaponExplosion64 = images/ships/shpmeltr/SHOT_H05_PCX.bmp
+WeaponExplosion65 = images/ships/shpmeltr/SHOT_H06_PCX.bmp
+WeaponExplosion66 = images/ships/shpmeltr/SHOT_H07_PCX.bmp
+WeaponExplosion67 = images/ships/shpmeltr/SHOT_H08_PCX.bmp
+WeaponExplosion68 = images/ships/shpmeltr/SHOT_H09_PCX.bmp
+WeaponExplosion69 = images/ships/shpmeltr/SHOT_H10_PCX.bmp
+WeaponExplosion70 = images/ships/shpmeltr/SHOT_H11_PCX.bmp
+WeaponExplosion71 = images/ships/shpmeltr/SHOT_H12_PCX.bmp
+WeaponExplosion72 = images/ships/shpmeltr/SHOT_H13_PCX.bmp
+WeaponExplosion73 = images/ships/shpmeltr/SHOT_H14_PCX.bmp
+WeaponExplosion74 = images/ships/shpmeltr/SHOT_H15_PCX.bmp
+WeaponExplosion75 = images/ships/shpmeltr/SHOT_H16_PCX.bmp
+WeaponExplosion76 = images/ships/shpmeltr/SHOT_H17_PCX.bmp
+WeaponExplosion77 = images/ships/shpmeltr/SHOT_H18_PCX.bmp
+WeaponExplosion78 = images/ships/shpmeltr/SHOT_H19_PCX.bmp
+WeaponExplosion79 = images/ships/shpmeltr/SHOT_H20_PCX.bmp
+
+SpecialSprites0 = images/ships/shpmeltr/SHOT_I01_PCX.bmp
+SpecialSprites1 = images/ships/shpmeltr/SHOT_I02_PCX.bmp
+SpecialSprites2 = images/ships/shpmeltr/SHOT_I03_PCX.bmp
+SpecialSprites3 = images/ships/shpmeltr/SHOT_I04_PCX.bmp
+SpecialSprites4 = images/ships/shpmeltr/SHOT_I05_PCX.bmp
+SpecialSprites5 = images/ships/shpmeltr/SHOT_I06_PCX.bmp
+SpecialSprites6 = images/ships/shpmeltr/SHOT_I07_PCX.bmp
+SpecialSprites7 = images/ships/shpmeltr/SHOT_I08_PCX.bmp
+SpecialSprites8 = images/ships/shpmeltr/SHOT_I09_PCX.bmp
+SpecialSprites9 = images/ships/shpmeltr/SHOT_I10_PCX.bmp
+SpecialSprites10 = images/ships/shpmeltr/SHOT_I11_PCX.bmp
+SpecialSprites11 = images/ships/shpmeltr/SHOT_I12_PCX.bmp
+SpecialSprites12 = images/ships/shpmeltr/SHOT_I13_PCX.bmp
+SpecialSprites13 = images/ships/shpmeltr/SHOT_I14_PCX.bmp
+SpecialSprites14 = images/ships/shpmeltr/SHOT_I15_PCX.bmp
+SpecialSprites15 = images/ships/shpmeltr/SHOT_I16_PCX.bmp
+SpecialSprites16 = images/ships/shpmeltr/SHOT_I17_PCX.bmp
+SpecialSprites17 = images/ships/shpmeltr/SHOT_I18_PCX.bmp
+SpecialSprites18 = images/ships/shpmeltr/SHOT_I19_PCX.bmp
+SpecialSprites19 = images/ships/shpmeltr/SHOT_I20_PCX.bmp
+
+ExtraSprites0 = images/ships/shpmeltr/SHOT_J01_PCX.bmp
+ExtraSprites1 = images/ships/shpmeltr/SHOT_J02_PCX.bmp
+ExtraSprites2 = images/ships/shpmeltr/SHOT_J03_PCX.bmp
+ExtraSprites3 = images/ships/shpmeltr/SHOT_J04_PCX.bmp
+ExtraSprites4 = images/ships/shpmeltr/SHOT_J05_PCX.bmp
+ExtraSprites5 = images/ships/shpmeltr/SHOT_J06_PCX.bmp
+ExtraSprites6 = images/ships/shpmeltr/SHOT_J07_PCX.bmp
+ExtraSprites7 = images/ships/shpmeltr/SHOT_J08_PCX.bmp
+ExtraSprites8 = images/ships/shpmeltr/SHOT_J09_PCX.bmp
+ExtraSprites9 = images/ships/shpmeltr/SHOT_J10_PCX.bmp
+ExtraSprites10 = images/ships/shpmeltr/SHOT_J11_PCX.bmp
+ExtraSprites11 = images/ships/shpmeltr/SHOT_J12_PCX.bmp
+ExtraSprites12 = images/ships/shpmeltr/SHOT_J13_PCX.bmp
+ExtraSprites13 = images/ships/shpmeltr/SHOT_J14_PCX.bmp
+ExtraSprites14 = images/ships/shpmeltr/SHOT_J15_PCX.bmp
+ExtraSprites15 = images/ships/shpmeltr/SHOT_J16_PCX.bmp
+ExtraSprites16 = images/ships/shpmeltr/SHOT_J17_PCX.bmp
+ExtraSprites17 = images/ships/shpmeltr/SHOT_J18_PCX.bmp
+ExtraSprites18 = images/ships/shpmeltr/SHOT_J19_PCX.bmp
+ExtraSprites19 = images/ships/shpmeltr/SHOT_J20_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpmmrxf.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpmmrxf.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpmmrxf.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -107,3 +107,19 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpmmrxf/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpmmrxf/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpmmrxf/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpmmrxf/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpmmrxf/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpmmrxf/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpmmrxf/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpmmrxf/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpmmrxf/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpmmrxf/SHOT_B01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpmycpo.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpmycpo.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpmycpo.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -77,3 +77,102 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpmycpo/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpmycpo/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpmycpo/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpmycpo/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpmycpo/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpmycpo/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpmycpo/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpmycpo/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpmycpo/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shpmycpo/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shpmycpo/SHOT_A03_PCX.bmp
+WeaponSprites3 = images/ships/shpmycpo/SHOT_A04_PCX.bmp
+WeaponSprites4 = images/ships/shpmycpo/SHOT_A05_PCX.bmp
+WeaponSprites5 = images/ships/shpmycpo/SHOT_A06_PCX.bmp
+WeaponSprites6 = images/ships/shpmycpo/SHOT_A07_PCX.bmp
+WeaponSprites7 = images/ships/shpmycpo/SHOT_A08_PCX.bmp
+WeaponSprites8 = images/ships/shpmycpo/SHOT_A09_PCX.bmp
+WeaponSprites9 = images/ships/shpmycpo/SHOT_A10_PCX.bmp
+WeaponSprites10 = images/ships/shpmycpo/SHOT_A11_PCX.bmp
+WeaponSprites11 = images/ships/shpmycpo/SHOT_A12_PCX.bmp
+WeaponSprites12 = images/ships/shpmycpo/SHOT_A13_PCX.bmp
+WeaponSprites13 = images/ships/shpmycpo/SHOT_A14_PCX.bmp
+WeaponSprites14 = images/ships/shpmycpo/SHOT_A15_PCX.bmp
+WeaponSprites15 = images/ships/shpmycpo/SHOT_A16_PCX.bmp
+WeaponSprites16 = images/ships/shpmycpo/SHOT_A17_PCX.bmp
+WeaponSprites17 = images/ships/shpmycpo/SHOT_A18_PCX.bmp
+WeaponSprites18 = images/ships/shpmycpo/SHOT_A19_PCX.bmp
+WeaponSprites19 = images/ships/shpmycpo/SHOT_A20_PCX.bmp
+WeaponSprites20 = images/ships/shpmycpo/SHOT_A21_PCX.bmp
+WeaponSprites21 = images/ships/shpmycpo/SHOT_A22_PCX.bmp
+WeaponSprites22 = images/ships/shpmycpo/SHOT_A23_PCX.bmp
+WeaponSprites23 = images/ships/shpmycpo/SHOT_A24_PCX.bmp
+WeaponSprites24 = images/ships/shpmycpo/SHOT_A25_PCX.bmp
+WeaponSprites25 = images/ships/shpmycpo/SHOT_A26_PCX.bmp
+WeaponSprites26 = images/ships/shpmycpo/SHOT_A27_PCX.bmp
+WeaponSprites27 = images/ships/shpmycpo/SHOT_A28_PCX.bmp
+WeaponSprites28 = images/ships/shpmycpo/SHOT_A29_PCX.bmp
+WeaponSprites29 = images/ships/shpmycpo/SHOT_A30_PCX.bmp
+WeaponSprites30 = images/ships/shpmycpo/SHOT_A31_PCX.bmp
+WeaponSprites31 = images/ships/shpmycpo/SHOT_A32_PCX.bmp
+WeaponSprites32 = images/ships/shpmycpo/SHOT_A33_PCX.bmp
+WeaponSprites33 = images/ships/shpmycpo/SHOT_A34_PCX.bmp
+WeaponSprites34 = images/ships/shpmycpo/SHOT_A35_PCX.bmp
+WeaponSprites35 = images/ships/shpmycpo/SHOT_A36_PCX.bmp
+WeaponSprites36 = images/ships/shpmycpo/SHOT_A37_PCX.bmp
+WeaponSprites37 = images/ships/shpmycpo/SHOT_A38_PCX.bmp
+WeaponSprites38 = images/ships/shpmycpo/SHOT_A39_PCX.bmp
+WeaponSprites39 = images/ships/shpmycpo/SHOT_A40_PCX.bmp
+WeaponSprites40 = images/ships/shpmycpo/SHOT_A41_PCX.bmp
+WeaponSprites41 = images/ships/shpmycpo/SHOT_A42_PCX.bmp
+WeaponSprites42 = images/ships/shpmycpo/SHOT_A43_PCX.bmp
+WeaponSprites43 = images/ships/shpmycpo/SHOT_A44_PCX.bmp
+WeaponSprites44 = images/ships/shpmycpo/SHOT_A45_PCX.bmp
+WeaponSprites45 = images/ships/shpmycpo/SHOT_A46_PCX.bmp
+WeaponSprites46 = images/ships/shpmycpo/SHOT_A47_PCX.bmp
+WeaponSprites47 = images/ships/shpmycpo/SHOT_A48_PCX.bmp
+WeaponSprites48 = images/ships/shpmycpo/SHOT_A49_PCX.bmp
+WeaponSprites49 = images/ships/shpmycpo/SHOT_A50_PCX.bmp
+WeaponSprites50 = images/ships/shpmycpo/SHOT_A51_PCX.bmp
+WeaponSprites51 = images/ships/shpmycpo/SHOT_A52_PCX.bmp
+WeaponSprites52 = images/ships/shpmycpo/SHOT_A53_PCX.bmp
+WeaponSprites53 = images/ships/shpmycpo/SHOT_A54_PCX.bmp
+WeaponSprites54 = images/ships/shpmycpo/SHOT_A55_PCX.bmp
+WeaponSprites55 = images/ships/shpmycpo/SHOT_A56_PCX.bmp
+WeaponSprites56 = images/ships/shpmycpo/SHOT_A57_PCX.bmp
+WeaponSprites57 = images/ships/shpmycpo/SHOT_A58_PCX.bmp
+WeaponSprites58 = images/ships/shpmycpo/SHOT_A59_PCX.bmp
+WeaponSprites59 = images/ships/shpmycpo/SHOT_A60_PCX.bmp
+WeaponSprites60 = images/ships/shpmycpo/SHOT_A61_PCX.bmp
+WeaponSprites61 = images/ships/shpmycpo/SHOT_A62_PCX.bmp
+WeaponSprites62 = images/ships/shpmycpo/SHOT_A63_PCX.bmp
+WeaponSprites63 = images/ships/shpmycpo/SHOT_A64_PCX.bmp
+
+WeaponExplosion0 = images/ships/shpmycpo/SHOT_B01_PCX.bmp
+WeaponExplosion1 = images/ships/shpmycpo/SHOT_B02_PCX.bmp
+WeaponExplosion2 = images/ships/shpmycpo/SHOT_B03_PCX.bmp
+WeaponExplosion3 = images/ships/shpmycpo/SHOT_B04_PCX.bmp
+WeaponExplosion4 = images/ships/shpmycpo/SHOT_B05_PCX.bmp
+WeaponExplosion5 = images/ships/shpmycpo/SHOT_B06_PCX.bmp
+WeaponExplosion6 = images/ships/shpmycpo/SHOT_B07_PCX.bmp
+WeaponExplosion7 = images/ships/shpmycpo/SHOT_B08_PCX.bmp
+WeaponExplosion8 = images/ships/shpmycpo/SHOT_B09_PCX.bmp
+WeaponExplosion9 = images/ships/shpmycpo/SHOT_B10_PCX.bmp
+WeaponExplosion10 = images/ships/shpmycpo/SHOT_B11_PCX.bmp
+WeaponExplosion11 = images/ships/shpmycpo/SHOT_B12_PCX.bmp
+WeaponExplosion12 = images/ships/shpmycpo/SHOT_B13_PCX.bmp
+WeaponExplosion13 = images/ships/shpmycpo/SHOT_B14_PCX.bmp
+WeaponExplosion14 = images/ships/shpmycpo/SHOT_B15_PCX.bmp
+WeaponExplosion15 = images/ships/shpmycpo/SHOT_B16_PCX.bmp
+WeaponExplosion16 = images/ships/shpmycpo/SHOT_B17_PCX.bmp
+WeaponExplosion17 = images/ships/shpmycpo/SHOT_B18_PCX.bmp
+WeaponExplosion18 = images/ships/shpmycpo/SHOT_B19_PCX.bmp
+WeaponExplosion19 = images/ships/shpmycpo/SHOT_B20_PCX.bmp
+

Modified: trunk/gamedata/default_ini/ships/shporzne.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shporzne.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shporzne.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -93,3 +93,44 @@
 ExtraSamples     = 3
 ExtraExplosion   = 10 +alpha
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shporzne/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shporzne/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shporzne/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shporzne/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shporzne/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shporzne/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shporzne/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shporzne/SHIP_S_00_TGA.bmp
+
+WeaponSprites0 = images/ships/shporzne/SHOT_A01_PCX.bmp
+
+WeaponExplosion0 = images/ships/shporzne/SHOT_B_00_BMP.bmp
+WeaponExplosion1 = images/ships/shporzne/SHOT_B_01_BMP.bmp
+WeaponExplosion2 = images/ships/shporzne/SHOT_B_02_BMP.bmp
+WeaponExplosion3 = images/ships/shporzne/SHOT_B_03_BMP.bmp
+WeaponExplosion4 = images/ships/shporzne/SHOT_B_04_BMP.bmp
+WeaponExplosion5 = images/ships/shporzne/SHOT_B_05_BMP.bmp
+WeaponExplosion6 = images/ships/shporzne/SHOT_B_06_BMP.bmp
+WeaponExplosion7 = images/ships/shporzne/SHOT_B_07_BMP.bmp
+WeaponExplosion8 = images/ships/shporzne/SHOT_B_08_BMP.bmp
+WeaponExplosion9 = images/ships/shporzne/SHOT_B_09_BMP.bmp
+
+SpecialSprites0 = images/ships/shporzne/SHOT_C01_PCX.bmp
+SpecialSprites1 = images/ships/shporzne/SHOT_C02_PCX.bmp
+
+ExtraSprites0 = images/ships/shporzne/SHOT_D_00_TGA.bmp
+
+ExtraExplosion0 = images/ships/shporzne/SHOT_E_00_BMP.bmp
+ExtraExplosion1 = images/ships/shporzne/SHOT_E_01_BMP.bmp
+ExtraExplosion2 = images/ships/shporzne/SHOT_E_02_BMP.bmp
+ExtraExplosion3 = images/ships/shporzne/SHOT_E_03_BMP.bmp
+ExtraExplosion4 = images/ships/shporzne/SHOT_E_04_BMP.bmp
+ExtraExplosion5 = images/ships/shporzne/SHOT_E_05_BMP.bmp
+ExtraExplosion6 = images/ships/shporzne/SHOT_E_06_BMP.bmp
+ExtraExplosion7 = images/ships/shporzne/SHOT_E_07_BMP.bmp
+ExtraExplosion8 = images/ships/shporzne/SHOT_E_08_BMP.bmp
+ExtraExplosion9 = images/ships/shporzne/SHOT_E_09_BMP.bmp

Modified: trunk/gamedata/default_ini/ships/shppkufu.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shppkufu.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shppkufu.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -87,3 +87,27 @@
 ExtraSamples     = 1
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shppkufu/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shppkufu/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shppkufu/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shppkufu/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shppkufu/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shppkufu/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shppkufu/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shppkufu/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shppkufu/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shppkufu/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shppkufu/SHOT_A03_PCX.bmp
+WeaponSprites3 = images/ships/shppkufu/SHOT_A04_PCX.bmp
+WeaponSprites4 = images/ships/shppkufu/SHOT_A05_PCX.bmp
+WeaponSprites5 = images/ships/shppkufu/SHOT_A06_PCX.bmp
+WeaponSprites6 = images/ships/shppkufu/SHOT_A07_PCX.bmp
+WeaponSprites7 = images/ships/shppkufu/SHOT_A08_PCX.bmp
+WeaponSprites8 = images/ships/shppkufu/SHOT_A09_PCX.bmp
+WeaponSprites9 = images/ships/shppkufu/SHOT_A10_PCX.bmp
+

Modified: trunk/gamedata/default_ini/ships/shprogsq.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shprogsq.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shprogsq.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -110,3 +110,17 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shprogsq/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shprogsq/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shprogsq/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shprogsq/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shprogsq/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shprogsq/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shprogsq/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shprogsq/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shprogsq/SHOT_A01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpshosc.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpshosc.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpshosc.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -81,3 +81,49 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 8
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpshosc/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpshosc/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpshosc/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpshosc/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpshosc/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpshosc/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpshosc/SHIP_P06_PCX.bmp
+PanelBitmaps7  = images/ships/shpshosc/SHIP_P07_PCX.bmp
+
+ShipSprites0 = images/ships/shpshosc/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpshosc/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpshosc/SHOT_B01_PCX.bmp
+SpecialSprites1 = images/ships/shpshosc/SHOT_B02_PCX.bmp
+SpecialSprites2 = images/ships/shpshosc/SHOT_B03_PCX.bmp
+SpecialSprites3 = images/ships/shpshosc/SHOT_B04_PCX.bmp
+SpecialSprites4 = images/ships/shpshosc/SHOT_B05_PCX.bmp
+SpecialSprites5 = images/ships/shpshosc/SHOT_B06_PCX.bmp
+SpecialSprites6 = images/ships/shpshosc/SHOT_B07_PCX.bmp
+SpecialSprites7 = images/ships/shpshosc/SHOT_B08_PCX.bmp
+SpecialSprites8 = images/ships/shpshosc/SHOT_B09_PCX.bmp
+SpecialSprites9 = images/ships/shpshosc/SHOT_B10_PCX.bmp
+SpecialSprites10 = images/ships/shpshosc/SHOT_B11_PCX.bmp
+SpecialSprites11 = images/ships/shpshosc/SHOT_B12_PCX.bmp
+SpecialSprites12 = images/ships/shpshosc/SHOT_B13_PCX.bmp
+SpecialSprites13 = images/ships/shpshosc/SHOT_B14_PCX.bmp
+SpecialSprites14 = images/ships/shpshosc/SHOT_B15_PCX.bmp
+SpecialSprites15 = images/ships/shpshosc/SHOT_B16_PCX.bmp
+SpecialSprites16 = images/ships/shpshosc/SHOT_B17_PCX.bmp
+SpecialSprites17 = images/ships/shpshosc/SHOT_B18_PCX.bmp
+SpecialSprites18 = images/ships/shpshosc/SHOT_B19_PCX.bmp
+SpecialSprites19 = images/ships/shpshosc/SHOT_B20_PCX.bmp
+SpecialSprites20 = images/ships/shpshosc/SHOT_B21_PCX.bmp
+SpecialSprites21 = images/ships/shpshosc/SHOT_B22_PCX.bmp
+SpecialSprites22 = images/ships/shpshosc/SHOT_B23_PCX.bmp
+SpecialSprites23 = images/ships/shpshosc/SHOT_B24_PCX.bmp
+SpecialSprites24 = images/ships/shpshosc/SHOT_B25_PCX.bmp
+SpecialSprites25 = images/ships/shpshosc/SHOT_B26_PCX.bmp
+SpecialSprites26 = images/ships/shpshosc/SHOT_B27_PCX.bmp
+SpecialSprites27 = images/ships/shpshosc/SHOT_B28_PCX.bmp
+SpecialSprites28 = images/ships/shpshosc/SHOT_B29_PCX.bmp
+SpecialSprites29 = images/ships/shpshosc/SHOT_B30_PCX.bmp
+

Modified: trunk/gamedata/default_ini/ships/shpslypr.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpslypr.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpslypr.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -62,3 +62,79 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpslypr/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpslypr/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpslypr/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpslypr/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpslypr/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpslypr/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpslypr/SHIP_P06_PCX.bmp
+
+ShipSprites0 = images/ships/shpslypr/SHIP_S01_PCX.bmp
+ShipSprites1 = images/ships/shpslypr/SHIP_S02_PCX.bmp
+ShipSprites2 = images/ships/shpslypr/SHIP_S03_PCX.bmp
+ShipSprites3 = images/ships/shpslypr/SHIP_S04_PCX.bmp
+ShipSprites4 = images/ships/shpslypr/SHIP_S05_PCX.bmp
+ShipSprites5 = images/ships/shpslypr/SHIP_S06_PCX.bmp
+ShipSprites6 = images/ships/shpslypr/SHIP_S07_PCX.bmp
+ShipSprites7 = images/ships/shpslypr/SHIP_S08_PCX.bmp
+ShipSprites8 = images/ships/shpslypr/SHIP_S09_PCX.bmp
+ShipSprites9 = images/ships/shpslypr/SHIP_S10_PCX.bmp
+ShipSprites10 = images/ships/shpslypr/SHIP_S11_PCX.bmp
+ShipSprites11 = images/ships/shpslypr/SHIP_S12_PCX.bmp
+ShipSprites12 = images/ships/shpslypr/SHIP_S13_PCX.bmp
+ShipSprites13 = images/ships/shpslypr/SHIP_S14_PCX.bmp
+ShipSprites14 = images/ships/shpslypr/SHIP_S15_PCX.bmp
+ShipSprites15 = images/ships/shpslypr/SHIP_S16_PCX.bmp
+ShipSprites16 = images/ships/shpslypr/SHIP_S17_PCX.bmp
+ShipSprites17 = images/ships/shpslypr/SHIP_S18_PCX.bmp
+ShipSprites18 = images/ships/shpslypr/SHIP_S19_PCX.bmp
+ShipSprites19 = images/ships/shpslypr/SHIP_S20_PCX.bmp
+ShipSprites20 = images/ships/shpslypr/SHIP_S21_PCX.bmp
+ShipSprites21 = images/ships/shpslypr/SHIP_S22_PCX.bmp
+ShipSprites22 = images/ships/shpslypr/SHIP_S23_PCX.bmp
+ShipSprites23 = images/ships/shpslypr/SHIP_S24_PCX.bmp
+ShipSprites24 = images/ships/shpslypr/SHIP_S25_PCX.bmp
+ShipSprites25 = images/ships/shpslypr/SHIP_S26_PCX.bmp
+ShipSprites26 = images/ships/shpslypr/SHIP_S27_PCX.bmp
+ShipSprites27 = images/ships/shpslypr/SHIP_S28_PCX.bmp
+ShipSprites28 = images/ships/shpslypr/SHIP_S29_PCX.bmp
+ShipSprites29 = images/ships/shpslypr/SHIP_S30_PCX.bmp
+ShipSprites30 = images/ships/shpslypr/SHIP_S31_PCX.bmp
+ShipSprites31 = images/ships/shpslypr/SHIP_S32_PCX.bmp
+ShipSprites32 = images/ships/shpslypr/SHIP_S33_PCX.bmp
+ShipSprites33 = images/ships/shpslypr/SHIP_S34_PCX.bmp
+ShipSprites34 = images/ships/shpslypr/SHIP_S35_PCX.bmp
+ShipSprites35 = images/ships/shpslypr/SHIP_S36_PCX.bmp
+ShipSprites36 = images/ships/shpslypr/SHIP_S37_PCX.bmp
+ShipSprites37 = images/ships/shpslypr/SHIP_S38_PCX.bmp
+ShipSprites38 = images/ships/shpslypr/SHIP_S39_PCX.bmp
+ShipSprites39 = images/ships/shpslypr/SHIP_S40_PCX.bmp
+ShipSprites40 = images/ships/shpslypr/SHIP_S41_PCX.bmp
+ShipSprites41 = images/ships/shpslypr/SHIP_S42_PCX.bmp
+ShipSprites42 = images/ships/shpslypr/SHIP_S43_PCX.bmp
+ShipSprites43 = images/ships/shpslypr/SHIP_S44_PCX.bmp
+ShipSprites44 = images/ships/shpslypr/SHIP_S45_PCX.bmp
+ShipSprites45 = images/ships/shpslypr/SHIP_S46_PCX.bmp
+ShipSprites46 = images/ships/shpslypr/SHIP_S47_PCX.bmp
+ShipSprites47 = images/ships/shpslypr/SHIP_S48_PCX.bmp
+ShipSprites48 = images/ships/shpslypr/SHIP_S49_PCX.bmp
+ShipSprites49 = images/ships/shpslypr/SHIP_S50_PCX.bmp
+ShipSprites50 = images/ships/shpslypr/SHIP_S51_PCX.bmp
+ShipSprites51 = images/ships/shpslypr/SHIP_S52_PCX.bmp
+ShipSprites52 = images/ships/shpslypr/SHIP_S53_PCX.bmp
+ShipSprites53 = images/ships/shpslypr/SHIP_S54_PCX.bmp
+ShipSprites54 = images/ships/shpslypr/SHIP_S55_PCX.bmp
+ShipSprites55 = images/ships/shpslypr/SHIP_S56_PCX.bmp
+ShipSprites56 = images/ships/shpslypr/SHIP_S57_PCX.bmp
+ShipSprites57 = images/ships/shpslypr/SHIP_S58_PCX.bmp
+ShipSprites58 = images/ships/shpslypr/SHIP_S59_PCX.bmp
+ShipSprites59 = images/ships/shpslypr/SHIP_S60_PCX.bmp
+ShipSprites60 = images/ships/shpslypr/SHIP_S61_PCX.bmp
+ShipSprites61 = images/ships/shpslypr/SHIP_S62_PCX.bmp
+ShipSprites62 = images/ships/shpslypr/SHIP_S63_PCX.bmp
+ShipSprites63 = images/ships/shpslypr/SHIP_S64_PCX.bmp
+
+WeaponExplosion0 = images/ships/shpslypr/SHIP_W01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpspael.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpspael.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpspael.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -82,3 +82,19 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpspael/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpspael/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpspael/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpspael/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpspael/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpspael/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpspael/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpspael/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpspael/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpspael/SHOT_B01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpstaba.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpstaba.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpstaba.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -69,3 +69,18 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpstaba/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpstaba/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpstaba/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpstaba/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpstaba/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpstaba/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpstaba/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpstaba/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpstaba/SHOT_A01_PCX.bmp
+

Modified: trunk/gamedata/default_ini/ships/shpsupbl.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpsupbl.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpsupbl.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -70,3 +70,30 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpsupbl/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpsupbl/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpsupbl/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpsupbl/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpsupbl/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpsupbl/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpsupbl/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpsupbl/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpsupbl/SHOT_A01_PCX.bmp
+
+WeaponExplosion0 = images/ships/shpsupbl/SHOT_B01_PCX.bmp
+WeaponExplosion1 = images/ships/shpsupbl/SHOT_B02_PCX.bmp
+WeaponExplosion2 = images/ships/shpsupbl/SHOT_B03_PCX.bmp
+WeaponExplosion3 = images/ships/shpsupbl/SHOT_B04_PCX.bmp
+WeaponExplosion4 = images/ships/shpsupbl/SHOT_B05_PCX.bmp
+WeaponExplosion5 = images/ships/shpsupbl/SHOT_B06_PCX.bmp
+WeaponExplosion6 = images/ships/shpsupbl/SHOT_B07_PCX.bmp
+WeaponExplosion7 = images/ships/shpsupbl/SHOT_B08_PCX.bmp
+WeaponExplosion8 = images/ships/shpsupbl/SHOT_B09_PCX.bmp
+WeaponExplosion9 = images/ships/shpsupbl/SHOT_B10_PCX.bmp
+
+

Modified: trunk/gamedata/default_ini/ships/shpsyrpe.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpsyrpe.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpsyrpe.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -82,3 +82,19 @@
 ExtraSamples     = 1
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpsyrpe/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpsyrpe/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpsyrpe/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpsyrpe/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpsyrpe/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpsyrpe/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpsyrpe/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpsyrpe/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpsyrpe/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpsyrpe/SHOT_B01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shptauar.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shptauar.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shptauar.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -84,5 +84,170 @@
 ExtraSprites     = 12
 ExtraSamples     = 4
 ExtraExplosion   = 20 +alpha
-ExtraExtraSprites0 = 1r +alpha
+ExtraExtraSprites0_ = 1r +alpha
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shptauar/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shptauar/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shptauar/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shptauar/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shptauar/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shptauar/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shptauar/SHIP_P06_PCX.bmp
+
+ShipSprites0 = images/ships/shptauar/SHIP_S0_00_TGA.bmp
+
+WeaponSprites0 = images/ships/shptauar/SHOT_A0_00_TGA.bmp 
+WeaponSprites1 = images/ships/shptauar/SHOT_A0_01_TGA.bmp 
+WeaponSprites2 = images/ships/shptauar/SHOT_A0_02_TGA.bmp 
+WeaponSprites3 = images/ships/shptauar/SHOT_A0_03_TGA.bmp 
+WeaponSprites4 = images/ships/shptauar/SHOT_A0_04_TGA.bmp 
+WeaponSprites5 = images/ships/shptauar/SHOT_A0_05_TGA.bmp 
+WeaponSprites6 = images/ships/shptauar/SHOT_A0_06_TGA.bmp 
+WeaponSprites7 = images/ships/shptauar/SHOT_A0_07_TGA.bmp 
+WeaponSprites8 = images/ships/shptauar/SHOT_A0_08_TGA.bmp 
+WeaponSprites9 = images/ships/shptauar/SHOT_A0_09_TGA.bmp 
+WeaponSprites10 = images/ships/shptauar/SHOT_A0_10_TGA.bmp 
+WeaponSprites11 = images/ships/shptauar/SHOT_A0_11_TGA.bmp 
+WeaponSprites12 = images/ships/shptauar/SHOT_A0_12_TGA.bmp 
+WeaponSprites13 = images/ships/shptauar/SHOT_A0_13_TGA.bmp 
+WeaponSprites14 = images/ships/shptauar/SHOT_A0_14_TGA.bmp 
+WeaponSprites15 = images/ships/shptauar/SHOT_A0_15_TGA.bmp 
+WeaponSprites16 = images/ships/shptauar/SHOT_A0_16_TGA.bmp 
+WeaponSprites17 = images/ships/shptauar/SHOT_A0_17_TGA.bmp 
+WeaponSprites18 = images/ships/shptauar/SHOT_A0_18_TGA.bmp 
+WeaponSprites19 = images/ships/shptauar/SHOT_A0_19_TGA.bmp 
+WeaponSprites20 = images/ships/shptauar/SHOT_A1_00_TGA.bmp 
+WeaponSprites21 = images/ships/shptauar/SHOT_A1_01_TGA.bmp 
+WeaponSprites22 = images/ships/shptauar/SHOT_A1_02_TGA.bmp 
+WeaponSprites23 = images/ships/shptauar/SHOT_A1_03_TGA.bmp 
+WeaponSprites24 = images/ships/shptauar/SHOT_A1_04_TGA.bmp 
+WeaponSprites25 = images/ships/shptauar/SHOT_A1_05_TGA.bmp 
+WeaponSprites26 = images/ships/shptauar/SHOT_A1_06_TGA.bmp 
+WeaponSprites27 = images/ships/shptauar/SHOT_A1_07_TGA.bmp 
+WeaponSprites28 = images/ships/shptauar/SHOT_A1_08_TGA.bmp 
+WeaponSprites29 = images/ships/shptauar/SHOT_A1_09_TGA.bmp 
+WeaponSprites30 = images/ships/shptauar/SHOT_A1_10_TGA.bmp 
+WeaponSprites31 = images/ships/shptauar/SHOT_A1_11_TGA.bmp 
+WeaponSprites32 = images/ships/shptauar/SHOT_A1_12_TGA.bmp 
+WeaponSprites33 = images/ships/shptauar/SHOT_A1_13_TGA.bmp 
+WeaponSprites34 = images/ships/shptauar/SHOT_A1_14_TGA.bmp 
+WeaponSprites35 = images/ships/shptauar/SHOT_A1_15_TGA.bmp 
+WeaponSprites36 = images/ships/shptauar/SHOT_A1_16_TGA.bmp 
+WeaponSprites37 = images/ships/shptauar/SHOT_A1_17_TGA.bmp 
+WeaponSprites38 = images/ships/shptauar/SHOT_A1_18_TGA.bmp 
+WeaponSprites39 = images/ships/shptauar/SHOT_A1_19_TGA.bmp 
+WeaponSprites40 = images/ships/shptauar/SHOT_A2_00_TGA.bmp 
+WeaponSprites41 = images/ships/shptauar/SHOT_A2_01_TGA.bmp 
+WeaponSprites42 = images/ships/shptauar/SHOT_A2_02_TGA.bmp 
+WeaponSprites43 = images/ships/shptauar/SHOT_A2_03_TGA.bmp 
+WeaponSprites44 = images/ships/shptauar/SHOT_A2_04_TGA.bmp 
+WeaponSprites45 = images/ships/shptauar/SHOT_A2_05_TGA.bmp 
+WeaponSprites46 = images/ships/shptauar/SHOT_A2_06_TGA.bmp 
+WeaponSprites47 = images/ships/shptauar/SHOT_A2_07_TGA.bmp 
+WeaponSprites48 = images/ships/shptauar/SHOT_A2_08_TGA.bmp 
+WeaponSprites49 = images/ships/shptauar/SHOT_A2_09_TGA.bmp 
+WeaponSprites50 = images/ships/shptauar/SHOT_A2_10_TGA.bmp 
+WeaponSprites51 = images/ships/shptauar/SHOT_A2_11_TGA.bmp 
+WeaponSprites52 = images/ships/shptauar/SHOT_A2_12_TGA.bmp 
+WeaponSprites53 = images/ships/shptauar/SHOT_A2_13_TGA.bmp 
+WeaponSprites54 = images/ships/shptauar/SHOT_A2_14_TGA.bmp 
+WeaponSprites55 = images/ships/shptauar/SHOT_A2_15_TGA.bmp 
+WeaponSprites56 = images/ships/shptauar/SHOT_A2_16_TGA.bmp 
+WeaponSprites57 = images/ships/shptauar/SHOT_A2_17_TGA.bmp 
+WeaponSprites58 = images/ships/shptauar/SHOT_A2_18_TGA.bmp 
+WeaponSprites59 = images/ships/shptauar/SHOT_A2_19_TGA.bmp 
+WeaponSprites60 = images/ships/shptauar/SHOT_A3_00_TGA.bmp 
+WeaponSprites61 = images/ships/shptauar/SHOT_A3_01_TGA.bmp 
+WeaponSprites62 = images/ships/shptauar/SHOT_A3_02_TGA.bmp 
+WeaponSprites63 = images/ships/shptauar/SHOT_A3_03_TGA.bmp 
+WeaponSprites64 = images/ships/shptauar/SHOT_A3_04_TGA.bmp 
+WeaponSprites65 = images/ships/shptauar/SHOT_A3_05_TGA.bmp 
+WeaponSprites66 = images/ships/shptauar/SHOT_A3_06_TGA.bmp 
+WeaponSprites67 = images/ships/shptauar/SHOT_A3_07_TGA.bmp 
+WeaponSprites68 = images/ships/shptauar/SHOT_A3_08_TGA.bmp 
+WeaponSprites69 = images/ships/shptauar/SHOT_A3_09_TGA.bmp 
+WeaponSprites70 = images/ships/shptauar/SHOT_A3_10_TGA.bmp 
+WeaponSprites71 = images/ships/shptauar/SHOT_A3_11_TGA.bmp 
+WeaponSprites72 = images/ships/shptauar/SHOT_A3_12_TGA.bmp 
+WeaponSprites73 = images/ships/shptauar/SHOT_A3_13_TGA.bmp 
+WeaponSprites74 = images/ships/shptauar/SHOT_A3_14_TGA.bmp 
+WeaponSprites75 = images/ships/shptauar/SHOT_A3_15_TGA.bmp 
+WeaponSprites76 = images/ships/shptauar/SHOT_A3_16_TGA.bmp 
+WeaponSprites77 = images/ships/shptauar/SHOT_A3_17_TGA.bmp 
+WeaponSprites78 = images/ships/shptauar/SHOT_A3_18_TGA.bmp 
+WeaponSprites79 = images/ships/shptauar/SHOT_A3_19_TGA.bmp 
+WeaponSprites80 = images/ships/shptauar/SHOT_AX_00_TGA.bmp 
+
+
+WeaponExplosion0 = images/ships/shptauar/SHOT_B_00_TGA.bmp 
+WeaponExplosion1 = images/ships/shptauar/SHOT_B_01_TGA.bmp 
+WeaponExplosion2 = images/ships/shptauar/SHOT_B_02_TGA.bmp 
+WeaponExplosion3 = images/ships/shptauar/SHOT_B_03_TGA.bmp 
+WeaponExplosion4 = images/ships/shptauar/SHOT_B_04_TGA.bmp 
+WeaponExplosion5 = images/ships/shptauar/SHOT_B_05_TGA.bmp 
+WeaponExplosion6 = images/ships/shptauar/SHOT_B_06_TGA.bmp 
+WeaponExplosion7 = images/ships/shptauar/SHOT_B_07_TGA.bmp 
+WeaponExplosion8 = images/ships/shptauar/SHOT_B_08_TGA.bmp 
+WeaponExplosion9 = images/ships/shptauar/SHOT_B_09_TGA.bmp 
+
+SpecialSprites0 = images/ships/shptauar/SHOT_C0_00_TGA.bmp
+SpecialSprites1 = images/ships/shptauar/SHOT_C1_00_TGA.bmp
+
+SpecialExplosion0 = images/ships/shptauar/SHOT_D_00_TGA.bmp
+SpecialExplosion1 = images/ships/shptauar/SHOT_D_01_TGA.bmp
+SpecialExplosion2 = images/ships/shptauar/SHOT_D_02_TGA.bmp
+SpecialExplosion3 = images/ships/shptauar/SHOT_D_03_TGA.bmp
+SpecialExplosion4 = images/ships/shptauar/SHOT_D_04_TGA.bmp
+SpecialExplosion5 = images/ships/shptauar/SHOT_D_05_TGA.bmp
+SpecialExplosion6 = images/ships/shptauar/SHOT_D_06_TGA.bmp
+SpecialExplosion7 = images/ships/shptauar/SHOT_D_07_TGA.bmp
+SpecialExplosion8 = images/ships/shptauar/SHOT_D_08_TGA.bmp
+SpecialExplosion9 = images/ships/shptauar/SHOT_D_09_TGA.bmp
+SpecialExplosion10 = images/ships/shptauar/SHOT_D_10_TGA.bmp
+SpecialExplosion11 = images/ships/shptauar/SHOT_D_11_TGA.bmp
+SpecialExplosion12 = images/ships/shptauar/SHOT_D_12_TGA.bmp
+SpecialExplosion13 = images/ships/shptauar/SHOT_D_13_TGA.bmp
+SpecialExplosion14 = images/ships/shptauar/SHOT_D_14_TGA.bmp
+SpecialExplosion15 = images/ships/shptauar/SHOT_D_15_TGA.bmp
+SpecialExplosion16 = images/ships/shptauar/SHOT_D_16_TGA.bmp
+SpecialExplosion17 = images/ships/shptauar/SHOT_D_17_TGA.bmp
+SpecialExplosion18 = images/ships/shptauar/SHOT_D_18_TGA.bmp
+SpecialExplosion19 = images/ships/shptauar/SHOT_D_19_TGA.bmp
+
+ExtraSprites0 = images/ships/shptauar/SHOT_C01_PCX.bmp 
+ExtraSprites1 = images/ships/shptauar/SHOT_C02_PCX.bmp 
+ExtraSprites2 = images/ships/shptauar/SHOT_C03_PCX.bmp 
+ExtraSprites3 = images/ships/shptauar/SHOT_C04_PCX.bmp 
+ExtraSprites4 = images/ships/shptauar/SHOT_C05_PCX.bmp 
+ExtraSprites5 = images/ships/shptauar/SHOT_C06_PCX.bmp 
+ExtraSprites6 = images/ships/shptauar/SHOT_C07_PCX.bmp 
+ExtraSprites7 = images/ships/shptauar/SHOT_C08_PCX.bmp 
+ExtraSprites8 = images/ships/shptauar/SHOT_C09_PCX.bmp 
+ExtraSprites9 = images/ships/shptauar/SHOT_C10_PCX.bmp 
+ExtraSprites10 = images/ships/shptauar/SHOT_C11_PCX.bmp 
+ExtraSprites11 = images/ships/shptauar/SHOT_C12_PCX.bmp 
+
+ExtraExplosion0 = images/ships/shptauar/SHOT_F_00_TGA.bmp
+ExtraExplosion1 = images/ships/shptauar/SHOT_F_01_TGA.bmp
+ExtraExplosion2 = images/ships/shptauar/SHOT_F_02_TGA.bmp
+ExtraExplosion3 = images/ships/shptauar/SHOT_F_03_TGA.bmp
+ExtraExplosion4 = images/ships/shptauar/SHOT_F_04_TGA.bmp
+ExtraExplosion5 = images/ships/shptauar/SHOT_F_05_TGA.bmp
+ExtraExplosion6 = images/ships/shptauar/SHOT_F_06_TGA.bmp
+ExtraExplosion7 = images/ships/shptauar/SHOT_F_07_TGA.bmp
+ExtraExplosion8 = images/ships/shptauar/SHOT_F_08_TGA.bmp
+ExtraExplosion9 = images/ships/shptauar/SHOT_F_09_TGA.bmp
+ExtraExplosion10 = images/ships/shptauar/SHOT_F_10_TGA.bmp
+ExtraExplosion11 = images/ships/shptauar/SHOT_F_11_TGA.bmp
+ExtraExplosion12 = images/ships/shptauar/SHOT_F_12_TGA.bmp
+ExtraExplosion13 = images/ships/shptauar/SHOT_F_13_TGA.bmp
+ExtraExplosion14 = images/ships/shptauar/SHOT_F_14_TGA.bmp
+ExtraExplosion15 = images/ships/shptauar/SHOT_F_15_TGA.bmp
+ExtraExplosion16 = images/ships/shptauar/SHOT_F_16_TGA.bmp
+ExtraExplosion17 = images/ships/shptauar/SHOT_F_17_TGA.bmp
+ExtraExplosion18 = images/ships/shptauar/SHOT_F_18_TGA.bmp
+ExtraExplosion19 = images/ships/shptauar/SHOT_F_19_TGA.bmp
+
+ExtraExtraSprites0_0 = images/ships/shptauar/SHOT_X0_00_BMP.bmp 

Modified: trunk/gamedata/default_ini/ships/shptauda.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shptauda.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shptauda.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -56,3 +56,52 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shptauda/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shptauda/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shptauda/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shptauda/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shptauda/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shptauda/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shptauda/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shptauda/SHIP_S_00_TGA.bmp
+
+WeaponExplosion0 = images/ships/shptauda/SHOT_B_00_TGA.bmp
+
+SpecialSprites0 = images/ships/shptauda/SHOT_C0_00_TGA.bmp
+SpecialSprites1 = images/ships/shptauda/SHOT_C1_00_TGA.bmp
+
+SpecialExplosion0 = images/ships/shptauda/SHOT_D_00_TGA.bmp
+SpecialExplosion1 = images/ships/shptauda/SHOT_D_01_TGA.bmp
+SpecialExplosion2 = images/ships/shptauda/SHOT_D_02_TGA.bmp
+SpecialExplosion3 = images/ships/shptauda/SHOT_D_03_TGA.bmp
+SpecialExplosion4 = images/ships/shptauda/SHOT_D_04_TGA.bmp
+SpecialExplosion5 = images/ships/shptauda/SHOT_D_05_TGA.bmp
+SpecialExplosion6 = images/ships/shptauda/SHOT_D_06_TGA.bmp
+SpecialExplosion7 = images/ships/shptauda/SHOT_D_07_TGA.bmp
+SpecialExplosion8 = images/ships/shptauda/SHOT_D_08_TGA.bmp
+SpecialExplosion9 = images/ships/shptauda/SHOT_D_09_TGA.bmp
+SpecialExplosion10 = images/ships/shptauda/SHOT_D_10_TGA.bmp
+SpecialExplosion11 = images/ships/shptauda/SHOT_D_11_TGA.bmp
+SpecialExplosion12 = images/ships/shptauda/SHOT_D_12_TGA.bmp
+SpecialExplosion13 = images/ships/shptauda/SHOT_D_13_TGA.bmp
+SpecialExplosion14 = images/ships/shptauda/SHOT_D_14_TGA.bmp
+SpecialExplosion15 = images/ships/shptauda/SHOT_D_15_TGA.bmp
+SpecialExplosion16 = images/ships/shptauda/SHOT_D_16_TGA.bmp
+SpecialExplosion17 = images/ships/shptauda/SHOT_D_17_TGA.bmp
+SpecialExplosion18 = images/ships/shptauda/SHOT_D_18_TGA.bmp
+SpecialExplosion19 = images/ships/shptauda/SHOT_D_19_TGA.bmp
+
+ExtraSprites0 = images/ships/shptauda/SHOT_E_00_TGA.bmp 
+ExtraSprites1 = images/ships/shptauda/SHOT_E_01_TGA.bmp 
+ExtraSprites2 = images/ships/shptauda/SHOT_E_02_TGA.bmp 
+ExtraSprites3 = images/ships/shptauda/SHOT_E_03_TGA.bmp 
+ExtraSprites4 = images/ships/shptauda/SHOT_E_04_TGA.bmp 
+ExtraSprites5 = images/ships/shptauda/SHOT_E_05_TGA.bmp 
+ExtraSprites6 = images/ships/shptauda/SHOT_E_06_TGA.bmp 
+ExtraSprites7 = images/ships/shptauda/SHOT_E_07_TGA.bmp 
+ExtraSprites8 = images/ships/shptauda/SHOT_E_08_TGA.bmp 
+ExtraSprites9 = images/ships/shptauda/SHOT_E_09_TGA.bmp 

Modified: trunk/gamedata/default_ini/ships/shptausl.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shptausl.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shptausl.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -63,3 +63,15 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shptausl/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shptausl/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shptausl/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shptausl/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shptausl/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shptausl/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shptausl/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shptausl/SHIP_S00_BMP.bmp

Modified: trunk/gamedata/default_ini/ships/shptauto.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shptauto.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shptauto.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -72,3 +72,70 @@
 ExtraSamples     = 2
 ExtraExplosion   = 1r
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shptauto/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shptauto/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shptauto/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shptauto/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shptauto/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shptauto/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shptauto/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shptauto/SHIP_S00_BMP.bmp
+
+WeaponSprites0 = images/ships/shptauto/SHOT_A00_BMP.bmp
+WeaponSprites1 = images/ships/shptauto/SHOT_A01_BMP.bmp
+WeaponSprites2 = images/ships/shptauto/SHOT_A02_BMP.bmp
+WeaponSprites3 = images/ships/shptauto/SHOT_A03_BMP.bmp
+WeaponSprites4 = images/ships/shptauto/SHOT_A04_BMP.bmp
+WeaponSprites5 = images/ships/shptauto/SHOT_A05_BMP.bmp
+
+WeaponExplosion0 = images/ships/shptauto/SHOT_B00_BMP.bmp
+WeaponExplosion1 = images/ships/shptauto/SHOT_B01_BMP.bmp
+WeaponExplosion2 = images/ships/shptauto/SHOT_B02_BMP.bmp
+WeaponExplosion3 = images/ships/shptauto/SHOT_B03_BMP.bmp
+WeaponExplosion4 = images/ships/shptauto/SHOT_B04_BMP.bmp
+WeaponExplosion5 = images/ships/shptauto/SHOT_B05_BMP.bmp
+WeaponExplosion6 = images/ships/shptauto/SHOT_B06_BMP.bmp
+WeaponExplosion7 = images/ships/shptauto/SHOT_B07_BMP.bmp
+WeaponExplosion8 = images/ships/shptauto/SHOT_B08_BMP.bmp
+WeaponExplosion9 = images/ships/shptauto/SHOT_B09_BMP.bmp
+WeaponExplosion10 = images/ships/shptauto/SHOT_B10_BMP.bmp
+WeaponExplosion11 = images/ships/shptauto/SHOT_B11_BMP.bmp
+
+SpecialSprites0 = images/ships/shptauto/SHOT_C00_BMP.bmp
+SpecialSprites1 = images/ships/shptauto/SHOT_C01_BMP.bmp
+SpecialSprites2 = images/ships/shptauto/SHOT_C02_BMP.bmp
+SpecialSprites3 = images/ships/shptauto/SHOT_C03_BMP.bmp
+SpecialSprites4 = images/ships/shptauto/SHOT_C04_BMP.bmp
+SpecialSprites5 = images/ships/shptauto/SHOT_C05_BMP.bmp
+
+SpecialExplosion0 = images/ships/shptauto/SHOT_D00_BMP.bmp
+SpecialExplosion1 = images/ships/shptauto/SHOT_D01_BMP.bmp
+SpecialExplosion2 = images/ships/shptauto/SHOT_D02_BMP.bmp
+SpecialExplosion3 = images/ships/shptauto/SHOT_D03_BMP.bmp
+SpecialExplosion4 = images/ships/shptauto/SHOT_D04_BMP.bmp
+SpecialExplosion5 = images/ships/shptauto/SHOT_D05_BMP.bmp
+SpecialExplosion6 = images/ships/shptauto/SHOT_D06_BMP.bmp
+SpecialExplosion7 = images/ships/shptauto/SHOT_D07_BMP.bmp
+SpecialExplosion8 = images/ships/shptauto/SHOT_D08_BMP.bmp
+SpecialExplosion9 = images/ships/shptauto/SHOT_D09_BMP.bmp
+SpecialExplosion10 = images/ships/shptauto/SHOT_D10_BMP.bmp
+SpecialExplosion11 = images/ships/shptauto/SHOT_D11_BMP.bmp
+
+ExtraSprites0 = images/ships/shptauto/SHOT_E0000_BMP.bmp 
+ExtraSprites1 = images/ships/shptauto/SHOT_E0001_BMP.bmp 
+ExtraSprites2 = images/ships/shptauto/SHOT_E0002_BMP.bmp 
+ExtraSprites3 = images/ships/shptauto/SHOT_E0003_BMP.bmp 
+ExtraSprites4 = images/ships/shptauto/SHOT_E0004_BMP.bmp 
+ExtraSprites5 = images/ships/shptauto/SHOT_E0005_BMP.bmp 
+ExtraSprites6 = images/ships/shptauto/SHOT_E0006_BMP.bmp 
+ExtraSprites7 = images/ships/shptauto/SHOT_E0007_BMP.bmp 
+ExtraSprites8 = images/ships/shptauto/SHOT_E0008_BMP.bmp 
+ExtraSprites9 = images/ships/shptauto/SHOT_E0009_BMP.bmp 
+ExtraSprites10 = images/ships/shptauto/SHOT_E0010_BMP.bmp 
+ExtraSprites11 = images/ships/shptauto/SHOT_E0011_BMP.bmp 
+
+ExtraExplosion0 = images/ships/shptauto/SHOT_F00_BMP.bmp

Modified: trunk/gamedata/default_ini/ships/shpthrto.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpthrto.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpthrto.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -79,3 +79,60 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpthrto/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpthrto/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpthrto/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpthrto/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpthrto/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpthrto/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpthrto/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpthrto/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpthrto/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpthrto/SHOT_B02_PCX.bmp
+SpecialSprites1 = images/ships/shpthrto/SHOT_B03_PCX.bmp
+SpecialSprites2 = images/ships/shpthrto/SHOT_B04_PCX.bmp
+SpecialSprites3 = images/ships/shpthrto/SHOT_B05_PCX.bmp
+SpecialSprites4 = images/ships/shpthrto/SHOT_B06_PCX.bmp
+SpecialSprites5 = images/ships/shpthrto/SHOT_B07_PCX.bmp
+SpecialSprites6 = images/ships/shpthrto/SHOT_B08_PCX.bmp
+SpecialSprites7 = images/ships/shpthrto/SHOT_B09_PCX.bmp
+SpecialSprites8 = images/ships/shpthrto/SHOT_B10_PCX.bmp
+SpecialSprites9 = images/ships/shpthrto/SHOT_B11_PCX.bmp
+SpecialSprites10 = images/ships/shpthrto/SHOT_B12_PCX.bmp
+SpecialSprites11 = images/ships/shpthrto/SHOT_B13_PCX.bmp
+SpecialSprites12 = images/ships/shpthrto/SHOT_B14_PCX.bmp
+SpecialSprites13 = images/ships/shpthrto/SHOT_B15_PCX.bmp
+SpecialSprites14 = images/ships/shpthrto/SHOT_B16_PCX.bmp
+SpecialSprites15 = images/ships/shpthrto/SHOT_B17_PCX.bmp
+SpecialSprites16 = images/ships/shpthrto/SHOT_B18_PCX.bmp
+SpecialSprites17 = images/ships/shpthrto/SHOT_B19_PCX.bmp
+SpecialSprites18 = images/ships/shpthrto/SHOT_B20_PCX.bmp
+SpecialSprites19 = images/ships/shpthrto/SHOT_B21_PCX.bmp
+SpecialSprites20 = images/ships/shpthrto/SHOT_B22_PCX.bmp
+SpecialSprites21 = images/ships/shpthrto/SHOT_B23_PCX.bmp
+SpecialSprites22 = images/ships/shpthrto/SHOT_B24_PCX.bmp
+SpecialSprites23 = images/ships/shpthrto/SHOT_B25_PCX.bmp
+SpecialSprites24 = images/ships/shpthrto/SHOT_B26_PCX.bmp
+SpecialSprites25 = images/ships/shpthrto/SHOT_B27_PCX.bmp
+SpecialSprites26 = images/ships/shpthrto/SHOT_B28_PCX.bmp
+SpecialSprites27 = images/ships/shpthrto/SHOT_B29_PCX.bmp
+SpecialSprites28 = images/ships/shpthrto/SHOT_B30_PCX.bmp
+SpecialSprites29 = images/ships/shpthrto/SHOT_B31_PCX.bmp
+SpecialSprites30 = images/ships/shpthrto/SHOT_B32_PCX.bmp
+SpecialSprites31 = images/ships/shpthrto/SHOT_B33_PCX.bmp
+SpecialSprites32 = images/ships/shpthrto/SHOT_B34_PCX.bmp
+SpecialSprites33 = images/ships/shpthrto/SHOT_B35_PCX.bmp
+SpecialSprites34 = images/ships/shpthrto/SHOT_B36_PCX.bmp
+SpecialSprites35 = images/ships/shpthrto/SHOT_B37_PCX.bmp
+SpecialSprites36 = images/ships/shpthrto/SHOT_B38_PCX.bmp
+SpecialSprites37 = images/ships/shpthrto/SHOT_B39_PCX.bmp
+SpecialSprites38 = images/ships/shpthrto/SHOT_B40_PCX.bmp
+
+
+

Modified: trunk/gamedata/default_ini/ships/shpumgdr.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpumgdr.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpumgdr.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -76,3 +76,23 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpumgdr/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpumgdr/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpumgdr/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpumgdr/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpumgdr/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpumgdr/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpumgdr/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpumgdr/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpumgdr/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shpumgdr/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shpumgdr/SHOT_A03_PCX.bmp
+WeaponSprites3 = images/ships/shpumgdr/SHOT_A04_PCX.bmp
+WeaponSprites4 = images/ships/shpumgdr/SHOT_A05_PCX.bmp
+WeaponSprites5 = images/ships/shpumgdr/SHOT_A06_PCX.bmp
+

Modified: trunk/gamedata/default_ini/ships/shputwju.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shputwju.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shputwju.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -73,3 +73,18 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shputwju/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shputwju/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shputwju/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shputwju/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shputwju/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shputwju/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shputwju/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shputwju/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shputwju/SHOT_A01_PCX.bmp
+

Modified: trunk/gamedata/default_ini/ships/shpvuxin.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpvuxin.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpvuxin.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -82,3 +82,36 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpvuxin/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpvuxin/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpvuxin/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpvuxin/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpvuxin/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpvuxin/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpvuxin/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpvuxin/SHIP_S00_PCX.bmp
+
+WeaponSprites0 = images/ships/shpvuxin/SHOT_000_PCX.bmp
+WeaponSprites1 = images/ships/shpvuxin/SHOT_001_PCX.bmp
+WeaponSprites2 = images/ships/shpvuxin/SHOT_002_PCX.bmp
+
+SpecialSprites0 = images/ships/shpvuxin/SHOT_A01_PCX.bmp
+SpecialSprites1 = images/ships/shpvuxin/SHOT_A02_PCX.bmp
+SpecialSprites2 = images/ships/shpvuxin/SHOT_A03_PCX.bmp
+SpecialSprites3 = images/ships/shpvuxin/SHOT_A04_PCX.bmp
+SpecialSprites4 = images/ships/shpvuxin/SHOT_A05_PCX.bmp
+SpecialSprites5 = images/ships/shpvuxin/SHOT_A06_PCX.bmp
+SpecialSprites6 = images/ships/shpvuxin/SHOT_A07_PCX.bmp
+SpecialSprites7 = images/ships/shpvuxin/SHOT_A08_PCX.bmp
+SpecialSprites8 = images/ships/shpvuxin/SHOT_A09_PCX.bmp
+SpecialSprites9 = images/ships/shpvuxin/SHOT_A10_PCX.bmp
+SpecialSprites10 = images/ships/shpvuxin/SHOT_A11_PCX.bmp
+              
+ExtraSprites0  = images/ships/shpvuxin/SHOT_E00_PCX.bmp
+ExtraSprites1  = images/ships/shpvuxin/SHOT_E01_PCX.bmp
+ExtraSprites2  = images/ships/shpvuxin/SHOT_E02_PCS.bmp
+

Modified: trunk/gamedata/default_ini/ships/shpyehte.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpyehte.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpyehte.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -77,3 +77,19 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpyehte/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpyehte/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpyehte/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpyehte/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpyehte/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpyehte/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpyehte/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpyehte/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpyehte/SHOT_A00_BMP.bmp
+
+SpecialSprites0 = images/ships/shpyehte/SHOT_B01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpzeksh.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpzeksh.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpzeksh.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -58,3 +58,29 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0  = images/ships/shpzeksh/SHIP_P00_PCX.bmp
+PanelBitmaps1  = images/ships/shpzeksh/SHIP_P01_PCX.bmp
+PanelBitmaps2  = images/ships/shpzeksh/SHIP_P02_PCX.bmp
+PanelBitmaps3  = images/ships/shpzeksh/SHIP_P03_PCX.bmp
+PanelBitmaps4  = images/ships/shpzeksh/SHIP_P04_PCX.bmp
+PanelBitmaps5  = images/ships/shpzeksh/SHIP_P05_PCX.bmp
+PanelBitmaps6  = images/ships/shpzeksh/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpzeksh/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpzeksh/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shpzeksh/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shpzeksh/SHOT_A03_PCX.bmp
+WeaponSprites3 = images/ships/shpzeksh/SHOT_A04_PCX.bmp
+WeaponSprites4 = images/ships/shpzeksh/SHOT_A05_PCX.bmp
+
+
+SpecialSprites0 = images/ships/shpzeksh/SHOT_B01_PCX.bmp
+SpecialSprites1 = images/ships/shpzeksh/SHOT_B02_PCX.bmp
+SpecialSprites2 = images/ships/shpzeksh/SHOT_B03_PCX.bmp
+SpecialSprites3 = images/ships/shpzeksh/SHOT_B04_PCX.bmp
+SpecialSprites4 = images/ships/shpzeksh/SHOT_B05_PCX.bmp
+SpecialSprites5 = images/ships/shpzeksh/SHOT_B06_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpzfpst.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpzfpst.ini	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/default_ini/ships/shpzfpst.ini	2004-09-25 14:18:41 UTC (rev 61)
@@ -81,3 +81,29 @@
 ExtraSamples     = 0
 ExtraExplosion   = 0
 PanelBitmaps     = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpzfpst/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpzfpst/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpzfpst/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpzfpst/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpzfpst/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpzfpst/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpzfpst/SHIP_P06_PCX.bmp
+
+ShipSprites0 = images/ships/shpzfpst/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpzfpst/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shpzfpst/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shpzfpst/SHOT_A03_PCX.bmp
+WeaponSprites3 = images/ships/shpzfpst/SHOT_A04_PCX.bmp
+WeaponSprites4 = images/ships/shpzfpst/SHOT_A05_PCX.bmp
+WeaponSprites5 = images/ships/shpzfpst/SHOT_A06_PCX.bmp
+
+SpecialSprites0 = images/ships/shpzfpst/SHOT_B01_PCX.bmp
+SpecialSprites1 = images/ships/shpzfpst/SHOT_B02_PCX.bmp
+SpecialSprites2 = images/ships/shpzfpst/SHOT_B03_PCX.bmp
+SpecialSprites3 = images/ships/shpzfpst/SHOT_B04_PCX.bmp
+SpecialSprites4 = images/ships/shpzfpst/SHOT_B05_PCX.bmp
+SpecialSprites5 = images/ships/shpzfpst/SHOT_B06_PCX.bmp
+

Modified: trunk/gamedata/ships/COPYING.txt
===================================================================
--- trunk/gamedata/ships/COPYING.txt	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/gamedata/ships/COPYING.txt	2004-09-25 14:18:41 UTC (rev 61)
@@ -1,370 +1,370 @@
-    Some contents text files may contain content from Ultronomicon (http://uqm.stack.nl/wiki/)
-    
-    Some contents data files may contain content from The Ur-Quan Masters project.
-    Used by permission from Toys For Bob.  The UQM license appears below.
-
-----------------------------------------------------------------------------
-    The Ur-Quan Masters
-    Copyright (C) 1992, 2002 Toys for Bob, Inc.
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be entertaining,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.  A copy of the
-    General Public License is included at the end of this document.
-
-    The content -- voiceovers, dialogue, graphics, and music -- are
-    copyright (C) 1992, 1993, 2002 Toys for Bob, Inc. or their
-    respective creators.  The content may be copied freely as part of
-    a distribution of The Ur-Quan Masters.  All other rights are reserved.
-
-    (Side Note: The content will become more freely redistributable
-     and reusable in later releases.)
-
-----------------------------------------------------------------------------
-
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year  name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.
+    Some contents text files may contain content from Ultronomicon (http://uqm.stack.nl/wiki/)
+    
+    Some contents data files may contain content from The Ur-Quan Masters project.
+    Used by permission from Toys For Bob.  The UQM license appears below.
+
+----------------------------------------------------------------------------
+    The Ur-Quan Masters
+    Copyright (C) 1992, 2002 Toys for Bob, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be entertaining,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.  A copy of the
+    General Public License is included at the end of this document.
+
+    The content -- voiceovers, dialogue, graphics, and music -- are
+    copyright (C) 1992, 1993, 2002 Toys for Bob, Inc. or their
+    respective creators.  The content may be copied freely as part of
+    a distribution of The Ur-Quan Masters.  All other rights are reserved.
+
+    (Side Note: The content will become more freely redistributable
+     and reusable in later releases.)
+
+----------------------------------------------------------------------------
+
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.

Deleted: trunk/gamedata/ships/shpalabc.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpandgu.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shparisk.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpbahbu.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpbipka.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpchebr.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpchmav.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpchoex.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpconca.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpconho.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpdragr.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpdruma.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpearc3.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpearcr.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpforsh.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpgarty.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpilwav.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpilwsp.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpkahbo.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpkohma.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpkzedr.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpmeltr.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpmmrxf.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpmycpo.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shporzne.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shppkufu.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shprogsq.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpshosc.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpslypr.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpspael.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpstaba.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpsupbl.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpsyrpe.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shptauar.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shptauda.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shptausl.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shptauto.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpthrto.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpumgdr.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shputwju.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpvuxin.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpyehte.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpzeksh.dat
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/ships/shpzfpst.dat
===================================================================
(Binary files differ)

Modified: trunk/source/ais/c_input.cpp
===================================================================
--- trunk/source/ais/c_input.cpp	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/source/ais/c_input.cpp	2004-09-25 14:18:41 UTC (rev 61)
@@ -37,54 +37,65 @@
 
 
 
-int my_bitmap_proc( int msg, DIALOG* d, int c ){
-	if( msg == MSG_END && d->dp ){
-		destroy_bitmap( (BITMAP*)d->dp );
-		d->dp = NULL;
-	}
+int my_bitmap_proc( int msg, DIALOG* d, int c )
+{
+  if( msg == MSG_END && d->dp )
+    {
+      destroy_bitmap( (BITMAP*)d->dp );
+      d->dp = NULL;
+    }
 
-	if( msg != MSG_DRAW || d->dp ) return d_bitmap_proc( msg, d, c );
-	return D_O_K;
+  if( msg != MSG_DRAW || d->dp ) 
+    return d_bitmap_proc( msg, d, c );
+  return D_O_K;
 }
 
-int my_list_proc( int msg, DIALOG* d, int c ){
-	int old_d1 = d->d1;
-	Fleet *fleet = (Fleet*)d->dp3;
-	int ret = d_list_proc2( msg, d, c );
-	if( d->d1 != old_d1 || msg == MSG_START ){
-		ShipType* type = fleet->getShipType(d->d1);
+int my_list_proc( int msg, DIALOG* d, int c )
+{
+  int old_d1 = d->d1;
+  Fleet *fleet = (Fleet*)d->dp3;
+  int ret = d_list_proc2( msg, d, c );
+  if( d->d1 != old_d1 || msg == MSG_START )
+    {
+      ShipType* type = fleet->getShipType(d->d1);
+      
+      ASSERT(type != NULL);
 
-        ASSERT(type != NULL);
+      selectDialog[SELECT_DIALOG_TITLE].flags |= D_DIRTY;
+      sprintf(selectTitleString, "%s\n%s\n%d of %d points", 
+	      selectShipPrompt,
+	      (type != NULL) ? type->name : 0,
+	      (type != NULL) ? type->cost : 0,
+	      fleet->getCost());
+      
+      tw_set_config_file(type->data->ini);
 
-        selectDialog[SELECT_DIALOG_TITLE].flags |= D_DIRTY;
-        sprintf(selectTitleString, "%s\n%s\n%d of %d points", 
-            selectShipPrompt,
-            (type != NULL) ? type->name : 0,
-            (type != NULL) ? type->cost : 0,
-            fleet->getCost());
-
-		BITMAP* panel = NULL;
-		DATAFILE* data = load_datafile_object( type->data->file.c_str(), "SHIP_P00_PCX" );
-
-		if( data ){
-			BITMAP* bmp = (BITMAP*)data->dat;
-			panel = create_bitmap_ex( bitmap_color_depth(screen), bmp->w, bmp->h );
-			blit( bmp, panel, 0, 0, 0, 0, bmp->w, bmp->h );
-			unload_datafile_object( data );
-			data = load_datafile_object( type->data->file.c_str(), "SHIP_P01_PCX" );
-			bmp = (BITMAP*)data->dat;
-			blit( bmp, panel, 0, 0, 4, 65, bmp->w, bmp->h );
-			unload_datafile_object( data );
-			color_correct_bitmap( panel, 0 );
-		}
-
-		if( selectDialog[SELECT_DIALOG_PIC].dp ) destroy_bitmap( (BITMAP*)selectDialog[SELECT_DIALOG_PIC].dp );
-		selectDialog[SELECT_DIALOG_PIC].dp = panel;
-		scare_mouse();
-		SEND_MESSAGE( &selectDialog[SELECT_DIALOG_PIC], MSG_DRAW, 0 );
-		unscare_mouse();
+      BITMAP* panel = load_bitmap(data_full_path(get_config_string("Graphic", 
+								   "PanelBitmaps0", 
+								   "")).c_str(), NULL);
+      if(panel)
+	{
+	  BITMAP* bmp = load_bitmap(data_full_path(get_config_string("Graphic", 
+								     "PanelBitmaps1", 
+								     "")).c_str(), NULL);
+	  blit( bmp, panel, 0, 0, 4, 65, bmp->w, bmp->h );
+	  destroy_bitmap(bmp);
+	  color_correct_bitmap( panel, 0 );
 	}
-	return ret;
+      else
+	{
+	  tw_error("Unable to load ship pannel!!\n%s", 
+		   data_full_path(get_config_string("Graphic", "PanelBitmaps0", "")).c_str());
+	}
+      
+      if( selectDialog[SELECT_DIALOG_PIC].dp ) 
+	destroy_bitmap( (BITMAP*)selectDialog[SELECT_DIALOG_PIC].dp );
+      selectDialog[SELECT_DIALOG_PIC].dp = panel;
+      scare_mouse();
+      SEND_MESSAGE( &selectDialog[SELECT_DIALOG_PIC], MSG_DRAW, 0 );
+      unscare_mouse();
+    }
+  return ret;
 }
 
 void calibrate_joysticks() 

Modified: trunk/source/melee/mmain.cpp
===================================================================
--- trunk/source/melee/mmain.cpp	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/source/melee/mmain.cpp	2004-09-25 14:18:41 UTC (rev 61)
@@ -513,7 +513,7 @@
     {
       if (slot[i] == -2) continue;
       sprintf (tmp, "Player%d", i+1);
-      //fleet->load("./fleets.tmp", tmp);
+
       Fleet *fleet = player_fleet[i];
       if (slot[i] == -1) slot[i] = random() % fleet->getSize();
       if (slot[i] < 0 || slot[i] >= fleet->getSize()) {tw_error("trying to load invalid ship");}
@@ -543,20 +543,20 @@
       // CHECK FILE SIZES !! to intercept desynch before they happen.
       int myfsize, otherfsize;
       
-		myfsize = file_size(s->type->data->file.c_str());
-		otherfsize = myfsize;
-		if (player_control[i]->channel != channel_none) 
-		  {
-		    log_int(player_control[i]->channel, otherfsize);
-		  }
+      myfsize = 0;
+      otherfsize = myfsize;
+      if (player_control[i]->channel != channel_none) 
+	{
+	  log_int(player_control[i]->channel, otherfsize);
+	}
+      
+      if (otherfsize != myfsize)
+	{
+	  // the player who loads the ship doesn't get this message, cause his own file is identical by default
+	  tw_error("DAT files have different size! This may cause a desynch. Press Retry to continue");
+	}
 		
-		if (otherfsize != myfsize)
-		  {
-			// the player who loads the ship doesn't get this message, cause his own file is identical by default
-		    tw_error("DAT files have different size! This may cause a desynch. Press Retry to continue");
-		  }
 		
-		
     }
   delete[] slot;
   //message.out("Finished selecting ships...", 1500);

Modified: trunk/source/melee/mship.cpp
===================================================================
--- trunk/source/melee/mship.cpp	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/source/melee/mship.cpp	2004-09-25 14:18:41 UTC (rev 61)
@@ -1,7 +1,7 @@
 /* $Id: mship.cpp,v 1.2 2004/08/08 17:36:06 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -43,37 +43,41 @@
 ShipClass *shipclasses = NULL;
 
 void register_shipclass (
-	const char *name, 
-	const char *source_name, 
-	Ship *(*func)(Vector2 pos, double a, ShipData *data, unsigned int code)
-) 
+			 const char *name, 
+			 const char *source_name, 
+			 Ship *(*func)(Vector2 pos, double a, ShipData *data, unsigned int code)
+			 ) 
 {
-	num_shipclasses += 1;
-	shipclasses = (ShipClass*)realloc(shipclasses, num_shipclasses * sizeof(ShipClass));
-	int i = num_shipclasses-1;
-	shipclasses[i].link_order = i;
-	shipclasses[i].name = name;
-	shipclasses[i].source = source_name;
-	shipclasses[i]._get_ship = func;
-	return;
+  num_shipclasses += 1;
+  shipclasses = (ShipClass*)realloc(shipclasses, num_shipclasses * sizeof(ShipClass));
+  int i = num_shipclasses-1;
+  shipclasses[i].link_order = i;
+  shipclasses[i].name = name;
+  shipclasses[i].source = source_name;
+  shipclasses[i]._get_ship = func;
+  return;
 }
 
 Ship *ShipClass::get_ship(Vector2 pos, double angle, ShipData *dat, unsigned int team) {
   STACKTRACE;
-	dat->lock();
-	Ship *s = _get_ship(pos, angle, dat, team);
-	dat->unlock();
-	s->code = this;
-	return s;
+  dat->lock();
+  Ship *s = _get_ship(pos, angle, dat, team);
+  dat->unlock();
+  s->code = this;
+  return s;
 }
 
-ShipClass *shipclass ( const char *name ) {
-	int i;
-	if (!name) return NULL;
-	for (i = 0; i < num_shipclasses; i += 1) {
-		if (!strcmp(shipclasses[i].name, name)) return &shipclasses[i];
-	}
-	return NULL;
+ShipClass *shipclass ( const char *name ) 
+{
+  int i;
+  if (!name) 
+    return NULL;
+  for (i = 0; i < num_shipclasses; i += 1) 
+    {
+      if (!strcmp(shipclasses[i].name, name)) 
+	return &shipclasses[i];
+    }
+  return NULL;
 }
 
 
@@ -86,34 +90,41 @@
 ShipType *shiptypes = NULL;
 
 
-Ship *ShipType::get_ship(Vector2 pos, double angle, unsigned int team) {
+Ship *ShipType::get_ship(Vector2 pos, double angle, unsigned int team) 
+{
   STACKTRACE;
-	game->log_file(file);
-	Ship *s = code->get_ship(pos, angle, data, team);
-	s->type = this;
-	return s;
+  game->log_file(file);
+  Ship *s = code->get_ship(pos, angle, data, team);
+  s->type = this;
+  return s;
 }
 
-ShipType *shiptype(const char *shiptype_id) {
-	int i;
-	for (i = 0; i < num_shiptypes; i += 1) {
-		if (!strcmp(shiptype_id, shiptypes[i].id)) {
-			return &shiptypes[i];
-		}
+ShipType *shiptype(const char *shiptype_id) 
+{
+  int i;
+  for (i = 0; i < num_shiptypes; i += 1) 
+    {
+      if (!strcmp(shiptype_id, shiptypes[i].id)) 
+	{
+	  return &shiptypes[i];
 	}
-	return NULL;
+    }
+  return NULL;
 }
 
-const char *old_code_name( const char *file ) {
-	char buffy[2048];
-	if (strlen(file) != 18) return NULL;
-	strncpy(buffy, file+9, 5);
-	buffy[5] = 0;
-	int i;
-	for (i = 0; i < num_shipclasses; i += 1) {
-		if (strstr(shipclasses[i].source, buffy)) return shipclasses[i].name;
-	}
-	return NULL;
+const char *old_code_name( const char *file ) 
+{
+  char buffy[2048];
+  if (strlen(file) != 18) 
+    return NULL;
+  strncpy(buffy, file+9, 5);
+  buffy[5] = 0;
+  int i;
+  for (i = 0; i < num_shipclasses; i += 1) 
+    {
+      if (strstr(shipclasses[i].source, buffy)) return shipclasses[i].name;
+    }
+  return NULL;
 }
 
 static void register_shiptype ( const char *file ) 
@@ -129,7 +140,8 @@
   char buffy[1024];
   strncpy(buffy, file, 1000);
   char *tmp = strrchr(buffy, '.');
-  if (!tmp || (tmp - buffy < 5)) tw_error("bad ship file name (%s)", file);
+  if (!tmp || (tmp - buffy < 5)) 
+    tw_error("bad ship file name (%s)", file);
   *tmp = 0;
   shiptypes[i].id = strdup(tmp - 5);
   
@@ -147,37 +159,36 @@
   
 
   const char *name = get_config_string("Info", "Name", NULL);
-  if (!name) {
-    const char *tmp;
-    int l = 0;
-    tmp = get_config_string("Info", "Name0", NULL);
-    if (tmp) {
-      l += sprintf(buffy + l, "%s ", tmp);
+  if (!name) 
+    {
+      const char *tmp;
+      int l = 0;
+      tmp = get_config_string("Info", "Name0", NULL);
+      if (tmp) 
+	{
+	  l += sprintf(buffy + l, "%s ", tmp);
+	}
+      tmp = get_config_string("Info", "Name1", NULL);
+      if (!tmp)
+	tw_error("init_ships - error initializing name (%s)", file);
+      l += sprintf(buffy + l, "%s", tmp);
+      int n = 1;
+      while (true) 
+	{
+	  char buf[25];
+	  n += 1;
+	  sprintf(buf, "Name%d", n);
+	  tmp = get_config_string("Info", buf, NULL);
+	  if (!tmp) 
+	    break;
+	  l += sprintf(buffy + l, " %s", tmp);
+	}
+      name = buffy;
     }
-    tmp = get_config_string("Info", "Name1", NULL);
-    if (!tmp)
-      tw_error("init_ships - error initializing name (%s)", file);
-    l += sprintf(buffy + l, "%s", tmp);
-    int n = 1;
-    while (true) {
-      char buf[25];
-      n += 1;
-      sprintf(buf, "Name%d", n);
-      tmp = get_config_string("Info", buf, NULL);
-      if (!tmp) break;
-      l += sprintf(buffy + l, " %s", tmp);
-    }
-    name = buffy;
-  }
   shiptypes[i].name = strdup(name);
   shiptypes[i].cost = get_config_int("Info", "TWCost", 0);
-  const char *data = get_config_string("Info", "Data", NULL);
-  if (!data) {
-    replace_extension(buffy, ini_path.c_str(), "dat", 2040);
-    shiptypes[i].data = shipdata(data_full_path(buffy), ini_path );
-  }
-  else 
-    shiptypes[i].data = shipdata(data, ini_path);
+  shiptypes[i].data = shipdata( ini_path );
+  
   const char *text = get_config_string("Info", "Description", NULL);
   if (!text) 
     {
@@ -191,19 +202,20 @@
   shiptypes[i].code = shipclass(code);
   if (!shiptypes[i].data || !shiptypes[i].code) 
     {
-      if (!data) data = "none";
-      if (!code) code = "none";
+      if (!code) 
+	code = "none";
       char buffy[2048];
       char *tmp = buffy;
       tmp += sprintf(tmp, "Ship registration failed\n%s (%s)\n",
 		     shiptypes[i].name, shiptypes[i].file);
-      if (!shiptypes[i].data) tmp += sprintf(tmp, "Data not found (%s)\n", data);
-      if (!shiptypes[i].code) tmp += sprintf(tmp, "Code not found (%s)\n", code);
+      if (!shiptypes[i].code) 
+	tmp += sprintf(tmp, "Code not found (%s)\n", code);
       tw_error(buffy);
       num_shiptypes -= 1;
       return;
     }
-  if (old) set_config_string("Info", "Code", code);
+  if (old) 
+    set_config_string("Info", "Code", code);
   
   return;
   

Modified: trunk/source/melee/mship.h
===================================================================
--- trunk/source/melee/mship.h	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/source/melee/mship.h	2004-09-25 14:18:41 UTC (rev 61)
@@ -23,50 +23,52 @@
 
 typedef short KeyCode;
 
-struct keyflag {
-	enum { 
-		left       =	(1<<0),
-		right      =	(1<<1),
-		thrust     =	(1<<2),
-		back       =	(1<<3),
-		fire       =	(1<<4),
-		special    =	(1<<5),
-		altfire    =	(1<<6),
-		next       =	(1<<7),
-		prev       =	(1<<8),
-		closest    =	(1<<9),
-		extra1     =   (1<<10),
-		extra2     =   (1<<11),
-		extra3     =   (1<<12),
-		extra4     =   (1<<13),
-		extra5     =   (1<<14),
-		suicide    =   (1<<15),
-		};
-	};
+struct keyflag 
+{
+  enum { 
+    left       =	(1<<0),
+    right      =	(1<<1),
+    thrust     =	(1<<2),
+    back       =	(1<<3),
+    fire       =	(1<<4),
+    special    =	(1<<5),
+    altfire    =	(1<<6),
+    next       =	(1<<7),
+    prev       =	(1<<8),
+    closest    =	(1<<9),
+    extra1     =   (1<<10),
+    extra2     =   (1<<11),
+    extra3     =   (1<<12),
+    extra4     =   (1<<13),
+    extra5     =   (1<<14),
+    suicide    =   (1<<15),
+  };
+};
 
-class Phaser : public SpaceObject {
-	protected:
-	Vector2 rel_pos;
-	Ship *ship;
-	int sprite_index;
-	int *colors;
-	int num_colors;
-	int color_index;
-	int frame_size;
-	int frame_step;
-	int phaser_step_position;
-	int phaser_steps;
-	int phaser_step_size;
+class Phaser : public SpaceObject 
+{
+ protected:
+  Vector2 rel_pos;
+  Ship *ship;
+  int sprite_index;
+  int *colors;
+  int num_colors;
+  int color_index;
+  int frame_size;
+  int frame_step;
+  int phaser_step_position;
+  int phaser_steps;
+  int phaser_step_size;
+  
+ public:
+  Phaser::Phaser(SpaceLocation *creator, Vector2 pos, Vector2 rel_pos, 
+		 Ship *ship, SpaceSprite *sprite, int osprite_index, int *ocolors, 
+		 int onum_colors, int ofsize, int steps, int step_time) ;
+  
+  virtual void animate(Frame *space);
+  virtual void calculate();
+};
 
-	public:
-	Phaser::Phaser(SpaceLocation *creator, Vector2 pos, Vector2 rel_pos, 
-		Ship *ship, SpaceSprite *sprite, int osprite_index, int *ocolors, 
-		int onum_colors, int ofsize, int steps, int step_time) ;
-
-	virtual void animate(Frame *space);
-	virtual void calculate();
-	};
-
 /** the classification of where a given ship comes from */
 enum ShipOrigin { 
     SHIP_ORIGIN_NONE = 0, /**< None, no classification given*/
@@ -76,107 +78,108 @@
 };
 
 /// \brief Exactly what is sounds like
-class Ship : public SpaceObject {
-	protected:
+class Ship : public SpaceObject 
+{
+ protected:
+  
+  int hotspot_frame;
+  int recharge_step;
+  int weapon_recharge;
+  int weapon_low;
+  int special_recharge;
+  int special_low;
+  
+  virtual void calculate_thrust();
+  virtual void calculate_turn_left();
+  virtual void calculate_turn_right();
+  virtual void calculate_fire_weapon();
+  virtual void calculate_fire_special();
+  virtual void calculate_hotspots();
 
-	int hotspot_frame;
-	int recharge_step;
-	int weapon_recharge;
-	int weapon_low;
-	int special_recharge;
-	int special_low;
-
-	virtual void calculate_thrust();
-	virtual void calculate_turn_left();
-	virtual void calculate_turn_right();
-	virtual void calculate_fire_weapon();
-	virtual void calculate_fire_special();
-	virtual void calculate_hotspots();
-
-	virtual int activate_weapon();
-	virtual int activate_special();
-
-	virtual double get_angle_ex() const; // stupid helper for camera
-
-	public:
-	ShipType *type;
-	virtual ShipType *get_shiptype();
-
-	ShipClass *code;
-
-	int death_counter;
-	int death_explosion_counter;
-
-	bool hashotspots;
-	virtual void assigntarget(SpaceObject *otarget);
-
-	virtual void materialize();
-	double crew;
-	double crew_max;
-	double batt;
-	double batt_max;
-	double turn_rate;
-	double turn_step;
-	double speed_max;
-	double accel_rate;
-	int    recharge_amount;
-	int    recharge_rate;
-	int    weapon_drain;
-	int    weapon_rate;
-	int    weapon_sample;
-	int    special_drain;
-	int    special_rate;
-	int    special_sample;
-	int    hotspot_rate;
-	char   captain_name[16];
-
-	SpaceSprite *spritePanel;
-
-	int update_panel;
-
-	KeyCode nextkeys;
-
-	char thrust;
-	char thrust_backwards;
-	char turn_left;
-	char turn_right;
-	char fire_weapon;
-	char fire_special;
-	char fire_altweapon;
-	char target_next;
-	char target_prev;
-	char target_closest;
-
-	char target_pressed;
-	Control *control;
-
-	friend class ShipPanel;
-
-	Ship(SpaceLocation *creator, Vector2 opos, double shipAngle, 
-			SpaceSprite *osprite) ;
-	Ship(Vector2 opos, double shipAngle, ShipData *shipData, 
-			unsigned int code);
-	virtual SpaceLocation *get_ship_phaser() ;
-	virtual ~Ship();
-	virtual void death();
-
-
-	virtual double getCrew();
-	virtual double getBatt();
-
-	virtual RGB crewPanelColor(int k = 0);
-	virtual RGB battPanelColor(int k = 0);
-	virtual bool custom_panel_update(BITMAP *panel, int display_type) {return false;};
-
-
-	void locate();
-
-	void calculate();
-	virtual int handle_damage(SpaceLocation *source, double normal, double direct = 0);
-	virtual int handle_fuel_sap(SpaceLocation *source, double normal);
-	virtual double handle_speed_loss(SpaceLocation *source, double normal);
-
-	virtual void animate(Frame *frame);
+  virtual int activate_weapon();
+  virtual int activate_special();
+  
+  virtual double get_angle_ex() const; ///< stupid helper for camera
+  
+ public:
+  ShipType *type;
+  virtual ShipType *get_shiptype();
+  
+  ShipClass *code;
+  
+  int death_counter;
+  int death_explosion_counter;
+  
+  bool hashotspots;
+  virtual void assigntarget(SpaceObject *otarget);
+  
+  virtual void materialize();
+  double crew;
+  double crew_max;
+  double batt;
+  double batt_max;
+  double turn_rate;
+  double turn_step;
+  double speed_max;
+  double accel_rate;
+  int    recharge_amount;
+  int    recharge_rate;
+  int    weapon_drain;
+  int    weapon_rate;
+  int    weapon_sample;
+  int    special_drain;
+  int    special_rate;
+  int    special_sample;
+  int    hotspot_rate;
+  char   captain_name[16];
+  
+  SpaceSprite *spritePanel;
+  
+  int update_panel;
+  
+  KeyCode nextkeys;
+  
+  char thrust;
+  char thrust_backwards;
+  char turn_left;
+  char turn_right;
+  char fire_weapon;
+  char fire_special;
+  char fire_altweapon;
+  char target_next;
+  char target_prev;
+  char target_closest;
+  
+  char target_pressed;
+  Control *control;
+  
+  friend class ShipPanel;
+  
+  Ship(SpaceLocation *creator, Vector2 opos, double shipAngle, 
+       SpaceSprite *osprite) ;
+  Ship(Vector2 opos, double shipAngle, ShipData *shipData, 
+       unsigned int code);
+  virtual SpaceLocation *get_ship_phaser() ;
+  virtual ~Ship();
+  virtual void death();
+  
+  
+  virtual double getCrew();
+  virtual double getBatt();
+  
+  virtual RGB crewPanelColor(int k = 0);
+  virtual RGB battPanelColor(int k = 0);
+  virtual bool custom_panel_update(BITMAP *panel, int display_type) {return false;};
+  
+  
+  void locate();
+  
+  void calculate();
+  virtual int handle_damage(SpaceLocation *source, double normal, double direct = 0);
+  virtual int handle_fuel_sap(SpaceLocation *source, double normal);
+  virtual double handle_speed_loss(SpaceLocation *source, double normal);
+  
+  virtual void animate(Frame *frame);
 };
 
 

Modified: trunk/source/melee/mshpdata.cpp
===================================================================
--- trunk/source/melee/mshpdata.cpp	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/source/melee/mshpdata.cpp	2004-09-25 14:18:41 UTC (rev 61)
@@ -42,21 +42,21 @@
 typedef std::map<std::string, ShipData*> ShipDataMap;
 ShipDataMap shipdatas;
 
-ShipData *shipdata ( std::string file, std::string inifile ) 
+/// Allocate ship data resources, or return already loaded ones
+ShipData *shipdata ( std::string inifile ) 
 {
-  if (file.empty() || inifile.empty()) 
+  if ( inifile.empty()) 
     return NULL;
 	
-  ShipDataMap::iterator shp = shipdatas.find(file);
+  ShipDataMap::iterator shp = shipdatas.find(inifile);
   if(shp!=shipdatas.end())
     return (*shp).second;
   
-  if (!exists(file.c_str())) 
-    return NULL;
-  ShipData *data = new ShipData(file, inifile);
-  shipdatas[file] = data;
+  ShipData *data = new ShipData( inifile);
+  shipdatas[inifile] = data;
   return data;
 }
+
 void save_spacesprite2(SpaceSprite *ss, const char *spritename, 
 		       const char *destination, const char *extension) 
 {
@@ -188,18 +188,17 @@
   if (num_more_sprites) 
     {
       int i;
-      for (i = 0; i < num_more_sprites; i += 1) delete more_sprites[i];
+      for (i = 0; i < num_more_sprites; i += 1) 
+	delete more_sprites[i];
       delete[] more_sprites;
       more_sprites = NULL;
       num_more_sprites = 0;
     }
   
-  //  unload_datafile(data);
-  
   status = LOADED_NONE;
 }
 
-ShipData::ShipData(std::string filename, std::string inifile) :
+ShipData::ShipData( std::string inifile) :
   spriteShip(NULL),
   spriteWeapon(NULL),
   spriteWeaponExplosion(NULL),
@@ -209,47 +208,56 @@
   spriteExtraExplosion(NULL)
 {
   STACKTRACE;
-  file = filename;
   ini  = inifile;
   references = 0;
   status = LOADED_NONE;
 }
 
 
-SpaceSprite *load_sprite(const char *string, DATAFILE *data, int *index) 
+SpaceSprite *load_sprite(const char *string ) 
 {
-	char buffy[512]; buffy[0] = 0;
-	char *cp = buffy;
-	char *tp;
-	int argc, i;
-	int rotations = 1;
-	char **argv = get_config_argv("Objects", string, &argc);
-	int count = 0;
-	if (!argc) return NULL;
-	count = atoi(argv[0]);
-	if (!count) return NULL;
-	tp = strchr(argv[0], 'r');
-	for (i = 1; i < argc; i += 1) {
-		if ((argv[i][0] == '-') || (argv[i][0] == '+')) {
-			cp += sprintf(cp, "%s ", argv[i]);
-		}
-		else if (argv[i][0] == 'r') tp = argv[i];
-		else {tw_error("load_sprite - unrecognized modifiers '%s'", argv[i]);}
-	}
-	if (tp) {
-		rotations = atoi(tp+1);
-		if (rotations == 0) rotations = 64;
-	}
-	SpaceSprite *sprite = NULL;
-	int attrib = string_to_sprite_attributes(buffy);
-	sprite = new SpaceSprite(&data[*index], count, attrib, rotations);
-	for (i = 0; i < count; i += 1) {
-	  destroy_rle_sprite((RLE_SPRITE*)data[(*index)+i].dat);
-	  data[(*index)+i].dat = NULL;
-		// brutal hack to free up the memory
-	}
-	*index += count;
-	return sprite;
+  char buffy[512]; buffy[0] = 0;
+  char *cp = buffy;
+  char *tp;
+  int argc, i;
+  int rotations = 1;
+  char **argv = get_config_argv("Objects", string, &argc);
+  int count = 0;
+  if (!argc) 
+    return NULL;
+  count = atoi(argv[0]);
+  if (!count) 
+    return NULL;
+  tp = strchr(argv[0], 'r');
+  for (i = 1; i < argc; i += 1) {
+    if ((argv[i][0] == '-') || (argv[i][0] == '+')) {
+      cp += sprintf(cp, "%s ", argv[i]);
+    }
+    else if (argv[i][0] == 'r') tp = argv[i];
+    else {tw_error("load_sprite - unrecognized modifiers '%s'", argv[i]);}
+  }
+  if (tp) 
+    {
+      rotations = atoi(tp+1);
+      if (rotations == 0) 
+	rotations = 64;
+    }
+  SpaceSprite *sprite = NULL;
+  int attrib = string_to_sprite_attributes(buffy);
+  
+  std::vector<std::string> tmpVec;
+
+  for(i = 0; i < count; i++) 
+    {
+      char tmp[200] = {0};
+      sprintf(tmp, "%d", i);
+      tmpVec.push_back( get_config_string("Graphic", 
+					  (std::string(string) + tmp).c_str(),
+					  ""));
+    }
+  
+  sprite = new SpaceSprite(tmpVec, count, attrib, rotations);
+  return sprite;
 }
 
 void ShipData::load() 
@@ -260,45 +268,45 @@
   if (status != LOADED_NONE) 
     return;
   
-  DATAFILE * data = load_datafile(file.c_str());
-  
-  if(!data)
-    {
-      tw_error("Error loading '%s'", file.c_str());
-    }
+  tw_set_config_file(ini);
 
-  set_config_data((char *)(data[index].dat), data[index].size);
-  
   int num_panel_bitmaps = get_config_int("Objects", "PanelBitmaps", 0);
-  
-  index++;
-  
   // load ship panel
   if (num_panel_bitmaps < 2)
     tw_error("Too few ship panel bitmaps");
-  spritePanel = new SpaceSprite(&data[index], num_panel_bitmaps, SpaceSprite::IRREGULAR);
-  index += num_panel_bitmaps;
-  
+
+  std::vector<std::string> tmpVec;
+  for(i = 0; i < num_panel_bitmaps; i++) 
+    {
+      char tmp[200] = {0};
+      sprintf(tmp, "%d", i);
+      tmpVec.push_back( get_config_string("Graphic", 
+					  (std::string("PanelBitmaps") + tmp).c_str(),
+					  ""));
+    }
+  spritePanel = new SpaceSprite(tmpVec, num_panel_bitmaps, SpaceSprite::IRREGULAR);
+  tmpVec.clear();
+  //  tw_error("!!");
   // load ship sprites
-  spriteShip = load_sprite("ShipSprites", data, &index);
-  
+  spriteShip = load_sprite("ShipSprites"); 
+
   // load weapon sprites
-  spriteWeapon = load_sprite("WeaponSprites", data, &index);
+  spriteWeapon = load_sprite("WeaponSprites");
 
   // load weapon explosion sprites
-  spriteWeaponExplosion = load_sprite("WeaponExplosion", data, &index);
+  spriteWeaponExplosion = load_sprite("WeaponExplosion");
 
   // load special ability sprites
-  spriteSpecial = load_sprite("SpecialSprites", data, &index);
+  spriteSpecial = load_sprite("SpecialSprites");
   
   // load special ability explosion sprites
-  spriteSpecialExplosion = load_sprite("SpecialExplosion", data, &index);
+  spriteSpecialExplosion = load_sprite("SpecialExplosion");
   
   // load extra sprites
-  spriteExtra = load_sprite("ExtraSprites", data, &index);
+  spriteExtra = load_sprite("ExtraSprites");
   
   // load extra explosion sprites
-  spriteExtraExplosion = load_sprite("ExtraExplosion", data, &index);
+  spriteExtraExplosion = load_sprite("ExtraExplosion");
   
   //load optional super-extra sprites
   i = 0;
@@ -306,16 +314,18 @@
   while (true) 
     {
       char buffy[512];
-      sprintf(buffy, "ExtraExtraSprites%d", i);
-      if (get_config_int("Objects", buffy, -1) == -1) break;
+      sprintf(buffy, "ExtraExtraSprites%d_", i);
+      if (get_config_int("Objects", buffy, -1) == -1) 
+	break;
+      
+      //tw_error("SSS");
       more_sprites = (SpaceSprite**) realloc(more_sprites, (i+1) * sizeof(SpaceSprite*));
-      more_sprites[i] = load_sprite(buffy, data, &index);
+      more_sprites[i] = load_sprite(buffy);
       i += 1;
     }
   num_more_sprites = i;
   
   // initialize ship victory ditty
-  tw_set_config_file(ini);
   moduleVictory = get_config_string("Music", "Victory", "");
   index++;
   
@@ -354,7 +364,6 @@
   
   status = LOADED_FULL;
 
-  unload_datafile(data);  
   return;  
 }
 

Modified: trunk/source/melee/msprite.cpp
===================================================================
--- trunk/source/melee/msprite.cpp	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/source/melee/msprite.cpp	2004-09-25 14:18:41 UTC (rev 61)
@@ -642,8 +642,7 @@
 
 
 
-SpaceSprite::SpaceSprite(std::vector<std::string> bmplist, int sprite_count, 
-			 int rotations, int _attributes)
+SpaceSprite::SpaceSprite(std::vector<std::string> bmplist, int sprite_count, int _attributes, int rotations)
 {
   STACKTRACE;
   int i, j, obpp=0;
@@ -679,7 +678,10 @@
     bpp = 0;
   
   
-  tmp2 = load_bitmap(bmplist[0].c_str(), NULL);
+  tmp2 = load_bitmap(data_full_path(bmplist[0]).c_str(), NULL);
+  if(!tmp2)
+    tw_error("Unable to load bitmap: %s", data_full_path(bmplist[0]).c_str());
+
   w = tmp2->w;
   h = tmp2->h;
   obpp = bitmap_color_depth(tmp2);
@@ -709,7 +711,7 @@
   
       for(i = 0; i < sprite_count; i += 1) 
 	{
-	  tmp2 = load_bitmap(bmplist[i].c_str(), NULL);
+	  tmp2 = load_bitmap(data_full_path(bmplist[i]).c_str(), NULL);
 	  if(!tmp2)
 	    {
 	      tw_error("unable to load bitmap: %s", bmplist[i].c_str());
@@ -750,7 +752,7 @@
   
   for(i = 0; i < sprite_count; i += 1) 
     {
-      tmp2 = load_bitmap(bmplist[i].c_str(), NULL);
+      tmp2 = load_bitmap(data_full_path(bmplist[i]).c_str(), NULL);
       if(!tmp2)
 	{
 	  tw_error("unable to load bitmap: %s", bmplist[i].c_str());

Modified: trunk/source/melee.h
===================================================================
--- trunk/source/melee.h	2004-09-20 21:04:58 UTC (rev 60)
+++ trunk/source/melee.h	2004-09-25 14:18:41 UTC (rev 61)
@@ -471,7 +471,9 @@
   SpaceSprite(BITMAP *image, int _attributes = -1);
   SpaceSprite(SpaceSprite &old);
  
-  SpaceSprite( std::vector<std::string> bmplist, int sprite_count, int rotations, int _attributes);
+  SpaceSprite( std::vector<std::string> bmplist, int sprite_count,  
+	       int _attributes = -1, 
+	       int rotations =1);
   virtual ~SpaceSprite();
   
   
@@ -557,7 +559,7 @@
 //melee/mshpdata
 extern int auto_unload;
 
-ShipData *shipdata ( std::string file, std::string inifile ) ;
+ShipData *shipdata ( std::string inifile ) ;
 void unload_all_ship_data() ;
 
 /*! \brief Sprites, samples - can be in loaded or unloaded state 
@@ -565,7 +567,8 @@
     Note: in future this class will contain only string to data files, all datas will
     actully be in SoundSystem and VideoSystem classes
 */ 
-class ShipData {
+class ShipData 
+{
   enum { 
     LOADED_NONE,
     LOADED_FULL,
@@ -575,7 +578,6 @@
   int references;
  public:
   int status;
-  std::string file;
   std::string ini;
 
   void lock();
@@ -601,7 +603,7 @@
   
   std::string moduleVictory;
   
-  ShipData(std::string filename, std::string inifile);
+  ShipData(std::string inifile);
   ~ShipData();
 };
 



From yurand at sheep.berlios.de  Sat Sep 25 18:33:25 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 25 Sep 2004 18:33:25 +0200
Subject: [Tw-light-svn] r62 - in trunk: Util Util/deditor Util/deditor/lua Util/deditor/lua/lib web
Message-ID: <200409251633.i8PGXPfp009710@sheep.berlios.de>

Author: yurand
Date: 2004-09-25 18:33:16 +0200 (Sat, 25 Sep 2004)
New Revision: 62

Added:
   trunk/Util/deditor/
   trunk/Util/deditor/MainDialog.ui
   trunk/Util/deditor/addplayeranswer.xpm
   trunk/Util/deditor/application.cpp
   trunk/Util/deditor/application.h
   trunk/Util/deditor/book.png
   trunk/Util/deditor/createnode.xpm
   trunk/Util/deditor/dialog.xml
   trunk/Util/deditor/dialogeditor.dsp
   trunk/Util/deditor/dialogeditor.dsw
   trunk/Util/deditor/dialogeditor.ncb
   trunk/Util/deditor/dialogeditor.opt
   trunk/Util/deditor/dialogeditor.plg
   trunk/Util/deditor/dialogeditor.sln
   trunk/Util/deditor/dialogeditor.suo
   trunk/Util/deditor/dialogeditor.vcproj
   trunk/Util/deditor/evalanswer.xpm
   trunk/Util/deditor/fileopen.xpm
   trunk/Util/deditor/filesave.xpm
   trunk/Util/deditor/gui.bat
   trunk/Util/deditor/helpers.cpp
   trunk/Util/deditor/helpers.h
   trunk/Util/deditor/itemdown.xpm
   trunk/Util/deditor/itemup.xpm
   trunk/Util/deditor/lua/
   trunk/Util/deditor/lua/Makefile
   trunk/Util/deditor/lua/README
   trunk/Util/deditor/lua/lapi.c
   trunk/Util/deditor/lua/lapi.h
   trunk/Util/deditor/lua/lauxlib.h
   trunk/Util/deditor/lua/lcode.c
   trunk/Util/deditor/lua/lcode.h
   trunk/Util/deditor/lua/ldebug.c
   trunk/Util/deditor/lua/ldebug.h
   trunk/Util/deditor/lua/ldo.c
   trunk/Util/deditor/lua/ldo.h
   trunk/Util/deditor/lua/ldump.c
   trunk/Util/deditor/lua/lfunc.c
   trunk/Util/deditor/lua/lfunc.h
   trunk/Util/deditor/lua/lgc.c
   trunk/Util/deditor/lua/lgc.h
   trunk/Util/deditor/lua/lib/
   trunk/Util/deditor/lua/lib/Makefile
   trunk/Util/deditor/lua/lib/README
   trunk/Util/deditor/lua/lib/lauxlib.c
   trunk/Util/deditor/lua/lib/lbaselib.c
   trunk/Util/deditor/lua/lib/ldblib.c
   trunk/Util/deditor/lua/lib/liolib.c
   trunk/Util/deditor/lua/lib/lmathlib.c
   trunk/Util/deditor/lua/lib/loadlib.c
   trunk/Util/deditor/lua/lib/lstrlib.c
   trunk/Util/deditor/lua/lib/ltablib.c
   trunk/Util/deditor/lua/llex.c
   trunk/Util/deditor/lua/llex.h
   trunk/Util/deditor/lua/llimits.h
   trunk/Util/deditor/lua/lmem.c
   trunk/Util/deditor/lua/lmem.h
   trunk/Util/deditor/lua/lobject.c
   trunk/Util/deditor/lua/lobject.h
   trunk/Util/deditor/lua/lopcodes.c
   trunk/Util/deditor/lua/lopcodes.h
   trunk/Util/deditor/lua/lparser.c
   trunk/Util/deditor/lua/lparser.h
   trunk/Util/deditor/lua/lstate.c
   trunk/Util/deditor/lua/lstate.h
   trunk/Util/deditor/lua/lstring.c
   trunk/Util/deditor/lua/lstring.h
   trunk/Util/deditor/lua/ltable.c
   trunk/Util/deditor/lua/ltable.h
   trunk/Util/deditor/lua/ltests.c
   trunk/Util/deditor/lua/ltm.c
   trunk/Util/deditor/lua/ltm.h
   trunk/Util/deditor/lua/lua.h
   trunk/Util/deditor/lua/lualib.h
   trunk/Util/deditor/lua/lundump.c
   trunk/Util/deditor/lua/lundump.h
   trunk/Util/deditor/lua/lvm.c
   trunk/Util/deditor/lua/lvm.h
   trunk/Util/deditor/lua/lzio.c
   trunk/Util/deditor/lua/lzio.h
   trunk/Util/deditor/main.cpp
   trunk/Util/deditor/maindialog.cpp
   trunk/Util/deditor/maindialog.h
   trunk/Util/deditor/mainwidget.cpp
   trunk/Util/deditor/mainwidget.h
   trunk/Util/deditor/moc_application.cpp
   trunk/Util/deditor/moc_maindialog.cpp
   trunk/Util/deditor/moc_node.cpp
   trunk/Util/deditor/node.cpp
   trunk/Util/deditor/node.h
   trunk/Util/deditor/removenode.xpm
   trunk/Util/deditor/rmplayeranswer.xpm
   trunk/Util/deditor/setalientext.xpm
   trunk/Util/deditor/setplayeranswertext.xpm
   trunk/Util/deditor/xmlparser.cpp
   trunk/Util/deditor/xmlparser.h
   trunk/web/3dlogo.jpg
   trunk/web/background.jpg
   trunk/web/dialog-editor-win32-62.zip
   trunk/web/downloads.html
   trunk/web/info.html
   trunk/web/links.html
   trunk/web/team.html
Removed:
   trunk/web/logo.png
Modified:
   trunk/web/index.html
   trunk/web/update.sh
Log:
Dialog Editor added to SVN tree
New web site added to SVN tree


Added: trunk/Util/deditor/MainDialog.ui
===================================================================
--- trunk/Util/deditor/MainDialog.ui	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/MainDialog.ui	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,1076 @@
+<!DOCTYPE UI><UI>
+<class>DialogEditorGenerated</class>
+<widget>
+    <class>QWidget</class>
+    <property stdset="1">
+        <name>name</name>
+        <cstring>DialogEditorGenerated</cstring>
+    </property>
+    <property stdset="1">
+        <name>geometry</name>
+        <rect>
+            <x>0</x>
+            <y>0</y>
+            <width>785</width>
+            <height>452</height>
+        </rect>
+    </property>
+    <property stdset="1">
+        <name>caption</name>
+        <string>Form1</string>
+    </property>
+    <grid>
+        <property stdset="1">
+            <name>margin</name>
+            <number>11</number>
+        </property>
+        <property stdset="1">
+            <name>spacing</name>
+            <number>6</number>
+        </property>
+        <widget row="0"  column="0" >
+            <class>QLayoutWidget</class>
+            <property stdset="1">
+                <name>name</name>
+                <cstring>Layout17</cstring>
+            </property>
+            <grid>
+                <property stdset="1">
+                    <name>margin</name>
+                    <number>0</number>
+                </property>
+                <property stdset="1">
+                    <name>spacing</name>
+                    <number>6</number>
+                </property>
+                <widget row="0"  column="2" >
+                    <class>QLayoutWidget</class>
+                    <property stdset="1">
+                        <name>name</name>
+                        <cstring>Layout19</cstring>
+                    </property>
+                    <vbox>
+                        <property stdset="1">
+                            <name>margin</name>
+                            <number>0</number>
+                        </property>
+                        <property stdset="1">
+                            <name>spacing</name>
+                            <number>6</number>
+                        </property>
+                        <widget>
+                            <class>QLayoutWidget</class>
+                            <property stdset="1">
+                                <name>name</name>
+                                <cstring>Layout18</cstring>
+                            </property>
+                            <hbox>
+                                <property stdset="1">
+                                    <name>margin</name>
+                                    <number>0</number>
+                                </property>
+                                <property stdset="1">
+                                    <name>spacing</name>
+                                    <number>6</number>
+                                </property>
+                                <widget>
+                                    <class>QLabel</class>
+                                    <property stdset="1">
+                                        <name>name</name>
+                                        <cstring>TextLabel3</cstring>
+                                    </property>
+                                    <property stdset="1">
+                                        <name>text</name>
+                                        <string>Triggers:</string>
+                                    </property>
+                                </widget>
+                                <widget>
+                                    <class>QLabel</class>
+                                    <property stdset="1">
+                                        <name>name</name>
+                                        <cstring>TextLabel12</cstring>
+                                    </property>
+                                    <property stdset="1">
+                                        <name>text</name>
+                                        <string>Name</string>
+                                    </property>
+                                </widget>
+                                <widget>
+                                    <class>QLabel</class>
+                                    <property stdset="1">
+                                        <name>name</name>
+                                        <cstring>TextLabel13</cstring>
+                                    </property>
+                                    <property stdset="1">
+                                        <name>text</name>
+                                        <string>Value</string>
+                                    </property>
+                                </widget>
+                            </hbox>
+                        </widget>
+                        <widget>
+                            <class>QTable</class>
+                            <property stdset="1">
+                                <name>name</name>
+                                <cstring>triggerTable</cstring>
+                            </property>
+                            <property stdset="1">
+                                <name>maximumSize</name>
+                                <size>
+                                    <width>200</width>
+                                    <height>32767</height>
+                                </size>
+                            </property>
+                            <property stdset="1">
+                                <name>numRows</name>
+                                <number>6</number>
+                            </property>
+                            <property stdset="1">
+                                <name>numCols</name>
+                                <number>6</number>
+                            </property>
+                            <property>
+                                <name>whatsThis</name>
+                                <string>First column - trigger name, second - value</string>
+                            </property>
+                        </widget>
+                        <widget>
+                            <class>QListView</class>
+                            <column>
+                                <property>
+                                    <name>text</name>
+                                    <string>ID</string>
+                                </property>
+                                <property>
+                                    <name>clickable</name>
+                                    <bool>true</bool>
+                                </property>
+                                <property>
+                                    <name>resizeable</name>
+                                    <bool>true</bool>
+                                </property>
+                            </column>
+                            <column>
+                                <property>
+                                    <name>text</name>
+                                    <string>Name</string>
+                                </property>
+                                <property>
+                                    <name>clickable</name>
+                                    <bool>true</bool>
+                                </property>
+                                <property>
+                                    <name>resizeable</name>
+                                    <bool>true</bool>
+                                </property>
+                            </column>
+                            <property stdset="1">
+                                <name>name</name>
+                                <cstring>nodeListView</cstring>
+                            </property>
+                            <property stdset="1">
+                                <name>sizePolicy</name>
+                                <sizepolicy>
+                                    <hsizetype>7</hsizetype>
+                                    <vsizetype>5</vsizetype>
+                                </sizepolicy>
+                            </property>
+                            <property stdset="1">
+                                <name>maximumSize</name>
+                                <size>
+                                    <width>200</width>
+                                    <height>32767</height>
+                                </size>
+                            </property>
+                            <property>
+                                <name>whatsThis</name>
+                                <string>Browse nodes from here</string>
+                            </property>
+                        </widget>
+                    </vbox>
+                </widget>
+                <widget row="0"  column="0" >
+                    <class>QLayoutWidget</class>
+                    <property stdset="1">
+                        <name>name</name>
+                        <cstring>Layout20</cstring>
+                    </property>
+                    <vbox>
+                        <property stdset="1">
+                            <name>margin</name>
+                            <number>0</number>
+                        </property>
+                        <property stdset="1">
+                            <name>spacing</name>
+                            <number>6</number>
+                        </property>
+                        <widget>
+                            <class>QTextBrowser</class>
+                            <property stdset="1">
+                                <name>name</name>
+                                <cstring>alienTextBrowser</cstring>
+                            </property>
+                            <property stdset="1">
+                                <name>sizePolicy</name>
+                                <sizepolicy>
+                                    <hsizetype>7</hsizetype>
+                                    <vsizetype>7</vsizetype>
+                                </sizepolicy>
+                            </property>
+                            <property stdset="1">
+                                <name>minimumSize</name>
+                                <size>
+                                    <width>200</width>
+                                    <height>200</height>
+                                </size>
+                            </property>
+                            <property>
+                                <name>whatsThis</name>
+                                <string>Alian picture, and text here</string>
+                            </property>
+                        </widget>
+                        <widget>
+                            <class>QLabel</class>
+                            <property stdset="1">
+                                <name>name</name>
+                                <cstring>TextLabel4</cstring>
+                            </property>
+                            <property stdset="1">
+                                <name>text</name>
+                                <string>Place text here:</string>
+                            </property>
+                        </widget>
+                        <widget>
+                            <class>QMultiLineEdit</class>
+                            <property stdset="1">
+                                <name>name</name>
+                                <cstring>commonMultiLineEdit</cstring>
+                            </property>
+                            <property stdset="1">
+                                <name>minimumSize</name>
+                                <size>
+                                    <width>0</width>
+                                    <height>90</height>
+                                </size>
+                            </property>
+                            <property>
+                                <name>whatsThis</name>
+                                <string>Text in this edit can be set aso player or alian answer.</string>
+                            </property>
+                        </widget>
+                    </vbox>
+                </widget>
+                <widget row="1"  column="0"  rowspan="1"  colspan="3" >
+                    <class>QListView</class>
+                    <column>
+                        <property>
+                            <name>text</name>
+                            <string>Player answers</string>
+                        </property>
+                        <property>
+                            <name>clickable</name>
+                            <bool>true</bool>
+                        </property>
+                        <property>
+                            <name>resizeable</name>
+                            <bool>true</bool>
+                        </property>
+                    </column>
+                    <property stdset="1">
+                        <name>name</name>
+                        <cstring>answersListView</cstring>
+                    </property>
+                    <property>
+                        <name>whatsThis</name>
+                        <string>Player Answers</string>
+                    </property>
+                </widget>
+                <widget row="0"  column="1" >
+                    <class>QLayoutWidget</class>
+                    <property stdset="1">
+                        <name>name</name>
+                        <cstring>Layout14</cstring>
+                    </property>
+                    <vbox>
+                        <property stdset="1">
+                            <name>margin</name>
+                            <number>0</number>
+                        </property>
+                        <property stdset="1">
+                            <name>spacing</name>
+                            <number>6</number>
+                        </property>
+                        <widget>
+                            <class>QCheckBox</class>
+                            <property stdset="1">
+                                <name>name</name>
+                                <cstring>TestModeCheckBox</cstring>
+                            </property>
+                            <property stdset="1">
+                                <name>text</name>
+                                <string>Test Mode (Hide not allowed answers)</string>
+                            </property>
+                        </widget>
+                        <widget>
+                            <class>QTabWidget</class>
+                            <property stdset="1">
+                                <name>name</name>
+                                <cstring>TabWidget2</cstring>
+                            </property>
+                            <property stdset="1">
+                                <name>sizePolicy</name>
+                                <sizepolicy>
+                                    <hsizetype>4</hsizetype>
+                                    <vsizetype>4</vsizetype>
+                                </sizepolicy>
+                            </property>
+                            <property stdset="1">
+                                <name>minimumSize</name>
+                                <size>
+                                    <width>200</width>
+                                    <height>250</height>
+                                </size>
+                            </property>
+                            <property stdset="1">
+                                <name>margin</name>
+                                <number>0</number>
+                            </property>
+                            <widget>
+                                <class>QWidget</class>
+                                <property stdset="1">
+                                    <name>name</name>
+                                    <cstring>tab</cstring>
+                                </property>
+                                <attribute>
+                                    <name>title</name>
+                                    <string>Node</string>
+                                </attribute>
+                                <grid>
+                                    <property stdset="1">
+                                        <name>margin</name>
+                                        <number>11</number>
+                                    </property>
+                                    <property stdset="1">
+                                        <name>spacing</name>
+                                        <number>6</number>
+                                    </property>
+                                    <widget row="0"  column="0" >
+                                        <class>QLayoutWidget</class>
+                                        <property stdset="1">
+                                            <name>name</name>
+                                            <cstring>Layout15</cstring>
+                                        </property>
+                                        <grid>
+                                            <property stdset="1">
+                                                <name>margin</name>
+                                                <number>0</number>
+                                            </property>
+                                            <property stdset="1">
+                                                <name>spacing</name>
+                                                <number>6</number>
+                                            </property>
+                                            <widget row="5"  column="1"  rowspan="1"  colspan="2" >
+                                                <class>QLineEdit</class>
+                                                <property stdset="1">
+                                                    <name>name</name>
+                                                    <cstring>textLocationLineEdit</cstring>
+                                                </property>
+                                                <property stdset="1">
+                                                    <name>alignment</name>
+                                                    <set>AlignLeft</set>
+                                                </property>
+                                                <property>
+                                                    <name>hAlign</name>
+                                                </property>
+                                                <property>
+                                                    <name>whatsThis</name>
+                                                    <string>Alien text location</string>
+                                                </property>
+                                            </widget>
+                                            <widget row="1"  column="1"  rowspan="1"  colspan="2" >
+                                                <class>QLineEdit</class>
+                                                <property stdset="1">
+                                                    <name>name</name>
+                                                    <cstring>NodeNameLineEdit</cstring>
+                                                </property>
+                                                <property stdset="1">
+                                                    <name>alignment</name>
+                                                    <set>AlignLeft</set>
+                                                </property>
+                                                <property>
+                                                    <name>hAlign</name>
+                                                </property>
+                                                <property>
+                                                    <name>whatsThis</name>
+                                                    <string>Name is not used</string>
+                                                </property>
+                                            </widget>
+                                            <widget row="4"  column="0" >
+                                                <class>QLabel</class>
+                                                <property stdset="1">
+                                                    <name>name</name>
+                                                    <cstring>TextLabel1_3</cstring>
+                                                </property>
+                                                <property stdset="1">
+                                                    <name>text</name>
+                                                    <string>Font:</string>
+                                                </property>
+                                                <property>
+                                                    <name>whatsThis</name>
+                                                    <string>Alien text font</string>
+                                                </property>
+                                            </widget>
+                                            <widget row="4"  column="1"  rowspan="1"  colspan="2" >
+                                                <class>QLineEdit</class>
+                                                <property stdset="1">
+                                                    <name>name</name>
+                                                    <cstring>fontLineEdit</cstring>
+                                                </property>
+                                                <property stdset="1">
+                                                    <name>alignment</name>
+                                                    <set>AlignLeft</set>
+                                                </property>
+                                                <property>
+                                                    <name>hAlign</name>
+                                                </property>
+                                                <property>
+                                                    <name>whatsThis</name>
+                                                    <string>Alien text font</string>
+                                                </property>
+                                            </widget>
+                                            <widget row="2"  column="0" >
+                                                <class>QLabel</class>
+                                                <property stdset="1">
+                                                    <name>name</name>
+                                                    <cstring>TextLabel3_2</cstring>
+                                                </property>
+                                                <property stdset="1">
+                                                    <name>text</name>
+                                                    <string>Music</string>
+                                                </property>
+                                                <property>
+                                                    <name>whatsThis</name>
+                                                    <string>Path to music file</string>
+                                                </property>
+                                            </widget>
+                                            <widget row="0"  column="0" >
+                                                <class>QLabel</class>
+                                                <property stdset="1">
+                                                    <name>name</name>
+                                                    <cstring>TextLabel1</cstring>
+                                                </property>
+                                                <property stdset="1">
+                                                    <name>text</name>
+                                                    <string>Node ID</string>
+                                                </property>
+                                                <property>
+                                                    <name>whatsThis</name>
+                                                    <string>unique identifier for node</string>
+                                                </property>
+                                            </widget>
+                                            <widget row="5"  column="0" >
+                                                <class>QLabel</class>
+                                                <property stdset="1">
+                                                    <name>name</name>
+                                                    <cstring>TextLabel2_3</cstring>
+                                                </property>
+                                                <property stdset="1">
+                                                    <name>text</name>
+                                                    <string>Text location:</string>
+                                                </property>
+                                                <property>
+                                                    <name>whatsThis</name>
+                                                    <string>Alien text location</string>
+                                                </property>
+                                            </widget>
+                                            <widget row="3"  column="0" >
+                                                <class>QLabel</class>
+                                                <property stdset="1">
+                                                    <name>name</name>
+                                                    <cstring>TextLabel4_2</cstring>
+                                                </property>
+                                                <property stdset="1">
+                                                    <name>text</name>
+                                                    <string>Background</string>
+                                                </property>
+                                                <property>
+                                                    <name>whatsThis</name>
+                                                    <string>Path to background picture</string>
+                                                </property>
+                                            </widget>
+                                            <spacer row="0"  column="1" >
+                                                <property>
+                                                    <name>name</name>
+                                                    <cstring>Spacer1</cstring>
+                                                </property>
+                                                <property>
+                                                    <name>orientation</name>
+                                                    <enum>Horizontal</enum>
+                                                </property>
+                                                <property>
+                                                    <name>sizeType</name>
+                                                    <enum>Expanding</enum>
+                                                </property>
+                                                <property>
+                                                    <name>sizeHint</name>
+                                                    <size>
+                                                        <width>20</width>
+                                                        <height>20</height>
+                                                    </size>
+                                                </property>
+                                            </spacer>
+                                            <widget row="2"  column="1"  rowspan="1"  colspan="2" >
+                                                <class>QLineEdit</class>
+                                                <property stdset="1">
+                                                    <name>name</name>
+                                                    <cstring>MusicEdit</cstring>
+                                                </property>
+                                                <property stdset="1">
+                                                    <name>alignment</name>
+                                                    <set>AlignLeft</set>
+                                                </property>
+                                                <property>
+                                                    <name>hAlign</name>
+                                                </property>
+                                                <property>
+                                                    <name>whatsThis</name>
+                                                    <string>Path to music file</string>
+                                                </property>
+                                            </widget>
+                                            <widget row="3"  column="1"  rowspan="1"  colspan="2" >
+                                                <class>QLineEdit</class>
+                                                <property stdset="1">
+                                                    <name>name</name>
+                                                    <cstring>BackgroundLineEdit</cstring>
+                                                </property>
+                                                <property stdset="1">
+                                                    <name>alignment</name>
+                                                    <set>AlignLeft</set>
+                                                </property>
+                                                <property>
+                                                    <name>hAlign</name>
+                                                </property>
+                                                <property>
+                                                    <name>whatsThis</name>
+                                                    <string>Path to background picture</string>
+                                                </property>
+                                            </widget>
+                                            <widget row="1"  column="0" >
+                                                <class>QLabel</class>
+                                                <property stdset="1">
+                                                    <name>name</name>
+                                                    <cstring>TextLabel2</cstring>
+                                                </property>
+                                                <property stdset="1">
+                                                    <name>text</name>
+                                                    <string>Node Name</string>
+                                                </property>
+                                                <property>
+                                                    <name>whatsThis</name>
+                                                    <string>Name is not used</string>
+                                                </property>
+                                            </widget>
+                                            <widget row="0"  column="2" >
+                                                <class>QLineEdit</class>
+                                                <property stdset="1">
+                                                    <name>name</name>
+                                                    <cstring>nodeIdLineEdit</cstring>
+                                                </property>
+                                                <property stdset="1">
+                                                    <name>alignment</name>
+                                                    <set>AlignRight</set>
+                                                </property>
+                                                <property>
+                                                    <name>hAlign</name>
+                                                </property>
+                                                <property>
+                                                    <name>whatsThis</name>
+                                                    <string>unique identifier for node</string>
+                                                </property>
+                                            </widget>
+                                        </grid>
+                                    </widget>
+                                </grid>
+                            </widget>
+                            <widget>
+                                <class>QWidget</class>
+                                <property stdset="1">
+                                    <name>name</name>
+                                    <cstring>tab</cstring>
+                                </property>
+                                <attribute>
+                                    <name>title</name>
+                                    <string>Answer</string>
+                                </attribute>
+                                <vbox>
+                                    <property stdset="1">
+                                        <name>margin</name>
+                                        <number>11</number>
+                                    </property>
+                                    <property stdset="1">
+                                        <name>spacing</name>
+                                        <number>6</number>
+                                    </property>
+                                    <widget>
+                                        <class>QLayoutWidget</class>
+                                        <property stdset="1">
+                                            <name>name</name>
+                                            <cstring>Layout12</cstring>
+                                        </property>
+                                        <vbox>
+                                            <property stdset="1">
+                                                <name>margin</name>
+                                                <number>0</number>
+                                            </property>
+                                            <property stdset="1">
+                                                <name>spacing</name>
+                                                <number>6</number>
+                                            </property>
+                                            <widget>
+                                                <class>QLayoutWidget</class>
+                                                <property stdset="1">
+                                                    <name>name</name>
+                                                    <cstring>Layout11</cstring>
+                                                </property>
+                                                <hbox>
+                                                    <property stdset="1">
+                                                        <name>margin</name>
+                                                        <number>0</number>
+                                                    </property>
+                                                    <property stdset="1">
+                                                        <name>spacing</name>
+                                                        <number>6</number>
+                                                    </property>
+                                                    <widget>
+                                                        <class>QLabel</class>
+                                                        <property stdset="1">
+                                                            <name>name</name>
+                                                            <cstring>TextLabel1_2</cstring>
+                                                        </property>
+                                                        <property stdset="1">
+                                                            <name>text</name>
+                                                            <string>Appear condition:</string>
+                                                        </property>
+                                                    </widget>
+                                                    <widget>
+                                                        <class>QLineEdit</class>
+                                                        <property stdset="1">
+                                                            <name>name</name>
+                                                            <cstring>appearConditionLineEdit</cstring>
+                                                        </property>
+                                                        <property>
+                                                            <name>whatsThis</name>
+                                                            <string>Answer will not show, if doesn.t match</string>
+                                                        </property>
+                                                    </widget>
+                                                </hbox>
+                                            </widget>
+                                            <widget>
+                                                <class>QGroupBox</class>
+                                                <property stdset="1">
+                                                    <name>name</name>
+                                                    <cstring>GroupBox1</cstring>
+                                                </property>
+                                                <property stdset="1">
+                                                    <name>title</name>
+                                                    <string>Actions</string>
+                                                </property>
+                                                <hbox>
+                                                    <property stdset="1">
+                                                        <name>margin</name>
+                                                        <number>11</number>
+                                                    </property>
+                                                    <property stdset="1">
+                                                        <name>spacing</name>
+                                                        <number>6</number>
+                                                    </property>
+                                                    <widget>
+                                                        <class>QLayoutWidget</class>
+                                                        <property stdset="1">
+                                                            <name>name</name>
+                                                            <cstring>Layout10</cstring>
+                                                        </property>
+                                                        <vbox>
+                                                            <property stdset="1">
+                                                                <name>margin</name>
+                                                                <number>0</number>
+                                                            </property>
+                                                            <property stdset="1">
+                                                                <name>spacing</name>
+                                                                <number>6</number>
+                                                            </property>
+                                                            <widget>
+                                                                <class>QLayoutWidget</class>
+                                                                <property stdset="1">
+                                                                    <name>name</name>
+                                                                    <cstring>Layout5</cstring>
+                                                                </property>
+                                                                <hbox>
+                                                                    <property stdset="1">
+                                                                        <name>margin</name>
+                                                                        <number>0</number>
+                                                                    </property>
+                                                                    <property stdset="1">
+                                                                        <name>spacing</name>
+                                                                        <number>6</number>
+                                                                    </property>
+                                                                    <widget>
+                                                                        <class>QLabel</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>TextLabel2_2</cstring>
+                                                                        </property>
+                                                                        <property stdset="1">
+                                                                            <name>text</name>
+                                                                            <string>condition</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                    <widget>
+                                                                        <class>QLineEdit</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>condition1LineEdit</cstring>
+                                                                        </property>
+                                                                        <property>
+                                                                            <name>whatsThis</name>
+                                                                            <string>if condition match, coresponding action will be evaluated</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                    <widget>
+                                                                        <class>QLabel</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>TextLabel7</cstring>
+                                                                        </property>
+                                                                        <property stdset="1">
+                                                                            <name>text</name>
+                                                                            <string>do</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                    <widget>
+                                                                        <class>QLineEdit</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>action1LineEdit</cstring>
+                                                                        </property>
+                                                                        <property>
+                                                                            <name>whatsThis</name>
+                                                                            <string>if condition match, coresponding action will be evaluated</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                </hbox>
+                                                            </widget>
+                                                            <widget>
+                                                                <class>QLayoutWidget</class>
+                                                                <property stdset="1">
+                                                                    <name>name</name>
+                                                                    <cstring>Layout6</cstring>
+                                                                </property>
+                                                                <hbox>
+                                                                    <property stdset="1">
+                                                                        <name>margin</name>
+                                                                        <number>0</number>
+                                                                    </property>
+                                                                    <property stdset="1">
+                                                                        <name>spacing</name>
+                                                                        <number>6</number>
+                                                                    </property>
+                                                                    <widget>
+                                                                        <class>QLabel</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>TextLabel3_3</cstring>
+                                                                        </property>
+                                                                        <property stdset="1">
+                                                                            <name>text</name>
+                                                                            <string>condition</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                    <widget>
+                                                                        <class>QLineEdit</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>condition2LineEdit</cstring>
+                                                                        </property>
+                                                                        <property>
+                                                                            <name>whatsThis</name>
+                                                                            <string>if condition match, coresponding action will be evaluated</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                    <widget>
+                                                                        <class>QLabel</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>TextLabel8</cstring>
+                                                                        </property>
+                                                                        <property stdset="1">
+                                                                            <name>text</name>
+                                                                            <string>do</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                    <widget>
+                                                                        <class>QLineEdit</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>action2LineEdit</cstring>
+                                                                        </property>
+                                                                        <property>
+                                                                            <name>whatsThis</name>
+                                                                            <string>if condition match, coresponding action will be evaluated</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                </hbox>
+                                                            </widget>
+                                                            <widget>
+                                                                <class>QLayoutWidget</class>
+                                                                <property stdset="1">
+                                                                    <name>name</name>
+                                                                    <cstring>Layout7</cstring>
+                                                                </property>
+                                                                <hbox>
+                                                                    <property stdset="1">
+                                                                        <name>margin</name>
+                                                                        <number>0</number>
+                                                                    </property>
+                                                                    <property stdset="1">
+                                                                        <name>spacing</name>
+                                                                        <number>6</number>
+                                                                    </property>
+                                                                    <widget>
+                                                                        <class>QLabel</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>TextLabel4_3</cstring>
+                                                                        </property>
+                                                                        <property stdset="1">
+                                                                            <name>text</name>
+                                                                            <string>condition</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                    <widget>
+                                                                        <class>QLineEdit</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>condition3LineEdit</cstring>
+                                                                        </property>
+                                                                        <property>
+                                                                            <name>whatsThis</name>
+                                                                            <string>if condition match, coresponding action will be evaluated</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                    <widget>
+                                                                        <class>QLabel</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>TextLabel9</cstring>
+                                                                        </property>
+                                                                        <property stdset="1">
+                                                                            <name>text</name>
+                                                                            <string>do</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                    <widget>
+                                                                        <class>QLineEdit</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>action3LineEdit</cstring>
+                                                                        </property>
+                                                                        <property>
+                                                                            <name>whatsThis</name>
+                                                                            <string>if condition match, coresponding action will be evaluated</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                </hbox>
+                                                            </widget>
+                                                            <widget>
+                                                                <class>QLayoutWidget</class>
+                                                                <property stdset="1">
+                                                                    <name>name</name>
+                                                                    <cstring>Layout8</cstring>
+                                                                </property>
+                                                                <hbox>
+                                                                    <property stdset="1">
+                                                                        <name>margin</name>
+                                                                        <number>0</number>
+                                                                    </property>
+                                                                    <property stdset="1">
+                                                                        <name>spacing</name>
+                                                                        <number>6</number>
+                                                                    </property>
+                                                                    <widget>
+                                                                        <class>QLabel</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>TextLabel5</cstring>
+                                                                        </property>
+                                                                        <property stdset="1">
+                                                                            <name>text</name>
+                                                                            <string>condition</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                    <widget>
+                                                                        <class>QLineEdit</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>condition4LineEdit</cstring>
+                                                                        </property>
+                                                                        <property>
+                                                                            <name>whatsThis</name>
+                                                                            <string>if condition match, coresponding action will be evaluated</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                    <widget>
+                                                                        <class>QLabel</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>TextLabel10</cstring>
+                                                                        </property>
+                                                                        <property stdset="1">
+                                                                            <name>text</name>
+                                                                            <string>do</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                    <widget>
+                                                                        <class>QLineEdit</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>action4LineEdit</cstring>
+                                                                        </property>
+                                                                        <property>
+                                                                            <name>whatsThis</name>
+                                                                            <string>if condition match, coresponding action will be evaluated</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                </hbox>
+                                                            </widget>
+                                                            <widget>
+                                                                <class>QLayoutWidget</class>
+                                                                <property stdset="1">
+                                                                    <name>name</name>
+                                                                    <cstring>Layout9</cstring>
+                                                                </property>
+                                                                <hbox>
+                                                                    <property stdset="1">
+                                                                        <name>margin</name>
+                                                                        <number>0</number>
+                                                                    </property>
+                                                                    <property stdset="1">
+                                                                        <name>spacing</name>
+                                                                        <number>6</number>
+                                                                    </property>
+                                                                    <widget>
+                                                                        <class>QLabel</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>TextLabel6</cstring>
+                                                                        </property>
+                                                                        <property stdset="1">
+                                                                            <name>text</name>
+                                                                            <string>condition</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                    <widget>
+                                                                        <class>QLineEdit</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>condition5LineEdit</cstring>
+                                                                        </property>
+                                                                        <property>
+                                                                            <name>whatsThis</name>
+                                                                            <string>if condition match, coresponding action will be evaluated</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                    <widget>
+                                                                        <class>QLabel</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>TextLabel11</cstring>
+                                                                        </property>
+                                                                        <property stdset="1">
+                                                                            <name>text</name>
+                                                                            <string>do</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                    <widget>
+                                                                        <class>QLineEdit</class>
+                                                                        <property stdset="1">
+                                                                            <name>name</name>
+                                                                            <cstring>action5LineEdit</cstring>
+                                                                        </property>
+                                                                        <property>
+                                                                            <name>whatsThis</name>
+                                                                            <string>if condition match, coresponding action will be evaluated</string>
+                                                                        </property>
+                                                                    </widget>
+                                                                </hbox>
+                                                            </widget>
+                                                        </vbox>
+                                                    </widget>
+                                                </hbox>
+                                            </widget>
+                                        </vbox>
+                                    </widget>
+                                </vbox>
+                            </widget>
+                        </widget>
+                    </vbox>
+                </widget>
+            </grid>
+        </widget>
+    </grid>
+</widget>
+<connections>
+    <connection>
+        <sender>nodeListView</sender>
+        <signal>selectionChanged(QListViewItem*)</signal>
+        <receiver>DialogEditorGenerated</receiver>
+        <slot>nodeChangedSlot(QListViewItem* )</slot>
+    </connection>
+    <connection>
+        <sender>answersListView</sender>
+        <signal>returnPressed(QListViewItem*)</signal>
+        <receiver>DialogEditorGenerated</receiver>
+        <slot>processAnswerSlot(QListViewItem*)</slot>
+    </connection>
+    <connection>
+        <sender>answersListView</sender>
+        <signal>doubleClicked(QListViewItem*)</signal>
+        <receiver>DialogEditorGenerated</receiver>
+        <slot>processAnswerSlot(QListViewItem*)</slot>
+    </connection>
+    <connection>
+        <sender>answersListView</sender>
+        <signal>selectionChanged(QListViewItem*)</signal>
+        <receiver>DialogEditorGenerated</receiver>
+        <slot>answerChangedSlot(QListViewItem*)</slot>
+    </connection>
+    <slot access="public">answerChangedSlot(QListViewItem*)</slot>
+    <slot access="public">answerPositionChanged(int)</slot>
+    <slot access="public">nodeChangedSlot(QListViewItem* )</slot>
+    <slot access="public">processAnswerSlot(QListViewItem*)</slot>
+    <slot access="public">saveAnswer()</slot>
+    <slot access="public">saveNodeInfo()</slot>
+</connections>
+<tabstops>
+    <tabstop>nodeIdLineEdit</tabstop>
+    <tabstop>NodeNameLineEdit</tabstop>
+    <tabstop>MusicEdit</tabstop>
+    <tabstop>BackgroundLineEdit</tabstop>
+    <tabstop>commonMultiLineEdit</tabstop>
+    <tabstop>nodeListView</tabstop>
+    <tabstop>triggerTable</tabstop>
+    <tabstop>alienTextBrowser</tabstop>
+    <tabstop>TabWidget2</tabstop>
+    <tabstop>appearConditionLineEdit</tabstop>
+    <tabstop>condition1LineEdit</tabstop>
+    <tabstop>action1LineEdit</tabstop>
+    <tabstop>condition2LineEdit</tabstop>
+    <tabstop>action2LineEdit</tabstop>
+    <tabstop>condition3LineEdit</tabstop>
+    <tabstop>action3LineEdit</tabstop>
+    <tabstop>condition4LineEdit</tabstop>
+    <tabstop>action4LineEdit</tabstop>
+    <tabstop>condition5LineEdit</tabstop>
+    <tabstop>action5LineEdit</tabstop>
+</tabstops>
+</UI>

Added: trunk/Util/deditor/addplayeranswer.xpm
===================================================================
--- trunk/Util/deditor/addplayeranswer.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/addplayeranswer.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *addplayeranswer_xpm[] = {
+"    16    13        5            1",
+". c #040404",
+"# c #808304",
+"a c None",
+"b c #00000",
+"c c #f3f7f3",
+"aaaaaaaaaaaaaaaa",
+"aaaaabbbbbbbaaaa",
+"aaaaaaaabaaaaaaa",
+"aaaaaaaabaaaaaaa",
+"aaaaaaabbbaaaaaa",
+"aaaaaaabbbaaaaaa",
+"aaaaaabbbbbaaaaa",
+"aaaaaaaaaaaaaaaa",
+"aabbbbbbbbbbbbaa",
+"aabbbbbbbbbbbbaa",
+"aabbbbbbbbbbbbaa",
+"aabbbbbbbbbbbbaa",
+"aaaaaaaaaaaaaaaa"
+};

Added: trunk/Util/deditor/application.cpp
===================================================================
--- trunk/Util/deditor/application.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/application.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,542 @@
+
+#include "application.h"
+
+#include <qimage.h>
+#include <qpixmap.h>
+#include <qtoolbar.h>
+#include <qtoolbutton.h>
+#include <qpopupmenu.h>
+#include <qmenubar.h>
+#include <qkeycode.h>
+#include <qmultilineedit.h>
+#include <qfile.h>
+#include <qfiledialog.h>
+#include <qstatusbar.h>
+#include <qmessagebox.h>
+#include <qprinter.h>
+#include <qapplication.h>
+#include <qaccel.h>
+#include <qtextstream.h>
+#include <qpainter.h>
+#include <qpaintdevicemetrics.h>
+#include <qwhatsthis.h>
+
+#include "mainwidget.h"
+
+#include "filesave.xpm"
+#include "fileopen.xpm"
+#include "createnode.xpm"
+#include "removenode.xpm"
+#include "setalientext.xpm"
+
+#include "addplayeranswer.xpm"
+#include "rmplayeranswer.xpm"
+#include "setplayeranswertext.xpm"
+#include "itemup.xpm"
+#include "itemdown.xpm"
+#include "evalanswer.xpm"
+
+//file
+static const char * fileOpenText = "<img source=\"fileopen\"> "
+"Click this button to open a <em>new file</em>. <br><br>"
+"You can also select the <b>Open command</b> from the File menu.";
+
+static const char * fileSaveText = "Click this button to save the file you are "
+"editing.  You will be prompted for a file name.\n\n"
+"You can also select the Save command from the File menu.\n\n";
+
+//Node
+static const char * addNewNodeText = "Click this button to create new dialog node";
+static const char * removeNodeText = "Click this button to destroy current dialog node";
+
+//Edit
+static const char * setAlienTextText = "Click this button to replace current alien text "
+"with text in edit box";
+
+static const char * addNewPlayerAnswerText = "Click this button to create new " 
+"answer choise";
+
+static const char * removePlayerAnswerText = "Click this button to remove "
+"selected player answer";
+
+static const char * setPlayerAnswerTextText = "Click this button to replace "
+"selected player answer with text in edit box";
+ 
+static const char * answerUpText = "Move answer up";
+static const char * answerDownText = "Move answer down";
+
+// Test
+static const char * hideNotAllowedAnswersText = "Hide answer variants that does not "
+"match current trigger selections";
+
+static const char * evaluateAnswerText = "Click this button to evaluate answer, "
+"it must change triggers and change current node";
+
+ApplicationWindow::ApplicationWindow()
+    : QMainWindow( 0, "example application main window", WDestructiveClose )
+{
+	WriteLog("ApplicationWindow\n");
+	e = new DialogEditor( this, "editor" );
+
+    e->setFocus();
+    setCentralWidget( e );
+
+	InitFileTools();
+	InitNodeManagerTools();
+	InitEditTools();
+	InitTestTools();
+	InitHelpTools();
+
+	InitFileMenu();
+	InitNodeManagerMenu();
+	InitEditMenu();
+	InitTestMenu();
+	InitHelpMenu();
+
+	strXML = e->GetXML();
+
+    statusBar()->message( "Ready", 2000 );
+	resize( 640, 480 );
+}
+
+ApplicationWindow::~ApplicationWindow()
+{
+	WriteLog("~ApplicationWindow\n");
+}
+
+
+void ApplicationWindow::InitFileMenu()
+{
+	WriteLog("ApplicationWindow::InitFileMenu\n");
+	int id;
+
+    QPixmap openIcon, saveIcon;
+    openIcon = QPixmap( fileopen );
+	saveIcon = QPixmap( filesave );
+
+	QPopupMenu * file = new QPopupMenu( this );
+    menuBar()->insertItem( "&File", file );
+
+    file->insertItem( "&New", this, SLOT(newDoc()), CTRL+Key_N );
+
+    id = file->insertItem( openIcon, "&Open",
+			   this, SLOT(load()), CTRL+Key_O );
+    file->setWhatsThis( id, fileOpenText );
+
+    id = file->insertItem( saveIcon, "&Save",
+			   this, SLOT(save()), CTRL+Key_S );
+    file->setWhatsThis( id, fileSaveText );
+    id = file->insertItem( "Save &as...", this, SLOT(saveAs()) );
+    file->setWhatsThis( id, fileSaveText );
+    file->insertSeparator();
+
+    file->insertSeparator();
+    file->insertItem( "&Close", this, SLOT(close()), CTRL+Key_W );
+    file->insertItem( "&Quit", qApp, SLOT( closeAllWindows() ), CTRL+Key_Q );
+}
+
+void ApplicationWindow::InitFileTools()
+{
+	WriteLog("ApplicationWindow::InitFileTools()\n");
+    QPixmap openIcon, saveIcon;
+
+    fileTools = new QToolBar( this, "file operations" );
+    fileTools->setLabel( tr( "File Operations" ) );
+
+    openIcon = QPixmap( fileopen );
+    QToolButton * fileOpen
+	= new QToolButton( openIcon, "Open File", QString::null,
+			   this, SLOT(load()), fileTools, "open file" );
+
+    saveIcon = QPixmap( filesave );
+    QToolButton * fileSave
+	= new QToolButton( saveIcon, "Save File", QString::null,
+			   this, SLOT(save()), fileTools, "save file" );
+
+    QWhatsThis::add( fileOpen, fileOpenText );
+    QMimeSourceFactory::defaultFactory()->setPixmap( "fileopen", openIcon );
+    QWhatsThis::add( fileSave, fileSaveText );
+
+}
+
+
+void ApplicationWindow::InitNodeManagerMenu()
+{
+	WriteLog("ApplicationWindow::InitNodeManagerMenu()\n");
+	int id;
+
+    QPixmap createnodeIcon, removenodeIcon;
+	createnodeIcon = QPixmap( createnode_xpm );
+	removenodeIcon = QPixmap( removenode_xpm );
+
+	QPopupMenu * node = new QPopupMenu( this );
+    menuBar()->insertItem( "&Node", node );
+
+    id = node->insertItem( createnodeIcon, "Add new node",
+			   this, SLOT(AddNewNodeSlot()), ALT+Key_N );
+
+    node->setWhatsThis( id, addNewNodeText );
+
+    id = node->insertItem( removenodeIcon, "Remove node",
+			   this, SLOT(RemoveNodeSlot()), ALT+Key_K );
+    node->setWhatsThis( id, removeNodeText );
+}
+
+void ApplicationWindow::InitNodeManagerTools()
+{
+	WriteLog("ApplicationWindow::InitNodeManagerTools");
+	QPixmap createnodeIcon, removenodeIcon;
+	createnodeIcon = QPixmap( createnode_xpm );
+	removenodeIcon = QPixmap( removenode_xpm );
+
+	nodeTools = new QToolBar( this, "Node manager operations" );
+    nodeTools->setLabel( tr( "Node manager Operations" ) );
+
+	QToolButton * addNewNode
+	= new QToolButton( createnodeIcon, "Add new node", QString::null,
+			   this, SLOT(AddNewNodeSlot()), nodeTools, "open file" );
+
+    QToolButton * removeNode
+	= new QToolButton( removenodeIcon, "Remove node", QString::null,
+			   this, SLOT(RemoveNodeSlot()), nodeTools, "open file" );
+
+	QWhatsThis::add( addNewNode, addNewNodeText );
+    QWhatsThis::add( removeNode, removeNodeText );
+}
+
+void ApplicationWindow::InitEditMenu()
+{
+	WriteLog("ApplicationWindow::InitEditMenu()\n");
+		int id;
+
+    QPixmap setalientextIcon, addplayeranswerIcon;
+	QPixmap rmplayeranswerIcon, setplayeranswertextIcon;
+	QPixmap answerUpIcon, answerDownIcon;
+
+	setalientextIcon = QPixmap(setalientext_xpm);
+	addplayeranswerIcon = QPixmap(addplayeranswer_xpm);
+	rmplayeranswerIcon = QPixmap(rmplayeranswer_xpm);
+	setplayeranswertextIcon = QPixmap(setplayeranswertext_xpm);
+	answerUpIcon = QPixmap(answerup_xpm);
+	answerDownIcon = QPixmap(answerdown_xpm);
+
+	QPopupMenu * edit = new QPopupMenu( this );
+    menuBar()->insertItem( "&Edit", edit );
+
+    id = edit->insertItem( setalientextIcon, "Set Alien Text",
+			   this, SLOT(SetAlienTextSlot()), ALT+Key_T );
+
+    edit->setWhatsThis( id, setAlienTextText );
+
+    id = edit->insertItem( addplayeranswerIcon, "Add new player answer",
+			   this, SLOT(AddNewPlayerAnswerSlot()), ALT+Key_A );
+    edit->setWhatsThis( id, addNewPlayerAnswerText );
+
+
+	id = edit->insertItem( rmplayeranswerIcon, "Remove player answer",
+			   this, SLOT(RemovePlayerAnswerSlot()), ALT+Key_R );
+
+    edit->setWhatsThis( id, removePlayerAnswerText );
+
+    id = edit->insertItem( setplayeranswertextIcon, "Set Player Answer Text",
+			   this, SLOT(SetPlayerAnswerTextSlot()), ALT+Key_F );
+    edit->setWhatsThis( id, setPlayerAnswerTextText );
+
+	id = edit->insertItem( answerUpIcon, "Move answer Up",
+			   this, SLOT(answerUpSlot()), 0 );
+    edit->setWhatsThis( id, answerUpText );
+
+	id = edit->insertItem( answerDownIcon, "Move answer down",
+			   this, SLOT(answerDownSlot()), 0 );
+    edit->setWhatsThis( id, answerDownText );
+
+}
+
+void ApplicationWindow::InitEditTools()
+{
+	WriteLog("ApplicationWindow::InitEditTools()\n");
+    QPixmap setalientextIcon, addplayeranswerIcon;
+	QPixmap rmplayeranswerIcon, setplayeranswertextIcon;
+	QPixmap answerUpIcon, answerDownIcon;
+
+	setalientextIcon = QPixmap(setalientext_xpm);
+	addplayeranswerIcon = QPixmap(addplayeranswer_xpm);
+	rmplayeranswerIcon = QPixmap(rmplayeranswer_xpm);
+	setplayeranswertextIcon = QPixmap(setplayeranswertext_xpm);
+	answerUpIcon = QPixmap(answerup_xpm);
+	answerDownIcon = QPixmap(answerdown_xpm);
+
+	editTools = new QToolBar( this, "edit operations" );
+    editTools->setLabel( tr( "Edit Operations" ) );
+
+	QToolButton * setAlienText
+	= new QToolButton( setalientextIcon, "Set Alien Text", QString::null,
+			   this, SLOT(SetAlienTextSlot()), editTools, "open file" );
+
+    QToolButton * addPlayerAnswer
+	= new QToolButton( addplayeranswerIcon, "Add new player answer", QString::null,
+			   this, SLOT(AddNewPlayerAnswerSlot()), editTools, "open file" );
+
+	QToolButton * removePlayerAnswer
+	= new QToolButton( rmplayeranswerIcon, "Remove player answer", QString::null,
+			   this, SLOT(RemovePlayerAnswerSlot()), editTools, "open file" );
+
+	QToolButton * setPlayerAnswer
+	= new QToolButton( setplayeranswertextIcon, "Set Player Answer Text", QString::null,
+			   this, SLOT(SetPlayerAnswerTextSlot()), editTools, "save file" );
+
+	QToolButton * answerUp
+	= new QToolButton( answerUpIcon, "Move Answer up", QString::null,
+			   this, SLOT(answerUpSlot()), editTools, "save file" );
+
+	QToolButton * answerDown
+	= new QToolButton( answerDownIcon, "Move Unswer down", QString::null,
+			   this, SLOT(answerDownSlot()), editTools, "save file" );
+
+	QWhatsThis::add( setAlienText, setAlienTextText );
+    QWhatsThis::add( addPlayerAnswer, addNewPlayerAnswerText );
+    QWhatsThis::add( removePlayerAnswer, removePlayerAnswerText );
+	QWhatsThis::add( setPlayerAnswer, setPlayerAnswerTextText );
+	QWhatsThis::add( answerUp, answerUpText );
+	QWhatsThis::add( answerDown, answerDownText );
+}
+
+void ApplicationWindow::InitTestMenu()
+{
+	WriteLog("ApplicationWindow::InitTestMenu()\n");
+	int id;
+	QPixmap evalanswerIcon;
+    evalanswerIcon = QPixmap( evalanswer_xpm );
+
+	QPopupMenu * test = new QPopupMenu( this );
+    menuBar()->insertItem( "&Test", test );
+
+    id = test->insertItem( evalanswerIcon, "Evaluate answer",
+			   this, SLOT(evaluateAnswerSlot()), CTRL+Key_R );
+    test->setWhatsThis( id, evaluateAnswerText );
+}
+
+void ApplicationWindow::InitTestTools()
+{
+	WriteLog("ApplicationWindow::InitTestTools()\n");
+	QPixmap evalanswerIcon;
+    evalanswerIcon = QPixmap( evalanswer_xpm );
+
+	testTools = new QToolBar( this, "Dialog Test" );
+    testTools->setLabel( tr( "Dialog Test" ) );
+
+    QToolButton * evalAnswer
+	= new QToolButton( evalanswerIcon, "Evaluate answer", QString::null,
+			   this, SLOT(evaluateAnswerSlot()), testTools, "open file" );
+
+
+//	QWhatsThis::add( hideNotAllowed, hideNotAllowedAnswersText );
+    QWhatsThis::add( evalAnswer, evaluateAnswerText );
+};
+
+void ApplicationWindow::InitHelpMenu()
+{
+	WriteLog("ApplicationWindow::InitHelpMenu()\n");
+	QPopupMenu * help = new QPopupMenu( this );
+    menuBar()->insertSeparator();
+    menuBar()->insertItem( "&Help", help );
+
+    help->insertItem( "&About", this, SLOT(about()), Key_F1 );
+    help->insertSeparator();
+    help->insertItem( "What's &This", this, SLOT(whatsThis()), SHIFT+Key_F1 );
+}
+
+
+void ApplicationWindow::InitHelpTools()
+{
+	WriteLog("ApplicationWindow::InitHelpTools()\n");
+	helpTools = new QToolBar( this, "What is this" );
+    helpTools->setLabel( tr( "What is this" ) );
+
+	(void)QWhatsThis::whatsThisButton( helpTools );
+}
+
+
+void ApplicationWindow::newDoc()
+{
+	WriteLog("ApplicationWindow::newDoc()\n");
+    ApplicationWindow *ed = new ApplicationWindow;
+    ed->setCaption("TW-Light Dialog Editor");
+    ed->show();
+}
+
+void ApplicationWindow::load()
+{
+	WriteLog("ApplicationWindow::load()\n");
+    QString fn = QFileDialog::getOpenFileName( QString::null, "XML files (*.xml)",
+					       this);
+    if ( !fn.isEmpty() )
+	load( fn );
+    else
+	statusBar()->message( "Loading aborted", 2000 );
+}
+
+
+void ApplicationWindow::load( QString fileName )
+{
+	WriteLog("ApplicationWindow::load( const char *fileName )");
+	e->loadDoc(fileName);
+	strXML = e->GetXML();
+
+	filename = fileName;
+    setCaption( fileName );
+    QString s;
+    s.sprintf( "Loaded document %s", fileName );
+    statusBar()->message( s, 2000 );
+}
+
+
+void ApplicationWindow::save()
+{
+	WriteLog("ApplicationWindow::save()");
+    if ( filename.isEmpty() ) {
+	saveAs();
+	return;
+    }
+
+    QString text = e->GetXML();
+    QFile f( filename );
+    if ( !f.open( IO_WriteOnly ) ) {
+	statusBar()->message( QString("Could not write to %1").arg(filename),
+			      2000 );
+	return;
+    }
+
+    QTextStream t( &f );
+    t << text;
+    f.close();
+
+    strXML = text;
+
+    setCaption( filename );
+    statusBar()->message( QString( "File %1 saved" ).arg( filename ), 2000 );
+}
+
+
+void ApplicationWindow::saveAs()
+{
+	WriteLog("ApplicationWindow::saveAs()");
+    QString fn = QFileDialog::getSaveFileName( QString::null, "XML files (*.xml)",
+					       this );
+    if ( !fn.isEmpty() ) {
+		if(fn.find(".xml", 0, FALSE)==-1)
+		{
+			fn += ".xml";
+		}
+	filename = fn;
+	save();
+    } else {
+	statusBar()->message( "Saving aborted", 2000 );
+    }
+}
+
+void ApplicationWindow::closeEvent( QCloseEvent* ce )
+{
+	WriteLog("ApplicationWindow::closeEvent( QCloseEvent* ce )\n");
+	if ( strXML == e->GetXML() ) {
+	ce->accept();
+	return;
+    }
+
+    switch( QMessageBox::information( this, "TW-Light Dialog Editor",
+				      "The document has been changed since "
+				      "the last save.",
+				      "Save Now", "Cancel", "Leave Anyway",
+				      0, 1 ) ) {
+    case 0:
+	save();
+	ce->accept();
+	break;
+    case 1:
+    default: // just for sanity
+	ce->ignore();
+	break;
+    case 2:
+	ce->accept();
+	break;
+    }
+}
+
+// node
+void ApplicationWindow::AddNewNodeSlot()
+{
+	WriteLog("ApplicationWindow::AddNewNodeSlot()\n");
+	e->CreateNewNode();
+}
+
+void ApplicationWindow::RemoveNodeSlot()
+{
+	WriteLog("ApplicationWindow::RemoveNodeSlot()\n");
+	e->removeNode();
+}
+
+// edit
+void ApplicationWindow::SetAlienTextSlot()
+{
+	WriteLog("ApplicationWindow::SetAlienTextSlot()\n");
+	e->setAlienText();
+}
+
+void ApplicationWindow::AddNewPlayerAnswerSlot()
+{
+	WriteLog("ApplicationWindow::AddNewPlayerAnswerSlot()\n");
+	e->AddPlayerAnswer();
+}
+
+void ApplicationWindow::RemovePlayerAnswerSlot()
+{
+	WriteLog("ApplicationWindow::RemovePlayerAnswerSlot()\n");
+	e->removeAnswer();
+}
+
+void ApplicationWindow::SetPlayerAnswerTextSlot()
+{
+	WriteLog("ApplicationWindow::SetPlayerAnswerTextSlot()\n");
+	e->setPlayerAnswerText();
+}
+
+void ApplicationWindow::answerUpSlot()
+{
+	e->answerUp();
+}
+
+void ApplicationWindow::answerDownSlot()
+{
+	e->answerDown();
+}
+
+
+// Test
+void ApplicationWindow::hideNotAllowedAnswersSlot()
+{
+	WriteLog("ApplicationWindow::hideNotAllowedAnswersSlot()\n");
+		QMessageBox::information( this, "hideNotAllowedAnswersSlot",
+                              "Not implemented yet");
+}
+void ApplicationWindow::evaluateAnswerSlot()
+{
+	WriteLog("ApplicationWindow::evaluateAnswerSlot()\n");
+	QListViewItem * answ = e->answersListView->currentItem();
+	if(answ)
+		e->processAnswerSlot(answ);
+}
+
+// Help
+void ApplicationWindow::about()
+{
+	WriteLog("ApplicationWindow::about()\n");
+    QMessageBox::about( this, "TW-Light Dialog Editor",
+			"Copyright (C) 2004 Yura Semasko aka Yurand.\n"
+			"http://www.tw-light.berlios.de yurand at land.ru\n\n"
+			"This program is free software; you can redistribute\n"
+			"it and/or modify it under the terms of the GNU General\n"
+			"Public License as published by the Free Software\n"
+			"Foundation; either version 2 of the License, or (at \n"
+			"your option) any later version.");
+}
+

Added: trunk/Util/deditor/application.h
===================================================================
--- trunk/Util/deditor/application.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/application.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,75 @@
+
+#ifndef APPLICATION_H
+#define APPLICATION_H
+
+#include <qmainwindow.h>
+
+class DialogEditor;
+class QToolBar;
+class QPopupMenu;
+
+class ApplicationWindow: public QMainWindow
+{
+    Q_OBJECT
+public:
+    ApplicationWindow();
+    ~ApplicationWindow();
+    
+protected:
+    void closeEvent( QCloseEvent* );
+
+	void InitFileTools();
+	void InitNodeManagerTools();
+	void InitEditTools();
+	void InitTestTools();
+	void InitHelpTools();
+
+	void InitFileMenu();
+	void InitNodeManagerMenu();
+	void InitEditMenu();
+	void InitTestMenu();
+	void InitHelpMenu();
+
+private slots:
+	// file 
+    void newDoc();
+    void load();
+    void load( QString fileName );
+    void save();
+    void saveAs();
+   
+	// node
+	void AddNewNodeSlot();
+	void RemoveNodeSlot();
+
+	// edit
+	void SetAlienTextSlot();
+	void AddNewPlayerAnswerSlot();
+	void RemovePlayerAnswerSlot();
+	void SetPlayerAnswerTextSlot();
+
+	void answerUpSlot();
+	void answerDownSlot();
+
+	// test
+	void hideNotAllowedAnswersSlot();
+	void evaluateAnswerSlot();
+
+	// about
+    void about();
+
+private:
+	QString strXML;
+
+    DialogEditor *e;
+    QToolBar *fileTools;
+	QToolBar *nodeTools;
+	QToolBar *editTools;
+	QToolBar *testTools;
+	QToolBar *helpTools;
+
+    QString filename;
+};
+
+
+#endif

Added: trunk/Util/deditor/book.png
===================================================================
(Binary files differ)


Property changes on: trunk/Util/deditor/book.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/Util/deditor/createnode.xpm
===================================================================
--- trunk/Util/deditor/createnode.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/createnode.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *createnode_xpm[] = {
+"    16    13        5            1",
+". c #040404",
+"# c #808304",
+"a c None",
+"b c #f3f704",
+"c c #f3f7f3",
+"................",
+"................",
+"......a....a....",
+"..bb..a....a....",
+".b..b.aa...a....",
+".b....a.a..a....",
+".b....a.a..a....",
+".b..b.a..a.a....",
+"..bb..a..a.a....",
+"......a...aa....",
+"................",
+"................",
+"................"
+};

Added: trunk/Util/deditor/dialog.xml
===================================================================
--- trunk/Util/deditor/dialog.xml	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/dialog.xml	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,2 @@
+<NODES><NODE id="0" name="Start" music="" background="a.png" alien_text="TW-Light Dialog Editor. 
+   &lt;br&gt; Test dialog" font="" text_location=""><PLAYER_ANSWER text="We come in peace" appear_condition="1"><ACTION condition="1" action="goto(&quot;2&quot;)"></ACTION></PLAYER_ANSWER><PLAYER_ANSWER text="Die supid alien!" appear_condition="1"><ACTION condition="1" action="goto(&quot;1&quot;)"></ACTION></PLAYER_ANSWER></NODE><NODE id="1" name="Batte" music="" background="" alien_text="You have bad manners, die" font="" text_location=""><PLAYER_ANSWER text="Ok!!" appear_condition="1"></PLAYER_ANSWER></NODE><NODE id="2" name="Bye" music="" background="a.png" alien_text="Have to go, sorry" font="" text_location=""><PLAYER_ANSWER text="Bye" appear_condition="1"></PLAYER_ANSWER></NODE></NODES>
\ No newline at end of file

Added: trunk/Util/deditor/dialogeditor.dsp
===================================================================
--- trunk/Util/deditor/dialogeditor.dsp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/dialogeditor.dsp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,363 @@
+# Microsoft Developer Studio Project File - Name="dialogeditor" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Application" 0x0101
+
+CFG=dialogeditor - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "dialogeditor.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "dialogeditor.mak" CFG="dialogeditor - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "dialogeditor - Win32 Release" (based on "Win32 (x86) Application")
+!MESSAGE "dialogeditor - Win32 Debug" (based on "Win32 (x86) Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+MTL=midl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "dialogeditor - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /I "./lua" /D "NDEBUG" /D "WIN32" /D "_WINDOWS" /D "_MBCS" /D "QT_DLL" /D "QT_THREAD_SUPPORT" /YX /FD /c
+# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x423 /d "NDEBUG"
+# ADD RSC /l 0x423 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386
+# ADD LINK32 qt-mt230nc.lib qtmain.lib qutil.lib /nologo /subsystem:windows /machine:I386
+
+!ELSEIF  "$(CFG)" == "dialogeditor - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "./lua" /D "_DEBUG" /D "WIN32" /D "_WINDOWS" /D "_MBCS" /D "QT_DLL" /D "QT_THREAD_SUPPORT" /YX /FD /GZ /c
+# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x423 /d "_DEBUG"
+# ADD RSC /l 0x423 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 qt-mt230nc.lib qtmain.lib qutil.lib /nologo /subsystem:windows /debug /machine:I386 /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "dialogeditor - Win32 Release"
+# Name "dialogeditor - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\application.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\application.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\helpers.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\helpers.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\main.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\mainwidget.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\mainwidget.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\node.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\node.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\xmlparser.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\xmlparser.h
+# End Source File
+# End Group
+# Begin Group "Resource Files"
+
+# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
+# End Group
+# Begin Group "generated"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\maindialog.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\maindialog.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\moc_application.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\moc_maindialog.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\moc_node.cpp
+# End Source File
+# End Group
+# Begin Group "lua"
+
+# PROP Default_Filter ""
+# Begin Group "lib"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\lua\lib\lauxlib.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lib\lbaselib.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lib\ldblib.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lib\liolib.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lib\lmathlib.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lib\loadlib.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lib\lstrlib.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lib\ltablib.c
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=.\lua\lapi.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lapi.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lcode.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lcode.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ldebug.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ldebug.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ldo.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ldo.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ldump.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lfunc.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lfunc.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lgc.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lgc.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\llex.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\llex.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\llimits.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lmem.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lmem.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lobject.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lobject.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lopcodes.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lopcodes.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lparser.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lparser.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lstate.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lstate.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lstring.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lstring.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ltable.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ltable.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ltests.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ltm.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ltm.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lundump.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lundump.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lvm.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lvm.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lzio.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lzio.h
+# End Source File
+# End Group
+# End Target
+# End Project

Added: trunk/Util/deditor/dialogeditor.dsw
===================================================================
--- trunk/Util/deditor/dialogeditor.dsw	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/dialogeditor.dsw	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,29 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "dialogeditor"=".\dialogeditor.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+

Added: trunk/Util/deditor/dialogeditor.ncb
===================================================================
(Binary files differ)


Property changes on: trunk/Util/deditor/dialogeditor.ncb
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/Util/deditor/dialogeditor.opt
===================================================================
(Binary files differ)


Property changes on: trunk/Util/deditor/dialogeditor.opt
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/Util/deditor/dialogeditor.plg
===================================================================
--- trunk/Util/deditor/dialogeditor.plg	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/dialogeditor.plg	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,145 @@
+<html>
+<body>
+<pre>
+<h1>Build Log</h1>
+<h3>
+--------------------Configuration: dialogeditor - Win32 Release--------------------
+</h3>
+<h3>Command Lines</h3>
+Creating temporary file "C:\DOCUME~1\Yura\LOCALS~1\Temp\RSPF.tmp" with contents
+[
+/nologo /ML /W3 /GX /O2 /I "./lua" /D "NDEBUG" /D "WIN32" /D "_WINDOWS" /D "_MBCS" /D "QT_DLL" /D "QT_THREAD_SUPPORT" /Fp"Release/dialogeditor.pch" /YX /Fo"Release/" /Fd"Release/" /FD /c 
+"C:\Projects\TW-Light Dialog Editor\application.cpp"
+"C:\Projects\TW-Light Dialog Editor\helpers.cpp"
+"C:\Projects\TW-Light Dialog Editor\main.cpp"
+"C:\Projects\TW-Light Dialog Editor\mainwidget.cpp"
+"C:\Projects\TW-Light Dialog Editor\node.cpp"
+"C:\Projects\TW-Light Dialog Editor\xmlparser.cpp"
+"C:\Projects\TW-Light Dialog Editor\maindialog.cpp"
+"C:\Projects\TW-Light Dialog Editor\moc_application.cpp"
+"C:\Projects\TW-Light Dialog Editor\moc_maindialog.cpp"
+"C:\Projects\TW-Light Dialog Editor\moc_node.cpp"
+"C:\Projects\TW-Light Dialog Editor\lua\lib\lauxlib.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lib\lbaselib.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lib\ldblib.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lib\liolib.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lib\lmathlib.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lib\loadlib.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lib\lstrlib.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lib\ltablib.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lapi.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lcode.c"
+"C:\Projects\TW-Light Dialog Editor\lua\ldebug.c"
+"C:\Projects\TW-Light Dialog Editor\lua\ldo.c"
+"C:\Projects\TW-Light Dialog Editor\lua\ldump.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lfunc.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lgc.c"
+"C:\Projects\TW-Light Dialog Editor\lua\llex.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lmem.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lobject.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lopcodes.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lparser.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lstate.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lstring.c"
+"C:\Projects\TW-Light Dialog Editor\lua\ltable.c"
+"C:\Projects\TW-Light Dialog Editor\lua\ltests.c"
+"C:\Projects\TW-Light Dialog Editor\lua\ltm.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lundump.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lvm.c"
+"C:\Projects\TW-Light Dialog Editor\lua\lzio.c"
+]
+Creating command line "cl.exe @C:\DOCUME~1\Yura\LOCALS~1\Temp\RSPF.tmp" 
+Creating temporary file "C:\DOCUME~1\Yura\LOCALS~1\Temp\RSP10.tmp" with contents
+[
+qt-mt230nc.lib qtmain.lib qutil.lib /nologo /subsystem:windows /incremental:no /pdb:"Release/dialogeditor.pdb" /machine:I386 /out:"Release/dialogeditor.exe" 
+".\Release\application.obj"
+".\Release\helpers.obj"
+".\Release\main.obj"
+".\Release\mainwidget.obj"
+".\Release\node.obj"
+".\Release\xmlparser.obj"
+".\Release\maindialog.obj"
+".\Release\moc_application.obj"
+".\Release\moc_maindialog.obj"
+".\Release\moc_node.obj"
+".\Release\lauxlib.obj"
+".\Release\lbaselib.obj"
+".\Release\ldblib.obj"
+".\Release\liolib.obj"
+".\Release\lmathlib.obj"
+".\Release\loadlib.obj"
+".\Release\lstrlib.obj"
+".\Release\ltablib.obj"
+".\Release\lapi.obj"
+".\Release\lcode.obj"
+".\Release\ldebug.obj"
+".\Release\ldo.obj"
+".\Release\ldump.obj"
+".\Release\lfunc.obj"
+".\Release\lgc.obj"
+".\Release\llex.obj"
+".\Release\lmem.obj"
+".\Release\lobject.obj"
+".\Release\lopcodes.obj"
+".\Release\lparser.obj"
+".\Release\lstate.obj"
+".\Release\lstring.obj"
+".\Release\ltable.obj"
+".\Release\ltests.obj"
+".\Release\ltm.obj"
+".\Release\lundump.obj"
+".\Release\lvm.obj"
+".\Release\lzio.obj"
+]
+Creating command line "link.exe @C:\DOCUME~1\Yura\LOCALS~1\Temp\RSP10.tmp"
+<h3>Output Window</h3>
+Compiling...
+application.cpp
+helpers.cpp
+main.cpp
+mainwidget.cpp
+C:\Projects\TW-Light Dialog Editor\mainwidget.cpp(495) : warning C4018: '==' : signed/unsigned mismatch
+node.cpp
+xmlparser.cpp
+maindialog.cpp
+moc_application.cpp
+moc_maindialog.cpp
+moc_node.cpp
+lauxlib.c
+lbaselib.c
+ldblib.c
+liolib.c
+lmathlib.c
+loadlib.c
+lstrlib.c
+ltablib.c
+lapi.c
+lcode.c
+ldebug.c
+ldo.c
+ldump.c
+lfunc.c
+lgc.c
+llex.c
+lmem.c
+lobject.c
+lopcodes.c
+lparser.c
+lstate.c
+lstring.c
+ltable.c
+ltests.c
+ltm.c
+lundump.c
+lvm.c
+lzio.c
+Linking...
+LIBC.lib(crt0init.obj) : warning LNK4098: defaultlib "msvcrt.lib" conflicts with use of other libs; use /NODEFAULTLIB:library
+
+
+
+<h3>Results</h3>
+dialogeditor.exe - 0 error(s), 2 warning(s)
+</pre>
+</body>
+</html>

Added: trunk/Util/deditor/dialogeditor.sln
===================================================================
--- trunk/Util/deditor/dialogeditor.sln	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/dialogeditor.sln	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,21 @@
+Microsoft Visual Studio Solution File, Format Version 8.00
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "dialogeditor", "dialogeditor.vcproj", "{62A63641-279C-47A0-9F16-C166FB146EE6}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfiguration) = preSolution
+		Debug = Debug
+		Release = Release
+	EndGlobalSection
+	GlobalSection(ProjectConfiguration) = postSolution
+		{62A63641-279C-47A0-9F16-C166FB146EE6}.Debug.ActiveCfg = Debug|Win32
+		{62A63641-279C-47A0-9F16-C166FB146EE6}.Debug.Build.0 = Debug|Win32
+		{62A63641-279C-47A0-9F16-C166FB146EE6}.Release.ActiveCfg = Release|Win32
+		{62A63641-279C-47A0-9F16-C166FB146EE6}.Release.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+	EndGlobalSection
+	GlobalSection(ExtensibilityAddIns) = postSolution
+	EndGlobalSection
+EndGlobal

Added: trunk/Util/deditor/dialogeditor.suo
===================================================================
(Binary files differ)


Property changes on: trunk/Util/deditor/dialogeditor.suo
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/Util/deditor/dialogeditor.vcproj
===================================================================
--- trunk/Util/deditor/dialogeditor.vcproj	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/dialogeditor.vcproj	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,300 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="dialogeditor"
+	SccProjectName=""
+	SccLocalPath="">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="c:\qt\include"
+				PreprocessorDefinitions="QT_DLL;QT_THREAD_SUPPORT"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="5"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderFile=".\Debug/dialogeditor.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="qt-mt230nc.lib qtmain.lib qutil.lib"
+				OutputFile=".\Debug/dialogeditor.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="c:\qt\lib"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile=".\Debug/dialogeditor.pdb"
+				SubSystem="2"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"
+				PreprocessorDefinitions="_DEBUG"
+				MkTypLibCompatible="TRUE"
+				SuppressStartupBanner="TRUE"
+				TargetEnvironment="1"
+				TypeLibraryName=".\Debug/dialogeditor.tlb"
+				HeaderFileName=""/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1059"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="c:\qt\include"
+				PreprocessorDefinitions="QT_DLL;QT_THREAD_SUPPORT"
+				StringPooling="TRUE"
+				RuntimeLibrary="4"
+				EnableFunctionLevelLinking="TRUE"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderFile=".\Release/dialogeditor.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="qt-mt230nc.lib qtmain.lib qutil.lib"
+				OutputFile=".\Release/dialogeditor.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="c:\qt\lib"
+				ProgramDatabaseFile=".\Release/dialogeditor.pdb"
+				SubSystem="2"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"
+				PreprocessorDefinitions="NDEBUG"
+				MkTypLibCompatible="TRUE"
+				SuppressStartupBanner="TRUE"
+				TargetEnvironment="1"
+				TypeLibraryName=".\Release/dialogeditor.tlb"
+				HeaderFileName=""/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1059"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
+			<File
+				RelativePath="application.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="application.h">
+			</File>
+			<File
+				RelativePath="main.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="mainwidget.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="mainwidget.h">
+			</File>
+			<File
+				RelativePath="node.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="node.h">
+			</File>
+		</Filter>
+		<Filter
+			Name="generated"
+			Filter="">
+			<File
+				RelativePath="maindialog.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="maindialog.h">
+			</File>
+			<File
+				RelativePath="moc_application.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="moc_maindialog.cpp">
+				<FileConfiguration
+					Name="Debug|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="0"
+						PreprocessorDefinitions=""
+						BasicRuntimeChecks="3"/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32">
+					<Tool
+						Name="VCCLCompilerTool"
+						Optimization="2"
+						PreprocessorDefinitions=""/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>

Added: trunk/Util/deditor/evalanswer.xpm
===================================================================
--- trunk/Util/deditor/evalanswer.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/evalanswer.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *evalanswer_xpm[] = {
+"    16    13        5            1",
+". c #040404",
+"# c #808304",
+"a c None",
+"b c #00000",
+"c c #f3f7f3",
+"aaaaaa...aaaaaaa",
+"aaaaaa...aaaaaaa",
+"aaca.......aacaa",
+"aa..aa...aa..aaa",
+"a.aaca...aaaa.aa",
+"a.aaac...aaaa.aa",
+"aa.aaa...aaa.aaa",
+"aaa..a...a..aaaa",
+"aaaaa.....aaaaaa",
+"aaaaaa...aaaaaaa",
+"aaaaac...aaaaaaa",
+"aaaaaa...aaaaaaa",
+"aaaaaa...aaaaaaa"
+};

Added: trunk/Util/deditor/fileopen.xpm
===================================================================
--- trunk/Util/deditor/fileopen.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/fileopen.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *fileopen[] = {
+"    16    13        5            1",
+". c #040404",
+"# c #808304",
+"a c None",
+"b c #f3f704",
+"c c #f3f7f3",
+"aaaaaaaaa...aaaa",
+"aaaaaaaa.aaa.a.a",
+"aaaaaaaaaaaaa..a",
+"a...aaaaaaaa...a",
+".bcb.......aaaaa",
+".cbcbcbcbc.aaaaa",
+".bcbcbcbcb.aaaaa",
+".cbcb...........",
+".bcb.#########.a",
+".cb.#########.aa",
+".b.#########.aaa",
+"..#########.aaaa",
+"...........aaaaa"
+};

Added: trunk/Util/deditor/filesave.xpm
===================================================================
--- trunk/Util/deditor/filesave.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/filesave.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *filesave[] = {
+"    14    14        4            1",
+". c #040404",
+"# c #808304",
+"a c #bfc2bf",
+"b c None",
+"..............",
+".#.aaaaaaaa.a.",
+".#.aaaaaaaa...",
+".#.aaaaaaaa.#.",
+".#.aaaaaaaa.#.",
+".#.aaaaaaaa.#.",
+".#.aaaaaaaa.#.",
+".##........##.",
+".############.",
+".##.........#.",
+".##......aa.#.",
+".##......aa.#.",
+".##......aa.#.",
+"b............."
+};

Added: trunk/Util/deditor/gui.bat
===================================================================
--- trunk/Util/deditor/gui.bat	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/gui.bat	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,5 @@
+uic -o maindialog.h MainDialog.ui
+uic -i maindialog.h -o maindialog.cpp MainDialog.ui
+moc -o moc_maindialog.cpp maindialog.h
+moc -o moc_application.cpp application.h
+moc -o moc_node.cpp node.h

Added: trunk/Util/deditor/helpers.cpp
===================================================================
--- trunk/Util/deditor/helpers.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/helpers.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,33 @@
+#include <qstring.h>
+#include <qregexp.h>
+#include <qdir.h>
+#include <qmessagebox.h>
+
+#include <stdio.h>
+
+static FILE * log = NULL;
+static int log_inited = 0;
+
+void WriteLog(QString str)
+{
+	if(!log_inited)
+	{
+		log_inited = 1;
+		log = fopen(QDir::currentDirPath() + "/dedit.log", "w+");
+	}
+	if(log)
+	{
+		fprintf(log, "%s", (const char*)str);
+		fflush(log);
+	}
+}
+
+QString TWEscapeXML(QString str)
+{
+	str.replace(QRegExp("&"),"&amp;");
+	str.replace(QRegExp(">"),"&gt;");
+	str.replace(QRegExp("<"),"&lt;");
+	str.replace(QRegExp("\""),"&quot;");
+
+	return str;
+}
\ No newline at end of file

Added: trunk/Util/deditor/helpers.h
===================================================================
--- trunk/Util/deditor/helpers.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/helpers.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,10 @@
+#ifndef __TW_HELPERS_H__
+#define __TW_HELPERS_H__
+
+#include <qstring.h>
+
+
+QString TWEscapeXML(QString str);
+void WriteLog(QString str);
+
+#endif

Added: trunk/Util/deditor/itemdown.xpm
===================================================================
--- trunk/Util/deditor/itemdown.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/itemdown.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *answerdown_xpm[] = {
+"    16    13        5            1",
+". c #040404",
+"# c #808304",
+"a c None",
+"b c #ffff00",
+"c c #00ffff",
+"aaaaaaaaaaaaaaaa",
+"aaaaaaaaaaaaaaaa",
+"aaaaaaaaaaaaaaaa",
+"aaaaaaaaaaaaaaaa",
+"..aaaaaaaaaaa..a",
+"..aaaaaaaaaaa..a",
+"a..aaaaaaaaa..aa",
+"aa..aaaaaaa..aaa",
+"aaa..aaaaa..aaaa",
+"aaaa..aaa..aaaaa",
+"aaaaa..a..aaaaaa",
+"aaaaaa...aaaaaaa",
+"aaaaaaa.aaaaaaaa"
+};

Added: trunk/Util/deditor/itemup.xpm
===================================================================
--- trunk/Util/deditor/itemup.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/itemup.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *answerup_xpm[] = {
+"    16    13        5            1",
+". c #040404",
+"# c #808304",
+"a c None",
+"b c #ffff00",
+"c c #00ffff",
+"aaaaaaaa.aaaaaaa",
+"aaaaaaa...aaaaaa",
+"aaaaaa..a..aaaaa",
+"aaaaa..aaa..aaaa",
+"aaaa..aaaaa..aaa",
+"aaa..aaaaaaa..aa",
+"aa..aaaaaaaaa..a",
+"a..aaaaaaaaaaa..",
+"aaaaaaaaaaaaaaaa",
+"aaaaaaaaaaaaaaaa",
+"aaaaaaaaaaaaaaaa",
+"aaaaaaaaaaaaaaaa",
+"aaaaaaaaaaaaaaaa"
+};

Added: trunk/Util/deditor/lua/Makefile
===================================================================
--- trunk/Util/deditor/lua/Makefile	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/Makefile	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,85 @@
+# makefile for Lua core library
+
+LUA= ..
+
+include $(LUA)/config
+
+OBJS=	\
+	lapi.o \
+	lcode.o \
+	ldebug.o \
+	ldo.o \
+	ldump.o \
+	lfunc.o \
+	lgc.o \
+	llex.o \
+	lmem.o \
+	lobject.o \
+	lopcodes.o \
+	lparser.o \
+	lstate.o \
+	lstring.o \
+	ltable.o \
+	ltests.o \
+	ltm.o \
+	lundump.o \
+	lvm.o \
+	lzio.o
+
+SRCS=	\
+	lapi.c \
+	lcode.c \
+	ldebug.c \
+	ldo.c \
+	ldump.c \
+	lfunc.c \
+	lgc.c \
+	llex.c \
+	lmem.c \
+	lobject.c \
+	lopcodes.c \
+	lparser.c \
+	lstate.c \
+	lstring.c \
+	ltable.c \
+	ltests.c \
+	ltm.c \
+	lundump.c \
+	lvm.c \
+	lzio.c \
+	lapi.h \
+	lcode.h \
+	ldebug.h \
+	ldo.h \
+	lfunc.h \
+	lgc.h \
+	llex.h \
+	llimits.h \
+	lmem.h \
+	lobject.h \
+	lopcodes.h \
+	lparser.h \
+	lstate.h \
+	lstring.h \
+	ltable.h \
+	ltm.h \
+	lundump.h \
+	lvm.h \
+	lzio.h
+
+T= $(LIB)/liblua.a
+
+all:	$T
+
+$T:	$(OBJS)
+	$(AR) $@ $(OBJS)
+	$(RANLIB) $@
+
+clean:
+	rm -f $(OBJS) $T
+
+co:
+	co -q -f -M $(SRCS)
+
+klean:	clean
+	rm -f $(SRCS)

Added: trunk/Util/deditor/lua/README
===================================================================
--- trunk/Util/deditor/lua/README	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/README	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,5 @@
+This is the Lua core.
+
+The standard Lua library are in lib/.
+A sample interpreter is in lua/.
+A standalone compiler is in luac/.

Added: trunk/Util/deditor/lua/lapi.c
===================================================================
--- trunk/Util/deditor/lua/lapi.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lapi.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,922 @@
+/*
+** $Id: lapi.c,v 1.235 2003/04/07 14:36:08 roberto Exp $
+** Lua API
+** See Copyright Notice in lua.h
+*/
+
+
+#include <assert.h>
+#include <string.h>
+
+#define lapi_c
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lundump.h"
+#include "lvm.h"
+
+
+const char lua_ident[] =
+  "$Lua: " LUA_VERSION " " LUA_COPYRIGHT " $\n"
+  "$Authors: " LUA_AUTHORS " $\n"
+  "$URL: www.lua.org $\n";
+
+
+
+#ifndef api_check
+#define api_check(L, o)		/*{ assert(o); }*/
+#endif
+
+#define api_checknelems(L, n)	api_check(L, (n) <= (L->top - L->base))
+
+#define api_incr_top(L)   {api_check(L, L->top < L->ci->top); L->top++;}
+
+
+
+
+static TObject *negindex (lua_State *L, int idx) {
+  if (idx > LUA_REGISTRYINDEX) {
+    api_check(L, idx != 0 && -idx <= L->top - L->base);
+    return L->top+idx;
+  }
+  else switch (idx) {  /* pseudo-indices */
+    case LUA_REGISTRYINDEX: return registry(L);
+    case LUA_GLOBALSINDEX: return gt(L);
+    default: {
+      TObject *func = (L->base - 1);
+      idx = LUA_GLOBALSINDEX - idx;
+      lua_assert(iscfunction(func));
+      return (idx <= clvalue(func)->c.nupvalues)
+                ? &clvalue(func)->c.upvalue[idx-1]
+                : NULL;
+    }
+  }
+}
+
+
+static TObject *luaA_index (lua_State *L, int idx) {
+  if (idx > 0) {
+    api_check(L, idx <= L->top - L->base);
+    return L->base + idx - 1;
+  }
+  else {
+    TObject *o = negindex(L, idx);
+    api_check(L, o != NULL);
+    return o;
+  }
+}
+
+
+static TObject *luaA_indexAcceptable (lua_State *L, int idx) {
+  if (idx > 0) {
+    TObject *o = L->base+(idx-1);
+    api_check(L, idx <= L->stack_last - L->base);
+    if (o >= L->top) return NULL;
+    else return o;
+  }
+  else
+    return negindex(L, idx);
+}
+
+
+void luaA_pushobject (lua_State *L, const TObject *o) {
+  setobj2s(L->top, o);
+  incr_top(L);
+}
+
+
+LUA_API int lua_checkstack (lua_State *L, int size) {
+  int res;
+  lua_lock(L);
+  if ((L->top - L->base + size) > LUA_MAXCSTACK)
+    res = 0;  /* stack overflow */
+  else {
+    luaD_checkstack(L, size);
+    if (L->ci->top < L->top + size)
+      L->ci->top = L->top + size;
+    res = 1;
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
+  int i;
+  lua_lock(to);
+  api_checknelems(from, n);
+  from->top -= n;
+  for (i = 0; i < n; i++) {
+    setobj2s(to->top, from->top + i);
+    api_incr_top(to);
+  }
+  lua_unlock(to);
+}
+
+
+LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {
+  lua_CFunction old;
+  lua_lock(L);
+  old = G(L)->panic;
+  G(L)->panic = panicf;
+  lua_unlock(L);
+  return old;
+}
+
+
+LUA_API lua_State *lua_newthread (lua_State *L) {
+  lua_State *L1;
+  lua_lock(L);
+  luaC_checkGC(L);
+  L1 = luaE_newthread(L);
+  setthvalue(L->top, L1);
+  api_incr_top(L);
+  lua_unlock(L);
+  lua_userstateopen(L1);
+  return L1;
+}
+
+
+
+/*
+** basic stack manipulation
+*/
+
+
+LUA_API int lua_gettop (lua_State *L) {
+  return (L->top - L->base);
+}
+
+
+LUA_API void lua_settop (lua_State *L, int idx) {
+  lua_lock(L);
+  if (idx >= 0) {
+    api_check(L, idx <= L->stack_last - L->base);
+    while (L->top < L->base + idx)
+      setnilvalue(L->top++);
+    L->top = L->base + idx;
+  }
+  else {
+    api_check(L, -(idx+1) <= (L->top - L->base));
+    L->top += idx+1;  /* `subtract' index (index is negative) */
+  }
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_remove (lua_State *L, int idx) {
+  StkId p;
+  lua_lock(L);
+  p = luaA_index(L, idx);
+  while (++p < L->top) setobjs2s(p-1, p);
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_insert (lua_State *L, int idx) {
+  StkId p;
+  StkId q;
+  lua_lock(L);
+  p = luaA_index(L, idx);
+  for (q = L->top; q>p; q--) setobjs2s(q, q-1);
+  setobjs2s(p, L->top);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_replace (lua_State *L, int idx) {
+  lua_lock(L);
+  api_checknelems(L, 1);
+  setobj(luaA_index(L, idx), L->top - 1);  /* write barrier */
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushvalue (lua_State *L, int idx) {
+  lua_lock(L);
+  setobj2s(L->top, luaA_index(L, idx));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API int lua_type (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  return (o == NULL) ? LUA_TNONE : ttype(o);
+}
+
+
+LUA_API const char *lua_typename (lua_State *L, int t) {
+  UNUSED(L);
+  return (t == LUA_TNONE) ? "no value" : luaT_typenames[t];
+}
+
+
+LUA_API int lua_iscfunction (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  return (o == NULL) ? 0 : iscfunction(o);
+}
+
+
+LUA_API int lua_isnumber (lua_State *L, int idx) {
+  TObject n;
+  const TObject *o = luaA_indexAcceptable(L, idx);
+  return (o != NULL && tonumber(o, &n));
+}
+
+
+LUA_API int lua_isstring (lua_State *L, int idx) {
+  int t = lua_type(L, idx);
+  return (t == LUA_TSTRING || t == LUA_TNUMBER);
+}
+
+
+LUA_API int lua_isuserdata (lua_State *L, int idx) {
+  const TObject *o = luaA_indexAcceptable(L, idx);
+  return (o != NULL && (ttisuserdata(o) || ttislightuserdata(o)));
+}
+
+
+LUA_API int lua_rawequal (lua_State *L, int index1, int index2) {
+  StkId o1 = luaA_indexAcceptable(L, index1);
+  StkId o2 = luaA_indexAcceptable(L, index2);
+  return (o1 == NULL || o2 == NULL) ? 0  /* index out of range */
+                                    : luaO_rawequalObj(o1, o2);
+}
+
+
+LUA_API int lua_equal (lua_State *L, int index1, int index2) {
+  StkId o1, o2;
+  int i;
+  lua_lock(L);  /* may call tag method */
+  o1 = luaA_indexAcceptable(L, index1);
+  o2 = luaA_indexAcceptable(L, index2);
+  i = (o1 == NULL || o2 == NULL) ? 0  /* index out of range */
+                                 : equalobj(L, o1, o2);
+  lua_unlock(L);
+  return i;
+}
+
+
+LUA_API int lua_lessthan (lua_State *L, int index1, int index2) {
+  StkId o1, o2;
+  int i;
+  lua_lock(L);  /* may call tag method */
+  o1 = luaA_indexAcceptable(L, index1);
+  o2 = luaA_indexAcceptable(L, index2);
+  i = (o1 == NULL || o2 == NULL) ? 0  /* index out-of-range */
+                                 : luaV_lessthan(L, o1, o2);
+  lua_unlock(L);
+  return i;
+}
+
+
+
+LUA_API lua_Number lua_tonumber (lua_State *L, int idx) {
+  TObject n;
+  const TObject *o = luaA_indexAcceptable(L, idx);
+  if (o != NULL && tonumber(o, &n))
+    return nvalue(o);
+  else
+    return 0;
+}
+
+
+LUA_API int lua_toboolean (lua_State *L, int idx) {
+  const TObject *o = luaA_indexAcceptable(L, idx);
+  return (o != NULL) && !l_isfalse(o);
+}
+
+
+LUA_API const char *lua_tostring (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  if (o == NULL)
+    return NULL;
+  else if (ttisstring(o))
+    return svalue(o);
+  else {
+    const char *s;
+    lua_lock(L);  /* `luaV_tostring' may create a new string */
+    s = (luaV_tostring(L, o) ? svalue(o) : NULL);
+    luaC_checkGC(L);
+    lua_unlock(L);
+    return s;
+  }
+}
+
+
+LUA_API size_t lua_strlen (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  if (o == NULL)
+    return 0;
+  else if (ttisstring(o))
+    return tsvalue(o)->tsv.len;
+  else {
+    size_t l;
+    lua_lock(L);  /* `luaV_tostring' may create a new string */
+    l = (luaV_tostring(L, o) ? tsvalue(o)->tsv.len : 0);
+    lua_unlock(L);
+    return l;
+  }
+}
+
+
+LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  return (o == NULL || !iscfunction(o)) ? NULL : clvalue(o)->c.f;
+}
+
+
+LUA_API void *lua_touserdata (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  if (o == NULL) return NULL;
+  switch (ttype(o)) {
+    case LUA_TUSERDATA: return (uvalue(o) + 1);
+    case LUA_TLIGHTUSERDATA: return pvalue(o);
+    default: return NULL;
+  }
+}
+
+
+LUA_API lua_State *lua_tothread (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  return (o == NULL || !ttisthread(o)) ? NULL : thvalue(o);
+}
+
+
+LUA_API const void *lua_topointer (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  if (o == NULL) return NULL;
+  else {
+    switch (ttype(o)) {
+      case LUA_TTABLE: return hvalue(o);
+      case LUA_TFUNCTION: return clvalue(o);
+      case LUA_TTHREAD: return thvalue(o);
+      case LUA_TUSERDATA:
+      case LUA_TLIGHTUSERDATA:
+        return lua_touserdata(L, idx);
+      default: return NULL;
+    }
+  }
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushnil (lua_State *L) {
+  lua_lock(L);
+  setnilvalue(L->top);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {
+  lua_lock(L);
+  setnvalue(L->top, n);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushlstring (lua_State *L, const char *s, size_t len) {
+  lua_lock(L);
+  luaC_checkGC(L);
+  setsvalue2s(L->top, luaS_newlstr(L, s, len));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushstring (lua_State *L, const char *s) {
+  if (s == NULL)
+    lua_pushnil(L);
+  else
+    lua_pushlstring(L, s, strlen(s));
+}
+
+
+LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
+                                      va_list argp) {
+  const char *ret;
+  lua_lock(L);
+  luaC_checkGC(L);
+  ret = luaO_pushvfstring(L, fmt, argp);
+  lua_unlock(L);
+  return ret;
+}
+
+
+LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {
+  const char *ret;
+  va_list argp;
+  lua_lock(L);
+  luaC_checkGC(L);
+  va_start(argp, fmt);
+  ret = luaO_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  lua_unlock(L);
+  return ret;
+}
+
+
+LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {
+  Closure *cl;
+  lua_lock(L);
+  luaC_checkGC(L);
+  api_checknelems(L, n);
+  cl = luaF_newCclosure(L, n);
+  cl->c.f = fn;
+  L->top -= n;
+  while (n--)
+    setobj2n(&cl->c.upvalue[n], L->top+n);
+  setclvalue(L->top, cl);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushboolean (lua_State *L, int b) {
+  lua_lock(L);
+  setbvalue(L->top, (b != 0));  /* ensure that true is 1 */
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {
+  lua_lock(L);
+  setpvalue(L->top, p);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+
+/*
+** get functions (Lua -> stack)
+*/
+
+
+LUA_API void lua_gettable (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = luaA_index(L, idx);
+  setobj2s(L->top - 1, luaV_gettable(L, t, L->top - 1, 0));
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawget (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = luaA_index(L, idx);
+  api_check(L, ttistable(t));
+  setobj2s(L->top - 1, luaH_get(hvalue(t), L->top - 1));
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawgeti (lua_State *L, int idx, int n) {
+  StkId o;
+  lua_lock(L);
+  o = luaA_index(L, idx);
+  api_check(L, ttistable(o));
+  setobj2s(L->top, luaH_getnum(hvalue(o), n));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_newtable (lua_State *L) {
+  lua_lock(L);
+  luaC_checkGC(L);
+  sethvalue(L->top, luaH_new(L, 0, 0));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_getmetatable (lua_State *L, int objindex) {
+  const TObject *obj;
+  Table *mt = NULL;
+  int res;
+  lua_lock(L);
+  obj = luaA_indexAcceptable(L, objindex);
+  if (obj != NULL) {
+    switch (ttype(obj)) {
+      case LUA_TTABLE:
+        mt = hvalue(obj)->metatable;
+        break;
+      case LUA_TUSERDATA:
+        mt = uvalue(obj)->uv.metatable;
+        break;
+    }
+  }
+  if (mt == NULL || mt == hvalue(defaultmeta(L)))
+    res = 0;
+  else {
+    sethvalue(L->top, mt);
+    api_incr_top(L);
+    res = 1;
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API void lua_getfenv (lua_State *L, int idx) {
+  StkId o;
+  lua_lock(L);
+  o = luaA_index(L, idx);
+  setobj2s(L->top, isLfunction(o) ? &clvalue(o)->l.g : gt(L));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+/*
+** set functions (stack -> Lua)
+*/
+
+
+LUA_API void lua_settable (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 2);
+  t = luaA_index(L, idx);
+  luaV_settable(L, t, L->top - 2, L->top - 1);
+  L->top -= 2;  /* pop index and value */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawset (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 2);
+  t = luaA_index(L, idx);
+  api_check(L, ttistable(t));
+  setobj2t(luaH_set(L, hvalue(t), L->top-2), L->top-1);  /* write barrier */
+  L->top -= 2;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawseti (lua_State *L, int idx, int n) {
+  StkId o;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = luaA_index(L, idx);
+  api_check(L, ttistable(o));
+  setobj2t(luaH_setnum(L, hvalue(o), n), L->top-1);  /* write barrier */
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_setmetatable (lua_State *L, int objindex) {
+  TObject *obj, *mt;
+  int res = 1;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  obj = luaA_index(L, objindex);
+  mt = (!ttisnil(L->top - 1)) ? L->top - 1 : defaultmeta(L);
+  api_check(L, ttistable(mt));
+  switch (ttype(obj)) {
+    case LUA_TTABLE: {
+      hvalue(obj)->metatable = hvalue(mt);  /* write barrier */
+      break;
+    }
+    case LUA_TUSERDATA: {
+      uvalue(obj)->uv.metatable = hvalue(mt);  /* write barrier */
+      break;
+    }
+    default: {
+      res = 0;  /* cannot set */
+      break;
+    }
+  }
+  L->top--;
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API int lua_setfenv (lua_State *L, int idx) {
+  StkId o;
+  int res = 0;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = luaA_index(L, idx);
+  L->top--;
+  api_check(L, ttistable(L->top));
+  if (isLfunction(o)) {
+    res = 1;
+    clvalue(o)->l.g = *(L->top);
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+/*
+** `load' and `call' functions (run Lua code)
+*/
+
+LUA_API void lua_call (lua_State *L, int nargs, int nresults) {
+  StkId func;
+  lua_lock(L);
+  api_checknelems(L, nargs+1);
+  func = L->top - (nargs+1);
+  luaD_call(L, func, nresults);
+  lua_unlock(L);
+}
+
+
+
+/*
+** Execute a protected call.
+*/
+struct CallS {  /* data to `f_call' */
+  StkId func;
+  int nresults;
+};
+
+
+static void f_call (lua_State *L, void *ud) {
+  struct CallS *c = cast(struct CallS *, ud);
+  luaD_call(L, c->func, c->nresults);
+}
+
+
+
+LUA_API int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc) {
+  struct CallS c;
+  int status;
+  ptrdiff_t func;
+  lua_lock(L);
+  func = (errfunc == 0) ? 0 : savestack(L, luaA_index(L, errfunc));
+  c.func = L->top - (nargs+1);  /* function to be called */
+  c.nresults = nresults;
+  status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);
+  lua_unlock(L);
+  return status;
+}
+
+
+/*
+** Execute a protected C call.
+*/
+struct CCallS {  /* data to `f_Ccall' */
+  lua_CFunction func;
+  void *ud;
+};
+
+
+static void f_Ccall (lua_State *L, void *ud) {
+  struct CCallS *c = cast(struct CCallS *, ud);
+  Closure *cl;
+  cl = luaF_newCclosure(L, 0);
+  cl->c.f = c->func;
+  setclvalue(L->top, cl);  /* push function */
+  incr_top(L);
+  setpvalue(L->top, c->ud);  /* push only argument */
+  incr_top(L);
+  luaD_call(L, L->top - 2, 0);
+}
+
+
+LUA_API int lua_cpcall (lua_State *L, lua_CFunction func, void *ud) {
+  struct CCallS c;
+  int status;
+  lua_lock(L);
+  c.func = func;
+  c.ud = ud;
+  status = luaD_pcall(L, f_Ccall, &c, savestack(L, L->top), 0);
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_load (lua_State *L, lua_Chunkreader reader, void *data,
+                      const char *chunkname) {
+  ZIO z;
+  int status;
+  int c;
+  lua_lock(L);
+  if (!chunkname) chunkname = "?";
+  luaZ_init(&z, reader, data, chunkname);
+  c = luaZ_lookahead(&z);
+  status = luaD_protectedparser(L, &z, (c == LUA_SIGNATURE[0]));
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_dump (lua_State *L, lua_Chunkwriter writer, void *data) {
+  int status;
+  TObject *o;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = L->top - 1;
+  if (isLfunction(o) && clvalue(o)->l.nupvalues == 0) {
+    luaU_dump(L, clvalue(o)->l.p, writer, data);
+    status = 1;
+  }
+  else
+    status = 0;
+  lua_unlock(L);
+  return status;
+}
+
+
+/*
+** Garbage-collection functions
+*/
+
+/* GC values are expressed in Kbytes: #bytes/2^10 */
+#define GCscalel(x)		((x)>>10)
+#define GCscale(x)		(cast(int, GCscalel(x)))
+#define GCunscale(x)		(cast(lu_mem, x)<<10)
+
+LUA_API int lua_getgcthreshold (lua_State *L) {
+  int threshold;
+  lua_lock(L);
+  threshold = GCscale(G(L)->GCthreshold);
+  lua_unlock(L);
+  return threshold;
+}
+
+LUA_API int lua_getgccount (lua_State *L) {
+  int count;
+  lua_lock(L);
+  count = GCscale(G(L)->nblocks);
+  lua_unlock(L);
+  return count;
+}
+
+LUA_API void lua_setgcthreshold (lua_State *L, int newthreshold) {
+  lua_lock(L);
+  if (cast(lu_mem, newthreshold) > GCscalel(MAX_LUMEM))
+    G(L)->GCthreshold = MAX_LUMEM;
+  else
+    G(L)->GCthreshold = GCunscale(newthreshold);
+  luaC_checkGC(L);
+  lua_unlock(L);
+}
+
+
+/*
+** miscellaneous functions
+*/
+
+
+LUA_API const char *lua_version (void) {
+  return LUA_VERSION;
+}
+
+
+LUA_API int lua_error (lua_State *L) {
+  lua_lock(L);
+  api_checknelems(L, 1);
+  luaG_errormsg(L);
+  lua_unlock(L);
+  return 0;  /* to avoid warnings */
+}
+
+
+LUA_API int lua_next (lua_State *L, int idx) {
+  StkId t;
+  int more;
+  lua_lock(L);
+  t = luaA_index(L, idx);
+  api_check(L, ttistable(t));
+  more = luaH_next(L, hvalue(t), L->top - 1);
+  if (more) {
+    api_incr_top(L);
+  }
+  else  /* no more elements */
+    L->top -= 1;  /* remove key */
+  lua_unlock(L);
+  return more;
+}
+
+
+LUA_API void lua_concat (lua_State *L, int n) {
+  lua_lock(L);
+  luaC_checkGC(L);
+  api_checknelems(L, n);
+  if (n >= 2) {
+    luaV_concat(L, n, L->top - L->base - 1);
+    L->top -= (n-1);
+  }
+  else if (n == 0) {  /* push empty string */
+    setsvalue2s(L->top, luaS_newlstr(L, NULL, 0));
+    api_incr_top(L);
+  }
+  /* else n == 1; nothing to do */
+  lua_unlock(L);
+}
+
+
+LUA_API void *lua_newuserdata (lua_State *L, size_t size) {
+  Udata *u;
+  lua_lock(L);
+  luaC_checkGC(L);
+  u = luaS_newudata(L, size);
+  setuvalue(L->top, u);
+  api_incr_top(L);
+  lua_unlock(L);
+  return u + 1;
+}
+
+
+LUA_API int lua_pushupvalues (lua_State *L) {
+  Closure *func;
+  int n, i;
+  lua_lock(L);
+  api_check(L, iscfunction(L->base - 1));
+  func = clvalue(L->base - 1);
+  n = func->c.nupvalues;
+  luaD_checkstack(L, n + LUA_MINSTACK);
+  for (i=0; i<n; i++) {
+    setobj2s(L->top, &func->c.upvalue[i]);
+    L->top++;
+  }
+  lua_unlock(L);
+  return n;
+}
+
+
+static const char *aux_upvalue (lua_State *L, int funcindex, int n,
+                                TObject **val) {
+  Closure *f;
+  StkId fi = luaA_index(L, funcindex);
+  if (!ttisfunction(fi)) return NULL;
+  f = clvalue(fi);
+  if (f->c.isC) {
+    if (n > f->c.nupvalues) return NULL;
+    *val = &f->c.upvalue[n-1];
+    return "";
+  }
+  else {
+    Proto *p = f->l.p;
+    if (n > p->sizeupvalues) return NULL;
+    *val = f->l.upvals[n-1]->v;
+    return getstr(p->upvalues[n-1]);
+  }
+}
+
+
+LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {
+  const char *name;
+  TObject *val;
+  lua_lock(L);
+  name = aux_upvalue(L, funcindex, n, &val);
+  if (name) {
+    setobj2s(L->top, val);
+    api_incr_top(L);
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {
+  const char *name;
+  TObject *val;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  name = aux_upvalue(L, funcindex, n, &val);
+  if (name) {
+    L->top--;
+    setobj(val, L->top);  /* write barrier */
+  }
+  lua_unlock(L);
+  return name;
+}
+

Added: trunk/Util/deditor/lua/lapi.h
===================================================================
--- trunk/Util/deditor/lua/lapi.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lapi.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,16 @@
+/*
+** $Id: lapi.h,v 1.21 2002/03/04 21:29:41 roberto Exp $
+** Auxiliary functions from Lua API
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lapi_h
+#define lapi_h
+
+
+#include "lobject.h"
+
+
+void luaA_pushobject (lua_State *L, const TObject *o);
+
+#endif

Added: trunk/Util/deditor/lua/lauxlib.h
===================================================================
--- trunk/Util/deditor/lua/lauxlib.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lauxlib.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,145 @@
+/*
+** $Id: lauxlib.h,v 1.60 2003/04/03 13:35:34 roberto Exp $
+** Auxiliary functions for building Lua libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lauxlib_h
+#define lauxlib_h
+
+
+#include <stddef.h>
+#include <stdio.h>
+
+#include "lua.h"
+
+
+#ifndef LUALIB_API
+#define LUALIB_API	LUA_API
+#endif
+
+
+
+typedef struct luaL_reg {
+  const char *name;
+  lua_CFunction func;
+} luaL_reg;
+
+
+LUALIB_API void luaL_openlib (lua_State *L, const char *libname,
+                               const luaL_reg *l, int nup);
+LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *e);
+LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *e);
+LUALIB_API int luaL_typerror (lua_State *L, int narg, const char *tname);
+LUALIB_API int luaL_argerror (lua_State *L, int numarg, const char *extramsg);
+LUALIB_API const char *luaL_checklstring (lua_State *L, int numArg, size_t *l);
+LUALIB_API const char *luaL_optlstring (lua_State *L, int numArg,
+                                           const char *def, size_t *l);
+LUALIB_API lua_Number luaL_checknumber (lua_State *L, int numArg);
+LUALIB_API lua_Number luaL_optnumber (lua_State *L, int nArg, lua_Number def);
+
+LUALIB_API void luaL_checkstack (lua_State *L, int sz, const char *msg);
+LUALIB_API void luaL_checktype (lua_State *L, int narg, int t);
+LUALIB_API void luaL_checkany (lua_State *L, int narg);
+
+LUALIB_API int   luaL_newmetatable (lua_State *L, const char *tname);
+LUALIB_API void  luaL_getmetatable (lua_State *L, const char *tname);
+LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname);
+
+LUALIB_API void luaL_where (lua_State *L, int lvl);
+LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...);
+
+LUALIB_API int luaL_findstring (const char *st, const char *const lst[]);
+
+LUALIB_API int luaL_ref (lua_State *L, int t);
+LUALIB_API void luaL_unref (lua_State *L, int t, int ref);
+
+LUALIB_API int luaL_getn (lua_State *L, int t);
+LUALIB_API void luaL_setn (lua_State *L, int t, int n);
+
+LUALIB_API int luaL_loadfile (lua_State *L, const char *filename);
+LUALIB_API int luaL_loadbuffer (lua_State *L, const char *buff, size_t sz,
+                                const char *name);
+
+
+
+/*
+** ===============================================================
+** some useful macros
+** ===============================================================
+*/
+
+#define luaL_argcheck(L, cond,numarg,extramsg) if (!(cond)) \
+                                               luaL_argerror(L, numarg,extramsg)
+#define luaL_checkstring(L,n)	(luaL_checklstring(L, (n), NULL))
+#define luaL_optstring(L,n,d)	(luaL_optlstring(L, (n), (d), NULL))
+#define luaL_checkint(L,n)	((int)luaL_checknumber(L, n))
+#define luaL_checklong(L,n)	((long)luaL_checknumber(L, n))
+#define luaL_optint(L,n,d)	((int)luaL_optnumber(L, n,(lua_Number)(d)))
+#define luaL_optlong(L,n,d)	((long)luaL_optnumber(L, n,(lua_Number)(d)))
+
+
+/*
+** {======================================================
+** Generic Buffer manipulation
+** =======================================================
+*/
+
+
+#ifndef LUAL_BUFFERSIZE
+#define LUAL_BUFFERSIZE	  BUFSIZ
+#endif
+
+
+typedef struct luaL_Buffer {
+  char *p;			/* current position in buffer */
+  int lvl;  /* number of strings in the stack (level) */
+  lua_State *L;
+  char buffer[LUAL_BUFFERSIZE];
+} luaL_Buffer;
+
+#define luaL_putchar(B,c) \
+  ((void)((B)->p < ((B)->buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), \
+   (*(B)->p++ = (char)(c)))
+
+#define luaL_addsize(B,n)	((B)->p += (n))
+
+LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B);
+LUALIB_API char *luaL_prepbuffer (luaL_Buffer *B);
+LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);
+LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s);
+LUALIB_API void luaL_addvalue (luaL_Buffer *B);
+LUALIB_API void luaL_pushresult (luaL_Buffer *B);
+
+
+/* }====================================================== */
+
+
+
+/*
+** Compatibility macros and functions
+*/
+
+LUALIB_API int   lua_dofile (lua_State *L, const char *filename);
+LUALIB_API int   lua_dostring (lua_State *L, const char *str);
+LUALIB_API int   lua_dobuffer (lua_State *L, const char *buff, size_t sz,
+                               const char *n);
+
+
+#define luaL_check_lstr 	luaL_checklstring
+#define luaL_opt_lstr 	luaL_optlstring 
+#define luaL_check_number 	luaL_checknumber 
+#define luaL_opt_number	luaL_optnumber
+#define luaL_arg_check	luaL_argcheck
+#define luaL_check_string	luaL_checkstring
+#define luaL_opt_string	luaL_optstring
+#define luaL_check_int	luaL_checkint
+#define luaL_check_long	luaL_checklong
+#define luaL_opt_int	luaL_optint
+#define luaL_opt_long	luaL_optlong
+
+
+#endif
+
+

Added: trunk/Util/deditor/lua/lcode.c
===================================================================
--- trunk/Util/deditor/lua/lcode.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lcode.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,714 @@
+/*
+** $Id: lcode.c,v 1.117 2003/04/03 13:35:34 roberto Exp $
+** Code generator for Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+
+#define lcode_c
+
+#include "lua.h"
+
+#include "lcode.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "llex.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+#include "ltable.h"
+
+
+#define hasjumps(e)	((e)->t != (e)->f)
+
+
+void luaK_nil (FuncState *fs, int from, int n) {
+  Instruction *previous;
+  if (fs->pc > fs->lasttarget &&  /* no jumps to current position? */
+      GET_OPCODE(*(previous = &fs->f->code[fs->pc-1])) == OP_LOADNIL) {
+    int pfrom = GETARG_A(*previous);
+    int pto = GETARG_B(*previous);
+    if (pfrom <= from && from <= pto+1) {  /* can connect both? */
+      if (from+n-1 > pto)
+        SETARG_B(*previous, from+n-1);
+      return;
+    }
+  }
+  luaK_codeABC(fs, OP_LOADNIL, from, from+n-1, 0);  /* else no optimization */
+}
+
+
+int luaK_jump (FuncState *fs) {
+  int jpc = fs->jpc;  /* save list of jumps to here */
+  int j;
+  fs->jpc = NO_JUMP;
+  j = luaK_codeAsBx(fs, OP_JMP, 0, NO_JUMP);
+  luaK_concat(fs, &j, jpc);  /* keep them on hold */
+  return j;
+}
+
+
+static int luaK_condjump (FuncState *fs, OpCode op, int A, int B, int C) {
+  luaK_codeABC(fs, op, A, B, C);
+  return luaK_jump(fs);
+}
+
+
+static void luaK_fixjump (FuncState *fs, int pc, int dest) {
+  Instruction *jmp = &fs->f->code[pc];
+  int offset = dest-(pc+1);
+  lua_assert(dest != NO_JUMP);
+  if (abs(offset) > MAXARG_sBx)
+    luaX_syntaxerror(fs->ls, "control structure too long");
+  SETARG_sBx(*jmp, offset);
+}
+
+
+/*
+** returns current `pc' and marks it as a jump target (to avoid wrong
+** optimizations with consecutive instructions not in the same basic block).
+*/
+int luaK_getlabel (FuncState *fs) {
+  fs->lasttarget = fs->pc;
+  return fs->pc;
+}
+
+
+static int luaK_getjump (FuncState *fs, int pc) {
+  int offset = GETARG_sBx(fs->f->code[pc]);
+  if (offset == NO_JUMP)  /* point to itself represents end of list */
+    return NO_JUMP;  /* end of list */
+  else
+    return (pc+1)+offset;  /* turn offset into absolute position */
+}
+
+
+static Instruction *getjumpcontrol (FuncState *fs, int pc) {
+  Instruction *pi = &fs->f->code[pc];
+  if (pc >= 1 && testOpMode(GET_OPCODE(*(pi-1)), OpModeT))
+    return pi-1;
+  else
+    return pi;
+}
+
+
+/*
+** check whether list has any jump that do not produce a value
+** (or produce an inverted value)
+*/
+static int need_value (FuncState *fs, int list, int cond) {
+  for (; list != NO_JUMP; list = luaK_getjump(fs, list)) {
+    Instruction i = *getjumpcontrol(fs, list);
+    if (GET_OPCODE(i) != OP_TEST || GETARG_C(i) != cond) return 1;
+  }
+  return 0;  /* not found */
+}
+
+
+static void patchtestreg (Instruction *i, int reg) {
+  if (reg == NO_REG) reg = GETARG_B(*i);
+  SETARG_A(*i, reg);
+}
+
+
+static void luaK_patchlistaux (FuncState *fs, int list,
+          int ttarget, int treg, int ftarget, int freg, int dtarget) {
+  while (list != NO_JUMP) {
+    int next = luaK_getjump(fs, list);
+    Instruction *i = getjumpcontrol(fs, list);
+    if (GET_OPCODE(*i) != OP_TEST) {
+      lua_assert(dtarget != NO_JUMP);
+      luaK_fixjump(fs, list, dtarget);  /* jump to default target */
+    }
+    else {
+      if (GETARG_C(*i)) {
+        lua_assert(ttarget != NO_JUMP);
+        patchtestreg(i, treg);
+        luaK_fixjump(fs, list, ttarget);
+      }
+      else {
+        lua_assert(ftarget != NO_JUMP);
+        patchtestreg(i, freg);
+        luaK_fixjump(fs, list, ftarget);
+      }
+    }
+    list = next;
+  }
+}
+
+
+static void luaK_dischargejpc (FuncState *fs) {
+  luaK_patchlistaux(fs, fs->jpc, fs->pc, NO_REG, fs->pc, NO_REG, fs->pc);
+  fs->jpc = NO_JUMP;
+}
+
+
+void luaK_patchlist (FuncState *fs, int list, int target) {
+  if (target == fs->pc)
+    luaK_patchtohere(fs, list);
+  else {
+    lua_assert(target < fs->pc);
+    luaK_patchlistaux(fs, list, target, NO_REG, target, NO_REG, target);
+  }
+}
+
+
+void luaK_patchtohere (FuncState *fs, int list) {
+  luaK_getlabel(fs);
+  luaK_concat(fs, &fs->jpc, list);
+}
+
+
+void luaK_concat (FuncState *fs, int *l1, int l2) {
+  if (l2 == NO_JUMP) return;
+  else if (*l1 == NO_JUMP)
+    *l1 = l2;
+  else {
+    int list = *l1;
+    int next;
+    while ((next = luaK_getjump(fs, list)) != NO_JUMP)  /* find last element */
+      list = next;
+    luaK_fixjump(fs, list, l2);
+  }
+}
+
+
+void luaK_checkstack (FuncState *fs, int n) {
+  int newstack = fs->freereg + n;
+  if (newstack > fs->f->maxstacksize) {
+    if (newstack >= MAXSTACK)
+      luaX_syntaxerror(fs->ls, "function or expression too complex");
+    fs->f->maxstacksize = cast(lu_byte, newstack);
+  }
+}
+
+
+void luaK_reserveregs (FuncState *fs, int n) {
+  luaK_checkstack(fs, n);
+  fs->freereg += n;
+}
+
+
+static void freereg (FuncState *fs, int reg) {
+  if (reg >= fs->nactvar && reg < MAXSTACK) {
+    fs->freereg--;
+    lua_assert(reg == fs->freereg);
+  }
+}
+
+
+static void freeexp (FuncState *fs, expdesc *e) {
+  if (e->k == VNONRELOC)
+    freereg(fs, e->info);
+}
+
+
+static int addk (FuncState *fs, TObject *k, TObject *v) {
+  const TObject *idx = luaH_get(fs->h, k);
+  if (ttisnumber(idx)) {
+    lua_assert(luaO_rawequalObj(&fs->f->k[cast(int, nvalue(idx))], v));
+    return cast(int, nvalue(idx));
+  }
+  else {  /* constant not found; create a new entry */
+    Proto *f = fs->f;
+    luaM_growvector(fs->L, f->k, fs->nk, f->sizek, TObject,
+                    MAXARG_Bx, "constant table overflow");
+    setobj2n(&f->k[fs->nk], v);
+    setnvalue(luaH_set(fs->L, fs->h, k), cast(lua_Number, fs->nk));
+    return fs->nk++;
+  }
+}
+
+
+int luaK_stringK (FuncState *fs, TString *s) {
+  TObject o;
+  setsvalue(&o, s);
+  return addk(fs, &o, &o);
+}
+
+
+int luaK_numberK (FuncState *fs, lua_Number r) {
+  TObject o;
+  setnvalue(&o, r);
+  return addk(fs, &o, &o);
+}
+
+
+static int nil_constant (FuncState *fs) {
+  TObject k, v;
+  setnilvalue(&v);
+  sethvalue(&k, fs->h);  /* cannot use nil as key; instead use table itself */
+  return addk(fs, &k, &v);
+}
+
+
+void luaK_setcallreturns (FuncState *fs, expdesc *e, int nresults) {
+  if (e->k == VCALL) {  /* expression is an open function call? */
+    SETARG_C(getcode(fs, e), nresults+1);
+    if (nresults == 1) {  /* `regular' expression? */
+      e->k = VNONRELOC;
+      e->info = GETARG_A(getcode(fs, e));
+    }
+  }
+}
+
+
+void luaK_dischargevars (FuncState *fs, expdesc *e) {
+  switch (e->k) {
+    case VLOCAL: {
+      e->k = VNONRELOC;
+      break;
+    }
+    case VUPVAL: {
+      e->info = luaK_codeABC(fs, OP_GETUPVAL, 0, e->info, 0);
+      e->k = VRELOCABLE;
+      break;
+    }
+    case VGLOBAL: {
+      e->info = luaK_codeABx(fs, OP_GETGLOBAL, 0, e->info);
+      e->k = VRELOCABLE;
+      break;
+    }
+    case VINDEXED: {
+      freereg(fs, e->aux);
+      freereg(fs, e->info);
+      e->info = luaK_codeABC(fs, OP_GETTABLE, 0, e->info, e->aux);
+      e->k = VRELOCABLE;
+      break;
+    }
+    case VCALL: {
+      luaK_setcallreturns(fs, e, 1);
+      break;
+    }
+    default: break;  /* there is one value available (somewhere) */
+  }
+}
+
+
+static int code_label (FuncState *fs, int A, int b, int jump) {
+  luaK_getlabel(fs);  /* those instructions may be jump targets */
+  return luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);
+}
+
+
+static void discharge2reg (FuncState *fs, expdesc *e, int reg) {
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VNIL: {
+      luaK_nil(fs, reg, 1);
+      break;
+    }
+    case VFALSE:  case VTRUE: {
+      luaK_codeABC(fs, OP_LOADBOOL, reg, e->k == VTRUE, 0);
+      break;
+    }
+    case VK: {
+      luaK_codeABx(fs, OP_LOADK, reg, e->info);
+      break;
+    }
+    case VRELOCABLE: {
+      Instruction *pc = &getcode(fs, e);
+      SETARG_A(*pc, reg);
+      break;
+    }
+    case VNONRELOC: {
+      if (reg != e->info)
+        luaK_codeABC(fs, OP_MOVE, reg, e->info, 0);
+      break;
+    }
+    default: {
+      lua_assert(e->k == VVOID || e->k == VJMP);
+      return;  /* nothing to do... */
+    }
+  }
+  e->info = reg;
+  e->k = VNONRELOC;
+}
+
+
+static void discharge2anyreg (FuncState *fs, expdesc *e) {
+  if (e->k != VNONRELOC) {
+    luaK_reserveregs(fs, 1);
+    discharge2reg(fs, e, fs->freereg-1);
+  }
+}
+
+
+static void luaK_exp2reg (FuncState *fs, expdesc *e, int reg) {
+  discharge2reg(fs, e, reg);
+  if (e->k == VJMP)
+    luaK_concat(fs, &e->t, e->info);  /* put this jump in `t' list */
+  if (hasjumps(e)) {
+    int final;  /* position after whole expression */
+    int p_f = NO_JUMP;  /* position of an eventual LOAD false */
+    int p_t = NO_JUMP;  /* position of an eventual LOAD true */
+    if (need_value(fs, e->t, 1) || need_value(fs, e->f, 0)) {
+      int fj = NO_JUMP;  /* first jump (over LOAD ops.) */
+      if (e->k != VJMP)
+        fj = luaK_jump(fs);
+      p_f = code_label(fs, reg, 0, 1);
+      p_t = code_label(fs, reg, 1, 0);
+      luaK_patchtohere(fs, fj);
+    }
+    final = luaK_getlabel(fs);
+    luaK_patchlistaux(fs, e->f, p_f, NO_REG, final, reg, p_f);
+    luaK_patchlistaux(fs, e->t, final, reg, p_t, NO_REG, p_t);
+  }
+  e->f = e->t = NO_JUMP;
+  e->info = reg;
+  e->k = VNONRELOC;
+}
+
+
+void luaK_exp2nextreg (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  freeexp(fs, e);
+  luaK_reserveregs(fs, 1);
+  luaK_exp2reg(fs, e, fs->freereg - 1);
+}
+
+
+int luaK_exp2anyreg (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  if (e->k == VNONRELOC) {
+    if (!hasjumps(e)) return e->info;  /* exp is already in a register */ 
+    if (e->info >= fs->nactvar) {  /* reg. is not a local? */
+      luaK_exp2reg(fs, e, e->info);  /* put value on it */
+      return e->info;
+    }
+  }
+  luaK_exp2nextreg(fs, e);  /* default */
+  return e->info;
+}
+
+
+void luaK_exp2val (FuncState *fs, expdesc *e) {
+  if (hasjumps(e))
+    luaK_exp2anyreg(fs, e);
+  else
+    luaK_dischargevars(fs, e);
+}
+
+
+int luaK_exp2RK (FuncState *fs, expdesc *e) {
+  luaK_exp2val(fs, e);
+  switch (e->k) {
+    case VNIL: {
+      if (fs->nk + MAXSTACK <= MAXARG_C) {  /* constant fit in argC? */
+        e->info = nil_constant(fs);
+        e->k = VK;
+        return e->info + MAXSTACK;
+      }
+      else break;
+    }
+    case VK: {
+      if (e->info + MAXSTACK <= MAXARG_C)  /* constant fit in argC? */
+        return e->info + MAXSTACK;
+      else break;
+    }
+    default: break;
+  }
+  /* not a constant in the right range: put it in a register */
+  return luaK_exp2anyreg(fs, e);
+}
+
+
+void luaK_storevar (FuncState *fs, expdesc *var, expdesc *exp) {
+  switch (var->k) {
+    case VLOCAL: {
+      freeexp(fs, exp);
+      luaK_exp2reg(fs, exp, var->info);
+      return;
+    }
+    case VUPVAL: {
+      int e = luaK_exp2anyreg(fs, exp);
+      luaK_codeABC(fs, OP_SETUPVAL, e, var->info, 0);
+      break;
+    }
+    case VGLOBAL: {
+      int e = luaK_exp2anyreg(fs, exp);
+      luaK_codeABx(fs, OP_SETGLOBAL, e, var->info);
+      break;
+    }
+    case VINDEXED: {
+      int e = luaK_exp2RK(fs, exp);
+      luaK_codeABC(fs, OP_SETTABLE, var->info, var->aux, e);
+      break;
+    }
+    default: {
+      lua_assert(0);  /* invalid var kind to store */
+      break;
+    }
+  }
+  freeexp(fs, exp);
+}
+
+
+void luaK_self (FuncState *fs, expdesc *e, expdesc *key) {
+  int func;
+  luaK_exp2anyreg(fs, e);
+  freeexp(fs, e);
+  func = fs->freereg;
+  luaK_reserveregs(fs, 2);
+  luaK_codeABC(fs, OP_SELF, func, e->info, luaK_exp2RK(fs, key));
+  freeexp(fs, key);
+  e->info = func;
+  e->k = VNONRELOC;
+}
+
+
+static void invertjump (FuncState *fs, expdesc *e) {
+  Instruction *pc = getjumpcontrol(fs, e->info);
+  lua_assert(testOpMode(GET_OPCODE(*pc), OpModeT) &&
+             GET_OPCODE(*pc) != OP_TEST);
+  SETARG_A(*pc, !(GETARG_A(*pc)));
+}
+
+
+static int jumponcond (FuncState *fs, expdesc *e, int cond) {
+  if (e->k == VRELOCABLE) {
+    Instruction ie = getcode(fs, e);
+    if (GET_OPCODE(ie) == OP_NOT) {
+      fs->pc--;  /* remove previous OP_NOT */
+      return luaK_condjump(fs, OP_TEST, NO_REG, GETARG_B(ie), !cond);
+    }
+    /* else go through */
+  }
+  discharge2anyreg(fs, e);
+  freeexp(fs, e);
+  return luaK_condjump(fs, OP_TEST, NO_REG, e->info, cond);
+}
+
+
+void luaK_goiftrue (FuncState *fs, expdesc *e) {
+  int pc;  /* pc of last jump */
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VK: case VTRUE: {
+      pc = NO_JUMP;  /* always true; do nothing */
+      break;
+    }
+    case VFALSE: {
+      pc = luaK_jump(fs);  /* always jump */
+      break;
+    }
+    case VJMP: {
+      invertjump(fs, e);
+      pc = e->info;
+      break;
+    }
+    default: {
+      pc = jumponcond(fs, e, 0);
+      break;
+    }
+  }
+  luaK_concat(fs, &e->f, pc);  /* insert last jump in `f' list */
+}
+
+
+void luaK_goiffalse (FuncState *fs, expdesc *e) {
+  int pc;  /* pc of last jump */
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VNIL: case VFALSE: {
+      pc = NO_JUMP;  /* always false; do nothing */
+      break;
+    }
+    case VTRUE: {
+      pc = luaK_jump(fs);  /* always jump */
+      break;
+    }
+    case VJMP: {
+      pc = e->info;
+      break;
+    }
+    default: {
+      pc = jumponcond(fs, e, 1);
+      break;
+    }
+  }
+  luaK_concat(fs, &e->t, pc);  /* insert last jump in `t' list */
+}
+
+
+static void codenot (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VNIL: case VFALSE: {
+      e->k = VTRUE;
+      break;
+    }
+    case VK: case VTRUE: {
+      e->k = VFALSE;
+      break;
+    }
+    case VJMP: {
+      invertjump(fs, e);
+      break;
+    }
+    case VRELOCABLE:
+    case VNONRELOC: {
+      discharge2anyreg(fs, e);
+      freeexp(fs, e);
+      e->info = luaK_codeABC(fs, OP_NOT, 0, e->info, 0);
+      e->k = VRELOCABLE;
+      break;
+    }
+    default: {
+      lua_assert(0);  /* cannot happen */
+      break;
+    }
+  }
+  /* interchange true and false lists */
+  { int temp = e->f; e->f = e->t; e->t = temp; }
+}
+
+
+void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {
+  t->aux = luaK_exp2RK(fs, k);
+  t->k = VINDEXED;
+}
+
+
+void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e) {
+  if (op == OPR_MINUS) {
+    luaK_exp2val(fs, e);
+    if (e->k == VK && ttisnumber(&fs->f->k[e->info]))
+      e->info = luaK_numberK(fs, -nvalue(&fs->f->k[e->info]));
+    else {
+      luaK_exp2anyreg(fs, e);
+      freeexp(fs, e);
+      e->info = luaK_codeABC(fs, OP_UNM, 0, e->info, 0);
+      e->k = VRELOCABLE;
+    }
+  }
+  else  /* op == NOT */
+    codenot(fs, e);
+}
+
+
+void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
+  switch (op) {
+    case OPR_AND: {
+      luaK_goiftrue(fs, v);
+      luaK_patchtohere(fs, v->t);
+      v->t = NO_JUMP;
+      break;
+    }
+    case OPR_OR: {
+      luaK_goiffalse(fs, v);
+      luaK_patchtohere(fs, v->f);
+      v->f = NO_JUMP;
+      break;
+    }
+    case OPR_CONCAT: {
+      luaK_exp2nextreg(fs, v);  /* operand must be on the `stack' */
+      break;
+    }
+    default: {
+      luaK_exp2RK(fs, v);
+      break;
+    }
+  }
+}
+
+
+static void codebinop (FuncState *fs, expdesc *res, BinOpr op,
+                       int o1, int o2) {
+  if (op <= OPR_POW) {  /* arithmetic operator? */
+    OpCode opc = cast(OpCode, (op - OPR_ADD) + OP_ADD);  /* ORDER OP */
+    res->info = luaK_codeABC(fs, opc, 0, o1, o2);
+    res->k = VRELOCABLE;
+  }
+  else {  /* test operator */
+    static const OpCode ops[] = {OP_EQ, OP_EQ, OP_LT, OP_LE, OP_LT, OP_LE};
+    int cond = 1;
+    if (op >= OPR_GT) {  /* `>' or `>='? */
+      int temp;  /* exchange args and replace by `<' or `<=' */
+      temp = o1; o1 = o2; o2 = temp;  /* o1 <==> o2 */
+    }
+    else if (op == OPR_NE) cond = 0;
+    res->info = luaK_condjump(fs, ops[op - OPR_NE], cond, o1, o2);
+    res->k = VJMP;
+  }
+}
+
+
+void luaK_posfix (FuncState *fs, BinOpr op, expdesc *e1, expdesc *e2) {
+  switch (op) {
+    case OPR_AND: {
+      lua_assert(e1->t == NO_JUMP);  /* list must be closed */
+      luaK_dischargevars(fs, e2);
+      luaK_concat(fs, &e1->f, e2->f);
+      e1->k = e2->k; e1->info = e2->info; e1->aux = e2->aux; e1->t = e2->t;
+      break;
+    }
+    case OPR_OR: {
+      lua_assert(e1->f == NO_JUMP);  /* list must be closed */
+      luaK_dischargevars(fs, e2);
+      luaK_concat(fs, &e1->t, e2->t);
+      e1->k = e2->k; e1->info = e2->info; e1->aux = e2->aux; e1->f = e2->f;
+      break;
+    }
+    case OPR_CONCAT: {
+      luaK_exp2val(fs, e2);
+      if (e2->k == VRELOCABLE && GET_OPCODE(getcode(fs, e2)) == OP_CONCAT) {
+        lua_assert(e1->info == GETARG_B(getcode(fs, e2))-1);
+        freeexp(fs, e1);
+        SETARG_B(getcode(fs, e2), e1->info);
+        e1->k = e2->k; e1->info = e2->info;
+      }
+      else {
+        luaK_exp2nextreg(fs, e2);
+        freeexp(fs, e2);
+        freeexp(fs, e1);
+        e1->info = luaK_codeABC(fs, OP_CONCAT, 0, e1->info, e2->info);
+        e1->k = VRELOCABLE;
+      }
+      break;
+    }
+    default: {
+      int o1 = luaK_exp2RK(fs, e1);
+      int o2 = luaK_exp2RK(fs, e2);
+      freeexp(fs, e2);
+      freeexp(fs, e1);
+      codebinop(fs, e1, op, o1, o2);
+    }
+  }
+}
+
+
+void luaK_fixline (FuncState *fs, int line) {
+  fs->f->lineinfo[fs->pc - 1] = line;
+}
+
+
+int luaK_code (FuncState *fs, Instruction i, int line) {
+  Proto *f = fs->f;
+  luaK_dischargejpc(fs);  /* `pc' will change */
+  /* put new instruction in code array */
+  luaM_growvector(fs->L, f->code, fs->pc, f->sizecode, Instruction,
+                  MAX_INT, "code size overflow");
+  f->code[fs->pc] = i;
+  /* save corresponding line information */
+  luaM_growvector(fs->L, f->lineinfo, fs->pc, f->sizelineinfo, int,
+                  MAX_INT, "code size overflow");
+  f->lineinfo[fs->pc] = line;
+  return fs->pc++;
+}
+
+
+int luaK_codeABC (FuncState *fs, OpCode o, int a, int b, int c) {
+  lua_assert(getOpMode(o) == iABC);
+  return luaK_code(fs, CREATE_ABC(o, a, b, c), fs->ls->lastline);
+}
+
+
+int luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {
+  lua_assert(getOpMode(o) == iABx || getOpMode(o) == iAsBx);
+  return luaK_code(fs, CREATE_ABx(o, a, bc), fs->ls->lastline);
+}
+

Added: trunk/Util/deditor/lua/lcode.h
===================================================================
--- trunk/Util/deditor/lua/lcode.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lcode.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,74 @@
+/*
+** $Id: lcode.h,v 1.38 2002/12/11 12:34:22 roberto Exp $
+** Code generator for Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lcode_h
+#define lcode_h
+
+#include "llex.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+
+
+/*
+** Marks the end of a patch list. It is an invalid value both as an absolute
+** address, and as a list link (would link an element to itself).
+*/
+#define NO_JUMP (-1)
+
+
+/*
+** grep "ORDER OPR" if you change these enums
+*/
+typedef enum BinOpr {
+  OPR_ADD, OPR_SUB, OPR_MULT, OPR_DIV, OPR_POW,
+  OPR_CONCAT,
+  OPR_NE, OPR_EQ,
+  OPR_LT, OPR_LE, OPR_GT, OPR_GE,
+  OPR_AND, OPR_OR,
+  OPR_NOBINOPR
+} BinOpr;
+
+#define binopistest(op)	((op) >= OPR_NE)
+
+typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_NOUNOPR } UnOpr;
+
+
+#define getcode(fs,e)	((fs)->f->code[(e)->info])
+
+#define luaK_codeAsBx(fs,o,A,sBx)	luaK_codeABx(fs,o,A,(sBx)+MAXARG_sBx)
+
+int luaK_code (FuncState *fs, Instruction i, int line);
+int luaK_codeABx (FuncState *fs, OpCode o, int A, unsigned int Bx);
+int luaK_codeABC (FuncState *fs, OpCode o, int A, int B, int C);
+void luaK_fixline (FuncState *fs, int line);
+void luaK_nil (FuncState *fs, int from, int n);
+void luaK_reserveregs (FuncState *fs, int n);
+void luaK_checkstack (FuncState *fs, int n);
+int luaK_stringK (FuncState *fs, TString *s);
+int luaK_numberK (FuncState *fs, lua_Number r);
+void luaK_dischargevars (FuncState *fs, expdesc *e);
+int luaK_exp2anyreg (FuncState *fs, expdesc *e);
+void luaK_exp2nextreg (FuncState *fs, expdesc *e);
+void luaK_exp2val (FuncState *fs, expdesc *e);
+int luaK_exp2RK (FuncState *fs, expdesc *e);
+void luaK_self (FuncState *fs, expdesc *e, expdesc *key);
+void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k);
+void luaK_goiftrue (FuncState *fs, expdesc *e);
+void luaK_goiffalse (FuncState *fs, expdesc *e);
+void luaK_storevar (FuncState *fs, expdesc *var, expdesc *e);
+void luaK_setcallreturns (FuncState *fs, expdesc *var, int nresults);
+int luaK_jump (FuncState *fs);
+void luaK_patchlist (FuncState *fs, int list, int target);
+void luaK_patchtohere (FuncState *fs, int list);
+void luaK_concat (FuncState *fs, int *l1, int l2);
+int luaK_getlabel (FuncState *fs);
+void luaK_prefix (FuncState *fs, UnOpr op, expdesc *v);
+void luaK_infix (FuncState *fs, BinOpr op, expdesc *v);
+void luaK_posfix (FuncState *fs, BinOpr op, expdesc *v1, expdesc *v2);
+
+
+#endif

Added: trunk/Util/deditor/lua/ldebug.c
===================================================================
--- trunk/Util/deditor/lua/ldebug.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ldebug.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,585 @@
+/*
+** $Id: ldebug.c,v 1.150 2003/03/19 21:24:04 roberto Exp $
+** Debug Interface
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+#include <string.h>
+
+#define ldebug_c
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "lcode.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lvm.h"
+
+
+
+static const char *getfuncname (CallInfo *ci, const char **name);
+
+
+#define isLua(ci)	(!((ci)->state & CI_C))
+
+
+static int currentpc (CallInfo *ci) {
+  if (!isLua(ci)) return -1;  /* function is not a Lua function? */
+  if (ci->state & CI_HASFRAME)  /* function has a frame? */
+    ci->u.l.savedpc = *ci->u.l.pc;  /* use `pc' from there */
+  /* function's pc is saved */
+  return pcRel(ci->u.l.savedpc, ci_func(ci)->l.p);
+}
+
+
+static int currentline (CallInfo *ci) {
+  int pc = currentpc(ci);
+  if (pc < 0)
+    return -1;  /* only active lua functions have current-line information */
+  else
+    return getline(ci_func(ci)->l.p, pc);
+}
+
+
+void luaG_inithooks (lua_State *L) {
+  CallInfo *ci;
+  for (ci = L->ci; ci != L->base_ci; ci--)  /* update all `savedpc's */
+    currentpc(ci);
+  L->hookinit = 1;
+}
+
+
+/*
+** this function can be called asynchronous (e.g. during a signal)
+*/
+LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
+  if (func == NULL || mask == 0) {  /* turn off hooks? */
+    mask = 0;
+    func = NULL;
+  }
+  L->hook = func;
+  L->basehookcount = count;
+  resethookcount(L);
+  L->hookmask = cast(lu_byte, mask);
+  L->hookinit = 0;
+  return 1;
+}
+
+
+LUA_API lua_Hook lua_gethook (lua_State *L) {
+  return L->hook;
+}
+
+
+LUA_API int lua_gethookmask (lua_State *L) {
+  return L->hookmask;
+}
+
+
+LUA_API int lua_gethookcount (lua_State *L) {
+  return L->basehookcount;
+}
+
+
+LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {
+  int status;
+  CallInfo *ci;
+  lua_lock(L);
+  for (ci = L->ci; level > 0 && ci > L->base_ci; ci--) {
+    level--;
+    if (!(ci->state & CI_C))  /* Lua function? */
+      level -= ci->u.l.tailcalls;  /* skip lost tail calls */
+  }
+  if (level > 0 || ci == L->base_ci) status = 0;  /* there is no such level */
+  else if (level < 0) {  /* level is of a lost tail call */
+    status = 1;
+    ar->i_ci = 0;
+  }
+  else {
+    status = 1;
+    ar->i_ci = ci - L->base_ci;
+  }
+  lua_unlock(L);
+  return status;
+}
+
+
+static Proto *getluaproto (CallInfo *ci) {
+  return (isLua(ci) ? ci_func(ci)->l.p : NULL);
+}
+
+
+LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {
+  const char *name;
+  CallInfo *ci;
+  Proto *fp;
+  lua_lock(L);
+  name = NULL;
+  ci = L->base_ci + ar->i_ci;
+  fp = getluaproto(ci);
+  if (fp) {  /* is a Lua function? */
+    name = luaF_getlocalname(fp, n, currentpc(ci));
+    if (name)
+      luaA_pushobject(L, ci->base+(n-1));  /* push value */
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {
+  const char *name;
+  CallInfo *ci;
+  Proto *fp;
+  lua_lock(L);
+  name = NULL;
+  ci = L->base_ci + ar->i_ci;
+  fp = getluaproto(ci);
+  L->top--;  /* pop new value */
+  if (fp) {  /* is a Lua function? */
+    name = luaF_getlocalname(fp, n, currentpc(ci));
+    if (!name || name[0] == '(')  /* `(' starts private locals */
+      name = NULL;
+    else
+      setobjs2s(ci->base+(n-1), L->top);
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+static void funcinfo (lua_Debug *ar, StkId func) {
+  Closure *cl = clvalue(func);
+  if (cl->c.isC) {
+    ar->source = "=[C]";
+    ar->linedefined = -1;
+    ar->what = "C";
+  }
+  else {
+    ar->source = getstr(cl->l.p->source);
+    ar->linedefined = cl->l.p->lineDefined;
+    ar->what = (ar->linedefined == 0) ? "main" : "Lua";
+  }
+  luaO_chunkid(ar->short_src, ar->source, LUA_IDSIZE);
+}
+
+
+static const char *travglobals (lua_State *L, const TObject *o) {
+  Table *g = hvalue(gt(L));
+  int i = sizenode(g);
+  while (i--) {
+    Node *n = gnode(g, i);
+    if (luaO_rawequalObj(o, gval(n)) && ttisstring(gkey(n)))
+      return getstr(tsvalue(gkey(n)));
+  }
+  return NULL;
+}
+
+
+static void info_tailcall (lua_State *L, lua_Debug *ar) {
+  ar->name = ar->namewhat = "";
+  ar->what = "tail";
+  ar->linedefined = ar->currentline = -1;
+  ar->source = "=(tail call)";
+  luaO_chunkid(ar->short_src, ar->source, LUA_IDSIZE);
+  ar->nups = 0;
+  setnilvalue(L->top);
+}
+
+
+static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
+                    StkId f, CallInfo *ci) {
+  int status = 1;
+  for (; *what; what++) {
+    switch (*what) {
+      case 'S': {
+        funcinfo(ar, f);
+        break;
+      }
+      case 'l': {
+        ar->currentline = (ci) ? currentline(ci) : -1;
+        break;
+      }
+      case 'u': {
+        ar->nups = clvalue(f)->c.nupvalues;
+        break;
+      }
+      case 'n': {
+        ar->namewhat = (ci) ? getfuncname(ci, &ar->name) : NULL;
+        if (ar->namewhat == NULL) {
+          /* try to find a global name */
+          if ((ar->name = travglobals(L, f)) != NULL)
+            ar->namewhat = "global";
+          else ar->namewhat = "";  /* not found */
+        }
+        break;
+      }
+      case 'f': {
+        setobj2s(L->top, f);
+        break;
+      }
+      default: status = 0;  /* invalid option */
+    }
+  }
+  return status;
+}
+
+
+LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
+  int status = 1;
+  lua_lock(L);
+  if (*what == '>') {
+    StkId f = L->top - 1;
+    if (!ttisfunction(f))
+      luaG_runerror(L, "value for `lua_getinfo' is not a function");
+    status = auxgetinfo(L, what + 1, ar, f, NULL);
+    L->top--;  /* pop function */
+  }
+  else if (ar->i_ci != 0) {  /* no tail call? */
+    CallInfo *ci = L->base_ci + ar->i_ci;
+    lua_assert(ttisfunction(ci->base - 1));
+    status = auxgetinfo(L, what, ar, ci->base - 1, ci);
+  }
+  else
+    info_tailcall(L, ar);
+  if (strchr(what, 'f')) incr_top(L);
+  lua_unlock(L);
+  return status;
+}
+
+
+/*
+** {======================================================
+** Symbolic Execution and code checker
+** =======================================================
+*/
+
+#define check(x)		if (!(x)) return 0;
+
+#define checkjump(pt,pc)	check(0 <= pc && pc < pt->sizecode)
+
+#define checkreg(pt,reg)	check((reg) < (pt)->maxstacksize)
+
+
+
+static int precheck (const Proto *pt) {
+  check(pt->maxstacksize <= MAXSTACK);
+  check(pt->sizelineinfo == pt->sizecode || pt->sizelineinfo == 0);
+  lua_assert(pt->numparams+pt->is_vararg <= pt->maxstacksize);
+  check(GET_OPCODE(pt->code[pt->sizecode-1]) == OP_RETURN);
+  return 1;
+}
+
+
+static int checkopenop (const Proto *pt, int pc) {
+  Instruction i = pt->code[pc+1];
+  switch (GET_OPCODE(i)) {
+    case OP_CALL:
+    case OP_TAILCALL:
+    case OP_RETURN: {
+      check(GETARG_B(i) == 0);
+      return 1;
+    }
+    case OP_SETLISTO: return 1;
+    default: return 0;  /* invalid instruction after an open call */
+  }
+}
+
+
+static int checkRK (const Proto *pt, int r) {
+  return (r < pt->maxstacksize || (r >= MAXSTACK && r-MAXSTACK < pt->sizek));
+}
+
+
+static Instruction luaG_symbexec (const Proto *pt, int lastpc, int reg) {
+  int pc;
+  int last;  /* stores position of last instruction that changed `reg' */
+  last = pt->sizecode-1;  /* points to final return (a `neutral' instruction) */
+  check(precheck(pt));
+  for (pc = 0; pc < lastpc; pc++) {
+    const Instruction i = pt->code[pc];
+    OpCode op = GET_OPCODE(i);
+    int a = GETARG_A(i);
+    int b = 0;
+    int c = 0;
+    checkreg(pt, a);
+    switch (getOpMode(op)) {
+      case iABC: {
+        b = GETARG_B(i);
+        c = GETARG_C(i);
+        if (testOpMode(op, OpModeBreg)) {
+          checkreg(pt, b);
+        }
+        else if (testOpMode(op, OpModeBrk))
+          check(checkRK(pt, b));
+        if (testOpMode(op, OpModeCrk))
+          check(checkRK(pt, c));
+        break;
+      }
+      case iABx: {
+        b = GETARG_Bx(i);
+        if (testOpMode(op, OpModeK)) check(b < pt->sizek);
+        break;
+      }
+      case iAsBx: {
+        b = GETARG_sBx(i);
+        break;
+      }
+    }
+    if (testOpMode(op, OpModesetA)) {
+      if (a == reg) last = pc;  /* change register `a' */
+    }
+    if (testOpMode(op, OpModeT)) {
+      check(pc+2 < pt->sizecode);  /* check skip */
+      check(GET_OPCODE(pt->code[pc+1]) == OP_JMP);
+    }
+    switch (op) {
+      case OP_LOADBOOL: {
+        check(c == 0 || pc+2 < pt->sizecode);  /* check its jump */
+        break;
+      }
+      case OP_LOADNIL: {
+        if (a <= reg && reg <= b)
+          last = pc;  /* set registers from `a' to `b' */
+        break;
+      }
+      case OP_GETUPVAL:
+      case OP_SETUPVAL: {
+        check(b < pt->nups);
+        break;
+      }
+      case OP_GETGLOBAL:
+      case OP_SETGLOBAL: {
+        check(ttisstring(&pt->k[b]));
+        break;
+      }
+      case OP_SELF: {
+        checkreg(pt, a+1);
+        if (reg == a+1) last = pc;
+        break;
+      }
+      case OP_CONCAT: {
+        /* `c' is a register, and at least two operands */
+        check(c < MAXSTACK && b < c);
+        break;
+      }
+      case OP_TFORLOOP:
+        checkreg(pt, a+c+5);
+        if (reg >= a) last = pc;  /* affect all registers above base */
+        /* go through */
+      case OP_FORLOOP:
+        checkreg(pt, a+2);
+        /* go through */
+      case OP_JMP: {
+        int dest = pc+1+b;
+	check(0 <= dest && dest < pt->sizecode);
+        /* not full check and jump is forward and do not skip `lastpc'? */
+        if (reg != NO_REG && pc < dest && dest <= lastpc)
+          pc += b;  /* do the jump */
+        break;
+      }
+      case OP_CALL:
+      case OP_TAILCALL: {
+        if (b != 0) {
+          checkreg(pt, a+b-1);
+        }
+        c--;  /* c = num. returns */
+        if (c == LUA_MULTRET) {
+          check(checkopenop(pt, pc));
+        }
+        else if (c != 0)
+          checkreg(pt, a+c-1);
+        if (reg >= a) last = pc;  /* affect all registers above base */
+        break;
+      }
+      case OP_RETURN: {
+        b--;  /* b = num. returns */
+        if (b > 0) checkreg(pt, a+b-1);
+        break;
+      }
+      case OP_SETLIST: {
+        checkreg(pt, a + (b&(LFIELDS_PER_FLUSH-1)) + 1);
+        break;
+      }
+      case OP_CLOSURE: {
+        int nup;
+        check(b < pt->sizep);
+        nup = pt->p[b]->nups;
+        check(pc + nup < pt->sizecode);
+        for (; nup>0; nup--) {
+          OpCode op1 = GET_OPCODE(pt->code[pc+nup]);
+          check(op1 == OP_GETUPVAL || op1 == OP_MOVE);
+        }
+        break;
+      }
+      default: break;
+    }
+  }
+  return pt->code[last];
+}
+
+#undef check
+#undef checkjump
+#undef checkreg
+
+/* }====================================================== */
+
+
+int luaG_checkcode (const Proto *pt) {
+  return luaG_symbexec(pt, pt->sizecode, NO_REG);
+}
+
+
+static const char *kname (Proto *p, int c) {
+  c = c - MAXSTACK;
+  if (c >= 0 && ttisstring(&p->k[c]))
+    return svalue(&p->k[c]);
+  else
+    return "?";
+}
+
+
+static const char *getobjname (CallInfo *ci, int stackpos, const char **name) {
+  if (isLua(ci)) {  /* a Lua function? */
+    Proto *p = ci_func(ci)->l.p;
+    int pc = currentpc(ci);
+    Instruction i;
+    *name = luaF_getlocalname(p, stackpos+1, pc);
+    if (*name)  /* is a local? */
+      return "local";
+    i = luaG_symbexec(p, pc, stackpos);  /* try symbolic execution */
+    lua_assert(pc != -1);
+    switch (GET_OPCODE(i)) {
+      case OP_GETGLOBAL: {
+        int g = GETARG_Bx(i);  /* global index */
+        lua_assert(ttisstring(&p->k[g]));
+        *name = svalue(&p->k[g]);
+        return "global";
+      }
+      case OP_MOVE: {
+        int a = GETARG_A(i);
+        int b = GETARG_B(i);  /* move from `b' to `a' */
+        if (b < a)
+          return getobjname(ci, b, name);  /* get name for `b' */
+        break;
+      }
+      case OP_GETTABLE: {
+        int k = GETARG_C(i);  /* key index */
+        *name = kname(p, k);
+        return "field";
+      }
+      case OP_SELF: {
+        int k = GETARG_C(i);  /* key index */
+        *name = kname(p, k);
+        return "method";
+      }
+      default: break;
+    }
+  }
+  return NULL;  /* no useful name found */
+}
+
+
+static const char *getfuncname (CallInfo *ci, const char **name) {
+  Instruction i;
+  if ((isLua(ci) && ci->u.l.tailcalls > 0) || !isLua(ci - 1))
+    return NULL;  /* calling function is not Lua (or is unknown) */
+  ci--;  /* calling function */
+  i = ci_func(ci)->l.p->code[currentpc(ci)];
+  if (GET_OPCODE(i) == OP_CALL || GET_OPCODE(i) == OP_TAILCALL)
+    return getobjname(ci, GETARG_A(i), name);
+  else
+    return NULL;  /* no useful name can be found */
+}
+
+
+/* only ANSI way to check whether a pointer points to an array */
+static int isinstack (CallInfo *ci, const TObject *o) {
+  StkId p;
+  for (p = ci->base; p < ci->top; p++)
+    if (o == p) return 1;
+  return 0;
+}
+
+
+void luaG_typeerror (lua_State *L, const TObject *o, const char *op) {
+  const char *name = NULL;
+  const char *t = luaT_typenames[ttype(o)];
+  const char *kind = (isinstack(L->ci, o)) ?
+                         getobjname(L->ci, o - L->base, &name) : NULL;
+  if (kind)
+    luaG_runerror(L, "attempt to %s %s `%s' (a %s value)",
+                op, kind, name, t);
+  else
+    luaG_runerror(L, "attempt to %s a %s value", op, t);
+}
+
+
+void luaG_concaterror (lua_State *L, StkId p1, StkId p2) {
+  if (ttisstring(p1)) p1 = p2;
+  lua_assert(!ttisstring(p1));
+  luaG_typeerror(L, p1, "concatenate");
+}
+
+
+void luaG_aritherror (lua_State *L, const TObject *p1, const TObject *p2) {
+  TObject temp;
+  if (luaV_tonumber(p1, &temp) == NULL)
+    p2 = p1;  /* first operand is wrong */
+  luaG_typeerror(L, p2, "perform arithmetic on");
+}
+
+
+int luaG_ordererror (lua_State *L, const TObject *p1, const TObject *p2) {
+  const char *t1 = luaT_typenames[ttype(p1)];
+  const char *t2 = luaT_typenames[ttype(p2)];
+  if (t1[2] == t2[2])
+    luaG_runerror(L, "attempt to compare two %s values", t1);
+  else
+    luaG_runerror(L, "attempt to compare %s with %s", t1, t2);
+  return 0;
+}
+
+
+static void addinfo (lua_State *L, const char *msg) {
+  CallInfo *ci = L->ci;
+  if (isLua(ci)) {  /* is Lua code? */
+    char buff[LUA_IDSIZE];  /* add file:line information */
+    int line = currentline(ci);
+    luaO_chunkid(buff, getstr(getluaproto(ci)->source), LUA_IDSIZE);
+    luaO_pushfstring(L, "%s:%d: %s", buff, line, msg);
+  }
+}
+
+
+void luaG_errormsg (lua_State *L) {
+  if (L->errfunc != 0) {  /* is there an error handling function? */
+    StkId errfunc = restorestack(L, L->errfunc);
+    if (!ttisfunction(errfunc)) luaD_throw(L, LUA_ERRERR);
+    setobjs2s(L->top, L->top - 1);  /* move argument */
+    setobjs2s(L->top - 1, errfunc);  /* push function */
+    incr_top(L);
+    luaD_call(L, L->top - 2, 1);  /* call it */
+  }
+  luaD_throw(L, LUA_ERRRUN);
+}
+
+
+void luaG_runerror (lua_State *L, const char *fmt, ...) {
+  va_list argp;
+  va_start(argp, fmt);
+  addinfo(L, luaO_pushvfstring(L, fmt, argp));
+  va_end(argp);
+  luaG_errormsg(L);
+}
+

Added: trunk/Util/deditor/lua/ldebug.h
===================================================================
--- trunk/Util/deditor/lua/ldebug.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ldebug.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,31 @@
+/*
+** $Id: ldebug.h,v 1.32 2002/11/18 11:01:55 roberto Exp $
+** Auxiliary functions from Debug Interface module
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ldebug_h
+#define ldebug_h
+
+
+#include "lstate.h"
+
+
+#define pcRel(pc, p)	(cast(int, (pc) - (p)->code) - 1)
+
+#define getline(f,pc)	(((f)->lineinfo) ? (f)->lineinfo[pc] : 0)
+
+#define resethookcount(L)	(L->hookcount = L->basehookcount)
+
+
+void luaG_inithooks (lua_State *L);
+void luaG_typeerror (lua_State *L, const TObject *o, const char *opname);
+void luaG_concaterror (lua_State *L, StkId p1, StkId p2);
+void luaG_aritherror (lua_State *L, const TObject *p1, const TObject *p2);
+int luaG_ordererror (lua_State *L, const TObject *p1, const TObject *p2);
+void luaG_runerror (lua_State *L, const char *fmt, ...);
+void luaG_errormsg (lua_State *L);
+int luaG_checkcode (const Proto *pt);
+
+
+#endif

Added: trunk/Util/deditor/lua/ldo.c
===================================================================
--- trunk/Util/deditor/lua/ldo.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ldo.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,458 @@
+/*
+** $Id: ldo.c,v 1.217 2003/04/03 13:35:34 roberto Exp $
+** Stack and Call structure of Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#include <setjmp.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define ldo_c
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lundump.h"
+#include "lvm.h"
+#include "lzio.h"
+
+
+
+
+/*
+** {======================================================
+** Error-recovery functions (based on long jumps)
+** =======================================================
+*/
+
+
+/* chain list of long jump buffers */
+struct lua_longjmp {
+  struct lua_longjmp *previous;
+  jmp_buf b;
+  volatile int status;  /* error code */
+};
+
+
+static void seterrorobj (lua_State *L, int errcode, StkId oldtop) {
+  switch (errcode) {
+    case LUA_ERRMEM: {
+      setsvalue2s(oldtop, luaS_new(L, MEMERRMSG));
+      break;
+    }
+    case LUA_ERRERR: {
+      setsvalue2s(oldtop, luaS_new(L, "error in error handling"));
+      break;
+    }
+    case LUA_ERRSYNTAX:
+    case LUA_ERRRUN: {
+      setobjs2s(oldtop, L->top - 1);  /* error message on current top */
+      break;
+    }
+  }
+  L->top = oldtop + 1;
+}
+
+
+void luaD_throw (lua_State *L, int errcode) {
+  if (L->errorJmp) {
+    L->errorJmp->status = errcode;
+    longjmp(L->errorJmp->b, 1);
+  }
+  else {
+    G(L)->panic(L);
+    exit(EXIT_FAILURE);
+  }
+}
+
+
+int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
+  struct lua_longjmp lj;
+  lj.status = 0;
+  lj.previous = L->errorJmp;  /* chain new error handler */
+  L->errorJmp = &lj;
+  if (setjmp(lj.b) == 0)
+    (*f)(L, ud);
+  L->errorJmp = lj.previous;  /* restore old error handler */
+  return lj.status;
+}
+
+
+static void restore_stack_limit (lua_State *L) {
+  L->stack_last = L->stack+L->stacksize-1;
+  if (L->size_ci > LUA_MAXCALLS) {  /* there was an overflow? */
+    int inuse = (L->ci - L->base_ci);
+    if (inuse + 1 < LUA_MAXCALLS)  /* can `undo' overflow? */
+      luaD_reallocCI(L, LUA_MAXCALLS);
+  }
+}
+
+/* }====================================================== */
+
+
+static void correctstack (lua_State *L, TObject *oldstack) {
+  CallInfo *ci;
+  GCObject *up;
+  L->top = (L->top - oldstack) + L->stack;
+  for (up = L->openupval; up != NULL; up = up->gch.next)
+    gcotouv(up)->v = (gcotouv(up)->v - oldstack) + L->stack;
+  for (ci = L->base_ci; ci <= L->ci; ci++) {
+    ci->top = (ci->top - oldstack) + L->stack;
+    ci->base = (ci->base - oldstack) + L->stack;
+  }
+  L->base = L->ci->base;
+}
+
+
+void luaD_reallocstack (lua_State *L, int newsize) {
+  TObject *oldstack = L->stack;
+  luaM_reallocvector(L, L->stack, L->stacksize, newsize, TObject);
+  L->stacksize = newsize;
+  L->stack_last = L->stack+newsize-1-EXTRA_STACK;
+  correctstack(L, oldstack);
+}
+
+
+void luaD_reallocCI (lua_State *L, int newsize) {
+  CallInfo *oldci = L->base_ci;
+  luaM_reallocvector(L, L->base_ci, L->size_ci, newsize, CallInfo);
+  L->size_ci = cast(unsigned short, newsize);
+  L->ci = (L->ci - oldci) + L->base_ci;
+  L->end_ci = L->base_ci + L->size_ci;
+}
+
+
+void luaD_growstack (lua_State *L, int n) {
+  if (n <= L->stacksize)  /* double size is enough? */
+    luaD_reallocstack(L, 2*L->stacksize);
+  else
+    luaD_reallocstack(L, L->stacksize + n + EXTRA_STACK);
+}
+
+
+static void luaD_growCI (lua_State *L) {
+  if (L->size_ci > LUA_MAXCALLS)  /* overflow while handling overflow? */
+    luaD_throw(L, LUA_ERRERR);
+  else {
+    luaD_reallocCI(L, 2*L->size_ci);
+    if (L->size_ci > LUA_MAXCALLS)
+      luaG_runerror(L, "stack overflow");
+  }
+}
+
+
+void luaD_callhook (lua_State *L, int event, int line) {
+  lua_Hook hook = L->hook;
+  if (hook && L->allowhook) {
+    ptrdiff_t top = savestack(L, L->top);
+    ptrdiff_t ci_top = savestack(L, L->ci->top);
+    lua_Debug ar;
+    ar.event = event;
+    ar.currentline = line;
+    if (event == LUA_HOOKTAILRET)
+      ar.i_ci = 0;  /* tail call; no debug information about it */
+    else
+      ar.i_ci = L->ci - L->base_ci;
+    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
+    L->ci->top = L->top + LUA_MINSTACK;
+    L->allowhook = 0;  /* cannot call hooks inside a hook */
+    lua_unlock(L);
+    (*hook)(L, &ar);
+    lua_lock(L);
+    lua_assert(!L->allowhook);
+    L->allowhook = 1;
+    L->ci->top = restorestack(L, ci_top);
+    L->top = restorestack(L, top);
+  }
+}
+
+
+static void adjust_varargs (lua_State *L, int nfixargs, StkId base) {
+  int i;
+  Table *htab;
+  TObject nname;
+  int actual = L->top - base;  /* actual number of arguments */
+  if (actual < nfixargs) {
+    luaD_checkstack(L, nfixargs - actual);
+    for (; actual < nfixargs; ++actual)
+      setnilvalue(L->top++);
+  }
+  actual -= nfixargs;  /* number of extra arguments */
+  htab = luaH_new(L, actual, 1);  /* create `arg' table */
+  for (i=0; i<actual; i++)  /* put extra arguments into `arg' table */
+    setobj2n(luaH_setnum(L, htab, i+1), L->top - actual + i);
+  /* store counter in field `n' */
+  setsvalue(&nname, luaS_newliteral(L, "n"));
+  setnvalue(luaH_set(L, htab, &nname), cast(lua_Number, actual));
+  L->top -= actual;  /* remove extra elements from the stack */
+  sethvalue(L->top, htab);
+  incr_top(L);
+}
+
+
+static StkId tryfuncTM (lua_State *L, StkId func) {
+  const TObject *tm = luaT_gettmbyobj(L, func, TM_CALL);
+  StkId p;
+  ptrdiff_t funcr = savestack(L, func);
+  if (!ttisfunction(tm))
+    luaG_typeerror(L, func, "call");
+  /* Open a hole inside the stack at `func' */
+  for (p = L->top; p > func; p--) setobjs2s(p, p-1);
+  incr_top(L);
+  func = restorestack(L, funcr);  /* previous call may change stack */
+  setobj2s(func, tm);  /* tag method is the new function to be called */
+  return func;
+}
+
+
+StkId luaD_precall (lua_State *L, StkId func) {
+  LClosure *cl;
+  ptrdiff_t funcr = savestack(L, func);
+  if (!ttisfunction(func)) /* `func' is not a function? */
+    func = tryfuncTM(L, func);  /* check the `function' tag method */
+  if (L->ci + 1 == L->end_ci) luaD_growCI(L);
+  else condhardstacktests(luaD_reallocCI(L, L->size_ci));
+  cl = &clvalue(func)->l;
+  if (!cl->isC) {  /* Lua function? prepare its call */
+    CallInfo *ci;
+    Proto *p = cl->p;
+    if (p->is_vararg)  /* varargs? */
+      adjust_varargs(L, p->numparams, func+1);
+    luaD_checkstack(L, p->maxstacksize);
+    ci = ++L->ci;  /* now `enter' new function */
+    L->base = L->ci->base = restorestack(L, funcr) + 1;
+    ci->top = L->base + p->maxstacksize;
+    ci->u.l.savedpc = p->code;  /* starting point */
+    ci->u.l.tailcalls = 0;
+    ci->state = CI_SAVEDPC;
+    while (L->top < ci->top)
+      setnilvalue(L->top++);
+    L->top = ci->top;
+    return NULL;
+  }
+  else {  /* if is a C function, call it */
+    CallInfo *ci;
+    int n;
+    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
+    ci = ++L->ci;  /* now `enter' new function */
+    L->base = L->ci->base = restorestack(L, funcr) + 1;
+    ci->top = L->top + LUA_MINSTACK;
+    ci->state = CI_C;  /* a C function */
+    if (L->hookmask & LUA_MASKCALL)
+      luaD_callhook(L, LUA_HOOKCALL, -1);
+    lua_unlock(L);
+#ifdef LUA_COMPATUPVALUES
+    lua_pushupvalues(L);
+#endif
+    n = (*clvalue(L->base - 1)->c.f)(L);  /* do the actual call */
+    lua_lock(L);
+    return L->top - n;
+  }
+}
+
+
+static StkId callrethooks (lua_State *L, StkId firstResult) {
+  ptrdiff_t fr = savestack(L, firstResult);  /* next call may change stack */
+  luaD_callhook(L, LUA_HOOKRET, -1);
+  if (!(L->ci->state & CI_C)) {  /* Lua function? */
+    while (L->ci->u.l.tailcalls--)  /* call hook for eventual tail calls */
+      luaD_callhook(L, LUA_HOOKTAILRET, -1);
+  }
+  return restorestack(L, fr);
+}
+
+
+void luaD_poscall (lua_State *L, int wanted, StkId firstResult) { 
+  StkId res;
+  if (L->hookmask & LUA_MASKRET)
+    firstResult = callrethooks(L, firstResult);
+  res = L->base - 1;  /* res == final position of 1st result */
+  L->ci--;
+  L->base = L->ci->base;  /* restore base */
+  /* move results to correct place */
+  while (wanted != 0 && firstResult < L->top) {
+    setobjs2s(res++, firstResult++);
+    wanted--;
+  }
+  while (wanted-- > 0)
+    setnilvalue(res++);
+  L->top = res;
+}
+
+
+/*
+** Call a function (C or Lua). The function to be called is at *func.
+** The arguments are on the stack, right after the function.
+** When returns, all the results are on the stack, starting at the original
+** function position.
+*/ 
+void luaD_call (lua_State *L, StkId func, int nResults) {
+  StkId firstResult;
+  lua_assert(!(L->ci->state & CI_CALLING));
+  if (++L->nCcalls >= LUA_MAXCCALLS) {
+    if (L->nCcalls == LUA_MAXCCALLS)
+      luaG_runerror(L, "C stack overflow");
+    else if (L->nCcalls >= (LUA_MAXCCALLS + (LUA_MAXCCALLS>>3)))
+      luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */
+  }
+  firstResult = luaD_precall(L, func);
+  if (firstResult == NULL)  /* is a Lua function? */
+    firstResult = luaV_execute(L);  /* call it */
+  luaD_poscall(L, nResults, firstResult);
+  L->nCcalls--;
+  luaC_checkGC(L);
+}
+
+
+static void resume (lua_State *L, void *ud) {
+  StkId firstResult;
+  int nargs = *cast(int *, ud);
+  CallInfo *ci = L->ci;
+  if (ci == L->base_ci) {  /* no activation record? */
+    if (nargs >= L->top - L->base)
+      luaG_runerror(L, "cannot resume dead coroutine");
+    luaD_precall(L, L->top - (nargs + 1));  /* start coroutine */
+  }
+  else if (ci->state & CI_YIELD) {  /* inside a yield? */
+    if (ci->state & CI_C) {  /* `common' yield? */
+      /* finish interrupted execution of `OP_CALL' */
+      int nresults;
+      lua_assert((ci-1)->state & CI_SAVEDPC);
+      lua_assert(GET_OPCODE(*((ci-1)->u.l.savedpc - 1)) == OP_CALL ||
+                 GET_OPCODE(*((ci-1)->u.l.savedpc - 1)) == OP_TAILCALL);
+      nresults = GETARG_C(*((ci-1)->u.l.savedpc - 1)) - 1;
+      luaD_poscall(L, nresults, L->top - nargs);  /* complete it */
+      if (nresults >= 0) L->top = L->ci->top;
+    }
+    else {  /* yielded inside a hook: just continue its execution */
+      ci->state &= ~CI_YIELD;
+    }
+  }
+  else
+    luaG_runerror(L, "cannot resume non-suspended coroutine");
+  firstResult = luaV_execute(L);
+  if (firstResult != NULL)   /* return? */
+    luaD_poscall(L, LUA_MULTRET, firstResult);  /* finalize this coroutine */
+}
+
+
+LUA_API int lua_resume (lua_State *L, int nargs) {
+  int status;
+  lu_byte old_allowhooks;
+  lua_lock(L);
+  old_allowhooks = L->allowhook;
+  lua_assert(L->errfunc == 0 && L->nCcalls == 0);
+  status = luaD_rawrunprotected(L, resume, &nargs);
+  if (status != 0) {  /* error? */
+    L->ci = L->base_ci;  /* go back to initial level */
+    L->base = L->ci->base;
+    L->nCcalls = 0;
+    luaF_close(L, L->base);  /* close eventual pending closures */
+    seterrorobj(L, status, L->base);
+    L->allowhook = old_allowhooks;
+    restore_stack_limit(L);
+  }
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_yield (lua_State *L, int nresults) {
+  CallInfo *ci;
+  lua_lock(L);
+  ci = L->ci;
+  if (L->nCcalls > 0)
+    luaG_runerror(L, "attempt to yield across metamethod/C-call boundary");
+  if (ci->state & CI_C) {  /* usual yield */
+    if ((ci-1)->state & CI_C)
+      luaG_runerror(L, "cannot yield a C function");
+    if (L->top - nresults > L->base) {  /* is there garbage in the stack? */
+      int i;
+      for (i=0; i<nresults; i++)  /* move down results */
+        setobjs2s(L->base + i, L->top - nresults + i);
+      L->top = L->base + nresults;
+    }
+  } /* else it's an yield inside a hook: nothing to do */
+  ci->state |= CI_YIELD;
+  lua_unlock(L);
+  return -1;
+}
+
+
+int luaD_pcall (lua_State *L, Pfunc func, void *u,
+                ptrdiff_t old_top, ptrdiff_t ef) {
+  int status;
+  unsigned short oldnCcalls = L->nCcalls;
+  ptrdiff_t old_ci = saveci(L, L->ci);
+  lu_byte old_allowhooks = L->allowhook;
+  ptrdiff_t old_errfunc = L->errfunc;
+  L->errfunc = ef;
+  status = luaD_rawrunprotected(L, func, u);
+  if (status != 0) {  /* an error occurred? */
+    StkId oldtop = restorestack(L, old_top);
+    luaF_close(L, oldtop);  /* close eventual pending closures */
+    seterrorobj(L, status, oldtop);
+    L->nCcalls = oldnCcalls;
+    L->ci = restoreci(L, old_ci);
+    L->base = L->ci->base;
+    L->allowhook = old_allowhooks;
+    restore_stack_limit(L);
+  }
+  L->errfunc = old_errfunc;
+  return status;
+}
+
+
+
+/*
+** Execute a protected parser.
+*/
+struct SParser {  /* data to `f_parser' */
+  ZIO *z;
+  Mbuffer buff;  /* buffer to be used by the scanner */
+  int bin;
+};
+
+static void f_parser (lua_State *L, void *ud) {
+  struct SParser *p;
+  Proto *tf;
+  Closure *cl;
+  luaC_checkGC(L);
+  p = cast(struct SParser *, ud);
+  tf = p->bin ? luaU_undump(L, p->z, &p->buff) : luaY_parser(L, p->z, &p->buff);
+  cl = luaF_newLclosure(L, 0, gt(L));
+  cl->l.p = tf;
+  setclvalue(L->top, cl);
+  incr_top(L);
+}
+
+
+int luaD_protectedparser (lua_State *L, ZIO *z, int bin) {
+  struct SParser p;
+  int status;
+  ptrdiff_t oldtopr = savestack(L, L->top);  /* save current top */
+  p.z = z; p.bin = bin;
+  luaZ_initbuffer(L, &p.buff);
+  status = luaD_rawrunprotected(L, f_parser, &p);
+  luaZ_freebuffer(L, &p.buff);
+  if (status != 0) {  /* error? */
+    StkId oldtop = restorestack(L, oldtopr);
+    seterrorobj(L, status, oldtop);
+  }
+  return status;
+}
+
+

Added: trunk/Util/deditor/lua/ldo.h
===================================================================
--- trunk/Util/deditor/lua/ldo.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ldo.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,60 @@
+/*
+** $Id: ldo.h,v 1.56 2002/12/04 17:29:32 roberto Exp $
+** Stack and Call structure of Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ldo_h
+#define ldo_h
+
+
+#include "lobject.h"
+#include "lstate.h"
+#include "lzio.h"
+
+
+/*
+** macro to control inclusion of some hard tests on stack reallocation
+*/ 
+#ifndef HARDSTACKTESTS
+#define condhardstacktests(x)	{ /* empty */ }
+#else
+#define condhardstacktests(x)	x
+#endif
+
+
+#define luaD_checkstack(L,n)	\
+  if ((char *)L->stack_last - (char *)L->top <= (n)*(int)sizeof(TObject)) \
+    luaD_growstack(L, n); \
+  else condhardstacktests(luaD_reallocstack(L, L->stacksize));
+
+
+#define incr_top(L) {luaD_checkstack(L,1); L->top++;}
+
+#define savestack(L,p)		((char *)(p) - (char *)L->stack)
+#define restorestack(L,n)	((TObject *)((char *)L->stack + (n)))
+
+#define saveci(L,p)		((char *)(p) - (char *)L->base_ci)
+#define restoreci(L,n)		((CallInfo *)((char *)L->base_ci + (n)))
+
+
+/* type of protected functions, to be ran by `runprotected' */
+typedef void (*Pfunc) (lua_State *L, void *ud);
+
+void luaD_resetprotection (lua_State *L);
+int luaD_protectedparser (lua_State *L, ZIO *z, int bin);
+void luaD_callhook (lua_State *L, int event, int line);
+StkId luaD_precall (lua_State *L, StkId func);
+void luaD_call (lua_State *L, StkId func, int nResults);
+int luaD_pcall (lua_State *L, Pfunc func, void *u,
+                ptrdiff_t oldtop, ptrdiff_t ef);
+void luaD_poscall (lua_State *L, int wanted, StkId firstResult);
+void luaD_reallocCI (lua_State *L, int newsize);
+void luaD_reallocstack (lua_State *L, int newsize);
+void luaD_growstack (lua_State *L, int n);
+
+void luaD_throw (lua_State *L, int errcode);
+int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud);
+
+
+#endif

Added: trunk/Util/deditor/lua/ldump.c
===================================================================
--- trunk/Util/deditor/lua/ldump.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ldump.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,170 @@
+/*
+** $Id: ldump.c,v 1.4 2003/02/11 23:52:12 lhf Exp $
+** save bytecodes
+** See Copyright Notice in lua.h
+*/
+
+#include <stddef.h>
+
+#define ldump_c
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lstate.h"
+#include "lundump.h"
+
+#define DumpVector(b,n,size,D)	DumpBlock(b,(n)*(size),D)
+#define DumpLiteral(s,D)	DumpBlock("" s,(sizeof(s))-1,D)
+
+typedef struct {
+ lua_State* L;
+ lua_Chunkwriter write;
+ void* data;
+} DumpState;
+
+static void DumpBlock(const void* b, size_t size, DumpState* D)
+{
+ lua_unlock(D->L);
+ (*D->write)(D->L,b,size,D->data);
+ lua_lock(D->L);
+}
+
+static void DumpByte(int y, DumpState* D)
+{
+ char x=(char)y;
+ DumpBlock(&x,sizeof(x),D);
+}
+
+static void DumpInt(int x, DumpState* D)
+{
+ DumpBlock(&x,sizeof(x),D);
+}
+
+static void DumpSize(size_t x, DumpState* D)
+{
+ DumpBlock(&x,sizeof(x),D);
+}
+
+static void DumpNumber(lua_Number x, DumpState* D)
+{
+ DumpBlock(&x,sizeof(x),D);
+}
+
+static void DumpString(TString* s, DumpState* D)
+{
+ if (s==NULL || getstr(s)==NULL)
+  DumpSize(0,D);
+ else
+ {
+  size_t size=s->tsv.len+1;		/* include trailing '\0' */
+  DumpSize(size,D);
+  DumpBlock(getstr(s),size,D);
+ }
+}
+
+static void DumpCode(const Proto* f, DumpState* D)
+{
+ DumpInt(f->sizecode,D);
+ DumpVector(f->code,f->sizecode,sizeof(*f->code),D);
+}
+
+static void DumpLocals(const Proto* f, DumpState* D)
+{
+ int i,n=f->sizelocvars;
+ DumpInt(n,D);
+ for (i=0; i<n; i++)
+ {
+  DumpString(f->locvars[i].varname,D);
+  DumpInt(f->locvars[i].startpc,D);
+  DumpInt(f->locvars[i].endpc,D);
+ }
+}
+
+static void DumpLines(const Proto* f, DumpState* D)
+{
+ DumpInt(f->sizelineinfo,D);
+ DumpVector(f->lineinfo,f->sizelineinfo,sizeof(*f->lineinfo),D);
+}
+
+static void DumpUpvalues(const Proto* f, DumpState* D)
+{
+ int i,n=f->sizeupvalues;
+ DumpInt(n,D);
+ for (i=0; i<n; i++) DumpString(f->upvalues[i],D);
+}
+
+static void DumpFunction(const Proto* f, const TString* p, DumpState* D);
+
+static void DumpConstants(const Proto* f, DumpState* D)
+{
+ int i,n;
+ DumpInt(n=f->sizek,D);
+ for (i=0; i<n; i++)
+ {
+  const TObject* o=&f->k[i];
+  DumpByte(ttype(o),D);
+  switch (ttype(o))
+  {
+   case LUA_TNUMBER:
+	DumpNumber(nvalue(o),D);
+	break;
+   case LUA_TSTRING:
+	DumpString(tsvalue(o),D);
+	break;
+   case LUA_TNIL:
+	break;
+   default:
+	lua_assert(0);			/* cannot happen */
+	break;
+  }
+ }
+ DumpInt(n=f->sizep,D);
+ for (i=0; i<n; i++) DumpFunction(f->p[i],f->source,D);
+}
+
+static void DumpFunction(const Proto* f, const TString* p, DumpState* D)
+{
+ DumpString((f->source==p) ? NULL : f->source,D);
+ DumpInt(f->lineDefined,D);
+ DumpByte(f->nups,D);
+ DumpByte(f->numparams,D);
+ DumpByte(f->is_vararg,D);
+ DumpByte(f->maxstacksize,D);
+ DumpLines(f,D);
+ DumpLocals(f,D);
+ DumpUpvalues(f,D);
+ DumpConstants(f,D);
+ DumpCode(f,D);
+}
+
+static void DumpHeader(DumpState* D)
+{
+ DumpLiteral(LUA_SIGNATURE,D);
+ DumpByte(VERSION,D);
+ DumpByte(luaU_endianness(),D);
+ DumpByte(sizeof(int),D);
+ DumpByte(sizeof(size_t),D);
+ DumpByte(sizeof(Instruction),D);
+ DumpByte(SIZE_OP,D);
+ DumpByte(SIZE_A,D);
+ DumpByte(SIZE_B,D);
+ DumpByte(SIZE_C,D);
+ DumpByte(sizeof(lua_Number),D);
+ DumpNumber(TEST_NUMBER,D);
+}
+
+/*
+** dump function as precompiled chunk
+*/
+void luaU_dump (lua_State* L, const Proto* Main, lua_Chunkwriter w, void* data)
+{
+ DumpState D;
+ D.L=L;
+ D.write=w;
+ D.data=data;
+ DumpHeader(&D);
+ DumpFunction(Main,NULL,&D);
+}
+

Added: trunk/Util/deditor/lua/lfunc.c
===================================================================
--- trunk/Util/deditor/lua/lfunc.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lfunc.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,135 @@
+/*
+** $Id: lfunc.c,v 1.67 2003/03/18 12:50:04 roberto Exp $
+** Auxiliary functions to manipulate prototypes and closures
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+
+#define lfunc_c
+
+#include "lua.h"
+
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+
+
+#define sizeCclosure(n)	(cast(int, sizeof(CClosure)) + \
+                         cast(int, sizeof(TObject)*((n)-1)))
+
+#define sizeLclosure(n)	(cast(int, sizeof(LClosure)) + \
+                         cast(int, sizeof(TObject *)*((n)-1)))
+
+
+
+Closure *luaF_newCclosure (lua_State *L, int nelems) {
+  Closure *c = cast(Closure *, luaM_malloc(L, sizeCclosure(nelems)));
+  luaC_link(L, valtogco(c), LUA_TFUNCTION);
+  c->c.isC = 1;
+  c->c.nupvalues = cast(lu_byte, nelems);
+  return c;
+}
+
+
+Closure *luaF_newLclosure (lua_State *L, int nelems, TObject *e) {
+  Closure *c = cast(Closure *, luaM_malloc(L, sizeLclosure(nelems)));
+  luaC_link(L, valtogco(c), LUA_TFUNCTION);
+  c->l.isC = 0;
+  c->l.g = *e;
+  c->l.nupvalues = cast(lu_byte, nelems);
+  return c;
+}
+
+
+UpVal *luaF_findupval (lua_State *L, StkId level) {
+  GCObject **pp = &L->openupval;
+  UpVal *p;
+  UpVal *v;
+  while ((p = ngcotouv(*pp)) != NULL && p->v >= level) {
+    if (p->v == level) return p;
+    pp = &p->next;
+  }
+  v = luaM_new(L, UpVal);  /* not found: create a new one */
+  v->tt = LUA_TUPVAL;
+  v->marked = 1;  /* open upvalues should not be collected */
+  v->v = level;  /* current value lives in the stack */
+  v->next = *pp;  /* chain it in the proper position */
+  *pp = valtogco(v);
+  return v;
+}
+
+
+void luaF_close (lua_State *L, StkId level) {
+  UpVal *p;
+  while ((p = ngcotouv(L->openupval)) != NULL && p->v >= level) {
+    setobj(&p->value, p->v);  /* save current value (write barrier) */
+    p->v = &p->value;  /* now current value lives here */
+    L->openupval = p->next;  /* remove from `open' list */
+    luaC_link(L, valtogco(p), LUA_TUPVAL);
+  }
+}
+
+
+Proto *luaF_newproto (lua_State *L) {
+  Proto *f = luaM_new(L, Proto);
+  luaC_link(L, valtogco(f), LUA_TPROTO);
+  f->k = NULL;
+  f->sizek = 0;
+  f->p = NULL;
+  f->sizep = 0;
+  f->code = NULL;
+  f->sizecode = 0;
+  f->sizelineinfo = 0;
+  f->sizeupvalues = 0;
+  f->nups = 0;
+  f->upvalues = NULL;
+  f->numparams = 0;
+  f->is_vararg = 0;
+  f->maxstacksize = 0;
+  f->lineinfo = NULL;
+  f->sizelocvars = 0;
+  f->locvars = NULL;
+  f->lineDefined = 0;
+  f->source = NULL;
+  return f;
+}
+
+
+void luaF_freeproto (lua_State *L, Proto *f) {
+  luaM_freearray(L, f->code, f->sizecode, Instruction);
+  luaM_freearray(L, f->p, f->sizep, Proto *);
+  luaM_freearray(L, f->k, f->sizek, TObject);
+  luaM_freearray(L, f->lineinfo, f->sizelineinfo, int);
+  luaM_freearray(L, f->locvars, f->sizelocvars, struct LocVar);
+  luaM_freearray(L, f->upvalues, f->sizeupvalues, TString *);
+  luaM_freelem(L, f);
+}
+
+
+void luaF_freeclosure (lua_State *L, Closure *c) {
+  int size = (c->c.isC) ? sizeCclosure(c->c.nupvalues) :
+                          sizeLclosure(c->l.nupvalues);
+  luaM_free(L, c, size);
+}
+
+
+/*
+** Look for n-th local variable at line `line' in function `func'.
+** Returns NULL if not found.
+*/
+const char *luaF_getlocalname (const Proto *f, int local_number, int pc) {
+  int i;
+  for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {
+    if (pc < f->locvars[i].endpc) {  /* is variable active? */
+      local_number--;
+      if (local_number == 0)
+        return getstr(f->locvars[i].varname);
+    }
+  }
+  return NULL;  /* not found */
+}
+

Added: trunk/Util/deditor/lua/lfunc.h
===================================================================
--- trunk/Util/deditor/lua/lfunc.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lfunc.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,25 @@
+/*
+** $Id: lfunc.h,v 1.21 2003/03/18 12:50:04 roberto Exp $
+** Auxiliary functions to manipulate prototypes and closures
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lfunc_h
+#define lfunc_h
+
+
+#include "lobject.h"
+
+
+Proto *luaF_newproto (lua_State *L);
+Closure *luaF_newCclosure (lua_State *L, int nelems);
+Closure *luaF_newLclosure (lua_State *L, int nelems, TObject *e);
+UpVal *luaF_findupval (lua_State *L, StkId level);
+void luaF_close (lua_State *L, StkId level);
+void luaF_freeproto (lua_State *L, Proto *f);
+void luaF_freeclosure (lua_State *L, Closure *c);
+
+const char *luaF_getlocalname (const Proto *func, int local_number, int pc);
+
+
+#endif

Added: trunk/Util/deditor/lua/lgc.c
===================================================================
--- trunk/Util/deditor/lua/lgc.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lgc.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,493 @@
+/*
+** $Id: lgc.c,v 1.171 2003/04/03 13:35:34 roberto Exp $
+** Garbage Collector
+** See Copyright Notice in lua.h
+*/
+
+#include <string.h>
+
+#define lgc_c
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+
+
+typedef struct GCState {
+  GCObject *tmark;  /* list of marked objects to be traversed */
+  GCObject *wk;  /* list of traversed key-weak tables (to be cleared) */
+  GCObject *wv;  /* list of traversed value-weak tables */
+  GCObject *wkv;  /* list of traversed key-value weak tables */
+  global_State *g;
+} GCState;
+
+
+/*
+** some userful bit tricks
+*/
+#define setbit(x,b)	((x) |= (1<<(b)))
+#define resetbit(x,b)	((x) &= cast(lu_byte, ~(1<<(b))))
+#define testbit(x,b)	((x) & (1<<(b)))
+
+#define unmark(x)	resetbit((x)->gch.marked, 0)
+#define ismarked(x)	((x)->gch.marked & ((1<<4)|1))
+
+#define stringmark(s)	setbit((s)->tsv.marked, 0)
+
+
+#define isfinalized(u)		(!testbit((u)->uv.marked, 1))
+#define markfinalized(u)	resetbit((u)->uv.marked, 1)
+
+
+#define KEYWEAKBIT    1
+#define VALUEWEAKBIT  2
+#define KEYWEAK         (1<<KEYWEAKBIT)
+#define VALUEWEAK       (1<<VALUEWEAKBIT)
+
+
+
+#define markobject(st,o) { checkconsistency(o); \
+  if (iscollectable(o) && !ismarked(gcvalue(o))) reallymarkobject(st,gcvalue(o)); }
+
+#define condmarkobject(st,o,c) { checkconsistency(o); \
+  if (iscollectable(o) && !ismarked(gcvalue(o)) && (c)) \
+    reallymarkobject(st,gcvalue(o)); }
+
+#define markvalue(st,t) { if (!ismarked(valtogco(t))) \
+		reallymarkobject(st, valtogco(t)); }
+
+
+
+static void reallymarkobject (GCState *st, GCObject *o) {
+  lua_assert(!ismarked(o));
+  setbit(o->gch.marked, 0);  /* mark object */
+  switch (o->gch.tt) {
+    case LUA_TUSERDATA: {
+      markvalue(st, gcotou(o)->uv.metatable);
+      break;
+    }
+    case LUA_TFUNCTION: {
+      gcotocl(o)->c.gclist = st->tmark;
+      st->tmark = o;
+      break;
+    }
+    case LUA_TTABLE: {
+      gcotoh(o)->gclist = st->tmark;
+      st->tmark = o;
+      break;
+    }
+    case LUA_TTHREAD: {
+      gcototh(o)->gclist = st->tmark;
+      st->tmark = o;
+      break;
+    }
+    case LUA_TPROTO: {
+      gcotop(o)->gclist = st->tmark;
+      st->tmark = o;
+      break;
+    }
+    default: lua_assert(o->gch.tt == LUA_TSTRING);
+  }
+}
+
+
+static void marktmu (GCState *st) {
+  GCObject *u;
+  for (u = st->g->tmudata; u; u = u->gch.next) {
+    unmark(u);  /* may be marked, if left from previous GC */
+    reallymarkobject(st, u);
+  }
+}
+
+
+/* move `dead' udata that need finalization to list `tmudata' */
+void luaC_separateudata (lua_State *L) {
+  GCObject **p = &G(L)->rootudata;
+  GCObject *curr;
+  GCObject *collected = NULL;  /* to collect udata with gc event */
+  GCObject **lastcollected = &collected;
+  while ((curr = *p) != NULL) {
+    lua_assert(curr->gch.tt == LUA_TUSERDATA);
+    if (ismarked(curr) || isfinalized(gcotou(curr)))
+      p = &curr->gch.next;  /* don't bother with them */
+
+    else if (fasttm(L, gcotou(curr)->uv.metatable, TM_GC) == NULL) {
+      markfinalized(gcotou(curr));  /* don't need finalization */
+      p = &curr->gch.next;
+    }
+    else {  /* must call its gc method */
+      *p = curr->gch.next;
+      curr->gch.next = NULL;  /* link `curr' at the end of `collected' list */
+      *lastcollected = curr;
+      lastcollected = &curr->gch.next;
+    }
+  }
+  /* insert collected udata with gc event into `tmudata' list */
+  *lastcollected = G(L)->tmudata;
+  G(L)->tmudata = collected;
+}
+
+
+static void removekey (Node *n) {
+  setnilvalue(gval(n));  /* remove corresponding value ... */
+  if (iscollectable(gkey(n)))
+    setttype(gkey(n), LUA_TNONE);  /* dead key; remove it */
+}
+
+
+static void traversetable (GCState *st, Table *h) {
+  int i;
+  int weakkey = 0;
+  int weakvalue = 0;
+  const TObject *mode;
+  markvalue(st, h->metatable);
+  lua_assert(h->lsizenode || h->node == st->g->dummynode);
+  mode = gfasttm(st->g, h->metatable, TM_MODE);
+  if (mode && ttisstring(mode)) {  /* is there a weak mode? */
+    weakkey = (strchr(svalue(mode), 'k') != NULL);
+    weakvalue = (strchr(svalue(mode), 'v') != NULL);
+    if (weakkey || weakvalue) {  /* is really weak? */
+      GCObject **weaklist;
+      h->marked &= ~(KEYWEAK | VALUEWEAK);  /* clear bits */
+      h->marked |= cast(lu_byte, (weakkey << KEYWEAKBIT) |
+                                 (weakvalue << VALUEWEAKBIT));
+      weaklist = (weakkey && weakvalue) ? &st->wkv :
+                              (weakkey) ? &st->wk :
+                                          &st->wv;
+      h->gclist = *weaklist;  /* must be cleared after GC, ... */
+      *weaklist = valtogco(h);  /* ... so put in the appropriate list */
+    }
+  }
+  if (!weakvalue) {
+    i = h->sizearray;
+    while (i--)
+      markobject(st, &h->array[i]);
+  }
+  i = sizenode(h);
+  while (i--) {
+    Node *n = gnode(h, i);
+    if (!ttisnil(gval(n))) {
+      lua_assert(!ttisnil(gkey(n)));
+      condmarkobject(st, gkey(n), !weakkey);
+      condmarkobject(st, gval(n), !weakvalue);
+    }
+  }
+}
+
+
+static void traverseproto (GCState *st, Proto *f) {
+  int i;
+  stringmark(f->source);
+  for (i=0; i<f->sizek; i++) {  /* mark literal strings */
+    if (ttisstring(f->k+i))
+      stringmark(tsvalue(f->k+i));
+  }
+  for (i=0; i<f->sizeupvalues; i++)  /* mark upvalue names */
+    stringmark(f->upvalues[i]);
+  for (i=0; i<f->sizep; i++)  /* mark nested protos */
+    markvalue(st, f->p[i]);
+  for (i=0; i<f->sizelocvars; i++)  /* mark local-variable names */
+    stringmark(f->locvars[i].varname);
+  lua_assert(luaG_checkcode(f));
+}
+
+
+
+static void traverseclosure (GCState *st, Closure *cl) {
+  if (cl->c.isC) {
+    int i;
+    for (i=0; i<cl->c.nupvalues; i++)  /* mark its upvalues */
+      markobject(st, &cl->c.upvalue[i]);
+  }
+  else {
+    int i;
+    lua_assert(cl->l.nupvalues == cl->l.p->nups);
+    markvalue(st, hvalue(&cl->l.g));
+    markvalue(st, cl->l.p);
+    for (i=0; i<cl->l.nupvalues; i++) {  /* mark its upvalues */
+      UpVal *u = cl->l.upvals[i];
+      if (!u->marked) {
+        markobject(st, &u->value);
+        u->marked = 1;
+      }
+    }
+  }
+}
+
+
+static void checkstacksizes (lua_State *L, StkId max) {
+  int used = L->ci - L->base_ci;  /* number of `ci' in use */
+  if (4*used < L->size_ci && 2*BASIC_CI_SIZE < L->size_ci)
+    luaD_reallocCI(L, L->size_ci/2);  /* still big enough... */
+  else condhardstacktests(luaD_reallocCI(L, L->size_ci));
+  used = max - L->stack;  /* part of stack in use */
+  if (4*used < L->stacksize && 2*(BASIC_STACK_SIZE+EXTRA_STACK) < L->stacksize)
+    luaD_reallocstack(L, L->stacksize/2);  /* still big enough... */
+  else condhardstacktests(luaD_reallocstack(L, L->stacksize));
+}
+
+
+static void traversestack (GCState *st, lua_State *L1) {
+  StkId o, lim;
+  CallInfo *ci;
+  markobject(st, gt(L1));
+  lim = L1->top;
+  for (ci = L1->base_ci; ci <= L1->ci; ci++) {
+    lua_assert(ci->top <= L1->stack_last);
+    lua_assert(ci->state & (CI_C | CI_HASFRAME | CI_SAVEDPC));
+    if (!(ci->state & CI_C) && lim < ci->top)
+      lim = ci->top;
+  }
+  for (o = L1->stack; o < L1->top; o++)
+    markobject(st, o);
+  for (; o <= lim; o++)
+    setnilvalue(o);
+  checkstacksizes(L1, lim);
+}
+
+
+static void propagatemarks (GCState *st) {
+  while (st->tmark) {  /* traverse marked objects */
+    switch (st->tmark->gch.tt) {
+      case LUA_TTABLE: {
+        Table *h = gcotoh(st->tmark);
+        st->tmark = h->gclist;
+        traversetable(st, h);
+        break;
+      }
+      case LUA_TFUNCTION: {
+        Closure *cl = gcotocl(st->tmark);
+        st->tmark = cl->c.gclist;
+        traverseclosure(st, cl);
+        break;
+      }
+      case LUA_TTHREAD: {
+        lua_State *th = gcototh(st->tmark);
+        st->tmark = th->gclist;
+        traversestack(st, th);
+        break;
+      }
+      case LUA_TPROTO: {
+        Proto *p = gcotop(st->tmark);
+        st->tmark = p->gclist;
+        traverseproto(st, p);
+        break;
+      }
+      default: lua_assert(0);
+    }
+  }
+}
+
+
+static int valismarked (const TObject *o) {
+  if (ttisstring(o))
+    stringmark(tsvalue(o));  /* strings are `values', so are never weak */
+  return !iscollectable(o) || testbit(o->value.gc->gch.marked, 0);
+}
+
+
+/*
+** clear collected keys from weaktables
+*/
+static void cleartablekeys (GCObject *l) {
+  while (l) {
+    Table *h = gcotoh(l);
+    int i = sizenode(h);
+    lua_assert(h->marked & KEYWEAK);
+    while (i--) {
+      Node *n = gnode(h, i);
+      if (!valismarked(gkey(n)))  /* key was collected? */
+        removekey(n);  /* remove entry from table */
+    }
+    l = h->gclist;
+  }
+}
+
+
+/*
+** clear collected values from weaktables
+*/
+static void cleartablevalues (GCObject *l) {
+  while (l) {
+    Table *h = gcotoh(l);
+    int i = h->sizearray;
+    lua_assert(h->marked & VALUEWEAK);
+    while (i--) {
+      TObject *o = &h->array[i];
+      if (!valismarked(o))  /* value was collected? */
+        setnilvalue(o);  /* remove value */
+    }
+    i = sizenode(h);
+    while (i--) {
+      Node *n = gnode(h, i);
+      if (!valismarked(gval(n)))  /* value was collected? */
+        removekey(n);  /* remove entry from table */
+    }
+    l = h->gclist;
+  }
+}
+
+
+static void freeobj (lua_State *L, GCObject *o) {
+  switch (o->gch.tt) {
+    case LUA_TPROTO: luaF_freeproto(L, gcotop(o)); break;
+    case LUA_TFUNCTION: luaF_freeclosure(L, gcotocl(o)); break;
+    case LUA_TUPVAL: luaM_freelem(L, gcotouv(o)); break;
+    case LUA_TTABLE: luaH_free(L, gcotoh(o)); break;
+    case LUA_TTHREAD: {
+      lua_assert(gcototh(o) != L && gcototh(o) != G(L)->mainthread);
+      luaE_freethread(L, gcototh(o));
+      break;
+    }
+    case LUA_TSTRING: {
+      luaM_free(L, o, sizestring(gcotots(o)->tsv.len));
+      break;
+    }
+    case LUA_TUSERDATA: {
+      luaM_free(L, o, sizeudata(gcotou(o)->uv.len));
+      break;
+    }
+    default: lua_assert(0);
+  }
+}
+
+
+static int sweeplist (lua_State *L, GCObject **p, int limit) {
+  GCObject *curr;
+  int count = 0;  /* number of collected items */
+  while ((curr = *p) != NULL) {
+    if (curr->gch.marked > limit) {
+      unmark(curr);
+      p = &curr->gch.next;
+    }
+    else {
+      count++;
+      *p = curr->gch.next;
+      freeobj(L, curr);
+    }
+  }
+  return count;
+}
+
+
+static void sweepstrings (lua_State *L, int all) {
+  int i;
+  for (i=0; i<G(L)->strt.size; i++) {  /* for each list */
+    G(L)->strt.nuse -= sweeplist(L, &G(L)->strt.hash[i], all);
+  }
+}
+
+
+static void checkSizes (lua_State *L) {
+  /* check size of string hash */
+  if (G(L)->strt.nuse < cast(ls_nstr, G(L)->strt.size/4) &&
+      G(L)->strt.size > MINSTRTABSIZE*2)
+    luaS_resize(L, G(L)->strt.size/2);  /* table is too big */
+  /* check size of buffer */
+  if (luaZ_sizebuffer(&G(L)->buff) > LUA_MINBUFFER*2) {  /* buffer too big? */
+    size_t newsize = luaZ_sizebuffer(&G(L)->buff) / 2;
+    luaZ_resizebuffer(L, &G(L)->buff, newsize);
+  }
+  G(L)->GCthreshold = 2*G(L)->nblocks;  /* new threshold */
+}
+
+
+static void do1gcTM (lua_State *L, Udata *udata) {
+  const TObject *tm = fasttm(L, udata->uv.metatable, TM_GC);
+  if (tm != NULL) {
+    setobj2s(L->top, tm);
+    setuvalue(L->top+1, udata);
+    L->top += 2;
+    luaD_call(L, L->top - 2, 0);
+  }
+}
+
+
+void luaC_callGCTM (lua_State *L) {
+  lu_byte oldah = L->allowhook;
+  L->allowhook = 0;  /* stop debug hooks during GC tag methods */
+  L->top++;  /* reserve space to keep udata while runs its gc method */
+  while (G(L)->tmudata != NULL) {
+    GCObject *o = G(L)->tmudata;
+    Udata *udata = gcotou(o);
+    G(L)->tmudata = udata->uv.next;  /* remove udata from `tmudata' */
+    udata->uv.next = G(L)->rootudata;  /* return it to `root' list */
+    G(L)->rootudata = o;
+    setuvalue(L->top - 1, udata);  /* keep a reference to it */
+    unmark(o);
+    markfinalized(udata);
+    do1gcTM(L, udata);
+  }
+  L->top--;
+  L->allowhook = oldah;  /* restore hooks */
+}
+
+
+void luaC_sweep (lua_State *L, int all) {
+  if (all) all = 256;  /* larger than any mark */
+  sweeplist(L, &G(L)->rootudata, all);
+  sweepstrings(L, all);
+  sweeplist(L, &G(L)->rootgc, all);
+}
+
+
+/* mark root set */
+static void markroot (GCState *st, lua_State *L) {
+  global_State *g = st->g;
+  markobject(st, defaultmeta(L));
+  markobject(st, registry(L));
+  traversestack(st, g->mainthread);
+  if (L != g->mainthread)  /* another thread is running? */
+    markvalue(st, L);  /* cannot collect it */
+}
+
+
+static void mark (lua_State *L) {
+  GCState st;
+  GCObject *wkv;
+  st.g = G(L);
+  st.tmark = NULL;
+  st.wkv = st.wk = st.wv = NULL;
+  markroot(&st, L);
+  propagatemarks(&st);  /* mark all reachable objects */
+  cleartablevalues(st.wkv);
+  cleartablevalues(st.wv);
+  wkv = st.wkv;  /* keys must be cleared after preserving udata */
+  st.wkv = NULL;
+  st.wv = NULL;
+  luaC_separateudata(L);  /* separate userdata to be preserved */
+  marktmu(&st);  /* mark `preserved' userdata */
+  propagatemarks(&st);  /* remark, to propagate `preserveness' */
+  cleartablekeys(wkv);
+  /* `propagatemarks' may resuscitate some weak tables; clear them too */
+  cleartablekeys(st.wk);
+  cleartablevalues(st.wv);
+  cleartablekeys(st.wkv);
+  cleartablevalues(st.wkv);
+}
+
+
+void luaC_collectgarbage (lua_State *L) {
+  mark(L);
+  luaC_sweep(L, 0);
+  checkSizes(L);
+  luaC_callGCTM(L);
+}
+
+
+void luaC_link (lua_State *L, GCObject *o, lu_byte tt) {
+  o->gch.next = G(L)->rootgc;
+  G(L)->rootgc = o;
+  o->gch.marked = 0;
+  o->gch.tt = tt;
+}
+

Added: trunk/Util/deditor/lua/lgc.h
===================================================================
--- trunk/Util/deditor/lua/lgc.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lgc.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,25 @@
+/*
+** $Id: lgc.h,v 1.19 2003/02/28 19:45:15 roberto Exp $
+** Garbage Collector
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lgc_h
+#define lgc_h
+
+
+#include "lobject.h"
+
+
+#define luaC_checkGC(L) { lua_assert(!(L->ci->state & CI_CALLING)); \
+	if (G(L)->nblocks >= G(L)->GCthreshold) luaC_collectgarbage(L); }
+
+
+void luaC_separateudata (lua_State *L);
+void luaC_callGCTM (lua_State *L);
+void luaC_sweep (lua_State *L, int all);
+void luaC_collectgarbage (lua_State *L);
+void luaC_link (lua_State *L, GCObject *o, lu_byte tt);
+
+
+#endif

Added: trunk/Util/deditor/lua/lib/Makefile
===================================================================
--- trunk/Util/deditor/lua/lib/Makefile	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/Makefile	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,27 @@
+# makefile for Lua standard library
+
+LUA= ../..
+
+include $(LUA)/config
+
+EXTRA_DEFS= $(POPEN) $(TMPNAM) $(DEGREES) $(LOADLIB)
+
+OBJS= lauxlib.o lbaselib.o ldblib.o liolib.o lmathlib.o ltablib.o lstrlib.o loadlib.o
+SRCS= lauxlib.c lbaselib.c ldblib.c liolib.c lmathlib.c ltablib.c lstrlib.c loadlib.c
+
+T= $(LIB)/liblualib.a
+
+all:	$T
+
+$T:	$(OBJS)
+	$(AR) $@ $(OBJS)
+	$(RANLIB) $@
+
+clean:
+	rm -f $(OBJS) $T
+
+co:
+	co -q -f -M $(SRCS)
+
+klean:	clean
+	rm -f $(SRCS)

Added: trunk/Util/deditor/lua/lib/README
===================================================================
--- trunk/Util/deditor/lua/lib/README	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/README	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,8 @@
+This is the standard Lua library.
+
+The code of the standard library can be read as an example of how to export
+C functions to Lua. The easiest library to read is lmathlib.c.
+
+The library is implemented entirely on top of the official Lua API as declared
+in lua.h, using lauxlib.c, which contains several useful functions for writing
+libraries. We encourage developers to use lauxlib.c in their own libraries.

Added: trunk/Util/deditor/lua/lib/lauxlib.c
===================================================================
--- trunk/Util/deditor/lua/lib/lauxlib.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/lauxlib.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,591 @@
+/*
+** $Id: lauxlib.c,v 1.100 2003/04/07 14:35:00 roberto Exp $
+** Auxiliary functions for building Lua libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#include <ctype.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+
+
+/* This file uses only the official API of Lua.
+** Any function declared here could be written as an application function.
+*/
+
+#define lauxlib_c
+
+#include "lua.h"
+
+#include "lauxlib.h"
+
+
+/* number of prereserved references (for internal use) */
+#define RESERVED_REFS	2
+
+/* reserved references */
+#define FREELIST_REF	1	/* free list of references */
+#define ARRAYSIZE_REF	2	/* array sizes */
+
+
+/* convert a stack index to positive */
+#define abs_index(L, i)		((i) > 0 || (i) <= LUA_REGISTRYINDEX ? (i) : \
+					lua_gettop(L) + (i) + 1)
+
+
+/*
+** {======================================================
+** Error-report functions
+** =======================================================
+*/
+
+
+LUALIB_API int luaL_argerror (lua_State *L, int narg, const char *extramsg) {
+  lua_Debug ar;
+  lua_getstack(L, 0, &ar);
+  lua_getinfo(L, "n", &ar);
+  if (strcmp(ar.namewhat, "method") == 0) {
+    narg--;  /* do not count `self' */
+    if (narg == 0)  /* error is in the self argument itself? */
+      return luaL_error(L, "calling `%s' on bad self (%s)", ar.name, extramsg);
+  }
+  if (ar.name == NULL)
+    ar.name = "?";
+  return luaL_error(L, "bad argument #%d to `%s' (%s)",
+                        narg, ar.name, extramsg);
+}
+
+
+LUALIB_API int luaL_typerror (lua_State *L, int narg, const char *tname) {
+  const char *msg = lua_pushfstring(L, "%s expected, got %s",
+                                    tname, lua_typename(L, lua_type(L,narg)));
+  return luaL_argerror(L, narg, msg);
+}
+
+
+static void tag_error (lua_State *L, int narg, int tag) {
+  luaL_typerror(L, narg, lua_typename(L, tag)); 
+}
+
+
+LUALIB_API void luaL_where (lua_State *L, int level) {
+  lua_Debug ar;
+  if (lua_getstack(L, level, &ar)) {  /* check function at level */
+    lua_getinfo(L, "Snl", &ar);  /* get info about it */
+    if (ar.currentline > 0) {  /* is there info? */
+      lua_pushfstring(L, "%s:%d: ", ar.short_src, ar.currentline);
+      return;
+    }
+  }
+  lua_pushliteral(L, "");  /* else, no information available... */
+}
+
+
+LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {
+  va_list argp;
+  va_start(argp, fmt);
+  luaL_where(L, 1);
+  lua_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  lua_concat(L, 2);
+  return lua_error(L);
+}
+
+/* }====================================================== */
+
+
+LUALIB_API int luaL_findstring (const char *name, const char *const list[]) {
+  int i;
+  for (i=0; list[i]; i++)
+    if (strcmp(list[i], name) == 0)
+      return i;
+  return -1;  /* name not found */
+}
+
+
+LUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {
+  lua_pushstring(L, tname);
+  lua_rawget(L, LUA_REGISTRYINDEX);  /* get registry.name */
+  if (!lua_isnil(L, -1))  /* name already in use? */
+    return 0;  /* leave previous value on top, but return 0 */
+  lua_pop(L, 1);
+  lua_newtable(L);  /* create metatable */
+  lua_pushstring(L, tname);
+  lua_pushvalue(L, -2);
+  lua_rawset(L, LUA_REGISTRYINDEX);  /* registry.name = metatable */
+  lua_pushvalue(L, -1);
+  lua_pushstring(L, tname);
+  lua_rawset(L, LUA_REGISTRYINDEX);  /* registry[metatable] = name */
+  return 1;
+}
+
+
+LUALIB_API void  luaL_getmetatable (lua_State *L, const char *tname) {
+  lua_pushstring(L, tname);
+  lua_rawget(L, LUA_REGISTRYINDEX);
+}
+
+
+LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {
+  const char *tn;
+  if (!lua_getmetatable(L, ud)) return NULL;  /* no metatable? */
+  lua_rawget(L, LUA_REGISTRYINDEX);  /* get registry[metatable] */
+  tn = lua_tostring(L, -1);
+  if (tn && (strcmp(tn, tname) == 0)) {
+    lua_pop(L, 1);
+    return lua_touserdata(L, ud);
+  }
+  else {
+    lua_pop(L, 1);
+    return NULL;
+  }
+}
+
+
+LUALIB_API void luaL_checkstack (lua_State *L, int space, const char *mes) {
+  if (!lua_checkstack(L, space))
+    luaL_error(L, "stack overflow (%s)", mes);
+}
+
+
+LUALIB_API void luaL_checktype (lua_State *L, int narg, int t) {
+  if (lua_type(L, narg) != t)
+    tag_error(L, narg, t);
+}
+
+
+LUALIB_API void luaL_checkany (lua_State *L, int narg) {
+  if (lua_type(L, narg) == LUA_TNONE)
+    luaL_argerror(L, narg, "value expected");
+}
+
+
+LUALIB_API const char *luaL_checklstring (lua_State *L, int narg, size_t *len) {
+  const char *s = lua_tostring(L, narg);
+  if (!s) tag_error(L, narg, LUA_TSTRING);
+  if (len) *len = lua_strlen(L, narg);
+  return s;
+}
+
+
+LUALIB_API const char *luaL_optlstring (lua_State *L, int narg,
+                                        const char *def, size_t *len) {
+  if (lua_isnoneornil(L, narg)) {
+    if (len)
+      *len = (def ? strlen(def) : 0);
+    return def;
+  }
+  else return luaL_checklstring(L, narg, len);
+}
+
+
+LUALIB_API lua_Number luaL_checknumber (lua_State *L, int narg) {
+  lua_Number d = lua_tonumber(L, narg);
+  if (d == 0 && !lua_isnumber(L, narg))  /* avoid extra test when d is not 0 */
+    tag_error(L, narg, LUA_TNUMBER);
+  return d;
+}
+
+
+LUALIB_API lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number def) {
+  if (lua_isnoneornil(L, narg)) return def;
+  else return luaL_checknumber(L, narg);
+}
+
+
+LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {
+  if (!lua_getmetatable(L, obj))  /* no metatable? */
+    return 0;
+  lua_pushstring(L, event);
+  lua_rawget(L, -2);
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 2);  /* remove metatable and metafield */
+    return 0;
+  }
+  else {
+    lua_remove(L, -2);  /* remove only metatable */
+    return 1;
+  }
+}
+
+
+LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {
+  obj = abs_index(L, obj);
+  if (!luaL_getmetafield(L, obj, event))  /* no metafield? */
+    return 0;
+  lua_pushvalue(L, obj);
+  lua_call(L, 1, 1);
+  return 1;
+}
+
+
+LUALIB_API void luaL_openlib (lua_State *L, const char *libname,
+                              const luaL_reg *l, int nup) {
+  if (libname) {
+    lua_pushstring(L, libname);
+    lua_gettable(L, LUA_GLOBALSINDEX);  /* check whether lib already exists */
+    if (lua_isnil(L, -1)) {  /* no? */
+      lua_pop(L, 1);
+      lua_newtable(L);  /* create it */
+      lua_pushstring(L, libname);
+      lua_pushvalue(L, -2);
+      lua_settable(L, LUA_GLOBALSINDEX);  /* register it with given name */
+    }
+    lua_insert(L, -(nup+1));  /* move library table to below upvalues */
+  }
+  for (; l->name; l++) {
+    int i;
+    lua_pushstring(L, l->name);
+    for (i=0; i<nup; i++)  /* copy upvalues to the top */
+      lua_pushvalue(L, -(nup+1));
+    lua_pushcclosure(L, l->func, nup);
+    lua_settable(L, -(nup+3));
+  }
+  lua_pop(L, nup);  /* remove upvalues */
+}
+
+
+
+/*
+** {======================================================
+** getn-setn: size for arrays
+** =======================================================
+*/
+
+static int checkint (lua_State *L, int topop) {
+  int n = (int)lua_tonumber(L, -1);
+  if (n == 0 && !lua_isnumber(L, -1)) n = -1;
+  lua_pop(L, topop);
+  return n;
+}
+
+
+static void getsizes (lua_State *L) {
+  lua_rawgeti(L, LUA_REGISTRYINDEX, ARRAYSIZE_REF);
+  if (lua_isnil(L, -1)) {  /* no `size' table? */
+    lua_pop(L, 1);  /* remove nil */
+    lua_newtable(L);  /* create it */
+    lua_pushvalue(L, -1);  /* `size' will be its own metatable */
+    lua_setmetatable(L, -2);
+    lua_pushliteral(L, "__mode");
+    lua_pushliteral(L, "k");
+    lua_rawset(L, -3);  /* metatable(N).__mode = "k" */
+    lua_pushvalue(L, -1);
+    lua_rawseti(L, LUA_REGISTRYINDEX, ARRAYSIZE_REF);  /* store in register */
+  }
+}
+
+
+void luaL_setn (lua_State *L, int t, int n) {
+  t = abs_index(L, t);
+  lua_pushliteral(L, "n");
+  lua_rawget(L, t);
+  if (checkint(L, 1) >= 0) {  /* is there a numeric field `n'? */
+    lua_pushliteral(L, "n");  /* use it */
+    lua_pushnumber(L, (lua_Number)n);
+    lua_rawset(L, t);
+  }
+  else {  /* use `sizes' */
+    getsizes(L);
+    lua_pushvalue(L, t);
+    lua_pushnumber(L, (lua_Number)n);
+    lua_rawset(L, -3);  /* sizes[t] = n */
+    lua_pop(L, 1);  /* remove `sizes' */
+  }
+}
+
+
+int luaL_getn (lua_State *L, int t) {
+  int n;
+  t = abs_index(L, t);
+  lua_pushliteral(L, "n");  /* try t.n */
+  lua_rawget(L, t);
+  if ((n = checkint(L, 1)) >= 0) return n;
+  getsizes(L);  /* else try sizes[t] */
+  lua_pushvalue(L, t);
+  lua_rawget(L, -2);
+  if ((n = checkint(L, 2)) >= 0) return n;
+  for (n = 1; ; n++) {  /* else must count elements */
+    lua_rawgeti(L, t, n);
+    if (lua_isnil(L, -1)) break;
+    lua_pop(L, 1);
+  }
+  lua_pop(L, 1);
+  return n - 1;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** Generic Buffer manipulation
+** =======================================================
+*/
+
+
+#define bufflen(B)	((B)->p - (B)->buffer)
+#define bufffree(B)	((size_t)(LUAL_BUFFERSIZE - bufflen(B)))
+
+#define LIMIT	(LUA_MINSTACK/2)
+
+
+static int emptybuffer (luaL_Buffer *B) {
+  size_t l = bufflen(B);
+  if (l == 0) return 0;  /* put nothing on stack */
+  else {
+    lua_pushlstring(B->L, B->buffer, l);
+    B->p = B->buffer;
+    B->lvl++;
+    return 1;
+  }
+}
+
+
+static void adjuststack (luaL_Buffer *B) {
+  if (B->lvl > 1) {
+    lua_State *L = B->L;
+    int toget = 1;  /* number of levels to concat */
+    size_t toplen = lua_strlen(L, -1);
+    do {
+      size_t l = lua_strlen(L, -(toget+1));
+      if (B->lvl - toget + 1 >= LIMIT || toplen > l) {
+        toplen += l;
+        toget++;
+      }
+      else break;
+    } while (toget < B->lvl);
+    lua_concat(L, toget);
+    B->lvl = B->lvl - toget + 1;
+  }
+}
+
+
+LUALIB_API char *luaL_prepbuffer (luaL_Buffer *B) {
+  if (emptybuffer(B))
+    adjuststack(B);
+  return B->buffer;
+}
+
+
+LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {
+  while (l--)
+    luaL_putchar(B, *s++);
+}
+
+
+LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {
+  luaL_addlstring(B, s, strlen(s));
+}
+
+
+LUALIB_API void luaL_pushresult (luaL_Buffer *B) {
+  emptybuffer(B);
+  lua_concat(B->L, B->lvl);
+  B->lvl = 1;
+}
+
+
+LUALIB_API void luaL_addvalue (luaL_Buffer *B) {
+  lua_State *L = B->L;
+  size_t vl = lua_strlen(L, -1);
+  if (vl <= bufffree(B)) {  /* fit into buffer? */
+    memcpy(B->p, lua_tostring(L, -1), vl);  /* put it there */
+    B->p += vl;
+    lua_pop(L, 1);  /* remove from stack */
+  }
+  else {
+    if (emptybuffer(B))
+      lua_insert(L, -2);  /* put buffer before new value */
+    B->lvl++;  /* add new value into B stack */
+    adjuststack(B);
+  }
+}
+
+
+LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {
+  B->L = L;
+  B->p = B->buffer;
+  B->lvl = 0;
+}
+
+/* }====================================================== */
+
+
+LUALIB_API int luaL_ref (lua_State *L, int t) {
+  int ref;
+  t = abs_index(L, t);
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 1);  /* remove from stack */
+    return LUA_REFNIL;  /* `nil' has a unique fixed reference */
+  }
+  lua_rawgeti(L, t, FREELIST_REF);  /* get first free element */
+  ref = (int)lua_tonumber(L, -1);  /* ref = t[FREELIST_REF] */
+  lua_pop(L, 1);  /* remove it from stack */
+  if (ref != 0) {  /* any free element? */
+    lua_rawgeti(L, t, ref);  /* remove it from list */
+    lua_rawseti(L, t, FREELIST_REF);  /* (t[FREELIST_REF] = t[ref]) */
+  }
+  else {  /* no free elements */
+    ref = luaL_getn(L, t);
+    if (ref < RESERVED_REFS)
+      ref = RESERVED_REFS;  /* skip reserved references */
+    ref++;  /* create new reference */
+    luaL_setn(L, t, ref);
+  }
+  lua_rawseti(L, t, ref);
+  return ref;
+}
+
+
+LUALIB_API void luaL_unref (lua_State *L, int t, int ref) {
+  if (ref >= 0) {
+    t = abs_index(L, t);
+    lua_rawgeti(L, t, FREELIST_REF);
+    lua_rawseti(L, t, ref);  /* t[ref] = t[FREELIST_REF] */
+    lua_pushnumber(L, (lua_Number)ref);
+    lua_rawseti(L, t, FREELIST_REF);  /* t[FREELIST_REF] = ref */
+  }
+}
+
+
+
+/*
+** {======================================================
+** Load functions
+** =======================================================
+*/
+
+typedef struct LoadF {
+  FILE *f;
+  char buff[LUAL_BUFFERSIZE];
+} LoadF;
+
+
+static const char *getF (lua_State *L, void *ud, size_t *size) {
+  LoadF *lf = (LoadF *)ud;
+  (void)L;
+  if (feof(lf->f)) return NULL;
+  *size = fread(lf->buff, 1, LUAL_BUFFERSIZE, lf->f);
+  return (*size > 0) ? lf->buff : NULL;
+}
+
+
+static int errfile (lua_State *L, int fnameindex) {
+  const char *filename = lua_tostring(L, fnameindex) + 1;
+  lua_pushfstring(L, "cannot read %s: %s", filename, strerror(errno));
+  lua_remove(L, fnameindex);
+  return LUA_ERRFILE;
+}
+
+
+LUALIB_API int luaL_loadfile (lua_State *L, const char *filename) {
+  LoadF lf;
+  int status, readstatus;
+  int c;
+  int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */
+  if (filename == NULL) {
+    lua_pushliteral(L, "=stdin");
+    lf.f = stdin;
+  }
+  else {
+    lua_pushfstring(L, "@%s", filename);
+    lf.f = fopen(filename, "r");
+  }
+  if (lf.f == NULL) return errfile(L, fnameindex);  /* unable to open file */
+  c = ungetc(getc(lf.f), lf.f);
+  if (!(isspace(c) || isprint(c)) && lf.f != stdin) {  /* binary file? */
+    fclose(lf.f);
+    lf.f = fopen(filename, "rb");  /* reopen in binary mode */
+    if (lf.f == NULL) return errfile(L, fnameindex); /* unable to reopen file */
+  }
+  status = lua_load(L, getF, &lf, lua_tostring(L, -1));
+  readstatus = ferror(lf.f);
+  if (lf.f != stdin) fclose(lf.f);  /* close file (even in case of errors) */
+  if (readstatus) {
+    lua_settop(L, fnameindex);  /* ignore results from `lua_load' */
+    return errfile(L, fnameindex);
+  }
+  lua_remove(L, fnameindex);
+  return status;
+}
+
+
+typedef struct LoadS {
+  const char *s;
+  size_t size;
+} LoadS;
+
+
+static const char *getS (lua_State *L, void *ud, size_t *size) {
+  LoadS *ls = (LoadS *)ud;
+  (void)L;
+  if (ls->size == 0) return NULL;
+  *size = ls->size;
+  ls->size = 0;
+  return ls->s;
+}
+
+
+LUALIB_API int luaL_loadbuffer (lua_State *L, const char *buff, size_t size,
+                                const char *name) {
+  LoadS ls;
+  ls.s = buff;
+  ls.size = size;
+  return lua_load(L, getS, &ls, name);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** compatibility code
+** =======================================================
+*/
+
+
+static void callalert (lua_State *L, int status) {
+  if (status != 0) {
+    lua_getglobal(L, "_ALERT");
+    if (lua_isfunction(L, -1)) {
+      lua_insert(L, -2);
+      lua_call(L, 1, 0);
+    }
+    else {  /* no _ALERT function; print it on stderr */
+      fprintf(stderr, "%s\n", lua_tostring(L, -2));
+      lua_pop(L, 2);  /* remove error message and _ALERT */
+    }
+  }
+}
+
+
+static int aux_do (lua_State *L, int status) {
+  if (status == 0) {  /* parse OK? */
+    status = lua_pcall(L, 0, LUA_MULTRET, 0);  /* call main */
+  }
+  callalert(L, status);
+  return status;
+}
+
+
+LUALIB_API int lua_dofile (lua_State *L, const char *filename) {
+  return aux_do(L, luaL_loadfile(L, filename));
+}
+
+
+LUALIB_API int lua_dobuffer (lua_State *L, const char *buff, size_t size,
+                          const char *name) {
+  return aux_do(L, luaL_loadbuffer(L, buff, size, name));
+}
+
+
+LUALIB_API int lua_dostring (lua_State *L, const char *str) {
+  return lua_dobuffer(L, str, strlen(str), str);
+}
+
+/* }====================================================== */

Added: trunk/Util/deditor/lua/lib/lbaselib.c
===================================================================
--- trunk/Util/deditor/lua/lib/lbaselib.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/lbaselib.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,674 @@
+/*
+** $Id: lbaselib.c,v 1.130 2003/04/03 13:35:34 roberto Exp $
+** Basic library
+** See Copyright Notice in lua.h
+*/
+
+
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lbaselib_c
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+
+
+/*
+** If your system does not support `stdout', you can just remove this function.
+** If you need, you can define your own `print' function, following this
+** model but changing `fputs' to put the strings at a proper place
+** (a console window or a log file, for instance).
+*/
+static int luaB_print (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  int i;
+  lua_getglobal(L, "tostring");
+  for (i=1; i<=n; i++) {
+    const char *s;
+    lua_pushvalue(L, -1);  /* function to be called */
+    lua_pushvalue(L, i);   /* value to print */
+    lua_call(L, 1, 1);
+    s = lua_tostring(L, -1);  /* get result */
+    if (s == NULL)
+      return luaL_error(L, "`tostring' must return a string to `print'");
+    if (i>1) fputs("\t", stdout);
+    fputs(s, stdout);
+    lua_pop(L, 1);  /* pop result */
+  }
+  fputs("\n", stdout);
+  return 0;
+}
+
+
+static int luaB_tonumber (lua_State *L) {
+  int base = luaL_optint(L, 2, 10);
+  if (base == 10) {  /* standard conversion */
+    luaL_checkany(L, 1);
+    if (lua_isnumber(L, 1)) {
+      lua_pushnumber(L, lua_tonumber(L, 1));
+      return 1;
+    }
+  }
+  else {
+    const char *s1 = luaL_checkstring(L, 1);
+    char *s2;
+    unsigned long n;
+    luaL_argcheck(L, 2 <= base && base <= 36, 2, "base out of range");
+    n = strtoul(s1, &s2, base);
+    if (s1 != s2) {  /* at least one valid digit? */
+      while (isspace((unsigned char)(*s2))) s2++;  /* skip trailing spaces */
+      if (*s2 == '\0') {  /* no invalid trailing characters? */
+        lua_pushnumber(L, (lua_Number)n);
+        return 1;
+      }
+    }
+  }
+  lua_pushnil(L);  /* else not a number */
+  return 1;
+}
+
+
+static int luaB_error (lua_State *L) {
+  int level = luaL_optint(L, 2, 1);
+  luaL_checkany(L, 1);
+  if (!lua_isstring(L, 1) || level == 0)
+    lua_pushvalue(L, 1);  /* propagate error message without changes */
+  else {  /* add extra information */
+    luaL_where(L, level);
+    lua_pushvalue(L, 1);
+    lua_concat(L, 2);
+  }
+  return lua_error(L);
+}
+
+
+static int luaB_getmetatable (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (!lua_getmetatable(L, 1)) {
+    lua_pushnil(L);
+    return 1;  /* no metatable */
+  }
+  luaL_getmetafield(L, 1, "__metatable");
+  return 1;  /* returns either __metatable field (if present) or metatable */
+}
+
+
+static int luaB_setmetatable (lua_State *L) {
+  int t = lua_type(L, 2);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
+                    "nil or table expected");
+  if (luaL_getmetafield(L, 1, "__metatable"))
+    luaL_error(L, "cannot change a protected metatable");
+  lua_settop(L, 2);
+  lua_setmetatable(L, 1);
+  return 1;
+}
+
+
+static void getfunc (lua_State *L) {
+  if (lua_isfunction(L, 1)) lua_pushvalue(L, 1);
+  else {
+    lua_Debug ar;
+    int level = luaL_optint(L, 1, 1);
+    luaL_argcheck(L, level >= 0, 1, "level must be non-negative");
+    if (lua_getstack(L, level, &ar) == 0)
+      luaL_argerror(L, 1, "invalid level");
+    lua_getinfo(L, "f", &ar);
+    if (lua_isnil(L, -1))
+      luaL_error(L, "no function environment for tail call at level %d",
+                    level);
+  }
+}
+
+
+static int aux_getfenv (lua_State *L) {
+  lua_getfenv(L, -1);
+  lua_pushliteral(L, "__fenv");
+  lua_rawget(L, -2);
+  return !lua_isnil(L, -1);
+}
+
+
+static int luaB_getfenv (lua_State *L) {
+  getfunc(L);
+  if (!aux_getfenv(L))  /* __fenv not defined? */
+    lua_pop(L, 1);  /* remove it, to return real environment */
+  return 1;
+}
+
+
+static int luaB_setfenv (lua_State *L) {
+  luaL_checktype(L, 2, LUA_TTABLE);
+  getfunc(L);
+  if (aux_getfenv(L))  /* __fenv defined? */
+    luaL_error(L, "`setfenv' cannot change a protected environment");
+  else
+    lua_pop(L, 2);  /* remove __fenv and real environment table */
+  lua_pushvalue(L, 2);
+  if (lua_isnumber(L, 1) && lua_tonumber(L, 1) == 0)
+    lua_replace(L, LUA_GLOBALSINDEX);
+  else if (lua_setfenv(L, -2) == 0)
+    luaL_error(L, "`setfenv' cannot change environment of given function");
+  return 0;
+}
+
+
+static int luaB_rawequal (lua_State *L) {
+  luaL_checkany(L, 1);
+  luaL_checkany(L, 2);
+  lua_pushboolean(L, lua_rawequal(L, 1, 2));
+  return 1;
+}
+
+
+static int luaB_rawget (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checkany(L, 2);
+  lua_rawget(L, 1);
+  return 1;
+}
+
+static int luaB_rawset (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checkany(L, 2);
+  luaL_checkany(L, 3);
+  lua_rawset(L, 1);
+  return 1;
+}
+
+
+static int luaB_gcinfo (lua_State *L) {
+  lua_pushnumber(L, (lua_Number)lua_getgccount(L));
+  lua_pushnumber(L, (lua_Number)lua_getgcthreshold(L));
+  return 2;
+}
+
+
+static int luaB_collectgarbage (lua_State *L) {
+  lua_setgcthreshold(L, luaL_optint(L, 1, 0));
+  return 0;
+}
+
+
+static int luaB_type (lua_State *L) {
+  luaL_checkany(L, 1);
+  lua_pushstring(L, lua_typename(L, lua_type(L, 1)));
+  return 1;
+}
+
+
+static int luaB_next (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  lua_settop(L, 2);  /* create a 2nd argument if there isn't one */
+  if (lua_next(L, 1))
+    return 2;
+  else {
+    lua_pushnil(L);
+    return 1;
+  }
+}
+
+
+static int luaB_pairs (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  lua_pushliteral(L, "next");
+  lua_rawget(L, LUA_GLOBALSINDEX);  /* return generator, */
+  lua_pushvalue(L, 1);  /* state, */
+  lua_pushnil(L);  /* and initial value */
+  return 3;
+}
+
+
+static int luaB_ipairs (lua_State *L) {
+  lua_Number i = lua_tonumber(L, 2);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  if (i == 0 && lua_isnone(L, 2)) {  /* `for' start? */
+    lua_pushliteral(L, "ipairs");
+    lua_rawget(L, LUA_GLOBALSINDEX);  /* return generator, */
+    lua_pushvalue(L, 1);  /* state, */
+    lua_pushnumber(L, 0);  /* and initial value */
+    return 3;
+  }
+  else {  /* `for' step */
+    i++;  /* next value */
+    lua_pushnumber(L, i);
+    lua_rawgeti(L, 1, (int)i);
+    return (lua_isnil(L, -1)) ? 0 : 2;
+  }
+}
+
+
+static int load_aux (lua_State *L, int status) {
+  if (status == 0)  /* OK? */
+    return 1;
+  else {
+    lua_pushnil(L);
+    lua_insert(L, -2);  /* put before error message */
+    return 2;  /* return nil plus error message */
+  }
+}
+
+
+static int luaB_loadstring (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &l);
+  const char *chunkname = luaL_optstring(L, 2, s);
+  return load_aux(L, luaL_loadbuffer(L, s, l, chunkname));
+}
+
+
+static int luaB_loadfile (lua_State *L) {
+  const char *fname = luaL_optstring(L, 1, NULL);
+  return load_aux(L, luaL_loadfile(L, fname));
+}
+
+
+static int luaB_dofile (lua_State *L) {
+  const char *fname = luaL_optstring(L, 1, NULL);
+  int status = luaL_loadfile(L, fname);
+  if (status != 0) lua_error(L);
+  lua_call(L, 0, LUA_MULTRET);
+  return lua_gettop(L) - 1;
+}
+
+
+static int luaB_assert (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (!lua_toboolean(L, 1))
+    return luaL_error(L, "%s", luaL_optstring(L, 2, "assertion failed!"));
+  lua_settop(L, 1);
+  return 1;
+}
+
+
+static int luaB_unpack (lua_State *L) {
+  int n, i;
+  luaL_checktype(L, 1, LUA_TTABLE);
+  n = luaL_getn(L, 1);
+  luaL_checkstack(L, n, "table too big to unpack");
+  for (i=1; i<=n; i++)  /* push arg[1...n] */
+    lua_rawgeti(L, 1, i);
+  return n;
+}
+
+
+static int luaB_pcall (lua_State *L) {
+  int status;
+  luaL_checkany(L, 1);
+  status = lua_pcall(L, lua_gettop(L) - 1, LUA_MULTRET, 0);
+  lua_pushboolean(L, (status == 0));
+  lua_insert(L, 1);
+  return lua_gettop(L);  /* return status + all results */
+}
+
+
+static int luaB_xpcall (lua_State *L) {
+  int status;
+  luaL_checkany(L, 2);
+  lua_settop(L, 2);
+  lua_insert(L, 1);  /* put error function under function to be called */
+  status = lua_pcall(L, 0, LUA_MULTRET, 1);
+  lua_pushboolean(L, (status == 0));
+  lua_replace(L, 1);
+  return lua_gettop(L);  /* return status + all results */
+}
+
+
+static int luaB_tostring (lua_State *L) {
+  char buff[64];
+  luaL_checkany(L, 1);
+  if (luaL_callmeta(L, 1, "__tostring"))  /* is there a metafield? */
+    return 1;  /* use its value */
+  switch (lua_type(L, 1)) {
+    case LUA_TNUMBER:
+      lua_pushstring(L, lua_tostring(L, 1));
+      return 1;
+    case LUA_TSTRING:
+      lua_pushvalue(L, 1);
+      return 1;
+    case LUA_TBOOLEAN:
+      lua_pushstring(L, (lua_toboolean(L, 1) ? "true" : "false"));
+      return 1;
+    case LUA_TTABLE:
+      sprintf(buff, "table: %p", lua_topointer(L, 1));
+      break;
+    case LUA_TFUNCTION:
+      sprintf(buff, "function: %p", lua_topointer(L, 1));
+      break;
+    case LUA_TUSERDATA:
+    case LUA_TLIGHTUSERDATA:
+      sprintf(buff, "userdata: %p", lua_touserdata(L, 1));
+      break;
+    case LUA_TTHREAD:
+      sprintf(buff, "thread: %p", (void *)lua_tothread(L, 1));
+      break;
+    case LUA_TNIL:
+      lua_pushliteral(L, "nil");
+      return 1;
+  }
+  lua_pushstring(L, buff);
+  return 1;
+}
+
+
+static int luaB_newproxy (lua_State *L) {
+  lua_settop(L, 1);
+  lua_newuserdata(L, 0);  /* create proxy */
+  if (lua_toboolean(L, 1) == 0)
+    return 1;  /* no metatable */
+  else if (lua_isboolean(L, 1)) {
+    lua_newtable(L);  /* create a new metatable `m' ... */
+    lua_pushvalue(L, -1);  /* ... and mark `m' as a valid metatable */
+    lua_pushboolean(L, 1);
+    lua_rawset(L, lua_upvalueindex(1));  /* weaktable[m] = true */
+  }
+  else {
+    int validproxy = 0;  /* to check if weaktable[metatable(u)] == true */
+    if (lua_getmetatable(L, 1)) {
+      lua_rawget(L, lua_upvalueindex(1));
+      validproxy = lua_toboolean(L, -1);
+      lua_pop(L, 1);  /* remove value */
+    }
+    luaL_argcheck(L, validproxy, 1, "boolean or proxy expected");
+    lua_getmetatable(L, 1);  /* metatable is valid; get it */
+  }
+  lua_setmetatable(L, 2);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** `require' function
+** =======================================================
+*/
+
+
+/* name of global that holds table with loaded packages */
+#define REQTAB		"_LOADED"
+
+/* name of global that holds the search path for packages */
+#define LUA_PATH	"LUA_PATH"
+
+#ifndef LUA_PATH_SEP
+#define LUA_PATH_SEP	';'
+#endif
+
+#ifndef LUA_PATH_MARK
+#define LUA_PATH_MARK	'?'
+#endif
+
+#ifndef LUA_PATH_DEFAULT
+#define LUA_PATH_DEFAULT	"?;?.lua"
+#endif
+
+
+static const char *getpath (lua_State *L) {
+  const char *path;
+  lua_getglobal(L, LUA_PATH);  /* try global variable */
+  path = lua_tostring(L, -1);
+  lua_pop(L, 1);
+  if (path) return path;
+  path = getenv(LUA_PATH);  /* else try environment variable */
+  if (path) return path;
+  return LUA_PATH_DEFAULT;  /* else use default */
+}
+
+
+static const char *pushnextpath (lua_State *L, const char *path) {
+  const char *l;
+  if (*path == '\0') return NULL;  /* no more paths */
+  if (*path == LUA_PATH_SEP) path++;  /* skip separator */
+  l = strchr(path, LUA_PATH_SEP);  /* find next separator */
+  if (l == NULL) l = path+strlen(path);
+  lua_pushlstring(L, path, l - path);  /* directory name */
+  return l;
+}
+
+
+static void pushcomposename (lua_State *L) {
+  const char *path = lua_tostring(L, -1);
+  const char *wild;
+  int n = 1;
+  while ((wild = strchr(path, LUA_PATH_MARK)) != NULL) {
+    /* is there stack space for prefix, name, and eventual last sufix? */
+    luaL_checkstack(L, 3, "too many marks in a path component");
+    lua_pushlstring(L, path, wild - path);  /* push prefix */
+    lua_pushvalue(L, 1);  /* push package name (in place of MARK) */
+    path = wild + 1;  /* continue after MARK */
+    n += 2;
+  }
+  lua_pushstring(L, path);  /* push last sufix (`n' already includes this) */
+  lua_concat(L, n);
+}
+
+
+static int luaB_require (lua_State *L) {
+  const char *path;
+  int status = LUA_ERRFILE;  /* not found (yet) */
+  luaL_checkstring(L, 1);
+  lua_settop(L, 1);
+  lua_getglobal(L, REQTAB);
+  if (!lua_istable(L, 2)) return luaL_error(L, "`" REQTAB "' is not a table");
+  path = getpath(L);
+  lua_pushvalue(L, 1);  /* check package's name in book-keeping table */
+  lua_rawget(L, 2);
+  if (lua_toboolean(L, -1))  /* is it there? */
+    return 1;  /* package is already loaded; return its result */
+  else {  /* must load it */
+    while (status == LUA_ERRFILE) {
+      lua_settop(L, 3);  /* reset stack position */
+      if ((path = pushnextpath(L, path)) == NULL) break;
+      pushcomposename(L);
+      status = luaL_loadfile(L, lua_tostring(L, -1));  /* try to load it */
+    }
+  }
+  switch (status) {
+    case 0: {
+      lua_getglobal(L, "_REQUIREDNAME");  /* save previous name */
+      lua_insert(L, -2);  /* put it below function */
+      lua_pushvalue(L, 1);
+      lua_setglobal(L, "_REQUIREDNAME");  /* set new name */
+      lua_call(L, 0, 1);  /* run loaded module */
+      lua_insert(L, -2);  /* put result below previous name */
+      lua_setglobal(L, "_REQUIREDNAME");  /* reset to previous name */
+      if (lua_isnil(L, -1)) {  /* no/nil return? */
+        lua_pushboolean(L, 1);
+        lua_replace(L, -2);  /* replace to true */
+      }
+      lua_pushvalue(L, 1);
+      lua_pushvalue(L, -2);
+      lua_rawset(L, 2);  /* mark it as loaded */
+      return 1;  /* return value */
+    }
+    case LUA_ERRFILE: {  /* file not found */
+      return luaL_error(L, "could not load package `%s' from path `%s'",
+                            lua_tostring(L, 1), getpath(L));
+    }
+    default: {
+      return luaL_error(L, "error loading package `%s' (%s)",
+                           lua_tostring(L, 1), lua_tostring(L, -1));
+    }
+  }
+}
+
+/* }====================================================== */
+
+
+static const luaL_reg base_funcs[] = {
+  {"error", luaB_error},
+  {"getmetatable", luaB_getmetatable},
+  {"setmetatable", luaB_setmetatable},
+  {"getfenv", luaB_getfenv},
+  {"setfenv", luaB_setfenv},
+  {"next", luaB_next},
+  {"ipairs", luaB_ipairs},
+  {"pairs", luaB_pairs},
+  {"print", luaB_print},
+  {"tonumber", luaB_tonumber},
+  {"tostring", luaB_tostring},
+  {"type", luaB_type},
+  {"assert", luaB_assert},
+  {"unpack", luaB_unpack},
+  {"rawequal", luaB_rawequal},
+  {"rawget", luaB_rawget},
+  {"rawset", luaB_rawset},
+  {"pcall", luaB_pcall},
+  {"xpcall", luaB_xpcall},
+  {"collectgarbage", luaB_collectgarbage},
+  {"gcinfo", luaB_gcinfo},
+  {"loadfile", luaB_loadfile},
+  {"dofile", luaB_dofile},
+  {"loadstring", luaB_loadstring},
+  {"require", luaB_require},
+  {NULL, NULL}
+};
+
+
+/*
+** {======================================================
+** Coroutine library
+** =======================================================
+*/
+
+static int auxresume (lua_State *L, lua_State *co, int narg) {
+  int status;
+  if (!lua_checkstack(co, narg))
+    luaL_error(L, "too many arguments to resume");
+  lua_xmove(L, co, narg);
+  status = lua_resume(co, narg);
+  if (status == 0) {
+    int nres = lua_gettop(co);
+    if (!lua_checkstack(L, nres))
+      luaL_error(L, "too many results to resume");
+    lua_xmove(co, L, nres);  /* move yielded values */
+    return nres;
+  }
+  else {
+    lua_xmove(co, L, 1);  /* move error message */
+    return -1;  /* error flag */
+  }
+}
+
+
+static int luaB_coresume (lua_State *L) {
+  lua_State *co = lua_tothread(L, 1);
+  int r;
+  luaL_argcheck(L, co, 1, "coroutine expected");
+  r = auxresume(L, co, lua_gettop(L) - 1);
+  if (r < 0) {
+    lua_pushboolean(L, 0);
+    lua_insert(L, -2);
+    return 2;  /* return false + error message */
+  }
+  else {
+    lua_pushboolean(L, 1);
+    lua_insert(L, -(r + 1));
+    return r + 1;  /* return true + `resume' returns */
+  }
+}
+
+
+static int luaB_auxwrap (lua_State *L) {
+  lua_State *co = lua_tothread(L, lua_upvalueindex(1));
+  int r = auxresume(L, co, lua_gettop(L));
+  if (r < 0) {
+    if (lua_isstring(L, -1)) {  /* error object is a string? */
+      luaL_where(L, 1);  /* add extra info */
+      lua_insert(L, -2);
+      lua_concat(L, 2);
+    }
+    lua_error(L);  /* propagate error */
+  }
+  return r;
+}
+
+
+static int luaB_cocreate (lua_State *L) {
+  lua_State *NL = lua_newthread(L);
+  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1), 1,
+    "Lua function expected");
+  lua_pushvalue(L, 1);  /* move function to top */
+  lua_xmove(L, NL, 1);  /* move function from L to NL */
+  return 1;
+}
+
+
+static int luaB_cowrap (lua_State *L) {
+  luaB_cocreate(L);
+  lua_pushcclosure(L, luaB_auxwrap, 1);
+  return 1;
+}
+
+
+static int luaB_yield (lua_State *L) {
+  return lua_yield(L, lua_gettop(L));
+}
+
+
+static int luaB_costatus (lua_State *L) {
+  lua_State *co = lua_tothread(L, 1);
+  luaL_argcheck(L, co, 1, "coroutine expected");
+  if (L == co) lua_pushliteral(L, "running");
+  else {
+    lua_Debug ar;
+    if (lua_getstack(co, 0, &ar) == 0 && lua_gettop(co) == 0)
+      lua_pushliteral(L, "dead");
+    else
+      lua_pushliteral(L, "suspended");
+  }
+  return 1;
+}
+
+
+static const luaL_reg co_funcs[] = {
+  {"create", luaB_cocreate},
+  {"wrap", luaB_cowrap},
+  {"resume", luaB_coresume},
+  {"yield", luaB_yield},
+  {"status", luaB_costatus},
+  {NULL, NULL}
+};
+
+/* }====================================================== */
+
+
+
+static void base_open (lua_State *L) {
+  lua_pushliteral(L, "_G");
+  lua_pushvalue(L, LUA_GLOBALSINDEX);
+  luaL_openlib(L, NULL, base_funcs, 0);  /* open lib into global table */
+  lua_pushliteral(L, "_VERSION");
+  lua_pushliteral(L, LUA_VERSION);
+  lua_rawset(L, -3);  /* set global _VERSION */
+  /* `newproxy' needs a weaktable as upvalue */
+  lua_pushliteral(L, "newproxy");
+  lua_newtable(L);  /* new table `w' */
+  lua_pushvalue(L, -1);  /* `w' will be its own metatable */
+  lua_setmetatable(L, -2);
+  lua_pushliteral(L, "__mode");
+  lua_pushliteral(L, "k");
+  lua_rawset(L, -3);  /* metatable(w).__mode = "k" */
+  lua_pushcclosure(L, luaB_newproxy, 1);
+  lua_rawset(L, -3);  /* set global `newproxy' */
+  lua_rawset(L, -1);  /* set global _G */
+}
+
+
+LUALIB_API int luaopen_base (lua_State *L) {
+  base_open(L);
+  luaL_openlib(L, LUA_COLIBNAME, co_funcs, 0);
+  lua_newtable(L);
+  lua_setglobal(L, REQTAB);
+  return 0;
+}
+

Added: trunk/Util/deditor/lua/lib/ldblib.c
===================================================================
--- trunk/Util/deditor/lua/lib/ldblib.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/ldblib.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,299 @@
+/*
+** $Id: ldblib.c,v 1.80 2003/04/03 13:35:34 roberto Exp $
+** Interface from Lua to its debug API
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define ldblib_c
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+
+static void settabss (lua_State *L, const char *i, const char *v) {
+  lua_pushstring(L, i);
+  lua_pushstring(L, v);
+  lua_rawset(L, -3);
+}
+
+
+static void settabsi (lua_State *L, const char *i, int v) {
+  lua_pushstring(L, i);
+  lua_pushnumber(L, (lua_Number)v);
+  lua_rawset(L, -3);
+}
+
+
+static int getinfo (lua_State *L) {
+  lua_Debug ar;
+  const char *options = luaL_optstring(L, 2, "flnSu");
+  if (lua_isnumber(L, 1)) {
+    if (!lua_getstack(L, (int)(lua_tonumber(L, 1)), &ar)) {
+      lua_pushnil(L);  /* level out of range */
+      return 1;
+    }
+  }
+  else if (lua_isfunction(L, 1)) {
+    lua_pushfstring(L, ">%s", options);
+    options = lua_tostring(L, -1);
+    lua_pushvalue(L, 1);
+  }
+  else
+    return luaL_argerror(L, 1, "function or level expected");
+  if (!lua_getinfo(L, options, &ar))
+    return luaL_argerror(L, 2, "invalid option");
+  lua_newtable(L);
+  for (; *options; options++) {
+    switch (*options) {
+      case 'S':
+        settabss(L, "source", ar.source);
+        settabss(L, "short_src", ar.short_src);
+        settabsi(L, "linedefined", ar.linedefined);
+        settabss(L, "what", ar.what);
+        break;
+      case 'l':
+        settabsi(L, "currentline", ar.currentline);
+        break;
+      case 'u':
+        settabsi(L, "nups", ar.nups);
+        break;
+      case 'n':
+        settabss(L, "name", ar.name);
+        settabss(L, "namewhat", ar.namewhat);
+        break;
+      case 'f':
+        lua_pushliteral(L, "func");
+        lua_pushvalue(L, -3);
+        lua_rawset(L, -3);
+        break;
+    }
+  }
+  return 1;  /* return table */
+}
+    
+
+static int getlocal (lua_State *L) {
+  lua_Debug ar;
+  const char *name;
+  if (!lua_getstack(L, luaL_checkint(L, 1), &ar))  /* level out of range? */
+    return luaL_argerror(L, 1, "level out of range");
+  name = lua_getlocal(L, &ar, luaL_checkint(L, 2));
+  if (name) {
+    lua_pushstring(L, name);
+    lua_pushvalue(L, -2);
+    return 2;
+  }
+  else {
+    lua_pushnil(L);
+    return 1;
+  }
+}
+
+
+static int setlocal (lua_State *L) {
+  lua_Debug ar;
+  if (!lua_getstack(L, luaL_checkint(L, 1), &ar))  /* level out of range? */
+    return luaL_argerror(L, 1, "level out of range");
+  luaL_checkany(L, 3);
+  lua_pushstring(L, lua_setlocal(L, &ar, luaL_checkint(L, 2)));
+  return 1;
+}
+
+
+static int auxupvalue (lua_State *L, int get) {
+  const char *name;
+  int n = luaL_checkint(L, 2);
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  if (lua_iscfunction(L, 1)) return 0;  /* cannot touch C upvalues from Lua */
+  name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);
+  if (name == NULL) return 0;
+  lua_pushstring(L, name);
+  lua_insert(L, -(get+1));
+  return get + 1;
+}
+
+
+static int getupvalue (lua_State *L) {
+  return auxupvalue(L, 1);
+}
+
+
+static int setupvalue (lua_State *L) {
+  luaL_checkany(L, 3);
+  return auxupvalue(L, 0);
+}
+
+
+
+static const char KEY_HOOK = 'h';
+
+
+static void hookf (lua_State *L, lua_Debug *ar) {
+  static const char *const hooknames[] =
+    {"call", "return", "line", "count", "tail return"};
+  lua_pushlightuserdata(L, (void *)&KEY_HOOK);
+  lua_rawget(L, LUA_REGISTRYINDEX);
+  if (lua_isfunction(L, -1)) {
+    lua_pushstring(L, hooknames[(int)ar->event]);
+    if (ar->currentline >= 0)
+      lua_pushnumber(L, (lua_Number)ar->currentline);
+    else lua_pushnil(L);
+    lua_assert(lua_getinfo(L, "lS", ar));
+    lua_call(L, 2, 0);
+  }
+  else
+    lua_pop(L, 1);  /* pop result from gettable */
+}
+
+
+static int makemask (const char *smask, int count) {
+  int mask = 0;
+  if (strchr(smask, 'c')) mask |= LUA_MASKCALL;
+  if (strchr(smask, 'r')) mask |= LUA_MASKRET;
+  if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
+  if (count > 0) mask |= LUA_MASKCOUNT;
+  return mask;
+}
+
+
+static char *unmakemask (int mask, char *smask) {
+  int i = 0;
+  if (mask & LUA_MASKCALL) smask[i++] = 'c';
+  if (mask & LUA_MASKRET) smask[i++] = 'r';
+  if (mask & LUA_MASKLINE) smask[i++] = 'l';
+  smask[i] = '\0';
+  return smask;
+}
+
+
+static int sethook (lua_State *L) {
+  if (lua_isnoneornil(L, 1)) {
+    lua_settop(L, 1);
+    lua_sethook(L, NULL, 0, 0);  /* turn off hooks */
+  }
+  else {
+    const char *smask = luaL_checkstring(L, 2);
+    int count = luaL_optint(L, 3, 0);
+    luaL_checktype(L, 1, LUA_TFUNCTION);
+    lua_sethook(L, hookf, makemask(smask, count), count);
+  }
+  lua_pushlightuserdata(L, (void *)&KEY_HOOK);
+  lua_pushvalue(L, 1);
+  lua_rawset(L, LUA_REGISTRYINDEX);  /* set new hook */
+  return 0;
+}
+
+
+static int gethook (lua_State *L) {
+  char buff[5];
+  int mask = lua_gethookmask(L);
+  lua_Hook hook = lua_gethook(L);
+  if (hook != NULL && hook != hookf)  /* external hook? */
+    lua_pushliteral(L, "external hook");
+  else {
+    lua_pushlightuserdata(L, (void *)&KEY_HOOK);
+    lua_rawget(L, LUA_REGISTRYINDEX);   /* get hook */
+  }
+  lua_pushstring(L, unmakemask(mask, buff));
+  lua_pushnumber(L, (lua_Number)lua_gethookcount(L));
+  return 3;
+}
+
+
+static int debug (lua_State *L) {
+  for (;;) {
+    char buffer[250];
+    fputs("lua_debug> ", stderr);
+    if (fgets(buffer, sizeof(buffer), stdin) == 0 ||
+        strcmp(buffer, "cont\n") == 0)
+      return 0;
+    lua_dostring(L, buffer);
+    lua_settop(L, 0);  /* remove eventual returns */
+  }
+}
+
+
+#define LEVELS1	12	/* size of the first part of the stack */
+#define LEVELS2	10	/* size of the second part of the stack */
+
+static int errorfb (lua_State *L) {
+  int level = 1;  /* skip level 0 (it's this function) */
+  int firstpart = 1;  /* still before eventual `...' */
+  lua_Debug ar;
+  if (lua_gettop(L) == 0)
+    lua_pushliteral(L, "");
+  else if (!lua_isstring(L, 1)) return 1;  /* no string message */
+  else lua_pushliteral(L, "\n");
+  lua_pushliteral(L, "stack traceback:");
+  while (lua_getstack(L, level++, &ar)) {
+    if (level > LEVELS1 && firstpart) {
+      /* no more than `LEVELS2' more levels? */
+      if (!lua_getstack(L, level+LEVELS2, &ar))
+        level--;  /* keep going */
+      else {
+        lua_pushliteral(L, "\n\t...");  /* too many levels */
+        while (lua_getstack(L, level+LEVELS2, &ar))  /* find last levels */
+          level++;
+      }
+      firstpart = 0;
+      continue;
+    }
+    lua_pushliteral(L, "\n\t");
+    lua_getinfo(L, "Snl", &ar);
+    lua_pushfstring(L, "%s:", ar.short_src);
+    if (ar.currentline > 0)
+      lua_pushfstring(L, "%d:", ar.currentline);
+    switch (*ar.namewhat) {
+      case 'g':  /* global */ 
+      case 'l':  /* local */
+      case 'f':  /* field */
+      case 'm':  /* method */
+        lua_pushfstring(L, " in function `%s'", ar.name);
+        break;
+      default: {
+        if (*ar.what == 'm')  /* main? */
+          lua_pushfstring(L, " in main chunk");
+        else if (*ar.what == 'C' || *ar.what == 't')
+          lua_pushliteral(L, " ?");  /* C function or tail call */
+        else
+          lua_pushfstring(L, " in function <%s:%d>",
+                             ar.short_src, ar.linedefined);
+      }
+    }
+    lua_concat(L, lua_gettop(L));
+  }
+  lua_concat(L, lua_gettop(L));
+  return 1;
+}
+
+
+static const luaL_reg dblib[] = {
+  {"getlocal", getlocal},
+  {"getinfo", getinfo},
+  {"gethook", gethook},
+  {"getupvalue", getupvalue},
+  {"sethook", sethook},
+  {"setlocal", setlocal},
+  {"setupvalue", setupvalue},
+  {"debug", debug},
+  {"traceback", errorfb},
+  {NULL, NULL}
+};
+
+
+LUALIB_API int luaopen_debug (lua_State *L) {
+  luaL_openlib(L, LUA_DBLIBNAME, dblib, 0);
+  lua_pushliteral(L, "_TRACEBACK");
+  lua_pushcfunction(L, errorfb);
+  lua_settable(L, LUA_GLOBALSINDEX);
+  return 1;
+}
+

Added: trunk/Util/deditor/lua/lib/liolib.c
===================================================================
--- trunk/Util/deditor/lua/lib/liolib.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/liolib.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,750 @@
+/*
+** $Id: liolib.c,v 2.39 2003/03/19 21:16:12 roberto Exp $
+** Standard I/O (and system) library
+** See Copyright Notice in lua.h
+*/
+
+
+#include <errno.h>
+#include <locale.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#define liolib_c
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+
+/*
+** by default, gcc does not get `tmpname'
+*/
+#ifndef USE_TMPNAME
+#ifdef __GNUC__
+#define USE_TMPNAME	0
+#else
+#define USE_TMPNAME	1
+#endif
+#endif
+
+
+/*
+** by default, posix systems get `popen'
+*/
+#ifndef USE_POPEN
+#ifdef _POSIX_C_SOURCE
+#if _POSIX_C_SOURCE >= 2
+#define USE_POPEN	1
+#endif
+#endif
+#endif
+
+#ifndef USE_POPEN
+#define USE_POPEN	0
+#endif
+
+
+
+
+/*
+** {======================================================
+** FILE Operations
+** =======================================================
+*/
+
+
+#if !USE_POPEN
+#define pclose(f)    (-1)
+#endif
+
+
+#define FILEHANDLE		"FILE*"
+
+#define IO_INPUT		"_input"
+#define IO_OUTPUT		"_output"
+
+
+static int pushresult (lua_State *L, int i, const char *filename) {
+  if (i) {
+    lua_pushboolean(L, 1);
+    return 1;
+  }
+  else {
+    lua_pushnil(L);
+    if (filename)
+      lua_pushfstring(L, "%s: %s", filename, strerror(errno));
+    else
+      lua_pushfstring(L, "%s", strerror(errno));
+    lua_pushnumber(L, errno);
+    return 3;
+  }
+}
+
+
+static FILE **topfile (lua_State *L, int findex) {
+  FILE **f = (FILE **)luaL_checkudata(L, findex, FILEHANDLE);
+  if (f == NULL) luaL_argerror(L, findex, "bad file");
+  return f;
+}
+
+
+static int io_type (lua_State *L) {
+  FILE **f = (FILE **)luaL_checkudata(L, 1, FILEHANDLE);
+  if (f == NULL) lua_pushnil(L);
+  else if (*f == NULL)
+    lua_pushliteral(L, "closed file");
+  else
+    lua_pushliteral(L, "file");
+  return 1;
+}
+
+
+static FILE *tofile (lua_State *L, int findex) {
+  FILE **f = topfile(L, findex);
+  if (*f == NULL)
+    luaL_error(L, "attempt to use a closed file");
+  return *f;
+}
+
+
+
+/*
+** When creating file handles, always creates a `closed' file handle
+** before opening the actual file; so, if there is a memory error, the
+** file is not left opened.
+*/
+static FILE **newfile (lua_State *L) {
+  FILE **pf = (FILE **)lua_newuserdata(L, sizeof(FILE *));
+  *pf = NULL;  /* file handle is currently `closed' */
+  luaL_getmetatable(L, FILEHANDLE);
+  lua_setmetatable(L, -2);
+  return pf;
+}
+
+
+/*
+** assumes that top of the stack is the `io' library, and next is
+** the `io' metatable
+*/
+static void registerfile (lua_State *L, FILE *f, const char *name,
+                                                 const char *impname) {
+  lua_pushstring(L, name);
+  *newfile(L) = f;
+  if (impname) {
+    lua_pushstring(L, impname);
+    lua_pushvalue(L, -2);
+    lua_settable(L, -6);  /* metatable[impname] = file */
+  }
+  lua_settable(L, -3);  /* io[name] = file */
+}
+
+
+static int aux_close (lua_State *L) {
+  FILE *f = tofile(L, 1);
+  if (f == stdin || f == stdout || f == stderr)
+    return 0;  /* file cannot be closed */
+  else {
+    int ok = (pclose(f) != -1) || (fclose(f) == 0);
+    if (ok)
+      *(FILE **)lua_touserdata(L, 1) = NULL;  /* mark file as closed */
+    return ok;
+  }
+}
+
+
+static int io_close (lua_State *L) {
+  if (lua_isnone(L, 1)) {
+    lua_pushstring(L, IO_OUTPUT);
+    lua_rawget(L, lua_upvalueindex(1));
+  }
+  return pushresult(L, aux_close(L), NULL);
+}
+
+
+static int io_gc (lua_State *L) {
+  FILE **f = topfile(L, 1);
+  if (*f != NULL)  /* ignore closed files */
+    aux_close(L);
+  return 0;
+}
+
+
+static int io_tostring (lua_State *L) {
+  char buff[32];
+  FILE **f = topfile(L, 1);
+  if (*f == NULL)
+    strcpy(buff, "closed");
+  else
+    sprintf(buff, "%p", lua_touserdata(L, 1));
+  lua_pushfstring(L, "file (%s)", buff);
+  return 1;
+}
+
+
+static int io_open (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  const char *mode = luaL_optstring(L, 2, "r");
+  FILE **pf = newfile(L);
+  *pf = fopen(filename, mode);
+  return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
+}
+
+
+static int io_popen (lua_State *L) {
+#if !USE_POPEN
+  luaL_error(L, "`popen' not supported");
+  return 0;
+#else
+  const char *filename = luaL_checkstring(L, 1);
+  const char *mode = luaL_optstring(L, 2, "r");
+  FILE **pf = newfile(L);
+  *pf = popen(filename, mode);
+  return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
+#endif
+}
+
+
+static int io_tmpfile (lua_State *L) {
+  FILE **pf = newfile(L);
+  *pf = tmpfile();
+  return (*pf == NULL) ? pushresult(L, 0, NULL) : 1;
+}
+
+
+static FILE *getiofile (lua_State *L, const char *name) {
+  lua_pushstring(L, name);
+  lua_rawget(L, lua_upvalueindex(1));
+  return tofile(L, -1);
+}
+
+
+static int g_iofile (lua_State *L, const char *name, const char *mode) {
+  if (!lua_isnoneornil(L, 1)) {
+    const char *filename = lua_tostring(L, 1);
+    lua_pushstring(L, name);
+    if (filename) {
+      FILE **pf = newfile(L);
+      *pf = fopen(filename, mode);
+      if (*pf == NULL) {
+        lua_pushfstring(L, "%s: %s", filename, strerror(errno));
+        luaL_argerror(L, 1, lua_tostring(L, -1));
+      }
+    }
+    else {
+      tofile(L, 1);  /* check that it's a valid file handle */
+      lua_pushvalue(L, 1);
+    }
+    lua_rawset(L, lua_upvalueindex(1));
+  }
+  /* return current value */
+  lua_pushstring(L, name);
+  lua_rawget(L, lua_upvalueindex(1));
+  return 1;
+}
+
+
+static int io_input (lua_State *L) {
+  return g_iofile(L, IO_INPUT, "r");
+}
+
+
+static int io_output (lua_State *L) {
+  return g_iofile(L, IO_OUTPUT, "w");
+}
+
+
+static int io_readline (lua_State *L);
+
+
+static void aux_lines (lua_State *L, int idx, int close) {
+  lua_pushliteral(L, FILEHANDLE);
+  lua_rawget(L, LUA_REGISTRYINDEX);
+  lua_pushvalue(L, idx);
+  lua_pushboolean(L, close);  /* close/not close file when finished */
+  lua_pushcclosure(L, io_readline, 3);
+}
+
+
+static int f_lines (lua_State *L) {
+  tofile(L, 1);  /* check that it's a valid file handle */
+  aux_lines(L, 1, 0);
+  return 1;
+}
+
+
+static int io_lines (lua_State *L) {
+  if (lua_isnoneornil(L, 1)) {  /* no arguments? */
+    lua_pushstring(L, IO_INPUT);
+    lua_rawget(L, lua_upvalueindex(1));  /* will iterate over default input */
+    return f_lines(L);
+  }
+  else {
+    const char *filename = luaL_checkstring(L, 1);
+    FILE **pf = newfile(L);
+    *pf = fopen(filename, "r");
+    luaL_argcheck(L, *pf, 1,  strerror(errno));
+    aux_lines(L, lua_gettop(L), 1);
+    return 1;
+  }
+}
+
+
+/*
+** {======================================================
+** READ
+** =======================================================
+*/
+
+
+static int read_number (lua_State *L, FILE *f) {
+  lua_Number d;
+  if (fscanf(f, LUA_NUMBER_SCAN, &d) == 1) {
+    lua_pushnumber(L, d);
+    return 1;
+  }
+  else return 0;  /* read fails */
+}
+
+
+static int test_eof (lua_State *L, FILE *f) {
+  int c = getc(f);
+  ungetc(c, f);
+  lua_pushlstring(L, NULL, 0);
+  return (c != EOF);
+}
+
+
+static int read_line (lua_State *L, FILE *f) {
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  for (;;) {
+    size_t l;
+    char *p = luaL_prepbuffer(&b);
+    if (fgets(p, LUAL_BUFFERSIZE, f) == NULL) {  /* eof? */
+      luaL_pushresult(&b);  /* close buffer */
+      return (lua_strlen(L, -1) > 0);  /* check whether read something */
+    }
+    l = strlen(p);
+    if (p[l-1] != '\n')
+      luaL_addsize(&b, l);
+    else {
+      luaL_addsize(&b, l - 1);  /* do not include `eol' */
+      luaL_pushresult(&b);  /* close buffer */
+      return 1;  /* read at least an `eol' */
+    }
+  }
+}
+
+
+static int read_chars (lua_State *L, FILE *f, size_t n) {
+  size_t rlen;  /* how much to read */
+  size_t nr;  /* number of chars actually read */
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  rlen = LUAL_BUFFERSIZE;  /* try to read that much each time */
+  do {
+    char *p = luaL_prepbuffer(&b);
+    if (rlen > n) rlen = n;  /* cannot read more than asked */
+    nr = fread(p, sizeof(char), rlen, f);
+    luaL_addsize(&b, nr);
+    n -= nr;  /* still have to read `n' chars */
+  } while (n > 0 && nr == rlen);  /* until end of count or eof */
+  luaL_pushresult(&b);  /* close buffer */
+  return (n == 0 || lua_strlen(L, -1) > 0);
+}
+
+
+static int g_read (lua_State *L, FILE *f, int first) {
+  int nargs = lua_gettop(L) - 1;
+  int success;
+  int n;
+  if (nargs == 0) {  /* no arguments? */
+    success = read_line(L, f);
+    n = first+1;  /* to return 1 result */
+  }
+  else {  /* ensure stack space for all results and for auxlib's buffer */
+    luaL_checkstack(L, nargs+LUA_MINSTACK, "too many arguments");
+    success = 1;
+    for (n = first; nargs-- && success; n++) {
+      if (lua_type(L, n) == LUA_TNUMBER) {
+        size_t l = (size_t)lua_tonumber(L, n);
+        success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);
+      }
+      else {
+        const char *p = lua_tostring(L, n);
+        luaL_argcheck(L, p && p[0] == '*', n, "invalid option");
+        switch (p[1]) {
+          case 'n':  /* number */
+            success = read_number(L, f);
+            break;
+          case 'l':  /* line */
+            success = read_line(L, f);
+            break;
+          case 'a':  /* file */
+            read_chars(L, f, ~((size_t)0));  /* read MAX_SIZE_T chars */
+            success = 1; /* always success */
+            break;
+          case 'w':  /* word */
+            return luaL_error(L, "obsolete option `*w' to `read'");
+          default:
+            return luaL_argerror(L, n, "invalid format");
+        }
+      }
+    }
+  }
+  if (!success) {
+    lua_pop(L, 1);  /* remove last result */
+    lua_pushnil(L);  /* push nil instead */
+  }
+  return n - first;
+}
+
+
+static int io_read (lua_State *L) {
+  return g_read(L, getiofile(L, IO_INPUT), 1);
+}
+
+
+static int f_read (lua_State *L) {
+  return g_read(L, tofile(L, 1), 2);
+}
+
+
+static int io_readline (lua_State *L) {
+  FILE *f = *(FILE **)lua_touserdata(L, lua_upvalueindex(2));
+  if (f == NULL)  /* file is already closed? */
+    luaL_error(L, "file is already closed");
+  if (read_line(L, f)) return 1;
+  else {  /* EOF */
+    if (lua_toboolean(L, lua_upvalueindex(3))) {  /* generator created file? */
+      lua_settop(L, 0);
+      lua_pushvalue(L, lua_upvalueindex(2));
+      aux_close(L);  /* close it */
+    }
+    return 0;
+  }
+}
+
+/* }====================================================== */
+
+
+static int g_write (lua_State *L, FILE *f, int arg) {
+  int nargs = lua_gettop(L) - 1;
+  int status = 1;
+  for (; nargs--; arg++) {
+    if (lua_type(L, arg) == LUA_TNUMBER) {
+      /* optimization: could be done exactly as for strings */
+      status = status &&
+          fprintf(f, LUA_NUMBER_FMT, lua_tonumber(L, arg)) > 0;
+    }
+    else {
+      size_t l;
+      const char *s = luaL_checklstring(L, arg, &l);
+      status = status && (fwrite(s, sizeof(char), l, f) == l);
+    }
+  }
+  return pushresult(L, status, NULL);
+}
+
+
+static int io_write (lua_State *L) {
+  return g_write(L, getiofile(L, IO_OUTPUT), 1);
+}
+
+
+static int f_write (lua_State *L) {
+  return g_write(L, tofile(L, 1), 2);
+}
+
+
+static int f_seek (lua_State *L) {
+  static const int mode[] = {SEEK_SET, SEEK_CUR, SEEK_END};
+  static const char *const modenames[] = {"set", "cur", "end", NULL};
+  FILE *f = tofile(L, 1);
+  int op = luaL_findstring(luaL_optstring(L, 2, "cur"), modenames);
+  long offset = luaL_optlong(L, 3, 0);
+  luaL_argcheck(L, op != -1, 2, "invalid mode");
+  op = fseek(f, offset, mode[op]);
+  if (op)
+    return pushresult(L, 0, NULL);  /* error */
+  else {
+    lua_pushnumber(L, ftell(f));
+    return 1;
+  }
+}
+
+
+static int io_flush (lua_State *L) {
+  return pushresult(L, fflush(getiofile(L, IO_OUTPUT)) == 0, NULL);
+}
+
+
+static int f_flush (lua_State *L) {
+  return pushresult(L, fflush(tofile(L, 1)) == 0, NULL);
+}
+
+
+static const luaL_reg iolib[] = {
+  {"input", io_input},
+  {"output", io_output},
+  {"lines", io_lines},
+  {"close", io_close},
+  {"flush", io_flush},
+  {"open", io_open},
+  {"popen", io_popen},
+  {"read", io_read},
+  {"tmpfile", io_tmpfile},
+  {"type", io_type},
+  {"write", io_write},
+  {NULL, NULL}
+};
+
+
+static const luaL_reg flib[] = {
+  {"flush", f_flush},
+  {"read", f_read},
+  {"lines", f_lines},
+  {"seek", f_seek},
+  {"write", f_write},
+  {"close", io_close},
+  {"__gc", io_gc},
+  {"__tostring", io_tostring},
+  {NULL, NULL}
+};
+
+
+static void createmeta (lua_State *L) {
+  luaL_newmetatable(L, FILEHANDLE);  /* create new metatable for file handles */
+  /* file methods */
+  lua_pushliteral(L, "__index");
+  lua_pushvalue(L, -2);  /* push metatable */
+  lua_rawset(L, -3);  /* metatable.__index = metatable */
+  luaL_openlib(L, NULL, flib, 0);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Other O.S. Operations
+** =======================================================
+*/
+
+static int io_execute (lua_State *L) {
+  lua_pushnumber(L, system(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+
+static int io_remove (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  return pushresult(L, remove(filename) == 0, filename);
+}
+
+
+static int io_rename (lua_State *L) {
+  const char *fromname = luaL_checkstring(L, 1);
+  const char *toname = luaL_checkstring(L, 2);
+  return pushresult(L, rename(fromname, toname) == 0, fromname);
+}
+
+
+static int io_tmpname (lua_State *L) {
+#if !USE_TMPNAME
+  luaL_error(L, "`tmpname' not supported");
+  return 0;
+#else
+  char buff[L_tmpnam];
+  if (tmpnam(buff) != buff)
+    return luaL_error(L, "unable to generate a unique filename in `tmpname'");
+  lua_pushstring(L, buff);
+  return 1;
+#endif
+}
+
+
+static int io_getenv (lua_State *L) {
+  lua_pushstring(L, getenv(luaL_checkstring(L, 1)));  /* if NULL push nil */
+  return 1;
+}
+
+
+static int io_clock (lua_State *L) {
+  lua_pushnumber(L, ((lua_Number)clock())/(lua_Number)CLOCKS_PER_SEC);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** Time/Date operations
+** { year=%Y, month=%m, day=%d, hour=%H, min=%M, sec=%S,
+**   wday=%w+1, yday=%j, isdst=? }
+** =======================================================
+*/
+
+static void setfield (lua_State *L, const char *key, int value) {
+  lua_pushstring(L, key);
+  lua_pushnumber(L, value);
+  lua_rawset(L, -3);
+}
+
+static void setboolfield (lua_State *L, const char *key, int value) {
+  lua_pushstring(L, key);
+  lua_pushboolean(L, value);
+  lua_rawset(L, -3);
+}
+
+static int getboolfield (lua_State *L, const char *key) {
+  int res;
+  lua_pushstring(L, key);
+  lua_gettable(L, -2);
+  res = lua_toboolean(L, -1);
+  lua_pop(L, 1);
+  return res;
+}
+
+
+static int getfield (lua_State *L, const char *key, int d) {
+  int res;
+  lua_pushstring(L, key);
+  lua_gettable(L, -2);
+  if (lua_isnumber(L, -1))
+    res = (int)(lua_tonumber(L, -1));
+  else {
+    if (d == -2)
+      return luaL_error(L, "field `%s' missing in date table", key);
+    res = d;
+  }
+  lua_pop(L, 1);
+  return res;
+}
+
+
+static int io_date (lua_State *L) {
+  const char *s = luaL_optstring(L, 1, "%c");
+  time_t t = (time_t)(luaL_optnumber(L, 2, -1));
+  struct tm *stm;
+  if (t == (time_t)(-1))  /* no time given? */
+    t = time(NULL);  /* use current time */
+  if (*s == '!') {  /* UTC? */
+    stm = gmtime(&t);
+    s++;  /* skip `!' */
+  }
+  else
+    stm = localtime(&t);
+  if (stm == NULL)  /* invalid date? */
+    lua_pushnil(L);
+  else if (strcmp(s, "*t") == 0) {
+    lua_newtable(L);
+    setfield(L, "sec", stm->tm_sec);
+    setfield(L, "min", stm->tm_min);
+    setfield(L, "hour", stm->tm_hour);
+    setfield(L, "day", stm->tm_mday);
+    setfield(L, "month", stm->tm_mon+1);
+    setfield(L, "year", stm->tm_year+1900);
+    setfield(L, "wday", stm->tm_wday+1);
+    setfield(L, "yday", stm->tm_yday+1);
+    setboolfield(L, "isdst", stm->tm_isdst);
+  }
+  else {
+    char b[256];
+    if (strftime(b, sizeof(b), s, stm))
+      lua_pushstring(L, b);
+    else
+      return luaL_error(L, "`date' format too long");
+  }
+  return 1;
+}
+
+
+static int io_time (lua_State *L) {
+  if (lua_isnoneornil(L, 1))  /* called without args? */
+    lua_pushnumber(L, time(NULL));  /* return current time */
+  else {
+    time_t t;
+    struct tm ts;
+    luaL_checktype(L, 1, LUA_TTABLE);
+    lua_settop(L, 1);  /* make sure table is at the top */
+    ts.tm_sec = getfield(L, "sec", 0);
+    ts.tm_min = getfield(L, "min", 0);
+    ts.tm_hour = getfield(L, "hour", 12);
+    ts.tm_mday = getfield(L, "day", -2);
+    ts.tm_mon = getfield(L, "month", -2) - 1;
+    ts.tm_year = getfield(L, "year", -2) - 1900;
+    ts.tm_isdst = getboolfield(L, "isdst");
+    t = mktime(&ts);
+    if (t == (time_t)(-1))
+      lua_pushnil(L);
+    else
+      lua_pushnumber(L, t);
+  }
+  return 1;
+}
+
+
+static int io_difftime (lua_State *L) {
+  lua_pushnumber(L, difftime((time_t)(luaL_checknumber(L, 1)),
+                             (time_t)(luaL_optnumber(L, 2, 0))));
+  return 1;
+}
+
+/* }====================================================== */
+
+
+static int io_setloc (lua_State *L) {
+  static const int cat[] = {LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY,
+                      LC_NUMERIC, LC_TIME};
+  static const char *const catnames[] = {"all", "collate", "ctype", "monetary",
+     "numeric", "time", NULL};
+  const char *l = lua_tostring(L, 1);
+  int op = luaL_findstring(luaL_optstring(L, 2, "all"), catnames);
+  luaL_argcheck(L, l || lua_isnoneornil(L, 1), 1, "string expected");
+  luaL_argcheck(L, op != -1, 2, "invalid option");
+  lua_pushstring(L, setlocale(cat[op], l));
+  return 1;
+}
+
+
+static int io_exit (lua_State *L) {
+  exit(luaL_optint(L, 1, EXIT_SUCCESS));
+  return 0;  /* to avoid warnings */
+}
+
+static const luaL_reg syslib[] = {
+  {"clock",     io_clock},
+  {"date",      io_date},
+  {"difftime",  io_difftime},
+  {"execute",   io_execute},
+  {"exit",      io_exit},
+  {"getenv",    io_getenv},
+  {"remove",    io_remove},
+  {"rename",    io_rename},
+  {"setlocale", io_setloc},
+  {"time",      io_time},
+  {"tmpname",   io_tmpname},
+  {NULL, NULL}
+};
+
+/* }====================================================== */
+
+
+
+LUALIB_API int luaopen_io (lua_State *L) {
+  luaL_openlib(L, LUA_OSLIBNAME, syslib, 0);
+  createmeta(L);
+  lua_pushvalue(L, -1);
+  luaL_openlib(L, LUA_IOLIBNAME, iolib, 1);
+  /* put predefined file handles into `io' table */
+  registerfile(L, stdin, "stdin", IO_INPUT);
+  registerfile(L, stdout, "stdout", IO_OUTPUT);
+  registerfile(L, stderr, "stderr", NULL);
+  return 1;
+}
+

Added: trunk/Util/deditor/lua/lib/lmathlib.c
===================================================================
--- trunk/Util/deditor/lua/lib/lmathlib.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/lmathlib.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,246 @@
+/*
+** $Id: lmathlib.c,v 1.56 2003/03/11 12:30:37 roberto Exp $
+** Standard mathematical library
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+#include <math.h>
+
+#define lmathlib_c
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#undef PI
+#define PI (3.14159265358979323846)
+#define RADIANS_PER_DEGREE (PI/180.0)
+
+
+
+/*
+** If you want Lua to operate in degrees (instead of radians),
+** define USE_DEGREES
+*/
+#ifdef USE_DEGREES
+#define FROMRAD(a)	((a)/RADIANS_PER_DEGREE)
+#define TORAD(a)	((a)*RADIANS_PER_DEGREE)
+#else
+#define FROMRAD(a)	(a)
+#define TORAD(a)	(a)
+#endif
+
+
+static int math_abs (lua_State *L) {
+  lua_pushnumber(L, fabs(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_sin (lua_State *L) {
+  lua_pushnumber(L, sin(TORAD(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_cos (lua_State *L) {
+  lua_pushnumber(L, cos(TORAD(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_tan (lua_State *L) {
+  lua_pushnumber(L, tan(TORAD(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_asin (lua_State *L) {
+  lua_pushnumber(L, FROMRAD(asin(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_acos (lua_State *L) {
+  lua_pushnumber(L, FROMRAD(acos(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_atan (lua_State *L) {
+  lua_pushnumber(L, FROMRAD(atan(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_atan2 (lua_State *L) {
+  lua_pushnumber(L, FROMRAD(atan2(luaL_checknumber(L, 1), luaL_checknumber(L, 2))));
+  return 1;
+}
+
+static int math_ceil (lua_State *L) {
+  lua_pushnumber(L, ceil(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_floor (lua_State *L) {
+  lua_pushnumber(L, floor(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_mod (lua_State *L) {
+  lua_pushnumber(L, fmod(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int math_sqrt (lua_State *L) {
+  lua_pushnumber(L, sqrt(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_pow (lua_State *L) {
+  lua_pushnumber(L, pow(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int math_log (lua_State *L) {
+  lua_pushnumber(L, log(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_log10 (lua_State *L) {
+  lua_pushnumber(L, log10(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_exp (lua_State *L) {
+  lua_pushnumber(L, exp(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_deg (lua_State *L) {
+  lua_pushnumber(L, luaL_checknumber(L, 1)/RADIANS_PER_DEGREE);
+  return 1;
+}
+
+static int math_rad (lua_State *L) {
+  lua_pushnumber(L, luaL_checknumber(L, 1)*RADIANS_PER_DEGREE);
+  return 1;
+}
+
+static int math_frexp (lua_State *L) {
+  int e;
+  lua_pushnumber(L, frexp(luaL_checknumber(L, 1), &e));
+  lua_pushnumber(L, e);
+  return 2;
+}
+
+static int math_ldexp (lua_State *L) {
+  lua_pushnumber(L, ldexp(luaL_checknumber(L, 1), luaL_checkint(L, 2)));
+  return 1;
+}
+
+
+
+static int math_min (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  lua_Number dmin = luaL_checknumber(L, 1);
+  int i;
+  for (i=2; i<=n; i++) {
+    lua_Number d = luaL_checknumber(L, i);
+    if (d < dmin)
+      dmin = d;
+  }
+  lua_pushnumber(L, dmin);
+  return 1;
+}
+
+
+static int math_max (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  lua_Number dmax = luaL_checknumber(L, 1);
+  int i;
+  for (i=2; i<=n; i++) {
+    lua_Number d = luaL_checknumber(L, i);
+    if (d > dmax)
+      dmax = d;
+  }
+  lua_pushnumber(L, dmax);
+  return 1;
+}
+
+
+static int math_random (lua_State *L) {
+  /* the `%' avoids the (rare) case of r==1, and is needed also because on
+     some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
+  lua_Number r = (lua_Number)(rand()%RAND_MAX) / (lua_Number)RAND_MAX;
+  switch (lua_gettop(L)) {  /* check number of arguments */
+    case 0: {  /* no arguments */
+      lua_pushnumber(L, r);  /* Number between 0 and 1 */
+      break;
+    }
+    case 1: {  /* only upper limit */
+      int u = luaL_checkint(L, 1);
+      luaL_argcheck(L, 1<=u, 1, "interval is empty");
+      lua_pushnumber(L, (int)floor(r*u)+1);  /* int between 1 and `u' */
+      break;
+    }
+    case 2: {  /* lower and upper limits */
+      int l = luaL_checkint(L, 1);
+      int u = luaL_checkint(L, 2);
+      luaL_argcheck(L, l<=u, 2, "interval is empty");
+      lua_pushnumber(L, (int)floor(r*(u-l+1))+l);  /* int between `l' and `u' */
+      break;
+    }
+    default: return luaL_error(L, "wrong number of arguments");
+  }
+  return 1;
+}
+
+
+static int math_randomseed (lua_State *L) {
+  srand(luaL_checkint(L, 1));
+  return 0;
+}
+
+
+static const luaL_reg mathlib[] = {
+  {"abs",   math_abs},
+  {"sin",   math_sin},
+  {"cos",   math_cos},
+  {"tan",   math_tan},
+  {"asin",  math_asin},
+  {"acos",  math_acos},
+  {"atan",  math_atan},
+  {"atan2", math_atan2},
+  {"ceil",  math_ceil},
+  {"floor", math_floor},
+  {"mod",   math_mod},
+  {"frexp", math_frexp},
+  {"ldexp", math_ldexp},
+  {"sqrt",  math_sqrt},
+  {"min",   math_min},
+  {"max",   math_max},
+  {"log",   math_log},
+  {"log10", math_log10},
+  {"exp",   math_exp},
+  {"deg",   math_deg},
+  {"pow",   math_pow},
+  {"rad",   math_rad},
+  {"random",     math_random},
+  {"randomseed", math_randomseed},
+  {NULL, NULL}
+};
+
+
+/*
+** Open math library
+*/
+LUALIB_API int luaopen_math (lua_State *L) {
+  luaL_openlib(L, LUA_MATHLIBNAME, mathlib, 0);
+  lua_pushliteral(L, "pi");
+  lua_pushnumber(L, PI);
+  lua_settable(L, -3);
+  lua_pushliteral(L, "__pow");
+  lua_pushcfunction(L, math_pow);
+  lua_settable(L, LUA_GLOBALSINDEX);
+  return 1;
+}
+

Added: trunk/Util/deditor/lua/lib/loadlib.c
===================================================================
--- trunk/Util/deditor/lua/lib/loadlib.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/loadlib.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,205 @@
+/*
+** $Id: loadlib.c,v 1.4 2003/04/07 20:11:53 roberto Exp $
+** Dynamic library loader for Lua
+** See Copyright Notice in lua.h
+*
+* This  Lua library  exports a  single function,  called loadlib,  which is
+* called from Lua  as loadlib(lib,init), where lib is the  full name of the
+* library to be  loaded (including the complete path) and  init is the name
+* of a function  to be called after the library  is loaded. Typically, this
+* function will register other functions,  thus making the complete library
+* available  to Lua.  The init  function is  *not* automatically  called by
+* loadlib. Instead,  loadlib returns  the init function  as a  Lua function
+* that the client  can call when it  thinks is appropriate. In  the case of
+* errors,  loadlib  returns  nil  and two  strings  describing  the  error.
+* The  first string  is  supplied by  the operating  system;  it should  be
+* informative and useful  for error messages. The second  string is "open",
+* "init", or  "absent" to identify  the error and is  meant to be  used for
+* making  decisions without  having to  look into  the first  string (whose
+* format is system-dependent).
+*
+* This module contains  an implementation of loadlib for  Unix systems that
+* have dlfcn, an implementation for Windows,  and a stub for other systems.
+* See  the list  at  the end  of  this  file for  some  links to  available
+* implementations of dlfcn  and interfaces to other  native dynamic loaders
+* on top of which loadlib could be implemented.
+*
+*/
+
+#include "lua.h"
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#undef LOADLIB
+
+
+#ifdef USE_DLOPEN
+#define LOADLIB
+/*
+* This is an implementation of loadlib based on the dlfcn interface.
+* The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,
+* NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least
+* as an emulation layer on top of native functions.
+*/
+
+#include <dlfcn.h>
+
+static int loadlib(lua_State *L)
+{
+ const char *path=luaL_checkstring(L,1);
+ const char *init=luaL_checkstring(L,2);
+ void *lib=dlopen(path,RTLD_NOW);
+ if (lib!=NULL)
+ {
+  lua_CFunction f=(lua_CFunction) dlsym(lib,init);
+  if (f!=NULL)
+  {
+   lua_pushlightuserdata(L,lib);
+   lua_pushcclosure(L,f,1);
+   return 1;
+  }
+ }
+ /* else return appropriate error messages */
+ lua_pushnil(L);
+ lua_pushstring(L,dlerror());
+ lua_pushstring(L,(lib!=NULL) ? "init" : "open");
+ if (lib!=NULL) dlclose(lib);
+ return 3;
+}
+
+#endif
+
+
+
+/*
+** In Windows, default is to use dll; otherwise, default is not to use dll
+*/
+#ifndef USE_DLL
+#ifdef _WIN32
+#define USE_DLL	1
+#else
+#define USE_DLL	0
+#endif
+#endif
+
+
+#if USE_DLL
+#define LOADLIB
+/*
+* This is an implementation of loadlib for Windows using native functions.
+*/
+
+#include <windows.h>
+
+static void pusherror(lua_State *L)
+{
+ int error=GetLastError();
+ char buffer[128];
+ if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
+	0, error, 0, buffer, sizeof(buffer), 0))
+  lua_pushstring(L,buffer);
+ else
+  lua_pushfstring(L,"system error %d\n",error);
+}
+
+static int loadlib(lua_State *L)
+{
+ const char *path=luaL_checkstring(L,1);
+ const char *init=luaL_checkstring(L,2);
+ HINSTANCE lib=LoadLibrary(path);
+ if (lib!=NULL)
+ {
+  lua_CFunction f=(lua_CFunction) GetProcAddress(lib,init);
+  if (f!=NULL)
+  {
+   lua_pushlightuserdata(L,lib);
+   lua_pushcclosure(L,f,1);
+   return 1;
+  }
+ }
+ lua_pushnil(L);
+ pusherror(L);
+ lua_pushstring(L,(lib!=NULL) ? "init" : "open");
+ if (lib!=NULL) FreeLibrary(lib);
+ return 3;
+}
+
+#endif
+
+
+
+#ifndef LOADLIB
+/* Fallback for other systems */
+
+/*
+** Those systems support dlopen, so they should have defined USE_DLOPEN.
+** The default (no)implementation gives them a special error message.
+*/
+#ifdef linux
+#define LOADLIB
+#endif
+
+#ifdef sun
+#define LOADLIB
+#endif
+
+#ifdef sgi
+#define LOADLIB
+#endif
+
+#ifdef BSD
+#define LOADLIB
+#endif
+
+#ifdef _WIN32
+#define LOADLIB
+#endif
+
+#ifdef LOADLIB
+#undef LOADLIB
+#define LOADLIB	"`loadlib' not installed (check your Lua configuration)"
+#else
+#define LOADLIB	"`loadlib' not supported"
+#endif
+
+static int loadlib(lua_State *L)
+{
+ lua_pushnil(L);
+ lua_pushliteral(L,LOADLIB);
+ lua_pushliteral(L,"absent");
+ return 3;
+}
+#endif
+
+LUALIB_API int luaopen_loadlib (lua_State *L)
+{
+ lua_register(L,"loadlib",loadlib);
+ return 0;
+}
+
+/*
+* Here are some links to available implementations of dlfcn and
+* interfaces to other native dynamic loaders on top of which loadlib
+* could be implemented. Please send contributions and corrections to us.
+*
+* AIX
+* Starting with AIX 4.2, dlfcn is included in the base OS.
+* There is also an emulation package available.
+* http://www.faqs.org/faqs/aix-faq/part4/section-21.html
+*
+* HPUX 
+* HPUX 11 has dlfcn. For HPUX 10 use shl_*.
+* http://www.geda.seul.org/mailinglist/geda-dev37/msg00094.html
+* http://www.stat.umn.edu/~luke/xls/projects/dlbasics/dlbasics.html
+*
+* Macintosh, Windows
+* http://www.stat.umn.edu/~luke/xls/projects/dlbasics/dlbasics.html
+*
+* Mac OS X/Darwin
+* http://www.opendarwin.org/projects/dlcompat/
+*
+* GLIB has wrapper code for BeOS, OS2, Unix and Windows
+* http://cvs.gnome.org/lxr/source/glib/gmodule/
+*
+*/

Added: trunk/Util/deditor/lua/lib/lstrlib.c
===================================================================
--- trunk/Util/deditor/lua/lib/lstrlib.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/lstrlib.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,770 @@
+/*
+** $Id: lstrlib.c,v 1.98 2003/04/03 13:35:34 roberto Exp $
+** Standard library for string operations and pattern-matching
+** See Copyright Notice in lua.h
+*/
+
+
+#include <ctype.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lstrlib_c
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/* macro to `unsign' a character */
+#ifndef uchar
+#define uchar(c)        ((unsigned char)(c))
+#endif
+
+
+typedef long sint32;	/* a signed version for size_t */
+
+
+static int str_len (lua_State *L) {
+  size_t l;
+  luaL_checklstring(L, 1, &l);
+  lua_pushnumber(L, (lua_Number)l);
+  return 1;
+}
+
+
+static sint32 posrelat (sint32 pos, size_t len) {
+  /* relative string position: negative means back from end */
+  return (pos>=0) ? pos : (sint32)len+pos+1;
+}
+
+
+static int str_sub (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &l);
+  sint32 start = posrelat(luaL_checklong(L, 2), l);
+  sint32 end = posrelat(luaL_optlong(L, 3, -1), l);
+  if (start < 1) start = 1;
+  if (end > (sint32)l) end = (sint32)l;
+  if (start <= end)
+    lua_pushlstring(L, s+start-1, end-start+1);
+  else lua_pushliteral(L, "");
+  return 1;
+}
+
+
+static int str_lower (lua_State *L) {
+  size_t l;
+  size_t i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &l);
+  luaL_buffinit(L, &b);
+  for (i=0; i<l; i++)
+    luaL_putchar(&b, tolower(uchar(s[i])));
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+static int str_upper (lua_State *L) {
+  size_t l;
+  size_t i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &l);
+  luaL_buffinit(L, &b);
+  for (i=0; i<l; i++)
+    luaL_putchar(&b, toupper(uchar(s[i])));
+  luaL_pushresult(&b);
+  return 1;
+}
+
+static int str_rep (lua_State *L) {
+  size_t l;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &l);
+  int n = luaL_checkint(L, 2);
+  luaL_buffinit(L, &b);
+  while (n-- > 0)
+    luaL_addlstring(&b, s, l);
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+static int str_byte (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &l);
+  sint32 pos = posrelat(luaL_optlong(L, 2, 1), l);
+  if (pos <= 0 || (size_t)(pos) > l)  /* index out of range? */
+    return 0;  /* no answer */
+  lua_pushnumber(L, uchar(s[pos-1]));
+  return 1;
+}
+
+
+static int str_char (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  int i;
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  for (i=1; i<=n; i++) {
+    int c = luaL_checkint(L, i);
+    luaL_argcheck(L, uchar(c) == c, i, "invalid value");
+    luaL_putchar(&b, uchar(c));
+  }
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+static int writer (lua_State *L, const void* b, size_t size, void* B) {
+  (void)L;
+  luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
+  return 1;
+}
+
+
+static int str_dump (lua_State *L) {
+  luaL_Buffer b;
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  luaL_buffinit(L,&b);
+  if (!lua_dump(L, writer, &b))
+    luaL_error(L, "unable to dump given function");
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+
+/*
+** {======================================================
+** PATTERN MATCHING
+** =======================================================
+*/
+
+#ifndef MAX_CAPTURES
+#define MAX_CAPTURES 32  /* arbitrary limit */
+#endif
+
+
+#define CAP_UNFINISHED	(-1)
+#define CAP_POSITION	(-2)
+
+typedef struct MatchState {
+  const char *src_init;  /* init of source string */
+  const char *src_end;  /* end (`\0') of source string */
+  lua_State *L;
+  int level;  /* total number of captures (finished or unfinished) */
+  struct {
+    const char *init;
+    sint32 len;
+  } capture[MAX_CAPTURES];
+} MatchState;
+
+
+#define ESC		'%'
+#define SPECIALS	"^$*+?.([%-"
+
+
+static int check_capture (MatchState *ms, int l) {
+  l -= '1';
+  if (l < 0 || l >= ms->level || ms->capture[l].len == CAP_UNFINISHED)
+    return luaL_error(ms->L, "invalid capture index");
+  return l;
+}
+
+
+static int capture_to_close (MatchState *ms) {
+  int level = ms->level;
+  for (level--; level>=0; level--)
+    if (ms->capture[level].len == CAP_UNFINISHED) return level;
+  return luaL_error(ms->L, "invalid pattern capture");
+}
+
+
+static const char *luaI_classend (MatchState *ms, const char *p) {
+  switch (*p++) {
+    case ESC: {
+      if (*p == '\0')
+        luaL_error(ms->L, "malformed pattern (ends with `%')");
+      return p+1;
+    }
+    case '[': {
+      if (*p == '^') p++;
+      do {  /* look for a `]' */
+        if (*p == '\0')
+          luaL_error(ms->L, "malformed pattern (missing `]')");
+        if (*(p++) == ESC && *p != '\0')
+          p++;  /* skip escapes (e.g. `%]') */
+      } while (*p != ']');
+      return p+1;
+    }
+    default: {
+      return p;
+    }
+  }
+}
+
+
+static int match_class (int c, int cl) {
+  int res;
+  switch (tolower(cl)) {
+    case 'a' : res = isalpha(c); break;
+    case 'c' : res = iscntrl(c); break;
+    case 'd' : res = isdigit(c); break;
+    case 'l' : res = islower(c); break;
+    case 'p' : res = ispunct(c); break;
+    case 's' : res = isspace(c); break;
+    case 'u' : res = isupper(c); break;
+    case 'w' : res = isalnum(c); break;
+    case 'x' : res = isxdigit(c); break;
+    case 'z' : res = (c == 0); break;
+    default: return (cl == c);
+  }
+  return (islower(cl) ? res : !res);
+}
+
+
+static int matchbracketclass (int c, const char *p, const char *ec) {
+  int sig = 1;
+  if (*(p+1) == '^') {
+    sig = 0;
+    p++;  /* skip the `^' */
+  }
+  while (++p < ec) {
+    if (*p == ESC) {
+      p++;
+      if (match_class(c, *p))
+        return sig;
+    }
+    else if ((*(p+1) == '-') && (p+2 < ec)) {
+      p+=2;
+      if (uchar(*(p-2)) <= c && c <= uchar(*p))
+        return sig;
+    }
+    else if (uchar(*p) == c) return sig;
+  }
+  return !sig;
+}
+
+
+static int luaI_singlematch (int c, const char *p, const char *ep) {
+  switch (*p) {
+    case '.': return 1;  /* matches any char */
+    case ESC: return match_class(c, *(p+1));
+    case '[': return matchbracketclass(c, p, ep-1);
+    default:  return (uchar(*p) == c);
+  }
+}
+
+
+static const char *match (MatchState *ms, const char *s, const char *p);
+
+
+static const char *matchbalance (MatchState *ms, const char *s,
+                                   const char *p) {
+  if (*p == 0 || *(p+1) == 0)
+    luaL_error(ms->L, "unbalanced pattern");
+  if (*s != *p) return NULL;
+  else {
+    int b = *p;
+    int e = *(p+1);
+    int cont = 1;
+    while (++s < ms->src_end) {
+      if (*s == e) {
+        if (--cont == 0) return s+1;
+      }
+      else if (*s == b) cont++;
+    }
+  }
+  return NULL;  /* string ends out of balance */
+}
+
+
+static const char *max_expand (MatchState *ms, const char *s,
+                                 const char *p, const char *ep) {
+  sint32 i = 0;  /* counts maximum expand for item */
+  while ((s+i)<ms->src_end && luaI_singlematch(uchar(*(s+i)), p, ep))
+    i++;
+  /* keeps trying to match with the maximum repetitions */
+  while (i>=0) {
+    const char *res = match(ms, (s+i), ep+1);
+    if (res) return res;
+    i--;  /* else didn't match; reduce 1 repetition to try again */
+  }
+  return NULL;
+}
+
+
+static const char *min_expand (MatchState *ms, const char *s,
+                                 const char *p, const char *ep) {
+  for (;;) {
+    const char *res = match(ms, s, ep+1);
+    if (res != NULL)
+      return res;
+    else if (s<ms->src_end && luaI_singlematch(uchar(*s), p, ep))
+      s++;  /* try with one more repetition */
+    else return NULL;
+  }
+}
+
+
+static const char *start_capture (MatchState *ms, const char *s,
+                                    const char *p, int what) {
+  const char *res;
+  int level = ms->level;
+  if (level >= MAX_CAPTURES) luaL_error(ms->L, "too many captures");
+  ms->capture[level].init = s;
+  ms->capture[level].len = what;
+  ms->level = level+1;
+  if ((res=match(ms, s, p)) == NULL)  /* match failed? */
+    ms->level--;  /* undo capture */
+  return res;
+}
+
+
+static const char *end_capture (MatchState *ms, const char *s,
+                                  const char *p) {
+  int l = capture_to_close(ms);
+  const char *res;
+  ms->capture[l].len = s - ms->capture[l].init;  /* close capture */
+  if ((res = match(ms, s, p)) == NULL)  /* match failed? */
+    ms->capture[l].len = CAP_UNFINISHED;  /* undo capture */
+  return res;
+}
+
+
+static const char *match_capture (MatchState *ms, const char *s, int l) {
+  size_t len;
+  l = check_capture(ms, l);
+  len = ms->capture[l].len;
+  if ((size_t)(ms->src_end-s) >= len &&
+      memcmp(ms->capture[l].init, s, len) == 0)
+    return s+len;
+  else return NULL;
+}
+
+
+static const char *match (MatchState *ms, const char *s, const char *p) {
+  init: /* using goto's to optimize tail recursion */
+  switch (*p) {
+    case '(': {  /* start capture */
+      if (*(p+1) == ')')  /* position capture? */
+        return start_capture(ms, s, p+2, CAP_POSITION);
+      else
+        return start_capture(ms, s, p+1, CAP_UNFINISHED);
+    }
+    case ')': {  /* end capture */
+      return end_capture(ms, s, p+1);
+    }
+    case ESC: {
+      switch (*(p+1)) {
+        case 'b': {  /* balanced string? */
+          s = matchbalance(ms, s, p+2);
+          if (s == NULL) return NULL;
+          p+=4; goto init;  /* else return match(ms, s, p+4); */
+        }
+        case 'f': {  /* frontier? */
+          const char *ep; char previous;
+          p += 2;
+          if (*p != '[')
+            luaL_error(ms->L, "missing `[' after `%%f' in pattern");
+          ep = luaI_classend(ms, p);  /* points to what is next */
+          previous = (s == ms->src_init) ? '\0' : *(s-1);
+          if (matchbracketclass(uchar(previous), p, ep-1) ||
+             !matchbracketclass(uchar(*s), p, ep-1)) return NULL;
+          p=ep; goto init;  /* else return match(ms, s, ep); */
+        }
+        default: {
+          if (isdigit(uchar(*(p+1)))) {  /* capture results (%0-%9)? */
+            s = match_capture(ms, s, *(p+1));
+            if (s == NULL) return NULL;
+            p+=2; goto init;  /* else return match(ms, s, p+2) */
+          }
+          goto dflt;  /* case default */
+        }
+      }
+    }
+    case '\0': {  /* end of pattern */
+      return s;  /* match succeeded */
+    }
+    case '$': {
+      if (*(p+1) == '\0')  /* is the `$' the last char in pattern? */
+        return (s == ms->src_end) ? s : NULL;  /* check end of string */
+      else goto dflt;
+    }
+    default: dflt: {  /* it is a pattern item */
+      const char *ep = luaI_classend(ms, p);  /* points to what is next */
+      int m = s<ms->src_end && luaI_singlematch(uchar(*s), p, ep);
+      switch (*ep) {
+        case '?': {  /* optional */
+          const char *res;
+          if (m && ((res=match(ms, s+1, ep+1)) != NULL))
+            return res;
+          p=ep+1; goto init;  /* else return match(ms, s, ep+1); */
+        }
+        case '*': {  /* 0 or more repetitions */
+          return max_expand(ms, s, p, ep);
+        }
+        case '+': {  /* 1 or more repetitions */
+          return (m ? max_expand(ms, s+1, p, ep) : NULL);
+        }
+        case '-': {  /* 0 or more repetitions (minimum) */
+          return min_expand(ms, s, p, ep);
+        }
+        default: {
+          if (!m) return NULL;
+          s++; p=ep; goto init;  /* else return match(ms, s+1, ep); */
+        }
+      }
+    }
+  }
+}
+
+
+
+static const char *lmemfind (const char *s1, size_t l1,
+                               const char *s2, size_t l2) {
+  if (l2 == 0) return s1;  /* empty strings are everywhere */
+  else if (l2 > l1) return NULL;  /* avoids a negative `l1' */
+  else {
+    const char *init;  /* to search for a `*s2' inside `s1' */
+    l2--;  /* 1st char will be checked by `memchr' */
+    l1 = l1-l2;  /* `s2' cannot be found after that */
+    while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != NULL) {
+      init++;   /* 1st char is already checked */
+      if (memcmp(init, s2+1, l2) == 0)
+        return init-1;
+      else {  /* correct `l1' and `s1' to try again */
+        l1 -= init-s1;
+        s1 = init;
+      }
+    }
+    return NULL;  /* not found */
+  }
+}
+
+
+static void push_onecapture (MatchState *ms, int i) {
+  int l = ms->capture[i].len;
+  if (l == CAP_UNFINISHED) luaL_error(ms->L, "unfinished capture");
+  if (l == CAP_POSITION)
+    lua_pushnumber(ms->L, (lua_Number)(ms->capture[i].init - ms->src_init + 1));
+  else
+    lua_pushlstring(ms->L, ms->capture[i].init, l);
+}
+
+
+static int push_captures (MatchState *ms, const char *s, const char *e) {
+  int i;
+  luaL_checkstack(ms->L, ms->level, "too many captures");
+  if (ms->level == 0 && s) {  /* no explicit captures? */
+    lua_pushlstring(ms->L, s, e-s);  /* return whole match */
+    return 1;
+  }
+  else {  /* return all captures */
+    for (i=0; i<ms->level; i++)
+      push_onecapture(ms, i);
+    return ms->level;  /* number of strings pushed */
+  }
+}
+
+
+static int str_find (lua_State *L) {
+  size_t l1, l2;
+  const char *s = luaL_checklstring(L, 1, &l1);
+  const char *p = luaL_checklstring(L, 2, &l2);
+  sint32 init = posrelat(luaL_optlong(L, 3, 1), l1) - 1;
+  if (init < 0) init = 0;
+  else if ((size_t)(init) > l1) init = (sint32)l1;
+  if (lua_toboolean(L, 4) ||  /* explicit request? */
+      strpbrk(p, SPECIALS) == NULL) {  /* or no special characters? */
+    /* do a plain search */
+    const char *s2 = lmemfind(s+init, l1-init, p, l2);
+    if (s2) {
+      lua_pushnumber(L, (lua_Number)(s2-s+1));
+      lua_pushnumber(L, (lua_Number)(s2-s+l2));
+      return 2;
+    }
+  }
+  else {
+    MatchState ms;
+    int anchor = (*p == '^') ? (p++, 1) : 0;
+    const char *s1=s+init;
+    ms.L = L;
+    ms.src_init = s;
+    ms.src_end = s+l1;
+    do {
+      const char *res;
+      ms.level = 0;
+      if ((res=match(&ms, s1, p)) != NULL) {
+        lua_pushnumber(L, (lua_Number)(s1-s+1));  /* start */
+        lua_pushnumber(L, (lua_Number)(res-s));   /* end */
+        return push_captures(&ms, NULL, 0) + 2;
+      }
+    } while (s1++<ms.src_end && !anchor);
+  }
+  lua_pushnil(L);  /* not found */
+  return 1;
+}
+
+
+static int gfind_aux (lua_State *L) {
+  MatchState ms;
+  const char *s = lua_tostring(L, lua_upvalueindex(1));
+  size_t ls = lua_strlen(L, lua_upvalueindex(1));
+  const char *p = lua_tostring(L, lua_upvalueindex(2));
+  const char *src;
+  ms.L = L;
+  ms.src_init = s;
+  ms.src_end = s+ls;
+  for (src = s + (size_t)lua_tonumber(L, lua_upvalueindex(3));
+       src <= ms.src_end;
+       src++) {
+    const char *e;
+    ms.level = 0;
+    if ((e = match(&ms, src, p)) != NULL) {
+      int newstart = e-s;
+      if (e == src) newstart++;  /* empty match? go at least one position */
+      lua_pushnumber(L, (lua_Number)newstart);
+      lua_replace(L, lua_upvalueindex(3));
+      return push_captures(&ms, src, e);
+    }
+  }
+  return 0;  /* not found */
+}
+
+
+static int gfind (lua_State *L) {
+  luaL_checkstring(L, 1);
+  luaL_checkstring(L, 2);
+  lua_settop(L, 2);
+  lua_pushnumber(L, 0);
+  lua_pushcclosure(L, gfind_aux, 3);
+  return 1;
+}
+
+
+static void add_s (MatchState *ms, luaL_Buffer *b,
+                   const char *s, const char *e) {
+  lua_State *L = ms->L;
+  if (lua_isstring(L, 3)) {
+    const char *news = lua_tostring(L, 3);
+    size_t l = lua_strlen(L, 3);
+    size_t i;
+    for (i=0; i<l; i++) {
+      if (news[i] != ESC)
+        luaL_putchar(b, news[i]);
+      else {
+        i++;  /* skip ESC */
+        if (!isdigit(uchar(news[i])))
+          luaL_putchar(b, news[i]);
+        else {
+          int level = check_capture(ms, news[i]);
+          push_onecapture(ms, level);
+          luaL_addvalue(b);  /* add capture to accumulated result */
+        }
+      }
+    }
+  }
+  else {  /* is a function */
+    int n;
+    lua_pushvalue(L, 3);
+    n = push_captures(ms, s, e);
+    lua_call(L, n, 1);
+    if (lua_isstring(L, -1))
+      luaL_addvalue(b);  /* add return to accumulated result */
+    else
+      lua_pop(L, 1);  /* function result is not a string: pop it */
+  }
+}
+
+
+static int str_gsub (lua_State *L) {
+  size_t srcl;
+  const char *src = luaL_checklstring(L, 1, &srcl);
+  const char *p = luaL_checkstring(L, 2);
+  int max_s = luaL_optint(L, 4, srcl+1);
+  int anchor = (*p == '^') ? (p++, 1) : 0;
+  int n = 0;
+  MatchState ms;
+  luaL_Buffer b;
+  luaL_argcheck(L,
+    lua_gettop(L) >= 3 && (lua_isstring(L, 3) || lua_isfunction(L, 3)),
+    3, "string or function expected");
+  luaL_buffinit(L, &b);
+  ms.L = L;
+  ms.src_init = src;
+  ms.src_end = src+srcl;
+  while (n < max_s) {
+    const char *e;
+    ms.level = 0;
+    e = match(&ms, src, p);
+    if (e) {
+      n++;
+      add_s(&ms, &b, src, e);
+    }
+    if (e && e>src) /* non empty match? */
+      src = e;  /* skip it */
+    else if (src < ms.src_end)
+      luaL_putchar(&b, *src++);
+    else break;
+    if (anchor) break;
+  }
+  luaL_addlstring(&b, src, ms.src_end-src);
+  luaL_pushresult(&b);
+  lua_pushnumber(L, (lua_Number)n);  /* number of substitutions */
+  return 2;
+}
+
+/* }====================================================== */
+
+
+/* maximum size of each formatted item (> len(format('%99.99f', -1e308))) */
+#define MAX_ITEM	512
+/* maximum size of each format specification (such as '%-099.99d') */
+#define MAX_FORMAT	20
+
+
+static void luaI_addquoted (lua_State *L, luaL_Buffer *b, int arg) {
+  size_t l;
+  const char *s = luaL_checklstring(L, arg, &l);
+  luaL_putchar(b, '"');
+  while (l--) {
+    switch (*s) {
+      case '"': case '\\': case '\n': {
+        luaL_putchar(b, '\\');
+        luaL_putchar(b, *s);
+        break;
+      }
+      case '\0': {
+        luaL_addlstring(b, "\\000", 4);
+        break;
+      }
+      default: {
+        luaL_putchar(b, *s);
+        break;
+      }
+    }
+    s++;
+  }
+  luaL_putchar(b, '"');
+}
+
+
+static const char *scanformat (lua_State *L, const char *strfrmt,
+                                 char *form, int *hasprecision) {
+  const char *p = strfrmt;
+  while (strchr("-+ #0", *p)) p++;  /* skip flags */
+  if (isdigit(uchar(*p))) p++;  /* skip width */
+  if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
+  if (*p == '.') {
+    p++;
+    *hasprecision = 1;
+    if (isdigit(uchar(*p))) p++;  /* skip precision */
+    if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
+  }
+  if (isdigit(uchar(*p)))
+    luaL_error(L, "invalid format (width or precision too long)");
+  if (p-strfrmt+2 > MAX_FORMAT)  /* +2 to include `%' and the specifier */
+    luaL_error(L, "invalid format (too long)");
+  form[0] = '%';
+  strncpy(form+1, strfrmt, p-strfrmt+1);
+  form[p-strfrmt+2] = 0;
+  return p;
+}
+
+
+static int str_format (lua_State *L) {
+  int arg = 1;
+  size_t sfl;
+  const char *strfrmt = luaL_checklstring(L, arg, &sfl);
+  const char *strfrmt_end = strfrmt+sfl;
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  while (strfrmt < strfrmt_end) {
+    if (*strfrmt != '%')
+      luaL_putchar(&b, *strfrmt++);
+    else if (*++strfrmt == '%')
+      luaL_putchar(&b, *strfrmt++);  /* %% */
+    else { /* format item */
+      char form[MAX_FORMAT];  /* to store the format (`%...') */
+      char buff[MAX_ITEM];  /* to store the formatted item */
+      int hasprecision = 0;
+      if (isdigit(uchar(*strfrmt)) && *(strfrmt+1) == '$')
+        return luaL_error(L, "obsolete option (d$) to `format'");
+      arg++;
+      strfrmt = scanformat(L, strfrmt, form, &hasprecision);
+      switch (*strfrmt++) {
+        case 'c':  case 'd':  case 'i': {
+          sprintf(buff, form, luaL_checkint(L, arg));
+          break;
+        }
+        case 'o':  case 'u':  case 'x':  case 'X': {
+          sprintf(buff, form, (unsigned int)(luaL_checknumber(L, arg)));
+          break;
+        }
+        case 'e':  case 'E': case 'f':
+        case 'g': case 'G': {
+          sprintf(buff, form, luaL_checknumber(L, arg));
+          break;
+        }
+        case 'q': {
+          luaI_addquoted(L, &b, arg);
+          continue;  /* skip the `addsize' at the end */
+        }
+        case 's': {
+          size_t l;
+          const char *s = luaL_checklstring(L, arg, &l);
+          if (!hasprecision && l >= 100) {
+            /* no precision and string is too long to be formatted;
+               keep original string */
+            lua_pushvalue(L, arg);
+            luaL_addvalue(&b);
+            continue;  /* skip the `addsize' at the end */
+          }
+          else {
+            sprintf(buff, form, s);
+            break;
+          }
+        }
+        default: {  /* also treat cases `pnLlh' */
+          return luaL_error(L, "invalid option to `format'");
+        }
+      }
+      luaL_addlstring(&b, buff, strlen(buff));
+    }
+  }
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+static const luaL_reg strlib[] = {
+  {"len", str_len},
+  {"sub", str_sub},
+  {"lower", str_lower},
+  {"upper", str_upper},
+  {"char", str_char},
+  {"rep", str_rep},
+  {"byte", str_byte},
+  {"format", str_format},
+  {"dump", str_dump},
+  {"find", str_find},
+  {"gfind", gfind},
+  {"gsub", str_gsub},
+  {NULL, NULL}
+};
+
+
+/*
+** Open string library
+*/
+LUALIB_API int luaopen_string (lua_State *L) {
+  luaL_openlib(L, LUA_STRLIBNAME, strlib, 0);
+  return 1;
+}
+

Added: trunk/Util/deditor/lua/lib/ltablib.c
===================================================================
--- trunk/Util/deditor/lua/lib/ltablib.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/ltablib.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,250 @@
+/*
+** $Id: ltablib.c,v 1.21 2003/04/03 13:35:34 roberto Exp $
+** Library for Table Manipulation
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stddef.h>
+
+#define ltablib_c
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#define aux_getn(L,n)	(luaL_checktype(L, n, LUA_TTABLE), luaL_getn(L, n))
+
+
+static int luaB_foreachi (lua_State *L) {
+  int i;
+  int n = aux_getn(L, 1);
+  luaL_checktype(L, 2, LUA_TFUNCTION);
+  for (i=1; i<=n; i++) {
+    lua_pushvalue(L, 2);  /* function */
+    lua_pushnumber(L, (lua_Number)i);  /* 1st argument */
+    lua_rawgeti(L, 1, i);  /* 2nd argument */
+    lua_call(L, 2, 1);
+    if (!lua_isnil(L, -1))
+      return 1;
+    lua_pop(L, 1);  /* remove nil result */
+  }
+  return 0;
+}
+
+
+static int luaB_foreach (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checktype(L, 2, LUA_TFUNCTION);
+  lua_pushnil(L);  /* first key */
+  for (;;) {
+    if (lua_next(L, 1) == 0)
+      return 0;
+    lua_pushvalue(L, 2);  /* function */
+    lua_pushvalue(L, -3);  /* key */
+    lua_pushvalue(L, -3);  /* value */
+    lua_call(L, 2, 1);
+    if (!lua_isnil(L, -1))
+      return 1;
+    lua_pop(L, 2);  /* remove value and result */
+  }
+}
+
+
+static int luaB_getn (lua_State *L) {
+  lua_pushnumber(L, (lua_Number)aux_getn(L, 1));
+  return 1;
+}
+
+
+static int luaB_setn (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_setn(L, 1, luaL_checkint(L, 2));
+  return 0;
+}
+
+
+static int luaB_tinsert (lua_State *L) {
+  int v = lua_gettop(L);  /* number of arguments */
+  int n = aux_getn(L, 1) + 1;
+  int pos;  /* where to insert new element */
+  if (v == 2)  /* called with only 2 arguments */
+    pos = n;  /* insert new element at the end */
+  else {
+    pos = luaL_checkint(L, 2);  /* 2nd argument is the position */
+    if (pos > n) n = pos;  /* `grow' array if necessary */
+    v = 3;  /* function may be called with more than 3 args */
+  }
+  luaL_setn(L, 1, n);  /* new size */
+  while (--n >= pos) {  /* move up elements */
+    lua_rawgeti(L, 1, n);
+    lua_rawseti(L, 1, n+1);  /* t[n+1] = t[n] */
+  }
+  lua_pushvalue(L, v);
+  lua_rawseti(L, 1, pos);  /* t[pos] = v */
+  return 0;
+}
+
+
+static int luaB_tremove (lua_State *L) {
+  int n = aux_getn(L, 1);
+  int pos = luaL_optint(L, 2, n);
+  if (n <= 0) return 0;  /* table is `empty' */
+  luaL_setn(L, 1, n-1);  /* t.n = n-1 */
+  lua_rawgeti(L, 1, pos);  /* result = t[pos] */
+  for ( ;pos<n; pos++) {
+    lua_rawgeti(L, 1, pos+1);
+    lua_rawseti(L, 1, pos);  /* t[pos] = t[pos+1] */
+  }
+  lua_pushnil(L);
+  lua_rawseti(L, 1, n);  /* t[n] = nil */
+  return 1;
+}
+
+
+static int str_concat (lua_State *L) {
+  luaL_Buffer b;
+  size_t lsep;
+  const char *sep = luaL_optlstring(L, 2, "", &lsep);
+  int i = luaL_optint(L, 3, 1);
+  int n = luaL_optint(L, 4, 0);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  if (n == 0) n = luaL_getn(L, 1);
+  luaL_buffinit(L, &b);
+  for (; i <= n; i++) {
+    lua_rawgeti(L, 1, i);
+    luaL_argcheck(L, lua_isstring(L, -1), 1, "table contains non-strings");
+    luaL_addvalue(&b);
+    if (i != n)
+      luaL_addlstring(&b, sep, lsep);
+  }
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+
+/*
+** {======================================================
+** Quicksort
+** (based on `Algorithms in MODULA-3', Robert Sedgewick;
+**  Addison-Wesley, 1993.)
+*/
+
+
+static void set2 (lua_State *L, int i, int j) {
+  lua_rawseti(L, 1, i);
+  lua_rawseti(L, 1, j);
+}
+
+static int sort_comp (lua_State *L, int a, int b) {
+  if (!lua_isnil(L, 2)) {  /* function? */
+    int res;
+    lua_pushvalue(L, 2);
+    lua_pushvalue(L, a-1);  /* -1 to compensate function */
+    lua_pushvalue(L, b-2);  /* -2 to compensate function and `a' */
+    lua_call(L, 2, 1);
+    res = lua_toboolean(L, -1);
+    lua_pop(L, 1);
+    return res;
+  }
+  else  /* a < b? */
+    return lua_lessthan(L, a, b);
+}
+
+static void auxsort (lua_State *L, int l, int u) {
+  while (l < u) {  /* for tail recursion */
+    int i, j;
+    /* sort elements a[l], a[(l+u)/2] and a[u] */
+    lua_rawgeti(L, 1, l);
+    lua_rawgeti(L, 1, u);
+    if (sort_comp(L, -1, -2))  /* a[u] < a[l]? */
+      set2(L, l, u);  /* swap a[l] - a[u] */
+    else
+      lua_pop(L, 2);
+    if (u-l == 1) break;  /* only 2 elements */
+    i = (l+u)/2;
+    lua_rawgeti(L, 1, i);
+    lua_rawgeti(L, 1, l);
+    if (sort_comp(L, -2, -1))  /* a[i]<a[l]? */
+      set2(L, i, l);
+    else {
+      lua_pop(L, 1);  /* remove a[l] */
+      lua_rawgeti(L, 1, u);
+      if (sort_comp(L, -1, -2))  /* a[u]<a[i]? */
+        set2(L, i, u);
+      else
+        lua_pop(L, 2);
+    }
+    if (u-l == 2) break;  /* only 3 elements */
+    lua_rawgeti(L, 1, i);  /* Pivot */
+    lua_pushvalue(L, -1);
+    lua_rawgeti(L, 1, u-1);
+    set2(L, i, u-1);
+    /* a[l] <= P == a[u-1] <= a[u], only need to sort from l+1 to u-2 */
+    i = l; j = u-1;
+    for (;;) {  /* invariant: a[l..i] <= P <= a[j..u] */
+      /* repeat ++i until a[i] >= P */
+      while (lua_rawgeti(L, 1, ++i), sort_comp(L, -1, -2)) {
+        if (i>u) luaL_error(L, "invalid order function for sorting");
+        lua_pop(L, 1);  /* remove a[i] */
+      }
+      /* repeat --j until a[j] <= P */
+      while (lua_rawgeti(L, 1, --j), sort_comp(L, -3, -1)) {
+        if (j<l) luaL_error(L, "invalid order function for sorting");
+        lua_pop(L, 1);  /* remove a[j] */
+      }
+      if (j<i) {
+        lua_pop(L, 3);  /* pop pivot, a[i], a[j] */
+        break;
+      }
+      set2(L, i, j);
+    }
+    lua_rawgeti(L, 1, u-1);
+    lua_rawgeti(L, 1, i);
+    set2(L, u-1, i);  /* swap pivot (a[u-1]) with a[i] */
+    /* a[l..i-1] <= a[i] == P <= a[i+1..u] */
+    /* adjust so that smaller half is in [j..i] and larger one in [l..u] */
+    if (i-l < u-i) {
+      j=l; i=i-1; l=i+2;
+    }
+    else {
+      j=i+1; i=u; u=j-2;
+    }
+    auxsort(L, j, i);  /* call recursively the smaller one */
+  }  /* repeat the routine for the larger one */
+}
+
+static int luaB_sort (lua_State *L) {
+  int n = aux_getn(L, 1);
+  luaL_checkstack(L, 40, "");  /* assume array is smaller than 2^40 */
+  if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */
+    luaL_checktype(L, 2, LUA_TFUNCTION);
+  lua_settop(L, 2);  /* make sure there is two arguments */
+  auxsort(L, 1, n);
+  return 0;
+}
+
+/* }====================================================== */
+
+
+static const luaL_reg tab_funcs[] = {
+  {"concat", str_concat},
+  {"foreach", luaB_foreach},
+  {"foreachi", luaB_foreachi},
+  {"getn", luaB_getn},
+  {"setn", luaB_setn},
+  {"sort", luaB_sort},
+  {"insert", luaB_tinsert},
+  {"remove", luaB_tremove},
+  {NULL, NULL}
+};
+
+
+LUALIB_API int luaopen_table (lua_State *L) {
+  luaL_openlib(L, LUA_TABLIBNAME, tab_funcs, 0);
+  return 1;
+}
+

Added: trunk/Util/deditor/lua/llex.c
===================================================================
--- trunk/Util/deditor/lua/llex.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/llex.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,417 @@
+/*
+** $Id: llex.c,v 1.119 2003/03/24 12:39:34 roberto Exp $
+** Lexical Analyzer
+** See Copyright Notice in lua.h
+*/
+
+
+#include <ctype.h>
+#include <string.h>
+
+#define llex_c
+
+#include "lua.h"
+
+#include "ldo.h"
+#include "llex.h"
+#include "lobject.h"
+#include "lparser.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "lzio.h"
+
+
+
+#define next(LS) (LS->current = zgetc(LS->z))
+
+
+
+/* ORDER RESERVED */
+static const char *const token2string [] = {
+    "and", "break", "do", "else", "elseif",
+    "end", "false", "for", "function", "if",
+    "in", "local", "nil", "not", "or", "repeat",
+    "return", "then", "true", "until", "while", "*name",
+    "..", "...", "==", ">=", "<=", "~=",
+    "*number", "*string", "<eof>"
+};
+
+
+void luaX_init (lua_State *L) {
+  int i;
+  for (i=0; i<NUM_RESERVED; i++) {
+    TString *ts = luaS_new(L, token2string[i]);
+    luaS_fix(ts);  /* reserved words are never collected */
+    lua_assert(strlen(token2string[i])+1 <= TOKEN_LEN);
+    ts->tsv.reserved = cast(lu_byte, i+1);  /* reserved word */
+  }
+}
+
+
+#define MAXSRC          80
+
+
+void luaX_checklimit (LexState *ls, int val, int limit, const char *msg) {
+  if (val > limit) {
+    msg = luaO_pushfstring(ls->L, "too many %s (limit=%d)", msg, limit);
+    luaX_syntaxerror(ls, msg);
+  }
+}
+
+
+void luaX_errorline (LexState *ls, const char *s, const char *token, int line) {
+  lua_State *L = ls->L;
+  char buff[MAXSRC];
+  luaO_chunkid(buff, getstr(ls->source), MAXSRC);
+  luaO_pushfstring(L, "%s:%d: %s near `%s'", buff, line, s, token); 
+  luaD_throw(L, LUA_ERRSYNTAX);
+}
+
+
+static void luaX_error (LexState *ls, const char *s, const char *token) {
+  luaX_errorline(ls, s, token, ls->linenumber);
+}
+
+
+void luaX_syntaxerror (LexState *ls, const char *msg) {
+  const char *lasttoken;
+  switch (ls->t.token) {
+    case TK_NAME:
+      lasttoken = getstr(ls->t.seminfo.ts);
+      break;
+    case TK_STRING:
+    case TK_NUMBER:
+      lasttoken = luaZ_buffer(ls->buff);
+      break;
+    default:
+      lasttoken = luaX_token2str(ls, ls->t.token);
+      break;
+  }
+  luaX_error(ls, msg, lasttoken);
+}
+
+
+const char *luaX_token2str (LexState *ls, int token) {
+  if (token < FIRST_RESERVED) {
+    lua_assert(token == (unsigned char)token);
+    return luaO_pushfstring(ls->L, "%c", token);
+  }
+  else
+    return token2string[token-FIRST_RESERVED];
+}
+
+
+static void luaX_lexerror (LexState *ls, const char *s, int token) {
+  if (token == TK_EOS)
+    luaX_error(ls, s, luaX_token2str(ls, token));
+  else
+    luaX_error(ls, s, luaZ_buffer(ls->buff));
+}
+
+
+static void inclinenumber (LexState *LS) {
+  next(LS);  /* skip `\n' */
+  ++LS->linenumber;
+  luaX_checklimit(LS, LS->linenumber, MAX_INT, "lines in a chunk");
+}
+
+
+void luaX_setinput (lua_State *L, LexState *LS, ZIO *z, TString *source) {
+  LS->L = L;
+  LS->lookahead.token = TK_EOS;  /* no look-ahead token */
+  LS->z = z;
+  LS->fs = NULL;
+  LS->linenumber = 1;
+  LS->lastline = 1;
+  LS->source = source;
+  next(LS);  /* read first char */
+  if (LS->current == '#') {
+    do {  /* skip first line */
+      next(LS);
+    } while (LS->current != '\n' && LS->current != EOZ);
+  }
+}
+
+
+
+/*
+** =======================================================
+** LEXICAL ANALYZER
+** =======================================================
+*/
+
+
+/* use buffer to store names, literal strings and numbers */
+
+/* extra space to allocate when growing buffer */
+#define EXTRABUFF	32
+
+/* maximum number of chars that can be read without checking buffer size */
+#define MAXNOCHECK	5
+
+#define checkbuffer(LS, len)	\
+    if (((len)+MAXNOCHECK)*sizeof(char) > luaZ_sizebuffer((LS)->buff)) \
+      luaZ_openspace((LS)->L, (LS)->buff, (len)+EXTRABUFF)
+
+#define save(LS, c, l) \
+	(luaZ_buffer((LS)->buff)[l++] = cast(char, c))
+#define save_and_next(LS, l)  (save(LS, LS->current, l), next(LS))
+
+
+static size_t readname (LexState *LS) {
+  size_t l = 0;
+  checkbuffer(LS, l);
+  do {
+    checkbuffer(LS, l);
+    save_and_next(LS, l);
+  } while (isalnum(LS->current) || LS->current == '_');
+  save(LS, '\0', l);
+  return l-1;
+}
+
+
+/* LUA_NUMBER */
+static void read_numeral (LexState *LS, int comma, SemInfo *seminfo) {
+  size_t l = 0;
+  checkbuffer(LS, l);
+  if (comma) save(LS, '.', l);
+  while (isdigit(LS->current)) {
+    checkbuffer(LS, l);
+    save_and_next(LS, l);
+  }
+  if (LS->current == '.') {
+    save_and_next(LS, l);
+    if (LS->current == '.') {
+      save_and_next(LS, l);
+      save(LS, '\0', l);
+      luaX_lexerror(LS,
+                 "ambiguous syntax (decimal point x string concatenation)",
+                 TK_NUMBER);
+    }
+  }
+  while (isdigit(LS->current)) {
+    checkbuffer(LS, l);
+    save_and_next(LS, l);
+  }
+  if (LS->current == 'e' || LS->current == 'E') {
+    save_and_next(LS, l);  /* read `E' */
+    if (LS->current == '+' || LS->current == '-')
+      save_and_next(LS, l);  /* optional exponent sign */
+    while (isdigit(LS->current)) {
+      checkbuffer(LS, l);
+      save_and_next(LS, l);
+    }
+  }
+  save(LS, '\0', l);
+  if (!luaO_str2d(luaZ_buffer(LS->buff), &seminfo->r))
+    luaX_lexerror(LS, "malformed number", TK_NUMBER);
+}
+
+
+static void read_long_string (LexState *LS, SemInfo *seminfo) {
+  int cont = 0;
+  size_t l = 0;
+  checkbuffer(LS, l);
+  save(LS, '[', l);  /* save first `[' */
+  save_and_next(LS, l);  /* pass the second `[' */
+  if (LS->current == '\n')  /* string starts with a newline? */
+    inclinenumber(LS);  /* skip it */
+  for (;;) {
+    checkbuffer(LS, l);
+    switch (LS->current) {
+      case EOZ:
+        save(LS, '\0', l);
+        luaX_lexerror(LS, (seminfo) ? "unfinished long string" :
+                                   "unfinished long comment", TK_EOS);
+        break;  /* to avoid warnings */
+      case '[':
+        save_and_next(LS, l);
+        if (LS->current == '[') {
+          cont++;
+          save_and_next(LS, l);
+        }
+        continue;
+      case ']':
+        save_and_next(LS, l);
+        if (LS->current == ']') {
+          if (cont == 0) goto endloop;
+          cont--;
+          save_and_next(LS, l);
+        }
+        continue;
+      case '\n':
+        save(LS, '\n', l);
+        inclinenumber(LS);
+        if (!seminfo) l = 0;  /* reset buffer to avoid wasting space */
+        continue;
+      default:
+        save_and_next(LS, l);
+    }
+  } endloop:
+  save_and_next(LS, l);  /* skip the second `]' */
+  save(LS, '\0', l);
+  if (seminfo)
+    seminfo->ts = luaS_newlstr(LS->L, luaZ_buffer(LS->buff) + 2, l - 5);
+}
+
+
+static void read_string (LexState *LS, int del, SemInfo *seminfo) {
+  size_t l = 0;
+  checkbuffer(LS, l);
+  save_and_next(LS, l);
+  while (LS->current != del) {
+    checkbuffer(LS, l);
+    switch (LS->current) {
+      case EOZ:
+        save(LS, '\0', l);
+        luaX_lexerror(LS, "unfinished string", TK_EOS);
+        break;  /* to avoid warnings */
+      case '\n':
+        save(LS, '\0', l);
+        luaX_lexerror(LS, "unfinished string", TK_STRING);
+        break;  /* to avoid warnings */
+      case '\\':
+        next(LS);  /* do not save the `\' */
+        switch (LS->current) {
+          case 'a': save(LS, '\a', l); next(LS); break;
+          case 'b': save(LS, '\b', l); next(LS); break;
+          case 'f': save(LS, '\f', l); next(LS); break;
+          case 'n': save(LS, '\n', l); next(LS); break;
+          case 'r': save(LS, '\r', l); next(LS); break;
+          case 't': save(LS, '\t', l); next(LS); break;
+          case 'v': save(LS, '\v', l); next(LS); break;
+          case '\n': save(LS, '\n', l); inclinenumber(LS); break;
+          case EOZ: break;  /* will raise an error next loop */
+          default: {
+            if (!isdigit(LS->current))
+              save_and_next(LS, l);  /* handles \\, \", \', and \? */
+            else {  /* \xxx */
+              int c = 0;
+              int i = 0;
+              do {
+                c = 10*c + (LS->current-'0');
+                next(LS);
+              } while (++i<3 && isdigit(LS->current));
+              if (c > UCHAR_MAX) {
+                save(LS, '\0', l);
+                luaX_lexerror(LS, "escape sequence too large", TK_STRING);
+              }
+              save(LS, c, l);
+            }
+          }
+        }
+        break;
+      default:
+        save_and_next(LS, l);
+    }
+  }
+  save_and_next(LS, l);  /* skip delimiter */
+  save(LS, '\0', l);
+  seminfo->ts = luaS_newlstr(LS->L, luaZ_buffer(LS->buff) + 1, l - 3);
+}
+
+
+int luaX_lex (LexState *LS, SemInfo *seminfo) {
+  for (;;) {
+    switch (LS->current) {
+
+      case '\n': {
+        inclinenumber(LS);
+        continue;
+      }
+      case '-': {
+        next(LS);
+        if (LS->current != '-') return '-';
+        /* else is a comment */
+        next(LS);
+        if (LS->current == '[' && (next(LS), LS->current == '['))
+          read_long_string(LS, NULL);  /* long comment */
+        else  /* short comment */
+          while (LS->current != '\n' && LS->current != EOZ)
+            next(LS);
+        continue;
+      }
+      case '[': {
+        next(LS);
+        if (LS->current != '[') return '[';
+        else {
+          read_long_string(LS, seminfo);
+          return TK_STRING;
+        }
+      }
+      case '=': {
+        next(LS);
+        if (LS->current != '=') return '=';
+        else { next(LS); return TK_EQ; }
+      }
+      case '<': {
+        next(LS);
+        if (LS->current != '=') return '<';
+        else { next(LS); return TK_LE; }
+      }
+      case '>': {
+        next(LS);
+        if (LS->current != '=') return '>';
+        else { next(LS); return TK_GE; }
+      }
+      case '~': {
+        next(LS);
+        if (LS->current != '=') return '~';
+        else { next(LS); return TK_NE; }
+      }
+      case '"':
+      case '\'': {
+        read_string(LS, LS->current, seminfo);
+        return TK_STRING;
+      }
+      case '.': {
+        next(LS);
+        if (LS->current == '.') {
+          next(LS);
+          if (LS->current == '.') {
+            next(LS);
+            return TK_DOTS;   /* ... */
+          }
+          else return TK_CONCAT;   /* .. */
+        }
+        else if (!isdigit(LS->current)) return '.';
+        else {
+          read_numeral(LS, 1, seminfo);
+          return TK_NUMBER;
+        }
+      }
+      case EOZ: {
+        return TK_EOS;
+      }
+      default: {
+        if (isspace(LS->current)) {
+          next(LS);
+          continue;
+        }
+        else if (isdigit(LS->current)) {
+          read_numeral(LS, 0, seminfo);
+          return TK_NUMBER;
+        }
+        else if (isalpha(LS->current) || LS->current == '_') {
+          /* identifier or reserved word */
+          size_t l = readname(LS);
+          TString *ts = luaS_newlstr(LS->L, luaZ_buffer(LS->buff), l);
+          if (ts->tsv.reserved > 0)  /* reserved word? */
+            return ts->tsv.reserved - 1 + FIRST_RESERVED;
+          seminfo->ts = ts;
+          return TK_NAME;
+        }
+        else {
+          int c = LS->current;
+          if (iscntrl(c))
+            luaX_error(LS, "invalid control char",
+                           luaO_pushfstring(LS->L, "char(%d)", c));
+          next(LS);
+          return c;  /* single-char tokens (+ - / ...) */
+        }
+      }
+    }
+  }
+}
+
+#undef next

Added: trunk/Util/deditor/lua/llex.h
===================================================================
--- trunk/Util/deditor/lua/llex.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/llex.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,75 @@
+/*
+** $Id: llex.h,v 1.47 2003/02/28 17:19:47 roberto Exp $
+** Lexical Analyzer
+** See Copyright Notice in lua.h
+*/
+
+#ifndef llex_h
+#define llex_h
+
+#include "lobject.h"
+#include "lzio.h"
+
+
+#define FIRST_RESERVED	257
+
+/* maximum length of a reserved word */
+#define TOKEN_LEN	(sizeof("function")/sizeof(char))
+
+
+/*
+* WARNING: if you change the order of this enumeration,
+* grep "ORDER RESERVED"
+*/
+enum RESERVED {
+  /* terminal symbols denoted by reserved words */
+  TK_AND = FIRST_RESERVED, TK_BREAK,
+  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,
+  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,
+  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,
+  /* other terminal symbols */
+  TK_NAME, TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,
+  TK_STRING, TK_EOS
+};
+
+/* number of reserved words */
+#define NUM_RESERVED	(cast(int, TK_WHILE-FIRST_RESERVED+1))
+
+
+typedef union {
+  lua_Number r;
+  TString *ts;
+} SemInfo;  /* semantics information */
+
+
+typedef struct Token {
+  int token;
+  SemInfo seminfo;
+} Token;
+
+
+typedef struct LexState {
+  int current;  /* current character (charint) */
+  int linenumber;  /* input line counter */
+  int lastline;  /* line of last token `consumed' */
+  Token t;  /* current token */
+  Token lookahead;  /* look ahead token */
+  struct FuncState *fs;  /* `FuncState' is private to the parser */
+  struct lua_State *L;
+  ZIO *z;  /* input stream */
+  Mbuffer *buff;  /* buffer for tokens */
+  TString *source;  /* current source name */
+  int nestlevel;  /* level of nested non-terminals */
+} LexState;
+
+
+void luaX_init (lua_State *L);
+void luaX_setinput (lua_State *L, LexState *LS, ZIO *z, TString *source);
+int luaX_lex (LexState *LS, SemInfo *seminfo);
+void luaX_checklimit (LexState *ls, int val, int limit, const char *msg);
+void luaX_syntaxerror (LexState *ls, const char *s);
+void luaX_errorline (LexState *ls, const char *s, const char *token, int line);
+const char *luaX_token2str (LexState *ls, int token);
+
+
+#endif

Added: trunk/Util/deditor/lua/llimits.h
===================================================================
--- trunk/Util/deditor/lua/llimits.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/llimits.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,185 @@
+/*
+** $Id: llimits.h,v 1.52 2003/02/20 19:33:23 roberto Exp $
+** Limits, basic types, and some other `installation-dependent' definitions
+** See Copyright Notice in lua.h
+*/
+
+#ifndef llimits_h
+#define llimits_h
+
+
+#include <limits.h>
+#include <stddef.h>
+
+
+#include "lua.h"
+
+
+/*
+** try to find number of bits in an integer
+*/
+#ifndef BITS_INT
+/* avoid overflows in comparison */
+#if INT_MAX-20 < 32760
+#define	BITS_INT	16
+#else
+#if INT_MAX > 2147483640L
+/* machine has at least 32 bits */
+#define BITS_INT	32
+#else
+#error "you must define BITS_INT with number of bits in an integer"
+#endif
+#endif
+#endif
+
+
+/*
+** the following types define integer types for values that may not
+** fit in a `small int' (16 bits), but may waste space in a
+** `large long' (64 bits). The current definitions should work in
+** any machine, but may not be optimal.
+*/
+
+/* an unsigned integer to hold hash values */
+typedef unsigned int lu_hash;
+/* its signed equivalent */
+typedef int ls_hash;
+
+/* an unsigned integer big enough to count the total memory used by Lua; */
+/* it should be at least as large as size_t */
+typedef unsigned long lu_mem;
+
+#define MAX_LUMEM	ULONG_MAX
+
+
+/* an integer big enough to count the number of strings in use */
+typedef long ls_nstr;
+
+/* chars used as small naturals (so that `char' is reserved for characters) */
+typedef unsigned char lu_byte;
+
+
+#define MAX_SIZET	((size_t)(~(size_t)0)-2)
+
+
+#define MAX_INT (INT_MAX-2)  /* maximum value of an int (-2 for safety) */
+
+/*
+** conversion of pointer to integer
+** this is for hashing only; there is no problem if the integer
+** cannot hold the whole pointer value
+*/
+#define IntPoint(p)  ((lu_hash)(p))
+
+
+
+/* type to ensure maximum alignment */
+#ifndef LUSER_ALIGNMENT_T
+typedef union { double u; void *s; long l; } L_Umaxalign;
+#else
+typedef LUSER_ALIGNMENT_T L_Umaxalign;
+#endif
+
+
+/* result of `usual argument conversion' over lua_Number */
+#ifndef LUA_UACNUMBER
+typedef double l_uacNumber;
+#else
+typedef LUA_UACNUMBER l_uacNumber;
+#endif
+
+
+#ifndef lua_assert
+#define lua_assert(c)		/* empty */
+#endif
+
+
+#ifndef check_exp
+#define check_exp(c,e)	(e)
+#endif
+
+
+#ifndef UNUSED
+#define UNUSED(x)	((void)(x))	/* to avoid warnings */
+#endif
+
+
+#ifndef cast
+#define cast(t, exp)	((t)(exp))
+#endif
+
+
+
+/*
+** type for virtual-machine instructions
+** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h)
+*/
+typedef unsigned long Instruction;
+
+
+/* maximum depth for calls (unsigned short) */
+#ifndef LUA_MAXCALLS
+#define LUA_MAXCALLS        4096
+#endif
+
+
+/*
+** maximum depth for C calls (unsigned short): Not too big, or may
+** overflow the C stack...
+*/
+
+#ifndef LUA_MAXCCALLS
+#define LUA_MAXCCALLS        200
+#endif
+
+
+/* maximum size for the C stack */
+#ifndef LUA_MAXCSTACK
+#define LUA_MAXCSTACK        2048
+#endif
+
+
+/* maximum stack for a Lua function */
+#define MAXSTACK	250
+
+
+/* maximum number of variables declared in a function */
+#ifndef MAXVARS
+#define MAXVARS 200           /* arbitrary limit (<MAXSTACK) */
+#endif
+
+
+/* maximum number of upvalues per function */
+#ifndef MAXUPVALUES
+#define MAXUPVALUES	32
+#endif
+
+
+/* maximum number of parameters in a function */
+#ifndef MAXPARAMS
+#define MAXPARAMS 100           /* arbitrary limit (<MAXLOCALS) */
+#endif
+
+
+/* minimum size for the string table (must be power of 2) */
+#ifndef MINSTRTABSIZE
+#define MINSTRTABSIZE	32
+#endif
+
+
+/* minimum size for string buffer */
+#ifndef LUA_MINBUFFER
+#define LUA_MINBUFFER	32
+#endif
+
+
+/*
+** maximum number of syntactical nested non-terminals: Not too big,
+** or may overflow the C stack...
+*/
+#ifndef LUA_MAXPARSERLEVEL
+#define LUA_MAXPARSERLEVEL	200
+#endif
+
+
+#endif

Added: trunk/Util/deditor/lua/lmem.c
===================================================================
--- trunk/Util/deditor/lua/lmem.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lmem.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,91 @@
+/*
+** $Id: lmem.c,v 1.61 2002/12/04 17:38:31 roberto Exp $
+** Interface to Memory Manager
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+
+#define lmem_c
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+
+
+
+/*
+** definition for realloc function. It must assure that l_realloc(NULL,
+** 0, x) allocates a new block (ANSI C assures that). (`os' is the old
+** block size; some allocators may use that.)
+*/
+#ifndef l_realloc
+#define l_realloc(b,os,s)	realloc(b,s)
+#endif
+
+/*
+** definition for free function. (`os' is the old block size; some
+** allocators may use that.)
+*/
+#ifndef l_free
+#define l_free(b,os)	free(b)
+#endif
+
+
+#define MINSIZEARRAY	4
+
+
+void *luaM_growaux (lua_State *L, void *block, int *size, int size_elems,
+                    int limit, const char *errormsg) {
+  void *newblock;
+  int newsize = (*size)*2;
+  if (newsize < MINSIZEARRAY)
+    newsize = MINSIZEARRAY;  /* minimum size */
+  else if (*size >= limit/2) {  /* cannot double it? */
+    if (*size < limit - MINSIZEARRAY)  /* try something smaller... */
+      newsize = limit;  /* still have at least MINSIZEARRAY free places */
+    else luaG_runerror(L, errormsg);
+  }
+  newblock = luaM_realloc(L, block,
+                          cast(lu_mem, *size)*cast(lu_mem, size_elems),
+                          cast(lu_mem, newsize)*cast(lu_mem, size_elems));
+  *size = newsize;  /* update only when everything else is OK */
+  return newblock;
+}
+
+
+/*
+** generic allocation routine.
+*/
+void *luaM_realloc (lua_State *L, void *block, lu_mem oldsize, lu_mem size) {
+  lua_assert((oldsize == 0) == (block == NULL));
+  if (size == 0) {
+    if (block != NULL) {
+      l_free(block, oldsize);
+      block = NULL;
+    }
+    else return NULL;  /* avoid `nblocks' computations when oldsize==size==0 */
+  }
+  else if (size >= MAX_SIZET)
+    luaG_runerror(L, "memory allocation error: block too big");
+  else {
+    block = l_realloc(block, oldsize, size);
+    if (block == NULL) {
+      if (L)
+        luaD_throw(L, LUA_ERRMEM);
+      else return NULL;  /* error before creating state! */
+    }
+  }
+  if (L) {
+    lua_assert(G(L) != NULL && G(L)->nblocks > 0);
+    G(L)->nblocks -= oldsize;
+    G(L)->nblocks += size;
+  }
+  return block;
+}
+

Added: trunk/Util/deditor/lua/lmem.h
===================================================================
--- trunk/Util/deditor/lua/lmem.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lmem.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,44 @@
+/*
+** $Id: lmem.h,v 1.26 2002/05/01 20:40:42 roberto Exp $
+** Interface to Memory Manager
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lmem_h
+#define lmem_h
+
+
+#include <stddef.h>
+
+#include "llimits.h"
+#include "lua.h"
+
+#define MEMERRMSG	"not enough memory"
+
+
+void *luaM_realloc (lua_State *L, void *oldblock, lu_mem oldsize, lu_mem size);
+
+void *luaM_growaux (lua_State *L, void *block, int *size, int size_elem,
+                    int limit, const char *errormsg);
+
+#define luaM_free(L, b, s)	luaM_realloc(L, (b), (s), 0)
+#define luaM_freelem(L, b)	luaM_realloc(L, (b), sizeof(*(b)), 0)
+#define luaM_freearray(L, b, n, t)	luaM_realloc(L, (b), \
+                                      cast(lu_mem, n)*cast(lu_mem, sizeof(t)), 0)
+
+#define luaM_malloc(L, t)	luaM_realloc(L, NULL, 0, (t))
+#define luaM_new(L, t)          cast(t *, luaM_malloc(L, sizeof(t)))
+#define luaM_newvector(L, n,t)  cast(t *, luaM_malloc(L, \
+                                         cast(lu_mem, n)*cast(lu_mem, sizeof(t))))
+
+#define luaM_growvector(L,v,nelems,size,t,limit,e) \
+          if (((nelems)+1) > (size)) \
+            ((v)=cast(t *, luaM_growaux(L,v,&(size),sizeof(t),limit,e)))
+
+#define luaM_reallocvector(L, v,oldn,n,t) \
+   ((v)=cast(t *, luaM_realloc(L, v,cast(lu_mem, oldn)*cast(lu_mem, sizeof(t)), \
+                                    cast(lu_mem, n)*cast(lu_mem, sizeof(t)))))
+
+
+#endif
+

Added: trunk/Util/deditor/lua/lobject.c
===================================================================
--- trunk/Util/deditor/lua/lobject.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lobject.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,195 @@
+/*
+** $Id: lobject.c,v 1.97 2003/04/03 13:35:34 roberto Exp $
+** Some generic functions over Lua objects
+** See Copyright Notice in lua.h
+*/
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lobject_c
+
+#include "lua.h"
+
+#include "ldo.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "lvm.h"
+
+
+/* function to convert a string to a lua_Number */
+#ifndef lua_str2number
+#define lua_str2number(s,p)     strtod((s), (p))
+#endif
+
+
+const TObject luaO_nilobject = {LUA_TNIL, {NULL}};
+
+
+/*
+** converts an integer to a "floating point byte", represented as
+** (mmmmmxxx), where the real value is (xxx) * 2^(mmmmm)
+*/
+int luaO_int2fb (unsigned int x) {
+  int m = 0;  /* mantissa */
+  while (x >= (1<<3)) {
+    x = (x+1) >> 1;
+    m++;
+  }
+  return (m << 3) | cast(int, x);
+}
+
+
+int luaO_log2 (unsigned int x) {
+  static const lu_byte log_8[255] = {
+    0,
+    1,1,
+    2,2,2,2,
+    3,3,3,3,3,3,3,3,
+    4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
+  };
+  if (x >= 0x00010000) {
+    if (x >= 0x01000000) return log_8[((x>>24) & 0xff) - 1]+24;
+    else return log_8[((x>>16) & 0xff) - 1]+16;
+  }
+  else {
+    if (x >= 0x00000100) return log_8[((x>>8) & 0xff) - 1]+8;
+    else if (x) return log_8[(x & 0xff) - 1];
+    return -1;  /* special `log' for 0 */
+  }
+}
+
+
+int luaO_rawequalObj (const TObject *t1, const TObject *t2) {
+  if (ttype(t1) != ttype(t2)) return 0;
+  else switch (ttype(t1)) {
+    case LUA_TNIL:
+      return 1;
+    case LUA_TNUMBER:
+      return nvalue(t1) == nvalue(t2);
+    case LUA_TBOOLEAN:
+      return bvalue(t1) == bvalue(t2);  /* boolean true must be 1 !! */
+    case LUA_TLIGHTUSERDATA:
+      return pvalue(t1) == pvalue(t2);
+    default:
+      lua_assert(iscollectable(t1));
+      return gcvalue(t1) == gcvalue(t2);
+  }
+}
+
+
+int luaO_str2d (const char *s, lua_Number *result) {
+  char *endptr;
+  lua_Number res = lua_str2number(s, &endptr);
+  if (endptr == s) return 0;  /* no conversion */
+  while (isspace((unsigned char)(*endptr))) endptr++;
+  if (*endptr != '\0') return 0;  /* invalid trailing characters? */
+  *result = res;
+  return 1;
+}
+
+
+
+static void pushstr (lua_State *L, const char *str) {
+  setsvalue2s(L->top, luaS_new(L, str));
+  incr_top(L);
+}
+
+
+/* this function handles only `%d', `%c', %f, and `%s' formats */
+const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {
+  int n = 1;
+  pushstr(L, "");
+  for (;;) {
+    const char *e = strchr(fmt, '%');
+    if (e == NULL) break;
+    setsvalue2s(L->top, luaS_newlstr(L, fmt, e-fmt));
+    incr_top(L);
+    switch (*(e+1)) {
+      case 's':
+        pushstr(L, va_arg(argp, char *));
+        break;
+      case 'c': {
+        char buff[2];
+        buff[0] = cast(char, va_arg(argp, int));
+        buff[1] = '\0';
+        pushstr(L, buff);
+        break;
+      }
+      case 'd':
+        setnvalue(L->top, cast(lua_Number, va_arg(argp, int)));
+        incr_top(L);
+        break;
+      case 'f':
+        setnvalue(L->top, cast(lua_Number, va_arg(argp, l_uacNumber)));
+        incr_top(L);
+        break;
+      case '%':
+        pushstr(L, "%");
+        break;
+      default: lua_assert(0);
+    }
+    n += 2;
+    fmt = e+2;
+  }
+  pushstr(L, fmt);
+  luaV_concat(L, n+1, L->top - L->base - 1);
+  L->top -= n;
+  return svalue(L->top - 1);
+}
+
+
+const char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {
+  const char *msg;
+  va_list argp;
+  va_start(argp, fmt);
+  msg = luaO_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  return msg;
+}
+
+
+void luaO_chunkid (char *out, const char *source, int bufflen) {
+  if (*source == '=') {
+    strncpy(out, source+1, bufflen);  /* remove first char */
+    out[bufflen-1] = '\0';  /* ensures null termination */
+  }
+  else {  /* out = "source", or "...source" */
+    if (*source == '@') {
+      int l;
+      source++;  /* skip the `@' */
+      bufflen -= sizeof(" `...' ");
+      l = strlen(source);
+      strcpy(out, "");
+      if (l>bufflen) {
+        source += (l-bufflen);  /* get last part of file name */
+        strcat(out, "...");
+      }
+      strcat(out, source);
+    }
+    else {  /* out = [string "string"] */
+      int len = strcspn(source, "\n");  /* stop at first newline */
+      bufflen -= sizeof(" [string \"...\"] ");
+      if (len > bufflen) len = bufflen;
+      strcpy(out, "[string \"");
+      if (source[len] != '\0') {  /* must truncate? */
+        strncat(out, source, len);
+        strcat(out, "...");
+      }
+      else
+        strcat(out, source);
+      strcat(out, "\"]");
+    }
+  }
+}

Added: trunk/Util/deditor/lua/lobject.h
===================================================================
--- trunk/Util/deditor/lua/lobject.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lobject.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,336 @@
+/*
+** $Id: lobject.h,v 1.159 2003/03/18 12:50:04 roberto Exp $
+** Type definitions for Lua objects
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lobject_h
+#define lobject_h
+
+
+#include "llimits.h"
+#include "lua.h"
+
+
+/* tags for values visible from Lua */
+#define NUM_TAGS	LUA_TTHREAD
+
+
+/*
+** Extra tags for non-values
+*/
+#define LUA_TPROTO	(NUM_TAGS+1)
+#define LUA_TUPVAL	(NUM_TAGS+2)
+
+
+/*
+** Union of all collectable objects
+*/
+typedef union GCObject GCObject;
+
+
+/*
+** Common Header for all collectable objects (in macro form, to be
+** included in other objects)
+*/
+#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked
+
+
+/*
+** Common header in struct form
+*/
+typedef struct GCheader {
+  CommonHeader;
+} GCheader;
+
+
+
+
+/*
+** Union of all Lua values
+*/
+typedef union {
+  GCObject *gc;
+  void *p;
+  lua_Number n;
+  int b;
+} Value;
+
+
+/*
+** Lua values (or `tagged objects')
+*/
+typedef struct lua_TObject {
+  int tt;
+  Value value;
+} TObject;
+
+
+/* Macros to test type */
+#define ttisnil(o)	(ttype(o) == LUA_TNIL)
+#define ttisnumber(o)	(ttype(o) == LUA_TNUMBER)
+#define ttisstring(o)	(ttype(o) == LUA_TSTRING)
+#define ttistable(o)	(ttype(o) == LUA_TTABLE)
+#define ttisfunction(o)	(ttype(o) == LUA_TFUNCTION)
+#define ttisboolean(o)	(ttype(o) == LUA_TBOOLEAN)
+#define ttisuserdata(o)	(ttype(o) == LUA_TUSERDATA)
+#define ttisthread(o)	(ttype(o) == LUA_TTHREAD)
+#define ttislightuserdata(o)	(ttype(o) == LUA_TLIGHTUSERDATA)
+
+/* Macros to access values */
+#define ttype(o)	((o)->tt)
+#define gcvalue(o)	check_exp(iscollectable(o), (o)->value.gc)
+#define pvalue(o)	check_exp(ttislightuserdata(o), (o)->value.p)
+#define nvalue(o)	check_exp(ttisnumber(o), (o)->value.n)
+#define tsvalue(o)	check_exp(ttisstring(o), &(o)->value.gc->ts)
+#define uvalue(o)	check_exp(ttisuserdata(o), &(o)->value.gc->u)
+#define clvalue(o)	check_exp(ttisfunction(o), &(o)->value.gc->cl)
+#define hvalue(o)	check_exp(ttistable(o), &(o)->value.gc->h)
+#define bvalue(o)	check_exp(ttisboolean(o), (o)->value.b)
+#define thvalue(o)	check_exp(ttisthread(o), &(o)->value.gc->th)
+
+#define l_isfalse(o)	(ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))
+
+/* Macros to set values */
+#define setnvalue(obj,x) \
+  { TObject *i_o=(obj); i_o->tt=LUA_TNUMBER; i_o->value.n=(x); }
+
+#define chgnvalue(obj,x) \
+	check_exp(ttype(obj)==LUA_TNUMBER, (obj)->value.n=(x))
+
+#define setpvalue(obj,x) \
+  { TObject *i_o=(obj); i_o->tt=LUA_TLIGHTUSERDATA; i_o->value.p=(x); }
+
+#define setbvalue(obj,x) \
+  { TObject *i_o=(obj); i_o->tt=LUA_TBOOLEAN; i_o->value.b=(x); }
+
+#define setsvalue(obj,x) \
+  { TObject *i_o=(obj); i_o->tt=LUA_TSTRING; \
+    i_o->value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o->value.gc->gch.tt == LUA_TSTRING); }
+
+#define setuvalue(obj,x) \
+  { TObject *i_o=(obj); i_o->tt=LUA_TUSERDATA; \
+    i_o->value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o->value.gc->gch.tt == LUA_TUSERDATA); }
+
+#define setthvalue(obj,x) \
+  { TObject *i_o=(obj); i_o->tt=LUA_TTHREAD; \
+    i_o->value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o->value.gc->gch.tt == LUA_TTHREAD); }
+
+#define setclvalue(obj,x) \
+  { TObject *i_o=(obj); i_o->tt=LUA_TFUNCTION; \
+    i_o->value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o->value.gc->gch.tt == LUA_TFUNCTION); }
+
+#define sethvalue(obj,x) \
+  { TObject *i_o=(obj); i_o->tt=LUA_TTABLE; \
+    i_o->value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o->value.gc->gch.tt == LUA_TTABLE); }
+
+#define setnilvalue(obj) ((obj)->tt=LUA_TNIL)
+
+
+
+/*
+** for internal debug only
+*/
+#define checkconsistency(obj) \
+  lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)->value.gc->gch.tt))
+
+
+#define setobj(obj1,obj2) \
+  { const TObject *o2=(obj2); TObject *o1=(obj1); \
+    checkconsistency(o2); \
+    o1->tt=o2->tt; o1->value = o2->value; }
+
+
+/*
+** different types of sets, according to destination
+*/
+
+/* from stack to (same) stack */
+#define setobjs2s	setobj
+/* to stack (not from same stack) */
+#define setobj2s	setobj
+#define setsvalue2s	setsvalue
+/* from table to same table */
+#define setobjt2t	setobj
+/* to table */
+#define setobj2t	setobj
+/* to new object */
+#define setobj2n	setobj
+#define setsvalue2n	setsvalue
+
+#define setttype(obj, tt) (ttype(obj) = (tt))
+
+
+#define iscollectable(o)	(ttype(o) >= LUA_TSTRING)
+
+
+
+typedef TObject *StkId;  /* index to stack elements */
+
+
+/*
+** String headers for string table
+*/
+typedef union TString {
+  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
+  struct {
+    CommonHeader;
+    lu_byte reserved;
+    lu_hash hash;
+    size_t len;
+  } tsv;
+} TString;
+
+
+#define getstr(ts)	cast(const char *, (ts) + 1)
+#define svalue(o)       getstr(tsvalue(o))
+
+
+
+typedef union Udata {
+  L_Umaxalign dummy;  /* ensures maximum alignment for `local' udata */
+  struct {
+    CommonHeader;
+    struct Table *metatable;
+    size_t len;
+  } uv;
+} Udata;
+
+
+
+
+/*
+** Function Prototypes
+*/
+typedef struct Proto {
+  CommonHeader;
+  TObject *k;  /* constants used by the function */
+  Instruction *code;
+  struct Proto **p;  /* functions defined inside the function */
+  int *lineinfo;  /* map from opcodes to source lines */
+  struct LocVar *locvars;  /* information about local variables */
+  TString **upvalues;  /* upvalue names */
+  TString  *source;
+  int sizeupvalues;
+  int sizek;  /* size of `k' */
+  int sizecode;
+  int sizelineinfo;
+  int sizep;  /* size of `p' */
+  int sizelocvars;
+  int lineDefined;
+  GCObject *gclist;
+  lu_byte nups;  /* number of upvalues */
+  lu_byte numparams;
+  lu_byte is_vararg;
+  lu_byte maxstacksize;
+} Proto;
+
+
+typedef struct LocVar {
+  TString *varname;
+  int startpc;  /* first point where variable is active */
+  int endpc;    /* first point where variable is dead */
+} LocVar;
+
+
+
+/*
+** Upvalues
+*/
+
+typedef struct UpVal {
+  CommonHeader;
+  TObject *v;  /* points to stack or to its own value */
+  TObject value;  /* the value (when closed) */
+} UpVal;
+
+
+/*
+** Closures
+*/
+
+#define ClosureHeader \
+	CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist
+
+typedef struct CClosure {
+  ClosureHeader;
+  lua_CFunction f;
+  TObject upvalue[1];
+} CClosure;
+
+
+typedef struct LClosure {
+  ClosureHeader;
+  struct Proto *p;
+  TObject g;  /* global table for this closure */
+  UpVal *upvals[1];
+} LClosure;
+
+
+typedef union Closure {
+  CClosure c;
+  LClosure l;
+} Closure;
+
+
+#define iscfunction(o)	(ttype(o) == LUA_TFUNCTION && clvalue(o)->c.isC)
+#define isLfunction(o)	(ttype(o) == LUA_TFUNCTION && !clvalue(o)->c.isC)
+
+
+/*
+** Tables
+*/
+
+typedef struct Node {
+  TObject i_key;
+  TObject i_val;
+  struct Node *next;  /* for chaining */
+} Node;
+
+
+typedef struct Table {
+  CommonHeader;
+  lu_byte flags;  /* 1<<p means tagmethod(p) is not present */ 
+  lu_byte lsizenode;  /* log2 of size of `node' array */
+  struct Table *metatable;
+  TObject *array;  /* array part */
+  Node *node;
+  Node *firstfree;  /* this position is free; all positions after it are full */
+  GCObject *gclist;
+  int sizearray;  /* size of `array' array */
+} Table;
+
+
+
+/*
+** `module' operation for hashing (size is always a power of 2)
+*/
+#define lmod(s,size) \
+	check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1))))
+
+
+#define twoto(x)	(1<<(x))
+#define sizenode(t)	(twoto((t)->lsizenode))
+
+
+
+extern const TObject luaO_nilobject;
+
+int luaO_log2 (unsigned int x);
+int luaO_int2fb (unsigned int x);
+#define fb2int(x)	(((x) & 7) << ((x) >> 3))
+
+int luaO_rawequalObj (const TObject *t1, const TObject *t2);
+int luaO_str2d (const char *s, lua_Number *result);
+
+const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp);
+const char *luaO_pushfstring (lua_State *L, const char *fmt, ...);
+void luaO_chunkid (char *out, const char *source, int len);
+
+
+#endif

Added: trunk/Util/deditor/lua/lopcodes.c
===================================================================
--- trunk/Util/deditor/lua/lopcodes.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lopcodes.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,102 @@
+/*
+** $Id: lopcodes.c,v 1.22 2002/12/04 17:38:31 roberto Exp $
+** extracted automatically from lopcodes.h by mkprint.lua
+** DO NOT EDIT
+** See Copyright Notice in lua.h
+*/
+
+
+#define lopcodes_c
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "lopcodes.h"
+
+
+#ifdef LUA_OPNAMES
+
+const char *const luaP_opnames[] = {
+  "MOVE",
+  "LOADK",
+  "LOADBOOL",
+  "LOADNIL",
+  "GETUPVAL",
+  "GETGLOBAL",
+  "GETTABLE",
+  "SETGLOBAL",
+  "SETUPVAL",
+  "SETTABLE",
+  "NEWTABLE",
+  "SELF",
+  "ADD",
+  "SUB",
+  "MUL",
+  "DIV",
+  "POW",
+  "UNM",
+  "NOT",
+  "CONCAT",
+  "JMP",
+  "EQ",
+  "LT",
+  "LE",
+  "TEST",
+  "CALL",
+  "TAILCALL",
+  "RETURN",
+  "FORLOOP",
+  "TFORLOOP",
+  "TFORPREP",
+  "SETLIST",
+  "SETLISTO",
+  "CLOSE",
+  "CLOSURE"
+};
+
+#endif
+
+#define opmode(t,b,bk,ck,sa,k,m) (((t)<<OpModeT) | \
+   ((b)<<OpModeBreg) | ((bk)<<OpModeBrk) | ((ck)<<OpModeCrk) | \
+   ((sa)<<OpModesetA) | ((k)<<OpModeK) | (m))
+
+
+const lu_byte luaP_opmodes[NUM_OPCODES] = {
+/*       T  B Bk Ck sA  K  mode			   opcode    */
+  opmode(0, 1, 0, 0, 1, 0, iABC)		/* OP_MOVE */
+ ,opmode(0, 0, 0, 0, 1, 1, iABx)		/* OP_LOADK */
+ ,opmode(0, 0, 0, 0, 1, 0, iABC)		/* OP_LOADBOOL */
+ ,opmode(0, 1, 0, 0, 1, 0, iABC)		/* OP_LOADNIL */
+ ,opmode(0, 0, 0, 0, 1, 0, iABC)		/* OP_GETUPVAL */
+ ,opmode(0, 0, 0, 0, 1, 1, iABx)		/* OP_GETGLOBAL */
+ ,opmode(0, 1, 0, 1, 1, 0, iABC)		/* OP_GETTABLE */
+ ,opmode(0, 0, 0, 0, 0, 1, iABx)		/* OP_SETGLOBAL */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_SETUPVAL */
+ ,opmode(0, 0, 1, 1, 0, 0, iABC)		/* OP_SETTABLE */
+ ,opmode(0, 0, 0, 0, 1, 0, iABC)		/* OP_NEWTABLE */
+ ,opmode(0, 1, 0, 1, 1, 0, iABC)		/* OP_SELF */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_ADD */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_SUB */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_MUL */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_DIV */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_POW */
+ ,opmode(0, 1, 0, 0, 1, 0, iABC)		/* OP_UNM */
+ ,opmode(0, 1, 0, 0, 1, 0, iABC)		/* OP_NOT */
+ ,opmode(0, 1, 0, 1, 1, 0, iABC)		/* OP_CONCAT */
+ ,opmode(0, 0, 0, 0, 0, 0, iAsBx)		/* OP_JMP */
+ ,opmode(1, 0, 1, 1, 0, 0, iABC)		/* OP_EQ */
+ ,opmode(1, 0, 1, 1, 0, 0, iABC)		/* OP_LT */
+ ,opmode(1, 0, 1, 1, 0, 0, iABC)		/* OP_LE */
+ ,opmode(1, 1, 0, 0, 1, 0, iABC)		/* OP_TEST */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_CALL */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_TAILCALL */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_RETURN */
+ ,opmode(0, 0, 0, 0, 0, 0, iAsBx)		/* OP_FORLOOP */
+ ,opmode(1, 0, 0, 0, 0, 0, iABC)		/* OP_TFORLOOP */
+ ,opmode(0, 0, 0, 0, 0, 0, iAsBx)		/* OP_TFORPREP */
+ ,opmode(0, 0, 0, 0, 0, 0, iABx)		/* OP_SETLIST */
+ ,opmode(0, 0, 0, 0, 0, 0, iABx)		/* OP_SETLISTO */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_CLOSE */
+ ,opmode(0, 0, 0, 0, 1, 0, iABx)		/* OP_CLOSURE */
+};
+

Added: trunk/Util/deditor/lua/lopcodes.h
===================================================================
--- trunk/Util/deditor/lua/lopcodes.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lopcodes.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,238 @@
+/*
+** $Id: lopcodes.h,v 1.102 2002/08/21 18:56:09 roberto Exp $
+** Opcodes for Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lopcodes_h
+#define lopcodes_h
+
+#include "llimits.h"
+
+
+/*===========================================================================
+  We assume that instructions are unsigned numbers.
+  All instructions have an opcode in the first 6 bits.
+  Instructions can have the following fields:
+	`A' : 8 bits
+	`B' : 9 bits
+	`C' : 9 bits
+	`Bx' : 18 bits (`B' and `C' together)
+	`sBx' : signed Bx
+
+  A signed argument is represented in excess K; that is, the number
+  value is the unsigned value minus K. K is exactly the maximum value
+  for that argument (so that -max is represented by 0, and +max is
+  represented by 2*max), which is half the maximum for the corresponding
+  unsigned argument.
+===========================================================================*/
+
+
+enum OpMode {iABC, iABx, iAsBx};  /* basic instruction format */
+
+
+/*
+** size and position of opcode arguments.
+*/
+#define SIZE_C		9
+#define SIZE_B		9
+#define SIZE_Bx		(SIZE_C + SIZE_B)
+#define SIZE_A		8
+
+#define SIZE_OP		6
+
+#define POS_C		SIZE_OP
+#define POS_B		(POS_C + SIZE_C)
+#define POS_Bx		POS_C
+#define POS_A		(POS_B + SIZE_B)
+
+
+/*
+** limits for opcode arguments.
+** we use (signed) int to manipulate most arguments,
+** so they must fit in BITS_INT-1 bits (-1 for sign)
+*/
+#if SIZE_Bx < BITS_INT-1
+#define MAXARG_Bx        ((1<<SIZE_Bx)-1)
+#define MAXARG_sBx        (MAXARG_Bx>>1)         /* `sBx' is signed */
+#else
+#define MAXARG_Bx        MAX_INT
+#define MAXARG_sBx        MAX_INT
+#endif
+
+
+#define MAXARG_A        ((1<<SIZE_A)-1)
+#define MAXARG_B        ((1<<SIZE_B)-1)
+#define MAXARG_C        ((1<<SIZE_C)-1)
+
+
+/* creates a mask with `n' 1 bits at position `p' */
+#define MASK1(n,p)	((~((~(Instruction)0)<<n))<<p)
+
+/* creates a mask with `n' 0 bits at position `p' */
+#define MASK0(n,p)	(~MASK1(n,p))
+
+/*
+** the following macros help to manipulate instructions
+*/
+
+#define GET_OPCODE(i)	(cast(OpCode, (i)&MASK1(SIZE_OP,0)))
+#define SET_OPCODE(i,o)	((i) = (((i)&MASK0(SIZE_OP,0)) | cast(Instruction, o)))
+
+#define GETARG_A(i)	(cast(int, (i)>>POS_A))
+#define SETARG_A(i,u)	((i) = (((i)&MASK0(SIZE_A,POS_A)) | \
+		((cast(Instruction, u)<<POS_A)&MASK1(SIZE_A,POS_A))))
+
+#define GETARG_B(i)	(cast(int, ((i)>>POS_B) & MASK1(SIZE_B,0)))
+#define SETARG_B(i,b)	((i) = (((i)&MASK0(SIZE_B,POS_B)) | \
+		((cast(Instruction, b)<<POS_B)&MASK1(SIZE_B,POS_B))))
+
+#define GETARG_C(i)	(cast(int, ((i)>>POS_C) & MASK1(SIZE_C,0)))
+#define SETARG_C(i,b)	((i) = (((i)&MASK0(SIZE_C,POS_C)) | \
+		((cast(Instruction, b)<<POS_C)&MASK1(SIZE_C,POS_C))))
+
+#define GETARG_Bx(i)	(cast(int, ((i)>>POS_Bx) & MASK1(SIZE_Bx,0)))
+#define SETARG_Bx(i,b)	((i) = (((i)&MASK0(SIZE_Bx,POS_Bx)) | \
+		((cast(Instruction, b)<<POS_Bx)&MASK1(SIZE_Bx,POS_Bx))))
+
+#define GETARG_sBx(i)	(GETARG_Bx(i)-MAXARG_sBx)
+#define SETARG_sBx(i,b)	SETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))
+
+
+#define CREATE_ABC(o,a,b,c)	(cast(Instruction, o) \
+			| (cast(Instruction, a)<<POS_A) \
+			| (cast(Instruction, b)<<POS_B) \
+			| (cast(Instruction, c)<<POS_C))
+
+#define CREATE_ABx(o,a,bc)	(cast(Instruction, o) \
+			| (cast(Instruction, a)<<POS_A) \
+			| (cast(Instruction, bc)<<POS_Bx))
+
+
+
+
+/*
+** invalid register that fits in 8 bits
+*/
+#define NO_REG		MAXARG_A
+
+
+/*
+** R(x) - register
+** Kst(x) - constant (in constant table)
+** RK(x) == if x < MAXSTACK then R(x) else Kst(x-MAXSTACK)
+*/
+
+
+/*
+** grep "ORDER OP" if you change these enums
+*/
+
+typedef enum {
+/*----------------------------------------------------------------------
+name		args	description
+------------------------------------------------------------------------*/
+OP_MOVE,/*	A B	R(A) := R(B)					*/
+OP_LOADK,/*	A Bx	R(A) := Kst(Bx)					*/
+OP_LOADBOOL,/*	A B C	R(A) := (Bool)B; if (C) PC++			*/
+OP_LOADNIL,/*	A B	R(A) := ... := R(B) := nil			*/
+OP_GETUPVAL,/*	A B	R(A) := UpValue[B]				*/
+
+OP_GETGLOBAL,/*	A Bx	R(A) := Gbl[Kst(Bx)]				*/
+OP_GETTABLE,/*	A B C	R(A) := R(B)[RK(C)]				*/
+
+OP_SETGLOBAL,/*	A Bx	Gbl[Kst(Bx)] := R(A)				*/
+OP_SETUPVAL,/*	A B	UpValue[B] := R(A)				*/
+OP_SETTABLE,/*	A B C	R(A)[RK(B)] := RK(C)				*/
+
+OP_NEWTABLE,/*	A B C	R(A) := {} (size = B,C)				*/
+
+OP_SELF,/*	A B C	R(A+1) := R(B); R(A) := R(B)[RK(C)]		*/
+
+OP_ADD,/*	A B C	R(A) := RK(B) + RK(C)				*/
+OP_SUB,/*	A B C	R(A) := RK(B) - RK(C)				*/
+OP_MUL,/*	A B C	R(A) := RK(B) * RK(C)				*/
+OP_DIV,/*	A B C	R(A) := RK(B) / RK(C)				*/
+OP_POW,/*	A B C	R(A) := RK(B) ^ RK(C)				*/
+OP_UNM,/*	A B	R(A) := -R(B)					*/
+OP_NOT,/*	A B	R(A) := not R(B)				*/
+
+OP_CONCAT,/*	A B C	R(A) := R(B).. ... ..R(C)			*/
+
+OP_JMP,/*	sBx	PC += sBx					*/
+
+OP_EQ,/*	A B C	if ((RK(B) == RK(C)) ~= A) then pc++		*/
+OP_LT,/*	A B C	if ((RK(B) <  RK(C)) ~= A) then pc++  		*/
+OP_LE,/*	A B C	if ((RK(B) <= RK(C)) ~= A) then pc++  		*/
+
+OP_TEST,/*	A B C	if (R(B) <=> C) then R(A) := R(B) else pc++	*/ 
+
+OP_CALL,/*	A B C	R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */
+OP_TAILCALL,/*	A B C	return R(A)(R(A+1), ... ,R(A+B-1))		*/
+OP_RETURN,/*	A B	return R(A), ... ,R(A+B-2)	(see note)	*/
+
+OP_FORLOOP,/*	A sBx	R(A)+=R(A+2); if R(A) <?= R(A+1) then PC+= sBx	*/
+
+OP_TFORLOOP,/*	A C	R(A+2), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); 
+                        if R(A+2) ~= nil then pc++			*/
+OP_TFORPREP,/*	A sBx	if type(R(A)) == table then R(A+1):=R(A), R(A):=next;
+			PC += sBx					*/
+
+OP_SETLIST,/*	A Bx	R(A)[Bx-Bx%FPF+i] := R(A+i), 1 <= i <= Bx%FPF+1	*/
+OP_SETLISTO,/*	A Bx							*/
+
+OP_CLOSE,/*	A 	close all variables in the stack up to (>=) R(A)*/
+OP_CLOSURE/*	A Bx	R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))	*/
+} OpCode;
+
+
+#define NUM_OPCODES	(cast(int, OP_CLOSURE+1))
+
+
+
+/*===========================================================================
+  Notes:
+  (1) In OP_CALL, if (B == 0) then B = top. C is the number of returns - 1,
+      and can be 0: OP_CALL then sets `top' to last_result+1, so
+      next open instruction (OP_CALL, OP_RETURN, OP_SETLIST) may use `top'.
+
+  (2) In OP_RETURN, if (B == 0) then return up to `top'
+
+  (3) For comparisons, B specifies what conditions the test should accept.
+
+  (4) All `skips' (pc++) assume that next instruction is a jump
+===========================================================================*/
+
+
+/*
+** masks for instruction properties
+*/  
+enum OpModeMask {
+  OpModeBreg = 2,       /* B is a register */
+  OpModeBrk,		/* B is a register/constant */
+  OpModeCrk,           /* C is a register/constant */
+  OpModesetA,           /* instruction set register A */
+  OpModeK,              /* Bx is a constant */
+  OpModeT		/* operator is a test */
+  
+};
+
+
+extern const lu_byte luaP_opmodes[NUM_OPCODES];
+
+#define getOpMode(m)            (cast(enum OpMode, luaP_opmodes[m] & 3))
+#define testOpMode(m, b)        (luaP_opmodes[m] & (1 << (b)))
+
+
+#ifdef LUA_OPNAMES
+extern const char *const luaP_opnames[];  /* opcode names */
+#endif
+
+
+
+/* number of list items to accumulate before a SETLIST instruction */
+/* (must be a power of 2) */
+#define LFIELDS_PER_FLUSH	32
+
+
+#endif

Added: trunk/Util/deditor/lua/lparser.c
===================================================================
--- trunk/Util/deditor/lua/lparser.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lparser.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,1329 @@
+/*
+** $Id: lparser.c,v 1.208 2003/04/03 13:35:34 roberto Exp $
+** Lua Parser
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define lparser_c
+
+#include "lua.h"
+
+#include "lcode.h"
+#include "ldebug.h"
+#include "lfunc.h"
+#include "llex.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+#include "lstate.h"
+#include "lstring.h"
+
+
+
+
+#define getlocvar(fs, i)	((fs)->f->locvars[(fs)->actvar[i]])
+
+
+#define enterlevel(ls)	if (++(ls)->nestlevel > LUA_MAXPARSERLEVEL) \
+		luaX_syntaxerror(ls, "too many syntax levels");
+#define leavelevel(ls)	((ls)->nestlevel--)
+
+
+/*
+** nodes for block list (list of active blocks)
+*/
+typedef struct BlockCnt {
+  struct BlockCnt *previous;  /* chain */
+  int breaklist;  /* list of jumps out of this loop */
+  int nactvar;  /* # active local variables outside the breakable structure */
+  int upval;  /* true if some variable in the block is an upvalue */
+  int isbreakable;  /* true if `block' is a loop */
+} BlockCnt;
+
+
+
+/*
+** prototypes for recursive non-terminal functions
+*/
+static void chunk (LexState *ls);
+static void expr (LexState *ls, expdesc *v);
+
+
+
+static void next (LexState *ls) {
+  ls->lastline = ls->linenumber;
+  if (ls->lookahead.token != TK_EOS) {  /* is there a look-ahead token? */
+    ls->t = ls->lookahead;  /* use this one */
+    ls->lookahead.token = TK_EOS;  /* and discharge it */
+  }
+  else
+    ls->t.token = luaX_lex(ls, &ls->t.seminfo);  /* read next token */
+}
+
+
+static void lookahead (LexState *ls) {
+  lua_assert(ls->lookahead.token == TK_EOS);
+  ls->lookahead.token = luaX_lex(ls, &ls->lookahead.seminfo);
+}
+
+
+static void error_expected (LexState *ls, int token) {
+  luaX_syntaxerror(ls,
+         luaO_pushfstring(ls->L, "`%s' expected", luaX_token2str(ls, token)));
+}
+
+
+static int testnext (LexState *ls, int c) {
+  if (ls->t.token == c) {
+    next(ls);
+    return 1;
+  }
+  else return 0;
+}
+
+
+static void check (LexState *ls, int c) {
+  if (!testnext(ls, c))
+    error_expected(ls, c);
+}
+
+
+#define check_condition(ls,c,msg)	{ if (!(c)) luaX_syntaxerror(ls, msg); }
+
+
+
+static void check_match (LexState *ls, int what, int who, int where) {
+  if (!testnext(ls, what)) {
+    if (where == ls->linenumber)
+      error_expected(ls, what);
+    else {
+      luaX_syntaxerror(ls, luaO_pushfstring(ls->L,
+             "`%s' expected (to close `%s' at line %d)",
+              luaX_token2str(ls, what), luaX_token2str(ls, who), where));
+    }
+  }
+}
+
+
+static TString *str_checkname (LexState *ls) {
+  TString *ts;
+  check_condition(ls, (ls->t.token == TK_NAME), "<name> expected");
+  ts = ls->t.seminfo.ts;
+  next(ls);
+  return ts;
+}
+
+
+static void init_exp (expdesc *e, expkind k, int i) {
+  e->f = e->t = NO_JUMP;
+  e->k = k;
+  e->info = i;
+}
+
+
+static void codestring (LexState *ls, expdesc *e, TString *s) {
+  init_exp(e, VK, luaK_stringK(ls->fs, s));
+}
+
+
+static void checkname(LexState *ls, expdesc *e) {
+  codestring(ls, e, str_checkname(ls));
+}
+
+
+static int luaI_registerlocalvar (LexState *ls, TString *varname) {
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;
+  luaM_growvector(ls->L, f->locvars, fs->nlocvars, f->sizelocvars,
+                  LocVar, MAX_INT, "");
+  f->locvars[fs->nlocvars].varname = varname;
+  return fs->nlocvars++;
+}
+
+
+static void new_localvar (LexState *ls, TString *name, int n) {
+  FuncState *fs = ls->fs;
+  luaX_checklimit(ls, fs->nactvar+n+1, MAXVARS, "local variables");
+  fs->actvar[fs->nactvar+n] = luaI_registerlocalvar(ls, name);
+}
+
+
+static void adjustlocalvars (LexState *ls, int nvars) {
+  FuncState *fs = ls->fs;
+  fs->nactvar += nvars;
+  for (; nvars; nvars--) {
+    getlocvar(fs, fs->nactvar - nvars).startpc = fs->pc;
+  }
+}
+
+
+static void removevars (LexState *ls, int tolevel) {
+  FuncState *fs = ls->fs;
+  while (fs->nactvar > tolevel)
+    getlocvar(fs, --fs->nactvar).endpc = fs->pc;
+}
+
+
+static void new_localvarstr (LexState *ls, const char *name, int n) {
+  new_localvar(ls, luaS_new(ls->L, name), n);
+}
+
+
+static void create_local (LexState *ls, const char *name) {
+  new_localvarstr(ls, name, 0);
+  adjustlocalvars(ls, 1);
+}
+
+
+static int indexupvalue (FuncState *fs, TString *name, expdesc *v) {
+  int i;
+  Proto *f = fs->f;
+  for (i=0; i<f->nups; i++) {
+    if (fs->upvalues[i].k == v->k && fs->upvalues[i].info == v->info) {
+      lua_assert(fs->f->upvalues[i] == name);
+      return i;
+    }
+  }
+  /* new one */
+  luaX_checklimit(fs->ls, f->nups + 1, MAXUPVALUES, "upvalues");
+  luaM_growvector(fs->L, fs->f->upvalues, f->nups, fs->f->sizeupvalues,
+                  TString *, MAX_INT, "");
+  fs->f->upvalues[f->nups] = name;
+  fs->upvalues[f->nups] = *v;
+  return f->nups++;
+}
+
+
+static int searchvar (FuncState *fs, TString *n) {
+  int i;
+  for (i=fs->nactvar-1; i >= 0; i--) {
+    if (n == getlocvar(fs, i).varname)
+      return i;
+  }
+  return -1;  /* not found */
+}
+
+
+static void markupval (FuncState *fs, int level) {
+  BlockCnt *bl = fs->bl;
+  while (bl && bl->nactvar > level) bl = bl->previous;
+  if (bl) bl->upval = 1;
+}
+
+
+static void singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {
+  if (fs == NULL)  /* no more levels? */
+    init_exp(var, VGLOBAL, NO_REG);  /* default is global variable */
+  else {
+    int v = searchvar(fs, n);  /* look up at current level */
+    if (v >= 0) {
+      init_exp(var, VLOCAL, v);
+      if (!base)
+        markupval(fs, v);  /* local will be used as an upval */
+    }
+    else {  /* not found at current level; try upper one */
+      singlevaraux(fs->prev, n, var, 0);
+      if (var->k == VGLOBAL) {
+        if (base)
+          var->info = luaK_stringK(fs, n);  /* info points to global name */
+      }
+      else {  /* LOCAL or UPVAL */
+        var->info = indexupvalue(fs, n, var);
+        var->k = VUPVAL;  /* upvalue in this level */
+      }
+    }
+  }
+}
+
+
+static TString *singlevar (LexState *ls, expdesc *var, int base) {
+  TString *varname = str_checkname(ls);
+  singlevaraux(ls->fs, varname, var, base);
+  return varname;
+}
+
+
+static void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {
+  FuncState *fs = ls->fs;
+  int extra = nvars - nexps;
+  if (e->k == VCALL) {
+    extra++;  /* includes call itself */
+    if (extra <= 0) extra = 0;
+    else luaK_reserveregs(fs, extra-1);
+    luaK_setcallreturns(fs, e, extra);  /* call provides the difference */
+  }
+  else {
+    if (e->k != VVOID) luaK_exp2nextreg(fs, e);  /* close last expression */
+    if (extra > 0) {
+      int reg = fs->freereg;
+      luaK_reserveregs(fs, extra);
+      luaK_nil(fs, reg, extra);
+    }
+  }
+}
+
+
+static void code_params (LexState *ls, int nparams, int dots) {
+  FuncState *fs = ls->fs;
+  adjustlocalvars(ls, nparams);
+  luaX_checklimit(ls, fs->nactvar, MAXPARAMS, "parameters");
+  fs->f->numparams = cast(lu_byte, fs->nactvar);
+  fs->f->is_vararg = cast(lu_byte, dots);
+  if (dots)
+    create_local(ls, "arg");
+  luaK_reserveregs(fs, fs->nactvar);  /* reserve register for parameters */
+}
+
+
+static void enterblock (FuncState *fs, BlockCnt *bl, int isbreakable) {
+  bl->breaklist = NO_JUMP;
+  bl->isbreakable = isbreakable;
+  bl->nactvar = fs->nactvar;
+  bl->upval = 0;
+  bl->previous = fs->bl;
+  fs->bl = bl;
+  lua_assert(fs->freereg == fs->nactvar);
+}
+
+
+static void leaveblock (FuncState *fs) {
+  BlockCnt *bl = fs->bl;
+  fs->bl = bl->previous;
+  removevars(fs->ls, bl->nactvar);
+  if (bl->upval)
+    luaK_codeABC(fs, OP_CLOSE, bl->nactvar, 0, 0);
+  lua_assert(bl->nactvar == fs->nactvar);
+  fs->freereg = fs->nactvar;  /* free registers */
+  luaK_patchtohere(fs, bl->breaklist);
+}
+
+
+static void pushclosure (LexState *ls, FuncState *func, expdesc *v) {
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;
+  int i;
+  luaM_growvector(ls->L, f->p, fs->np, f->sizep, Proto *,
+                  MAXARG_Bx, "constant table overflow");
+  f->p[fs->np++] = func->f;
+  init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np-1));
+  for (i=0; i<func->f->nups; i++) {
+    OpCode o = (func->upvalues[i].k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;
+    luaK_codeABC(fs, o, 0, func->upvalues[i].info, 0);
+  }
+}
+
+
+static void open_func (LexState *ls, FuncState *fs) {
+  Proto *f = luaF_newproto(ls->L);
+  fs->f = f;
+  fs->prev = ls->fs;  /* linked list of funcstates */
+  fs->ls = ls;
+  fs->L = ls->L;
+  ls->fs = fs;
+  fs->pc = 0;
+  fs->lasttarget = 0;
+  fs->jpc = NO_JUMP;
+  fs->freereg = 0;
+  fs->nk = 0;
+  fs->h = luaH_new(ls->L, 0, 0);
+  fs->np = 0;
+  fs->nlocvars = 0;
+  fs->nactvar = 0;
+  fs->bl = NULL;
+  f->source = ls->source;
+  f->maxstacksize = 2;  /* registers 0/1 are always valid */
+}
+
+
+static void close_func (LexState *ls) {
+  lua_State *L = ls->L;
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;
+  removevars(ls, 0);
+  luaK_codeABC(fs, OP_RETURN, 0, 1, 0);  /* final return */
+  luaM_reallocvector(L, f->code, f->sizecode, fs->pc, Instruction);
+  f->sizecode = fs->pc;
+  luaM_reallocvector(L, f->lineinfo, f->sizelineinfo, fs->pc, int);
+  f->sizelineinfo = fs->pc;
+  luaM_reallocvector(L, f->k, f->sizek, fs->nk, TObject);
+  f->sizek = fs->nk;
+  luaM_reallocvector(L, f->p, f->sizep, fs->np, Proto *);
+  f->sizep = fs->np;
+  luaM_reallocvector(L, f->locvars, f->sizelocvars, fs->nlocvars, LocVar);
+  f->sizelocvars = fs->nlocvars;
+  luaM_reallocvector(L, f->upvalues, f->sizeupvalues, f->nups, TString *);
+  f->sizeupvalues = f->nups;
+  lua_assert(luaG_checkcode(f));
+  lua_assert(fs->bl == NULL);
+  ls->fs = fs->prev;
+}
+
+
+Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff) {
+  struct LexState lexstate;
+  struct FuncState funcstate;
+  lexstate.buff = buff;
+  lexstate.nestlevel = 0;
+  luaX_setinput(L, &lexstate, z, luaS_new(L, zname(z)));
+  open_func(&lexstate, &funcstate);
+  next(&lexstate);  /* read first token */
+  chunk(&lexstate);
+  check_condition(&lexstate, (lexstate.t.token == TK_EOS), "<eof> expected");
+  close_func(&lexstate);
+  lua_assert(funcstate.prev == NULL);
+  lua_assert(funcstate.f->nups == 0);
+  lua_assert(lexstate.nestlevel == 0);
+  return funcstate.f;
+}
+
+
+
+/*============================================================*/
+/* GRAMMAR RULES */
+/*============================================================*/
+
+
+static void luaY_field (LexState *ls, expdesc *v) {
+  /* field -> ['.' | ':'] NAME */
+  FuncState *fs = ls->fs;
+  expdesc key;
+  luaK_exp2anyreg(fs, v);
+  next(ls);  /* skip the dot or colon */
+  checkname(ls, &key);
+  luaK_indexed(fs, v, &key);
+}
+
+
+static void luaY_index (LexState *ls, expdesc *v) {
+  /* index -> '[' expr ']' */
+  next(ls);  /* skip the '[' */
+  expr(ls, v);
+  luaK_exp2val(ls->fs, v);
+  check(ls, ']');
+}
+
+
+/*
+** {======================================================================
+** Rules for Constructors
+** =======================================================================
+*/
+
+
+struct ConsControl {
+  expdesc v;  /* last list item read */
+  expdesc *t;  /* table descriptor */
+  int nh;  /* total number of `record' elements */
+  int na;  /* total number of array elements */
+  int tostore;  /* number of array elements pending to be stored */
+};
+
+
+static void recfield (LexState *ls, struct ConsControl *cc) {
+  /* recfield -> (NAME | `['exp1`]') = exp1 */
+  FuncState *fs = ls->fs;
+  int reg = ls->fs->freereg;
+  expdesc key, val;
+  if (ls->t.token == TK_NAME) {
+    luaX_checklimit(ls, cc->nh, MAX_INT, "items in a constructor");
+    cc->nh++;
+    checkname(ls, &key);
+  }
+  else  /* ls->t.token == '[' */
+    luaY_index(ls, &key);
+  check(ls, '=');
+  luaK_exp2RK(fs, &key);
+  expr(ls, &val);
+  luaK_codeABC(fs, OP_SETTABLE, cc->t->info, luaK_exp2RK(fs, &key),
+                                             luaK_exp2RK(fs, &val));
+  fs->freereg = reg;  /* free registers */
+}
+
+
+static void closelistfield (FuncState *fs, struct ConsControl *cc) {
+  if (cc->v.k == VVOID) return;  /* there is no list item */
+  luaK_exp2nextreg(fs, &cc->v);
+  cc->v.k = VVOID;
+  if (cc->tostore == LFIELDS_PER_FLUSH) {
+    luaK_codeABx(fs, OP_SETLIST, cc->t->info, cc->na-1);  /* flush */
+    cc->tostore = 0;  /* no more items pending */
+    fs->freereg = cc->t->info + 1;  /* free registers */
+  }
+}
+
+
+static void lastlistfield (FuncState *fs, struct ConsControl *cc) {
+  if (cc->tostore == 0) return;
+  if (cc->v.k == VCALL) {
+    luaK_setcallreturns(fs, &cc->v, LUA_MULTRET);
+    luaK_codeABx(fs, OP_SETLISTO, cc->t->info, cc->na-1);
+  }
+  else {
+    if (cc->v.k != VVOID)
+      luaK_exp2nextreg(fs, &cc->v);
+    luaK_codeABx(fs, OP_SETLIST, cc->t->info, cc->na-1);
+  }
+  fs->freereg = cc->t->info + 1;  /* free registers */
+}
+
+
+static void listfield (LexState *ls, struct ConsControl *cc) {
+  expr(ls, &cc->v);
+  luaX_checklimit(ls, cc->na, MAXARG_Bx, "items in a constructor");
+  cc->na++;
+  cc->tostore++;
+}
+
+
+static void constructor (LexState *ls, expdesc *t) {
+  /* constructor -> ?? */
+  FuncState *fs = ls->fs;
+  int line = ls->linenumber;
+  int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
+  struct ConsControl cc;
+  cc.na = cc.nh = cc.tostore = 0;
+  cc.t = t;
+  init_exp(t, VRELOCABLE, pc);
+  init_exp(&cc.v, VVOID, 0);  /* no value (yet) */
+  luaK_exp2nextreg(ls->fs, t);  /* fix it at stack top (for gc) */
+  check(ls, '{');
+  do {
+    lua_assert(cc.v.k == VVOID || cc.tostore > 0);
+    testnext(ls, ';');  /* compatibility only */
+    if (ls->t.token == '}') break;
+    closelistfield(fs, &cc);
+    switch(ls->t.token) {
+      case TK_NAME: {  /* may be listfields or recfields */
+        lookahead(ls);
+        if (ls->lookahead.token != '=')  /* expression? */
+          listfield(ls, &cc);
+        else
+          recfield(ls, &cc);
+        break;
+      }
+      case '[': {  /* constructor_item -> recfield */
+        recfield(ls, &cc);
+        break;
+      }
+      default: {  /* constructor_part -> listfield */
+        listfield(ls, &cc);
+        break;
+      }
+    }
+  } while (testnext(ls, ',') || testnext(ls, ';'));
+  check_match(ls, '}', '{', line);
+  lastlistfield(fs, &cc);
+  SETARG_B(fs->f->code[pc], luaO_int2fb(cc.na)); /* set initial array size */
+  SETARG_C(fs->f->code[pc], luaO_log2(cc.nh)+1);  /* set initial table size */
+}
+
+/* }====================================================================== */
+
+
+
+static void parlist (LexState *ls) {
+  /* parlist -> [ param { `,' param } ] */
+  int nparams = 0;
+  int dots = 0;
+  if (ls->t.token != ')') {  /* is `parlist' not empty? */
+    do {
+      switch (ls->t.token) {
+        case TK_DOTS: dots = 1; next(ls); break;
+        case TK_NAME: new_localvar(ls, str_checkname(ls), nparams++); break;
+        default: luaX_syntaxerror(ls, "<name> or `...' expected");
+      }
+    } while (!dots && testnext(ls, ','));
+  }
+  code_params(ls, nparams, dots);
+}
+
+
+static void body (LexState *ls, expdesc *e, int needself, int line) {
+  /* body ->  `(' parlist `)' chunk END */
+  FuncState new_fs;
+  open_func(ls, &new_fs);
+  new_fs.f->lineDefined = line;
+  check(ls, '(');
+  if (needself)
+    create_local(ls, "self");
+  parlist(ls);
+  check(ls, ')');
+  chunk(ls);
+  check_match(ls, TK_END, TK_FUNCTION, line);
+  close_func(ls);
+  pushclosure(ls, &new_fs, e);
+}
+
+
+static int explist1 (LexState *ls, expdesc *v) {
+  /* explist1 -> expr { `,' expr } */
+  int n = 1;  /* at least one expression */
+  expr(ls, v);
+  while (testnext(ls, ',')) {
+    luaK_exp2nextreg(ls->fs, v);
+    expr(ls, v);
+    n++;
+  }
+  return n;
+}
+
+
+static void funcargs (LexState *ls, expdesc *f) {
+  FuncState *fs = ls->fs;
+  expdesc args;
+  int base, nparams;
+  int line = ls->linenumber;
+  switch (ls->t.token) {
+    case '(': {  /* funcargs -> `(' [ explist1 ] `)' */
+      if (line != ls->lastline)
+        luaX_syntaxerror(ls,"ambiguous syntax (function call x new statement)");
+      next(ls);
+      if (ls->t.token == ')')  /* arg list is empty? */
+        args.k = VVOID;
+      else {
+        explist1(ls, &args);
+        luaK_setcallreturns(fs, &args, LUA_MULTRET);
+      }
+      check_match(ls, ')', '(', line);
+      break;
+    }
+    case '{': {  /* funcargs -> constructor */
+      constructor(ls, &args);
+      break;
+    }
+    case TK_STRING: {  /* funcargs -> STRING */
+      codestring(ls, &args, ls->t.seminfo.ts);
+      next(ls);  /* must use `seminfo' before `next' */
+      break;
+    }
+    default: {
+      luaX_syntaxerror(ls, "function arguments expected");
+      return;
+    }
+  }
+  lua_assert(f->k == VNONRELOC);
+  base = f->info;  /* base register for call */
+  if (args.k == VCALL)
+    nparams = LUA_MULTRET;  /* open call */
+  else {
+    if (args.k != VVOID)
+      luaK_exp2nextreg(fs, &args);  /* close last argument */
+    nparams = fs->freereg - (base+1);
+  }
+  init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));
+  luaK_fixline(fs, line);
+  fs->freereg = base+1;  /* call remove function and arguments and leaves
+                            (unless changed) one result */
+}
+
+
+
+
+/*
+** {======================================================================
+** Expression parsing
+** =======================================================================
+*/
+
+
+static void prefixexp (LexState *ls, expdesc *v) {
+  /* prefixexp -> NAME | '(' expr ')' */
+  switch (ls->t.token) {
+    case '(': {
+      int line = ls->linenumber;
+      next(ls);
+      expr(ls, v);
+      check_match(ls, ')', '(', line);
+      luaK_dischargevars(ls->fs, v);
+      return;
+    }
+    case TK_NAME: {
+      singlevar(ls, v, 1);
+      return;
+    }
+#ifdef LUA_COMPATUPSYNTAX
+    case '%': {  /* for compatibility only */
+      TString *varname;
+      int line = ls->linenumber;
+      next(ls);  /* skip `%' */
+      varname = singlevar(ls, v, 1);
+      if (v->k != VUPVAL)
+        luaX_errorline(ls, "global upvalues are obsolete",
+                           getstr(varname), line);
+      return;
+    }
+#endif
+    default: {
+      luaX_syntaxerror(ls, "unexpected symbol");
+      return;
+    }
+  }
+}
+
+
+static void primaryexp (LexState *ls, expdesc *v) {
+  /* primaryexp ->
+        prefixexp { `.' NAME | `[' exp `]' | `:' NAME funcargs | funcargs } */
+  FuncState *fs = ls->fs;
+  prefixexp(ls, v);
+  for (;;) {
+    switch (ls->t.token) {
+      case '.': {  /* field */
+        luaY_field(ls, v);
+        break;
+      }
+      case '[': {  /* `[' exp1 `]' */
+        expdesc key;
+        luaK_exp2anyreg(fs, v);
+        luaY_index(ls, &key);
+        luaK_indexed(fs, v, &key);
+        break;
+      }
+      case ':': {  /* `:' NAME funcargs */
+        expdesc key;
+        next(ls);
+        checkname(ls, &key);
+        luaK_self(fs, v, &key);
+        funcargs(ls, v);
+        break;
+      }
+      case '(': case TK_STRING: case '{': {  /* funcargs */
+        luaK_exp2nextreg(fs, v);
+        funcargs(ls, v);
+        break;
+      }
+      default: return;
+    }
+  }
+}
+
+
+static void simpleexp (LexState *ls, expdesc *v) {
+  /* simpleexp -> NUMBER | STRING | NIL | constructor | FUNCTION body
+               | primaryexp */
+  switch (ls->t.token) {
+    case TK_NUMBER: {
+      init_exp(v, VK, luaK_numberK(ls->fs, ls->t.seminfo.r));
+      next(ls);  /* must use `seminfo' before `next' */
+      break;
+    }
+    case TK_STRING: {
+      codestring(ls, v, ls->t.seminfo.ts);
+      next(ls);  /* must use `seminfo' before `next' */
+      break;
+    }
+    case TK_NIL: {
+      init_exp(v, VNIL, 0);
+      next(ls);
+      break;
+    }
+    case TK_TRUE: {
+      init_exp(v, VTRUE, 0);
+      next(ls);
+      break;
+    }
+    case TK_FALSE: {
+      init_exp(v, VFALSE, 0);
+      next(ls);
+      break;
+    }
+    case '{': {  /* constructor */
+      constructor(ls, v);
+      break;
+    }
+    case TK_FUNCTION: {
+      next(ls);
+      body(ls, v, 0, ls->linenumber);
+      break;
+    }
+    default: {
+      primaryexp(ls, v);
+      break;
+    }
+  }
+}
+
+
+static UnOpr getunopr (int op) {
+  switch (op) {
+    case TK_NOT: return OPR_NOT;
+    case '-': return OPR_MINUS;
+    default: return OPR_NOUNOPR;
+  }
+}
+
+
+static BinOpr getbinopr (int op) {
+  switch (op) {
+    case '+': return OPR_ADD;
+    case '-': return OPR_SUB;
+    case '*': return OPR_MULT;
+    case '/': return OPR_DIV;
+    case '^': return OPR_POW;
+    case TK_CONCAT: return OPR_CONCAT;
+    case TK_NE: return OPR_NE;
+    case TK_EQ: return OPR_EQ;
+    case '<': return OPR_LT;
+    case TK_LE: return OPR_LE;
+    case '>': return OPR_GT;
+    case TK_GE: return OPR_GE;
+    case TK_AND: return OPR_AND;
+    case TK_OR: return OPR_OR;
+    default: return OPR_NOBINOPR;
+  }
+}
+
+
+static const struct {
+  lu_byte left;  /* left priority for each binary operator */
+  lu_byte right; /* right priority */
+} priority[] = {  /* ORDER OPR */
+   {6, 6}, {6, 6}, {7, 7}, {7, 7},  /* arithmetic */
+   {10, 9}, {5, 4},                 /* power and concat (right associative) */
+   {3, 3}, {3, 3},                  /* equality */
+   {3, 3}, {3, 3}, {3, 3}, {3, 3},  /* order */
+   {2, 2}, {1, 1}                   /* logical (and/or) */
+};
+
+#define UNARY_PRIORITY	8  /* priority for unary operators */
+
+
+/*
+** subexpr -> (simplexep | unop subexpr) { binop subexpr }
+** where `binop' is any binary operator with a priority higher than `limit'
+*/
+static BinOpr subexpr (LexState *ls, expdesc *v, int limit) {
+  BinOpr op;
+  UnOpr uop;
+  enterlevel(ls);
+  uop = getunopr(ls->t.token);
+  if (uop != OPR_NOUNOPR) {
+    next(ls);
+    subexpr(ls, v, UNARY_PRIORITY);
+    luaK_prefix(ls->fs, uop, v);
+  }
+  else simpleexp(ls, v);
+  /* expand while operators have priorities higher than `limit' */
+  op = getbinopr(ls->t.token);
+  while (op != OPR_NOBINOPR && cast(int, priority[op].left) > limit) {
+    expdesc v2;
+    BinOpr nextop;
+    next(ls);
+    luaK_infix(ls->fs, op, v);
+    /* read sub-expression with higher priority */
+    nextop = subexpr(ls, &v2, cast(int, priority[op].right));
+    luaK_posfix(ls->fs, op, v, &v2);
+    op = nextop;
+  }
+  leavelevel(ls);
+  return op;  /* return first untreated operator */
+}
+
+
+static void expr (LexState *ls, expdesc *v) {
+  subexpr(ls, v, -1);
+}
+
+/* }==================================================================== */
+
+
+
+/*
+** {======================================================================
+** Rules for Statements
+** =======================================================================
+*/
+
+
+static int block_follow (int token) {
+  switch (token) {
+    case TK_ELSE: case TK_ELSEIF: case TK_END:
+    case TK_UNTIL: case TK_EOS:
+      return 1;
+    default: return 0;
+  }
+}
+
+
+static void block (LexState *ls) {
+  /* block -> chunk */
+  FuncState *fs = ls->fs;
+  BlockCnt bl;
+  enterblock(fs, &bl, 0);
+  chunk(ls);
+  lua_assert(bl.breaklist == NO_JUMP);
+  leaveblock(fs);
+}
+
+
+/*
+** structure to chain all variables in the left-hand side of an
+** assignment
+*/
+struct LHS_assign {
+  struct LHS_assign *prev;
+  expdesc v;  /* variable (global, local, upvalue, or indexed) */
+};
+
+
+/*
+** check whether, in an assignment to a local variable, the local variable
+** is needed in a previous assignment (to a table). If so, save original
+** local value in a safe place and use this safe copy in the previous
+** assignment.
+*/
+static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {
+  FuncState *fs = ls->fs;
+  int extra = fs->freereg;  /* eventual position to save local variable */
+  int conflict = 0;
+  for (; lh; lh = lh->prev) {
+    if (lh->v.k == VINDEXED) {
+      if (lh->v.info == v->info) {  /* conflict? */
+        conflict = 1;
+        lh->v.info = extra;  /* previous assignment will use safe copy */
+      }
+      if (lh->v.aux == v->info) {  /* conflict? */
+        conflict = 1;
+        lh->v.aux = extra;  /* previous assignment will use safe copy */
+      }
+    }
+  }
+  if (conflict) {
+    luaK_codeABC(fs, OP_MOVE, fs->freereg, v->info, 0);  /* make copy */
+    luaK_reserveregs(fs, 1);
+  }
+}
+
+
+static void assignment (LexState *ls, struct LHS_assign *lh, int nvars) {
+  expdesc e;
+  check_condition(ls, VLOCAL <= lh->v.k && lh->v.k <= VINDEXED,
+                      "syntax error");
+  if (testnext(ls, ',')) {  /* assignment -> `,' primaryexp assignment */
+    struct LHS_assign nv;
+    nv.prev = lh;
+    primaryexp(ls, &nv.v);
+    if (nv.v.k == VLOCAL)
+      check_conflict(ls, lh, &nv.v);
+    assignment(ls, &nv, nvars+1);
+  }
+  else {  /* assignment -> `=' explist1 */
+    int nexps;
+    check(ls, '=');
+    nexps = explist1(ls, &e);
+    if (nexps != nvars) {
+      adjust_assign(ls, nvars, nexps, &e);
+      if (nexps > nvars)
+        ls->fs->freereg -= nexps - nvars;  /* remove extra values */
+    }
+    else {
+      luaK_setcallreturns(ls->fs, &e, 1);  /* close last expression */
+      luaK_storevar(ls->fs, &lh->v, &e);
+      return;  /* avoid default */
+    }
+  }
+  init_exp(&e, VNONRELOC, ls->fs->freereg-1);  /* default assignment */
+  luaK_storevar(ls->fs, &lh->v, &e);
+}
+
+
+static void cond (LexState *ls, expdesc *v) {
+  /* cond -> exp */
+  expr(ls, v);  /* read condition */
+  if (v->k == VNIL) v->k = VFALSE;  /* `falses' are all equal here */
+  luaK_goiftrue(ls->fs, v);
+  luaK_patchtohere(ls->fs, v->t);
+}
+
+
+/*
+** The while statement optimizes its code by coding the condition
+** after its body (and thus avoiding one jump in the loop).
+*/
+
+/*
+** maximum size of expressions for optimizing `while' code
+*/
+#ifndef MAXEXPWHILE
+#define MAXEXPWHILE	100
+#endif
+
+/*
+** the call `luaK_goiffalse' may grow the size of an expression by
+** at most this:
+*/
+#define EXTRAEXP	5
+
+static void whilestat (LexState *ls, int line) {
+  /* whilestat -> WHILE cond DO block END */
+  Instruction codeexp[MAXEXPWHILE + EXTRAEXP];
+  int lineexp;
+  int i;
+  int sizeexp;
+  FuncState *fs = ls->fs;
+  int whileinit, blockinit, expinit;
+  expdesc v;
+  BlockCnt bl;
+  next(ls);  /* skip WHILE */
+  whileinit = luaK_jump(fs);  /* jump to condition (which will be moved) */
+  expinit = luaK_getlabel(fs);
+  expr(ls, &v);  /* parse condition */
+  if (v.k == VK) v.k = VTRUE;  /* `trues' are all equal here */
+  lineexp = ls->linenumber;
+  luaK_goiffalse(fs, &v);
+  luaK_concat(fs, &v.f, fs->jpc);
+  fs->jpc = NO_JUMP;
+  sizeexp = fs->pc - expinit;  /* size of expression code */
+  if (sizeexp > MAXEXPWHILE) 
+    luaX_syntaxerror(ls, "`while' condition too complex");
+  for (i = 0; i < sizeexp; i++)  /* save `exp' code */
+    codeexp[i] = fs->f->code[expinit + i];
+  fs->pc = expinit;  /* remove `exp' code */
+  enterblock(fs, &bl, 1);
+  check(ls, TK_DO);
+  blockinit = luaK_getlabel(fs);
+  block(ls);
+  luaK_patchtohere(fs, whileinit);  /* initial jump jumps to here */
+  /* move `exp' back to code */
+  if (v.t != NO_JUMP) v.t += fs->pc - expinit;
+  if (v.f != NO_JUMP) v.f += fs->pc - expinit;
+  for (i=0; i<sizeexp; i++)
+    luaK_code(fs, codeexp[i], lineexp);
+  check_match(ls, TK_END, TK_WHILE, line);
+  leaveblock(fs);
+  luaK_patchlist(fs, v.t, blockinit);  /* true conditions go back to loop */
+  luaK_patchtohere(fs, v.f);  /* false conditions finish the loop */
+}
+
+
+static void repeatstat (LexState *ls, int line) {
+  /* repeatstat -> REPEAT block UNTIL cond */
+  FuncState *fs = ls->fs;
+  int repeat_init = luaK_getlabel(fs);
+  expdesc v;
+  BlockCnt bl;
+  enterblock(fs, &bl, 1);
+  next(ls);
+  block(ls);
+  check_match(ls, TK_UNTIL, TK_REPEAT, line);
+  cond(ls, &v);
+  luaK_patchlist(fs, v.f, repeat_init);
+  leaveblock(fs);
+}
+
+
+static int exp1 (LexState *ls) {
+  expdesc e;
+  int k;
+  expr(ls, &e);
+  k = e.k;
+  luaK_exp2nextreg(ls->fs, &e);
+  return k;
+}
+
+
+static void forbody (LexState *ls, int base, int line, int nvars, int isnum) {
+  BlockCnt bl;
+  FuncState *fs = ls->fs;
+  int prep, endfor;
+  adjustlocalvars(ls, nvars);  /* scope for all variables */
+  check(ls, TK_DO);
+  enterblock(fs, &bl, 1);  /* loop block */
+  prep = luaK_getlabel(fs);
+  block(ls);
+  luaK_patchtohere(fs, prep-1);
+  endfor = (isnum) ? luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP) :
+                     luaK_codeABC(fs, OP_TFORLOOP, base, 0, nvars - 3);
+  luaK_fixline(fs, line);  /* pretend that `OP_FOR' starts the loop */
+  luaK_patchlist(fs, (isnum) ? endfor : luaK_jump(fs), prep);
+  leaveblock(fs);
+}
+
+
+static void fornum (LexState *ls, TString *varname, int line) {
+  /* fornum -> NAME = exp1,exp1[,exp1] DO body */
+  FuncState *fs = ls->fs;
+  int base = fs->freereg;
+  new_localvar(ls, varname, 0);
+  new_localvarstr(ls, "(for limit)", 1);
+  new_localvarstr(ls, "(for step)", 2);
+  check(ls, '=');
+  exp1(ls);  /* initial value */
+  check(ls, ',');
+  exp1(ls);  /* limit */
+  if (testnext(ls, ','))
+    exp1(ls);  /* optional step */
+  else {  /* default step = 1 */
+    luaK_codeABx(fs, OP_LOADK, fs->freereg, luaK_numberK(fs, 1));
+    luaK_reserveregs(fs, 1);
+  }
+  luaK_codeABC(fs, OP_SUB, fs->freereg - 3, fs->freereg - 3, fs->freereg - 1);
+  luaK_jump(fs);
+  forbody(ls, base, line, 3, 1);
+}
+
+
+static void forlist (LexState *ls, TString *indexname) {
+  /* forlist -> NAME {,NAME} IN explist1 DO body */
+  FuncState *fs = ls->fs;
+  expdesc e;
+  int nvars = 0;
+  int line;
+  int base = fs->freereg;
+  new_localvarstr(ls, "(for generator)", nvars++);
+  new_localvarstr(ls, "(for state)", nvars++);
+  new_localvar(ls, indexname, nvars++);
+  while (testnext(ls, ','))
+    new_localvar(ls, str_checkname(ls), nvars++);
+  check(ls, TK_IN);
+  line = ls->linenumber;
+  adjust_assign(ls, nvars, explist1(ls, &e), &e);
+  luaK_checkstack(fs, 3);  /* extra space to call generator */
+  luaK_codeAsBx(fs, OP_TFORPREP, base, NO_JUMP);
+  forbody(ls, base, line, nvars, 0);
+}
+
+
+static void forstat (LexState *ls, int line) {
+  /* forstat -> fornum | forlist */
+  FuncState *fs = ls->fs;
+  TString *varname;
+  BlockCnt bl;
+  enterblock(fs, &bl, 0);  /* block to control variable scope */
+  next(ls);  /* skip `for' */
+  varname = str_checkname(ls);  /* first variable name */
+  switch (ls->t.token) {
+    case '=': fornum(ls, varname, line); break;
+    case ',': case TK_IN: forlist(ls, varname); break;
+    default: luaX_syntaxerror(ls, "`=' or `in' expected");
+  }
+  check_match(ls, TK_END, TK_FOR, line);
+  leaveblock(fs);
+}
+
+
+static void test_then_block (LexState *ls, expdesc *v) {
+  /* test_then_block -> [IF | ELSEIF] cond THEN block */
+  next(ls);  /* skip IF or ELSEIF */
+  cond(ls, v);
+  check(ls, TK_THEN);
+  block(ls);  /* `then' part */
+}
+
+
+static void ifstat (LexState *ls, int line) {
+  /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
+  FuncState *fs = ls->fs;
+  expdesc v;
+  int escapelist = NO_JUMP;
+  test_then_block(ls, &v);  /* IF cond THEN block */
+  while (ls->t.token == TK_ELSEIF) {
+    luaK_concat(fs, &escapelist, luaK_jump(fs));
+    luaK_patchtohere(fs, v.f);
+    test_then_block(ls, &v);  /* ELSEIF cond THEN block */
+  }
+  if (ls->t.token == TK_ELSE) {
+    luaK_concat(fs, &escapelist, luaK_jump(fs));
+    luaK_patchtohere(fs, v.f);
+    next(ls);  /* skip ELSE (after patch, for correct line info) */
+    block(ls);  /* `else' part */
+  }
+  else
+    luaK_concat(fs, &escapelist, v.f);
+  luaK_patchtohere(fs, escapelist);
+  check_match(ls, TK_END, TK_IF, line);
+}
+
+
+static void localfunc (LexState *ls) {
+  expdesc v, b;
+  new_localvar(ls, str_checkname(ls), 0);
+  init_exp(&v, VLOCAL, ls->fs->freereg++);
+  adjustlocalvars(ls, 1);
+  body(ls, &b, 0, ls->linenumber);
+  luaK_storevar(ls->fs, &v, &b);
+}
+
+
+static void localstat (LexState *ls) {
+  /* stat -> LOCAL NAME {`,' NAME} [`=' explist1] */
+  int nvars = 0;
+  int nexps;
+  expdesc e;
+  do {
+    new_localvar(ls, str_checkname(ls), nvars++);
+  } while (testnext(ls, ','));
+  if (testnext(ls, '='))
+    nexps = explist1(ls, &e);
+  else {
+    e.k = VVOID;
+    nexps = 0;
+  }
+  adjust_assign(ls, nvars, nexps, &e);
+  adjustlocalvars(ls, nvars);
+}
+
+
+static int funcname (LexState *ls, expdesc *v) {
+  /* funcname -> NAME {field} [`:' NAME] */
+  int needself = 0;
+  singlevar(ls, v, 1);
+  while (ls->t.token == '.')
+    luaY_field(ls, v);
+  if (ls->t.token == ':') {
+    needself = 1;
+    luaY_field(ls, v);
+  }
+  return needself;
+}
+
+
+static void funcstat (LexState *ls, int line) {
+  /* funcstat -> FUNCTION funcname body */
+  int needself;
+  expdesc v, b;
+  next(ls);  /* skip FUNCTION */
+  needself = funcname(ls, &v);
+  body(ls, &b, needself, line);
+  luaK_storevar(ls->fs, &v, &b);
+  luaK_fixline(ls->fs, line);  /* definition `happens' in the first line */
+}
+
+
+static void exprstat (LexState *ls) {
+  /* stat -> func | assignment */
+  FuncState *fs = ls->fs;
+  struct LHS_assign v;
+  primaryexp(ls, &v.v);
+  if (v.v.k == VCALL) {  /* stat -> func */
+    luaK_setcallreturns(fs, &v.v, 0);  /* call statement uses no results */
+  }
+  else {  /* stat -> assignment */
+    v.prev = NULL;
+    assignment(ls, &v, 1);
+  }
+}
+
+
+static void retstat (LexState *ls) {
+  /* stat -> RETURN explist */
+  FuncState *fs = ls->fs;
+  expdesc e;
+  int first, nret;  /* registers with returned values */
+  next(ls);  /* skip RETURN */
+  if (block_follow(ls->t.token) || ls->t.token == ';')
+    first = nret = 0;  /* return no values */
+  else {
+    nret = explist1(ls, &e);  /* optional return values */
+    if (e.k == VCALL) {
+      luaK_setcallreturns(fs, &e, LUA_MULTRET);
+      if (nret == 1) {  /* tail call? */
+        SET_OPCODE(getcode(fs,&e), OP_TAILCALL);
+        lua_assert(GETARG_A(getcode(fs,&e)) == fs->nactvar);
+      }
+      first = fs->nactvar;
+      nret = LUA_MULTRET;  /* return all values */
+    }
+    else {
+      if (nret == 1)  /* only one single value? */
+        first = luaK_exp2anyreg(fs, &e);
+      else {
+        luaK_exp2nextreg(fs, &e);  /* values must go to the `stack' */
+        first = fs->nactvar;  /* return all `active' values */
+        lua_assert(nret == fs->freereg - first);
+      }
+    }
+  }
+  luaK_codeABC(fs, OP_RETURN, first, nret+1, 0);
+}
+
+
+static void breakstat (LexState *ls) {
+  /* stat -> BREAK [NAME] */
+  FuncState *fs = ls->fs;
+  BlockCnt *bl = fs->bl;
+  int upval = 0;
+  next(ls);  /* skip BREAK */
+  while (bl && !bl->isbreakable) {
+    upval |= bl->upval;
+    bl = bl->previous;
+  }
+  if (!bl)
+    luaX_syntaxerror(ls, "no loop to break");
+  if (upval)
+    luaK_codeABC(fs, OP_CLOSE, bl->nactvar, 0, 0);
+  luaK_concat(fs, &bl->breaklist, luaK_jump(fs));
+}
+
+
+static int statement (LexState *ls) {
+  int line = ls->linenumber;  /* may be needed for error messages */
+  switch (ls->t.token) {
+    case TK_IF: {  /* stat -> ifstat */
+      ifstat(ls, line);
+      return 0;
+    }
+    case TK_WHILE: {  /* stat -> whilestat */
+      whilestat(ls, line);
+      return 0;
+    }
+    case TK_DO: {  /* stat -> DO block END */
+      next(ls);  /* skip DO */
+      block(ls);
+      check_match(ls, TK_END, TK_DO, line);
+      return 0;
+    }
+    case TK_FOR: {  /* stat -> forstat */
+      forstat(ls, line);
+      return 0;
+    }
+    case TK_REPEAT: {  /* stat -> repeatstat */
+      repeatstat(ls, line);
+      return 0;
+    }
+    case TK_FUNCTION: {
+      funcstat(ls, line);  /* stat -> funcstat */
+      return 0;
+    }
+    case TK_LOCAL: {  /* stat -> localstat */
+      next(ls);  /* skip LOCAL */
+      if (testnext(ls, TK_FUNCTION))  /* local function? */
+        localfunc(ls);
+      else
+        localstat(ls);
+      return 0;
+    }
+    case TK_RETURN: {  /* stat -> retstat */
+      retstat(ls);
+      return 1;  /* must be last statement */
+    }
+    case TK_BREAK: {  /* stat -> breakstat */
+      breakstat(ls);
+      return 1;  /* must be last statement */
+    }
+    default: {
+      exprstat(ls);
+      return 0;  /* to avoid warnings */
+    }
+  }
+}
+
+
+static void chunk (LexState *ls) {
+  /* chunk -> { stat [`;'] } */
+  int islast = 0;
+  enterlevel(ls);
+  while (!islast && !block_follow(ls->t.token)) {
+    islast = statement(ls);
+    testnext(ls, ';');
+    lua_assert(ls->fs->freereg >= ls->fs->nactvar);
+    ls->fs->freereg = ls->fs->nactvar;  /* free registers */
+  }
+  leavelevel(ls);
+}
+
+/* }====================================================================== */

Added: trunk/Util/deditor/lua/lparser.h
===================================================================
--- trunk/Util/deditor/lua/lparser.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lparser.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,71 @@
+/*
+** $Id: lparser.h,v 1.47 2003/02/11 10:46:24 roberto Exp $
+** Lua Parser
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lparser_h
+#define lparser_h
+
+#include "llimits.h"
+#include "lobject.h"
+#include "ltable.h"
+#include "lzio.h"
+
+
+/*
+** Expression descriptor
+*/
+
+typedef enum {
+  VVOID,	/* no value */
+  VNIL,
+  VTRUE,
+  VFALSE,
+  VK,		/* info = index of constant in `k' */
+  VLOCAL,	/* info = local register */
+  VUPVAL,       /* info = index of upvalue in `upvalues' */
+  VGLOBAL,	/* info = index of table; aux = index of global name in `k' */
+  VINDEXED,	/* info = table register; aux = index register (or `k') */
+  VJMP,		/* info = instruction pc */
+  VRELOCABLE,	/* info = instruction pc */
+  VNONRELOC,	/* info = result register */
+  VCALL		/* info = result register */
+} expkind;
+
+typedef struct expdesc {
+  expkind k;
+  int info, aux;
+  int t;  /* patch list of `exit when true' */
+  int f;  /* patch list of `exit when false' */
+} expdesc;
+
+
+struct BlockCnt;  /* defined in lparser.c */
+
+
+/* state needed to generate code for a given function */
+typedef struct FuncState {
+  Proto *f;  /* current function header */
+  Table *h;  /* table to find (and reuse) elements in `k' */
+  struct FuncState *prev;  /* enclosing function */
+  struct LexState *ls;  /* lexical state */
+  struct lua_State *L;  /* copy of the Lua state */
+  struct BlockCnt *bl;  /* chain of current blocks */
+  int pc;  /* next position to code (equivalent to `ncode') */
+  int lasttarget;   /* `pc' of last `jump target' */
+  int jpc;  /* list of pending jumps to `pc' */
+  int freereg;  /* first free register */
+  int nk;  /* number of elements in `k' */
+  int np;  /* number of elements in `p' */
+  int nlocvars;  /* number of elements in `locvars' */
+  int nactvar;  /* number of active local variables */
+  expdesc upvalues[MAXUPVALUES];  /* upvalues */
+  int actvar[MAXVARS];  /* declared-variable stack */
+} FuncState;
+
+
+Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff);
+
+
+#endif

Added: trunk/Util/deditor/lua/lstate.c
===================================================================
--- trunk/Util/deditor/lua/lstate.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lstate.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,220 @@
+/*
+** $Id: lstate.c,v 1.123 2003/04/03 13:35:34 roberto Exp $
+** Global State
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+
+#define lstate_c
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "llex.h"
+#include "lmem.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+
+
+/*
+** macro to allow the inclusion of user information in Lua state
+*/
+#ifndef LUA_USERSTATE
+#define EXTRASPACE	0
+#else
+union UEXTRASPACE {L_Umaxalign a; LUA_USERSTATE b;};
+#define EXTRASPACE (sizeof(union UEXTRASPACE))
+#endif
+
+
+
+/*
+** you can change this function through the official API:
+** call `lua_setpanicf'
+*/
+static int default_panic (lua_State *L) {
+  UNUSED(L);
+  return 0;
+}
+
+
+static lua_State *mallocstate (lua_State *L) {
+  lu_byte *block = (lu_byte *)luaM_malloc(L, sizeof(lua_State) + EXTRASPACE);
+  if (block == NULL) return NULL;
+  else {
+    block += EXTRASPACE;
+    return cast(lua_State *, block);
+  }
+}
+
+
+static void freestate (lua_State *L, lua_State *L1) {
+  luaM_free(L, cast(lu_byte *, L1) - EXTRASPACE,
+               sizeof(lua_State) + EXTRASPACE);
+}
+
+
+static void stack_init (lua_State *L1, lua_State *L) {
+  L1->stack = luaM_newvector(L, BASIC_STACK_SIZE + EXTRA_STACK, TObject);
+  L1->stacksize = BASIC_STACK_SIZE + EXTRA_STACK;
+  L1->top = L1->stack;
+  L1->stack_last = L1->stack+(L1->stacksize - EXTRA_STACK)-1;
+  L1->base_ci = luaM_newvector(L, BASIC_CI_SIZE, CallInfo);
+  L1->ci = L1->base_ci;
+  L1->ci->state = CI_C;  /*  not a Lua function */
+  setnilvalue(L1->top++);  /* `function' entry for this `ci' */
+  L1->base = L1->ci->base = L1->top;
+  L1->ci->top = L1->top + LUA_MINSTACK;
+  L1->size_ci = BASIC_CI_SIZE;
+  L1->end_ci = L1->base_ci + L1->size_ci;
+}
+
+
+static void freestack (lua_State *L, lua_State *L1) {
+  luaM_freearray(L, L1->base_ci, L1->size_ci, CallInfo);
+  luaM_freearray(L, L1->stack, L1->stacksize, TObject);
+}
+
+
+/*
+** open parts that may cause memory-allocation errors
+*/
+static void f_luaopen (lua_State *L, void *ud) {
+  /* create a new global state */
+  global_State *g = luaM_new(NULL, global_State);
+  UNUSED(ud);
+  if (g == NULL) luaD_throw(L, LUA_ERRMEM);
+  L->l_G = g;
+  g->mainthread = L;
+  g->GCthreshold = 0;  /* mark it as unfinished state */
+  g->strt.size = 0;
+  g->strt.nuse = 0;
+  g->strt.hash = NULL;
+  setnilvalue(defaultmeta(L));
+  setnilvalue(registry(L));
+  luaZ_initbuffer(L, &g->buff);
+  g->panic = default_panic;
+  g->rootgc = NULL;
+  g->rootudata = NULL;
+  g->tmudata = NULL;
+  setnilvalue(gkey(g->dummynode));
+  setnilvalue(gval(g->dummynode));
+  g->dummynode->next = NULL;
+  g->nblocks = sizeof(lua_State) + sizeof(global_State);
+  stack_init(L, L);  /* init stack */
+  /* create default meta table with a dummy table, and then close the loop */
+  defaultmeta(L)->tt = LUA_TTABLE;
+  sethvalue(defaultmeta(L), luaH_new(L, 0, 0));
+  hvalue(defaultmeta(L))->metatable = hvalue(defaultmeta(L));
+  sethvalue(gt(L), luaH_new(L, 0, 4));  /* table of globals */
+  sethvalue(registry(L), luaH_new(L, 4, 4));  /* registry */
+  luaS_resize(L, MINSTRTABSIZE);  /* initial size of string table */
+  luaT_init(L);
+  luaX_init(L);
+  luaS_fix(luaS_newliteral(L, MEMERRMSG));
+  g->GCthreshold = 4*G(L)->nblocks;
+}
+
+
+static void preinit_state (lua_State *L) {
+  L->stack = NULL;
+  L->stacksize = 0;
+  L->errorJmp = NULL;
+  L->hook = NULL;
+  L->hookmask = L->hookinit = 0;
+  L->basehookcount = 0;
+  L->allowhook = 1;
+  resethookcount(L);
+  L->openupval = NULL;
+  L->size_ci = 0;
+  L->nCcalls = 0;
+  L->base_ci = L->ci = NULL;
+  L->errfunc = 0;
+  setnilvalue(gt(L));
+}
+
+
+static void close_state (lua_State *L) {
+  luaF_close(L, L->stack);  /* close all upvalues for this thread */
+  if (G(L)) {  /* close global state */
+    luaC_sweep(L, 1);  /* collect all elements */
+    lua_assert(G(L)->rootgc == NULL);
+    lua_assert(G(L)->rootudata == NULL);
+    luaS_freeall(L);
+    luaZ_freebuffer(L, &G(L)->buff);
+  }
+  freestack(L, L);
+  if (G(L)) {
+    lua_assert(G(L)->nblocks == sizeof(lua_State) + sizeof(global_State));
+    luaM_freelem(NULL, G(L));
+  }
+  freestate(NULL, L);
+}
+
+
+lua_State *luaE_newthread (lua_State *L) {
+  lua_State *L1 = mallocstate(L);
+  luaC_link(L, valtogco(L1), LUA_TTHREAD);
+  preinit_state(L1);
+  L1->l_G = L->l_G;
+  stack_init(L1, L);  /* init stack */
+  setobj2n(gt(L1), gt(L));  /* share table of globals */
+  return L1;
+}
+
+
+void luaE_freethread (lua_State *L, lua_State *L1) {
+  luaF_close(L1, L1->stack);  /* close all upvalues for this thread */
+  lua_assert(L1->openupval == NULL);
+  freestack(L, L1);
+  freestate(L, L1);
+}
+
+
+LUA_API lua_State *lua_open (void) {
+  lua_State *L = mallocstate(NULL);
+  if (L) {  /* allocation OK? */
+    L->tt = LUA_TTHREAD;
+    L->marked = 0;
+    L->next = L->gclist = NULL;
+    preinit_state(L);
+    L->l_G = NULL;
+    if (luaD_rawrunprotected(L, f_luaopen, NULL) != 0) {
+      /* memory allocation error: free partial state */
+      close_state(L);
+      L = NULL;
+    }
+  }
+  lua_userstateopen(L);
+  return L;
+}
+
+
+static void callallgcTM (lua_State *L, void *ud) {
+  UNUSED(ud);
+  luaC_callGCTM(L);  /* call GC metamethods for all udata */
+}
+
+
+LUA_API void lua_close (lua_State *L) {
+  lua_lock(L);
+  L = G(L)->mainthread;  /* only the main thread can be closed */
+  luaF_close(L, L->stack);  /* close all upvalues for this thread */
+  luaC_separateudata(L);  /* separate udata that have GC metamethods */
+  L->errfunc = 0;  /* no error function during GC metamethods */
+  do {  /* repeat until no more errors */
+    L->ci = L->base_ci;
+    L->base = L->top = L->ci->base;
+    L->nCcalls = 0;
+  } while (luaD_rawrunprotected(L, callallgcTM, NULL) != 0);
+  lua_assert(G(L)->tmudata == NULL);
+  close_state(L);
+}
+

Added: trunk/Util/deditor/lua/lstate.h
===================================================================
--- trunk/Util/deditor/lua/lstate.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lstate.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,195 @@
+/*
+** $Id: lstate.h,v 1.109 2003/02/27 11:52:30 roberto Exp $
+** Global State
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lstate_h
+#define lstate_h
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "ltm.h"
+#include "lzio.h"
+
+
+/*
+** macros for thread synchronization inside Lua core machine:
+** all accesses to the global state and to global objects are synchronized.
+** Because threads can read the stack of other threads
+** (when running garbage collection),
+** a thread must also synchronize any write-access to its own stack.
+** Unsynchronized accesses are allowed only when reading its own stack,
+** or when reading immutable fields from global objects
+** (such as string values and udata values). 
+*/
+#ifndef lua_lock
+#define lua_lock(L)	((void) 0)
+#endif
+
+#ifndef lua_unlock
+#define lua_unlock(L)	((void) 0)
+#endif
+
+
+#ifndef lua_userstateopen
+#define lua_userstateopen(l)
+#endif
+
+
+
+struct lua_longjmp;  /* defined in ldo.c */
+
+
+/* default meta table (both for tables and udata) */
+#define defaultmeta(L)	(&G(L)->_defaultmeta)
+
+/* table of globals */
+#define gt(L)	(&L->_gt)
+
+/* registry */
+#define registry(L)	(&G(L)->_registry)
+
+
+/* extra stack space to handle TM calls and some other extras */
+#define EXTRA_STACK   5
+
+
+#define BASIC_CI_SIZE           8
+
+#define BASIC_STACK_SIZE        (2*LUA_MINSTACK)
+
+
+
+typedef struct stringtable {
+  GCObject **hash;
+  ls_nstr nuse;  /* number of elements */
+  int size;
+} stringtable;
+
+
+/*
+** informations about a call
+*/
+typedef struct CallInfo {
+  StkId base;  /* base for called function */
+  StkId	top;  /* top for this function */
+  int state;  /* bit fields; see below */
+  union {
+    struct {  /* for Lua functions */
+      const Instruction *savedpc;
+      const Instruction **pc;  /* points to `pc' variable in `luaV_execute' */
+      int tailcalls;  /* number of tail calls lost under this entry */
+    } l;
+    struct {  /* for C functions */
+      int dummy;  /* just to avoid an empty struct */
+    } c;
+  } u;
+} CallInfo;
+
+
+/*
+** bit fields for `CallInfo.state'
+*/
+#define CI_C		(1<<0)  /* 1 if function is a C function */
+/* 1 if (Lua) function has an active `luaV_execute' running it */
+#define CI_HASFRAME	(1<<1)
+/* 1 if Lua function is calling another Lua function (and therefore its
+   `pc' is being used by the other, and therefore CI_SAVEDPC is 1 too) */
+#define CI_CALLING	(1<<2)
+#define CI_SAVEDPC	(1<<3)  /* 1 if `savedpc' is updated */
+#define CI_YIELD	(1<<4)  /* 1 if thread is suspended */
+
+
+#define ci_func(ci)	(clvalue((ci)->base - 1))
+
+
+/*
+** `global state', shared by all threads of this state
+*/
+typedef struct global_State {
+  stringtable strt;  /* hash table for strings */
+  GCObject *rootgc;  /* list of (almost) all collectable objects */
+  GCObject *rootudata;   /* (separated) list of all userdata */
+  GCObject *tmudata;  /* list of userdata to be GC */
+  Mbuffer buff;  /* temporary buffer for string concatentation */
+  lu_mem GCthreshold;
+  lu_mem nblocks;  /* number of `bytes' currently allocated */
+  lua_CFunction panic;  /* to be called in unprotected errors */
+  TObject _registry;
+  TObject _defaultmeta;
+  struct lua_State *mainthread;
+  Node dummynode[1];  /* common node array for all empty tables */
+  TString *tmname[TM_N];  /* array with tag-method names */
+} global_State;
+
+
+/*
+** `per thread' state
+*/
+struct lua_State {
+  CommonHeader;
+  StkId top;  /* first free slot in the stack */
+  StkId base;  /* base of current function */
+  global_State *l_G;
+  CallInfo *ci;  /* call info for current function */
+  StkId stack_last;  /* last free slot in the stack */
+  StkId stack;  /* stack base */
+  int stacksize;
+  CallInfo *end_ci;  /* points after end of ci array*/
+  CallInfo *base_ci;  /* array of CallInfo's */
+  unsigned short size_ci;  /* size of array `base_ci' */
+  unsigned short nCcalls;  /* number of nested C calls */
+  lu_byte hookmask;
+  lu_byte allowhook;
+  lu_byte hookinit;
+  int basehookcount;
+  int hookcount;
+  lua_Hook hook;
+  TObject _gt;  /* table of globals */
+  GCObject *openupval;  /* list of open upvalues in this stack */
+  GCObject *gclist;
+  struct lua_longjmp *errorJmp;  /* current error recover point */
+  ptrdiff_t errfunc;  /* current error handling function (stack index) */
+};
+
+
+#define G(L)	(L->l_G)
+
+
+/*
+** Union of all collectable objects
+*/
+union GCObject {
+  GCheader gch;
+  union TString ts;
+  union Udata u;
+  union Closure cl;
+  struct Table h;
+  struct Proto p;
+  struct UpVal uv;
+  struct lua_State th;  /* thread */
+};
+
+
+/* macros to convert a GCObject into a specific value */
+#define gcotots(o)	check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
+#define gcotou(o)	check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
+#define gcotocl(o)	check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
+#define gcotoh(o)	check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
+#define gcotop(o)	check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
+#define gcotouv(o)	check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
+#define ngcotouv(o) \
+	check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
+#define gcototh(o)	check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
+
+/* macro to convert any value into a GCObject */
+#define valtogco(v)	(cast(GCObject *, (v)))
+
+
+lua_State *luaE_newthread (lua_State *L);
+void luaE_freethread (lua_State *L, lua_State *L1);
+
+#endif
+

Added: trunk/Util/deditor/lua/lstring.c
===================================================================
--- trunk/Util/deditor/lua/lstring.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lstring.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,102 @@
+/*
+** $Id: lstring.c,v 1.78 2002/12/04 17:38:31 roberto Exp $
+** String table (keeps all strings handled by Lua)
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define lstring_c
+
+#include "lua.h"
+
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+
+
+
+void luaS_freeall (lua_State *L) {
+  lua_assert(G(L)->strt.nuse==0);
+  luaM_freearray(L, G(L)->strt.hash, G(L)->strt.size, TString *);
+}
+
+
+void luaS_resize (lua_State *L, int newsize) {
+  GCObject **newhash = luaM_newvector(L, newsize, GCObject *);
+  stringtable *tb = &G(L)->strt;
+  int i;
+  for (i=0; i<newsize; i++) newhash[i] = NULL;
+  /* rehash */
+  for (i=0; i<tb->size; i++) {
+    GCObject *p = tb->hash[i];
+    while (p) {  /* for each node in the list */
+      GCObject *next = p->gch.next;  /* save next */
+      lu_hash h = gcotots(p)->tsv.hash;
+      int h1 = lmod(h, newsize);  /* new position */
+      lua_assert(cast(int, h%newsize) == lmod(h, newsize));
+      p->gch.next = newhash[h1];  /* chain it */
+      newhash[h1] = p;
+      p = next;
+    }
+  }
+  luaM_freearray(L, tb->hash, tb->size, TString *);
+  tb->size = newsize;
+  tb->hash = newhash;
+}
+
+
+static TString *newlstr (lua_State *L, const char *str, size_t l, lu_hash h) {
+  TString *ts = cast(TString *, luaM_malloc(L, sizestring(l)));
+  stringtable *tb;
+  ts->tsv.len = l;
+  ts->tsv.hash = h;
+  ts->tsv.marked = 0;
+  ts->tsv.tt = LUA_TSTRING;
+  ts->tsv.reserved = 0;
+  memcpy(ts+1, str, l*sizeof(char));
+  ((char *)(ts+1))[l] = '\0';  /* ending 0 */
+  tb = &G(L)->strt;
+  h = lmod(h, tb->size);
+  ts->tsv.next = tb->hash[h];  /* chain new entry */
+  tb->hash[h] = valtogco(ts);
+  tb->nuse++;
+  if (tb->nuse > cast(ls_nstr, tb->size) && tb->size <= MAX_INT/2)
+    luaS_resize(L, tb->size*2);  /* too crowded */
+  return ts;
+}
+
+
+TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
+  GCObject *o;
+  lu_hash h = (lu_hash)l;  /* seed */
+  size_t step = (l>>5)+1;  /* if string is too long, don't hash all its chars */
+  size_t l1;
+  for (l1=l; l1>=step; l1-=step)  /* compute hash */
+    h = h ^ ((h<<5)+(h>>2)+(unsigned char)(str[l1-1]));
+  for (o = G(L)->strt.hash[lmod(h, G(L)->strt.size)];
+       o != NULL;
+       o = o->gch.next) {
+    TString *ts = gcotots(o);
+    if (ts->tsv.len == l && (memcmp(str, getstr(ts), l) == 0))
+      return ts;
+  }
+  return newlstr(L, str, l, h);  /* not found */
+}
+
+
+Udata *luaS_newudata (lua_State *L, size_t s) {
+  Udata *u;
+  u = cast(Udata *, luaM_malloc(L, sizeudata(s)));
+  u->uv.marked = (1<<1);  /* is not finalized */
+  u->uv.tt = LUA_TUSERDATA;
+  u->uv.len = s;
+  u->uv.metatable = hvalue(defaultmeta(L));
+  /* chain it on udata list */
+  u->uv.next = G(L)->rootudata;
+  G(L)->rootudata = valtogco(u);
+  return u;
+}
+

Added: trunk/Util/deditor/lua/lstring.h
===================================================================
--- trunk/Util/deditor/lua/lstring.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lstring.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,33 @@
+/*
+** $Id: lstring.h,v 1.37 2002/08/16 14:45:55 roberto Exp $
+** String table (keep all strings handled by Lua)
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lstring_h
+#define lstring_h
+
+
+#include "lobject.h"
+#include "lstate.h"
+
+
+
+#define sizestring(l)	(cast(lu_mem, sizeof(union TString))+ \
+                         (cast(lu_mem, l)+1)*sizeof(char))
+
+#define sizeudata(l)	(cast(lu_mem, sizeof(union Udata))+(l))
+
+#define luaS_new(L, s)	(luaS_newlstr(L, s, strlen(s)))
+#define luaS_newliteral(L, s)	(luaS_newlstr(L, "" s, \
+                                 (sizeof(s)/sizeof(char))-1))
+
+#define luaS_fix(s)	((s)->tsv.marked |= (1<<4))
+
+void luaS_resize (lua_State *L, int newsize);
+Udata *luaS_newudata (lua_State *L, size_t s);
+void luaS_freeall (lua_State *L);
+TString *luaS_newlstr (lua_State *L, const char *str, size_t l);
+
+
+#endif

Added: trunk/Util/deditor/lua/ltable.c
===================================================================
--- trunk/Util/deditor/lua/ltable.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ltable.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,509 @@
+/*
+** $Id: ltable.c,v 1.132 2003/04/03 13:35:34 roberto Exp $
+** Lua tables (hash)
+** See Copyright Notice in lua.h
+*/
+
+
+/*
+** Implementation of tables (aka arrays, objects, or hash tables).
+** Tables keep its elements in two parts: an array part and a hash part.
+** Non-negative integer keys are all candidates to be kept in the array
+** part. The actual size of the array is the largest `n' such that at
+** least half the slots between 0 and n are in use.
+** Hash uses a mix of chained scatter table with Brent's variation.
+** A main invariant of these tables is that, if an element is not
+** in its main position (i.e. the `original' position that its hash gives
+** to it), then the colliding element is in its own main position.
+** In other words, there are collisions only when two elements have the
+** same main position (i.e. the same hash values for that table size).
+** Because of that, the load factor of these tables can be 100% without
+** performance penalties.
+*/
+
+#include <string.h>
+
+#define ltable_c
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "ltable.h"
+
+
+/*
+** max size of array part is 2^MAXBITS
+*/
+#if BITS_INT > 26
+#define MAXBITS		24
+#else
+#define MAXBITS		(BITS_INT-2)
+#endif
+
+/* check whether `x' < 2^MAXBITS */
+#define toobig(x)	((((x)-1) >> MAXBITS) != 0)
+
+
+/* function to convert a lua_Number to int (with any rounding method) */
+#ifndef lua_number2int
+#define lua_number2int(i,n)	((i)=(int)(n))
+#endif
+
+
+#define hashpow2(t,n)      (gnode(t, lmod((n), sizenode(t))))
+  
+#define hashstr(t,str)  hashpow2(t, (str)->tsv.hash)
+#define hashboolean(t,p)        hashpow2(t, p)
+
+
+/*
+** for some types, it is better to avoid modulus by power of 2, as
+** they tend to have many 2 factors.
+*/
+#define hashmod(t,n)	(gnode(t, ((n) % ((sizenode(t)-1)|1))))
+
+
+#define hashpointer(t,p)	hashmod(t, IntPoint(p))
+
+
+/*
+** number of ints inside a lua_Number
+*/
+#define numints		cast(int, sizeof(lua_Number)/sizeof(int))
+
+
+/*
+** hash for lua_Numbers
+*/
+static Node *hashnum (const Table *t, lua_Number n) {
+  unsigned int a[numints];
+  int i;
+  n += 1;  /* normalize number (avoid -0) */
+  lua_assert(sizeof(a) <= sizeof(n));
+  memcpy(a, &n, sizeof(a));
+  for (i = 1; i < numints; i++) a[0] += a[i];
+  return hashmod(t, cast(lu_hash, a[0]));
+}
+
+
+
+/*
+** returns the `main' position of an element in a table (that is, the index
+** of its hash value)
+*/
+Node *luaH_mainposition (const Table *t, const TObject *key) {
+  switch (ttype(key)) {
+    case LUA_TNUMBER:
+      return hashnum(t, nvalue(key));
+    case LUA_TSTRING:
+      return hashstr(t, tsvalue(key));
+    case LUA_TBOOLEAN:
+      return hashboolean(t, bvalue(key));
+    case LUA_TLIGHTUSERDATA:
+      return hashpointer(t, pvalue(key));
+    default:
+      return hashpointer(t, gcvalue(key));
+  }
+}
+
+
+/*
+** returns the index for `key' if `key' is an appropriate key to live in
+** the array part of the table, -1 otherwise.
+*/
+static int arrayindex (const TObject *key) {
+  if (ttisnumber(key)) {
+    int k;
+    lua_number2int(k, (nvalue(key)));
+    if (cast(lua_Number, k) == nvalue(key) && k >= 1 && !toobig(k))
+      return k;
+  }
+  return -1;  /* `key' did not match some condition */
+}
+
+
+/*
+** returns the index of a `key' for table traversals. First goes all
+** elements in the array part, then elements in the hash part. The
+** beginning and end of a traversal are signalled by -1.
+*/
+static int luaH_index (lua_State *L, Table *t, StkId key) {
+  int i;
+  if (ttisnil(key)) return -1;  /* first iteration */
+  i = arrayindex(key);
+  if (0 <= i && i <= t->sizearray) {  /* is `key' inside array part? */
+    return i-1;  /* yes; that's the index (corrected to C) */
+  }
+  else {
+    const TObject *v = luaH_get(t, key);
+    if (v == &luaO_nilobject)
+      luaG_runerror(L, "invalid key for `next'");
+    i = cast(int, (cast(const lu_byte *, v) -
+                   cast(const lu_byte *, gval(gnode(t, 0)))) / sizeof(Node));
+    return i + t->sizearray;  /* hash elements are numbered after array ones */
+  }
+}
+
+
+int luaH_next (lua_State *L, Table *t, StkId key) {
+  int i = luaH_index(L, t, key);  /* find original element */
+  for (i++; i < t->sizearray; i++) {  /* try first array part */
+    if (!ttisnil(&t->array[i])) {  /* a non-nil value? */
+      setnvalue(key, cast(lua_Number, i+1));
+      setobj2s(key+1, &t->array[i]);
+      return 1;
+    }
+  }
+  for (i -= t->sizearray; i < sizenode(t); i++) {  /* then hash part */
+    if (!ttisnil(gval(gnode(t, i)))) {  /* a non-nil value? */
+      setobj2s(key, gkey(gnode(t, i)));
+      setobj2s(key+1, gval(gnode(t, i)));
+      return 1;
+    }
+  }
+  return 0;  /* no more elements */
+}
+
+
+/*
+** {=============================================================
+** Rehash
+** ==============================================================
+*/
+
+
+static void computesizes  (int nums[], int ntotal, int *narray, int *nhash) {
+  int i;
+  int a = nums[0];  /* number of elements smaller than 2^i */
+  int na = a;  /* number of elements to go to array part */
+  int n = (na == 0) ? -1 : 0;  /* (log of) optimal size for array part */
+  for (i = 1; a < *narray && *narray >= twoto(i-1); i++) {
+    if (nums[i] > 0) {
+      a += nums[i];
+      if (a >= twoto(i-1)) {  /* more than half elements in use? */
+        n = i;
+        na = a;
+      }
+    }
+  }
+  lua_assert(na <= *narray && *narray <= ntotal);
+  *nhash = ntotal - na;
+  *narray = (n == -1) ? 0 : twoto(n);
+  lua_assert(na <= *narray && na >= *narray/2);
+}
+
+
+static void numuse (const Table *t, int *narray, int *nhash) {
+  int nums[MAXBITS+1];
+  int i, lg;
+  int totaluse = 0;
+  /* count elements in array part */
+  for (i=0, lg=0; lg<=MAXBITS; lg++) {  /* for each slice [2^(lg-1) to 2^lg) */
+    int ttlg = twoto(lg);  /* 2^lg */
+    if (ttlg > t->sizearray) {
+      ttlg = t->sizearray;
+      if (i >= ttlg) break;
+    }
+    nums[lg] = 0;
+    for (; i<ttlg; i++) {
+      if (!ttisnil(&t->array[i])) {
+        nums[lg]++;
+        totaluse++;
+      }
+    }
+  }
+  for (; lg<=MAXBITS; lg++) nums[lg] = 0;  /* reset other counts */
+  *narray = totaluse;  /* all previous uses were in array part */
+  /* count elements in hash part */
+  i = sizenode(t);
+  while (i--) {
+    Node *n = &t->node[i];
+    if (!ttisnil(gval(n))) {
+      int k = arrayindex(gkey(n));
+      if (k >= 0) {  /* is `key' an appropriate array index? */
+        nums[luaO_log2(k-1)+1]++;  /* count as such */
+        (*narray)++;
+      }
+      totaluse++;
+    }
+  }
+  computesizes(nums, totaluse, narray, nhash);
+}
+
+
+static void setarrayvector (lua_State *L, Table *t, int size) {
+  int i;
+  luaM_reallocvector(L, t->array, t->sizearray, size, TObject);
+  for (i=t->sizearray; i<size; i++)
+     setnilvalue(&t->array[i]);
+  t->sizearray = size;
+}
+
+
+static void setnodevector (lua_State *L, Table *t, int lsize) {
+  int i;
+  int size = twoto(lsize);
+  if (lsize > MAXBITS)
+    luaG_runerror(L, "table overflow");
+  if (lsize == 0) {  /* no elements to hash part? */
+    t->node = G(L)->dummynode;  /* use common `dummynode' */
+    lua_assert(ttisnil(gkey(t->node)));  /* assert invariants: */
+    lua_assert(ttisnil(gval(t->node)));
+    lua_assert(t->node->next == NULL);  /* (`dummynode' must be empty) */
+  }
+  else {
+    t->node = luaM_newvector(L, size, Node);
+    for (i=0; i<size; i++) {
+      t->node[i].next = NULL;
+      setnilvalue(gkey(gnode(t, i)));
+      setnilvalue(gval(gnode(t, i)));
+    }
+  }
+  t->lsizenode = cast(lu_byte, lsize);
+  t->firstfree = gnode(t, size-1);  /* first free position to be used */
+}
+
+
+static void resize (lua_State *L, Table *t, int nasize, int nhsize) {
+  int i;
+  int oldasize = t->sizearray;
+  int oldhsize = t->lsizenode;
+  Node *nold;
+  Node temp[1];
+  if (oldhsize)
+    nold = t->node;  /* save old hash ... */
+  else {  /* old hash is `dummynode' */
+    lua_assert(t->node == G(L)->dummynode);
+    temp[0] = t->node[0];  /* copy it to `temp' */
+    nold = temp;
+    setnilvalue(gkey(G(L)->dummynode));  /* restate invariant */
+    setnilvalue(gval(G(L)->dummynode));
+    lua_assert(G(L)->dummynode->next == NULL);
+  }
+  if (nasize > oldasize)  /* array part must grow? */
+    setarrayvector(L, t, nasize);
+  /* create new hash part with appropriate size */
+  setnodevector(L, t, nhsize);  
+  /* re-insert elements */
+  if (nasize < oldasize) {  /* array part must shrink? */
+    t->sizearray = nasize;
+    /* re-insert elements from vanishing slice */
+    for (i=nasize; i<oldasize; i++) {
+      if (!ttisnil(&t->array[i]))
+        setobjt2t(luaH_setnum(L, t, i+1), &t->array[i]);
+    }
+    /* shrink array */
+    luaM_reallocvector(L, t->array, oldasize, nasize, TObject);
+  }
+  /* re-insert elements in hash part */
+  for (i = twoto(oldhsize) - 1; i >= 0; i--) {
+    Node *old = nold+i;
+    if (!ttisnil(gval(old)))
+      setobjt2t(luaH_set(L, t, gkey(old)), gval(old));
+  }
+  if (oldhsize)
+    luaM_freearray(L, nold, twoto(oldhsize), Node);  /* free old array */
+}
+
+
+static void rehash (lua_State *L, Table *t) {
+  int nasize, nhsize;
+  numuse(t, &nasize, &nhsize);  /* compute new sizes for array and hash parts */
+  resize(L, t, nasize, luaO_log2(nhsize)+1);
+}
+
+
+
+/*
+** }=============================================================
+*/
+
+
+Table *luaH_new (lua_State *L, int narray, int lnhash) {
+  Table *t = luaM_new(L, Table);
+  luaC_link(L, valtogco(t), LUA_TTABLE);
+  t->metatable = hvalue(defaultmeta(L));
+  t->flags = cast(lu_byte, ~0);
+  /* temporary values (kept only if some malloc fails) */
+  t->array = NULL;
+  t->sizearray = 0;
+  t->lsizenode = 0;
+  t->node = NULL;
+  setarrayvector(L, t, narray);
+  setnodevector(L, t, lnhash);
+  return t;
+}
+
+
+void luaH_free (lua_State *L, Table *t) {
+  if (t->lsizenode)
+    luaM_freearray(L, t->node, sizenode(t), Node);
+  luaM_freearray(L, t->array, t->sizearray, TObject);
+  luaM_freelem(L, t);
+}
+
+
+#if 0
+/*
+** try to remove an element from a hash table; cannot move any element
+** (because gc can call `remove' during a table traversal)
+*/
+void luaH_remove (Table *t, Node *e) {
+  Node *mp = luaH_mainposition(t, gkey(e));
+  if (e != mp) {  /* element not in its main position? */
+    while (mp->next != e) mp = mp->next;  /* find previous */
+    mp->next = e->next;  /* remove `e' from its list */
+  }
+  else {
+    if (e->next != NULL) ??
+  }
+  lua_assert(ttisnil(gval(node)));
+  setnilvalue(gkey(e));  /* clear node `e' */
+  e->next = NULL;
+}
+#endif
+
+
+/*
+** inserts a new key into a hash table; first, check whether key's main 
+** position is free. If not, check whether colliding node is in its main 
+** position or not: if it is not, move colliding node to an empty place and 
+** put new key in its main position; otherwise (colliding node is in its main 
+** position), new key goes to an empty position. 
+*/
+static TObject *newkey (lua_State *L, Table *t, const TObject *key) {
+  TObject *val;
+  Node *mp = luaH_mainposition(t, key);
+  if (!ttisnil(gval(mp))) {  /* main position is not free? */
+    Node *othern = luaH_mainposition(t, gkey(mp));  /* `mp' of colliding node */
+    Node *n = t->firstfree;  /* get a free place */
+    if (othern != mp) {  /* is colliding node out of its main position? */
+      /* yes; move colliding node into free position */
+      while (othern->next != mp) othern = othern->next;  /* find previous */
+      othern->next = n;  /* redo the chain with `n' in place of `mp' */
+      *n = *mp;  /* copy colliding node into free pos. (mp->next also goes) */
+      mp->next = NULL;  /* now `mp' is free */
+      setnilvalue(gval(mp));
+    }
+    else {  /* colliding node is in its own main position */
+      /* new node will go into free position */
+      n->next = mp->next;  /* chain new position */
+      mp->next = n;
+      mp = n;
+    }
+  }
+  setobj2t(gkey(mp), key);  /* write barrier */
+  lua_assert(ttisnil(gval(mp)));
+  for (;;) {  /* correct `firstfree' */
+    if (ttisnil(gkey(t->firstfree)))
+      return gval(mp);  /* OK; table still has a free place */
+    else if (t->firstfree == t->node) break;  /* cannot decrement from here */
+    else (t->firstfree)--;
+  }
+  /* no more free places; must create one */
+  setbvalue(gval(mp), 0);  /* avoid new key being removed */
+  rehash(L, t);  /* grow table */
+  val = cast(TObject *, luaH_get(t, key));  /* get new position */
+  lua_assert(ttisboolean(val));
+  setnilvalue(val);
+  return val;
+}
+
+
+/*
+** generic search function
+*/
+static const TObject *luaH_getany (Table *t, const TObject *key) {
+  if (ttisnil(key)) return &luaO_nilobject;
+  else {
+    Node *n = luaH_mainposition(t, key);
+    do {  /* check whether `key' is somewhere in the chain */
+      if (luaO_rawequalObj(gkey(n), key)) return gval(n);  /* that's it */
+      else n = n->next;
+    } while (n);
+    return &luaO_nilobject;
+  }
+}
+
+
+/*
+** search function for integers
+*/
+const TObject *luaH_getnum (Table *t, int key) {
+  if (1 <= key && key <= t->sizearray)
+    return &t->array[key-1];
+  else {
+    lua_Number nk = cast(lua_Number, key);
+    Node *n = hashnum(t, nk);
+    do {  /* check whether `key' is somewhere in the chain */
+      if (ttisnumber(gkey(n)) && nvalue(gkey(n)) == nk)
+        return gval(n);  /* that's it */
+      else n = n->next;
+    } while (n);
+    return &luaO_nilobject;
+  }
+}
+
+
+/*
+** search function for strings
+*/
+const TObject *luaH_getstr (Table *t, TString *key) {
+  Node *n = hashstr(t, key);
+  do {  /* check whether `key' is somewhere in the chain */
+    if (ttisstring(gkey(n)) && tsvalue(gkey(n)) == key)
+      return gval(n);  /* that's it */
+    else n = n->next;
+  } while (n);
+  return &luaO_nilobject;
+}
+
+
+/*
+** main search function
+*/
+const TObject *luaH_get (Table *t, const TObject *key) {
+  switch (ttype(key)) {
+    case LUA_TSTRING: return luaH_getstr(t, tsvalue(key));
+    case LUA_TNUMBER: {
+      int k;
+      lua_number2int(k, (nvalue(key)));
+      if (cast(lua_Number, k) == nvalue(key))  /* is an integer index? */
+        return luaH_getnum(t, k);  /* use specialized version */
+      /* else go through */
+    }
+    default: return luaH_getany(t, key);
+  }
+}
+
+
+TObject *luaH_set (lua_State *L, Table *t, const TObject *key) {
+  const TObject *p = luaH_get(t, key);
+  t->flags = 0;
+  if (p != &luaO_nilobject)
+    return cast(TObject *, p);
+  else {
+    if (ttisnil(key)) luaG_runerror(L, "table index is nil");
+    else if (ttisnumber(key) && nvalue(key) != nvalue(key))
+      luaG_runerror(L, "table index is NaN");
+    return newkey(L, t, key);
+  }
+}
+
+
+TObject *luaH_setnum (lua_State *L, Table *t, int key) {
+  const TObject *p = luaH_getnum(t, key);
+  if (p != &luaO_nilobject)
+    return cast(TObject *, p);
+  else {
+    TObject k;
+    setnvalue(&k, cast(lua_Number, key));
+    return newkey(L, t, &k);
+  }
+}
+

Added: trunk/Util/deditor/lua/ltable.h
===================================================================
--- trunk/Util/deditor/lua/ltable.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ltable.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,31 @@
+/*
+** $Id: ltable.h,v 1.44 2003/03/18 12:50:04 roberto Exp $
+** Lua tables (hash)
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ltable_h
+#define ltable_h
+
+#include "lobject.h"
+
+
+#define gnode(t,i)	(&(t)->node[i])
+#define gkey(n)		(&(n)->i_key)
+#define gval(n)		(&(n)->i_val)
+
+
+const TObject *luaH_getnum (Table *t, int key);
+TObject *luaH_setnum (lua_State *L, Table *t, int key);
+const TObject *luaH_getstr (Table *t, TString *key);
+const TObject *luaH_get (Table *t, const TObject *key);
+TObject *luaH_set (lua_State *L, Table *t, const TObject *key);
+Table *luaH_new (lua_State *L, int narray, int lnhash);
+void luaH_free (lua_State *L, Table *t);
+int luaH_next (lua_State *L, Table *t, StkId key);
+
+/* exported only for debugging */
+Node *luaH_mainposition (const Table *t, const TObject *key);
+
+
+#endif

Added: trunk/Util/deditor/lua/ltests.c
===================================================================
--- trunk/Util/deditor/lua/ltests.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ltests.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,852 @@
+/*
+** $Id: ltests.c,v 1.158 2003/04/07 14:35:00 roberto Exp $
+** Internal Module for Debugging of the Lua Implementation
+** See Copyright Notice in lua.h
+*/
+
+
+#include <ctype.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define ltests_c
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "lauxlib.h"
+#include "lcode.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lmem.h"
+#include "lopcodes.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "lualib.h"
+
+
+
+/*
+** The whole module only makes sense with LUA_DEBUG on
+*/
+#ifdef LUA_DEBUG
+
+
+#define lua_pushintegral(L,i)	lua_pushnumber(L, cast(lua_Number, (i)))
+
+
+static lua_State *lua_state = NULL;
+
+int islocked = 0;
+
+
+#define func_at(L,k)	(L->ci->base+(k) - 1)
+
+
+static void setnameval (lua_State *L, const char *name, int val) {
+  lua_pushstring(L, name);
+  lua_pushintegral(L, val);
+  lua_settable(L, -3);
+}
+
+
+/*
+** {======================================================================
+** Controlled version for realloc.
+** =======================================================================
+*/
+
+#define MARK		0x55  /* 01010101 (a nice pattern) */
+
+#ifndef EXTERNMEMCHECK
+/* full memory check */
+#define HEADER	(sizeof(L_Umaxalign)) /* ensures maximum alignment for HEADER */
+#define MARKSIZE	16  /* size of marks after each block */
+#define blockhead(b)	(cast(char *, b) - HEADER)
+#define setsize(newblock, size)	(*cast(size_t *, newblock) = size)
+#define checkblocksize(b, size) (size == (*cast(size_t *, blockhead(b))))
+#define fillmem(mem,size)	memset(mem, -MARK, size)
+#else
+/* external memory check: don't do it twice */
+#define HEADER		0
+#define MARKSIZE	0
+#define blockhead(b)	(b)
+#define setsize(newblock, size)	/* empty */
+#define checkblocksize(b,size)	(1)
+#define fillmem(mem,size)	/* empty */
+#endif
+
+unsigned long memdebug_numblocks = 0;
+unsigned long memdebug_total = 0;
+unsigned long memdebug_maxmem = 0;
+unsigned long memdebug_memlimit = ULONG_MAX;
+
+
+static void *checkblock (void *block, size_t size) {
+  void *b = blockhead(block);
+  int i;
+  for (i=0;i<MARKSIZE;i++)
+    lua_assert(*(cast(char *, b)+HEADER+size+i) == MARK+i); /* corrupted block? */
+  return b;
+}
+
+
+static void freeblock (void *block, size_t size) {
+  if (block) {
+    lua_assert(checkblocksize(block, size));
+    block = checkblock(block, size);
+    fillmem(block, size+HEADER+MARKSIZE);  /* erase block */
+    free(block);  /* free original block */
+    memdebug_numblocks--;
+    memdebug_total -= size;
+  }
+}
+
+
+void *debug_realloc (void *block, size_t oldsize, size_t size) {
+  lua_assert(oldsize == 0 || checkblocksize(block, oldsize));
+  /* ISO does not specify what realloc(NULL, 0) does */
+  lua_assert(block != NULL || size > 0);
+  if (size == 0) {
+    freeblock(block, oldsize);
+    return NULL;
+  }
+  else if (size > oldsize && memdebug_total+size-oldsize > memdebug_memlimit)
+    return NULL;  /* to test memory allocation errors */
+  else {
+    void *newblock;
+    int i;
+    size_t realsize = HEADER+size+MARKSIZE;
+    size_t commonsize = (oldsize < size) ? oldsize : size;
+    if (realsize < size) return NULL;  /* overflow! */
+    newblock = malloc(realsize);  /* alloc a new block */
+    if (newblock == NULL) return NULL;
+    if (block) {
+      memcpy(cast(char *, newblock)+HEADER, block, commonsize);
+      freeblock(block, oldsize);  /* erase (and check) old copy */
+    }
+    /* initialize new part of the block with something `weird' */
+    fillmem(cast(char *, newblock)+HEADER+commonsize, size-commonsize);
+    memdebug_total += size;
+    if (memdebug_total > memdebug_maxmem)
+      memdebug_maxmem = memdebug_total;
+    memdebug_numblocks++;
+    setsize(newblock, size);
+    for (i=0;i<MARKSIZE;i++)
+      *(cast(char *, newblock)+HEADER+size+i) = cast(char, MARK+i);
+    return cast(char *, newblock)+HEADER;
+  }
+}
+
+
+/* }====================================================================== */
+
+
+
+/*
+** {======================================================
+** Disassembler
+** =======================================================
+*/
+
+
+static char *buildop (Proto *p, int pc, char *buff) {
+  Instruction i = p->code[pc];
+  OpCode o = GET_OPCODE(i);
+  const char *name = luaP_opnames[o];
+  int line = getline(p, pc);
+  sprintf(buff, "(%4d) %4d - ", line, pc);
+  switch (getOpMode(o)) {  
+    case iABC:
+      sprintf(buff+strlen(buff), "%-12s%4d %4d %4d", name,
+              GETARG_A(i), GETARG_B(i), GETARG_C(i));
+      break;
+    case iABx:
+      sprintf(buff+strlen(buff), "%-12s%4d %4d", name, GETARG_A(i), GETARG_Bx(i));
+      break;
+    case iAsBx:
+      sprintf(buff+strlen(buff), "%-12s%4d %4d", name, GETARG_A(i), GETARG_sBx(i));
+      break;
+  }
+  return buff;
+}
+
+
+#if 0
+void luaI_printcode (Proto *pt, int size) {
+  int pc;
+  for (pc=0; pc<size; pc++) {
+    char buff[100];
+    printf("%s\n", buildop(pt, pc, buff));
+  }
+  printf("-------\n");
+}
+#endif
+
+
+static int listcode (lua_State *L) {
+  int pc;
+  Proto *p;
+  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),
+                 1, "Lua function expected");
+  p = clvalue(func_at(L, 1))->l.p;
+  lua_newtable(L);
+  setnameval(L, "maxstack", p->maxstacksize);
+  setnameval(L, "numparams", p->numparams);
+  for (pc=0; pc<p->sizecode; pc++) {
+    char buff[100];
+    lua_pushintegral(L, pc+1);
+    lua_pushstring(L, buildop(p, pc, buff));
+    lua_settable(L, -3);
+  }
+  return 1;
+}
+
+
+static int listk (lua_State *L) {
+  Proto *p;
+  int i;
+  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),
+                 1, "Lua function expected");
+  p = clvalue(func_at(L, 1))->l.p;
+  lua_newtable(L);
+  for (i=0; i<p->sizek; i++) {
+    lua_pushintegral(L, i+1);
+    luaA_pushobject(L, p->k+i);
+    lua_settable(L, -3);
+  }
+  return 1;
+}
+
+
+static int listlocals (lua_State *L) {
+  Proto *p;
+  int pc = luaL_checkint(L, 2) - 1;
+  int i = 0;
+  const char *name;
+  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),
+                 1, "Lua function expected");
+  p = clvalue(func_at(L, 1))->l.p;
+  while ((name = luaF_getlocalname(p, ++i, pc)) != NULL)
+    lua_pushstring(L, name);
+  return i-1;
+}
+
+/* }====================================================== */
+
+
+
+
+static int get_limits (lua_State *L) {
+  lua_newtable(L);
+  setnameval(L, "BITS_INT", BITS_INT);
+  setnameval(L, "LFPF", LFIELDS_PER_FLUSH);
+  setnameval(L, "MAXVARS", MAXVARS);
+  setnameval(L, "MAXPARAMS", MAXPARAMS);
+  setnameval(L, "MAXSTACK", MAXSTACK);
+  setnameval(L, "MAXUPVALUES", MAXUPVALUES);
+  return 1;
+}
+
+
+static int mem_query (lua_State *L) {
+  if (lua_isnone(L, 1)) {
+    lua_pushintegral(L, memdebug_total);
+    lua_pushintegral(L, memdebug_numblocks);
+    lua_pushintegral(L, memdebug_maxmem);
+    return 3;
+  }
+  else {
+    memdebug_memlimit = luaL_checkint(L, 1);
+    return 0;
+  }
+}
+
+
+static int hash_query (lua_State *L) {
+  if (lua_isnone(L, 2)) {
+    luaL_argcheck(L, lua_type(L, 1) == LUA_TSTRING, 1, "string expected");
+    lua_pushintegral(L, tsvalue(func_at(L, 1))->tsv.hash);
+  }
+  else {
+    TObject *o = func_at(L, 1);
+    Table *t;
+    luaL_checktype(L, 2, LUA_TTABLE);
+    t = hvalue(func_at(L, 2));
+    lua_pushintegral(L, luaH_mainposition(t, o) - t->node);
+  }
+  return 1;
+}
+
+
+static int stacklevel (lua_State *L) {
+  unsigned long a = 0;
+  lua_pushintegral(L, (int)(L->top - L->stack));
+  lua_pushintegral(L, (int)(L->stack_last - L->stack));
+  lua_pushintegral(L, (int)(L->ci - L->base_ci));
+  lua_pushintegral(L, (int)(L->end_ci - L->base_ci));
+  lua_pushintegral(L, (unsigned long)&a);
+  return 5;
+}
+
+
+static int table_query (lua_State *L) {
+  const Table *t;
+  int i = luaL_optint(L, 2, -1);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  t = hvalue(func_at(L, 1));
+  if (i == -1) {
+    lua_pushintegral(L, t->sizearray);
+    lua_pushintegral(L, sizenode(t));
+    lua_pushintegral(L, t->firstfree - t->node);
+  }
+  else if (i < t->sizearray) {
+    lua_pushintegral(L, i);
+    luaA_pushobject(L, &t->array[i]);
+    lua_pushnil(L); 
+  }
+  else if ((i -= t->sizearray) < sizenode(t)) {
+    if (!ttisnil(gval(gnode(t, i))) ||
+        ttisnil(gkey(gnode(t, i))) ||
+        ttisnumber(gkey(gnode(t, i)))) {
+      luaA_pushobject(L, gkey(gnode(t, i)));
+    }
+    else
+      lua_pushstring(L, "<undef>");
+    luaA_pushobject(L, gval(gnode(t, i)));
+    if (t->node[i].next)
+      lua_pushintegral(L, t->node[i].next - t->node);
+    else
+      lua_pushnil(L);
+  }
+  return 3;
+}
+
+
+static int string_query (lua_State *L) {
+  stringtable *tb = &G(L)->strt;
+  int s = luaL_optint(L, 2, 0) - 1;
+  if (s==-1) {
+    lua_pushintegral(L ,tb->nuse);
+    lua_pushintegral(L ,tb->size);
+    return 2;
+  }
+  else if (s < tb->size) {
+    GCObject *ts;
+    int n = 0;
+    for (ts = tb->hash[s]; ts; ts = ts->gch.next) {
+      setsvalue2s(L->top, gcotots(ts));
+      incr_top(L);
+      n++;
+    }
+    return n;
+  }
+  return 0;
+}
+
+
+static int tref (lua_State *L) {
+  int level = lua_gettop(L);
+  int lock = luaL_optint(L, 2, 1);
+  luaL_checkany(L, 1);
+  lua_pushvalue(L, 1);
+  lua_pushintegral(L, lua_ref(L, lock));
+  assert(lua_gettop(L) == level+1);  /* +1 for result */
+  return 1;
+}
+
+static int getref (lua_State *L) {
+  int level = lua_gettop(L);
+  lua_getref(L, luaL_checkint(L, 1));
+  assert(lua_gettop(L) == level+1);
+  return 1;
+}
+
+static int unref (lua_State *L) {
+  int level = lua_gettop(L);
+  lua_unref(L, luaL_checkint(L, 1));
+  assert(lua_gettop(L) == level);
+  return 0;
+}
+
+static int metatable (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (lua_isnone(L, 2)) {
+    if (lua_getmetatable(L, 1) == 0)
+      lua_pushnil(L);
+  }
+  else {
+    lua_settop(L, 2);
+    luaL_checktype(L, 2, LUA_TTABLE);
+    lua_setmetatable(L, 1);
+  }
+  return 1;
+}
+
+
+static int upvalue (lua_State *L) {
+  int n = luaL_checkint(L, 2);
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  if (lua_isnone(L, 3)) {
+    const char *name = lua_getupvalue(L, 1, n);
+    if (name == NULL) return 0;
+    lua_pushstring(L, name);
+    return 2;
+  }
+  else {
+    const char *name = lua_setupvalue(L, 1, n);
+    lua_pushstring(L, name);
+    return 1;
+  }
+}
+
+
+static int newuserdata (lua_State *L) {
+  size_t size = luaL_checkint(L, 1);
+  char *p = cast(char *, lua_newuserdata(L, size));
+  while (size--) *p++ = '\0';
+  return 1;
+}
+
+
+static int pushuserdata (lua_State *L) {
+  lua_pushlightuserdata(L, cast(void *, luaL_checkint(L, 1)));
+  return 1;
+}
+
+
+static int udataval (lua_State *L) {
+  lua_pushintegral(L, cast(int, lua_touserdata(L, 1)));
+  return 1;
+}
+
+
+static int doonnewstack (lua_State *L) {
+  lua_State *L1 = lua_newthread(L);
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &l);
+  int status = luaL_loadbuffer(L1, s, l, s);
+  if (status == 0)
+    status = lua_pcall(L1, 0, 0, 0);
+  lua_pushintegral(L, status);
+  return 1;
+}
+
+
+static int s2d (lua_State *L) {
+  lua_pushnumber(L, *cast(const double *, luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int d2s (lua_State *L) {
+  double d = luaL_checknumber(L, 1);
+  lua_pushlstring(L, cast(char *, &d), sizeof(d));
+  return 1;
+}
+
+
+static int newstate (lua_State *L) {
+  lua_State *L1 = lua_open();
+  if (L1) {
+    lua_userstateopen(L1);  /* init lock */
+    lua_pushintegral(L, (unsigned long)L1);
+  }
+  else
+    lua_pushnil(L);
+  return 1;
+}
+
+
+static int loadlib (lua_State *L) {
+  static const luaL_reg libs[] = {
+    {"mathlibopen", luaopen_math},
+    {"strlibopen", luaopen_string},
+    {"iolibopen", luaopen_io},
+    {"tablibopen", luaopen_table},
+    {"dblibopen", luaopen_debug},
+    {"baselibopen", luaopen_base},
+    {NULL, NULL}
+  };
+  lua_State *L1 = cast(lua_State *,
+                       cast(unsigned long, luaL_checknumber(L, 1)));
+  lua_pushvalue(L1, LUA_GLOBALSINDEX);
+  luaL_openlib(L1, NULL, libs, 0);
+  return 0;
+}
+
+static int closestate (lua_State *L) {
+  lua_State *L1 = cast(lua_State *, cast(unsigned long, luaL_checknumber(L, 1)));
+  lua_close(L1);
+  lua_unlock(L);  /* close cannot unlock that */
+  return 0;
+}
+
+static int doremote (lua_State *L) {
+  lua_State *L1 = cast(lua_State *,cast(unsigned long,luaL_checknumber(L, 1)));
+  size_t lcode;
+  const char *code = luaL_checklstring(L, 2, &lcode);
+  int status;
+  lua_settop(L1, 0);
+  status = luaL_loadbuffer(L1, code, lcode, code);
+  if (status == 0)
+    status = lua_pcall(L1, 0, LUA_MULTRET, 0);
+  if (status != 0) {
+    lua_pushnil(L);
+    lua_pushintegral(L, status);
+    lua_pushstring(L, lua_tostring(L1, -1));
+    return 3;
+  }
+  else {
+    int i = 0;
+    while (!lua_isnone(L1, ++i))
+      lua_pushstring(L, lua_tostring(L1, i));
+    lua_pop(L1, i-1);
+    return i-1;
+  }
+}
+
+
+static int log2_aux (lua_State *L) {
+  lua_pushintegral(L, luaO_log2(luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int int2fb_aux (lua_State *L) {
+  int b = luaO_int2fb(luaL_checkint(L, 1));
+  lua_pushintegral(L, b);
+  lua_pushintegral(L, fb2int(b));
+  return 2;
+}
+
+
+static int test_do (lua_State *L) {
+  const char *p = luaL_checkstring(L, 1);
+  if (*p == '@')
+    lua_dofile(L, p+1);
+  else
+    lua_dostring(L, p);
+  return lua_gettop(L);
+}
+
+
+
+/*
+** {======================================================
+** function to test the API with C. It interprets a kind of assembler
+** language with calls to the API, so the test can be driven by Lua code
+** =======================================================
+*/
+
+static const char *const delimits = " \t\n,;";
+
+static void skip (const char **pc) {
+  while (**pc != '\0' && strchr(delimits, **pc)) (*pc)++;
+}
+
+static int getnum_aux (lua_State *L, const char **pc) {
+  int res = 0;
+  int sig = 1;
+  skip(pc);
+  if (**pc == '.') {
+    res = cast(int, lua_tonumber(L, -1));
+    lua_pop(L, 1);
+    (*pc)++;
+    return res;
+  }
+  else if (**pc == '-') {
+    sig = -1;
+    (*pc)++;
+  }
+  while (isdigit(cast(int, **pc))) res = res*10 + (*(*pc)++) - '0';
+  return sig*res;
+}
+  
+static const char *getname_aux (char *buff, const char **pc) {
+  int i = 0;
+  skip(pc);
+  while (**pc != '\0' && !strchr(delimits, **pc))
+    buff[i++] = *(*pc)++;
+  buff[i] = '\0';
+  return buff;
+}
+
+
+#define EQ(s1)	(strcmp(s1, inst) == 0)
+
+#define getnum	(getnum_aux(L, &pc))
+#define getname	(getname_aux(buff, &pc))
+
+
+static int testC (lua_State *L) {
+  char buff[30];
+  const char *pc = luaL_checkstring(L, 1);
+  for (;;) {
+    const char *inst = getname;
+    if EQ("") return 0;
+    else if EQ("isnumber") {
+      lua_pushintegral(L, lua_isnumber(L, getnum));
+    }
+    else if EQ("isstring") {
+      lua_pushintegral(L, lua_isstring(L, getnum));
+    }
+    else if EQ("istable") {
+      lua_pushintegral(L, lua_istable(L, getnum));
+    }
+    else if EQ("iscfunction") {
+      lua_pushintegral(L, lua_iscfunction(L, getnum));
+    }
+    else if EQ("isfunction") {
+      lua_pushintegral(L, lua_isfunction(L, getnum));
+    }
+    else if EQ("isuserdata") {
+      lua_pushintegral(L, lua_isuserdata(L, getnum));
+    }
+    else if EQ("isudataval") {
+      lua_pushintegral(L, lua_islightuserdata(L, getnum));
+    }
+    else if EQ("isnil") {
+      lua_pushintegral(L, lua_isnil(L, getnum));
+    }
+    else if EQ("isnull") {
+      lua_pushintegral(L, lua_isnone(L, getnum));
+    }
+    else if EQ("tonumber") {
+      lua_pushnumber(L, lua_tonumber(L, getnum));
+    }
+    else if EQ("tostring") {
+      const char *s = lua_tostring(L, getnum);
+      lua_pushstring(L, s);
+    }
+    else if EQ("strlen") {
+      lua_pushintegral(L, lua_strlen(L, getnum));
+    }
+    else if EQ("tocfunction") {
+      lua_pushcfunction(L, lua_tocfunction(L, getnum));
+    }
+    else if EQ("return") {
+      return getnum;
+    }
+    else if EQ("gettop") {
+      lua_pushintegral(L, lua_gettop(L));
+    }
+    else if EQ("settop") {
+      lua_settop(L, getnum);
+    }
+    else if EQ("pop") {
+      lua_pop(L, getnum);
+    }
+    else if EQ("pushnum") {
+      lua_pushintegral(L, getnum);
+    }
+    else if EQ("pushnil") {
+      lua_pushnil(L);
+    }
+    else if EQ("pushbool") {
+      lua_pushboolean(L, getnum);
+    }
+    else if EQ("tobool") {
+      lua_pushintegral(L, lua_toboolean(L, getnum));
+    }
+    else if EQ("pushvalue") {
+      lua_pushvalue(L, getnum);
+    }
+    else if EQ("pushcclosure") {
+      lua_pushcclosure(L, testC, getnum);
+    }
+    else if EQ("pushupvalues") {
+      lua_pushupvalues(L);
+    }
+    else if EQ("remove") {
+      lua_remove(L, getnum);
+    }
+    else if EQ("insert") {
+      lua_insert(L, getnum);
+    }
+    else if EQ("replace") {
+      lua_replace(L, getnum);
+    }
+    else if EQ("gettable") {
+      lua_gettable(L, getnum);
+    }
+    else if EQ("settable") {
+      lua_settable(L, getnum);
+    }
+    else if EQ("next") {
+      lua_next(L, -2);
+    }
+    else if EQ("concat") {
+      lua_concat(L, getnum);
+    }
+    else if EQ("lessthan") {
+      int a = getnum;
+      lua_pushboolean(L, lua_lessthan(L, a, getnum));
+    }
+    else if EQ("equal") {
+      int a = getnum;
+      lua_pushboolean(L, lua_equal(L, a, getnum));
+    }
+    else if EQ("rawcall") {
+      int narg = getnum;
+      int nres = getnum;
+      lua_call(L, narg, nres);
+    }
+    else if EQ("call") {
+      int narg = getnum;
+      int nres = getnum;
+      lua_pcall(L, narg, nres, 0);
+    }
+    else if EQ("loadstring") {
+      size_t sl;
+      const char *s = luaL_checklstring(L, getnum, &sl);
+      luaL_loadbuffer(L, s, sl, s);
+    }
+    else if EQ("loadfile") {
+      luaL_loadfile(L, luaL_checkstring(L, getnum));
+    }
+    else if EQ("setmetatable") {
+      lua_setmetatable(L, getnum);
+    }
+    else if EQ("getmetatable") {
+      if (lua_getmetatable(L, getnum) == 0)
+        lua_pushnil(L);
+    }
+    else if EQ("type") {
+      lua_pushstring(L, lua_typename(L, lua_type(L, getnum)));
+    }
+    else if EQ("getn") {
+      int i = getnum;
+      lua_pushintegral(L, luaL_getn(L, i));
+    }
+    else if EQ("setn") {
+      int i = getnum;
+      int n = cast(int, lua_tonumber(L, -1));
+      luaL_setn(L, i, n);
+      lua_pop(L, 1);
+    }
+    else luaL_error(L, "unknown instruction %s", buff);
+  }
+  return 0;
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** tests for yield inside hooks
+** =======================================================
+*/
+
+static void yieldf (lua_State *L, lua_Debug *ar) {
+  lua_yield(L, 0);
+}
+
+static int setyhook (lua_State *L) {
+  if (lua_isnoneornil(L, 1))
+    lua_sethook(L, NULL, 0, 0);  /* turn off hooks */
+  else {
+    const char *smask = luaL_checkstring(L, 1);
+    int count = luaL_optint(L, 2, 0);
+    int mask = 0;
+    if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
+    if (count > 0) mask |= LUA_MASKCOUNT;
+    lua_sethook(L, yieldf, mask, count);
+  }
+  return 0;
+}
+
+
+static int coresume (lua_State *L) {
+  int status;
+  lua_State *co = lua_tothread(L, 1);
+  luaL_argcheck(L, co, 1, "coroutine expected");
+  status = lua_resume(co, 0);
+  if (status != 0) {
+    lua_pushboolean(L, 0);
+    lua_insert(L, -2);
+    return 2;  /* return false + error message */
+  }
+  else {
+    lua_pushboolean(L, 1);
+    return 1;
+  }
+}
+
+/* }====================================================== */
+
+
+
+static const struct luaL_reg tests_funcs[] = {
+  {"hash", hash_query},
+  {"limits", get_limits},
+  {"listcode", listcode},
+  {"listk", listk},
+  {"listlocals", listlocals},
+  {"loadlib", loadlib},
+  {"stacklevel", stacklevel},
+  {"querystr", string_query},
+  {"querytab", table_query},
+  {"doit", test_do},
+  {"testC", testC},
+  {"ref", tref},
+  {"getref", getref},
+  {"unref", unref},
+  {"d2s", d2s},
+  {"s2d", s2d},
+  {"metatable", metatable},
+  {"upvalue", upvalue},
+  {"newuserdata", newuserdata},
+  {"pushuserdata", pushuserdata},
+  {"udataval", udataval},
+  {"doonnewstack", doonnewstack},
+  {"newstate", newstate},
+  {"closestate", closestate},
+  {"doremote", doremote},
+  {"log2", log2_aux},
+  {"int2fb", int2fb_aux},
+  {"totalmem", mem_query},
+  {"resume", coresume},
+  {"setyhook", setyhook},
+  {NULL, NULL}
+};
+
+
+static void fim (void) {
+  if (!islocked)
+    lua_close(lua_state);
+  lua_assert(memdebug_numblocks == 0);
+  lua_assert(memdebug_total == 0);
+}
+
+
+static int l_panic (lua_State *L) {
+  UNUSED(L);
+  fprintf(stderr, "unable to recover; exiting\n");
+  return 0;
+}
+
+
+int luaB_opentests (lua_State *L) {
+  lua_atpanic(L, l_panic);
+  lua_userstateopen(L);  /* init lock */
+  lua_state = L;  /* keep first state to be opened */
+  luaL_openlib(L, "T", tests_funcs, 0);
+  atexit(fim);
+  return 0;
+}
+
+
+#undef main
+int main (int argc, char *argv[]) {
+  char *limit = getenv("MEMLIMIT");
+  if (limit)
+    memdebug_memlimit = strtoul(limit, NULL, 10);
+  l_main(argc, argv);
+  return 0;
+}
+
+#endif

Added: trunk/Util/deditor/lua/ltm.c
===================================================================
--- trunk/Util/deditor/lua/ltm.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ltm.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,70 @@
+/*
+** $Id: ltm.c,v 1.106 2003/04/03 13:35:34 roberto Exp $
+** Tag methods
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define ltm_c
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+
+
+
+const char *const luaT_typenames[] = {
+  "nil", "boolean", "userdata", "number",
+  "string", "table", "function", "userdata", "thread"
+};
+
+
+void luaT_init (lua_State *L) {
+  static const char *const luaT_eventname[] = {  /* ORDER TM */
+    "__index", "__newindex",
+    "__gc", "__mode", "__eq",
+    "__add", "__sub", "__mul", "__div",
+    "__pow", "__unm", "__lt", "__le",
+    "__concat", "__call"
+  };
+  int i;
+  for (i=0; i<TM_N; i++) {
+    G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);
+    luaS_fix(G(L)->tmname[i]);  /* never collect these names */
+  }
+}
+
+
+/*
+** function to be used with macro "fasttm": optimized for absence of
+** tag methods
+*/
+const TObject *luaT_gettm (Table *events, TMS event, TString *ename) {
+  const TObject *tm = luaH_getstr(events, ename);
+  lua_assert(event <= TM_EQ);
+  if (ttisnil(tm)) {  /* no tag method? */
+    events->flags |= cast(lu_byte, 1u<<event);  /* cache this fact */
+    return NULL;
+  }
+  else return tm;
+}
+
+
+const TObject *luaT_gettmbyobj (lua_State *L, const TObject *o, TMS event) {
+  TString *ename = G(L)->tmname[event];
+  switch (ttype(o)) {
+    case LUA_TTABLE:
+      return luaH_getstr(hvalue(o)->metatable, ename);
+    case LUA_TUSERDATA:
+      return luaH_getstr(uvalue(o)->uv.metatable, ename);
+    default:
+      return &luaO_nilobject;
+  }
+}
+

Added: trunk/Util/deditor/lua/ltm.h
===================================================================
--- trunk/Util/deditor/lua/ltm.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ltm.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,51 @@
+/*
+** $Id: ltm.h,v 1.41 2002/11/14 11:51:50 roberto Exp $
+** Tag methods
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ltm_h
+#define ltm_h
+
+
+#include "lobject.h"
+
+
+/*
+* WARNING: if you change the order of this enumeration,
+* grep "ORDER TM"
+*/
+typedef enum {
+  TM_INDEX,
+  TM_NEWINDEX,
+  TM_GC,
+  TM_MODE,
+  TM_EQ,  /* last tag method with `fast' access */
+  TM_ADD,
+  TM_SUB,
+  TM_MUL,
+  TM_DIV,
+  TM_POW,
+  TM_UNM,
+  TM_LT,
+  TM_LE,
+  TM_CONCAT,
+  TM_CALL,
+  TM_N		/* number of elements in the enum */
+} TMS;
+
+
+
+#define gfasttm(g,et,e) \
+  (((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
+
+#define fasttm(l,et,e)	gfasttm(G(l), et, e)
+
+
+const TObject *luaT_gettm (Table *events, TMS event, TString *ename);
+const TObject *luaT_gettmbyobj (lua_State *L, const TObject *o, TMS event);
+void luaT_init (lua_State *L);
+
+extern const char *const luaT_typenames[];
+
+#endif

Added: trunk/Util/deditor/lua/lua.h
===================================================================
--- trunk/Util/deditor/lua/lua.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lua.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,391 @@
+/*
+** $Id: lua.h,v 1.175 2003/03/18 12:31:39 roberto Exp $
+** Lua - An Extensible Extension Language
+** Tecgraf: Computer Graphics Technology Group, PUC-Rio, Brazil
+** http://www.lua.org	mailto:info at lua.org
+** See Copyright Notice at the end of this file
+*/
+
+
+#ifndef lua_h
+#define lua_h
+
+#include <stdarg.h>
+#include <stddef.h>
+
+
+#define LUA_VERSION	"Lua 5.0"
+#define LUA_COPYRIGHT	"Copyright (C) 1994-2003 Tecgraf, PUC-Rio"
+#define LUA_AUTHORS 	"R. Ierusalimschy, L. H. de Figueiredo & W. Celes"
+
+
+
+/* option for multiple returns in `lua_pcall' and `lua_call' */
+#define LUA_MULTRET	(-1)
+
+
+/*
+** pseudo-indices
+*/
+#define LUA_REGISTRYINDEX	(-10000)
+#define LUA_GLOBALSINDEX	(-10001)
+#define lua_upvalueindex(i)	(LUA_GLOBALSINDEX-(i))
+
+
+/* error codes for `lua_load' and `lua_pcall' */
+#define LUA_ERRRUN	1
+#define LUA_ERRFILE	2
+#define LUA_ERRSYNTAX	3
+#define LUA_ERRMEM	4
+#define LUA_ERRERR	5
+
+
+typedef struct lua_State lua_State;
+
+typedef int (*lua_CFunction) (lua_State *L);
+
+
+/*
+** functions that read/write blocks when loading/dumping Lua chunks
+*/
+typedef const char * (*lua_Chunkreader) (lua_State *L, void *ud, size_t *sz);
+
+typedef int (*lua_Chunkwriter) (lua_State *L, const void* p,
+                                size_t sz, void* ud);
+
+
+/*
+** basic types
+*/
+#define LUA_TNONE	(-1)
+
+#define LUA_TNIL	0
+#define LUA_TBOOLEAN	1
+#define LUA_TLIGHTUSERDATA	2
+#define LUA_TNUMBER	3
+#define LUA_TSTRING	4
+#define LUA_TTABLE	5
+#define LUA_TFUNCTION	6
+#define LUA_TUSERDATA	7
+#define LUA_TTHREAD	8
+
+
+/* minimum Lua stack available to a C function */
+#define LUA_MINSTACK	20
+
+
+/*
+** generic extra include file
+*/
+#ifdef LUA_USER_H
+#include LUA_USER_H
+#endif
+
+
+/* type of numbers in Lua */
+#ifndef LUA_NUMBER
+typedef double lua_Number;
+#else
+typedef LUA_NUMBER lua_Number;
+#endif
+
+
+/* mark for all API functions */
+#ifndef LUA_API
+#define LUA_API		extern
+#endif
+
+
+/*
+** state manipulation
+*/
+LUA_API lua_State *lua_open (void);
+LUA_API void       lua_close (lua_State *L);
+LUA_API lua_State *lua_newthread (lua_State *L);
+
+LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);
+
+
+/*
+** basic stack manipulation
+*/
+LUA_API int   lua_gettop (lua_State *L);
+LUA_API void  lua_settop (lua_State *L, int idx);
+LUA_API void  lua_pushvalue (lua_State *L, int idx);
+LUA_API void  lua_remove (lua_State *L, int idx);
+LUA_API void  lua_insert (lua_State *L, int idx);
+LUA_API void  lua_replace (lua_State *L, int idx);
+LUA_API int   lua_checkstack (lua_State *L, int sz);
+
+LUA_API void  lua_xmove (lua_State *from, lua_State *to, int n);
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API int             lua_isnumber (lua_State *L, int idx);
+LUA_API int             lua_isstring (lua_State *L, int idx);
+LUA_API int             lua_iscfunction (lua_State *L, int idx);
+LUA_API int             lua_isuserdata (lua_State *L, int idx);
+LUA_API int             lua_type (lua_State *L, int idx);
+LUA_API const char     *lua_typename (lua_State *L, int tp);
+
+LUA_API int            lua_equal (lua_State *L, int idx1, int idx2);
+LUA_API int            lua_rawequal (lua_State *L, int idx1, int idx2);
+LUA_API int            lua_lessthan (lua_State *L, int idx1, int idx2);
+
+LUA_API lua_Number      lua_tonumber (lua_State *L, int idx);
+LUA_API int             lua_toboolean (lua_State *L, int idx);
+LUA_API const char     *lua_tostring (lua_State *L, int idx);
+LUA_API size_t          lua_strlen (lua_State *L, int idx);
+LUA_API lua_CFunction   lua_tocfunction (lua_State *L, int idx);
+LUA_API void	       *lua_touserdata (lua_State *L, int idx);
+LUA_API lua_State      *lua_tothread (lua_State *L, int idx);
+LUA_API const void     *lua_topointer (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  lua_pushnil (lua_State *L);
+LUA_API void  lua_pushnumber (lua_State *L, lua_Number n);
+LUA_API void  lua_pushlstring (lua_State *L, const char *s, size_t l);
+LUA_API void  lua_pushstring (lua_State *L, const char *s);
+LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
+                                                    va_list argp);
+LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...);
+LUA_API void  lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);
+LUA_API void  lua_pushboolean (lua_State *L, int b);
+LUA_API void  lua_pushlightuserdata (lua_State *L, void *p);
+
+
+/*
+** get functions (Lua -> stack)
+*/
+LUA_API void  lua_gettable (lua_State *L, int idx);
+LUA_API void  lua_rawget (lua_State *L, int idx);
+LUA_API void  lua_rawgeti (lua_State *L, int idx, int n);
+LUA_API void  lua_newtable (lua_State *L);
+LUA_API void *lua_newuserdata (lua_State *L, size_t sz);
+LUA_API int   lua_getmetatable (lua_State *L, int objindex);
+LUA_API void  lua_getfenv (lua_State *L, int idx);
+
+
+/*
+** set functions (stack -> Lua)
+*/
+LUA_API void  lua_settable (lua_State *L, int idx);
+LUA_API void  lua_rawset (lua_State *L, int idx);
+LUA_API void  lua_rawseti (lua_State *L, int idx, int n);
+LUA_API int   lua_setmetatable (lua_State *L, int objindex);
+LUA_API int   lua_setfenv (lua_State *L, int idx);
+
+
+/*
+** `load' and `call' functions (load and run Lua code)
+*/
+LUA_API void  lua_call (lua_State *L, int nargs, int nresults);
+LUA_API int   lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);
+LUA_API int lua_cpcall (lua_State *L, lua_CFunction func, void *ud);
+LUA_API int   lua_load (lua_State *L, lua_Chunkreader reader, void *dt,
+                        const char *chunkname);
+
+LUA_API int lua_dump (lua_State *L, lua_Chunkwriter writer, void *data);
+
+
+/*
+** coroutine functions
+*/
+LUA_API int  lua_yield (lua_State *L, int nresults);
+LUA_API int  lua_resume (lua_State *L, int narg);
+
+/*
+** garbage-collection functions
+*/
+LUA_API int   lua_getgcthreshold (lua_State *L);
+LUA_API int   lua_getgccount (lua_State *L);
+LUA_API void  lua_setgcthreshold (lua_State *L, int newthreshold);
+
+/*
+** miscellaneous functions
+*/
+
+LUA_API const char *lua_version (void);
+
+LUA_API int   lua_error (lua_State *L);
+
+LUA_API int   lua_next (lua_State *L, int idx);
+
+LUA_API void  lua_concat (lua_State *L, int n);
+
+
+
+/* 
+** ===============================================================
+** some useful macros
+** ===============================================================
+*/
+
+#define lua_boxpointer(L,u) \
+	(*(void **)(lua_newuserdata(L, sizeof(void *))) = (u))
+
+#define lua_unboxpointer(L,i)	(*(void **)(lua_touserdata(L, i)))
+
+#define lua_pop(L,n)		lua_settop(L, -(n)-1)
+
+#define lua_register(L,n,f) \
+	(lua_pushstring(L, n), \
+	 lua_pushcfunction(L, f), \
+	 lua_settable(L, LUA_GLOBALSINDEX))
+
+#define lua_pushcfunction(L,f)	lua_pushcclosure(L, f, 0)
+
+#define lua_isfunction(L,n)	(lua_type(L,n) == LUA_TFUNCTION)
+#define lua_istable(L,n)	(lua_type(L,n) == LUA_TTABLE)
+#define lua_islightuserdata(L,n)	(lua_type(L,n) == LUA_TLIGHTUSERDATA)
+#define lua_isnil(L,n)		(lua_type(L,n) == LUA_TNIL)
+#define lua_isboolean(L,n)	(lua_type(L,n) == LUA_TBOOLEAN)
+#define lua_isnone(L,n)		(lua_type(L,n) == LUA_TNONE)
+#define lua_isnoneornil(L, n)	(lua_type(L,n) <= 0)
+
+#define lua_pushliteral(L, s)	\
+	lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
+
+
+
+/*
+** compatibility macros and functions
+*/
+
+
+LUA_API int lua_pushupvalues (lua_State *L);
+
+#define lua_getregistry(L)	lua_pushvalue(L, LUA_REGISTRYINDEX)
+#define lua_setglobal(L,s)	\
+   (lua_pushstring(L, s), lua_insert(L, -2), lua_settable(L, LUA_GLOBALSINDEX))
+
+#define lua_getglobal(L,s)	\
+		(lua_pushstring(L, s), lua_gettable(L, LUA_GLOBALSINDEX))
+
+
+/* compatibility with ref system */
+
+/* pre-defined references */
+#define LUA_NOREF	(-2)
+#define LUA_REFNIL	(-1)
+
+#define lua_ref(L,lock)	((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : \
+      (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))
+
+#define lua_unref(L,ref)	luaL_unref(L, LUA_REGISTRYINDEX, (ref))
+
+#define lua_getref(L,ref)	lua_rawgeti(L, LUA_REGISTRYINDEX, ref)
+
+
+
+/*
+** {======================================================================
+** useful definitions for Lua kernel and libraries
+** =======================================================================
+*/
+
+/* formats for Lua numbers */
+#ifndef LUA_NUMBER_SCAN
+#define LUA_NUMBER_SCAN		"%lf"
+#endif
+
+#ifndef LUA_NUMBER_FMT
+#define LUA_NUMBER_FMT		"%.14g"
+#endif
+
+/* }====================================================================== */
+
+
+/*
+** {======================================================================
+** Debug API
+** =======================================================================
+*/
+
+
+/*
+** Event codes
+*/
+#define LUA_HOOKCALL	0
+#define LUA_HOOKRET	1
+#define LUA_HOOKLINE	2
+#define LUA_HOOKCOUNT	3
+#define LUA_HOOKTAILRET 4
+
+
+/*
+** Event masks
+*/
+#define LUA_MASKCALL	(1 << LUA_HOOKCALL)
+#define LUA_MASKRET	(1 << LUA_HOOKRET)
+#define LUA_MASKLINE	(1 << LUA_HOOKLINE)
+#define LUA_MASKCOUNT	(1 << LUA_HOOKCOUNT)
+
+typedef struct lua_Debug lua_Debug;  /* activation record */
+
+typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);
+
+
+LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar);
+LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);
+LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);
+LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);
+LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n);
+LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n);
+
+LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count);
+LUA_API lua_Hook lua_gethook (lua_State *L);
+LUA_API int lua_gethookmask (lua_State *L);
+LUA_API int lua_gethookcount (lua_State *L);
+
+
+#define LUA_IDSIZE	60
+
+struct lua_Debug {
+  int event;
+  const char *name;	/* (n) */
+  const char *namewhat;	/* (n) `global', `local', `field', `method' */
+  const char *what;	/* (S) `Lua', `C', `main', `tail' */
+  const char *source;	/* (S) */
+  int currentline;	/* (l) */
+  int nups;		/* (u) number of upvalues */
+  int linedefined;	/* (S) */
+  char short_src[LUA_IDSIZE]; /* (S) */
+  /* private part */
+  int i_ci;  /* active function */
+};
+
+/* }====================================================================== */
+
+
+/******************************************************************************
+* Copyright (C) 1994-2003 Tecgraf, PUC-Rio.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining
+* a copy of this software and associated documentation files (the
+* "Software"), to deal in the Software without restriction, including
+* without limitation the rights to use, copy, modify, merge, publish,
+* distribute, sublicense, and/or sell copies of the Software, and to
+* permit persons to whom the Software is furnished to do so, subject to
+* the following conditions:
+*
+* The above copyright notice and this permission notice shall be
+* included in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+******************************************************************************/
+
+
+#endif

Added: trunk/Util/deditor/lua/lualib.h
===================================================================
--- trunk/Util/deditor/lua/lualib.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lualib.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,56 @@
+/*
+** $Id: lualib.h,v 1.28 2003/03/18 12:24:26 roberto Exp $
+** Lua standard libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lualib_h
+#define lualib_h
+
+#include "lua.h"
+
+
+#ifndef LUALIB_API
+#define LUALIB_API	LUA_API
+#endif
+
+
+#define LUA_COLIBNAME	"coroutine"
+LUALIB_API int luaopen_base (lua_State *L);
+
+#define LUA_TABLIBNAME	"table"
+LUALIB_API int luaopen_table (lua_State *L);
+
+#define LUA_IOLIBNAME	"io"
+#define LUA_OSLIBNAME	"os"
+LUALIB_API int luaopen_io (lua_State *L);
+
+#define LUA_STRLIBNAME	"string"
+LUALIB_API int luaopen_string (lua_State *L);
+
+#define LUA_MATHLIBNAME	"math"
+LUALIB_API int luaopen_math (lua_State *L);
+
+#define LUA_DBLIBNAME	"debug"
+LUALIB_API int luaopen_debug (lua_State *L);
+
+
+LUALIB_API int luaopen_loadlib (lua_State *L);
+
+
+/* to help testing the libraries */
+#ifndef lua_assert
+#define lua_assert(c)		/* empty */
+#endif
+
+
+/* compatibility code */
+#define lua_baselibopen	luaopen_base
+#define lua_tablibopen	luaopen_table
+#define lua_iolibopen	luaopen_io
+#define lua_strlibopen	luaopen_string
+#define lua_mathlibopen	luaopen_math
+#define lua_dblibopen	luaopen_debug
+
+#endif

Added: trunk/Util/deditor/lua/lundump.c
===================================================================
--- trunk/Util/deditor/lua/lundump.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lundump.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,286 @@
+/*
+** $Id: lundump.c,v 1.49 2003/04/07 20:34:20 lhf Exp $
+** load pre-compiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#define lundump_c
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "lfunc.h"
+#include "lmem.h"
+#include "lopcodes.h"
+#include "lstring.h"
+#include "lundump.h"
+#include "lzio.h"
+
+#define	LoadByte	(lu_byte) ezgetc
+
+typedef struct {
+ lua_State* L;
+ ZIO* Z;
+ Mbuffer* b;
+ int swap;
+ const char* name;
+} LoadState;
+
+static void unexpectedEOZ (LoadState* S)
+{
+ luaG_runerror(S->L,"unexpected end of file in %s",S->name);
+}
+
+static int ezgetc (LoadState* S)
+{
+ int c=zgetc(S->Z);
+ if (c==EOZ) unexpectedEOZ(S);
+ return c;
+}
+
+static void ezread (LoadState* S, void* b, int n)
+{
+ int r=luaZ_read(S->Z,b,n);
+ if (r!=0) unexpectedEOZ(S);
+}
+
+static void LoadBlock (LoadState* S, void* b, size_t size)
+{
+ if (S->swap)
+ {
+  char* p=(char*) b+size-1;
+  int n=size;
+  while (n--) *p--=(char)ezgetc(S);
+ }
+ else
+  ezread(S,b,size);
+}
+
+static void LoadVector (LoadState* S, void* b, int m, size_t size)
+{
+ if (S->swap)
+ {
+  char* q=(char*) b;
+  while (m--)
+  {
+   char* p=q+size-1;
+   int n=size;
+   while (n--) *p--=(char)ezgetc(S);
+   q+=size;
+  }
+ }
+ else
+  ezread(S,b,m*size);
+}
+
+static int LoadInt (LoadState* S)
+{
+ int x;
+ LoadBlock(S,&x,sizeof(x));
+ if (x<0) luaG_runerror(S->L,"bad integer in %s",S->name);
+ return x;
+}
+
+static size_t LoadSize (LoadState* S)
+{
+ size_t x;
+ LoadBlock(S,&x,sizeof(x));
+ return x;
+}
+
+static lua_Number LoadNumber (LoadState* S)
+{
+ lua_Number x;
+ LoadBlock(S,&x,sizeof(x));
+ return x;
+}
+
+static TString* LoadString (LoadState* S)
+{
+ size_t size=LoadSize(S);
+ if (size==0)
+  return NULL;
+ else
+ {
+  char* s=luaZ_openspace(S->L,S->b,size);
+  ezread(S,s,size);
+  return luaS_newlstr(S->L,s,size-1);		/* remove trailing '\0' */
+ }
+}
+
+static void LoadCode (LoadState* S, Proto* f)
+{
+ int size=LoadInt(S);
+ f->code=luaM_newvector(S->L,size,Instruction);
+ f->sizecode=size;
+ LoadVector(S,f->code,size,sizeof(*f->code));
+}
+
+static void LoadLocals (LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ f->locvars=luaM_newvector(S->L,n,LocVar);
+ f->sizelocvars=n;
+ for (i=0; i<n; i++)
+ {
+  f->locvars[i].varname=LoadString(S);
+  f->locvars[i].startpc=LoadInt(S);
+  f->locvars[i].endpc=LoadInt(S);
+ }
+}
+
+static void LoadLines (LoadState* S, Proto* f)
+{
+ int size=LoadInt(S);
+ f->lineinfo=luaM_newvector(S->L,size,int);
+ f->sizelineinfo=size;
+ LoadVector(S,f->lineinfo,size,sizeof(*f->lineinfo));
+}
+
+static void LoadUpvalues (LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ if (n!=0 && n!=f->nups) 
+  luaG_runerror(S->L,"bad nupvalues in %s: read %d; expected %d",
+		S->name,n,f->nups);
+ f->upvalues=luaM_newvector(S->L,n,TString*);
+ f->sizeupvalues=n;
+ for (i=0; i<n; i++) f->upvalues[i]=LoadString(S);
+}
+
+static Proto* LoadFunction (LoadState* S, TString* p);
+
+static void LoadConstants (LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ f->k=luaM_newvector(S->L,n,TObject);
+ f->sizek=n;
+ for (i=0; i<n; i++)
+ {
+  TObject* o=&f->k[i];
+  int t=LoadByte(S);
+  switch (t)
+  {
+   case LUA_TNUMBER:
+	setnvalue(o,LoadNumber(S));
+	break;
+   case LUA_TSTRING:
+	setsvalue2n(o,LoadString(S));
+	break;
+   case LUA_TNIL:
+   	setnilvalue(o);
+	break;
+   default:
+	luaG_runerror(S->L,"bad constant type (%d) in %s",t,S->name);
+	break;
+  }
+ }
+ n=LoadInt(S);
+ f->p=luaM_newvector(S->L,n,Proto*);
+ f->sizep=n;
+ for (i=0; i<n; i++) f->p[i]=LoadFunction(S,f->source);
+}
+
+static Proto* LoadFunction (LoadState* S, TString* p)
+{
+ Proto* f=luaF_newproto(S->L);
+ f->source=LoadString(S); if (f->source==NULL) f->source=p;
+ f->lineDefined=LoadInt(S);
+ f->nups=LoadByte(S);
+ f->numparams=LoadByte(S);
+ f->is_vararg=LoadByte(S);
+ f->maxstacksize=LoadByte(S);
+ LoadLines(S,f);
+ LoadLocals(S,f);
+ LoadUpvalues(S,f);
+ LoadConstants(S,f);
+ LoadCode(S,f);
+#ifndef TRUST_BINARIES
+ if (!luaG_checkcode(f)) luaG_runerror(S->L,"bad code in %s",S->name);
+#endif
+ return f;
+}
+
+static void LoadSignature (LoadState* S)
+{
+ const char* s=LUA_SIGNATURE;
+ while (*s!=0 && ezgetc(S)==*s)
+  ++s;
+ if (*s!=0) luaG_runerror(S->L,"bad signature in %s",S->name);
+}
+
+static void TestSize (LoadState* S, int s, const char* what)
+{
+ int r=LoadByte(S);
+ if (r!=s)
+  luaG_runerror(S->L,"virtual machine mismatch in %s: "
+	"size of %s is %d but read %d",S->name,what,s,r);
+}
+
+#define TESTSIZE(s,w)	TestSize(S,s,w)
+#define V(v)		v/16,v%16
+
+static void LoadHeader (LoadState* S)
+{
+ int version;
+ lua_Number x,tx=TEST_NUMBER;
+ LoadSignature(S);
+ version=LoadByte(S);
+ if (version>VERSION)
+  luaG_runerror(S->L,"%s too new: "
+	"read version %d.%d; expected at most %d.%d",
+	S->name,V(version),V(VERSION));
+ if (version<VERSION0)				/* check last major change */
+  luaG_runerror(S->L,"%s too old: "
+	"read version %d.%d; expected at least %d.%d",
+	S->name,V(version),V(VERSION0));
+ S->swap=(luaU_endianness()!=LoadByte(S));	/* need to swap bytes? */
+ TESTSIZE(sizeof(int),"int");
+ TESTSIZE(sizeof(size_t), "size_t");
+ TESTSIZE(sizeof(Instruction), "Instruction");
+ TESTSIZE(SIZE_OP, "OP");
+ TESTSIZE(SIZE_A, "A");
+ TESTSIZE(SIZE_B, "B");
+ TESTSIZE(SIZE_C, "C");
+ TESTSIZE(sizeof(lua_Number), "number");
+ x=LoadNumber(S);
+ if ((long)x!=(long)tx)		/* disregard errors in last bits of fraction */
+  luaG_runerror(S->L,"unknown number format in %s",S->name);
+}
+
+static Proto* LoadChunk (LoadState* S)
+{
+ LoadHeader(S);
+ return LoadFunction(S,NULL);
+}
+
+/*
+** load precompiled chunk
+*/
+Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff)
+{
+ LoadState S;
+ const char* s=zname(Z);
+ if (*s=='@' || *s=='=')
+  S.name=s+1;
+ else if (*s==LUA_SIGNATURE[0])
+  S.name="binary string";
+ else
+  S.name=s;
+ S.L=L;
+ S.Z=Z;
+ S.b=buff;
+ return LoadChunk(&S);
+}
+
+/*
+** find byte order
+*/
+int luaU_endianness (void)
+{
+ int x=1;
+ return *(char*)&x;
+}

Added: trunk/Util/deditor/lua/lundump.h
===================================================================
--- trunk/Util/deditor/lua/lundump.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lundump.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,34 @@
+/*
+** $Id: lundump.h,v 1.30 2003/04/07 20:34:20 lhf Exp $
+** load pre-compiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lundump_h
+#define lundump_h
+
+#include "lobject.h"
+#include "lzio.h"
+
+/* load one chunk; from lundump.c */
+Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff);
+
+/* find byte order; from lundump.c */
+int luaU_endianness (void);
+
+/* dump one chunk; from ldump.c */
+void luaU_dump (lua_State* L, const Proto* Main, lua_Chunkwriter w, void* data);
+
+/* print one chunk; from print.c */
+void luaU_print (const Proto* Main);
+
+/* definitions for headers of binary files */
+#define	LUA_SIGNATURE	"\033Lua"	/* binary files start with "<esc>Lua" */
+#define	VERSION		0x50		/* last format change was in 5.0 */
+#define	VERSION0	0x50		/* last major  change was in 5.0 */
+
+/* a multiple of PI for testing native format */
+/* multiplying by 1E7 gives non-trivial integer values */
+#define	TEST_NUMBER	((lua_Number)3.14159265358979323846E7)
+
+#endif

Added: trunk/Util/deditor/lua/lvm.c
===================================================================
--- trunk/Util/deditor/lua/lvm.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lvm.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,780 @@
+/*
+** $Id: lvm.c,v 1.284 2003/04/03 13:35:34 roberto Exp $
+** Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+
+/* needed only when `lua_number2str' uses `sprintf' */
+#include <stdio.h>
+
+#define lvm_c
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lvm.h"
+
+
+
+/* function to convert a lua_Number to a string */
+#ifndef lua_number2str
+#define lua_number2str(s,n)     sprintf((s), LUA_NUMBER_FMT, (n))
+#endif
+
+
+/* limit for table tag-method chains (to avoid loops) */
+#define MAXTAGLOOP	100
+
+
+const TObject *luaV_tonumber (const TObject *obj, TObject *n) {
+  lua_Number num;
+  if (ttisnumber(obj)) return obj;
+  if (ttisstring(obj) && luaO_str2d(svalue(obj), &num)) {
+    setnvalue(n, num);
+    return n;
+  }
+  else
+    return NULL;
+}
+
+
+int luaV_tostring (lua_State *L, StkId obj) {
+  if (!ttisnumber(obj))
+    return 0;
+  else {
+    char s[32];  /* 16 digits, sign, point and \0  (+ some extra...) */
+    lua_number2str(s, nvalue(obj));
+    setsvalue2s(obj, luaS_new(L, s));
+    return 1;
+  }
+}
+
+
+static void traceexec (lua_State *L) {
+  lu_byte mask = L->hookmask;
+  if (mask > LUA_MASKLINE) {  /* instruction-hook set? */
+    if (L->hookcount == 0) {
+      resethookcount(L);
+      luaD_callhook(L, LUA_HOOKCOUNT, -1);
+      return;
+    }
+  }
+  if (mask & LUA_MASKLINE) {
+    CallInfo *ci = L->ci;
+    Proto *p = ci_func(ci)->l.p;
+    int newline = getline(p, pcRel(*ci->u.l.pc, p));
+    if (!L->hookinit) {
+      luaG_inithooks(L);
+      return;
+    }
+    lua_assert(ci->state & CI_HASFRAME);
+    if (pcRel(*ci->u.l.pc, p) == 0)  /* tracing may be starting now? */
+      ci->u.l.savedpc = *ci->u.l.pc;  /* initialize `savedpc' */
+    /* calls linehook when enters a new line or jumps back (loop) */
+    if (*ci->u.l.pc <= ci->u.l.savedpc ||
+        newline != getline(p, pcRel(ci->u.l.savedpc, p))) {
+      luaD_callhook(L, LUA_HOOKLINE, newline);
+      ci = L->ci;  /* previous call may reallocate `ci' */
+    }
+    ci->u.l.savedpc = *ci->u.l.pc;
+  }
+}
+
+
+static void callTMres (lua_State *L, const TObject *f,
+                       const TObject *p1, const TObject *p2) {
+  setobj2s(L->top, f);  /* push function */
+  setobj2s(L->top+1, p1);  /* 1st argument */
+  setobj2s(L->top+2, p2);  /* 2nd argument */
+  luaD_checkstack(L, 3);  /* cannot check before (could invalidate p1, p2) */
+  L->top += 3;
+  luaD_call(L, L->top - 3, 1);
+  L->top--;  /* result will be in L->top */
+}
+
+
+
+static void callTM (lua_State *L, const TObject *f,
+                    const TObject *p1, const TObject *p2, const TObject *p3) {
+  setobj2s(L->top, f);  /* push function */
+  setobj2s(L->top+1, p1);  /* 1st argument */
+  setobj2s(L->top+2, p2);  /* 2nd argument */
+  setobj2s(L->top+3, p3);  /* 3th argument */
+  luaD_checkstack(L, 4);  /* cannot check before (could invalidate p1...p3) */
+  L->top += 4;
+  luaD_call(L, L->top - 4, 0);
+}
+
+
+static const TObject *luaV_index (lua_State *L, const TObject *t,
+                                  TObject *key, int loop) {
+  const TObject *tm = fasttm(L, hvalue(t)->metatable, TM_INDEX);
+  if (tm == NULL) return &luaO_nilobject;  /* no TM */
+  if (ttisfunction(tm)) {
+    callTMres(L, tm, t, key);
+    return L->top;
+  }
+  else return luaV_gettable(L, tm, key, loop);
+}
+
+static const TObject *luaV_getnotable (lua_State *L, const TObject *t,
+                                       TObject *key, int loop) {
+  const TObject *tm = luaT_gettmbyobj(L, t, TM_INDEX);
+  if (ttisnil(tm))
+    luaG_typeerror(L, t, "index");
+  if (ttisfunction(tm)) {
+    callTMres(L, tm, t, key);
+    return L->top;
+  }
+  else return luaV_gettable(L, tm, key, loop);
+}
+
+
+/*
+** Function to index a table.
+** Receives the table at `t' and the key at `key'.
+** leaves the result at `res'.
+*/
+const TObject *luaV_gettable (lua_State *L, const TObject *t, TObject *key,
+                              int loop) {
+  if (loop > MAXTAGLOOP)
+    luaG_runerror(L, "loop in gettable");
+  if (ttistable(t)) {  /* `t' is a table? */
+    Table *h = hvalue(t);
+    const TObject *v = luaH_get(h, key);  /* do a primitive get */
+    if (!ttisnil(v)) return v;
+    else return luaV_index(L, t, key, loop+1);
+  }
+  else return luaV_getnotable(L, t, key, loop+1);
+}
+
+
+/*
+** Receives table at `t', key at `key' and value at `val'.
+*/
+void luaV_settable (lua_State *L, const TObject *t, TObject *key, StkId val) {
+  const TObject *tm;
+  int loop = 0;
+  do {
+    if (ttistable(t)) {  /* `t' is a table? */
+      Table *h = hvalue(t);
+      TObject *oldval = luaH_set(L, h, key); /* do a primitive set */
+      if (!ttisnil(oldval) ||  /* result is no nil? */
+          (tm = fasttm(L, h->metatable, TM_NEWINDEX)) == NULL) { /* or no TM? */
+        setobj2t(oldval, val);  /* write barrier */
+        return;
+      }
+      /* else will try the tag method */
+    }
+    else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))
+      luaG_typeerror(L, t, "index");
+    if (ttisfunction(tm)) {
+      callTM(L, tm, t, key, val);
+      return;
+    }
+    t = tm;  /* else repeat with `tm' */ 
+  } while (++loop <= MAXTAGLOOP);
+  luaG_runerror(L, "loop in settable");
+}
+
+
+static int call_binTM (lua_State *L, const TObject *p1, const TObject *p2,
+                       StkId res, TMS event) {
+  ptrdiff_t result = savestack(L, res);
+  const TObject *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */
+  if (ttisnil(tm))
+    tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */
+  if (!ttisfunction(tm)) return 0;
+  callTMres(L, tm, p1, p2);
+  res = restorestack(L, result);  /* previous call may change stack */
+  setobjs2s(res, L->top);
+  return 1;
+}
+
+
+static const TObject *get_compTM (lua_State *L, Table *mt1, Table *mt2,
+                                  TMS event) {
+  const TObject *tm1 = fasttm(L, mt1, event);
+  const TObject *tm2;
+  if (tm1 == NULL) return NULL;  /* no metamethod */
+  if (mt1 == mt2) return tm1;  /* same metatables => same metamethods */
+  tm2 = fasttm(L, mt2, event);
+  if (tm2 == NULL) return NULL;  /* no metamethod */
+  if (luaO_rawequalObj(tm1, tm2))  /* same metamethods? */
+    return tm1;
+  return NULL;
+}
+
+
+static int call_orderTM (lua_State *L, const TObject *p1, const TObject *p2,
+                         TMS event) {
+  const TObject *tm1 = luaT_gettmbyobj(L, p1, event);
+  const TObject *tm2;
+  if (ttisnil(tm1)) return -1;  /* no metamethod? */
+  tm2 = luaT_gettmbyobj(L, p2, event);
+  if (!luaO_rawequalObj(tm1, tm2))  /* different metamethods? */
+    return -1;
+  callTMres(L, tm1, p1, p2);
+  return !l_isfalse(L->top);
+}
+
+
+static int luaV_strcmp (const TString *ls, const TString *rs) {
+  const char *l = getstr(ls);
+  size_t ll = ls->tsv.len;
+  const char *r = getstr(rs);
+  size_t lr = rs->tsv.len;
+  for (;;) {
+    int temp = strcoll(l, r);
+    if (temp != 0) return temp;
+    else {  /* strings are equal up to a `\0' */
+      size_t len = strlen(l);  /* index of first `\0' in both strings */
+      if (len == lr)  /* r is finished? */
+        return (len == ll) ? 0 : 1;
+      else if (len == ll)  /* l is finished? */
+        return -1;  /* l is smaller than r (because r is not finished) */
+      /* both strings longer than `len'; go on comparing (after the `\0') */
+      len++;
+      l += len; ll -= len; r += len; lr -= len;
+    }
+  }
+}
+
+
+int luaV_lessthan (lua_State *L, const TObject *l, const TObject *r) {
+  int res;
+  if (ttype(l) != ttype(r))
+    return luaG_ordererror(L, l, r);
+  else if (ttisnumber(l))
+    return nvalue(l) < nvalue(r);
+  else if (ttisstring(l))
+    return luaV_strcmp(tsvalue(l), tsvalue(r)) < 0;
+  else if ((res = call_orderTM(L, l, r, TM_LT)) != -1)
+    return res;
+  return luaG_ordererror(L, l, r);
+}
+
+
+static int luaV_lessequal (lua_State *L, const TObject *l, const TObject *r) {
+  int res;
+  if (ttype(l) != ttype(r))
+    return luaG_ordererror(L, l, r);
+  else if (ttisnumber(l))
+    return nvalue(l) <= nvalue(r);
+  else if (ttisstring(l))
+    return luaV_strcmp(tsvalue(l), tsvalue(r)) <= 0;
+  else if ((res = call_orderTM(L, l, r, TM_LE)) != -1)  /* first try `le' */
+    return res;
+  else if ((res = call_orderTM(L, r, l, TM_LT)) != -1)  /* else try `lt' */
+    return !res;
+  return luaG_ordererror(L, l, r);
+}
+
+
+int luaV_equalval (lua_State *L, const TObject *t1, const TObject *t2) {
+  const TObject *tm;
+  lua_assert(ttype(t1) == ttype(t2));
+  switch (ttype(t1)) {
+    case LUA_TNIL: return 1;
+    case LUA_TNUMBER: return nvalue(t1) == nvalue(t2);
+    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */
+    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
+    case LUA_TUSERDATA: {
+      if (uvalue(t1) == uvalue(t2)) return 1;
+      tm = get_compTM(L, uvalue(t1)->uv.metatable, uvalue(t2)->uv.metatable,
+                         TM_EQ);
+      break;  /* will try TM */
+    }
+    case LUA_TTABLE: {
+      if (hvalue(t1) == hvalue(t2)) return 1;
+      tm = get_compTM(L, hvalue(t1)->metatable, hvalue(t2)->metatable, TM_EQ);
+      break;  /* will try TM */
+    }
+    default: return gcvalue(t1) == gcvalue(t2);
+  }
+  if (tm == NULL) return 0;  /* no TM? */
+  callTMres(L, tm, t1, t2);  /* call TM */
+  return !l_isfalse(L->top);
+}
+
+
+void luaV_concat (lua_State *L, int total, int last) {
+  do {
+    StkId top = L->base + last + 1;
+    int n = 2;  /* number of elements handled in this pass (at least 2) */
+    if (!tostring(L, top-2) || !tostring(L, top-1)) {
+      if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))
+        luaG_concaterror(L, top-2, top-1);
+    } else if (tsvalue(top-1)->tsv.len > 0) {  /* if len=0, do nothing */
+      /* at least two string values; get as many as possible */
+      lu_mem tl = cast(lu_mem, tsvalue(top-1)->tsv.len) +
+                  cast(lu_mem, tsvalue(top-2)->tsv.len);
+      char *buffer;
+      int i;
+      while (n < total && tostring(L, top-n-1)) {  /* collect total length */
+        tl += tsvalue(top-n-1)->tsv.len;
+        n++;
+      }
+      if (tl > MAX_SIZET) luaG_runerror(L, "string size overflow");
+      buffer = luaZ_openspace(L, &G(L)->buff, tl);
+      tl = 0;
+      for (i=n; i>0; i--) {  /* concat all strings */
+        size_t l = tsvalue(top-i)->tsv.len;
+        memcpy(buffer+tl, svalue(top-i), l);
+        tl += l;
+      }
+      setsvalue2s(top-n, luaS_newlstr(L, buffer, tl));
+    }
+    total -= n-1;  /* got `n' strings to create 1 new */
+    last -= n-1;
+  } while (total > 1);  /* repeat until only 1 result left */
+}
+
+
+static void Arith (lua_State *L, StkId ra,
+                   const TObject *rb, const TObject *rc, TMS op) {
+  TObject tempb, tempc;
+  const TObject *b, *c;
+  if ((b = luaV_tonumber(rb, &tempb)) != NULL &&
+      (c = luaV_tonumber(rc, &tempc)) != NULL) {
+    switch (op) {
+      case TM_ADD: setnvalue(ra, nvalue(b) + nvalue(c)); break;
+      case TM_SUB: setnvalue(ra, nvalue(b) - nvalue(c)); break;
+      case TM_MUL: setnvalue(ra, nvalue(b) * nvalue(c)); break;
+      case TM_DIV: setnvalue(ra, nvalue(b) / nvalue(c)); break;
+      case TM_POW: {
+        const TObject *f = luaH_getstr(hvalue(gt(L)), G(L)->tmname[TM_POW]);
+        ptrdiff_t res = savestack(L, ra);
+        if (!ttisfunction(f))
+          luaG_runerror(L, "`__pow' (`^' operator) is not a function");
+        callTMres(L, f, b, c);
+        ra = restorestack(L, res);  /* previous call may change stack */
+        setobjs2s(ra, L->top);
+        break;
+      }
+      default: lua_assert(0); break;
+    }
+  }
+  else if (!call_binTM(L, rb, rc, ra, op))
+    luaG_aritherror(L, rb, rc);
+}
+
+
+
+/*
+** some macros for common tasks in `luaV_execute'
+*/
+
+#define runtime_check(L, c)	{ if (!(c)) return 0; }
+
+#define RA(i)	(base+GETARG_A(i))
+/* to be used after possible stack reallocation */
+#define XRA(i)	(L->base+GETARG_A(i))
+#define RB(i)	(base+GETARG_B(i))
+#define RKB(i)	((GETARG_B(i) < MAXSTACK) ? RB(i) : k+GETARG_B(i)-MAXSTACK)
+#define RC(i)	(base+GETARG_C(i))
+#define RKC(i)	((GETARG_C(i) < MAXSTACK) ? RC(i) : k+GETARG_C(i)-MAXSTACK)
+#define KBx(i)	(k+GETARG_Bx(i))
+
+
+#define dojump(pc, i)	((pc) += (i))
+
+
+StkId luaV_execute (lua_State *L) {
+  LClosure *cl;
+  TObject *k;
+  const Instruction *pc;
+ callentry:  /* entry point when calling new functions */
+  L->ci->u.l.pc = &pc;
+  if (L->hookmask & LUA_MASKCALL)
+    luaD_callhook(L, LUA_HOOKCALL, -1);
+ retentry:  /* entry point when returning to old functions */
+  lua_assert(L->ci->state == CI_SAVEDPC ||
+             L->ci->state == (CI_SAVEDPC | CI_CALLING));
+  L->ci->state = CI_HASFRAME;  /* activate frame */
+  pc = L->ci->u.l.savedpc;
+  cl = &clvalue(L->base - 1)->l;
+  k = cl->p->k;
+  /* main loop of interpreter */
+  for (;;) {
+    const Instruction i = *pc++;
+    StkId base, ra;
+    if ((L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) &&
+        (--L->hookcount == 0 || L->hookmask & LUA_MASKLINE)) {
+      traceexec(L);
+      if (L->ci->state & CI_YIELD) {  /* did hook yield? */
+        L->ci->u.l.savedpc = pc - 1;
+        L->ci->state = CI_YIELD | CI_SAVEDPC;
+        return NULL;
+      }
+    }
+    /* warning!! several calls may realloc the stack and invalidate `ra' */
+    base = L->base;
+    ra = RA(i);
+    lua_assert(L->ci->state & CI_HASFRAME);
+    lua_assert(base == L->ci->base);
+    lua_assert(L->top <= L->stack + L->stacksize && L->top >= base);
+    lua_assert(L->top == L->ci->top ||
+         GET_OPCODE(i) == OP_CALL ||   GET_OPCODE(i) == OP_TAILCALL ||
+         GET_OPCODE(i) == OP_RETURN || GET_OPCODE(i) == OP_SETLISTO);
+    switch (GET_OPCODE(i)) {
+      case OP_MOVE: {
+        setobjs2s(ra, RB(i));
+        break;
+      }
+      case OP_LOADK: {
+        setobj2s(ra, KBx(i));
+        break;
+      }
+      case OP_LOADBOOL: {
+        setbvalue(ra, GETARG_B(i));
+        if (GETARG_C(i)) pc++;  /* skip next instruction (if C) */
+        break;
+      }
+      case OP_LOADNIL: {
+        TObject *rb = RB(i);
+        do {
+          setnilvalue(rb--);
+        } while (rb >= ra);
+        break;
+      }
+      case OP_GETUPVAL: {
+        int b = GETARG_B(i);
+        setobj2s(ra, cl->upvals[b]->v);
+        break;
+      }
+      case OP_GETGLOBAL: {
+        TObject *rb = KBx(i);
+        const TObject *v;
+        lua_assert(ttisstring(rb) && ttistable(&cl->g));
+        v = luaH_getstr(hvalue(&cl->g), tsvalue(rb));
+        if (!ttisnil(v)) { setobj2s(ra, v); }
+        else
+          setobj2s(XRA(i), luaV_index(L, &cl->g, rb, 0));
+        break;
+      }
+      case OP_GETTABLE: {
+        StkId rb = RB(i);
+        TObject *rc = RKC(i);
+        if (ttistable(rb)) {
+          const TObject *v = luaH_get(hvalue(rb), rc);
+          if (!ttisnil(v)) { setobj2s(ra, v); }
+          else
+            setobj2s(XRA(i), luaV_index(L, rb, rc, 0));
+        }
+        else
+          setobj2s(XRA(i), luaV_getnotable(L, rb, rc, 0));
+        break;
+      }
+      case OP_SETGLOBAL: {
+        lua_assert(ttisstring(KBx(i)) && ttistable(&cl->g));
+        luaV_settable(L, &cl->g, KBx(i), ra);
+        break;
+      }
+      case OP_SETUPVAL: {
+        int b = GETARG_B(i);
+        setobj(cl->upvals[b]->v, ra);  /* write barrier */
+        break;
+      }
+      case OP_SETTABLE: {
+        luaV_settable(L, ra, RKB(i), RKC(i));
+        break;
+      }
+      case OP_NEWTABLE: {
+        int b = GETARG_B(i);
+        b = fb2int(b);
+        sethvalue(ra, luaH_new(L, b, GETARG_C(i)));
+        luaC_checkGC(L);
+        break;
+      }
+      case OP_SELF: {
+        StkId rb = RB(i);
+        TObject *rc = RKC(i);
+        runtime_check(L, ttisstring(rc));
+        setobjs2s(ra+1, rb);
+        if (ttistable(rb)) {
+          const TObject *v = luaH_getstr(hvalue(rb), tsvalue(rc));
+          if (!ttisnil(v)) { setobj2s(ra, v); }
+          else
+            setobj2s(XRA(i), luaV_index(L, rb, rc, 0));
+        }
+        else
+          setobj2s(XRA(i), luaV_getnotable(L, rb, rc, 0));
+        break;
+      }
+      case OP_ADD: {
+        TObject *rb = RKB(i);
+        TObject *rc = RKC(i);
+        if (ttisnumber(rb) && ttisnumber(rc)) {
+          setnvalue(ra, nvalue(rb) + nvalue(rc));
+        }
+        else
+          Arith(L, ra, rb, rc, TM_ADD);
+        break;
+      }
+      case OP_SUB: {
+        TObject *rb = RKB(i);
+        TObject *rc = RKC(i);
+        if (ttisnumber(rb) && ttisnumber(rc)) {
+          setnvalue(ra, nvalue(rb) - nvalue(rc));
+        }
+        else
+          Arith(L, ra, rb, rc, TM_SUB);
+        break;
+      }
+      case OP_MUL: {
+        TObject *rb = RKB(i);
+        TObject *rc = RKC(i);
+        if (ttisnumber(rb) && ttisnumber(rc)) {
+          setnvalue(ra, nvalue(rb) * nvalue(rc));
+        }
+        else
+          Arith(L, ra, rb, rc, TM_MUL);
+        break;
+      }
+      case OP_DIV: {
+        TObject *rb = RKB(i);
+        TObject *rc = RKC(i);
+        if (ttisnumber(rb) && ttisnumber(rc)) {
+          setnvalue(ra, nvalue(rb) / nvalue(rc));
+        }
+        else
+          Arith(L, ra, rb, rc, TM_DIV);
+        break;
+      }
+      case OP_POW: {
+        Arith(L, ra, RKB(i), RKC(i), TM_POW);
+        break;
+      }
+      case OP_UNM: {
+        const TObject *rb = RB(i);
+        TObject temp;
+        if (tonumber(rb, &temp)) {
+          setnvalue(ra, -nvalue(rb));
+        }
+        else {
+          setnilvalue(&temp);
+          if (!call_binTM(L, RB(i), &temp, ra, TM_UNM))
+            luaG_aritherror(L, RB(i), &temp);
+        }
+        break;
+      }
+      case OP_NOT: {
+        int res = l_isfalse(RB(i));  /* next assignment may change this value */
+        setbvalue(ra, res);
+        break;
+      }
+      case OP_CONCAT: {
+        int b = GETARG_B(i);
+        int c = GETARG_C(i);
+        luaV_concat(L, c-b+1, c);  /* may change `base' (and `ra') */
+        base = L->base;
+        setobjs2s(RA(i), base+b);
+        luaC_checkGC(L);
+        break;
+      }
+      case OP_JMP: {
+        dojump(pc, GETARG_sBx(i));
+        break;
+      }
+      case OP_EQ: {
+        if (equalobj(L, RKB(i), RKC(i)) != GETARG_A(i)) pc++;
+        else dojump(pc, GETARG_sBx(*pc) + 1);
+        break;
+      }
+      case OP_LT: {
+        if (luaV_lessthan(L, RKB(i), RKC(i)) != GETARG_A(i)) pc++;
+        else dojump(pc, GETARG_sBx(*pc) + 1);
+        break;
+      }
+      case OP_LE: {
+        if (luaV_lessequal(L, RKB(i), RKC(i)) != GETARG_A(i)) pc++;
+        else dojump(pc, GETARG_sBx(*pc) + 1);
+        break;
+      }
+      case OP_TEST: {
+        TObject *rb = RB(i);
+        if (l_isfalse(rb) == GETARG_C(i)) pc++;
+        else {
+          setobjs2s(ra, rb);
+          dojump(pc, GETARG_sBx(*pc) + 1);
+        }
+        break;
+      }
+      case OP_CALL:
+      case OP_TAILCALL: {
+        StkId firstResult;
+        int b = GETARG_B(i);
+        int nresults;
+        if (b != 0) L->top = ra+b;  /* else previous instruction set top */
+        nresults = GETARG_C(i) - 1;
+        firstResult = luaD_precall(L, ra);
+        if (firstResult) {
+          if (firstResult > L->top) {  /* yield? */
+            lua_assert(L->ci->state == (CI_C | CI_YIELD));
+            (L->ci - 1)->u.l.savedpc = pc;
+            (L->ci - 1)->state = CI_SAVEDPC;
+            return NULL;
+          }
+          /* it was a C function (`precall' called it); adjust results */
+          luaD_poscall(L, nresults, firstResult);
+          if (nresults >= 0) L->top = L->ci->top;
+        }
+        else {  /* it is a Lua function */
+          if (GET_OPCODE(i) == OP_CALL) {  /* regular call? */
+            (L->ci-1)->u.l.savedpc = pc;  /* save `pc' to return later */
+            (L->ci-1)->state = (CI_SAVEDPC | CI_CALLING);
+          }
+          else {  /* tail call: put new frame in place of previous one */
+            int aux;
+            base = (L->ci - 1)->base;  /* `luaD_precall' may change the stack */
+            ra = RA(i);
+            if (L->openupval) luaF_close(L, base);
+            for (aux = 0; ra+aux < L->top; aux++)  /* move frame down */
+              setobjs2s(base+aux-1, ra+aux);
+            (L->ci - 1)->top = L->top = base+aux;  /* correct top */
+            lua_assert(L->ci->state & CI_SAVEDPC);
+            (L->ci - 1)->u.l.savedpc = L->ci->u.l.savedpc;
+            (L->ci - 1)->u.l.tailcalls++;  /* one more call lost */
+            (L->ci - 1)->state = CI_SAVEDPC;
+            L->ci--;  /* remove new frame */
+            L->base = L->ci->base;
+          }
+          goto callentry;
+        }
+        break;
+      }
+      case OP_RETURN: {
+        CallInfo *ci = L->ci - 1;  /* previous function frame */
+        int b = GETARG_B(i);
+        if (b != 0) L->top = ra+b-1;
+        lua_assert(L->ci->state & CI_HASFRAME);
+        if (L->openupval) luaF_close(L, base);
+        L->ci->state = CI_SAVEDPC;  /* deactivate current function */
+        L->ci->u.l.savedpc = pc;
+        /* previous function was running `here'? */
+        if (!(ci->state & CI_CALLING)) {
+          lua_assert((ci->state & CI_C) || ci->u.l.pc != &pc);
+          return ra;  /* no: return */
+        }
+        else {  /* yes: continue its execution */
+          int nresults;
+          lua_assert(ci->u.l.pc == &pc &&
+                     ttisfunction(ci->base - 1) &&
+                     (ci->state & CI_SAVEDPC));
+          lua_assert(GET_OPCODE(*(ci->u.l.savedpc - 1)) == OP_CALL);
+          nresults = GETARG_C(*(ci->u.l.savedpc - 1)) - 1;
+          luaD_poscall(L, nresults, ra);
+          if (nresults >= 0) L->top = L->ci->top;
+          goto retentry;
+        }
+      }
+      case OP_FORLOOP: {
+        lua_Number step, idx, limit;
+        const TObject *plimit = ra+1;
+        const TObject *pstep = ra+2;
+        if (!ttisnumber(ra))
+          luaG_runerror(L, "`for' initial value must be a number");
+        if (!tonumber(plimit, ra+1))
+          luaG_runerror(L, "`for' limit must be a number");
+        if (!tonumber(pstep, ra+2))
+          luaG_runerror(L, "`for' step must be a number");
+        step = nvalue(pstep);
+        idx = nvalue(ra) + step;  /* increment index */
+        limit = nvalue(plimit);
+        if (step > 0 ? idx <= limit : idx >= limit) {
+          dojump(pc, GETARG_sBx(i));  /* jump back */
+          chgnvalue(ra, idx);  /* update index */
+        }
+        break;
+      }
+      case OP_TFORLOOP: {
+        int nvar = GETARG_C(i) + 1;
+        StkId cb = ra + nvar + 2;  /* call base */
+        setobjs2s(cb, ra);
+        setobjs2s(cb+1, ra+1);
+        setobjs2s(cb+2, ra+2);
+        L->top = cb+3;  /* func. + 2 args (state and index) */
+        luaD_call(L, cb, nvar);
+        L->top = L->ci->top;
+        ra = XRA(i) + 2;  /* final position of first result */
+        cb = ra + nvar;
+        do {  /* move results to proper positions */
+          nvar--;
+          setobjs2s(ra+nvar, cb+nvar);
+        } while (nvar > 0);
+        if (ttisnil(ra))  /* break loop? */
+          pc++;  /* skip jump (break loop) */
+        else
+          dojump(pc, GETARG_sBx(*pc) + 1);  /* jump back */
+        break;
+      }
+      case OP_TFORPREP: {  /* for compatibility only */
+        if (ttistable(ra)) {
+          setobjs2s(ra+1, ra);
+          setobj2s(ra, luaH_getstr(hvalue(gt(L)), luaS_new(L, "next")));
+        }
+        dojump(pc, GETARG_sBx(i));
+        break;
+      }
+      case OP_SETLIST:
+      case OP_SETLISTO: {
+        int bc;
+        int n;
+        Table *h;
+        runtime_check(L, ttistable(ra));
+        h = hvalue(ra);
+        bc = GETARG_Bx(i);
+        if (GET_OPCODE(i) == OP_SETLIST)
+          n = (bc&(LFIELDS_PER_FLUSH-1)) + 1;
+        else {
+          n = L->top - ra - 1;
+          L->top = L->ci->top;
+        }
+        bc &= ~(LFIELDS_PER_FLUSH-1);  /* bc = bc - bc%FPF */
+        for (; n > 0; n--)
+          setobj2t(luaH_setnum(L, h, bc+n), ra+n);  /* write barrier */
+        break;
+      }
+      case OP_CLOSE: {
+        luaF_close(L, ra);
+        break;
+      }
+      case OP_CLOSURE: {
+        Proto *p;
+        Closure *ncl;
+        int nup, j;
+        p = cl->p->p[GETARG_Bx(i)];
+        nup = p->nups;
+        ncl = luaF_newLclosure(L, nup, &cl->g);
+        ncl->l.p = p;
+        for (j=0; j<nup; j++, pc++) {
+          if (GET_OPCODE(*pc) == OP_GETUPVAL)
+            ncl->l.upvals[j] = cl->upvals[GETARG_B(*pc)];
+          else {
+            lua_assert(GET_OPCODE(*pc) == OP_MOVE);
+            ncl->l.upvals[j] = luaF_findupval(L, base + GETARG_B(*pc));
+          }
+        }
+        setclvalue(ra, ncl);
+        luaC_checkGC(L);
+        break;
+      }
+    }
+  }
+}
+

Added: trunk/Util/deditor/lua/lvm.h
===================================================================
--- trunk/Util/deditor/lua/lvm.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lvm.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,35 @@
+/*
+** $Id: lvm.h,v 1.47 2002/11/14 16:16:21 roberto Exp $
+** Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lvm_h
+#define lvm_h
+
+
+#include "ldo.h"
+#include "lobject.h"
+#include "ltm.h"
+
+
+#define tostring(L,o) ((ttype(o) == LUA_TSTRING) || (luaV_tostring(L, o)))
+
+#define tonumber(o,n)	(ttype(o) == LUA_TNUMBER || \
+                         (((o) = luaV_tonumber(o,n)) != NULL))
+
+#define equalobj(L,o1,o2) \
+	(ttype(o1) == ttype(o2) && luaV_equalval(L, o1, o2))
+
+
+int luaV_lessthan (lua_State *L, const TObject *l, const TObject *r);
+int luaV_equalval (lua_State *L, const TObject *t1, const TObject *t2);
+const TObject *luaV_tonumber (const TObject *obj, TObject *n);
+int luaV_tostring (lua_State *L, StkId obj);
+const TObject *luaV_gettable (lua_State *L, const TObject *t, TObject *key,
+                              int loop);
+void luaV_settable (lua_State *L, const TObject *t, TObject *key, StkId val);
+StkId luaV_execute (lua_State *L);
+void luaV_concat (lua_State *L, int total, int last);
+
+#endif

Added: trunk/Util/deditor/lua/lzio.c
===================================================================
--- trunk/Util/deditor/lua/lzio.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lzio.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,81 @@
+/*
+** $Id: lzio.c,v 1.24 2003/03/20 16:00:56 roberto Exp $
+** a generic input stream interface
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define lzio_c
+
+#include "lua.h"
+
+#include "llimits.h"
+#include "lmem.h"
+#include "lzio.h"
+
+
+int luaZ_fill (ZIO *z) {
+  size_t size;
+  const char *buff = z->reader(NULL, z->data, &size);
+  if (buff == NULL || size == 0) return EOZ;
+  z->n = size - 1;
+  z->p = buff;
+  return char2int(*(z->p++));
+}
+
+
+int luaZ_lookahead (ZIO *z) {
+  if (z->n == 0) {
+    int c = luaZ_fill(z);
+    if (c == EOZ) return c;
+    z->n++;
+    z->p--;
+  }
+  return char2int(*z->p);
+}
+
+
+void luaZ_init (ZIO *z, lua_Chunkreader reader, void *data, const char *name) {
+  z->reader = reader;
+  z->data = data;
+  z->name = name;
+  z->n = 0;
+  z->p = NULL;
+}
+
+
+/* --------------------------------------------------------------- read --- */
+size_t luaZ_read (ZIO *z, void *b, size_t n) {
+  while (n) {
+    size_t m;
+    if (z->n == 0) {
+      if (luaZ_fill(z) == EOZ)
+        return n;  /* return number of missing bytes */
+      else {
+        ++z->n;  /* filbuf removed first byte; put back it */
+        --z->p;
+      }
+    }
+    m = (n <= z->n) ? n : z->n;  /* min. between n and z->n */
+    memcpy(b, z->p, m);
+    z->n -= m;
+    z->p += m;
+    b = (char *)b + m;
+    n -= m;
+  }
+  return 0;
+}
+
+/* ------------------------------------------------------------------------ */
+char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n) {
+  if (n > buff->buffsize) {
+    if (n < LUA_MINBUFFER) n = LUA_MINBUFFER;
+    luaM_reallocvector(L, buff->buffer, buff->buffsize, n, char);
+    buff->buffsize = n;
+  }
+  return buff->buffer;
+}
+
+

Added: trunk/Util/deditor/lua/lzio.h
===================================================================
--- trunk/Util/deditor/lua/lzio.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lzio.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,64 @@
+/*
+** $Id: lzio.h,v 1.15 2003/03/20 16:00:56 roberto Exp $
+** Buffered streams
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lzio_h
+#define lzio_h
+
+#include "lua.h"
+
+
+#define EOZ	(-1)			/* end of stream */
+
+typedef struct Zio ZIO;
+
+
+#define char2int(c)	cast(int, cast(unsigned char, (c)))
+
+#define zgetc(z)  (((z)->n--)>0 ?  char2int(*(z)->p++) : luaZ_fill(z))
+
+#define zname(z)	((z)->name)
+
+void luaZ_init (ZIO *z, lua_Chunkreader reader, void *data, const char *name);
+size_t luaZ_read (ZIO* z, void* b, size_t n);	/* read next n bytes */
+int luaZ_lookahead (ZIO *z);
+
+
+
+typedef struct Mbuffer {
+  char *buffer;
+  size_t buffsize;
+} Mbuffer;
+
+
+char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n);
+
+#define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
+
+#define luaZ_sizebuffer(buff)	((buff)->buffsize)
+#define luaZ_buffer(buff)	((buff)->buffer)
+
+#define luaZ_resizebuffer(L, buff, size) \
+	(luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), \
+	(buff)->buffsize = size)
+
+#define luaZ_freebuffer(L, buff)	luaZ_resizebuffer(L, buff, 0)
+
+
+/* --------- Private Part ------------------ */
+
+struct Zio {
+  size_t n;			/* bytes still unread */
+  const char *p;		/* current position in buffer */
+  lua_Chunkreader reader;
+  void* data;			/* additional data */
+  const char *name;
+};
+
+
+int luaZ_fill (ZIO *z);
+
+#endif

Added: trunk/Util/deditor/main.cpp
===================================================================
--- trunk/Util/deditor/main.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/main.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,25 @@
+
+#include <qapplication.h>
+#include "helpers.h"
+#include "application.h"
+
+#ifdef WIN32
+#include <windows.h>
+#endif
+
+int main( int argc, char ** argv ) {
+	#ifdef WIN32
+	char szPath[MAX_PATH];
+	GetModuleFileName(NULL, szPath, sizeof(szPath));
+	if (strrchr(szPath, '\\')) *strrchr(szPath, '\\') = '\0';
+	SetCurrentDirectory(szPath);
+	#endif
+
+	WriteLog("main\n");
+    QApplication a( argc, argv );
+    ApplicationWindow * mw = new ApplicationWindow();
+    mw->setCaption( "TW-Light Dialog Editor" );
+    mw->show();
+    a.connect( &a, SIGNAL(lastWindowClosed()), &a, SLOT(quit()) );
+    return a.exec();
+}

Added: trunk/Util/deditor/maindialog.cpp
===================================================================
--- trunk/Util/deditor/maindialog.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/maindialog.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,425 @@
+/****************************************************************************
+** Form implementation generated from reading ui file 'MainDialog.ui'
+**
+** Created: Wed Sep 1 19:55:28 2004
+**      by:  The User Interface Compiler (uic)
+**
+** WARNING! All changes made in this file will be lost!
+****************************************************************************/
+#include "maindialog.h"
+
+#include <qcheckbox.h>
+#include <qgroupbox.h>
+#include <qheader.h>
+#include <qlabel.h>
+#include <qlineedit.h>
+#include <qlistview.h>
+#include <qmultilineedit.h>
+#include <qpushbutton.h>
+#include <qtable.h>
+#include <qtabwidget.h>
+#include <qtextbrowser.h>
+#include <qlayout.h>
+#include <qvariant.h>
+#include <qtooltip.h>
+#include <qwhatsthis.h>
+
+/* 
+ *  Constructs a DialogEditorGenerated which is a child of 'parent', with the 
+ *  name 'name' and widget flags set to 'f' 
+ */
+DialogEditorGenerated::DialogEditorGenerated( QWidget* parent,  const char* name, WFlags fl )
+    : QWidget( parent, name, fl )
+{
+    if ( !name )
+	setName( "DialogEditorGenerated" );
+    resize( 785, 452 ); 
+    setCaption( tr( "Form1" ) );
+    DialogEditorGeneratedLayout = new QGridLayout( this ); 
+    DialogEditorGeneratedLayout->setSpacing( 6 );
+    DialogEditorGeneratedLayout->setMargin( 11 );
+
+    Layout17 = new QGridLayout; 
+    Layout17->setSpacing( 6 );
+    Layout17->setMargin( 0 );
+
+    Layout19 = new QVBoxLayout; 
+    Layout19->setSpacing( 6 );
+    Layout19->setMargin( 0 );
+
+    Layout18 = new QHBoxLayout; 
+    Layout18->setSpacing( 6 );
+    Layout18->setMargin( 0 );
+
+    TextLabel3 = new QLabel( this, "TextLabel3" );
+    TextLabel3->setText( tr( "Triggers:" ) );
+    Layout18->addWidget( TextLabel3 );
+
+    TextLabel12 = new QLabel( this, "TextLabel12" );
+    TextLabel12->setText( tr( "Name" ) );
+    Layout18->addWidget( TextLabel12 );
+
+    TextLabel13 = new QLabel( this, "TextLabel13" );
+    TextLabel13->setText( tr( "Value" ) );
+    Layout18->addWidget( TextLabel13 );
+    Layout19->addLayout( Layout18 );
+
+    triggerTable = new QTable( this, "triggerTable" );
+    triggerTable->setMaximumSize( QSize( 200, 32767 ) );
+    triggerTable->setNumRows( 6 );
+    triggerTable->setNumCols( 6 );
+    QWhatsThis::add(  triggerTable, tr( "First column - trigger name, second - value" ) );
+    Layout19->addWidget( triggerTable );
+
+    nodeListView = new QListView( this, "nodeListView" );
+    nodeListView->addColumn( tr( "ID" ) );
+    nodeListView->addColumn( tr( "Name" ) );
+    nodeListView->setSizePolicy( QSizePolicy( (QSizePolicy::SizeType)7, (QSizePolicy::SizeType)5, nodeListView->sizePolicy().hasHeightForWidth() ) );
+    nodeListView->setMaximumSize( QSize( 200, 32767 ) );
+    QWhatsThis::add(  nodeListView, tr( "Browse nodes from here" ) );
+    Layout19->addWidget( nodeListView );
+
+    Layout17->addLayout( Layout19, 0, 2 );
+
+    Layout20 = new QVBoxLayout; 
+    Layout20->setSpacing( 6 );
+    Layout20->setMargin( 0 );
+
+    alienTextBrowser = new QTextBrowser( this, "alienTextBrowser" );
+    alienTextBrowser->setSizePolicy( QSizePolicy( (QSizePolicy::SizeType)7, (QSizePolicy::SizeType)7, alienTextBrowser->sizePolicy().hasHeightForWidth() ) );
+    alienTextBrowser->setMinimumSize( QSize( 200, 200 ) );
+    QWhatsThis::add(  alienTextBrowser, tr( "Alian picture, and text here" ) );
+    Layout20->addWidget( alienTextBrowser );
+
+    TextLabel4 = new QLabel( this, "TextLabel4" );
+    TextLabel4->setText( tr( "Place text here:" ) );
+    Layout20->addWidget( TextLabel4 );
+
+    commonMultiLineEdit = new QMultiLineEdit( this, "commonMultiLineEdit" );
+    commonMultiLineEdit->setMinimumSize( QSize( 0, 90 ) );
+    QWhatsThis::add(  commonMultiLineEdit, tr( "Text in this edit can be set aso player or alian answer." ) );
+    Layout20->addWidget( commonMultiLineEdit );
+
+    Layout17->addLayout( Layout20, 0, 0 );
+
+    answersListView = new QListView( this, "answersListView" );
+    answersListView->addColumn( tr( "Player answers" ) );
+    QWhatsThis::add(  answersListView, tr( "Player Answers" ) );
+
+    Layout17->addMultiCellWidget( answersListView, 1, 1, 0, 2 );
+
+    Layout14 = new QVBoxLayout; 
+    Layout14->setSpacing( 6 );
+    Layout14->setMargin( 0 );
+
+    TestModeCheckBox = new QCheckBox( this, "TestModeCheckBox" );
+    TestModeCheckBox->setText( tr( "Test Mode (Hide not allowed answers)" ) );
+    Layout14->addWidget( TestModeCheckBox );
+
+    TabWidget2 = new QTabWidget( this, "TabWidget2" );
+    TabWidget2->setSizePolicy( QSizePolicy( (QSizePolicy::SizeType)4, (QSizePolicy::SizeType)4, TabWidget2->sizePolicy().hasHeightForWidth() ) );
+    TabWidget2->setMinimumSize( QSize( 200, 250 ) );
+    TabWidget2->setMargin( 0 );
+
+    tab = new QWidget( TabWidget2, "tab" );
+    tabLayout = new QGridLayout( tab ); 
+    tabLayout->setSpacing( 6 );
+    tabLayout->setMargin( 11 );
+
+    Layout15 = new QGridLayout; 
+    Layout15->setSpacing( 6 );
+    Layout15->setMargin( 0 );
+
+    textLocationLineEdit = new QLineEdit( tab, "textLocationLineEdit" );
+    textLocationLineEdit->setAlignment( int( QLineEdit::AlignLeft ) );
+    QWhatsThis::add(  textLocationLineEdit, tr( "Alien text location" ) );
+
+    Layout15->addMultiCellWidget( textLocationLineEdit, 5, 5, 1, 2 );
+
+    NodeNameLineEdit = new QLineEdit( tab, "NodeNameLineEdit" );
+    NodeNameLineEdit->setAlignment( int( QLineEdit::AlignLeft ) );
+    QWhatsThis::add(  NodeNameLineEdit, tr( "Name is not used" ) );
+
+    Layout15->addMultiCellWidget( NodeNameLineEdit, 1, 1, 1, 2 );
+
+    TextLabel1_3 = new QLabel( tab, "TextLabel1_3" );
+    TextLabel1_3->setText( tr( "Font:" ) );
+    QWhatsThis::add(  TextLabel1_3, tr( "Alien text font" ) );
+
+    Layout15->addWidget( TextLabel1_3, 4, 0 );
+
+    fontLineEdit = new QLineEdit( tab, "fontLineEdit" );
+    fontLineEdit->setAlignment( int( QLineEdit::AlignLeft ) );
+    QWhatsThis::add(  fontLineEdit, tr( "Alien text font" ) );
+
+    Layout15->addMultiCellWidget( fontLineEdit, 4, 4, 1, 2 );
+
+    TextLabel3_2 = new QLabel( tab, "TextLabel3_2" );
+    TextLabel3_2->setText( tr( "Music" ) );
+    QWhatsThis::add(  TextLabel3_2, tr( "Path to music file" ) );
+
+    Layout15->addWidget( TextLabel3_2, 2, 0 );
+
+    TextLabel1 = new QLabel( tab, "TextLabel1" );
+    TextLabel1->setText( tr( "Node ID" ) );
+    QWhatsThis::add(  TextLabel1, tr( "unique identifier for node" ) );
+
+    Layout15->addWidget( TextLabel1, 0, 0 );
+
+    TextLabel2_3 = new QLabel( tab, "TextLabel2_3" );
+    TextLabel2_3->setText( tr( "Text location:" ) );
+    QWhatsThis::add(  TextLabel2_3, tr( "Alien text location" ) );
+
+    Layout15->addWidget( TextLabel2_3, 5, 0 );
+
+    TextLabel4_2 = new QLabel( tab, "TextLabel4_2" );
+    TextLabel4_2->setText( tr( "Background" ) );
+    QWhatsThis::add(  TextLabel4_2, tr( "Path to background picture" ) );
+
+    Layout15->addWidget( TextLabel4_2, 3, 0 );
+    QSpacerItem* spacer = new QSpacerItem( 20, 20, QSizePolicy::Expanding, QSizePolicy::Minimum );
+    Layout15->addItem( spacer, 0, 1 );
+
+    MusicEdit = new QLineEdit( tab, "MusicEdit" );
+    MusicEdit->setAlignment( int( QLineEdit::AlignLeft ) );
+    QWhatsThis::add(  MusicEdit, tr( "Path to music file" ) );
+
+    Layout15->addMultiCellWidget( MusicEdit, 2, 2, 1, 2 );
+
+    BackgroundLineEdit = new QLineEdit( tab, "BackgroundLineEdit" );
+    BackgroundLineEdit->setAlignment( int( QLineEdit::AlignLeft ) );
+    QWhatsThis::add(  BackgroundLineEdit, tr( "Path to background picture" ) );
+
+    Layout15->addMultiCellWidget( BackgroundLineEdit, 3, 3, 1, 2 );
+
+    TextLabel2 = new QLabel( tab, "TextLabel2" );
+    TextLabel2->setText( tr( "Node Name" ) );
+    QWhatsThis::add(  TextLabel2, tr( "Name is not used" ) );
+
+    Layout15->addWidget( TextLabel2, 1, 0 );
+
+    nodeIdLineEdit = new QLineEdit( tab, "nodeIdLineEdit" );
+    nodeIdLineEdit->setAlignment( int( QLineEdit::AlignRight ) );
+    QWhatsThis::add(  nodeIdLineEdit, tr( "unique identifier for node" ) );
+
+    Layout15->addWidget( nodeIdLineEdit, 0, 2 );
+
+    tabLayout->addLayout( Layout15, 0, 0 );
+    TabWidget2->insertTab( tab, tr( "Node" ) );
+
+    tab_2 = new QWidget( TabWidget2, "tab_2" );
+    tabLayout_2 = new QVBoxLayout( tab_2 ); 
+    tabLayout_2->setSpacing( 6 );
+    tabLayout_2->setMargin( 11 );
+
+    Layout12 = new QVBoxLayout; 
+    Layout12->setSpacing( 6 );
+    Layout12->setMargin( 0 );
+
+    Layout11 = new QHBoxLayout; 
+    Layout11->setSpacing( 6 );
+    Layout11->setMargin( 0 );
+
+    TextLabel1_2 = new QLabel( tab_2, "TextLabel1_2" );
+    TextLabel1_2->setText( tr( "Appear condition:" ) );
+    Layout11->addWidget( TextLabel1_2 );
+
+    appearConditionLineEdit = new QLineEdit( tab_2, "appearConditionLineEdit" );
+    QWhatsThis::add(  appearConditionLineEdit, tr( "Answer will not show, if doesn.t match" ) );
+    Layout11->addWidget( appearConditionLineEdit );
+    Layout12->addLayout( Layout11 );
+
+    GroupBox1 = new QGroupBox( tab_2, "GroupBox1" );
+    GroupBox1->setTitle( tr( "Actions" ) );
+    GroupBox1->setColumnLayout(0, Qt::Vertical );
+    GroupBox1->layout()->setSpacing( 0 );
+    GroupBox1->layout()->setMargin( 0 );
+    GroupBox1Layout = new QHBoxLayout( GroupBox1->layout() );
+    GroupBox1Layout->setAlignment( Qt::AlignTop );
+    GroupBox1Layout->setSpacing( 6 );
+    GroupBox1Layout->setMargin( 11 );
+
+    Layout10 = new QVBoxLayout; 
+    Layout10->setSpacing( 6 );
+    Layout10->setMargin( 0 );
+
+    Layout5 = new QHBoxLayout; 
+    Layout5->setSpacing( 6 );
+    Layout5->setMargin( 0 );
+
+    TextLabel2_2 = new QLabel( GroupBox1, "TextLabel2_2" );
+    TextLabel2_2->setText( tr( "condition" ) );
+    Layout5->addWidget( TextLabel2_2 );
+
+    condition1LineEdit = new QLineEdit( GroupBox1, "condition1LineEdit" );
+    QWhatsThis::add(  condition1LineEdit, tr( "if condition match, coresponding action will be evaluated" ) );
+    Layout5->addWidget( condition1LineEdit );
+
+    TextLabel7 = new QLabel( GroupBox1, "TextLabel7" );
+    TextLabel7->setText( tr( "do" ) );
+    Layout5->addWidget( TextLabel7 );
+
+    action1LineEdit = new QLineEdit( GroupBox1, "action1LineEdit" );
+    QWhatsThis::add(  action1LineEdit, tr( "if condition match, coresponding action will be evaluated" ) );
+    Layout5->addWidget( action1LineEdit );
+    Layout10->addLayout( Layout5 );
+
+    Layout6 = new QHBoxLayout; 
+    Layout6->setSpacing( 6 );
+    Layout6->setMargin( 0 );
+
+    TextLabel3_3 = new QLabel( GroupBox1, "TextLabel3_3" );
+    TextLabel3_3->setText( tr( "condition" ) );
+    Layout6->addWidget( TextLabel3_3 );
+
+    condition2LineEdit = new QLineEdit( GroupBox1, "condition2LineEdit" );
+    QWhatsThis::add(  condition2LineEdit, tr( "if condition match, coresponding action will be evaluated" ) );
+    Layout6->addWidget( condition2LineEdit );
+
+    TextLabel8 = new QLabel( GroupBox1, "TextLabel8" );
+    TextLabel8->setText( tr( "do" ) );
+    Layout6->addWidget( TextLabel8 );
+
+    action2LineEdit = new QLineEdit( GroupBox1, "action2LineEdit" );
+    QWhatsThis::add(  action2LineEdit, tr( "if condition match, coresponding action will be evaluated" ) );
+    Layout6->addWidget( action2LineEdit );
+    Layout10->addLayout( Layout6 );
+
+    Layout7 = new QHBoxLayout; 
+    Layout7->setSpacing( 6 );
+    Layout7->setMargin( 0 );
+
+    TextLabel4_3 = new QLabel( GroupBox1, "TextLabel4_3" );
+    TextLabel4_3->setText( tr( "condition" ) );
+    Layout7->addWidget( TextLabel4_3 );
+
+    condition3LineEdit = new QLineEdit( GroupBox1, "condition3LineEdit" );
+    QWhatsThis::add(  condition3LineEdit, tr( "if condition match, coresponding action will be evaluated" ) );
+    Layout7->addWidget( condition3LineEdit );
+
+    TextLabel9 = new QLabel( GroupBox1, "TextLabel9" );
+    TextLabel9->setText( tr( "do" ) );
+    Layout7->addWidget( TextLabel9 );
+
+    action3LineEdit = new QLineEdit( GroupBox1, "action3LineEdit" );
+    QWhatsThis::add(  action3LineEdit, tr( "if condition match, coresponding action will be evaluated" ) );
+    Layout7->addWidget( action3LineEdit );
+    Layout10->addLayout( Layout7 );
+
+    Layout8 = new QHBoxLayout; 
+    Layout8->setSpacing( 6 );
+    Layout8->setMargin( 0 );
+
+    TextLabel5 = new QLabel( GroupBox1, "TextLabel5" );
+    TextLabel5->setText( tr( "condition" ) );
+    Layout8->addWidget( TextLabel5 );
+
+    condition4LineEdit = new QLineEdit( GroupBox1, "condition4LineEdit" );
+    QWhatsThis::add(  condition4LineEdit, tr( "if condition match, coresponding action will be evaluated" ) );
+    Layout8->addWidget( condition4LineEdit );
+
+    TextLabel10 = new QLabel( GroupBox1, "TextLabel10" );
+    TextLabel10->setText( tr( "do" ) );
+    Layout8->addWidget( TextLabel10 );
+
+    action4LineEdit = new QLineEdit( GroupBox1, "action4LineEdit" );
+    QWhatsThis::add(  action4LineEdit, tr( "if condition match, coresponding action will be evaluated" ) );
+    Layout8->addWidget( action4LineEdit );
+    Layout10->addLayout( Layout8 );
+
+    Layout9 = new QHBoxLayout; 
+    Layout9->setSpacing( 6 );
+    Layout9->setMargin( 0 );
+
+    TextLabel6 = new QLabel( GroupBox1, "TextLabel6" );
+    TextLabel6->setText( tr( "condition" ) );
+    Layout9->addWidget( TextLabel6 );
+
+    condition5LineEdit = new QLineEdit( GroupBox1, "condition5LineEdit" );
+    QWhatsThis::add(  condition5LineEdit, tr( "if condition match, coresponding action will be evaluated" ) );
+    Layout9->addWidget( condition5LineEdit );
+
+    TextLabel11 = new QLabel( GroupBox1, "TextLabel11" );
+    TextLabel11->setText( tr( "do" ) );
+    Layout9->addWidget( TextLabel11 );
+
+    action5LineEdit = new QLineEdit( GroupBox1, "action5LineEdit" );
+    QWhatsThis::add(  action5LineEdit, tr( "if condition match, coresponding action will be evaluated" ) );
+    Layout9->addWidget( action5LineEdit );
+    Layout10->addLayout( Layout9 );
+    GroupBox1Layout->addLayout( Layout10 );
+    Layout12->addWidget( GroupBox1 );
+    tabLayout_2->addLayout( Layout12 );
+    TabWidget2->insertTab( tab_2, tr( "Answer" ) );
+    Layout14->addWidget( TabWidget2 );
+
+    Layout17->addLayout( Layout14, 0, 1 );
+
+    DialogEditorGeneratedLayout->addLayout( Layout17, 0, 0 );
+
+    // signals and slots connections
+    connect( nodeListView, SIGNAL( selectionChanged(QListViewItem*) ), this, SLOT( nodeChangedSlot(QListViewItem* ) ) );
+    connect( answersListView, SIGNAL( returnPressed(QListViewItem*) ), this, SLOT( processAnswerSlot(QListViewItem*) ) );
+    connect( answersListView, SIGNAL( doubleClicked(QListViewItem*) ), this, SLOT( processAnswerSlot(QListViewItem*) ) );
+    connect( answersListView, SIGNAL( selectionChanged(QListViewItem*) ), this, SLOT( answerChangedSlot(QListViewItem*) ) );
+
+    // tab order
+    setTabOrder( nodeIdLineEdit, NodeNameLineEdit );
+    setTabOrder( NodeNameLineEdit, MusicEdit );
+    setTabOrder( MusicEdit, BackgroundLineEdit );
+    setTabOrder( BackgroundLineEdit, commonMultiLineEdit );
+    setTabOrder( commonMultiLineEdit, nodeListView );
+    setTabOrder( nodeListView, triggerTable );
+    setTabOrder( triggerTable, alienTextBrowser );
+    setTabOrder( alienTextBrowser, TabWidget2 );
+    setTabOrder( TabWidget2, appearConditionLineEdit );
+    setTabOrder( appearConditionLineEdit, condition1LineEdit );
+    setTabOrder( condition1LineEdit, action1LineEdit );
+    setTabOrder( action1LineEdit, condition2LineEdit );
+    setTabOrder( condition2LineEdit, action2LineEdit );
+    setTabOrder( action2LineEdit, condition3LineEdit );
+    setTabOrder( condition3LineEdit, action3LineEdit );
+    setTabOrder( action3LineEdit, condition4LineEdit );
+    setTabOrder( condition4LineEdit, action4LineEdit );
+    setTabOrder( action4LineEdit, condition5LineEdit );
+    setTabOrder( condition5LineEdit, action5LineEdit );
+}
+
+/*  
+ *  Destroys the object and frees any allocated resources
+ */
+DialogEditorGenerated::~DialogEditorGenerated()
+{
+    // no need to delete child widgets, Qt does it all for us
+}
+
+void DialogEditorGenerated::answerChangedSlot(QListViewItem*)
+{
+    qWarning( "DialogEditorGenerated::answerChangedSlot(QListViewItem*): Not implemented yet!" );
+}
+
+void DialogEditorGenerated::answerPositionChanged(int)
+{
+    qWarning( "DialogEditorGenerated::answerPositionChanged(int): Not implemented yet!" );
+}
+
+void DialogEditorGenerated::nodeChangedSlot(QListViewItem* )
+{
+    qWarning( "DialogEditorGenerated::nodeChangedSlot(QListViewItem* ): Not implemented yet!" );
+}
+
+void DialogEditorGenerated::processAnswerSlot(QListViewItem*)
+{
+    qWarning( "DialogEditorGenerated::processAnswerSlot(QListViewItem*): Not implemented yet!" );
+}
+
+void DialogEditorGenerated::saveAnswer()
+{
+    qWarning( "DialogEditorGenerated::saveAnswer(): Not implemented yet!" );
+}
+
+void DialogEditorGenerated::saveNodeInfo()
+{
+    qWarning( "DialogEditorGenerated::saveNodeInfo(): Not implemented yet!" );
+}
+

Added: trunk/Util/deditor/maindialog.h
===================================================================
--- trunk/Util/deditor/maindialog.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/maindialog.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,114 @@
+/****************************************************************************
+** Form interface generated from reading ui file 'MainDialog.ui'
+**
+** Created: Wed Sep 1 19:55:28 2004
+**      by:  The User Interface Compiler (uic)
+**
+** WARNING! All changes made in this file will be lost!
+****************************************************************************/
+#ifndef DIALOGEDITORGENERATED_H
+#define DIALOGEDITORGENERATED_H
+
+#include <qvariant.h>
+#include <qwidget.h>
+class QVBoxLayout; 
+class QHBoxLayout; 
+class QGridLayout; 
+class QCheckBox;
+class QGroupBox;
+class QLabel;
+class QLineEdit;
+class QListView;
+class QListViewItem;
+class QMultiLineEdit;
+class QTabWidget;
+class QTable;
+class QTextBrowser;
+
+class DialogEditorGenerated : public QWidget
+{ 
+    Q_OBJECT
+
+public:
+    DialogEditorGenerated( QWidget* parent = 0, const char* name = 0, WFlags fl = 0 );
+    ~DialogEditorGenerated();
+
+    QLabel* TextLabel3;
+    QLabel* TextLabel12;
+    QLabel* TextLabel13;
+    QTable* triggerTable;
+    QListView* nodeListView;
+    QTextBrowser* alienTextBrowser;
+    QLabel* TextLabel4;
+    QMultiLineEdit* commonMultiLineEdit;
+    QListView* answersListView;
+    QCheckBox* TestModeCheckBox;
+    QTabWidget* TabWidget2;
+    QWidget* tab;
+    QLineEdit* textLocationLineEdit;
+    QLineEdit* NodeNameLineEdit;
+    QLabel* TextLabel1_3;
+    QLineEdit* fontLineEdit;
+    QLabel* TextLabel3_2;
+    QLabel* TextLabel1;
+    QLabel* TextLabel2_3;
+    QLabel* TextLabel4_2;
+    QLineEdit* MusicEdit;
+    QLineEdit* BackgroundLineEdit;
+    QLabel* TextLabel2;
+    QLineEdit* nodeIdLineEdit;
+    QWidget* tab_2;
+    QLabel* TextLabel1_2;
+    QLineEdit* appearConditionLineEdit;
+    QGroupBox* GroupBox1;
+    QLabel* TextLabel2_2;
+    QLineEdit* condition1LineEdit;
+    QLabel* TextLabel7;
+    QLineEdit* action1LineEdit;
+    QLabel* TextLabel3_3;
+    QLineEdit* condition2LineEdit;
+    QLabel* TextLabel8;
+    QLineEdit* action2LineEdit;
+    QLabel* TextLabel4_3;
+    QLineEdit* condition3LineEdit;
+    QLabel* TextLabel9;
+    QLineEdit* action3LineEdit;
+    QLabel* TextLabel5;
+    QLineEdit* condition4LineEdit;
+    QLabel* TextLabel10;
+    QLineEdit* action4LineEdit;
+    QLabel* TextLabel6;
+    QLineEdit* condition5LineEdit;
+    QLabel* TextLabel11;
+    QLineEdit* action5LineEdit;
+
+public slots:
+    virtual void answerChangedSlot(QListViewItem*);
+    virtual void answerPositionChanged(int);
+    virtual void nodeChangedSlot(QListViewItem* );
+    virtual void processAnswerSlot(QListViewItem*);
+    virtual void saveAnswer();
+    virtual void saveNodeInfo();
+
+protected:
+    QGridLayout* DialogEditorGeneratedLayout;
+    QGridLayout* Layout17;
+    QVBoxLayout* Layout19;
+    QHBoxLayout* Layout18;
+    QVBoxLayout* Layout20;
+    QVBoxLayout* Layout14;
+    QGridLayout* tabLayout;
+    QGridLayout* Layout15;
+    QVBoxLayout* tabLayout_2;
+    QVBoxLayout* Layout12;
+    QHBoxLayout* Layout11;
+    QHBoxLayout* GroupBox1Layout;
+    QVBoxLayout* Layout10;
+    QHBoxLayout* Layout5;
+    QHBoxLayout* Layout6;
+    QHBoxLayout* Layout7;
+    QHBoxLayout* Layout8;
+    QHBoxLayout* Layout9;
+};
+
+#endif // DIALOGEDITORGENERATED_H

Added: trunk/Util/deditor/mainwidget.cpp
===================================================================
--- trunk/Util/deditor/mainwidget.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/mainwidget.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,514 @@
+
+#include "mainwidget.h"
+#include <qtextbrowser.h>
+#include <qtable.h> 
+#include <qlistview.h>
+#include <qlineedit.h>
+#include <qxml.h> 
+#include <qfile.h>
+#include <qmessagebox.h>
+#include <qmultilineedit.h>
+#include <qimage.h>
+#include <qdir.h>
+#include <qcheckbox.h>
+#include <qspinbox.h>
+
+#include <assert.h>
+
+#include "node.h"
+#include "xmlparser.h"
+#include <io.h>
+
+extern "C" {
+#	include "lua.h"
+#	include "lualib.h"
+#	include "lauxlib.h"
+}
+
+DialogEditor::DialogEditor( QWidget* parent, const char* name, WFlags fl ): DialogEditorGenerated(parent, name, fl)
+{
+	WriteLog("DialogEditor::DialogEditor\n");
+	alienTextBrowser->setFrameStyle( QFrame::Panel | QFrame::Sunken );
+	alienTextBrowser->setText("<HTML><BODY><center><img width=\"100\" height=\"100\" src=\"./tw-logo.png\"><br>Alien text and picture will be here</center></BODY></HTML>");
+	alienTextBrowser->mimeSourceFactory()->setExtensionType("qml", "text/utf8");
+
+	CreateNewNode();
+	answersListView->setSorting(-1);
+}
+
+DialogEditor::~DialogEditor()
+{
+	WriteLog("DialogEditor::~DialogEditor\n");
+}
+
+
+PlayerAnswer* DialogEditor::getPlayerAnswer(QString& text)
+{
+	NodeItem * node = (NodeItem*)nodeListView->currentItem();
+	PlayerAnswer * a;
+	for(a = node->m_answers.first();
+			a; a = node->m_answers.next())
+		if(a->m_strText == text)
+			break;
+	assert(a&&"Answer was not found in node!!!");
+	return a;
+}
+
+int DialogEditor::getPlayerAnswerPos(QString& text)
+{
+	NodeItem * node = (NodeItem*)nodeListView->currentItem();
+	PlayerAnswer * a;
+	int pos = 0;
+	for(a = node->m_answers.first();
+			a; a = node->m_answers.next())
+			{
+				if(a->m_strText == text)
+					break;
+				pos++;
+			}
+	assert(a&&"Answer was not found in node!!!");
+	return pos;
+}
+
+void DialogEditor::removeAnswer()
+{		
+	WriteLog("DialogEditor::removeAnswer()\n");
+	QListViewItem * curAnsw = answersListView->currentItem();
+	if (!curAnsw)
+			return;
+	NodeItem * node = (NodeItem*)nodeListView->currentItem();
+	node->m_answers.remove(getPlayerAnswer(curAnsw->text(0)));
+
+	delete curAnsw;
+}
+
+void DialogEditor::removeNode()
+{
+	WriteLog("DialogEditor::removeNode()\n");
+	if(nodeListView->childCount()==1)
+		return;
+	
+	QListViewItem* item= nodeListView->currentItem();
+	QListViewItemIterator it( item );
+	it++;
+	if(it.current())
+	{
+		nodeListView->setCurrentItem(it.current());
+	}
+	else
+	{
+		QListViewItemIterator i( item );
+		i--;
+		nodeListView->setCurrentItem(i.current());
+	}
+	delete item;
+}
+
+void DialogEditor::CreateNewNode()
+{
+	WriteLog("DialogEditor::CreateNewNode()\n");
+	int nodeCount = nodeListView->childCount();
+	
+	QString strId;
+	if (nodeCount)
+	{
+		int id = 0;
+		QListViewItem* item = nodeListView->firstChild ();
+		QListViewItemIterator it( item );
+		for(;it.current();it++)
+		{
+			if(it.current()->text(0).toInt()>id)
+				id = it.current()->text(0).toInt();
+		}
+		strId.sprintf("%d",id+1);
+	}
+	else
+	{
+		strId = "0";
+	}
+	NodeItem* critem = new NodeItem ( nodeListView ) ;
+
+	NodeItem * node = (NodeItem*)nodeListView->currentItem();
+	if(node)
+	{
+		critem->setFont(node->m_strFont);
+		critem->setPicture(node->m_strPicture);
+		critem->setTextLocation(node->m_strTextLocation);
+		critem->setMusic(node->m_strMusic);
+	}
+	critem->setName("New node name");
+	critem->setID( strId );
+	nodeListView->setCurrentItem(critem);
+}
+
+void DialogEditor::nodeChangedSlot(QListViewItem* i)
+{
+	WriteLog("DialogEditor::nodeChangedSlot\n");
+	NodeItem * node = (NodeItem*)i;
+	if (!i)
+		return;
+
+	// disconnect edits from previous
+	disconnect( nodeIdLineEdit,     0, 0, 0 );
+	disconnect( NodeNameLineEdit,   0, 0, 0 );
+	disconnect( MusicEdit,          0, 0, 0 );
+	disconnect( BackgroundLineEdit, 0, 0, 0 );
+	disconnect( textLocationLineEdit, 0, 0, 0 );
+	disconnect( fontLineEdit, 0, 0, 0 );
+
+	connect( nodeIdLineEdit, SIGNAL( textChanged ( const QString&)), 
+		node, SLOT(setID(const QString&)));
+	connect( NodeNameLineEdit, SIGNAL( textChanged ( const QString&)), 
+		node, SLOT(setName(const QString&)));
+	connect( MusicEdit, SIGNAL( textChanged ( const QString&)), 
+		node, SLOT(setMusic(const QString&)));
+	connect( BackgroundLineEdit, SIGNAL( textChanged ( const QString&)), 
+		node, SLOT(setPicture(const QString&)));
+	connect( textLocationLineEdit, SIGNAL( textChanged ( const QString&)), 
+		node, SLOT(setTextLocation(const QString&)));
+	connect( fontLineEdit, SIGNAL( textChanged ( const QString&)), 
+		node, SLOT(setFont(const QString&)));
+
+	nodeIdLineEdit      ->setText(node->text(0));
+	NodeNameLineEdit    ->setText(node->text(1));
+	MusicEdit           ->setText(node->m_strMusic);
+	BackgroundLineEdit  ->setText(node->m_strPicture);
+	textLocationLineEdit->setText(node->m_strTextLocation);
+	fontLineEdit        ->setText(node->m_strFont);
+
+	// Set Browser
+	QString browserText;
+	browserText += "<HTML><BODY><CENTER>";
+	if(node->m_strPicture!= "")
+	{
+		browserText += QString("").sprintf("<img width=\"100\" height=\"100\""
+			"src=\"alien\" alt=\"Home\" border=\"0\"><br>");
+	}
+
+	browserText += node->m_strAlienText;
+	browserText += "</CENTER></BODY></HTML>";
+
+	alienTextBrowser->mimeSourceFactory()->setFilePath( QDir::currentDirPath() );
+	alienTextBrowser->mimeSourceFactory()->setImage("alien",QImage(BackgroundLineEdit->text()));
+	alienTextBrowser->setText(browserText);
+
+	// Set Answers
+	disconnectAnswer();
+	answersListView->clear();
+	for(PlayerAnswer * a = node->m_answers. last();
+		a; a = node->m_answers.prev())
+	{
+		if (script_check_condition(a->m_strAppearCondition) || !TestModeCheckBox->isChecked ())
+			QListViewItem * item = new QListViewItem(answersListView,a->m_strText);
+	//	answersListView     ->setCurrentItem(item);
+	}
+}
+
+
+void DialogEditor::disconnectAnswer()
+{
+	WriteLog("DialogEditor::disconnectAnswer()\n");
+	disconnect(condition1LineEdit, 0, 0, 0);
+	condition1LineEdit->setText("");
+	condition1LineEdit->setEnabled(FALSE);
+	disconnect(condition2LineEdit, 0, 0, 0);
+	condition2LineEdit->setText("");
+	condition2LineEdit->setEnabled(FALSE);
+	disconnect(condition3LineEdit, 0, 0, 0);
+	condition3LineEdit->setText("");
+	condition3LineEdit->setEnabled(FALSE);
+	disconnect(condition4LineEdit, 0, 0, 0);
+	condition4LineEdit->setText("");
+	condition4LineEdit->setEnabled(FALSE);
+	disconnect(condition5LineEdit, 0, 0, 0);
+	condition5LineEdit->setText("");
+	condition5LineEdit->setEnabled(FALSE);
+
+	disconnect(action1LineEdit, 0, 0, 0);
+	action1LineEdit->setText("");
+	action1LineEdit->setEnabled(FALSE);
+	disconnect(action2LineEdit, 0, 0, 0);
+	action2LineEdit->setText("");
+	action2LineEdit->setEnabled(FALSE);
+	disconnect(action3LineEdit, 0, 0, 0);
+	action3LineEdit->setText("");
+	action3LineEdit->setEnabled(FALSE);
+	disconnect(action4LineEdit, 0, 0, 0);
+	action4LineEdit->setText("");
+	action4LineEdit->setEnabled(FALSE);
+	disconnect(action5LineEdit, 0, 0, 0);
+	action5LineEdit->setText("");
+	action5LineEdit->setEnabled(FALSE);
+
+	disconnect(appearConditionLineEdit, 0, 0, 0);
+	appearConditionLineEdit->setText("");
+	appearConditionLineEdit->setEnabled(FALSE);
+}
+
+
+void DialogEditor::answerChangedSlot(QListViewItem* item)
+{
+	WriteLog("DialogEditor::answerChangedSlot(QListViewItem* item)\n");
+	disconnectAnswer();
+	if(!item)
+	{
+		condition1LineEdit->setEnabled ( FALSE ) ;
+		return;
+	}
+	
+
+	PlayerAnswer * pa = getPlayerAnswer(item->text(0));
+
+	connect( condition1LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setCondition1Line(const QString&)));
+	condition1LineEdit->setEnabled(TRUE);
+	connect( condition2LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setCondition2Line(const QString&)));
+	condition2LineEdit->setEnabled(TRUE);
+	connect( condition3LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setCondition3Line(const QString&)));
+	condition3LineEdit->setEnabled(TRUE);
+	connect( condition4LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setCondition4Line(const QString&)));
+	condition4LineEdit->setEnabled(TRUE);
+	connect( condition5LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setCondition5Line(const QString&)));
+	condition5LineEdit->setEnabled(TRUE);
+
+	connect( action1LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setAction1Line(const QString&)));
+	action1LineEdit->setEnabled(TRUE);
+	connect( action2LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setAction2Line(const QString&)));
+	action2LineEdit->setEnabled(TRUE);
+	connect( action3LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setAction3Line(const QString&)));
+	action3LineEdit->setEnabled(TRUE);
+	connect( action4LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setAction4Line(const QString&)));
+	action4LineEdit->setEnabled(TRUE);
+	connect( action5LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setAction5Line(const QString&)));
+	action5LineEdit->setEnabled(TRUE);
+
+	connect( appearConditionLineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setAppearCondition(const QString&)));
+	appearConditionLineEdit->setEnabled(TRUE);
+
+	condition1LineEdit->setText(pa->m_strCond[0]);
+	condition2LineEdit->setText(pa->m_strCond[1]);
+	condition3LineEdit->setText(pa->m_strCond[2]);
+	condition4LineEdit->setText(pa->m_strCond[3]);
+	condition5LineEdit->setText(pa->m_strCond[4]);
+
+	action1LineEdit->setText(pa->m_strAct[0]);
+	action2LineEdit->setText(pa->m_strAct[1]);
+	action3LineEdit->setText(pa->m_strAct[2]);
+	action4LineEdit->setText(pa->m_strAct[3]);
+	action5LineEdit->setText(pa->m_strAct[4]);
+
+	appearConditionLineEdit->setText(pa->m_strAppearCondition);
+
+	commonMultiLineEdit->setText(item->text(0));
+}
+
+QString DialogEditor::GetXML()
+{
+	WriteLog("DialogEditor::edited()\n");
+	QString strRes;
+	strRes += "<NODES>";
+	QListViewItem* item = nodeListView->firstChild ();
+	QListViewItemIterator it( item );
+	for(;it.current();it++)
+	{
+		NodeItem *item = (NodeItem*)it.current();
+		strRes += "<NODE id=\""   + TWEscapeXML(item->text(0)) + "\"";
+		strRes += " name=\""      + TWEscapeXML(item->text(1)) + "\"";
+		strRes += " music=\""     + TWEscapeXML(item->m_strMusic) + "\"";
+		strRes += " background=\""+ TWEscapeXML(item->m_strPicture) + "\"";
+		strRes += " alien_text=\""+ TWEscapeXML(item->m_strAlienText) + "\"";
+		strRes += " font=\""+ TWEscapeXML(item->m_strFont) + "\"";
+		strRes += " text_location=\""+ TWEscapeXML(item->m_strTextLocation) + "\"";
+		strRes += ">";
+
+
+		for(PlayerAnswer * a = item->m_answers.first();
+			a; a = item->m_answers.next())
+		{	
+			strRes +="<PLAYER_ANSWER ";
+			strRes +="text=\"" + TWEscapeXML(a->m_strText) + "\" ";
+			strRes +="appear_condition=\"" + TWEscapeXML(a->m_strAppearCondition) + "\">";
+			
+			for(int j=0;j<5;j++)
+				if( !(a->m_strCond[j].isEmpty()) && !(a->m_strAct[j].isEmpty()))
+				{
+					strRes += "<ACTION ";
+					strRes += "condition=\"" + TWEscapeXML(a->m_strCond[j]) + "\" ";
+					strRes += "action=\"" + TWEscapeXML(a->m_strAct[j]) + "\">";
+					strRes += "</ACTION>";
+				}
+			strRes +="</PLAYER_ANSWER>";
+		}
+		strRes += "</NODE>";
+	}
+	strRes += "</NODES>";
+	return strRes;
+}
+
+void DialogEditor::loadDoc(QString fileName)
+{
+  WriteLog("DialogEditor::loadDoc(QString fileName)\n");
+
+  if(fileName.find(".xml", 0, FALSE)==-1)
+  {
+	  QString mes;
+	  mes.sprintf("file:\n%s\nDoes not have xml extension", fileName);
+
+	  QMessageBox::warning (this, "TW-Light editor",
+			mes);
+  }
+
+  QFile f(fileName);
+  XMLParser handler(this);
+  QXmlInputSource source(f);
+
+  QXmlSimpleReader reader;
+  reader.setContentHandler( &handler );
+  reader.parse( source );
+}
+
+void DialogEditor::setAlienText()
+{
+	WriteLog("DialogEditor::setAlienText()\n");
+	NodeItem * node = (NodeItem*)nodeListView->currentItem();
+	node->m_strAlienText = commonMultiLineEdit->text();
+	nodeChangedSlot(node);
+}
+
+void DialogEditor::setPlayerAnswerText()
+{
+	WriteLog("DialogEditor::setPlayerAnswerText()\n");
+	QListViewItem * curAnsw = answersListView->currentItem();
+	if(!curAnsw)
+		return;
+	PlayerAnswer * pa = getPlayerAnswer(curAnsw->text(0));
+	pa->m_strText = commonMultiLineEdit->text();
+	curAnsw->setText(0, commonMultiLineEdit->text());
+}
+
+void DialogEditor::AddPlayerAnswer()
+{
+	WriteLog("DialogEditor::AddPlayerAnswer()\n");
+	NodeItem * node = (NodeItem*)nodeListView->currentItem();
+	PlayerAnswer * item = new PlayerAnswer;
+	item->m_strText = commonMultiLineEdit->text();
+	item->m_strAppearCondition = "1";
+
+	node->m_answers.append(item);
+	nodeChangedSlot(node);
+}
+
+// To be implemented
+bool DialogEditor::script_check_condition(QString & condition)
+{
+	WriteLog("DialogEditor::script_check_condition(QString & condition)\n");
+	return true;
+}
+
+NodeItem * DialogEditor::getNodeItem(QString& id)
+{
+	WriteLog("DialogEditor::getNodeItem(QString& id)\n");
+	QListViewItem* item = nodeListView->firstChild ();
+	QListViewItemIterator it( item );
+	for(;it.current();it++)
+	{
+		if(it.current()->text(0) == id)
+			return (NodeItem *)it.current();
+	}
+	return NULL;
+}
+
+
+void DialogEditor::processAnswerSlot(QListViewItem* item)
+{
+	WriteLog("DialogEditor::processAnswerSlot(QListViewItem* item)\n");
+	PlayerAnswer* answer = getPlayerAnswer(item->text(0));
+	for(int i=0;i<5;i++)
+	{
+			lua_State * L = lua_open();
+			lua_baselibopen(L);
+			lua_iolibopen(L);
+			lua_strlibopen(L);
+			lua_mathlibopen(L);
+			bool eva = lua_dostring(L, "function goto(id) gotoid = id; end");
+			eva = lua_dostring(L, answer->m_strAct[i]);
+			lua_getglobal(L, "gotoid");
+			if (lua_isstring(L, -1)) 
+			{
+				const char * id = lua_tostring(L, -1);
+				NodeItem * node = getNodeItem(QString(id));
+				if(node)
+					nodeListView->setCurrentItem(node);
+			}
+			lua_close(L);
+	}
+}
+
+void DialogEditor::answerUp()
+{
+	NodeItem * node = (NodeItem*)nodeListView->currentItem();
+	QListViewItem * item = answersListView->currentItem();
+
+	if(!node || !item)
+		return;
+	
+	int pos = getPlayerAnswerPos(item->text(0));
+	if(pos==0)
+		return;
+	
+	QString strText = item->text(0);
+	PlayerAnswer* answer = node->m_answers.take(pos);
+	node->m_answers.insert(pos-1, answer);
+
+	nodeChangedSlot(node);	
+
+	QListViewItemIterator it( answersListView->firstChild () );
+	for(;it.current();it++)
+	{
+		if(it.current()->text(0)==strText)
+		{
+			answersListView->setCurrentItem(it.current());
+			break;
+		}
+	}
+}
+
+void DialogEditor::answerDown()
+{
+	NodeItem * node = (NodeItem*)nodeListView->currentItem();
+	QListViewItem * item = answersListView->currentItem();
+	
+	if(!node || !item)
+		return;
+
+	int pos = getPlayerAnswerPos(item->text(0));
+	if(pos==node->m_answers.count()-1 )
+		return;
+	
+	QString strText = item->text(0);
+
+	PlayerAnswer* answer = node->m_answers.take(pos);
+	node->m_answers.insert(pos+1, answer);
+
+	nodeChangedSlot(node);	
+	QListViewItemIterator it( answersListView->firstChild () );
+	for(;it.current();it++)
+	{
+		if(it.current()->text(0)==strText)
+		{
+			answersListView->setCurrentItem(it.current());
+			break;
+		}
+	}
+}
+

Added: trunk/Util/deditor/mainwidget.h
===================================================================
--- trunk/Util/deditor/mainwidget.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/mainwidget.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,52 @@
+#ifndef TW_MAINWIDGET_H
+#define TW_MAINWIDGET_H
+
+#include "maindialog.h"
+#include <qmenubar.h>
+#include <qtoolbar.h>
+#include <qmainwindow.h>
+#include "helpers.h"
+#include "node.h"
+
+class DialogEditor: public DialogEditorGenerated
+{
+private:
+
+public:
+	DialogEditor( QWidget* parent = 0, const char* name = 0, WFlags fl = 0 );
+	~DialogEditor();
+
+	void loadDoc(QString fileName);
+
+	/// Get XML 
+	QString GetXML();
+
+	virtual void setAlienText();
+	virtual void removeNode();
+	virtual void CreateNewNode();
+	virtual void nodeChangedSlot(QListViewItem* );
+	virtual void AddPlayerAnswer();
+	virtual void answerChangedSlot(QListViewItem* item);
+	virtual void removeAnswer();
+	virtual void setPlayerAnswerText();
+	virtual void disconnectAnswer();
+	virtual void processAnswerSlot(QListViewItem*);
+
+	virtual void answerUp();
+	virtual void answerDown();
+
+	NodeItem * getNodeItem(QString& id);
+	PlayerAnswer* getPlayerAnswer(QString& text);
+	int getPlayerAnswerPos(QString& text);
+
+	bool script_check_condition(QString & condition);
+protected:
+	QToolBar *fileTools;
+	QMenuBar *menu;
+
+	void InitMenu();
+	void InitToolBar();
+};
+
+
+#endif TW_MAINWIDGET

Added: trunk/Util/deditor/moc_application.cpp
===================================================================
--- trunk/Util/deditor/moc_application.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/moc_application.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,153 @@
+/****************************************************************************
+** ApplicationWindow meta object code from reading C++ file 'application.h'
+**
+** Created: Wed Sep 1 19:55:28 2004
+**      by: The Qt MOC ($Id: //depot/qt/main/src/moc/moc.y#178 $)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#define Q_MOC_ApplicationWindow
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#define Q_MOC_OUTPUT_REVISION 8
+#elif Q_MOC_OUTPUT_REVISION != 8
+#error "Moc format conflict - please regenerate all moc files"
+#endif
+
+#include "application.h"
+#include <qmetaobject.h>
+#include <qapplication.h>
+
+#if defined(Q_SPARCWORKS_FUNCP_BUG)
+#define Q_AMPERSAND
+#else
+#define Q_AMPERSAND &
+#endif
+
+
+const char *ApplicationWindow::className() const
+{
+    return "ApplicationWindow";
+}
+
+QMetaObject *ApplicationWindow::metaObj = 0;
+
+void ApplicationWindow::initMetaObject()
+{
+    if ( metaObj )
+	return;
+    if ( strcmp(QMainWindow::className(), "QMainWindow") != 0 )
+	badSuperclassWarning("ApplicationWindow","QMainWindow");
+    (void) staticMetaObject();
+}
+
+#ifndef QT_NO_TRANSLATION
+QString ApplicationWindow::tr(const char* s)
+{
+    return ((QNonBaseApplication*)qApp)->translate("ApplicationWindow",s);
+}
+
+#endif // QT_NO_TRANSLATION
+QMetaObject* ApplicationWindow::staticMetaObject()
+{
+    if ( metaObj )
+	return metaObj;
+    (void) QMainWindow::staticMetaObject();
+#ifndef QT_NO_PROPERTIES
+#endif // QT_NO_PROPERTIES
+    typedef void(ApplicationWindow::*m1_t0)();
+    typedef void(ApplicationWindow::*m1_t1)();
+    typedef void(ApplicationWindow::*m1_t2)(QString);
+    typedef void(ApplicationWindow::*m1_t3)();
+    typedef void(ApplicationWindow::*m1_t4)();
+    typedef void(ApplicationWindow::*m1_t5)();
+    typedef void(ApplicationWindow::*m1_t6)();
+    typedef void(ApplicationWindow::*m1_t7)();
+    typedef void(ApplicationWindow::*m1_t8)();
+    typedef void(ApplicationWindow::*m1_t9)();
+    typedef void(ApplicationWindow::*m1_t10)();
+    typedef void(ApplicationWindow::*m1_t11)();
+    typedef void(ApplicationWindow::*m1_t12)();
+    typedef void(ApplicationWindow::*m1_t13)();
+    typedef void(ApplicationWindow::*m1_t14)();
+    typedef void(ApplicationWindow::*m1_t15)();
+    m1_t0 v1_0 = Q_AMPERSAND ApplicationWindow::newDoc;
+    m1_t1 v1_1 = Q_AMPERSAND ApplicationWindow::load;
+    m1_t2 v1_2 = Q_AMPERSAND ApplicationWindow::load;
+    m1_t3 v1_3 = Q_AMPERSAND ApplicationWindow::save;
+    m1_t4 v1_4 = Q_AMPERSAND ApplicationWindow::saveAs;
+    m1_t5 v1_5 = Q_AMPERSAND ApplicationWindow::AddNewNodeSlot;
+    m1_t6 v1_6 = Q_AMPERSAND ApplicationWindow::RemoveNodeSlot;
+    m1_t7 v1_7 = Q_AMPERSAND ApplicationWindow::SetAlienTextSlot;
+    m1_t8 v1_8 = Q_AMPERSAND ApplicationWindow::AddNewPlayerAnswerSlot;
+    m1_t9 v1_9 = Q_AMPERSAND ApplicationWindow::RemovePlayerAnswerSlot;
+    m1_t10 v1_10 = Q_AMPERSAND ApplicationWindow::SetPlayerAnswerTextSlot;
+    m1_t11 v1_11 = Q_AMPERSAND ApplicationWindow::answerUpSlot;
+    m1_t12 v1_12 = Q_AMPERSAND ApplicationWindow::answerDownSlot;
+    m1_t13 v1_13 = Q_AMPERSAND ApplicationWindow::hideNotAllowedAnswersSlot;
+    m1_t14 v1_14 = Q_AMPERSAND ApplicationWindow::evaluateAnswerSlot;
+    m1_t15 v1_15 = Q_AMPERSAND ApplicationWindow::about;
+    QMetaData *slot_tbl = QMetaObject::new_metadata(16);
+    QMetaData::Access *slot_tbl_access = QMetaObject::new_metaaccess(16);
+    slot_tbl[0].name = "newDoc()";
+    slot_tbl[0].ptr = *((QMember*)&v1_0);
+    slot_tbl_access[0] = QMetaData::Private;
+    slot_tbl[1].name = "load()";
+    slot_tbl[1].ptr = *((QMember*)&v1_1);
+    slot_tbl_access[1] = QMetaData::Private;
+    slot_tbl[2].name = "load(QString)";
+    slot_tbl[2].ptr = *((QMember*)&v1_2);
+    slot_tbl_access[2] = QMetaData::Private;
+    slot_tbl[3].name = "save()";
+    slot_tbl[3].ptr = *((QMember*)&v1_3);
+    slot_tbl_access[3] = QMetaData::Private;
+    slot_tbl[4].name = "saveAs()";
+    slot_tbl[4].ptr = *((QMember*)&v1_4);
+    slot_tbl_access[4] = QMetaData::Private;
+    slot_tbl[5].name = "AddNewNodeSlot()";
+    slot_tbl[5].ptr = *((QMember*)&v1_5);
+    slot_tbl_access[5] = QMetaData::Private;
+    slot_tbl[6].name = "RemoveNodeSlot()";
+    slot_tbl[6].ptr = *((QMember*)&v1_6);
+    slot_tbl_access[6] = QMetaData::Private;
+    slot_tbl[7].name = "SetAlienTextSlot()";
+    slot_tbl[7].ptr = *((QMember*)&v1_7);
+    slot_tbl_access[7] = QMetaData::Private;
+    slot_tbl[8].name = "AddNewPlayerAnswerSlot()";
+    slot_tbl[8].ptr = *((QMember*)&v1_8);
+    slot_tbl_access[8] = QMetaData::Private;
+    slot_tbl[9].name = "RemovePlayerAnswerSlot()";
+    slot_tbl[9].ptr = *((QMember*)&v1_9);
+    slot_tbl_access[9] = QMetaData::Private;
+    slot_tbl[10].name = "SetPlayerAnswerTextSlot()";
+    slot_tbl[10].ptr = *((QMember*)&v1_10);
+    slot_tbl_access[10] = QMetaData::Private;
+    slot_tbl[11].name = "answerUpSlot()";
+    slot_tbl[11].ptr = *((QMember*)&v1_11);
+    slot_tbl_access[11] = QMetaData::Private;
+    slot_tbl[12].name = "answerDownSlot()";
+    slot_tbl[12].ptr = *((QMember*)&v1_12);
+    slot_tbl_access[12] = QMetaData::Private;
+    slot_tbl[13].name = "hideNotAllowedAnswersSlot()";
+    slot_tbl[13].ptr = *((QMember*)&v1_13);
+    slot_tbl_access[13] = QMetaData::Private;
+    slot_tbl[14].name = "evaluateAnswerSlot()";
+    slot_tbl[14].ptr = *((QMember*)&v1_14);
+    slot_tbl_access[14] = QMetaData::Private;
+    slot_tbl[15].name = "about()";
+    slot_tbl[15].ptr = *((QMember*)&v1_15);
+    slot_tbl_access[15] = QMetaData::Private;
+    metaObj = QMetaObject::new_metaobject(
+	"ApplicationWindow", "QMainWindow",
+	slot_tbl, 16,
+	0, 0,
+#ifndef QT_NO_PROPERTIES
+	0, 0,
+	0, 0,
+#endif // QT_NO_PROPERTIES
+	0, 0 );
+    metaObj->set_slot_access( slot_tbl_access );
+#ifndef QT_NO_PROPERTIES
+#endif // QT_NO_PROPERTIES
+    return metaObj;
+}

Added: trunk/Util/deditor/moc_maindialog.cpp
===================================================================
--- trunk/Util/deditor/moc_maindialog.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/moc_maindialog.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,103 @@
+/****************************************************************************
+** DialogEditorGenerated meta object code from reading C++ file 'maindialog.h'
+**
+** Created: Wed Sep 1 19:55:28 2004
+**      by: The Qt MOC ($Id: //depot/qt/main/src/moc/moc.y#178 $)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#define Q_MOC_DialogEditorGenerated
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#define Q_MOC_OUTPUT_REVISION 8
+#elif Q_MOC_OUTPUT_REVISION != 8
+#error "Moc format conflict - please regenerate all moc files"
+#endif
+
+#include "maindialog.h"
+#include <qmetaobject.h>
+#include <qapplication.h>
+
+#if defined(Q_SPARCWORKS_FUNCP_BUG)
+#define Q_AMPERSAND
+#else
+#define Q_AMPERSAND &
+#endif
+
+
+const char *DialogEditorGenerated::className() const
+{
+    return "DialogEditorGenerated";
+}
+
+QMetaObject *DialogEditorGenerated::metaObj = 0;
+
+void DialogEditorGenerated::initMetaObject()
+{
+    if ( metaObj )
+	return;
+    if ( strcmp(QWidget::className(), "QWidget") != 0 )
+	badSuperclassWarning("DialogEditorGenerated","QWidget");
+    (void) staticMetaObject();
+}
+
+#ifndef QT_NO_TRANSLATION
+QString DialogEditorGenerated::tr(const char* s)
+{
+    return ((QNonBaseApplication*)qApp)->translate("DialogEditorGenerated",s);
+}
+
+#endif // QT_NO_TRANSLATION
+QMetaObject* DialogEditorGenerated::staticMetaObject()
+{
+    if ( metaObj )
+	return metaObj;
+    (void) QWidget::staticMetaObject();
+#ifndef QT_NO_PROPERTIES
+#endif // QT_NO_PROPERTIES
+    typedef void(DialogEditorGenerated::*m1_t0)(QListViewItem*);
+    typedef void(DialogEditorGenerated::*m1_t1)(int);
+    typedef void(DialogEditorGenerated::*m1_t2)(QListViewItem*);
+    typedef void(DialogEditorGenerated::*m1_t3)(QListViewItem*);
+    typedef void(DialogEditorGenerated::*m1_t4)();
+    typedef void(DialogEditorGenerated::*m1_t5)();
+    m1_t0 v1_0 = Q_AMPERSAND DialogEditorGenerated::answerChangedSlot;
+    m1_t1 v1_1 = Q_AMPERSAND DialogEditorGenerated::answerPositionChanged;
+    m1_t2 v1_2 = Q_AMPERSAND DialogEditorGenerated::nodeChangedSlot;
+    m1_t3 v1_3 = Q_AMPERSAND DialogEditorGenerated::processAnswerSlot;
+    m1_t4 v1_4 = Q_AMPERSAND DialogEditorGenerated::saveAnswer;
+    m1_t5 v1_5 = Q_AMPERSAND DialogEditorGenerated::saveNodeInfo;
+    QMetaData *slot_tbl = QMetaObject::new_metadata(6);
+    QMetaData::Access *slot_tbl_access = QMetaObject::new_metaaccess(6);
+    slot_tbl[0].name = "answerChangedSlot(QListViewItem*)";
+    slot_tbl[0].ptr = *((QMember*)&v1_0);
+    slot_tbl_access[0] = QMetaData::Public;
+    slot_tbl[1].name = "answerPositionChanged(int)";
+    slot_tbl[1].ptr = *((QMember*)&v1_1);
+    slot_tbl_access[1] = QMetaData::Public;
+    slot_tbl[2].name = "nodeChangedSlot(QListViewItem*)";
+    slot_tbl[2].ptr = *((QMember*)&v1_2);
+    slot_tbl_access[2] = QMetaData::Public;
+    slot_tbl[3].name = "processAnswerSlot(QListViewItem*)";
+    slot_tbl[3].ptr = *((QMember*)&v1_3);
+    slot_tbl_access[3] = QMetaData::Public;
+    slot_tbl[4].name = "saveAnswer()";
+    slot_tbl[4].ptr = *((QMember*)&v1_4);
+    slot_tbl_access[4] = QMetaData::Public;
+    slot_tbl[5].name = "saveNodeInfo()";
+    slot_tbl[5].ptr = *((QMember*)&v1_5);
+    slot_tbl_access[5] = QMetaData::Public;
+    metaObj = QMetaObject::new_metaobject(
+	"DialogEditorGenerated", "QWidget",
+	slot_tbl, 6,
+	0, 0,
+#ifndef QT_NO_PROPERTIES
+	0, 0,
+	0, 0,
+#endif // QT_NO_PROPERTIES
+	0, 0 );
+    metaObj->set_slot_access( slot_tbl_access );
+#ifndef QT_NO_PROPERTIES
+#endif // QT_NO_PROPERTIES
+    return metaObj;
+}

Added: trunk/Util/deditor/moc_node.cpp
===================================================================
--- trunk/Util/deditor/moc_node.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/moc_node.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,211 @@
+/****************************************************************************
+** PlayerAnswer meta object code from reading C++ file 'node.h'
+**
+** Created: Wed Sep 1 19:55:28 2004
+**      by: The Qt MOC ($Id: //depot/qt/main/src/moc/moc.y#178 $)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#define Q_MOC_PlayerAnswer
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#define Q_MOC_OUTPUT_REVISION 8
+#elif Q_MOC_OUTPUT_REVISION != 8
+#error "Moc format conflict - please regenerate all moc files"
+#endif
+
+#include "node.h"
+#include <qmetaobject.h>
+#include <qapplication.h>
+
+#if defined(Q_SPARCWORKS_FUNCP_BUG)
+#define Q_AMPERSAND
+#else
+#define Q_AMPERSAND &
+#endif
+
+
+const char *PlayerAnswer::className() const
+{
+    return "PlayerAnswer";
+}
+
+QMetaObject *PlayerAnswer::metaObj = 0;
+
+void PlayerAnswer::initMetaObject()
+{
+    if ( metaObj )
+	return;
+    if ( strcmp(QObject::className(), "QObject") != 0 )
+	badSuperclassWarning("PlayerAnswer","QObject");
+    (void) staticMetaObject();
+}
+
+#ifndef QT_NO_TRANSLATION
+QString PlayerAnswer::tr(const char* s)
+{
+    return ((QNonBaseApplication*)qApp)->translate("PlayerAnswer",s);
+}
+
+#endif // QT_NO_TRANSLATION
+QMetaObject* PlayerAnswer::staticMetaObject()
+{
+    if ( metaObj )
+	return metaObj;
+    (void) QObject::staticMetaObject();
+#ifndef QT_NO_PROPERTIES
+#endif // QT_NO_PROPERTIES
+    typedef void(PlayerAnswer::*m1_t0)(const QString&);
+    typedef void(PlayerAnswer::*m1_t1)(const QString&);
+    typedef void(PlayerAnswer::*m1_t2)(const QString&);
+    typedef void(PlayerAnswer::*m1_t3)(const QString&);
+    typedef void(PlayerAnswer::*m1_t4)(const QString&);
+    typedef void(PlayerAnswer::*m1_t5)(const QString&);
+    typedef void(PlayerAnswer::*m1_t6)(const QString&);
+    typedef void(PlayerAnswer::*m1_t7)(const QString&);
+    typedef void(PlayerAnswer::*m1_t8)(const QString&);
+    typedef void(PlayerAnswer::*m1_t9)(const QString&);
+    typedef void(PlayerAnswer::*m1_t10)(const QString&);
+    m1_t0 v1_0 = Q_AMPERSAND PlayerAnswer::setCondition1Line;
+    m1_t1 v1_1 = Q_AMPERSAND PlayerAnswer::setCondition2Line;
+    m1_t2 v1_2 = Q_AMPERSAND PlayerAnswer::setCondition3Line;
+    m1_t3 v1_3 = Q_AMPERSAND PlayerAnswer::setCondition4Line;
+    m1_t4 v1_4 = Q_AMPERSAND PlayerAnswer::setCondition5Line;
+    m1_t5 v1_5 = Q_AMPERSAND PlayerAnswer::setAction1Line;
+    m1_t6 v1_6 = Q_AMPERSAND PlayerAnswer::setAction2Line;
+    m1_t7 v1_7 = Q_AMPERSAND PlayerAnswer::setAction3Line;
+    m1_t8 v1_8 = Q_AMPERSAND PlayerAnswer::setAction4Line;
+    m1_t9 v1_9 = Q_AMPERSAND PlayerAnswer::setAction5Line;
+    m1_t10 v1_10 = Q_AMPERSAND PlayerAnswer::setAppearCondition;
+    QMetaData *slot_tbl = QMetaObject::new_metadata(11);
+    QMetaData::Access *slot_tbl_access = QMetaObject::new_metaaccess(11);
+    slot_tbl[0].name = "setCondition1Line(const QString&)";
+    slot_tbl[0].ptr = *((QMember*)&v1_0);
+    slot_tbl_access[0] = QMetaData::Public;
+    slot_tbl[1].name = "setCondition2Line(const QString&)";
+    slot_tbl[1].ptr = *((QMember*)&v1_1);
+    slot_tbl_access[1] = QMetaData::Public;
+    slot_tbl[2].name = "setCondition3Line(const QString&)";
+    slot_tbl[2].ptr = *((QMember*)&v1_2);
+    slot_tbl_access[2] = QMetaData::Public;
+    slot_tbl[3].name = "setCondition4Line(const QString&)";
+    slot_tbl[3].ptr = *((QMember*)&v1_3);
+    slot_tbl_access[3] = QMetaData::Public;
+    slot_tbl[4].name = "setCondition5Line(const QString&)";
+    slot_tbl[4].ptr = *((QMember*)&v1_4);
+    slot_tbl_access[4] = QMetaData::Public;
+    slot_tbl[5].name = "setAction1Line(const QString&)";
+    slot_tbl[5].ptr = *((QMember*)&v1_5);
+    slot_tbl_access[5] = QMetaData::Public;
+    slot_tbl[6].name = "setAction2Line(const QString&)";
+    slot_tbl[6].ptr = *((QMember*)&v1_6);
+    slot_tbl_access[6] = QMetaData::Public;
+    slot_tbl[7].name = "setAction3Line(const QString&)";
+    slot_tbl[7].ptr = *((QMember*)&v1_7);
+    slot_tbl_access[7] = QMetaData::Public;
+    slot_tbl[8].name = "setAction4Line(const QString&)";
+    slot_tbl[8].ptr = *((QMember*)&v1_8);
+    slot_tbl_access[8] = QMetaData::Public;
+    slot_tbl[9].name = "setAction5Line(const QString&)";
+    slot_tbl[9].ptr = *((QMember*)&v1_9);
+    slot_tbl_access[9] = QMetaData::Public;
+    slot_tbl[10].name = "setAppearCondition(const QString&)";
+    slot_tbl[10].ptr = *((QMember*)&v1_10);
+    slot_tbl_access[10] = QMetaData::Public;
+    metaObj = QMetaObject::new_metaobject(
+	"PlayerAnswer", "QObject",
+	slot_tbl, 11,
+	0, 0,
+#ifndef QT_NO_PROPERTIES
+	0, 0,
+	0, 0,
+#endif // QT_NO_PROPERTIES
+	0, 0 );
+    metaObj->set_slot_access( slot_tbl_access );
+#ifndef QT_NO_PROPERTIES
+#endif // QT_NO_PROPERTIES
+    return metaObj;
+}
+
+
+const char *NodeItem::className() const
+{
+    return "NodeItem";
+}
+
+QMetaObject *NodeItem::metaObj = 0;
+
+void NodeItem::initMetaObject()
+{
+    if ( metaObj )
+	return;
+    if ( strcmp(QObject::className(), "QObject") != 0 )
+	badSuperclassWarning("NodeItem","QObject");
+    (void) staticMetaObject();
+}
+
+#ifndef QT_NO_TRANSLATION
+QString NodeItem::tr(const char* s)
+{
+    return ((QNonBaseApplication*)qApp)->translate("NodeItem",s);
+}
+
+#endif // QT_NO_TRANSLATION
+QMetaObject* NodeItem::staticMetaObject()
+{
+    if ( metaObj )
+	return metaObj;
+    (void) QObject::staticMetaObject();
+#ifndef QT_NO_PROPERTIES
+#endif // QT_NO_PROPERTIES
+    typedef void(NodeItem::*m1_t0)(const QString&);
+    typedef void(NodeItem::*m1_t1)(const QString&);
+    typedef void(NodeItem::*m1_t2)(const QString&);
+    typedef void(NodeItem::*m1_t3)(const QString&);
+    typedef void(NodeItem::*m1_t4)(const QString&);
+    typedef void(NodeItem::*m1_t5)(const QString&);
+    typedef void(NodeItem::*m1_t6)(const QString&);
+    m1_t0 v1_0 = Q_AMPERSAND NodeItem::setID;
+    m1_t1 v1_1 = Q_AMPERSAND NodeItem::setName;
+    m1_t2 v1_2 = Q_AMPERSAND NodeItem::setMusic;
+    m1_t3 v1_3 = Q_AMPERSAND NodeItem::setPicture;
+    m1_t4 v1_4 = Q_AMPERSAND NodeItem::setAlienText;
+    m1_t5 v1_5 = Q_AMPERSAND NodeItem::setTextLocation;
+    m1_t6 v1_6 = Q_AMPERSAND NodeItem::setFont;
+    QMetaData *slot_tbl = QMetaObject::new_metadata(7);
+    QMetaData::Access *slot_tbl_access = QMetaObject::new_metaaccess(7);
+    slot_tbl[0].name = "setID(const QString&)";
+    slot_tbl[0].ptr = *((QMember*)&v1_0);
+    slot_tbl_access[0] = QMetaData::Public;
+    slot_tbl[1].name = "setName(const QString&)";
+    slot_tbl[1].ptr = *((QMember*)&v1_1);
+    slot_tbl_access[1] = QMetaData::Public;
+    slot_tbl[2].name = "setMusic(const QString&)";
+    slot_tbl[2].ptr = *((QMember*)&v1_2);
+    slot_tbl_access[2] = QMetaData::Public;
+    slot_tbl[3].name = "setPicture(const QString&)";
+    slot_tbl[3].ptr = *((QMember*)&v1_3);
+    slot_tbl_access[3] = QMetaData::Public;
+    slot_tbl[4].name = "setAlienText(const QString&)";
+    slot_tbl[4].ptr = *((QMember*)&v1_4);
+    slot_tbl_access[4] = QMetaData::Public;
+    slot_tbl[5].name = "setTextLocation(const QString&)";
+    slot_tbl[5].ptr = *((QMember*)&v1_5);
+    slot_tbl_access[5] = QMetaData::Public;
+    slot_tbl[6].name = "setFont(const QString&)";
+    slot_tbl[6].ptr = *((QMember*)&v1_6);
+    slot_tbl_access[6] = QMetaData::Public;
+    metaObj = QMetaObject::new_metaobject(
+	"NodeItem", "QObject",
+	slot_tbl, 7,
+	0, 0,
+#ifndef QT_NO_PROPERTIES
+	0, 0,
+	0, 0,
+#endif // QT_NO_PROPERTIES
+	0, 0 );
+    metaObj->set_slot_access( slot_tbl_access );
+#ifndef QT_NO_PROPERTIES
+#endif // QT_NO_PROPERTIES
+    return metaObj;
+}

Added: trunk/Util/deditor/node.cpp
===================================================================
--- trunk/Util/deditor/node.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/node.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,111 @@
+
+#include "node.h"
+
+PlayerAnswer::PlayerAnswer()
+{
+	m_strAppearCondition = "";
+	m_strText = "";
+
+	m_strCond[0] = "";
+	m_strCond[1] = "";
+	m_strCond[2] = "";
+	m_strCond[3] = "";
+	m_strCond[4] = "";
+
+	m_strAct[0] = "";
+	m_strAct[1] = "";
+	m_strAct[2] = "";
+	m_strAct[3] = "";
+	m_strAct[4] = "";
+}
+
+void PlayerAnswer::setCondition1Line(const QString& text)
+{
+	m_strCond[0] = text;
+}
+void PlayerAnswer::setCondition2Line(const QString& text)
+{
+	m_strCond[1] = text;
+}
+void PlayerAnswer::setCondition3Line(const QString& text)
+{
+	m_strCond[2] = text;
+}
+void PlayerAnswer::setCondition4Line(const QString& text)
+{
+	m_strCond[3] = text;
+}
+void PlayerAnswer::setCondition5Line(const QString& text)
+{
+	m_strCond[4] = text;
+}
+
+
+void PlayerAnswer::setAction1Line(const QString& text)
+{
+	m_strAct[0] = text;
+}
+void PlayerAnswer::setAction2Line(const QString& text)
+{
+	m_strAct[1] = text;
+}
+void PlayerAnswer::setAction3Line(const QString& text)
+{
+	m_strAct[2] = text;
+}
+void PlayerAnswer::setAction4Line(const QString& text)
+{
+	m_strAct[3] = text;
+}
+
+void PlayerAnswer::setAction5Line(const QString& text)
+{
+	m_strAct[4] = text;
+}
+
+void PlayerAnswer::setAppearCondition(const QString& text)
+{
+	m_strAppearCondition = text;
+}
+
+
+NodeItem::NodeItem ( QListView * parent ):
+	QListViewItem(parent) 
+{
+		m_strMusic = "";
+		m_strPicture = "";
+		m_strAlienText ="";
+		m_strTextLocation = "";
+		m_strFont = "";
+}; 
+
+void NodeItem::setID       ( const QString & text)
+{
+	setText(0,text);
+}
+void NodeItem::setName     ( const QString & text)
+{
+	setText(1,text);
+}
+void NodeItem::setMusic    ( const QString & text)
+{
+	m_strMusic = text;
+}
+void NodeItem::setPicture  ( const QString & text)
+{
+	m_strPicture = text;
+}
+void NodeItem::setAlienText( const QString & text)
+{
+	m_strAlienText = text;
+}
+void NodeItem::setTextLocation(const QString& text)
+{
+	m_strTextLocation = text;
+}
+
+void NodeItem::setFont(const QString& text)
+{
+	m_strFont = text;
+}
+

Added: trunk/Util/deditor/node.h
===================================================================
--- trunk/Util/deditor/node.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/node.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,62 @@
+#ifndef TW_DIALOG_EDITOR_NODE
+#define TW_DIALOG_EDITOR_NODE
+
+#include <qlistview.h>
+#include <qstring.h>
+#include <qlistbox.h>
+#include <qsortedlist.h>
+
+class PlayerAnswer : public QObject
+{
+	Q_OBJECT
+public:
+	PlayerAnswer();
+	
+	QString m_strText;
+	QString m_strAppearCondition;
+
+	QString m_strCond[5];
+	QString m_strAct[5];
+
+public slots:
+	virtual void setCondition1Line(const QString&);
+	virtual void setCondition2Line(const QString&);
+	virtual void setCondition3Line(const QString&);
+	virtual void setCondition4Line(const QString&);
+	virtual void setCondition5Line(const QString&);
+	virtual void setAction1Line(const QString&);
+	virtual void setAction2Line(const QString&);
+	virtual void setAction3Line(const QString&);
+	virtual void setAction4Line(const QString&);
+	virtual void setAction5Line(const QString&);
+	virtual void setAppearCondition(const QString&);
+};
+
+
+class NodeItem : public QObject, public QListViewItem
+{ 
+  Q_OBJECT
+	// column 0 - String id, 1 - string name
+public:
+
+	NodeItem ( QListView * parent ); 
+
+	QString m_strMusic;
+	QString m_strPicture;
+	QString m_strAlienText;
+	QString m_strTextLocation;
+	QString m_strFont;
+
+	QList<PlayerAnswer> m_answers;
+public slots:
+	virtual void setID       ( const QString & text);
+	virtual void setName     ( const QString & text);
+	virtual void setMusic    ( const QString & text);
+	virtual void setPicture  ( const QString & text);
+	virtual void setAlienText( const QString & text);
+	virtual void setTextLocation(const QString& text);
+	virtual void setFont(const QString& text);
+};
+
+
+#endif

Added: trunk/Util/deditor/removenode.xpm
===================================================================
--- trunk/Util/deditor/removenode.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/removenode.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *removenode_xpm[] = {
+"    16    13        5            1",
+". c #040404",
+"# c #808304",
+"a c None",
+"b c #ffff00",
+"c c #00ffff",
+"c..............c",
+".c............c.",
+"..c...a....a.c..",
+"..bc..a....ac...",
+".b..c.aa...c....",
+".b...ca.a.ca....",
+".b....c.ac.a....",
+".b..b.acca.a....",
+"..bb..acca.a....",
+"......c..caa....",
+".....c....c.....",
+"....c......c....",
+"...c........c..."
+};

Added: trunk/Util/deditor/rmplayeranswer.xpm
===================================================================
--- trunk/Util/deditor/rmplayeranswer.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/rmplayeranswer.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *rmplayeranswer_xpm[] = {
+"    16    13        5            1",
+". c #040404",
+"# c #808304",
+"a c None",
+"b c #00000",
+"c c #f3f7f3",
+"caaaaaaaaaaaaaac",
+"acaaabbbbbbbaaca",
+"aacaaaaabaaaacaa",
+"aaacaaaabaaacaaa",
+"aaaacaabbbacaaaa",
+"aaaaacabbbcaaaaa",
+"aaaaaacbbcbaaaaa",
+"aaaaaaaccaaaaaaa",
+"aabbbbbccbbbbbaa",
+"aabbbbcbbcbbbbaa",
+"aabbbcbbbbcbbbaa",
+"aabbcbbbbbbcbbaa",
+"aaacaaaaaaaacaaa"
+};

Added: trunk/Util/deditor/setalientext.xpm
===================================================================
--- trunk/Util/deditor/setalientext.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/setalientext.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *setalientext_xpm[] = {
+"    16    13        5            1",
+". c #040404",
+"# c #808304",
+"a c None",
+"b c #00000",
+"c c #f3f7f3",
+"aaaaaaaaaaaaaaaa",
+"aaaaabbbbbbbaaaa",
+"aaaaaaaabaaaaaaa",
+"aaaaaaaabaaaaaaa",
+"aaaaaaabbbaaaaaa",
+"aaaaaaabbbaaaaaa",
+"aaaaaabbbbbaaaaa",
+"aaaaaaaaaaaaaaaa",
+"aaaaa#########aa",
+"aaaa#########aaa",
+"aaa#########aaaa",
+"aa#########aaaaa",
+"aaaaaaaaaaaaaaaa"
+};

Added: trunk/Util/deditor/setplayeranswertext.xpm
===================================================================
--- trunk/Util/deditor/setplayeranswertext.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/setplayeranswertext.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *setplayeranswertext_xpm[] = {
+"    16    13        5            1",
+". c #040404",
+"# c #808304",
+"a c None",
+"b c #00000",
+"c c #f3f7f3",
+"................",
+"................",
+"aacaaa...aaaacaa",
+"aaacaa...aaacaaa",
+"aaaaca...aaaaaaa",
+"aaaaac...aaaaaaa",
+"aaaaaa...aaaaaaa",
+"aaaaaa...aaaaaaa",
+"aaaaaa...aaaaaaa",
+"aaaaaa...aaaaaaa",
+"aaaaac...aaaaaaa",
+"aaaaaa...aaaaaaa",
+"aaaaaa...aaaaaaa"
+};

Added: trunk/Util/deditor/xmlparser.cpp
===================================================================
--- trunk/Util/deditor/xmlparser.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/xmlparser.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,185 @@
+#include "xmlparser.h"
+#include <iostream.h>
+#include <qstring.h>
+#include <qlineedit.h>
+#include <qmessagebox.h> 
+#include <assert.h>
+
+#include "mainwidget.h"
+#include "node.h"
+
+
+XMLParser::XMLParser(DialogEditor* editor)
+{
+	WriteLog("XMLParser::XMLParser\n");
+	m_dialogEditor = editor;
+	curAnswer = NULL;
+	curNode   = NULL;
+}
+
+bool XMLParser::startDocument()
+{
+	WriteLog("XMLParser::startDocument()\n");
+	m_dialogEditor->nodeListView->clear();
+    return TRUE;
+}
+
+bool XMLParser::startElement( const QString&, const QString&, 
+                                    const QString& qName, 
+                                    const QXmlAttributes& attr)
+{
+	WriteLog("XMLParser::startElement\n");
+	if (qName=="NODES")
+	{
+	}
+	else if (qName=="NODE")
+	{
+		QString strId ="", strName = "", strMusic ="", strBack ="";
+		QString strAlienText = "";
+		QString strFont = "", strTextLocation ="";
+
+		for(int i=0; i< attr.length();i++)
+		{
+			if(attr.localName(i)=="id")
+			{
+				strId = attr.value(i);
+			}
+			else
+			if(attr.localName(i)=="name")
+			{
+				strName = attr.value(i);
+			}
+			else
+			if(attr.localName(i)=="music")
+			{
+				strMusic = attr.value(i);
+			}
+			else
+			if(attr.localName(i)=="background")
+			{
+				strBack = attr.value(i);
+			}
+			else
+			if(attr.localName(i)=="alien_text")
+			{
+				strAlienText = attr.value(i);
+			}
+			else
+			if(attr.localName(i)=="font")
+			{
+				strFont = attr.value(i);
+			}
+			else
+			if(attr.localName(i)=="text_location")
+			{
+				strTextLocation = attr.value(i);
+			}
+			else
+			{
+				QMessageBox::warning (m_dialogEditor, "TW-Light editor",
+				QString("Unknown attribute: ") + attr.localName(i));
+			}
+		}
+		curNode = new NodeItem ( m_dialogEditor->nodeListView );
+
+		curNode->setID          ( strId );
+		curNode->setName        ( strName );
+		curNode->setMusic       ( strMusic );
+		curNode->setPicture     ( strBack);
+		curNode->setAlienText   ( strAlienText );
+		curNode->setFont        ( strFont );
+		curNode->setTextLocation( strTextLocation);
+
+	}
+	else if(qName=="PLAYER_ANSWER")
+	{
+		assert(curNode&&"Cant locate Dialog Node in XML!!!");
+		curAnswer = new PlayerAnswer;
+
+		QString strText = "", strAppearCondition = "";
+		for(int i=0; i< attr.length();i++)
+		{
+			if(attr.localName(i)=="text")
+			{
+				
+				strText = attr.value(i);
+			}
+			else if (attr.localName(i)=="appear_condition")
+			{
+				strAppearCondition = attr.value(i);
+			}
+			else
+			{
+				QMessageBox::warning (m_dialogEditor, "TW-Light editor",
+				QString("Unknown attribute: ") + attr.localName(i));
+			}
+		}
+		curAnswer->m_strText = strText;
+		curAnswer->setAppearCondition( strAppearCondition);
+	}
+	else if(qName=="ACTION")
+	{
+		assert(curAnswer);
+		int j;
+		for(j=0; j<5;j++)
+			if(curAnswer->m_strAct[j].isEmpty()&&
+			   curAnswer->m_strCond[j].isEmpty())
+			    break;
+		QString strCondition = "";
+		QString strAction    = "";
+		for(int i=0; i< attr.length();i++)
+		{
+			if(attr.localName(i)=="condition")
+			{
+				
+				strCondition = attr.value(i);
+			}
+			else if (attr.localName(i)=="action")
+			{
+				strAction = attr.value(i);
+			}
+			else
+			{
+				QMessageBox::warning (m_dialogEditor, "TW-Light editor",
+				QString("Unknown attribute: ") + attr.localName(i));
+			}
+		}
+		curAnswer->m_strAct[j] = strAction;
+		curAnswer->m_strCond[j] = strCondition;
+	}
+	else
+	{
+		QMessageBox::warning (m_dialogEditor, "TW-Light editor",
+			QString("Unknown Node: ") + qName);
+	}
+
+    return TRUE;
+}
+
+bool XMLParser::endElement( const QString & namespaceURI, const QString & localName, const QString & qName ) 
+{
+	WriteLog("XMLParser::endElement\n");
+	if(qName=="NODES")
+	{
+	}
+	else if (qName=="NODE")
+	{
+		m_dialogEditor->nodeListView->setCurrentItem(curNode);
+		curNode=NULL;
+	}
+	else if(qName=="PLAYER_ANSWER")
+	{
+		curNode->m_answers.append(curAnswer);
+		curAnswer = NULL;
+	}
+	else if(qName=="ACTION")
+	{
+	}
+	else
+	{
+		QMessageBox::warning (m_dialogEditor, "TW-Light editor",
+			QString("Unknown Node: ") + qName);
+	}
+    return TRUE;
+}
+

Added: trunk/Util/deditor/xmlparser.h
===================================================================
--- trunk/Util/deditor/xmlparser.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/xmlparser.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,30 @@
+#ifndef __TW_XMLPARSER_H__
+#define __TW_XMLPARSER_H__
+
+#include <qxml.h>
+
+class QString;
+class DialogEditor;
+class NodeItem;
+class PlayerAnswer;
+
+class XMLParser : public QXmlDefaultHandler
+{
+private:
+	DialogEditor * m_dialogEditor;
+
+	NodeItem * curNode;
+	PlayerAnswer * curAnswer;
+public:
+	XMLParser(DialogEditor* editor);
+    bool startDocument();
+    bool startElement( const QString&, const QString&, const QString& , 
+                       const QXmlAttributes& attr);
+    bool endElement( const QString&, const QString&, const QString& );
+
+private:
+    QString indent;
+};                   
+
+#endif
+

Added: trunk/web/3dlogo.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/web/3dlogo.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/web/background.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/web/background.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/web/dialog-editor-win32-62.zip
===================================================================
(Binary files differ)


Property changes on: trunk/web/dialog-editor-win32-62.zip
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/web/downloads.html
===================================================================
--- trunk/web/downloads.html	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/web/downloads.html	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,54 @@
+<html>
+
+<head>
+<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
+<meta http-equiv="content-type" content="text/html; charset=windows-1251">
+<meta name="description" content="Homepage of TW-Light.">
+<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
+<title>TW-Light</title>
+</head>
+
+<body>
+
+<div class="navbar">
+  <table class="navlinks" summary="navigation bar">
+    <tr>
+      <td>
+        <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
+      </td>
+      <td>
+      <a href="./index.html">News</a> | <a href="./info.html">Info</a> | <a href="./team.html">Team</a> | <a  id="curpagelink" href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a href="./links.html">Links</a>
+      </td>
+    </tr>
+  </table>
+</div>
+
+<div class="main">
+  <h2>Downloads</h2>
+  
+<p class="indented">
+The latest version is <b>0.2r16</b>. You can download it <a href="http://developer.berlios.de/project/showfiles.php?group_id=2082&release_id=3153">here.</a>
+
+<p class="indented">
+To successfully compile the sources and play the game on Linux/Unix you first need 
+<a href="http://www.allegro.cc/files/index.html">Allegro</a>, SDL 1.2.5 (or newer),
+libogg and libvorbis installed, See makefile after unpacking for more instructions.
+	<!--	
+	 and <a href="http://www.lua.org">Lua</a>
+	View <a href="">ChangeLog</a> to see the list of the latest changes.<br>
+	-->
+</p>
+<p class="indented">
+If you want to contribute TW-Light by writting good dialogs, download and use 
+our dialog editor. The latest version is <b>62</b>. You can download Windows binaries 
+<a href="./dialog-editor-win32-62.zip">here</a>.
+</p>
+</div>
+
+<p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
+<table border="0" cellpadding="0" cellspacing="0" width="100%">
+<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
+</td></tr></table>	
+
+</body>
+</html>
\ No newline at end of file

Modified: trunk/web/index.html
===================================================================
--- trunk/web/index.html	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/web/index.html	2004-09-25 16:33:16 UTC (rev 62)
@@ -14,7 +14,7 @@
   <table class="navlinks" summary="navigation bar">
     <tr>
       <td>
-        <img src="./snapshot.png" alt="" width="200" height="120" /> 
+        <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
       </td>
       <td>
       <a id="curpagelink" href="./index.html">News</a> | <a href="./info.html">Info</a> | <a href="./team.html">Team</a> | <a  href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a href="./links.html">Links</a>

Added: trunk/web/info.html
===================================================================
--- trunk/web/info.html	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/web/info.html	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,122 @@
+<html>
+<head>
+<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
+<meta http-equiv="content-type" content="text/html; charset=windows-1251">
+<meta name="description" content="Homepage of TW-Light.">
+<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
+<title>TW-Light</title>
+</head>
+
+<body>
+
+<div class="navbar">
+  <table class="navlinks" summary="navigation bar">
+    <tr>
+      <td>
+        <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
+      </td>
+      <td>
+      <a href="./index.html">News</a> | <a id="curpagelink" href="./info.html">Info</a> | <a href="./team.html">Team</a> | <a  href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a href="./links.html">Links</a>
+      </td>
+    </tr>
+  </table>
+</div>
+
+<div class="main">
+  <h2>Game Info</h2>
+  <h3 class="important">Story Info</h3>
+  
+  <p class="indented">
+  The Ur-quan are defeated - the destruction of the Sa-matra threw them into chaos, 
+  making them easy prey for the New Alliance of Free Stars. Within weeks the NAFS 
+  forces managed to destroy most of the fleets of the two races who terrorized the 
+  galaxy for the past 20,000 years!
+  </p>
+  
+  <p class="indented">
+  Thanks to you, hope is given to the entire galaxy, and especially to the human race. 
+  Now free from their prison under a Slaveshield it's Humanity's time to rebuild.
+  </p>
+  
+  <p class="indented">
+  However, it seems there are more troubles ahead, according to a vision of 
+  the Pkunk Queen.
+  </p>
+  
+  <p class="indented">
+  It is up to you to save the galaxy again. It's a dirty job, but someone got to do it!
+  </p>
+  
+  <p class="indented">
+  And you must do it with nothing more then a mighty alliance of races 
+  and a bunch of powerful friends at your side! Or so you believe...
+  </p>
+  <p class="indented">
+  TWX:Legacies will start right after StarControl II.
+  </p>
+  
+  <p class="indented">
+  The player is back into the shoes of the famous captain from the last game and 
+  will be continuing his adventures.
+  </p>
+  
+  <p class="indented">Game Features:</p>
+
+<blockquote>
+  <p class="indented">1) All the races from SCII.</p>
+  <p class="indented">&nbsp;2) Bigger and expended Starmap.</p>
+  <p class="indented">3) 13 completly new alien races.</p>
+  <p class="indented">4) Development of the Arilou, Orz and Precursor mysteries.</p>
+  <p class="indented">5) New interesting quests, mysteries and quesions.</p>
+  <p class="indented">6) The MarkII.</p>
+
+  <p class="indented">7) The origin of the Mmrnmhrm.</p>
+  <p class="indented">8) Dangerous Space Monsters. </p>
+  <p class="indented">9) Many special missions and boss fights.</p>
+  <p class="indented">10) Modular flagship (like SCII) and Precursor upgrades for normal ships.</p>
+  <p class="indented">11) Bonus quests and hidden surprises.</p>
+  <p class="indented">12) New characters that help the player during the game. </p>
+
+  <p class="indented">13) Your chance to develop your relations with the beautiful Talana to the next level! </p>
+  <p class="indented">14) And so much more...</p>
+</blockquote>
+  
+  <h3>development</h3>
+  
+<p class="indented">
+TW-Light is developed by a group of Star Control fans. Though the game is quite playable 
+now, it is far from being complete. The development of this game is still going 
+on. Please note, that this is a <b>real project</b>, not just a collection of 
+plans, ideas and dreams like in some other places in the net.
+</p>
+<p class="indented">
+Things may seem to change slow, but there is real progress and every new version 
+is (we hope ;-) better than previous one. Anyway it is better to have a working 
+game than lots of ideas, but no code at all. All the work is done in our spare 
+time, so don't expect that your nice suggestion will be implemented in a short 
+time. If you are badly missing some feature and think that you can make it 
+youself, your patch will be welcome (if it does not break all the rest ;-)
+</p>
+<p class="indented">
+You can support the project by participating discussion in 
+<a href="http://timewarp.sourceforge.net/forum/index.php">TimeWarp forum</a>, 
+where you can post suggestions for future development or just any questions about TW-Light.
+</p>
+<p class="indented">
+You can support the project by posting bugreports and patches in 
+<a href="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">TW-Light Bugzilla</a>
+</p>
+
+<p class="indented">
+<a href="http://svn.berlios.de/viewcvs/tw-light/">TW-Light SVN repository</a> 
+</p>
+
+</div>
+
+<p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
+<table border="0" cellpadding="0" cellspacing="0" width="100%">
+<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
+</td></tr></table>
+	
+</body>
+</html>
\ No newline at end of file

Added: trunk/web/links.html
===================================================================
--- trunk/web/links.html	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/web/links.html	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,49 @@
+<html>
+
+<head>
+<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
+<meta http-equiv="content-type" content="text/html; charset=windows-1251">
+<meta name="description" content="Homepage of TW-Light.">
+<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
+<title>TW-Light</title>
+</head>
+
+<body>
+
+<div class="navbar">
+  <table class="navlinks" summary="navigation bar">
+    <tr>
+      <td>
+        <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
+      </td>
+      <td>
+      <a href="./index.html">News</a> | <a href="./info.html">Info</a> | <a href="./team.html">Team</a> | <a href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a id="curpagelink" href="./links.html">Links</a>
+      </td>
+    </tr>
+  </table>
+</div>
+
+<div class="main">
+  <h3>TW-Light resources</h3>
+  <ul>
+    <li><a href="http://developer.berlios.de/projects/tw-light/">BerliOS: TW-Light Project Info</a></li>
+    <li><a href="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">TW-Light Bugzilla</a> </li>
+    <li><a href="http://timewarp.sourceforge.net/forum/index.php">TimeWarp Forum (official)</a> </li>
+</ul>
+
+<h3>Other Star Control inspired game projects in development</h3>
+<ul>
+    <li><a href="http://timewarp.sourceforge.net">TimeWarp</a> </li>
+    <li><a href="http://sc2.sourceforge.net">The Ur-quan Masters</a> </li>
+    <li><a href="http://twx.sourceforge.net">TWX</a> </li>
+</ul>
+
+</div>
+
+<p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
+<table border="0" cellpadding="0" cellspacing="0" width="100%">
+<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
+</td></tr></table>
+
+</body>
+</html>
\ No newline at end of file

Deleted: trunk/web/logo.png
===================================================================
(Binary files differ)

Added: trunk/web/team.html
===================================================================
--- trunk/web/team.html	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/web/team.html	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,61 @@
+<html>
+<head>
+<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
+<meta http-equiv="content-type" content="text/html; charset=windows-1251">
+<meta name="description" content="Homepage of TW-Light.">
+<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
+<title>TW-Light</title>
+</head>
+
+<body>
+
+<div class="navbar">
+  <table class="navlinks" summary="navigation bar">
+    <tr>
+      <td>
+        <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
+      </td>
+      <td>
+      <a href="./index.html">News</a> | <a href="./info.html">Info</a> | <a id="curpagelink" href="./team.html">Team</a> | <a  href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a href="./links.html">Links</a>
+      </td>
+    </tr>
+  </table>
+</div>
+
+<div class="main">
+  <h2>Team</h2>
+  <h4><span id="core">Programmers:</span></h4>
+  <ul>
+    <li>Yura Semashko <a href="mailto:yurand at land.ru">(Yurand)</a></li>
+    <li>Paul Forest <a href="mailto:youbastrd at users.sourceforge.net">(youBastrd)</a></li>
+  </ul>
+
+  <h4>Content and Plot manager:</h4>
+
+  <ul>
+    <li>Asaf Hamtzany <a href="">(UAF)</a></li>
+  </ul>
+  
+  <h4>Dialog Writers</h4>
+  
+  <ul>
+    <li>Pelorki</li>
+  </ul>
+  
+  <h4>Special Thanks:</h4>
+  <ul>
+    <li>Tau</li>
+    <li>Officer Flubbo</li>
+    <li>Captain Maim</li>
+    <li>Jumping Peppers</li>
+  </ul>
+
+</div>
+
+<p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
+<table border="0" cellpadding="0" cellspacing="0" width="100%">
+<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
+</td></tr></table>
+	
+</body>
+</html>
\ No newline at end of file

Modified: trunk/web/update.sh
===================================================================
--- trunk/web/update.sh	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/web/update.sh	2004-09-25 16:33:16 UTC (rev 62)
@@ -1,2 +1,2 @@
 #!/bin/bash
-pscp index.html yurand at shell.berlios.de:/home/groups/tw-light/htdocs
\ No newline at end of file
+pscp 3dlogo.jpg background.jpg dialog-editor-win32-62.zip downloads.html index.html info.html links.html team.html style.css yurand at shell.berlios.de:/home/groups/tw-light/htdocs
\ No newline at end of file



From yurand at sheep.berlios.de  Sat Sep 25 21:22:41 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 25 Sep 2004 21:22:41 +0200
Subject: [Tw-light-svn] r63 - in trunk/source: . melee other sc1ships sc2ships ships util
Message-ID: <200409251922.i8PJMf3j004175@sheep.berlios.de>

Author: yurand
Date: 2004-09-25 21:22:38 +0200 (Sat, 25 Sep 2004)
New Revision: 63

Modified:
   trunk/source/gui.cpp
   trunk/source/melee.h
   trunk/source/melee/mcbodies.cpp
   trunk/source/melee/mframe.cpp
   trunk/source/melee/mgame.cpp
   trunk/source/melee/mhelpers.cpp
   trunk/source/melee/moptions.cpp
   trunk/source/melee/mship.cpp
   trunk/source/melee/mshot.cpp
   trunk/source/melee/msprite.cpp
   trunk/source/melee/mview.cpp
   trunk/source/other/vbodies.cpp
   trunk/source/sc1ships/shpandgu.cpp
   trunk/source/sc1ships/shpchebr.cpp
   trunk/source/sc1ships/shpearcr.cpp
   trunk/source/sc1ships/shpilwav.cpp
   trunk/source/sc1ships/shpkzedr.cpp
   trunk/source/sc1ships/shpshosc.cpp
   trunk/source/sc1ships/shpsyrpe.cpp
   trunk/source/sc1ships/shpvuxin.cpp
   trunk/source/sc2ships/shpchmav.cpp
   trunk/source/sc2ships/shpdruma.cpp
   trunk/source/sc2ships/shpmeltr.cpp
   trunk/source/sc2ships/shporzne.cpp
   trunk/source/sc2ships/shppkufu.cpp
   trunk/source/sc2ships/shpslypr.cpp
   trunk/source/sc2ships/shputwju.cpp
   trunk/source/scp.cpp
   trunk/source/ships/shpaktgu.cpp
   trunk/source/ships/shpalabc.cpp
   trunk/source/ships/shpbipka.cpp
   trunk/source/ships/shpbogce.cpp
   trunk/source/ships/shpchoex.cpp
   trunk/source/ships/shpconca.cpp
   trunk/source/ships/shpearc3.cpp
   trunk/source/ships/shpforsh.cpp
   trunk/source/ships/shpgarty.cpp
   trunk/source/ships/shpilwsp.cpp
   trunk/source/ships/shprogsq.cpp
   trunk/source/ships/shpstaba.cpp
   trunk/source/ships/shptauar.cpp
   trunk/source/ships/shptausl.cpp
   trunk/source/ships/shptaust.cpp
   trunk/source/ships/shptauto.cpp
   trunk/source/ships/shpyusra.cpp
   trunk/source/ships/shpzeksh.cpp
   trunk/source/util/errors.cpp
   trunk/source/util/sound.cpp
   trunk/source/util/sound.h
Log:
Fixed some bug in AlaryBC
Fixed bug that sometimes lead to crash at exit


Modified: trunk/source/gui.cpp
===================================================================
--- trunk/source/gui.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/gui.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -65,27 +65,27 @@
 {
   int f, g, h;
   if (0) ;
-  else if (videosystem.width <= 250) g = 0;
-  else if (videosystem.width <= 320) g = 1;
-  else if (videosystem.width <= 400) g = 2;
-  else if (videosystem.width <= 640) g = 3;
-  else if (videosystem.width <= 800) g = 4;
-  else if (videosystem.width <= 1024) g = 5;
-  else if (videosystem.width <= 1280) g = 6;
-  else if (videosystem.width <= 1600) g = 7;
+  else if (videosystem->width <= 250) g = 0;
+  else if (videosystem->width <= 320) g = 1;
+  else if (videosystem->width <= 400) g = 2;
+  else if (videosystem->width <= 640) g = 3;
+  else if (videosystem->width <= 800) g = 4;
+  else if (videosystem->width <= 1024) g = 5;
+  else if (videosystem->width <= 1280) g = 6;
+  else if (videosystem->width <= 1600) g = 7;
   else g = 8;
   if (0) ;
-  else if (videosystem.height <= 180) h = 0;
-  else if (videosystem.height <= 240) h = 1;
-  else if (videosystem.height <= 300) h = 2;
-  else if (videosystem.height <= 480) h = 3;
-  else if (videosystem.height <= 600) h = 4;
-  else if (videosystem.height <= 768) h = 5;
-  else if (videosystem.height <= 1024) h = 6;
-  else if (videosystem.height <= 1280) h = 7;
+  else if (videosystem->height <= 180) h = 0;
+  else if (videosystem->height <= 240) h = 1;
+  else if (videosystem->height <= 300) h = 2;
+  else if (videosystem->height <= 480) h = 3;
+  else if (videosystem->height <= 600) h = 4;
+  else if (videosystem->height <= 768) h = 5;
+  else if (videosystem->height <= 1024) h = 6;
+  else if (videosystem->height <= 1280) h = 7;
   else h = 8;
   f = (c + g + h + 1) / 2;
-  return videosystem.get_font(f);
+  return videosystem->get_font(f);
 }
 
 void TW_Dialog_Player::redraw() 
@@ -117,7 +117,8 @@
   window = w;
   ifocus = focus;
   player = NULL;
-  if (!window) window = &videosystem.window;
+  if (!window) 
+    window = &videosystem->window;
   window->add_callback(this);
   int i;
   for (i = 0; d[i].proc; i += 1) ;
@@ -193,7 +194,7 @@
 int TW_Dialog_Player::update() 
 {
   STACKTRACE;
-  videosystem.poll_redraw();
+  videosystem->poll_redraw();
   BITMAP *old = screen;
   screen = subscreen;
   if (!player) player = init_dialog(dialog, ifocus);
@@ -214,7 +215,8 @@
 {
   int return_value;
   TW_Dialog_Player bob;
-  if (!window) window = &videosystem.window;
+  if (!window) 
+    window = &videosystem->window;
   bob.init(window, d, index);
   
   while (keypressed()) readkey();
@@ -230,7 +232,8 @@
 {
   BITMAP *tmp;
   int n, i, return_value;
-  if (!window) window = &videosystem.window;
+  if (!window) 
+    window = &videosystem->window;
   for (n = 0; d[n].proc; n += 1) ;
   if (!window->surface) 
     tw_error ("tw_dialog_pre - no drawing surface");
@@ -727,17 +730,17 @@
     case MSG_END:
       if (d->flags & D_DISABLED) 
 	{
-	  tw_sound.play_sound(menuDisabled, 0.5);
+	  tw_sound->play_sound(menuDisabled, 0.5);
         }
       else 
 	{
-	  tw_sound.play_sound(menuAccept, 0.25);
+	  tw_sound->play_sound(menuAccept, 0.25);
         }
       break;
 
     case MSG_GOTFOCUS:
       {
-	tw_sound.play_sound(menuFocus, 0.5);
+	tw_sound->play_sound(menuFocus, 0.5);
 	break;
       }
     };

Modified: trunk/source/melee/mcbodies.cpp
===================================================================
--- trunk/source/melee/mcbodies.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/melee/mcbodies.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -131,16 +131,16 @@
       switch(i)
 	{
 	case 0:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
 	  break;
 	case 1:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
 	  break;
 	case 2:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
 	  break;
 	case 3:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
 	  break;
 	default:
 	  {

Modified: trunk/source/melee/mframe.cpp
===================================================================
--- trunk/source/melee/mframe.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/melee/mframe.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -843,16 +843,16 @@
       switch(i)
 	{
 	  case 0:
-	    tw_sound.play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+	    tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
 	    break;
 	  case 1:
-	    tw_sound.play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+	    tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
 	    break;
 	  case 2:
-	    tw_sound.play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+	    tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
 	    break;
 	  case 3:
-	    tw_sound.play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+	    tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
 	    break;
 	default:
 	  {
@@ -923,16 +923,16 @@
   switch(i)
     {
     case 0:
-      tw_sound.play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+      tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
       break;
     case 1:
-      tw_sound.play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+      tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
       break;
     case 2:
-      tw_sound.play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+      tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
       break;
     case 3:
-      tw_sound.play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+      tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
       break;
     }
 

Modified: trunk/source/melee/mgame.cpp
===================================================================
--- trunk/source/melee/mgame.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/melee/mgame.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -666,12 +666,12 @@
       play_music();
       while(!game_done) 
 	{
-	  if(!tw_sound.playing_music())
+	  if(!tw_sound->playing_music())
 	    play_music();
 	  
 	  unsigned int time = get_time();
 	  poll_input();
-	  videosystem.poll_redraw();
+	  videosystem->poll_redraw();
 	  if ((next_tic_time <= time) && (next_render_time > game_time) && game_ready()) 
 	    {
 	      _STACKTRACE("Game::play - Game physics")
@@ -746,8 +746,7 @@
 	tmp = source->data->moduleVictory;
       if (!tmp.empty()) 
 	{
-	  tw_sound.play_music(data_full_path(tmp), 1);
-	  //tw_sound.play_sound(data_full_path(tmp));
+	  tw_sound->play_music(data_full_path(tmp), 1);
 	}
       
     }
@@ -1052,7 +1051,7 @@
 	delete tic_history; tic_history = NULL;
 	delete render_history; render_history = NULL;
 
-	tw_sound.play_music(std::string(""));
+	tw_sound->play_music(std::string(""));
 
 	message.out("deleteing game objects");
 	destroy_all();
@@ -1279,7 +1278,7 @@
 void Game::play_music() 
 {
   STACKTRACE;
-  tw_sound.play_music(data_full_path("music/Robeter-battle-music-remix.ogg"));
+  tw_sound->play_music(data_full_path("music/Robeter-battle-music-remix.ogg"));
   return;
 }
 

Modified: trunk/source/melee/mhelpers.cpp
===================================================================
--- trunk/source/melee/mhelpers.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/melee/mhelpers.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -76,7 +76,7 @@
 int  GFX_TIMEWARP_WINDOW =  GFX_AUTODETECT_WINDOWED;
 int GFX_TIMEWARP_FULLSCREEN = GFX_AUTODETECT_FULLSCREEN;
 
-VideoSystem videosystem;
+VideoSystem* videosystem = NULL;
 
 static void tw_display_switch_out() 
 {
@@ -84,12 +84,12 @@
 
 static void tw_display_switch_in() 
 {
-  if (get_time() > videosystem.last_poll + 1000) 
+  if (get_time() > videosystem->last_poll + 1000) 
     {
-      videosystem.redraw();
+      videosystem->redraw();
     }
   else 
-    videosystem.screen_corrupted = true;
+    videosystem->screen_corrupted = true;
 }
 
 static int _gamma = -1;
@@ -148,7 +148,7 @@
 
 int tw_color (RGB c) 
 {
-  videosystem.color_effects(&c);
+  videosystem->color_effects(&c);
   return makecol(c.r, c.g, c.b);
 }
 
@@ -165,7 +165,7 @@
   if (screen_corrupted) 
     {
       screen_corrupted = false;
-      videosystem.redraw();
+      videosystem->redraw();
       return 1;
     }
   return 0;
@@ -467,13 +467,13 @@
   int nx = 0, ny = 0, nw = 0, nh = 0;
   if (parent == this) 
     {
-      surface = videosystem.surface;
+      surface = videosystem->surface;
       if (surface) 
 	{
 	  nx = 0;
 	  ny = 0;
-	  nw = videosystem.width;
-	  nh = videosystem.height;
+	  nw = videosystem->width;
+	  nh = videosystem->height;
 	}
     }
   else 
@@ -673,7 +673,7 @@
   help_dialog[2].dp = (void *) text.c_str();
   help_dialog[2].d1 = 0;
   help_dialog[2].d2 = 0;
-  tw_popup_dialog(&videosystem.window, help_dialog, 1);
+  tw_popup_dialog(&videosystem->window, help_dialog, 1);
   return;
 }
 

Modified: trunk/source/melee/moptions.cpp
===================================================================
--- trunk/source/melee/moptions.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/melee/moptions.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -163,13 +163,13 @@
   
   while ( (choice != DIALOG_VIDEO_EXIT) && (!done) ) 
     {
-      sprintf(dialog_string[3], "%dx%d", videosystem.width, videosystem.height);
+      sprintf(dialog_string[3], "%dx%d", videosystem->width, videosystem->height);
       
       
       //set index for resolution
       int x=-1, y=-1, x2, y2, i, bpp, bpp2, fs;
-      x2 = videosystem.width;
-      y2 = videosystem.height;
+      x2 = videosystem->width;
+      y2 = videosystem->height;
       for (i = 0; resolution[i+1]; i += 1) 
 	{
 	  x = strtol(resolution[i], NULL, 10);
@@ -184,7 +184,7 @@
       
       video_dialog[DIALOG_VIDEO_RESLIST].d1 = i;
       //set index for bpp
-      bpp = videosystem.bpp;
+      bpp = videosystem->bpp;
       for (i = 0; true; i += 1) 
 	{
 	  if (!color_depth[i]) 
@@ -197,7 +197,7 @@
       video_dialog[DIALOG_VIDEO_BPPLIST].d1 = i;
         
       //set button for fullscreen
-      video_dialog[DIALOG_VIDEO_FULLSCREEN].flags = videosystem.fullscreen ? D_SELECTED : 0;
+      video_dialog[DIALOG_VIDEO_FULLSCREEN].flags = videosystem->fullscreen ? D_SELECTED : 0;
 
       int startfs = video_dialog[DIALOG_VIDEO_FULLSCREEN].flags;
       
@@ -235,7 +235,7 @@
 	  fs     = get_config_int("Video", "FullScreen", false);
 	  set_gamma(get_config_int("Video", "Gamma", 128));
 	  
-	  videosystem.set_resolution(x2, y2, bpp2, fs);
+	  videosystem->set_resolution(x2, y2, bpp2, fs);
 	  break;
 	  
 	  
@@ -273,7 +273,7 @@
 	  
 	  //try to set video mode.  If it does not work, back out, and do not confirm
 	  //the changes.
-	  if ( ! videosystem.set_resolution(x2, y2, bpp2, fs))  
+	  if ( ! videosystem->set_resolution(x2, y2, bpp2, fs))  
 	    {
 	      done = false;
 	    }
@@ -299,7 +299,7 @@
 		fs     = get_config_int("Video", "FullScreen", false);
 		set_gamma(get_config_int("Video", "Gamma", 128));
 		
-		i = videosystem.set_resolution(x2, y2, bpp2, fs);
+		i = videosystem->set_resolution(x2, y2, bpp2, fs);
 		done = false;
 	      }
             }
@@ -315,27 +315,27 @@
   int i;
 
   //set dialog values
-  audio_dialog[DIALOG_AUDIO_SOUND_VOL].d2 = iround(100 * tw_sound.load_sound_volume());
-  audio_dialog[DIALOG_AUDIO_MUSIC_VOL].d2 = iround(100 * tw_sound.load_music_volume());
+  audio_dialog[DIALOG_AUDIO_SOUND_VOL].d2 = iround(100 * tw_sound->load_sound_volume());
+  audio_dialog[DIALOG_AUDIO_MUSIC_VOL].d2 = iround(100 * tw_sound->load_music_volume());
 	
   //do the dialog
   i = tw_popup_dialog(NULL, audio_dialog, 0);
   if (i != DIALOG_AUDIO_OK) return;
   
   //set actual values
-  tw_sound.set_sound_volume( audio_dialog[DIALOG_AUDIO_SOUND_VOL].d2/100.0);
-  tw_sound.set_music_volume( audio_dialog[DIALOG_AUDIO_MUSIC_VOL].d2/100.0);
+  tw_sound->set_sound_volume( audio_dialog[DIALOG_AUDIO_SOUND_VOL].d2/100.0);
+  tw_sound->set_music_volume( audio_dialog[DIALOG_AUDIO_MUSIC_VOL].d2/100.0);
 };
 
 int handleSoundSliderChange(void *dp3, int d2) 
 {
-  tw_sound.set_sound_volume( audio_dialog[DIALOG_AUDIO_SOUND_VOL].d2/100.0);
+  tw_sound->set_sound_volume( audio_dialog[DIALOG_AUDIO_SOUND_VOL].d2/100.0);
   return 0;
 }
 
 int handleMusicSliderChange(void *dp3, int d2) 
 {
-  tw_sound.set_music_volume( audio_dialog[DIALOG_AUDIO_MUSIC_VOL].d2/100.0);
+  tw_sound->set_music_volume( audio_dialog[DIALOG_AUDIO_MUSIC_VOL].d2/100.0);
   return 0;
 }
 

Modified: trunk/source/melee/mship.cpp
===================================================================
--- trunk/source/melee/mship.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/melee/mship.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -376,7 +376,7 @@
       text_mode(-1);
       textprintf_centre(
 			spritePanel->get_bitmap(0), 
-			videosystem.get_font(1), 
+			videosystem->get_font(1), 
 			30, 51, 
 			pallete_color[0], 
 			captain_name
@@ -530,7 +530,7 @@
       if (nextkeys & keyflag::suicide) 
 	{
 	  crew  = 0;
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMSHIP_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMSHIP_WAV.wav"));
 	  
 	  if (meleedata.xpl1Sprite) 
 	    {
@@ -750,7 +750,7 @@
     {
       total += crew;
       crew  = 0;
-      tw_sound.play_sound(data_full_path("sound/boom/BOOMSHIP_WAV.wav"));
+      tw_sound->play_sound(data_full_path("sound/boom/BOOMSHIP_WAV.wav"));
       //modified by Tau - start
       if (meleedata.xpl1Sprite) 
 	{
@@ -829,8 +829,8 @@
 
 		if (weapon_sample >= 0)
 		  {
-		    tw_sound.stop_sound(data_full_path(data->sampleWeapon[weapon_sample]));
-		    tw_sound.play_sound(data_full_path(data->sampleWeapon[weapon_sample]));
+		    tw_sound->stop_sound(data_full_path(data->sampleWeapon[weapon_sample]));
+		    tw_sound->play_sound(data_full_path(data->sampleWeapon[weapon_sample]));
 		  }
 	}
 	return;
@@ -858,8 +858,8 @@
 
     if (special_sample >= 0)
       {
-	tw_sound.stop_sound(data_full_path(data->sampleSpecial[special_sample]));
-	tw_sound.play_sound(data_full_path(data->sampleSpecial[special_sample]));
+	tw_sound->stop_sound(data_full_path(data->sampleSpecial[special_sample]));
+	tw_sound->play_sound(data_full_path(data->sampleSpecial[special_sample]));
       }
   }
 }

Modified: trunk/source/melee/mshot.cpp
===================================================================
--- trunk/source/melee/mshot.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/melee/mshot.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -130,7 +130,7 @@
   STACKTRACE;
   if(!explosionSample.empty()) 
     {
-      tw_sound.play_sound(data_full_path(explosionSample));
+      tw_sound->play_sound(data_full_path(explosionSample));
     }
   else if(damage_factor > 0) 
     {
@@ -142,16 +142,16 @@
       switch(i)
 	{
 	case 0:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
 	  break;
 	case 1:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
 	  break;
 	case 2:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
 	  break;
 	case 3:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
 	  break;
 	default:
 	  {

Modified: trunk/source/melee/msprite.cpp
===================================================================
--- trunk/source/melee/msprite.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/melee/msprite.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -256,7 +256,7 @@
 	      }
 	      break;
 	    }
-	  videosystem.color_effects(&a);
+	  videosystem->color_effects(&a);
 	  c = makeacol_depth(bitmap_color_depth(bmp), a.r, a.g, a.b, a.filler);
 	  if ((c == bmc) && masked) 
 	    {
@@ -394,7 +394,7 @@
   general_attributes = _attributes;
   if (general_attributes &  MATCH_SCREEN_FORMAT) 
     {
-      bpp = videosystem.bpp;
+      bpp = videosystem->bpp;
       if (general_attributes & ALPHA) 
 	{
 	  bpp = 32; //quick hack, because converting to 16bpp isn't quite working properly
@@ -668,7 +668,7 @@
   general_attributes = _attributes;
   if (general_attributes &  MATCH_SCREEN_FORMAT) 
     {
-      bpp = videosystem.bpp;
+      bpp = videosystem->bpp;
       if (general_attributes & ALPHA) 
 	{
 	  bpp = 32; 

Modified: trunk/source/melee/mview.cpp
===================================================================
--- trunk/source/melee/mview.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/melee/mview.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -455,8 +455,8 @@
 		}
 	else {
 		text_mode(0);
-		videosystem.window.lock();
-		bmp = videosystem.window.surface;
+		videosystem->window.lock();
+		bmp = videosystem->window.surface;
 		}
 	clean();
 	if (!frame) rectfill(bmp, 0, 0, ox, oy, 0);
@@ -467,7 +467,8 @@
 		y += text_height(font);
 		}
 	if (frame && !frame->full_redraw) frame->add_box(0, 0, x, y);	
-	if (!frame) videosystem.window.unlock();
+	if (!frame) 
+	  videosystem->window.unlock();
 	ox = x;
 	oy = y;
 	return;

Modified: trunk/source/melee.h
===================================================================
--- trunk/source/melee.h	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/melee.h	2004-09-25 19:22:38 UTC (rev 63)
@@ -356,6 +356,7 @@
   virtual int _get_size() const {return sizeof(*this);}
 };
 
+/// Video System
 class VideoSystem : public BaseClass 
 {
  public:
@@ -378,7 +379,8 @@
   void (*color_effects)(Color *color);
   void update_colors();
   void redraw();
-} extern videosystem;
+};
+extern VideoSystem* videosystem;
 
 int get_gamma();
 void set_gamma(int gamma);

Modified: trunk/source/other/vbodies.cpp
===================================================================
--- trunk/source/other/vbodies.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/other/vbodies.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -686,16 +686,16 @@
       switch(i)
 	{
 	case 0:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
 	  break;
 	case 1:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
 	  break;
 	case 2:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
 	  break;
 	case 3:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
 	  break;
 	default:
 	  {
@@ -714,8 +714,8 @@
 //  game->all_damage_direct = true;
 //  game->is_nebula = true;
   friction = 0.0004;
-	videosystem.color_effects = VNebulaColorEffects;
-	videosystem.update_colors();
+	videosystem->color_effects = VNebulaColorEffects;
+	videosystem->update_colors();
 }
 
 VNebula::VNebula(double ofriction):Presence()
@@ -723,8 +723,8 @@
   STACKTRACE;
 //  game->all_damage_direct = true;
   friction = ofriction;
-	videosystem.color_effects = VNebulaColorEffects;
-	videosystem.update_colors();
+	videosystem->color_effects = VNebulaColorEffects;
+	videosystem->update_colors();
 
 }
 
@@ -734,8 +734,8 @@
 //  game->all_damage_direct = true;
   friction = ofriction; 
   ionStorms = oionStorms;
-	videosystem.color_effects = VNebulaColorEffects;
-	videosystem.update_colors();
+  videosystem->color_effects = VNebulaColorEffects;
+  videosystem->update_colors();
 }
 
 void VNebula::calculate(void) {
@@ -756,18 +756,13 @@
 }
 
 VNebula::~VNebula() {
-//  game->all_damage_direct = false;
-//  game->is_nebula = false;
-  videosystem.color_effects = gamma_color_effects;
-	videosystem.update_colors();
+  videosystem->color_effects = gamma_color_effects;
+  videosystem->update_colors();
 }
 
-VIonStorm::VIonStorm(void):SpaceObject(NULL, Vector2(0,0), 0, NULL) {
+VIonStorm::VIonStorm(void):SpaceObject(NULL, Vector2(0,0), 0, NULL) 
+{
   STACKTRACE;
-//	SpaceObject(SpaceLocation *creator, Vector2 opos, double oangle, 
-//			SpaceSprite *osprite);
-
-  ;
 }
 
 
@@ -1355,16 +1350,16 @@
       switch(i)
 	{
 	case 0:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
 	  break;
 	case 1:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
 	  break;
 	case 2:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
 	  break;
 	case 3:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
 	  break;
 	default:
 	  {
@@ -1461,16 +1456,16 @@
       switch(i)
 	{
 	case 0:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
 	  break;
 	case 1:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
 	  break;
 	case 2:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
 	  break;
 	case 3:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
 	  break;
 	default:
 	  {
@@ -1591,16 +1586,16 @@
       switch(i)
 	{
 	case 0:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
 	  break;
 	case 1:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
 	  break;
 	case 2:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
 	  break;
 	case 3:
-	  tw_sound.play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
 	  break;
 	default:
 	  {
@@ -1687,16 +1682,16 @@
     switch(i)
       {
       case 0:
-	tw_sound.play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+	tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
 	break;
       case 1:
-	tw_sound.play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+	tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
 	break;
       case 2:
-	tw_sound.play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+	tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
 	break;
       case 3:
-	tw_sound.play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+	tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
 	break;
       default:
 	{

Modified: trunk/source/sc1ships/shpandgu.cpp
===================================================================
--- trunk/source/sc1ships/shpandgu.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/sc1ships/shpandgu.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -120,16 +120,16 @@
 	  switch(i)
 	    {
 	    case 0:
-	      tw_sound.play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+	      tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
 	      break;
 	    case 1:
-	      tw_sound.play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+	      tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
 	      break;
 	    case 2:
-	      tw_sound.play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+	      tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
 	      break;
 	    case 3:
-	      tw_sound.play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+	      tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
 	      break;
 	    default:
 	      {

Modified: trunk/source/sc1ships/shpchebr.cpp
===================================================================
--- trunk/source/sc1ships/shpchebr.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/sc1ships/shpchebr.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -123,7 +123,7 @@
 			shot->collide_flag_sameship = bit(LAYER_SPECIAL);
 			game->add(shot);
 		}
-		tw_sound.play_sound(data_full_path(data->sampleExtra[0]));
+		tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
 		weaponObject->destroy();
 		weaponObject = NULL;
 	}
@@ -205,7 +205,7 @@
 void ChenjesuDOGI::inflict_damage(SpaceObject *other)
 {
   STACKTRACE;
-  tw_sound.play_sound(data_full_path(data->sampleExtra[1]));
+  tw_sound->play_sound(data_full_path(data->sampleExtra[1]));
 
   if(sameTeam(other)) 
     return;
@@ -243,8 +243,8 @@
 void ChenjesuDOGI::soundExplosion()
 {
   STACKTRACE;
-  tw_sound.stop_sound(data_full_path(data->sampleExtra[2]));
-  tw_sound.play_sound(data_full_path(data->sampleExtra[2]));
+  tw_sound->stop_sound(data_full_path(data->sampleExtra[2]));
+  tw_sound->play_sound(data_full_path(data->sampleExtra[2]));
   return;
 }
 

Modified: trunk/source/sc1ships/shpearcr.cpp
===================================================================
--- trunk/source/sc1ships/shpearcr.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/sc1ships/shpearcr.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -81,7 +81,7 @@
     }
   if (fire) 
     {
-      tw_sound.play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+      tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
     }
   
   return(fire);

Modified: trunk/source/sc1ships/shpilwav.cpp
===================================================================
--- trunk/source/sc1ships/shpilwav.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/sc1ships/shpilwav.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -81,8 +81,8 @@
     else 
       {
 	cloak = TRUE;
-	tw_sound.stop_sound(data_full_path(data->sampleSpecial[0]));
-	tw_sound.play_sound(data_full_path(data->sampleSpecial[0]));
+	tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+	tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
 	batt -= special_drain;
       }
 

Modified: trunk/source/sc1ships/shpkzedr.cpp
===================================================================
--- trunk/source/sc1ships/shpkzedr.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/sc1ships/shpkzedr.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -162,8 +162,8 @@
     {
       collide_flag_sameship = 0;
       vel = 0;
-      tw_sound.stop_sound(data_full_path(data->sampleExtra[0]));
-      tw_sound.play_sound(data_full_path(data->sampleExtra[0]));
+      tw_sound->stop_sound(data_full_path(data->sampleExtra[0]));
+      tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
       
       add(new Laser(this, trajectory_angle(target),
 		    pallete_color[laser_color], laser_range, laser_damage,
@@ -219,8 +219,8 @@
   STACKTRACE;
   if (other == ship) 
     {
-      tw_sound.stop_sound(data_full_path(data->sampleExtra[1]));
-      tw_sound.play_sound(data_full_path(data->sampleExtra[1]));
+      tw_sound->stop_sound(data_full_path(data->sampleExtra[1]));
+      tw_sound->play_sound(data_full_path(data->sampleExtra[1]));
       damage(ship, 0, -1);
     } 
   if (!other->isPlanet()) state = 0;

Modified: trunk/source/sc1ships/shpshosc.cpp
===================================================================
--- trunk/source/sc1ships/shpshosc.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/sc1ships/shpshosc.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -73,8 +73,8 @@
 	      q.end();
 	      add(new Animation(this, pos, data->spriteSpecial, 
 				0, specialFrames, 50, DEPTH_EXPLOSIONS, specialScale));
-	      tw_sound.stop_sound(data_full_path(data->sampleSpecial[0]));
-	      tw_sound.play_sound(data_full_path(data->sampleSpecial[0]));
+	      tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+	      tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
 	      damage(this, 0, 999);
 	    }
 	  else 

Modified: trunk/source/sc1ships/shpsyrpe.cpp
===================================================================
--- trunk/source/sc1ships/shpsyrpe.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/sc1ships/shpsyrpe.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -157,8 +157,8 @@
   STACKTRACE;
   if (other->isShip() && other->damage_factor == 0) 
     {
-      tw_sound.stop_sound(data_full_path(data->sampleExtra[0]));
-      tw_sound.play_sound(data_full_path(data->sampleExtra[0]));
+      tw_sound->stop_sound(data_full_path(data->sampleExtra[0]));
+      tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
       damage(other, 0, -1);
       state = 0;
   }

Modified: trunk/source/sc1ships/shpvuxin.cpp
===================================================================
--- trunk/source/sc1ships/shpvuxin.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/sc1ships/shpvuxin.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -112,7 +112,7 @@
 
   Ship *target = (Ship *) other;
 
-  tw_sound.play_sound(data_full_path(data->sampleSpecial[1]));
+  tw_sound->play_sound(data_full_path(data->sampleSpecial[1]));
 
   //MYCODE begin
   int hx,hy,tries, col;

Modified: trunk/source/sc2ships/shpchmav.cpp
===================================================================
--- trunk/source/sc2ships/shpchmav.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/sc2ships/shpchmav.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -301,7 +301,7 @@
 		if (!q.currento->isInvisible() && !q.currento->sameTeam(this) && (q.currento->collide_flag_anyone&bit(LAYER_LINES))) {
 			add(new PointLaser(this, pallete_color[lColor], 1, lFrames,
                         		this, q.currento, Vector2(0.0, 0.0) ));
-			tw_sound.play_sound(data_full_path(MELEE_BOOM_SOUND1));
+			tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND1));
 			lRecharge += lRechargeRate;
 			break;
 			}
@@ -325,8 +325,8 @@
 			add(new Animation(this, pos,
 					  meleedata.kaboomSprite, 0, KABOOM_FRAMES, 
 					  50, DEPTH_EXPLOSIONS));
-			tw_sound.stop_sound(data_full_path(data->sampleExtra[0]));
-			tw_sound.play_sound(data_full_path(data->sampleExtra[0]));
+			tw_sound->stop_sound(data_full_path(data->sampleExtra[0]));
+			tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
 			}
 		}
 	return total;

Modified: trunk/source/sc2ships/shpdruma.cpp
===================================================================
--- trunk/source/sc2ships/shpdruma.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/sc2ships/shpdruma.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -69,8 +69,8 @@
 
     special_recharge = special_rate;
 
-    tw_sound.stop_sound(data_full_path(data->sampleSpecial[0]));
-    tw_sound.play_sound(data_full_path(data->sampleSpecial[0]));
+    tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+    tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
   }
 }
 

Modified: trunk/source/sc2ships/shpmeltr.cpp
===================================================================
--- trunk/source/sc2ships/shpmeltr.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/sc2ships/shpmeltr.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -171,7 +171,7 @@
 		  damage_factor *= 2;
 		  armour *= 2;
 		  range += RangeUp;
-		  tw_sound.play_sound(data_full_path(data->sampleWeapon[0]));
+		  tw_sound->play_sound(data_full_path(data->sampleWeapon[0]));
 		}
 	    }
 	}
@@ -183,7 +183,7 @@
 	{
 	  vel = v * unit_vector(angle);
 	  released = TRUE;
-	  tw_sound.play_sound(data_full_path(data->sampleSpecial[0]));
+	  tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
 	}
       else 
 	{

Modified: trunk/source/sc2ships/shporzne.cpp
===================================================================
--- trunk/source/sc2ships/shporzne.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/sc2ships/shporzne.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -279,7 +279,7 @@
 		  damage(orzship, 0, -1);
 		}
 	      
-	      tw_sound.play_sound(data_full_path(data->sampleExtra[0]));
+	      tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
 	      damage(invading, 0, 1);
 	      damage_frame = 50;
 	      if ( invading->spritePanel )
@@ -295,7 +295,7 @@
 	  else if (chance < 10 * frame_time) 
 	    {
 	      state = 0;
-	      tw_sound.play_sound(data_full_path(data->sampleExtra[2]));
+	      tw_sound->play_sound(data_full_path(data->sampleExtra[2]));
 	      if ( invading->spritePanel )
 		{
 		  blit(invading->data->spritePanel->get_bitmap(0), invading->spritePanel->get_bitmap(0),
@@ -389,7 +389,7 @@
       if (invading->damage_factor < armour)
 	{
 	  collide_flag_anyone = 0;
-	  tw_sound.play_sound(data_full_path(data->sampleExtra[1]));
+	  tw_sound->play_sound(data_full_path(data->sampleExtra[1]));
 	  damage(invading, 0, 1);
 	  if (invading->spritePanel)
 	    {

Modified: trunk/source/sc2ships/shppkufu.cpp
===================================================================
--- trunk/source/sc2ships/shppkufu.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/sc2ships/shppkufu.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -49,7 +49,7 @@
   if (crew > 0) 
     return r;
   
-  tw_sound.play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
+  tw_sound->play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
   game->add(new Animation(this, pos,	meleedata.kaboomSprite, 0, KABOOM_FRAMES, 
 			  time_ratio, DEPTH_EXPLOSIONS));
   
@@ -176,12 +176,12 @@
       
       special_recharge = special_rate;
 
-      tw_sound.stop_sound(data_full_path(data->sampleSpecial[special_sample]));
+      tw_sound->stop_sound(data_full_path(data->sampleSpecial[special_sample]));
       
       special_sample = (special_sample + 1 + random(13)) % 14;
 
-      tw_sound.stop_sound(data_full_path(data->sampleSpecial[special_sample]));
-      tw_sound.play_sound(data_full_path(data->sampleSpecial[special_sample]));
+      tw_sound->stop_sound(data_full_path(data->sampleSpecial[special_sample]));
+      tw_sound->play_sound(data_full_path(data->sampleSpecial[special_sample]));
     }
 }
 

Modified: trunk/source/sc2ships/shpslypr.cpp
===================================================================
--- trunk/source/sc2ships/shpslypr.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/sc2ships/shpslypr.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -154,8 +154,8 @@
 	      if (damage(q.current, 1)) 
 		{
 		  batt = batt_max;
-		  tw_sound.stop_sound(data_full_path(data->sampleSpecial[0]));
-		  tw_sound.play_sound(data_full_path(data->sampleSpecial[0]));
+		  tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+		  tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
 		}
 	    }
 	}

Modified: trunk/source/sc2ships/shputwju.cpp
===================================================================
--- trunk/source/sc2ships/shputwju.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/sc2ships/shputwju.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -74,8 +74,8 @@
 
     weapon_recharge = weapon_rate;
 
-    tw_sound.stop_sound(data_full_path(data->sampleWeapon[0]));
-    tw_sound.play_sound(data_full_path(data->sampleWeapon[0]));
+    tw_sound->stop_sound(data_full_path(data->sampleWeapon[0]));
+    tw_sound->play_sound(data_full_path(data->sampleWeapon[0]));
   }
 }
 

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/scp.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -81,7 +81,7 @@
 FILE *debug_file;
 
 /*! \brief Blits GUI background bitmap on to a video window */
-void showTitle(VideoWindow *window = &videosystem.window);
+void showTitle(VideoWindow *window = &videosystem->window);
 
 /*! \brief MELEE_EX dialog - selects alternate games as opposed to standard melee. 
   From here you can access diagnostics (DIAGNOSTICS dialog) and ship info. 
@@ -191,7 +191,7 @@
 {
   STACKTRACE;
   titleMusic = data_full_path("music/Robeter-Space-Gods-Loop.ogg");
-  tw_sound.play_music(titleMusic);
+  tw_sound->play_music(titleMusic);
 
   menuAccept   = data_full_path("sound/menu/MENUACCEPT.wav");
   menuFocus    = data_full_path("sound/menu/MENUFOCUS.wav");
@@ -264,7 +264,7 @@
       new_game->preinit();
       new_game->window = new VideoWindow;
       new_game->window->preinit();
-      new_game->window->init(&videosystem.window);
+      new_game->window->init(&videosystem->window);
       new_game->window->locate(0,0,0,0,0,1,0,1);
       new_game->init(_log);
       new_game->play();
@@ -519,8 +519,11 @@
   if (allegro_init() < 0)
     tw_error_exit("Allegro initialization failed");
   create_user_ini();
-  videosystem.preinit();
   
+  VideoSystem video;
+  videosystem = &video;
+  videosystem->preinit();
+  
   try {
     init_time();
     init_error();
@@ -612,7 +615,7 @@
     srand(time(NULL));
     set_color_conversion(COLORCONV_KEEP_TRANS);
     
-    videosystem.set_resolution(screen_width, screen_height, screen_bpp, fullscreen);
+    videosystem->set_resolution(screen_width, screen_height, screen_bpp, fullscreen);
     register_bitmap_file_type("jpg", load_jpg, NULL);
     if(!theme)
 	theme = agup_theme_by_name("Photon");
@@ -625,9 +628,12 @@
     gui_text_list_proc = d_agup_text_list_proc;
 
     enable_input(inputs);
-    tw_sound.set_sound_volume(tw_sound.load_sound_volume());
-    tw_sound.set_music_volume(tw_sound.load_music_volume());
     
+    SoundSystem sound;
+    tw_sound = &sound;
+    tw_sound->set_sound_volume(tw_sound->load_sound_volume());
+    tw_sound->set_music_volume(tw_sound->load_music_volume());
+    
     showLoadingScreen();
     
     View *v = NULL;
@@ -643,7 +649,7 @@
     }
     else {
       mainmenu.preinit();
-      mainmenu.init(&videosystem.window);
+      mainmenu.init(&videosystem->window);
       mainmenu.doit();
       mainmenu.deinit();
     }
@@ -1392,8 +1398,7 @@
 		free(shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp);
 	}
 	
-	videosystem.redraw();
-	//	clear_bitmap(screen);
+	videosystem->redraw();
 	return;
 }
 
@@ -1472,23 +1477,23 @@
   char blah[256];
   
   scare_mouse();
-  videosystem.window.lock();
-  clear_to_color(videosystem.window.surface, 0);
+  videosystem->window.lock();
+  clear_to_color(videosystem->window.surface, 0);
   textprintf(screen, font, 40, 20, palette_color[15], "Press the keys combinations you wish to test");
   textprintf(screen, font, 40, 40, palette_color[15], "When you're finished, press ESCAPE or F10");
-  videosystem.window.unlock();
+  videosystem->window.unlock();
   unscare_mouse();
   
   while (!key[KEY_F10] && !key[KEY_ESC]) 
     {
-      if (videosystem.poll_redraw()) 
+      if (videosystem->poll_redraw()) 
 	{
 	  scare_mouse();
-	  videosystem.window.lock();
-	  clear_to_color(videosystem.window.surface, 0);
+	  videosystem->window.lock();
+	  clear_to_color(videosystem->window.surface, 0);
 	  textprintf(screen, font, 40, 20, palette_color[15], "Press the keys combinations you wish to test");
 	  textprintf(screen, font, 40, 40, palette_color[15], "When you're finished, press ESCAPE or F10");
-	  videosystem.window.unlock();
+	  videosystem->window.unlock();
 	  unscare_mouse();
 	}
       rectfill(screen, 50, 60, 500, 60 + 20 * j, palette_color[0]);

Modified: trunk/source/ships/shpaktgu.cpp
===================================================================
--- trunk/source/ships/shpaktgu.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/ships/shpaktgu.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -183,9 +183,9 @@
 void AktunLaser::inflict_damage(SpaceObject *other)
 {
   STACKTRACE;
-  tw_sound.stop_sound(data_full_path(owner->data->sampleWeapon[0]));
+  tw_sound->stop_sound(data_full_path(owner->data->sampleWeapon[0]));
   Laser::inflict_damage(other);
-  tw_sound.play_sound(data_full_path(owner->data->sampleWeapon[1]));
+  tw_sound->play_sound(data_full_path(owner->data->sampleWeapon[1]));
 }
 
 AktunComSat::AktunComSat(double oangle, double orange, int odamage,
@@ -249,7 +249,7 @@
 	  game->add(l);
 	  if (l->exists()) 
 	    {
-	      tw_sound.play_sound(data_full_path(ship->data->sampleExtra[0]));
+	      tw_sound->play_sound(data_full_path(ship->data->sampleExtra[0]));
 	      lRecharge += lRechargeRate;
 	      break;
 	    }
@@ -280,8 +280,8 @@
 	state = 0;
 	game->add(new Animation(this, pos,
 				meleedata.kaboomSprite, 0, KABOOM_FRAMES, 50, LAYER_EXPLOSIONS));
-	tw_sound.stop_sound(data_full_path(data->sampleExtra[0]));
-	tw_sound.play_sound(data_full_path(data->sampleExtra[0]));
+	tw_sound->stop_sound(data_full_path(data->sampleExtra[0]));
+	tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
 	}
     }
   return 1;

Modified: trunk/source/ships/shpalabc.cpp
===================================================================
--- trunk/source/ships/shpalabc.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/ships/shpalabc.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -189,6 +189,7 @@
   extraSpeedLossReduction  = get_config_float("Extra", "SpeedLossReduction", 1);
   
   max_shield_flash_time = get_config_float("Extra", "ShieldFlashTime", 1);
+  shield_flash_time = max_shield_flash_time;
   shield_flash_scale = 0;
   
   absorbed_damage = 0;
@@ -246,9 +247,9 @@
 	    SpaceLocation *ani = new Animation(this, pos+rrr*unit_vector(aaa), 
 					       data->spriteExtraExplosion, 0, 10, 50, DEPTH_EXPLOSIONS);
 	    game->add(ani);
-	    tw_sound.play_sound(data_full_path(data->sampleWeapon[2])); 
+	    tw_sound->play_sound(data_full_path(data->sampleWeapon[2])); 
 	  }
-	  tw_sound.play_sound(data_full_path(MELEE_BOOM_SOUND4)); 
+	  tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND4)); 
 	}
     }
   
@@ -517,7 +518,7 @@
       // give some sound for the shield if the shield absorbs its damage.
       if (data->sampleExtra.size() >= 2)
 	{
-	  tw_sound.play_sound(data_full_path(data->sampleExtra[1]));
+	  tw_sound->play_sound(data_full_path(data->sampleExtra[1]));
 	}
       shield_flash_time = max_shield_flash_time;	// 1 second ?
       // 0=shield is almost drained, 1=shield is maxed.
@@ -552,7 +553,7 @@
       engines_armour -= total;
       if (engines_armour <=0) 
 	{
-	  tw_sound.play_sound(data_full_path(data->sampleExtra[0]));
+	  tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
 	  engines_death_frame = 8;
 	  engines_death_count = 500 +random()%100;
 	  speed_max /= 2.0;
@@ -567,7 +568,7 @@
     int i;
     for (i=0; i<3; i++)
       turret[i]->state = 0;
-    tw_sound.play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
+    tw_sound->play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
     game->add(new Animation(this, pos,
 			    meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS, 2.0));
     if (attributes & ATTRIB_NOTIFY_ON_DEATH) game->ship_died(this, source);
@@ -590,7 +591,7 @@
       if (engines_armour > 0) 
 	{
 	  engines_armour = 0;
-	  tw_sound.play_sound(data_full_path(data->sampleExtra[0]));
+	  tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
 	  engines_death_frame = 8;
 	  engines_death_count = 500 +random()%100;
 	}
@@ -729,7 +730,7 @@
     {
       game->add(new Animation(this, pos, data->spriteWeaponExplosion, 0, 10, 50, DEPTH_EXPLOSIONS));
       state = 0; 
-      tw_sound.play_sound(data_full_path(MELEE_BOOM_SOUND1));
+      tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND1));
     }
 };
 
@@ -760,7 +761,7 @@
   explosionFrameSize  = 50;
   explosionSample = data->sampleWeapon[2];
   smoke_frame = 0;
-  tw_sound.play_sound(data_full_path(data->sampleWeapon[1])); // was vol 64
+  tw_sound->play_sound(data_full_path(data->sampleWeapon[1])); // was vol 64
 }
 
 
@@ -813,7 +814,7 @@
   sinc_it();
 
   fire_frame[0] = fire_frame[1] = 10;
-  
+  fire_time[0] = fire_time[1] = 0;
   alive = true;
 }
 
@@ -939,7 +940,7 @@
   if (armour <= 0) 
     {
       alive = false;
-      tw_sound.play_sound(data_full_path(MELEE_BOOM_SOUND2));
+      tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND2));
       game->add(new FixedAnimation(this, this, ship->data->spriteSpecialExplosion,
 				   0, 10, 50, DEPTH_EXPLOSIONS));
       return; 
@@ -1016,7 +1017,7 @@
 	    {
 	      recharge += ship->special_rate;
 	      ship->batt -= ship->special_drain;
-	      tw_sound.play_sound(data_full_path(ship->data->sampleSpecial[0]));
+	      tw_sound->play_sound(data_full_path(ship->data->sampleSpecial[0]));
 	      shots_fired++;
 	      if (barrel == 0) 
 		{
@@ -1025,7 +1026,8 @@
 					     ship->specialDamage, ship->specialRange,
 					     ship->specialArmour, ship, this, 
 					     ship->data->spriteSpecial, ship->specialRelativity));
-		  fire_frame[0] = 0; fire_time[0] =  turret_fire_frame_size;
+		  fire_frame[0] = 0; 
+		  fire_time[0] =  turret_fire_frame_size;
 		  barrel = 1; 
 		}
 	      else 
@@ -1035,7 +1037,8 @@
 					     ship->specialDamage, ship->specialRange,
 					     ship->specialArmour, ship, this, 
 					     ship->data->spriteSpecial, ship->specialRelativity));
-		  fire_frame[1] = 0; fire_time[1] =  turret_fire_frame_size;
+		  fire_frame[1] = 0; 
+		  fire_time[1] =  turret_fire_frame_size;
 		  barrel = 0; 
 		}
 	    }

Modified: trunk/source/ships/shpbipka.cpp
===================================================================
--- trunk/source/ships/shpbipka.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/ships/shpbipka.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -477,7 +477,7 @@
 void BipoleShip::destroyed( SpaceLocation* source )
 {
   STACKTRACE;
-  tw_sound.play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
+  tw_sound->play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
   game->add(new Animation(this, pos,
 			  meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, LAYER_EXPLOSIONS));
 }

Modified: trunk/source/ships/shpbogce.cpp
===================================================================
--- trunk/source/ships/shpbogce.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/ships/shpbogce.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -422,7 +422,7 @@
   blast_accel = oblast_accel;
   blast_maxspeed = oblast_maxspeed;
   hotspot_frame = 0;
-  tw_sound.play_sound(data_full_path(s));//       play_sound(s, 128);
+  tw_sound->play_sound(data_full_path(s));//       play_sound(s, 128);
   explosionSprite = esprite;
   explosionFrameCount = 10;
   explosionFrameSize = 50;
@@ -518,7 +518,7 @@
   other->handle_damage(this, 1);
   if (!s.empty())  
     {
-      tw_sound.play_sound(data_full_path(s)); // was vol 160
+      tw_sound->play_sound(data_full_path(s)); // was vol 160
     }
   state = 0;
 }
@@ -541,7 +541,7 @@
 {
   STACKTRACE;
   pos += edge();
-  tw_sound.play_sound(data_full_path(ex_sample)); // was vol 240
+  tw_sound->play_sound(data_full_path(ex_sample)); // was vol 240
   game->add(new Animation(this, pos, ex_sprite, 0, 10, 50, LAYER_EXPLOSIONS));
   other->handle_damage(this, damage_factor);
   state = 0;

Modified: trunk/source/ships/shpchoex.cpp
===================================================================
--- trunk/source/ships/shpchoex.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/ships/shpchoex.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -571,8 +571,8 @@
 	    }
 	  if(count==0)
 	    {
-	      tw_sound.stop_sound(data_full_path(data->sampleExtra[0]));
-	      tw_sound.play_sound(data_full_path(data->sampleExtra[0]));
+	      tw_sound->stop_sound(data_full_path(data->sampleExtra[0]));
+	      tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
 	     }
 	  count++;
 	  
@@ -581,8 +581,8 @@
       drillFrames-= frame_time;
       if ((drillFrames <= 0) && (!latched)) 
 	{
-	  tw_sound.stop_sound(data_full_path(data->sampleWeapon[0]));
-	  tw_sound.play_sound(data_full_path(data->sampleWeapon[0]));
+	  tw_sound->stop_sound(data_full_path(data->sampleWeapon[0]));
+	  tw_sound->play_sound(data_full_path(data->sampleWeapon[0]));
 	}
      }
    else 
@@ -693,8 +693,8 @@
 		  grabdistance = (distance(other) * 1.1);
 		  grabshipangle = (other->get_angle());
 		  drillDamageLeft = weaponDamage;
-		  tw_sound.stop_sound(data_full_path(data->sampleExtra[1]));
-		  tw_sound.play_sound(data_full_path(data->sampleExtra[1]));
+		  tw_sound->stop_sound(data_full_path(data->sampleExtra[1]));
+		  tw_sound->play_sound(data_full_path(data->sampleExtra[1]));
 		  if ((drillFrames / frame_time)< weaponDamage) 
 		    {
 		      drillDamagePerDamageFrame = (weaponDamage/drillFrames)

Modified: trunk/source/ships/shpconca.cpp
===================================================================
--- trunk/source/ships/shpconca.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/ships/shpconca.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -155,7 +155,7 @@
 	  
 	  do_area_damage( );
 	  
-	  tw_sound.play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
+	  tw_sound->play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
 	  game->add(new Animation(this, pos,	meleedata.kaboomSprite, 0, 
 				  KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS));
 	  

Modified: trunk/source/ships/shpearc3.cpp
===================================================================
--- trunk/source/ships/shpearc3.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/ships/shpearc3.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -184,7 +184,7 @@
       game->add(new EarthlingCruiserMk3Beam(this, Vector2(0,-6), specialRange,
 					    specialDamage, specialDamageShots, 
 					    specialFrames, tgt));
-	    tw_sound.play_sound(data_full_path(data->sampleSpecial[0]));
+	    tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
 	    fire = true; 
     }
   
@@ -203,7 +203,7 @@
 	sprite_index = 32;
 
 	attributes &= ~ATTRIB_STANDARD_INDEX;
-	tw_sound.play_sound(data_full_path(data->sampleWeapon[0]));
+	tw_sound->play_sound(data_full_path(data->sampleWeapon[0]));
 }
 
 
@@ -217,7 +217,7 @@
 void EarthlingCruiserMk3Shot::soundExplosion()
 {
   STACKTRACE;
-  tw_sound.play_sound(data_full_path(explosionSample));
+  tw_sound->play_sound(data_full_path(explosionSample));
   return;
 }
 

Modified: trunk/source/ships/shpforsh.cpp
===================================================================
--- trunk/source/ships/shpforsh.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/ships/shpforsh.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -95,8 +95,8 @@
   SpaceSprite *tmp_s = data->spriteWeapon;
   if (weapon_type==2)	
     tmp_s = data->spriteExtra;
-  tw_sound.stop_sound(data_full_path(data->sampleWeapon[0]));
-  tw_sound.play_sound(data_full_path(data->sampleWeapon[0]));
+  tw_sound->stop_sound(data_full_path(data->sampleWeapon[0]));
+  tw_sound->play_sound(data_full_path(data->sampleWeapon[0]));
 	
   if (weapon_type == 0) 
     {
@@ -124,8 +124,8 @@
   STACKTRACE;
   if(shockingFrames == 0) 
     {
-      tw_sound.stop_sound(data_full_path(data->sampleSpecial[0]));
-      tw_sound.play_sound(data_full_path(data->sampleSpecial[0]));
+      tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+      tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
       shockingFrames = specialFrames;
       shockVar = 1;
       recharge_amount = 0; 
@@ -147,36 +147,36 @@
 	}
       if(shockingFrames == 2000 )
 	{
-	  tw_sound.stop_sound(data_full_path(data->sampleSpecial[0]));
-	  tw_sound.play_sound(data_full_path(data->sampleSpecial[0]));
+	  tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+	  tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
 
 	  add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
 	}
       if(shockingFrames == 1500 )
 	{
-	  tw_sound.stop_sound(data_full_path(data->sampleSpecial[0]));
-	  tw_sound.play_sound(data_full_path(data->sampleSpecial[0]));
+	  tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+	  tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
 	  
 	  add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
 	}
       if(shockingFrames == 1000 )
 	{
-	  tw_sound.stop_sound(data_full_path(data->sampleSpecial[0]));
-	  tw_sound.play_sound(data_full_path(data->sampleSpecial[0]));
+	  tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+	  tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
 	  
 	  add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
 	}
       if(shockingFrames == 500 )
 	{
-	  tw_sound.stop_sound(data_full_path(data->sampleSpecial[0]));
-	  tw_sound.play_sound(data_full_path(data->sampleSpecial[0]));
+	  tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+	  tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
 	  
 	  add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
 	}
       if(shockingFrames == 50 )
 	{
-	  tw_sound.stop_sound(data_full_path(data->sampleSpecial[1]));
-	  tw_sound.play_sound(data_full_path(data->sampleSpecial[1]));
+	  tw_sound->stop_sound(data_full_path(data->sampleSpecial[1]));
+	  tw_sound->play_sound(data_full_path(data->sampleSpecial[1]));
 	  
 	  add( new ForevianShockwave(0, 70, angle , specialVelocity, specialDamage, 
 				     specialRange, specialArmour, this, this, special_sprite, 
@@ -211,8 +211,8 @@
   if (other==last_hit)
     return;
   
-  tw_sound.stop_sound(data_full_path(data->sampleSpecial[2]));
-  tw_sound.play_sound(data_full_path(data->sampleSpecial[2]));
+  tw_sound->stop_sound(data_full_path(data->sampleSpecial[2]));
+  tw_sound->play_sound(data_full_path(data->sampleSpecial[2]));
 	  
   if (!other->sameShip(this))
     damage(other, 0, damage_factor);

Modified: trunk/source/ships/shpgarty.cpp
===================================================================
--- trunk/source/ships/shpgarty.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/ships/shpgarty.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -392,7 +392,7 @@
 
   if (!done_once)
     {
-      tw_sound.play_sound(data_full_path(data->sampleExtra[0])); //charge
+      tw_sound->play_sound(data_full_path(data->sampleExtra[0])); //charge
       done_once=TRUE;
     }
 
@@ -410,7 +410,7 @@
 	      charge_frame++;
 	      if(charge_frame == 5) 
 		{ 
-		  tw_sound.play_sound(data_full_path(data->sampleExtra[0])); //charge
+		  tw_sound->play_sound(data_full_path(data->sampleExtra[0])); //charge
 		  charge_frame = 0;
 		  charge_phase++;
 		  damage_factor += Charge;
@@ -430,7 +430,7 @@
 	  released = TRUE;
 	  if (Timer > MinTL)
 	    {
-	      tw_sound.play_sound(data_full_path(data->sampleWeapon[0])); //shoot
+	      tw_sound->play_sound(data_full_path(data->sampleWeapon[0])); //shoot
 	    }
 	}
       else 
@@ -457,9 +457,9 @@
   else if (Timer < MinTL) 
     {
       released=TRUE;
-      tw_sound.play_sound(data_full_path(data->sampleExtra[0]));
-      tw_sound.stop_sound(data_full_path(data->sampleExtra[1])); //cancel if less than min time limit
-      tw_sound.play_sound(data_full_path(data->sampleExtra[1])); //cancel if less than min time limit
+      tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
+      tw_sound->stop_sound(data_full_path(data->sampleExtra[1])); //cancel if less than min time limit
+      tw_sound->play_sound(data_full_path(data->sampleExtra[1])); //cancel if less than min time limit
       
       state=0;
     }
@@ -524,7 +524,7 @@
   armour += damage_factor + direct ; // nullify damage
   if (((!ship_hit && !source->isShip()) ||
        (ship_hit && source->isShip())) && !released)
-    tw_sound.play_sound(data_full_path(data->sampleExtra[2]));
+    tw_sound->play_sound(data_full_path(data->sampleExtra[2]));
   Shot::handle_damage(source, normal, direct);
   return 0;
 }

Modified: trunk/source/ships/shpilwsp.cpp
===================================================================
--- trunk/source/ships/shpilwsp.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/ships/shpilwsp.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -183,8 +183,8 @@
       freq = 2000 - 80*(int)other->mass;
     }
 
-  tw_sound.stop_sound(data_full_path(data->sampleExtra[0]));
-  tw_sound.play_sound(data_full_path(data->sampleExtra[0])); 
+  tw_sound->stop_sound(data_full_path(data->sampleExtra[0]));
+  tw_sound->play_sound(data_full_path(data->sampleExtra[0])); 
   game->add( new FixedAnimation( this, other, data->spriteExtra, 0, 
 				 data->spriteExtra->frames(), time_ratio, LAYER_EXPLOSIONS ));
   

Modified: trunk/source/ships/shprogsq.cpp
===================================================================
--- trunk/source/ships/shprogsq.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/ships/shprogsq.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -672,8 +672,7 @@
 
 	if ( !state )
 	{
-	  // this ship dies :(
-	  tw_sound.play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
+	  tw_sound->play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
 	  game->add(new Animation(this, pos, meleedata.kaboomSprite, 0, 
 				  KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS));
 	}
@@ -738,16 +737,16 @@
   switch(i)
     {
     case 0:
-      tw_sound.play_sound(data_full_path(MELEE_BOOM_SOUND1));
+      tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND1));
       break;
     case 1:
-      tw_sound.play_sound(data_full_path(MELEE_BOOM_SOUND2));
+      tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND2));
       break;
     case 2:
-      tw_sound.play_sound(data_full_path(MELEE_BOOM_SOUND3));
+      tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND3));
       break;
     case 3:
-      tw_sound.play_sound(data_full_path(MELEE_BOOM_SOUND4));
+      tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND4));
       break;
     default:
       {

Modified: trunk/source/ships/shpstaba.cpp
===================================================================
--- trunk/source/ships/shpstaba.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/ships/shpstaba.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -116,7 +116,7 @@
 		}
 	if (fire) 
 	  {
-	    tw_sound.play_sound(data_full_path(MELEE_BOOM_SOUND1));
+	    tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND1));
 	  }
 
 	return(fire);
@@ -148,7 +148,7 @@
   }
   if (fire) 
     {
-      tw_sound.play_sound(data_full_path(MELEE_BOOM_SOUND1));
+      tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND1));
     }
   
   Ship::calculate();

Modified: trunk/source/ships/shptauar.cpp
===================================================================
--- trunk/source/ships/shptauar.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/ships/shptauar.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -256,11 +256,11 @@
 	 {
 	   if (fire_special)
 	     {
-	       tw_sound.play_sound(data_full_path(data->sampleSpecial[0]));
+	       tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
 	     }
 	   else
 	     {
-	       tw_sound.play_sound(data_full_path(data->sampleWeapon[0]));
+	       tw_sound->play_sound(data_full_path(data->sampleWeapon[0]));
 	     }
 	   weapon_sound_timer = iround(weaponSoundTimer * tw_random(0.49, 1.63));
 	 }
@@ -474,15 +474,15 @@
 		image->type = DAT_RLE_SPRITE;
 		tmp = create_bitmap_ex( bitmap_color_depth( bmp ), bmp->w, bmp->h );
 		//void* old_color_effects = videosystem.color_effects;
-		void* old_color_effects = (void *)videosystem.color_effects; //added (void *) 7/1/2003 Culture20
-		videosystem.color_effects = TauArchonFreezeColorEffects;
+		void* old_color_effects = (void *)videosystem->color_effects; //added (void *) 7/1/2003 Culture20
+		videosystem->color_effects = TauArchonFreezeColorEffects;
 	//	videosystem.update_colors();
 		blit( bmp, tmp, 0, 0, 0, 0, bmp->w, bmp->h );
 		image->dat = get_rle_sprite( tmp );
 		SpaceSprite* frozen_sprite = new SpaceSprite( image, 1 );
 		destroy_bitmap( tmp );
 		//videosystem.color_effects = (void (__cdecl *)(struct RGB *))old_color_effects;
-		videosystem.color_effects = (void (*)(struct RGB *))old_color_effects; //removed __cdecl 7/1/2003 Culture20
+		videosystem->color_effects = (void (*)(struct RGB *))old_color_effects; //removed __cdecl 7/1/2003 Culture20
 	//	videosystem.update_colors();
 		delete image;
 		game->add(new TauArchonFrozen(this, other, frozen_sprite));
@@ -519,11 +519,11 @@
 
 	if (tw_random()%2)
 	  {
-	    tw_sound.play_sound(data_full_path(data->sampleWeapon[4]));
+	    tw_sound->play_sound(data_full_path(data->sampleWeapon[4]));
 	  }
 	else
 	  {
-	    tw_sound.play_sound(data_full_path(data->sampleWeapon[5]));
+	    tw_sound->play_sound(data_full_path(data->sampleWeapon[5]));
 	  }
 }
 

Modified: trunk/source/ships/shptausl.cpp
===================================================================
--- trunk/source/ships/shptausl.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/ships/shptausl.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -163,8 +163,8 @@
 	      batt -= special_drain;
 	      special_recharge += special_rate;
 	      
-	      tw_sound.stop_sound(data_full_path(data->sampleSpecial[0]));
-	      tw_sound.play_sound(data_full_path(data->sampleSpecial[0]));
+	      tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+	      tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
 	      
 	      if (special_charge >= max_charge)
 		activate_special(); 
@@ -195,13 +195,13 @@
       a = special_charge - sub_range;
       jd = range0 + a * (range1 + a * range2);
       trace_recharge = 0;
-      tw_sound.stop_sound(data_full_path(data->sampleSpecial[2]));
-      tw_sound.play_sound(data_full_path(data->sampleSpecial[2]));
+      tw_sound->stop_sound(data_full_path(data->sampleSpecial[2]));
+      tw_sound->play_sound(data_full_path(data->sampleSpecial[2]));
     }
   else    
     {
-      tw_sound.stop_sound(data_full_path(data->sampleSpecial[1]));
-      tw_sound.play_sound(data_full_path(data->sampleSpecial[1]));
+      tw_sound->stop_sound(data_full_path(data->sampleSpecial[1]));
+      tw_sound->play_sound(data_full_path(data->sampleSpecial[1]));
     }
 
   special_charge = 0;
@@ -211,24 +211,27 @@
 void TauSlider::calculate()
 {
   STACKTRACE;
-        just_exited = false;
-        Ship::calculate();
-        if (in_jump) {
-                trace_recharge -= frame_time;
-                if (trace_recharge < 0) {
-                        trace_recharge += trace_rate;
-                        ct = (ct + 1) % max_trace_number;
-                        tr[ct] = new TauSliderTrace(this); 
-						add(tr[ct]);}
-                //x = normalize(x + jvx * frame_time, X_MAX);
-                //y = normalize(y + jvy * frame_time, Y_MAX);
-				pos = normalize(pos + jvp * frame_time, map_size);
-                jd -= jv * frame_time;
-                if (jd <= 0) {
-                        in_jump = false;
-                        layer = LAYER_SHIPS;
-                        collide_flag_anyone = collide_flag_reserve; }                        
-        }        
+  just_exited = false;
+  Ship::calculate();
+  if (in_jump) 
+    {
+      trace_recharge -= frame_time;
+      if (trace_recharge < 0) 
+	{
+	  trace_recharge += trace_rate;
+	  ct = (ct + 1) % max_trace_number;
+	  tr[ct] = new TauSliderTrace(this); 
+	  add(tr[ct]);
+	}
+      pos = normalize(pos + jvp * frame_time, map_size);
+      jd -= jv * frame_time;
+      if (jd <= 0) 
+	{
+	  in_jump = false;
+	  layer = LAYER_SHIPS;
+	  collide_flag_anyone = collide_flag_reserve; 
+	}
+    }        
 }
 
 int TauSlider::handle_damage(SpaceLocation *source, int normal, int direct) {

Modified: trunk/source/ships/shptaust.cpp
===================================================================
--- trunk/source/ships/shptaust.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/ships/shptaust.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -175,7 +175,7 @@
   smoke_frame = 0;
   first_frame = 12;
   
-  tw_sound.play_sound(data_full_path(s));
+  tw_sound->play_sound(data_full_path(s));
 }
 
 

Modified: trunk/source/ships/shptauto.cpp
===================================================================
--- trunk/source/ships/shptauto.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/ships/shptauto.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -134,7 +134,7 @@
       can_switch = false;
       if (TauTor_state) 
 	{
-	  tw_sound.play_sound(data_full_path(data->sampleExtra[1]));
+	  tw_sound->play_sound(data_full_path(data->sampleExtra[1]));
 	  residual_drain = 0.0;
 	  recharge_amount = extra_recharge;
 	  weapon_rate  = extra_rate;
@@ -147,7 +147,7 @@
 	  transition_count = transition_time;
 	  residual_drain = 0.0;
 	  recharge_amount = 0;
-	  tw_sound.play_sound(data_full_path(data->sampleExtra[0]));
+	  tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
 	  weapon_rate  = special_rate;
 	  weapon_drain = special_drain; 
 	}
@@ -176,7 +176,7 @@
   
   if (TauTor_state && (batt == 0)) 
     {
-      tw_sound.play_sound(data_full_path(data->sampleExtra[1]));
+      tw_sound->play_sound(data_full_path(data->sampleExtra[1]));
       residual_drain = 0.0;
       recharge_amount = extra_recharge;
       weapon_rate  = extra_rate;

Modified: trunk/source/ships/shpyusra.cpp
===================================================================
--- trunk/source/ships/shpyusra.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/ships/shpyusra.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -210,8 +210,8 @@
   rel_dist = distance( other );
   change_owner( other );       // are now part of the other ship
   std::string smpl = data->sampleWeapon[1 + random() % 2];
-  tw_sound.stop_sound(data_full_path(smpl));
-  tw_sound.play_sound(data_full_path(smpl));
+  tw_sound->stop_sound(data_full_path(smpl));
+  tw_sound->play_sound(data_full_path(smpl));
 }
 
 int YushSpear::handle_damage( SpaceLocation* other, double normal, double direct )

Modified: trunk/source/ships/shpzeksh.cpp
===================================================================
--- trunk/source/ships/shpzeksh.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/ships/shpzeksh.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -78,8 +78,8 @@
 int ZekfahanShocker::activate_weapon()
 {
   STACKTRACE;
-  tw_sound.stop_sound(data_full_path(data->sampleWeapon[0]));
-  tw_sound.play_sound(data_full_path(data->sampleWeapon[0]));
+  tw_sound->stop_sound(data_full_path(data->sampleWeapon[0]));
+  tw_sound->play_sound(data_full_path(data->sampleWeapon[0]));
   
   add(new AnimatedShot(this, Vector2(42.0, 15.0), angle , weaponVelocity,
 		       weaponDamage, weaponRange, weaponArmour, this, data->spriteWeapon, 5, 12, 1.0));
@@ -93,8 +93,8 @@
   STACKTRACE;
   if(shockingFrames == 0)
     {
-      tw_sound.stop_sound(data_full_path(data->sampleSpecial[0]));
-      tw_sound.play_sound(data_full_path(data->sampleSpecial[0]));
+      tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+      tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
       
       shockingFrames = specialFrames;
       shockVar = 1;
@@ -118,8 +118,8 @@
       }
     if(shockVar && shockingFrames <= 50 )
       {
-	tw_sound.stop_sound(data_full_path(data->sampleSpecial[1]));
-	tw_sound.play_sound(data_full_path(data->sampleSpecial[1]));
+	tw_sound->stop_sound(data_full_path(data->sampleSpecial[1]));
+	tw_sound->play_sound(data_full_path(data->sampleSpecial[1]));
 	
 	add( new Shockwave(Vector2(0, 70), angle , specialVelocity, 
 			   specialDamage, specialRange, specialArmour, this, this, 
@@ -144,8 +144,8 @@
 void Shockwave::inflict_damage(SpaceObject *other) 
 {
   STACKTRACE;
-  tw_sound.stop_sound(data_full_path(data->sampleSpecial[2]));
-  tw_sound.play_sound(data_full_path(data->sampleSpecial[2]));
+  tw_sound->stop_sound(data_full_path(data->sampleSpecial[2]));
+  tw_sound->play_sound(data_full_path(data->sampleSpecial[2]));
  
   damage(other, 0, damage_factor);
   add( new Animation(this, pos, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));

Modified: trunk/source/util/errors.cpp
===================================================================
--- trunk/source/util/errors.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/util/errors.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -85,9 +85,9 @@
   int i;
   
   if (popup) 
-    i = tw_popup_dialog(&videosystem.window, dialog, 2) - 2;
+    i = tw_popup_dialog(&videosystem->window, dialog, 2) - 2;
   else
-    i = tw_do_dialog   (&videosystem.window, dialog, 2) - 2;
+    i = tw_do_dialog   (&videosystem->window, dialog, 2) - 2;
   return i + 1;
 }
 
@@ -140,7 +140,7 @@
   log_debug(UserStackTraceHelper::get_stack_trace_string().c_str());
   
   
-  if (videosystem.width <= 0) {
+  if (videosystem->width <= 0) {
     allegro_message("Critical Error$: %s\n", error_string);
     log_debug("\nUnable to display messge, shutting down\n");
     throw -1;
@@ -167,7 +167,7 @@
     selection = ES_ABORT;
   log_debug("Option \"%s\" selected\n", es[selection]);
   
-  videosystem.screen_corrupted = true;
+  videosystem->screen_corrupted = true;
   
   if (selection == ES_DEBUG) {//"Debug"
     __error_flag |= 1;
@@ -214,7 +214,7 @@
 
 void tw_error_exit(const char* message) {
 	log_debug("\nCritical Error!: %s\n\n", message);
-	if ((videosystem.width > 0) && (strlen(message) < 1000)) {
+	if ((videosystem->width > 0) && (strlen(message) < 1000)) {
 		char buf[1024];
 		sprintf(buf, "Critical Error!: %s", message);
 		tw_alert (buf, "Quit");
@@ -249,13 +249,12 @@
   #ifdef DEBUG
   //  debug_log(GetStackNodeString(srcline).c_str());
   #endif 
-
-  call_stack.push(srcline);
+      call_stack.push(srcline);
 }
 
 UserStackTraceHelper::~UserStackTraceHelper()
 {
-  call_stack.pop();
+      call_stack.pop();
 }
 
 std::string UserStackTraceHelper::GetStackNodeString(SOURCE_LINE* stNode)

Modified: trunk/source/util/sound.cpp
===================================================================
--- trunk/source/util/sound.cpp	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/util/sound.cpp	2004-09-25 19:22:38 UTC (rev 63)
@@ -26,7 +26,8 @@
 #include "other/twconfig.h"
 #include "errors.h"
 
-SoundSystem tw_sound;
+SoundSystem* tw_sound = NULL;
+
 SoundSystem::SoundSystem(bool sound_on)
 {
   STACKTRACE;

Modified: trunk/source/util/sound.h
===================================================================
--- trunk/source/util/sound.h	2004-09-25 16:33:16 UTC (rev 62)
+++ trunk/source/util/sound.h	2004-09-25 19:22:38 UTC (rev 63)
@@ -67,6 +67,6 @@
   /// \brief return true if music playing
   bool playing_music();
 };
-extern SoundSystem tw_sound;
+extern SoundSystem* tw_sound;
 
 #endif



From yurand at sheep.berlios.de  Sun Sep 26 10:31:02 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 26 Sep 2004 10:31:02 +0200
Subject: [Tw-light-svn] r64 - in trunk: . gamedata gamedata/ships source source/games source/libraries source/libraries/lua source/libraries/lua/lib source/other
Message-ID: <200409260831.i8Q8V2NU015407@sheep.berlios.de>

Author: yurand
Date: 2004-09-26 10:30:59 +0200 (Sun, 26 Sep 2004)
New Revision: 64

Added:
   trunk/gamedata/gob.dat
   trunk/source/games/ggob.cpp
   trunk/source/games/ggob.h
   trunk/source/libraries/lua/
   trunk/source/libraries/lua/Makefile
   trunk/source/libraries/lua/README
   trunk/source/libraries/lua/lapi.c
   trunk/source/libraries/lua/lapi.h
   trunk/source/libraries/lua/lauxlib.h
   trunk/source/libraries/lua/lcode.c
   trunk/source/libraries/lua/lcode.h
   trunk/source/libraries/lua/ldebug.c
   trunk/source/libraries/lua/ldebug.h
   trunk/source/libraries/lua/ldo.c
   trunk/source/libraries/lua/ldo.h
   trunk/source/libraries/lua/ldump.c
   trunk/source/libraries/lua/lfunc.c
   trunk/source/libraries/lua/lfunc.h
   trunk/source/libraries/lua/lgc.c
   trunk/source/libraries/lua/lgc.h
   trunk/source/libraries/lua/lib/
   trunk/source/libraries/lua/lib/Makefile
   trunk/source/libraries/lua/lib/README
   trunk/source/libraries/lua/lib/lauxlib.c
   trunk/source/libraries/lua/lib/lbaselib.c
   trunk/source/libraries/lua/lib/ldblib.c
   trunk/source/libraries/lua/lib/liolib.c
   trunk/source/libraries/lua/lib/lmathlib.c
   trunk/source/libraries/lua/lib/loadlib.c
   trunk/source/libraries/lua/lib/lstrlib.c
   trunk/source/libraries/lua/lib/ltablib.c
   trunk/source/libraries/lua/llex.c
   trunk/source/libraries/lua/llex.h
   trunk/source/libraries/lua/llimits.h
   trunk/source/libraries/lua/lmem.c
   trunk/source/libraries/lua/lmem.h
   trunk/source/libraries/lua/lobject.c
   trunk/source/libraries/lua/lobject.h
   trunk/source/libraries/lua/lopcodes.c
   trunk/source/libraries/lua/lopcodes.h
   trunk/source/libraries/lua/lparser.c
   trunk/source/libraries/lua/lparser.h
   trunk/source/libraries/lua/lstate.c
   trunk/source/libraries/lua/lstate.h
   trunk/source/libraries/lua/lstring.c
   trunk/source/libraries/lua/lstring.h
   trunk/source/libraries/lua/ltable.c
   trunk/source/libraries/lua/ltable.h
   trunk/source/libraries/lua/ltests.c
   trunk/source/libraries/lua/ltm.c
   trunk/source/libraries/lua/ltm.h
   trunk/source/libraries/lua/lua.h
   trunk/source/libraries/lua/lualib.h
   trunk/source/libraries/lua/lundump.c
   trunk/source/libraries/lua/lundump.h
   trunk/source/libraries/lua/lvm.c
   trunk/source/libraries/lua/lvm.h
   trunk/source/libraries/lua/lzio.c
   trunk/source/libraries/lua/lzio.h
   trunk/source/other/gup.cpp
   trunk/source/other/gup.h
Modified:
   trunk/gamedata/ships/shpalabc.txt
   trunk/gamedata/ships/shpandgu.txt
   trunk/gamedata/ships/shpbipka.txt
   trunk/gamedata/ships/shpchebr.txt
   trunk/gamedata/ships/shpchmav.txt
   trunk/gamedata/ships/shpchoex.txt
   trunk/gamedata/ships/shpconca.txt
   trunk/gamedata/ships/shpconho.txt
   trunk/gamedata/ships/shpdruma.txt
   trunk/gamedata/ships/shpearc3.txt
   trunk/gamedata/ships/shpforsh.txt
   trunk/gamedata/ships/shpgarty.txt
   trunk/gamedata/ships/shpilwsp.txt
   trunk/gamedata/ships/shpkahbo.txt
   trunk/gamedata/ships/shporzne.txt
   trunk/gamedata/ships/shprogsq.txt
   trunk/gamedata/ships/shpsupbl.txt
   trunk/gamedata/ships/shpthrto.txt
   trunk/makefile
   trunk/source/games/gflmelee.cpp
   trunk/source/scp.h
   trunk/sources.lst
Log:
GOB added


Added: trunk/gamedata/gob.dat
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/gob.dat
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/gamedata/ships/shpalabc.txt
===================================================================
--- trunk/gamedata/ships/shpalabc.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpalabc.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -3,18 +3,13 @@
 
 Weapon:
 -------
-Heavy "fire and forget" MIRV torpedo. The torpedo is extremely slow though
-(even warheads have lower-than-average velocity).
+Heavy "fire and forget" MIRV torpedo. The torpedo is extremely slow though (even warheads have lower-than-average velocity).
 
 Note: Torpedo itself will not do damage on collisions (only launched warheads will). 
 
 Turrets:
 --------
-Press "special" to turn them on or off (look in the upper-right corner
-of the "captain screen" to see current state). When on, turrets will
-automatically shoot on possible targets in range. Priority list is
-(descending): your target, any enemy ship, non-damaging things,
-heavy shots.
+Press "special" to turn them on or off (look in the upper-right corner of the "captain screen" to see current state). When on, turrets will automatically shoot on possible targets in range. Priority list is (descending): your target, any enemy ship, non-damaging things, heavy shots.
 
 Note: Turrets can be damaged (disabled).
 
@@ -25,18 +20,14 @@
 
 Shield:
 -------
-Automatic absorbance shield can block most of the incoming damage.
-Does not work when/if overloaded by continuous heavy fire.
-The shield status indicator is located in the upper-left corner
-of the "captain screen"
+Automatic absorbance shield can block most of the incoming damage. Does not work when/if overloaded by continuous heavy fire. The shield status indicator is located in the upper-left corner of the "captain screen"
 
 Note: Shield does cover turrets and engines.
 
 
 Quirk #1:
 ---------
-Damage (even direct) cut in half (to make this ship really tough
-without going over 42 crew (for aesthetic reasons)).
+Damage (even direct) cut in half (to make this ship really tough without going over 42 crew (for aesthetic reasons)). 
 
 Quirk #2:
 ---------
@@ -46,5 +37,3 @@
 -----------------------------------
 *Tau* <twships at tau137.com>
 
-
-Last updated on 31 Jan 2003.

Modified: trunk/gamedata/ships/shpandgu.txt
===================================================================
--- trunk/gamedata/ships/shpandgu.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpandgu.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,7 +1,3 @@
-The Androsynth Guardians main weapon fires acid
-bubbles that slowly home in on enemies using the
-Chaos(tm) tracking system.  
+The Androsynth Guardians main weapon fires acid bubbles that slowly home in on enemies using the Chaos(tm) tracking system.  
 
-It's special weapon transforms it into a flaming comet,
-which is extremely fast and maneuverable, and inflicts
-damage upon impact.  
\ No newline at end of file
+It's special weapon transforms it into a flaming comet, which is extremely fast and maneuverable, and inflicts damage upon impact.  
\ No newline at end of file

Modified: trunk/gamedata/ships/shpbipka.txt
===================================================================
--- trunk/gamedata/ships/shpbipka.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpbipka.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,17 +1,14 @@
-Bipole Katamaran
-
-For a stone-like race. Maybe Taalo...
-
-Primary Weapon:
-  Both sideships have a simple projectile cannon.
-  
-Special:
-  Increases the distance between the sideships (if both exist) or accelerates
-  backwards (if only one of them exists).
-
-Notes:
-  This ship is made up of two 'sideships' each of which can survive the
-  destruction of the other. Their crew and battery is kept track of independently
-  but is shown on the panel summed.
-
- * created by: cyhawk at sch.bme.hu and forevian at freemail.hu
+Bipole Katamaran
+
+For a stone-like race. Maybe Taalo...
+
+Primary Weapon:
+  Both sideships have a simple projectile cannon.
+  
+Special:
+  Increases the distance between the sideships (if both exist) or accelerates backwards (if only one of them exists).
+
+Notes:
+  This ship is made up of two 'sideships' each of which can survive the destruction of the other. Their crew and battery is kept track of independently but is shown on the panel summed.
+
+ * created by: cyhawk at sch.bme.hu and forevian at freemail.hu

Modified: trunk/gamedata/ships/shpchebr.txt
===================================================================
--- trunk/gamedata/ships/shpchebr.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpchebr.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,13 +1,8 @@
-The Chenjesu Broodhome main weapon fires crystals
-that keep traveling until you lift the fire button,
-when they explode into many small fragments.  
+The Chenjesu Broodhome main weapon fires crystals that keep traveling until you lift the fire button, when they explode into many small fragments.  
 
-It's special weapon launches DOGIs that seek the
-Chenjesu's target and drain their battery.  
+It's special weapon launches DOGIs that seek the Chenjesu's target and drain their battery.  
 
 Chenjesu are a crystaline life form.  
 
-In Star Control 2, the Chenjesu were imprisoned on
-their homeworld with the Mmrnmhrmm before the game
-started, slowly transforming into Chmmr.  
+In Star Control 2, the Chenjesu were imprisoned on their homeworld with the Mmrnmhrmm before the game started, slowly transforming into Chmmr.  
 

Modified: trunk/gamedata/ships/shpchmav.txt
===================================================================
--- trunk/gamedata/ships/shpchmav.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpchmav.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,18 +1,9 @@
-The Chmmr Avatar is one of the original ships
-from Star Control 2.
-
 The ship's main weapon consists of an uberlaser.
 
-Three defense satellites circle the ship. Each is
-equipped with a short-range auto-targeting laser.
+Three defense satellites circle the ship. Each is equipped with a short-range auto-targeting laser.
 
 The special is a tractor beam with unlimited range.
 
-The Chmmr are a race born of two races, the Chenjesu 
-and the Mrmnmhrm, in an attempt to save the latter from 
-extinction.  The Chmmr are immensely powerful, hyper-
-intelligent, and possibly somewhat schizophenic.  
+The Chmmr are a race born of two races, the Chenjesu and the Mrmnmhrm, in an attempt to save the latter from extinction.  The Chmmr are immensely powerful, hyper-intelligent, and possibly somewhat schizophenic.  
 
-The Chmmr were slave-shielded by the Ur-Quan, but 
-when set free provided a valuable contribution to
-the fight for freedom.
\ No newline at end of file
+The Chmmr were slave-shielded by the Ur-Quan, but when set free provided a valuable contribution to the fight for freedom.
\ No newline at end of file

Modified: trunk/gamedata/ships/shpchoex.txt
===================================================================
--- trunk/gamedata/ships/shpchoex.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpchoex.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,30 +1,30 @@
-The Chorali Extractor
-CrewMax        = 10
-BattMax        = 20
-SpeedMax       = 40
-AccelRate      = 10
-TurnRate       = 2
-I've got the speed/turning set medium/high to compensate for my lack of skill.
-
-Appearance: Currently, it's a shiny gold colored ship.  It's physically large, but that's only because I wanted to have a spinning asteroid as part of the ship.  The front of the ship is flanged outward; this is where the ship's tractor beam comes from.
-
-Weapon: Multi-Use Tractor Beam.  
-Cost: 8 to activate or deactivate prematurely
-Range:6 (from center of ship)
-Time: The Beam lasts for 6000 frames (not sure what that is in seconds, 6?)
-Description:  The Chorali use their tractor beams for just about everything.  They didn't invent the beams, they found the technology on a dead world and replicated it, but they can at least come up with new uses.  First, the beams will draw any matter they come in contact with (currently just ships and asteroids, I tried to get the cargo chain from the confed cargotran to work, but I'm not sure what way would be proper).  The beams also turn any ships they draw, so that they will not continue to fire at the Extractor (watch out for B.U.T.T. missles). If the object is drawn completely to the Extractor, it will be held stationary (no thrust or turning, fire & special still work) until the beam's duration is done.  If the fire button is pressed while an asteroid is held, the asteroid is lobbed at high velocity towards the current target.  Weak long range tractor beams will occasionally correct the trajectory of the missile. 
-[AsteroidMissile]
-Range    = 60
-Velocity = 80
-Damage   = 2
-Armour   = 1
-TurnRate = 2
-The beams will also push away any objects that the onboard computer thinks are dangerous.  Currently, the only homing missiles it can keep at bay are Mycon plasmoids and Khor-Ah blades.
-
-
-Special:  Planet-Fall.
-Cost: 1
-Rate: 0
-The Chorali have discovered that their tractor beams can also be used on nearby planets with surpising success.  If the beams are not focused, they will draw the ship towards the planet.  Used in combination with the main weapon, the Extractor can force enemy ships to crash into the planet.
-
-Quirk: If the highly focused beams of the main weapon are used on the planet, chunks of matter are lifted from the planet, making asteroids (of a non-regenerating type, to keep the amount of permanent asteroids to a minimum).
+The Chorali Extractor
+CrewMax        = 10
+BattMax        = 20
+SpeedMax       = 40
+AccelRate      = 10
+TurnRate       = 2
+I've got the speed/turning set medium/high to compensate for my lack of skill.
+
+Appearance: Currently, it's a shiny gold colored ship.  It's physically large, but that's only because I wanted to have a spinning asteroid as part of the ship.  The front of the ship is flanged outward; this is where the ship's tractor beam comes from.
+
+Weapon: Multi-Use Tractor Beam.  
+Cost: 8 to activate or deactivate prematurely
+Range:6 (from center of ship)
+Time: The Beam lasts for 6000 frames (not sure what that is in seconds, 6?)
+Description:  The Chorali use their tractor beams for just about everything.  They didn't invent the beams, they found the technology on a dead world and replicated it, but they can at least come up with new uses.  First, the beams will draw any matter they come in contact with (currently just ships and asteroids, I tried to get the cargo chain from the confed cargotran to work, but I'm not sure what way would be proper).  The beams also turn any ships they draw, so that they will not continue to fire at the Extractor (watch out for B.U.T.T. missles). If the object is drawn completely to the Extractor, it will be held stationary (no thrust or turning, fire & special still work) until the beam's duration is done.  If the fire button is pressed while an asteroid is held, the asteroid is lobbed at high velocity towards the current target.  Weak long range tractor beams will occasionally correct the trajectory of the missile. 
+[AsteroidMissile]
+Range    = 60
+Velocity = 80
+Damage   = 2
+Armour   = 1
+TurnRate = 2
+The beams will also push away any objects that the onboard computer thinks are dangerous.  Currently, the only homing missiles it can keep at bay are Mycon plasmoids and Khor-Ah blades.
+
+
+Special:  Planet-Fall.
+Cost: 1
+Rate: 0
+The Chorali have discovered that their tractor beams can also be used on nearby planets with surpising success.  If the beams are not focused, they will draw the ship towards the planet.  Used in combination with the main weapon, the Extractor can force enemy ships to crash into the planet.
+
+Quirk: If the highly focused beams of the main weapon are used on the planet, chunks of matter are lifted from the planet, making asteroids (of a non-regenerating type, to keep the amount of permanent asteroids to a minimum).

Modified: trunk/gamedata/ships/shpconca.txt
===================================================================
--- trunk/gamedata/ships/shpconca.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpconca.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,28 +1,28 @@
-Ship		- Confed Cargotran
-Class		- Commercial cargo tug
-Crew		- 6
-Battery		- 4
-Acceleration	- Awe-inspiring
-Turning		- Average
-Top speed	- Slower than an Earthling Cruiser
-Creator		- Corona688, tsm at accesscomm.ca
-
-Weapons:
- Primary 	- Weak short-range laser
- Secondary	- Decelerate, straightens out the chain
- Teritary	- fire + special, ditch the cargo
-
-Weaknesses:	This is NOT a military vessel, and is not meant to
- enter combat.  It's single weapon is only really meant to crack
- asteroids.  Even worse, the structural integrity field used to
- chain the cargo containers behind it means that any damage on them is 
- transferred to the tug.  If forced to enter combat, the captain's
- only recourse is to ditch the cargo entirely and take refuge in the
- slowly growing cloud of containers.
-
-Strengths:	No military strengths.
-
-Quirks:		Although the tug itself has terrific acceleration, this
- is more than offset by the kilotons of cargo it tows.  If caught in a
- gravity well, the cargo can easily haul the whole mess into the planet
+Ship		- Confed Cargotran
+Class		- Commercial cargo tug
+Crew		- 6
+Battery		- 4
+Acceleration	- Awe-inspiring
+Turning		- Average
+Top speed	- Slower than an Earthling Cruiser
+Creator		- Corona688, tsm at accesscomm.ca
+
+Weapons:
+ Primary 	- Weak short-range laser
+ Secondary	- Decelerate, straightens out the chain
+ Teritary	- fire + special, ditch the cargo
+
+Weaknesses:	This is NOT a military vessel, and is not meant to
+ enter combat.  It's single weapon is only really meant to crack
+ asteroids.  Even worse, the structural integrity field used to
+ chain the cargo containers behind it means that any damage on them is 
+ transferred to the tug.  If forced to enter combat, the captain's
+ only recourse is to ditch the cargo entirely and take refuge in the
+ slowly growing cloud of containers.
+
+Strengths:	No military strengths.
+
+Quirks:		Although the tug itself has terrific acceleration, this
+ is more than offset by the kilotons of cargo it tows.  If caught in a
+ gravity well, the cargo can easily haul the whole mess into the planet
  unless the captain jettisons it immediately.
\ No newline at end of file

Modified: trunk/gamedata/ships/shpconho.txt
===================================================================
--- trunk/gamedata/ships/shpconho.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpconho.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,56 +1,56 @@
-Ship          - Confederation Hornet
-Class         - Medium Range Light Fighter
-crew          - 1
-battery       - 10
-accelleration - Good
-Turning       - Very Good
-Top Speed     - Very Good
-
-Weapons
- Primary   - Dual Ball Laser Cannons
- Secondary - Torpedoes (Direct Damage Missles, Slightly Homing)
-
-Extra - Recharging Shield
- Can absorb 8 points of damage, readout in crew-bar
-
-Limitations
- - killed instantly by any direct damage
-   - current known direct damages include :
-     - running into a planet
-     - Orz Marines
-     - Narool Acid
-     - *NEW* Torpedoes
-
-Strong-Points
- - Extremely Manouverable, an excellent pilot can challenge any ship in space
- - Strong destructive capability for a light fighter (lasers do 1 damage each, Torpedoes do 4)
- - Recharging Shield + High Manouverability = longer life, there is no suffering from length in battle
- - Perfect for circling enemies.
-
-/**************************************************************************************/
-03/02/2001
-  - corrected minor bug (i was 1 pixle off when blitting shield pictures)
-  - changed colors around ship in panel to all blue shades
-
-/**********/
-
-03/01/2001
-Torpedoes Implimented
-  - still 4 damage, but now split across normal and direct, (3 and 1 respectively)
-
-Shield Indicator Overlay Implimented
-  - Displays a color around the ship in the panel indicating how your shield is faring.
-
-mshppan.cpp updated to solve a problem with graphic artifacts being left when a hornet's dying, fixed now - if there are any side affects let me know.
-
-/**********/
-
-02/27/2001
-  - Shield indicator bar all blue now.
-  - added homing to missles.
-  - Minor initialization changes to strenthen ship. (not truly necessary in my opinion)
-
-/**********/
-
-02/26/2001
+Ship          - Confederation Hornet
+Class         - Medium Range Light Fighter
+crew          - 1
+battery       - 10
+accelleration - Good
+Turning       - Very Good
+Top Speed     - Very Good
+
+Weapons
+ Primary   - Dual Ball Laser Cannons
+ Secondary - Torpedoes (Direct Damage Missles, Slightly Homing)
+
+Extra - Recharging Shield
+ Can absorb 8 points of damage, readout in crew-bar
+
+Limitations
+ - killed instantly by any direct damage
+   - current known direct damages include :
+     - running into a planet
+     - Orz Marines
+     - Narool Acid
+     - *NEW* Torpedoes
+
+Strong-Points
+ - Extremely Manouverable, an excellent pilot can challenge any ship in space
+ - Strong destructive capability for a light fighter (lasers do 1 damage each, Torpedoes do 4)
+ - Recharging Shield + High Manouverability = longer life, there is no suffering from length in battle
+ - Perfect for circling enemies.
+
+/**************************************************************************************/
+03/02/2001
+  - corrected minor bug (i was 1 pixle off when blitting shield pictures)
+  - changed colors around ship in panel to all blue shades
+
+/**********/
+
+03/01/2001
+Torpedoes Implimented
+  - still 4 damage, but now split across normal and direct, (3 and 1 respectively)
+
+Shield Indicator Overlay Implimented
+  - Displays a color around the ship in the panel indicating how your shield is faring.
+
+mshppan.cpp updated to solve a problem with graphic artifacts being left when a hornet's dying, fixed now - if there are any side affects let me know.
+
+/**********/
+
+02/27/2001
+  - Shield indicator bar all blue now.
+  - added homing to missles.
+  - Minor initialization changes to strenthen ship. (not truly necessary in my opinion)
+
+/**********/
+
+02/26/2001
 First release, most features implimented
\ No newline at end of file

Modified: trunk/gamedata/ships/shpdruma.txt
===================================================================
--- trunk/gamedata/ships/shpdruma.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpdruma.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,18 +1,19 @@
+ General Overview
 
-The Druuge Mauler is one of the original ships
-from Star Control 2.
+One of the single most troublesome ships in the game. The Mauler is slow, ungainly reactions make it a difficult ship to play with. Mastering the correct usage of the high-recoil cannon is not easy and the slow battery regeneration turns the Mauler into a vulnerable ship. To compensate for the Mauler's weak battery recharging, Druuge captains have been known to order lower-ranking crew members to be thrown into the furnace. Yet, when correctly used against certain ships, the Mauler can prove a deadly adversary. Correct usage of recoil effects would allow for great targeting and quick evasion.
 
-The Druuge Mauler is a slow ship with a very powerful long-range weapon but a weak recharge system.
+Main Weapon: High-Recoil Cannon
 
-The Mauler's only weapon is a long-range, high-recoil cannon. Firing the cannon once will thrust the Mauler backwards slightly. Several shots will send it flying unless the captain thrusts his engines to resist the recoil.
+Takes four points of battery and does six points of damage. The high-recoil cannon's fast shots can pummel an unwary enemy from long distance. The recoil itself can propel the Mauler into ?hyperspacing speed? which can be a double-edged sword. The recoil-effect, combined with the Furnace, nominate the Mauler as one of the few ships that are actually DANGEROUS to a Chmmr Avatar. Aiming takes a while to master but the shots are hard to evade.
 
-To compensate for the Mauler's weak battery recharging, Druuge captains have been known to order lower-ranking crew members to be thrown into the furnace. Although doing this costs the ship one crew member, it also recharges the Mauler's batteries halfway. 
+Special System: The Furnace
 
-The Druuge are a race living in a dystopian 
-corporate society, with an emphasis on trade, 
-profit, and cruelty.  
+At first, this appears to be the single most useless special system available. Throwing a crewman into the furnace to fill half-way of the battery. But when thinking of the possible action ? The Mauler actually never runs out of battery power. This is especially useful against the Avatar where you can use the high-recoil cannon and the supply of battery power to keep out of the Avatar's Tractor-and-Laser tactic, pummeling it to dust. Other than that, it is recommended that you be as cheap as possible on throwing people into the furnace.
 
-The Druuge trade slaves, fuel and artifacts. They
-were responsible for the death of the Gg in order
-to save their own skin when the Kohr-Ah approached.
+Tactical Overview
 
+The Mauler is a very specific ship. It has its advantages only versus specific ships. It is very vulnerable.
+
+Strong against: Chmmr Avatar. Shofixti Scout - The high-recoil would allow the Mauler to stay out of the Glory Device?s range and it only needs one hit to send the Scout to hell. The Ilwrath Avenger will have a hard time against it too. When flown really masterfully it can also tear ships such as the Earthling (Humans) Cruiser apart.
+
+Weak Against: Whoa. What not? The Marauder's spinning blades, the Arilou Skiff can easily lay an ambush, the VUX Limpets, The Slylandro Probe and Pkunk Fury speed. The X-form?s long-range missiles, the Kzer-za Dreadnought]?s fighters, Chenjesu Broodhome DOGIs, the Orz Nemesis marines and the Mycon Podship Can easily wear-down the crew complement. The Utwig Jugger loves meeting the Mauler in battle. 
\ No newline at end of file

Modified: trunk/gamedata/ships/shpearc3.txt
===================================================================
--- trunk/gamedata/ships/shpearc3.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpearc3.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,24 +1,24 @@
-EARTHLING CRUISER MK3
-
-This ship represents yet another attempt to make a worthy "new generation" Earthling ship.
-Started a along time ago, it would never be competed if it was not for Starwreck, which
-inspired that last effort needed to bring this ship to life.  And, sure enough, this attempt
-brings the Earthling Cruiser a step or two closer to its 'Treck predecessors (which is not
-necessarily a bad thing).
-
-Primary weapon on this ship is the proton torpedo launcher, capable of firing highly destructive
-projectiles at long range.  Advanced targeting system automatically tracks all major targets in range
-and calculates optimum firing angle.  However, the launcher itself is limited to a relatively small
-firing arc, and can take some time to aim in on target.  The limited accuracy is an inherited problem
-of all existing proton torpedo launchers.
-
-Secondary weapon system is the short-range point defense laser (PDL).  The beam can be fired
-in short bursts, with some time required to cool down the emitter.   Each burst is automatically
-aimed at the nearest non-friendly object.  If the object is destroyed or is out of range, PDL can
-quickly acquire a new target.  This weapon is especially effective against projectile weapons.
-----------------------------
-
-
-*Tau* <twships at tau137.com>
-
-30 Jan 2003
+EARTHLING CRUISER MK3
+
+This ship represents yet another attempt to make a worthy "new generation" Earthling ship.
+Started a along time ago, it would never be competed if it was not for Starwreck, which
+inspired that last effort needed to bring this ship to life.  And, sure enough, this attempt
+brings the Earthling Cruiser a step or two closer to its 'Treck predecessors (which is not
+necessarily a bad thing).
+
+Primary weapon on this ship is the proton torpedo launcher, capable of firing highly destructive
+projectiles at long range.  Advanced targeting system automatically tracks all major targets in range
+and calculates optimum firing angle.  However, the launcher itself is limited to a relatively small
+firing arc, and can take some time to aim in on target.  The limited accuracy is an inherited problem
+of all existing proton torpedo launchers.
+
+Secondary weapon system is the short-range point defense laser (PDL).  The beam can be fired
+in short bursts, with some time required to cool down the emitter.   Each burst is automatically
+aimed at the nearest non-friendly object.  If the object is destroyed or is out of range, PDL can
+quickly acquire a new target.  This weapon is especially effective against projectile weapons.
+----------------------------
+
+
+*Tau* <twships at tau137.com>
+
+30 Jan 2003

Modified: trunk/gamedata/ships/shpforsh.txt
===================================================================
--- trunk/gamedata/ships/shpforsh.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpforsh.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,22 +1,22 @@
-----------------
-Zekfahan Shocker
-----------------
-
-The primary is the same but the graphics made it necessary
-to put the guns closer. If you think this a major drawback,
-I might redesign it to feature the original barrel distances.
-
-The secondary now is a chain lightning weapon. It will bounce
-towards every non-planet object after a hit, including the
-shocker itself. It does a reducing amount of damage with
-each bouncing, and the shocker is immune to its shot.
-
-Thanks for Richardyzo for allowing me to rework his ship idea.
-(I've done it because the original one had some copyright
-issues with StarCraft.)
-
-I'd like to thank "the coder" also for doing me this job.
-
-Have fun with the new Shocker! Richardyzo, I hope you enjoy it!
-
-	Forevian
+----------------
+Zekfahan Shocker
+----------------
+
+The primary is the same but the graphics made it necessary
+to put the guns closer. If you think this a major drawback,
+I might redesign it to feature the original barrel distances.
+
+The secondary now is a chain lightning weapon. It will bounce
+towards every non-planet object after a hit, including the
+shocker itself. It does a reducing amount of damage with
+each bouncing, and the shocker is immune to its shot.
+
+Thanks for Richardyzo for allowing me to rework his ship idea.
+(I've done it because the original one had some copyright
+issues with StarCraft.)
+
+I'd like to thank "the coder" also for doing me this job.
+
+Have fun with the new Shocker! Richardyzo, I hope you enjoy it!
+
+	Forevian

Modified: trunk/gamedata/ships/shpgarty.txt
===================================================================
--- trunk/gamedata/ships/shpgarty.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpgarty.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,32 +1,32 @@
-Ship          - Garash Tyrant
-Class         - Behemoth
-crew          - 42
-battery       - 42
-acceleration  - Poor
-Turning       - Very Good
-Top Speed     - Average
-
-Weapons
- Primary   - Charging weapon (damage depending on charge)
-  Stage 1: acts as shield and good at ramming
-  Stage 2: can be released.
-  Stage 3: same as stage two but a little bit powerful.
- Secondary - Repulsar wave  
-  Knockbacks opponent.
-  Knockouts control over ship at a very limited time.
-  Inflicts a modest damage.
-
-Weaknesses
- Slow rate of fire
- Cannot shoot at whim (there's a minimum charge required to shoot)
- Cannot hold on to the shot indefinitely (auto released at some max time   limit)
- Very big ship (easy to hit with high armored shots)
- 
- 
-Strenghts
- Good at long range.
- Good defense vs low armoured shots.
- Good at pillboxing tactics.
- Very good versus low range ships.
- Very powerful shot (absorbs everything or any other form of shots!)
-
+Ship          - Garash Tyrant
+Class         - Behemoth
+crew          - 42
+battery       - 42
+acceleration  - Poor
+Turning       - Very Good
+Top Speed     - Average
+
+Weapons
+ Primary   - Charging weapon (damage depending on charge)
+  Stage 1: acts as shield and good at ramming
+  Stage 2: can be released.
+  Stage 3: same as stage two but a little bit powerful.
+ Secondary - Repulsar wave  
+  Knockbacks opponent.
+  Knockouts control over ship at a very limited time.
+  Inflicts a modest damage.
+
+Weaknesses
+ Slow rate of fire
+ Cannot shoot at whim (there's a minimum charge required to shoot)
+ Cannot hold on to the shot indefinitely (auto released at some max time   limit)
+ Very big ship (easy to hit with high armored shots)
+ 
+ 
+Strenghts
+ Good at long range.
+ Good defense vs low armoured shots.
+ Good at pillboxing tactics.
+ Very good versus low range ships.
+ Very powerful shot (absorbs everything or any other form of shots!)
+

Modified: trunk/gamedata/ships/shpilwsp.txt
===================================================================
--- trunk/gamedata/ships/shpilwsp.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpilwsp.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,16 +1,16 @@
-Ilwrath Spider
-
-During the war against the Traddash the Ilwrath could salvage some Traddash
-technology and came out with this new prototype. (non-official concept)
-
-Primary Weapon:
-  Improved dual version of the original flamethrowers partially based on the Torch's
-  after burners.
-  
-Special:
-  Strange smoke that stops everything for a small amount of time. Even projectiles.
-  The smoke completly adsorbs laser.
-
- * created by: DOS and cyhawk at sch.bme.hu and forevian at freemail.hu
- * thank for the folks at Shipboard for suggesting some elements -- I don't
+Ilwrath Spider
+
+During the war against the Traddash the Ilwrath could salvage some Traddash
+technology and came out with this new prototype. (non-official concept)
+
+Primary Weapon:
+  Improved dual version of the original flamethrowers partially based on the Torch's
+  after burners.
+  
+Special:
+  Strange smoke that stops everything for a small amount of time. Even projectiles.
+  The smoke completly adsorbs laser.
+
+ * created by: DOS and cyhawk at sch.bme.hu and forevian at freemail.hu
+ * thank for the folks at Shipboard for suggesting some elements -- I don't
    remember their name and right now I'm lazy to check the topic
\ No newline at end of file

Modified: trunk/gamedata/ships/shpkahbo.txt
===================================================================
--- trunk/gamedata/ships/shpkahbo.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpkahbo.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,12 +1,12 @@
-Kahr Boomerang
-
-This ship has characteristics close to the Yehat Terminator.
-
-Weapon (3)
-Press Special to select (can be done at any time)
-
-Small boomerang : 1 damage that bounces of ships, short range. No limit.
-Medium boomerang : 3 damage, long range (otherwise same as small). limit 4.
-Large boomerang : 5 damage, controlable range, when you release fire will return.  If turning ship when released it will turn in rotation direction of ship.  Also industuctable like Kohr-ah FIRED system. Limit 1
-
+Kahr Boomerang
+
+This ship has characteristics close to the Yehat Terminator.
+
+Weapon (3)
+Press Special to select (can be done at any time)
+
+Small boomerang : 1 damage that bounces of ships, short range. No limit.
+Medium boomerang : 3 damage, long range (otherwise same as small). limit 4.
+Large boomerang : 5 damage, controlable range, when you release fire will return.  If turning ship when released it will turn in rotation direction of ship.  Also industuctable like Kohr-ah FIRED system. Limit 1
+
 Enjoy
\ No newline at end of file

Modified: trunk/gamedata/ships/shporzne.txt
===================================================================
--- trunk/gamedata/ships/shporzne.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shporzne.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,3 +1,21 @@
-The nemesis is a medium size, medium speed, medium to high manuverable ship. It's primary weapon is a turreted cannon with medium power. The turret can be rotated to face any direction, which is not that useful a feature, but looks nice.  You do this by holding down special and pressing the turn buttons.  
+ General Overview
 
-The secondary ability of the Nemesis is to launch it's crew members in armoured EVA suits. These "space marines" travel under their own power through space to board enemy ships and kill their crew. Go! Go! Go! They can stay in space indefinitely, but return when the target is destroyed.  To launch marines, press both the special key and the fire key at the same time.  
+Always a worthy adversary. Underestimating the Nemesis would likely be the last mistake anyone can ever make. Like its name suggests, the Orz ship is a goddess of revenge, coming to inflict pain and vengeance on the galaxy. The Nemesis is fairly quick and has a fair turn-rate. Never, under any circumstances, chase after the nemesis!
+
+Main Weapon/Special system: Rotating Howitzer
+
+The Howitzer inflicts deadly damage and its shots are fast and medium-ranged. The rotational turret allows usage as a strafing weapon or as a backwards utilized attacker-repellent.
+
+
+Special Action: Marines (GoGos)
+
+Using their armored exo-skeleton, Orzine marines exit the ship from the aft portholes and enter an enemy ship by burning a hole in the hull. They then start roaming the enemy ship?s corridors, killing every crewman in sight. Especially useful in large groups, the marines can blast a ship entirely by themselves. Warlike creatures such as Ur-Quan, Chmmr, Yehat and Shofixti usually put up a better resistance than peaceful or cowardly creatures like the Spathi, Chenjesu and Mycon. The marine tactic of using a planet wrap-around slingshot maneuver to gain speed aids them against some ships.
+
+Tactical Overview
+
+A very effective ship that rarely fails.
+
+Strong against: Kzer-Za Dreadnought and to some degree Kohr-Ah Marauder are both in danger. The Chenjesu Broodhome is virtually helpless against the marines as is the VUX Intruder and the Mycon Podship. The marines cling on to the Yehat Terminator until the shield goes down and while they are repelled by the Utwig Jugger Shield, no fuel is gained and so they can be used to take down the Jugger?s shield. Showing the Chmmr Avatar your aft and blasting her with the howitzer is a tricky thing but the Nemesis can break through the tractor beam and as soon as the Zap-sats are down, the Avatar is marine-meat
+
+Weak against: The Pkunk Fury, Slylandro Probe and Arilou Skiff can effortlessly pull out of marine?s grasp and use hit-n-run attacks to whack the unready Nemesis. The Androsynth Guardian is a bit tricky ? if she get stuck without battery she?s Marine-meat but the Comet form destroys marines on impact and the Nemesis?s aft section appears to have been designed exactly to be wedged by a wicked blazer. So long as they manage to evade the marines, The X-form and the Spathi Eluder can pose a pain in the butt to any Nemesis captain. A very hot Shofixti Scout pilot can evade the marines long enough to use a wrap-around slingshot maneuver to catch the Nemesis unaware.
+

Modified: trunk/gamedata/ships/shprogsq.txt
===================================================================
--- trunk/gamedata/ships/shprogsq.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shprogsq.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,16 +1,16 @@
-
-Rogue Squadron
-
-background:
-
-A rogue squadron of former UQ crew, now lawless scavengers of the universe, a curious mixture of different races in a simple general ship design which is harmless on its own, but can be dangerous in large numbers.
-
-How to use this ship:
-
-main = pulse laser
-
-special = choose formations.
-
-In the ini file, you can edit formations. A formation is a list of x y points relative to the leader ship which you have to give a position (0,0), entered on a single line. The must be exactly as many x y pairs as there are crew members. I use an odd number of crew (11) to make the ships start in a symmetrical pattern around the leader.
-
-In melee, the player controls position (0,0) of the grid, which is indicated by a small arrow. Ships are distributed relative to the player position and angle.
+
+Rogue Squadron
+
+background:
+
+A rogue squadron of former UQ crew, now lawless scavengers of the universe, a curious mixture of different races in a simple general ship design which is harmless on its own, but can be dangerous in large numbers.
+
+How to use this ship:
+
+main = pulse laser
+
+special = choose formations.
+
+In the ini file, you can edit formations. A formation is a list of x y points relative to the leader ship which you have to give a position (0,0), entered on a single line. The must be exactly as many x y pairs as there are crew members. I use an odd number of crew (11) to make the ships start in a symmetrical pattern around the leader.
+
+In melee, the player controls position (0,0) of the grid, which is indicated by a small arrow. Ships are distributed relative to the player position and angle.

Modified: trunk/gamedata/ships/shpsupbl.txt
===================================================================
--- trunk/gamedata/ships/shpsupbl.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpsupbl.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,14 +1,19 @@
+ General review
 
-The Supox Blade is one of the original ships
-from Star Control 2.
+The Blade is a largely underrated ship. It's rapid fire capability can pound an unwary enemy and the lateral thrusting, when properly used, is nearly as good as the Arilou Hyperspace shunts in evading shots. The Blade is quick and agile with a fair turn-rate, allowing it to considerably hamper enemy targeting efforts. Its slender form makes it harder to hit her.
 
-The main weapon consists of a rapid-fire forward
-cannon.
+Main Weapon: Sprout Gun
 
-The special allows the ship to move almost instantly
-left, right, back, like a leaf in the wind.
+The rapid-fire Sprout Gun may cause small damage but it sure fires fast. Even when out of battery, the gun?s firing rate remains high and it's range, equaling the Ur-Quan Kzer-Za Dreadnought and the Syreen Penetrator can prove deadly.
 
-The Supox are the only sentient plant species known.
+Special System: Lateral Thrusting System
 
-The Supox formed peaceful allies of the Utwig, whom
-they helped in their time of distress.
+It takes a hell lot of practice to master the tricky Lateral Thrusting System but when correctly used, the Lateral Thrusting can be used to sidestep shots or strafe into a firing position. Especially effective against slow-firing ships such as the Dreadnought or Kohr-Ah Marauder.
+
+Tactical Overview
+
+The Blade is a fair adversary that shouldn't be taken lightly.
+
+Strong against: Syreen Penetrator, Kzer-Za Dreadnought, VUX Intruder, Ilwrath Avenger, Utwig Jugger.
+
+Weak against: Chenjesu Broodhome The crystalline shards put the Lateral-Sidestepping into a real problem. Arilou Skiff, Slylandro Probe and Pkunk Fury can convey quick hit-n-run attacks on the Blade. Chmmr Avatar. 

Modified: trunk/gamedata/ships/shpthrto.txt
===================================================================
--- trunk/gamedata/ships/shpthrto.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpthrto.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,4 +1,4 @@
-he Thraddash Torch is the pride and joy of Thraddash Culture Nineteen. It is very small, but its maneuverability and its powerful afterburners make it a serious contender even against large ships.
+The Thraddash Torch is the pride and joy of Thraddash Culture Nineteen. It is very small, but its maneuverability and its powerful afterburners make it a serious contender even against large ships.
 
 The Torch's main weapon is a medium-range blaster cannon. The blaster is pretty weak (although it can penetrate an Umgah Drone's anti-matter cone), so most Thraddash pilots use the Reeunk Afterburner as their main weapon. The afterburner accelerates the Torch to incredible speeds and leaves in its wake a fiery trail of ionized plasma that, while still hot, can cripple enemy ships in seconds should one be following too closely.
 

Modified: trunk/makefile
===================================================================
--- trunk/makefile	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/makefile	2004-09-26 08:30:59 UTC (rev 64)
@@ -74,7 +74,7 @@
         source/other source/ships source/sc1ships source/sc2ships \
         source/twgui source/util source/libraries/alogg \
         source/libraries/jpgalleg source/libraries/jgmod source/libraries/cppunit \
-        source/libraries/raknet
+        source/libraries/raknet source/libraries/lua source/libraries/lua/lib
 
 #FILELIST= ${shell find source -type f "(" -name "*.c" -o -name "*.cpp" ")"}
 FILELIST= ${shell cat sources.lst}
@@ -121,7 +121,8 @@
 	LIBS += ${shell allegro-config --libs} -pthread ${shell sdl-config --libs}
 endif
 
-CFLAGS += -I./source -I./source/libraries
+CFLAGS += -I./source -I./source/libraries -I./source/libraries/lua
+
 ifdef TEST
 CFLAGS += -DTEST ${shell cppunit-config --cflags }
 LIBS += ${shell cppunit-config --libs }

Modified: trunk/source/games/gflmelee.cpp
===================================================================
--- trunk/source/games/gflmelee.cpp	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/games/gflmelee.cpp	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,7 +1,7 @@
 /* $Id: gflmelee.cpp,v 1.1.1.1 2004/08/01 10:21:21 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Added: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/games/ggob.cpp	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,1000 @@
+/*
+This file is part of "TW-Light" 
+                    http://tw-light.berlios.de/
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#include <allegro.h>
+
+#include "melee.h"
+
+#include "scp.h"
+#include "frame.h"
+
+#include "melee/mgame.h"
+#include "melee/mmain.h"
+#include "melee/mview.h"
+#include "melee/mcontrol.h"
+#include "melee/mcbodies.h"
+#include "melee/mshppan.h"
+#include "melee/mship.h"
+#include "melee/mshot.h"
+#include "melee/mlog.h"
+#include "melee/manim.h"
+#include "melee/mfleet.h"
+
+#include "util/aastr.h"
+
+#include "ggob.h"
+#include "sc1ships.h"
+#include "sc2ships.h"
+
+#include "other/gup.h"
+#include "other/dialogs.h"
+#include "other/twconfig.h"
+
+#define gobgame ((GobGame*)game)
+
+////////////////////////////////////////////////////////////////////////
+//				Gob stuff
+////////////////////////////////////////////////////////////////////////
+
+int GobAsteroid::handle_damage (SpaceLocation *source, double normal, double direct) 
+{
+  STACKTRACE;
+  if (!exists()) 
+    return 0;
+  int i = Asteroid::handle_damage(source, normal, direct);
+  if (!exists()) 
+    {
+      GobPlayer *p = gobgame->get_player(source);
+      if (p) 
+	p->buckazoids += 1;
+    }
+  return i;
+}
+
+void GobAsteroid::death () 
+{
+  STACKTRACE;
+  Animation *a = new Animation(this, pos,
+			       explosion, 0, explosion->frames(), time_ratio, get_depth());
+  a->match_velocity(this);
+  game->add(a);
+
+  game->add ( new GobAsteroid() );
+  return;
+}
+
+void GobGame::preinit() 
+{
+  STACKTRACE;
+  Game::preinit();
+
+  gobplayers = 0;
+  gobplayer = NULL;
+  gobenemies = 0;
+  max_enemies = 0;
+  gobenemy = NULL;
+
+  int i;
+  for (i = 0; i < 3; i += 1)
+    stationSprite[i] = NULL;
+  for (i = 0; i < 3; i += 1)
+    station_pic_name[i] = NULL;
+  for (i = 0; i < 3; i += 1)
+    station_build_name[i] = NULL;
+  defenderSprite = NULL;
+}
+
+void GobGame::add_gobplayer(Control *control) 
+{
+  STACKTRACE;
+  int i = gobplayers;
+  gobplayers += 1;
+  gobplayer = (GobPlayer**) realloc(gobplayer, sizeof(GobPlayer*) * gobplayers);
+  gobplayer[i] = new GobPlayer();
+  gobplayer[i]->init(control, new_team());
+  add_focus(control, control->channel);
+  return;
+}
+
+void GobPlayer::died(SpaceLocation *killer) 
+{
+  STACKTRACE;
+  if (upgrade_list[UpgradeIndex::divinefavor]->num && (random()&1)) 
+    { //divine favor
+      ship->crew = ship->crew_max;
+      ship->batt = ship->batt_max;
+      ship->translate(random(Vector2(-2048,-2048), Vector2(2048,2048)));
+      ship->state = 1;
+    }
+  else 
+    ship = NULL;
+  return;
+}
+
+
+void GobGame::play_sound (SAMPLE *sample, SpaceLocation *source, int vol, int freq) 
+{
+  return;
+  /*
+	double v;
+	Vector2 d = source->normal_pos() - space_center;
+	d = normalize(d + size/2, size) - size/2;
+	v = 1000;
+	if (space_zoom > 0.01) v = 500 + space_view_size.x / space_zoom / 4;
+	v = 1 + magnitude_sqr(d) / (v*v);
+	Game::play_sound(sample, source, iround(vol/v), freq);
+  */
+}
+
+
+void GobGame::init(Log *_log) 
+{
+  STACKTRACE;
+  int i;
+  Game::init(_log);
+  
+  log_file("server.ini");
+  max_enemies = get_config_int("Gob", "MaxEnemies", 32);
+  gobenemy = (GobEnemy**) malloc(sizeof(GobEnemy*) * max_enemies);
+  
+  size = Vector2(24000, 24000);
+  
+  enemy_team = new_team();
+  
+  DATAFILE *tmpdata; 
+  tmpdata = load_datafile_object(data_full_path("gob.dat").c_str(), "station0sprite");
+  if (!tmpdata) 
+    tw_error( "couldn't find gob.dat#station0sprite");
+  stationSprite[0] = new SpaceSprite(tmpdata, 1, SpaceSprite::MASKED | SpaceSprite::MIPMAPED, 64);
+  unload_datafile_object(tmpdata);
+  stationSprite[0]->permanent_phase_shift(8);
+
+  tmpdata = load_datafile_object(data_full_path("gob.dat").c_str(), "station1sprite");
+  if (!tmpdata) 
+    tw_error ("couldn't find gob.dat#station1sprite");
+  stationSprite[1] = new SpaceSprite(tmpdata, 1, SpaceSprite::MASKED | SpaceSprite::MIPMAPED, 64);
+  unload_datafile_object(tmpdata);
+  stationSprite[1]->permanent_phase_shift(8);
+  
+  tmpdata = load_datafile_object(data_full_path("gob.dat").c_str(), "station2sprite");
+  if (!tmpdata) 
+    tw_error ("couldn't find gob.dat#station2sprite");
+  stationSprite[2] = new SpaceSprite(tmpdata, 1, SpaceSprite::MASKED | SpaceSprite::MIPMAPED, 64);
+  unload_datafile_object(tmpdata);
+  stationSprite[2]->permanent_phase_shift(8);
+  
+  tmpdata = load_datafile_object(data_full_path("gob.dat").c_str(), "defender");
+  if (!tmpdata) 
+    tw_error ("couldn't find gob.dat#defender");
+  defenderSprite = new SpaceSprite(tmpdata, 1, SpaceSprite::MASKED | SpaceSprite::MIPMAPED);
+  unload_datafile_object(tmpdata);
+  
+	
+  station_pic_name[0] = "gob.dat#station0picture.bmp";
+  station_pic_name[1] = "gob.dat#station1picture.bmp";
+  station_pic_name[2] = "gob.dat#station2picture.bmp";
+  station_build_name[0] = "supbl";
+  station_build_name[1] = "orzne";
+  station_build_name[2] = "kohma";
+  
+  prepare();
+
+  add(new Stars());
+	
+	num_planets = 0;
+	i = 0;
+	add_planet_and_station(meleedata.planetSprite, i, 
+			       stationSprite[i], station_build_name[i], station_pic_name[i]);
+	i = 1;
+	add_planet_and_station(meleedata.planetSprite, i, stationSprite[i], station_build_name[i], station_pic_name[i]);
+	i = 2;
+	add_planet_and_station(meleedata.planetSprite, i, stationSprite[i], station_build_name[i], station_pic_name[i]);
+	i = random() % 3;
+	add_planet_and_station(meleedata.planetSprite, i, stationSprite[i], "utwju", station_pic_name[i]);
+
+	for (i = 0; i < 19; i += 1) add(new GobAsteroid());
+
+
+
+	int server_players, client_players;
+	tw_set_config_file("client.ini");
+	server_players = client_players = get_config_int("Gob", "NumPlayers", 1);
+	if (!lag_frames) client_players = 0;
+	log_int(channel_server, server_players);
+	log_int(channel_client, client_players);
+	for (i = 0; i < server_players; i += 1) {
+		char buffy[256];
+		sprintf(buffy, "Config%d", i);
+		add_gobplayer(create_control(channel_server, "Human", buffy));
+		gobplayer[i]->new_ship(shiptype("supbl"));
+		Ship *s = gobplayer[i]->ship;
+		s->translate(size/2-s->normal_pos());
+		double angle = PI2 * i / (client_players + server_players);
+		s->translate(rotate(Vector2(260, 120), angle));
+		s->accelerate(s, PI2/3 + angle, 0.17, MAX_SPEED);
+	}
+	for (i = server_players; i < client_players + server_players; i += 1) {
+		char buffy[256];
+		sprintf(buffy, "Config%d", i - server_players);
+		add_gobplayer(create_control(channel_client, "Human", buffy));
+		gobplayer[i]->new_ship(shiptype("supbl"));
+		Ship *s = gobplayer[i]->ship;
+		s->translate(size/2-s->normal_pos());
+		double angle = PI2 * i / (client_players + server_players);
+		s->translate(rotate(Vector2(260, 120), angle));
+		s->accelerate(s, PI2/3 + angle, 0.17, MAX_SPEED);
+	}
+
+	for (i = 0; i < gobplayers; i += 1) add ( new RainbowRift() );
+
+	next_add_new_enemy_time = 1000;
+	add_new_enemy();
+	this->change_view("Hero");
+	view->window->locate(
+		0,0,
+		0,0,
+		0,0.9,
+		0,1
+		);
+	return;
+}
+GobGame::~GobGame() {
+  delete stationSprite[0];
+  delete stationSprite[1];
+  delete stationSprite[2];
+  delete defenderSprite;
+  int i;
+  for (i = 0; i < gobplayers; i += 1) 
+    {
+      delete gobplayer[i];
+    }
+  free(gobplayer);
+  for (i = 0; i < gobenemies; i += 1) 
+    {
+      delete gobenemy[i];
+    }
+  free(gobenemy);
+  return;
+}
+
+void GobGame::add_planet_and_station ( SpaceSprite *planet_sprite, 
+				       int planet_index, SpaceSprite *station_sprite, 
+				       const char *builds, const char *background) 
+{
+  Planet *p = new Planet (size/2, planet_sprite, planet_index);
+  if (num_planets) while (true) 
+    {
+      SpaceLocation *n;
+      n = p->nearest_planet();
+      if (!n || (p->distance(n) > 1500)) break;
+      p->translate(random(size));
+    }
+  add ( p );
+  
+  GobStation *gs = new GobStation(station_sprite, p, builds, background);
+  gs->collide_flag_sameship = ALL_LAYERS;
+  gs->collide_flag_sameteam = ALL_LAYERS;
+  gs->collide_flag_anyone = ALL_LAYERS;
+  add ( gs );
+  
+  gobgame->planet[gobgame->num_planets] = p;
+  gobgame->station[gobgame->num_planets] = gs;
+  gobgame->num_planets += 1;
+}
+
+void GobGame::fps() 
+{
+  STACKTRACE;
+  Game::fps();
+  
+  message.print((int)msecs_per_fps, 15, "enemies: %d", (int)gobenemies);
+  message.print((int)msecs_per_fps, 15, "time: %d", (int)(game_time / 1000));
+
+  int i = 0;
+  for (i = 0; i < gobplayers; i += 1) 
+    {
+      if (!is_local(gobplayer[i]->channel)) 
+	continue;
+      
+      if (gobplayer[i]->ship) {
+	message.print((int)msecs_per_fps, 15-i, "coordinates: %d x %d", 
+		      iround(gobplayer[i]->ship->normal_pos().x), 
+		      iround(gobplayer[i]->ship->normal_pos().y));
+      }
+      message.print((int)msecs_per_fps, 15-i, "starbucks: %d", gobplayer[i]->starbucks);
+      message.print((int)msecs_per_fps, 15-i, "buckazoids: %d", gobplayer[i]->buckazoids);
+      message.print((int)msecs_per_fps, 15-i, "kills: %d", gobplayer[i]->kills);
+    }
+  return;
+}
+
+void GobGame::calculate() 
+{
+  STACKTRACE;
+  
+
+  if (next_add_new_enemy_time <= game_time) {
+    next_add_new_enemy_time = game_time;
+    int t = 28;
+    if ((random() % t) < 4) add_new_enemy();
+    int e = gobenemies;
+    e -= random() % (1 + game_time / (250 * 1000));
+    if (0) ;
+    else if (e >=12) next_add_new_enemy_time += 15000;
+    else if (e >= 7) next_add_new_enemy_time += 7000;
+    else if (e >= 4) next_add_new_enemy_time += 5000;
+    else if (e >= 2) next_add_new_enemy_time += 3000;
+    else if (e >= 1) next_add_new_enemy_time += 2000;
+    else next_add_new_enemy_time += 1000;
+  }
+  Game::calculate();
+  return;
+}
+
+int GobGame::get_enemy_index(SpaceLocation *what) 
+{
+  STACKTRACE;
+  int i;
+  Ship *s = what->ship;
+  if (!s) return -1;
+  for (i = 0; i < gobenemies; i += 1) 
+    {
+      if (gobenemy[i]->ship == s) return i;
+    }
+  return -1;
+}
+
+void GobGame::ship_died(Ship *who, SpaceLocation *source) 
+{
+  STACKTRACE;
+  
+  GobPlayer *p = this->get_player(who);
+  if (p && (p->ship == who)) { //Player died
+    p->died(source);
+  }
+	int i = get_enemy_index(who);
+	if ((i != -1) && (gobenemy[i]->ship == who)) {
+		GobEnemy *e = gobenemy[i];
+		e->died(source);
+		gobenemies -= 1;
+		GobEnemy *tmp = gobenemy[gobenemies];
+		gobenemy[i] = tmp;
+		p = get_player(source);
+	}
+
+	Game::ship_died(who, source);
+	return;
+}
+GobPlayer *GobGame::get_player(SpaceLocation *what) {
+  STACKTRACE;
+	int i;
+	for (i = 0; i < gobplayers; i += 1) {		
+		if (what->get_team() == gobplayer[i]->team) return gobplayer[i];
+	}
+	return NULL;
+}
+void GobGame::add_new_enemy() 
+{
+  STACKTRACE;
+  
+  static char *enemy_types[] = {
+		"thrto", "zfpst", "shosc", "dragr", 
+		"kahbo", "ilwsp", 
+		"syrpe", "kzedr", "mmrxf", 
+		"druma", "earcr", 
+		"yehte", "chmav" 
+		};
+  const int num_enemy_types = sizeof(enemy_types)/sizeof(enemy_types[0]);
+  if (gobenemies == max_enemies) 
+    return;
+  GobEnemy *ge = new GobEnemy();
+
+  int base = game_time / 30 / 1000;
+  if (gobenemies >= 4) 
+    base += (gobenemies*gobenemies - 10) / 5;
+  
+  gobenemy[gobenemies] = ge;
+  gobenemies += 1;
+  base = iround(base / 1.5);
+  int e = 99999;
+  while (e >= num_enemy_types) {
+/*
+base	time	low		high
+
+  1		.5		-0.1	3.7
+  10	5		2.62	7.47
+  50	25		5.89	14.24
+ 100	50		8.1		17.3
+ 200	100		11.01	26.49
+
+
+
+*/
+    e = base;
+    e = random() % (e + 2);
+    e = random() % (e + 3);
+    if (e < pow(2.5*base,0.4) - 1) 
+      e = random() % num_enemy_types;
+    if (e > sqrt(3*base) + 2) 
+      e = random() % (e + 1);
+    //if (e > num_enemy_types * 2) e = e % num_enemy_types;
+    e = e;
+  }
+  Ship *ship = create_ship(channel_server, enemy_types[e], "WussieBot", random(size), random(PI2), enemy_team);
+  if (!strcmp(enemy_types[e], "shosc")) ((ShofixtiScout*)ship)->specialDamage /= 4;
+  if (!strcmp(enemy_types[e], "zfpst")) ((ZoqFotPikStinger*)ship)->specialDamage /= 2;
+  if (!strcmp(enemy_types[e], "syrpe")) ((SyreenPenetrator*)ship)->specialDamage /= 2;
+  if (!strcmp(enemy_types[e], "dragr")) ship->special_drain *= 2;
+  if (!strcmp(enemy_types[e], "chmav")) {
+    ((ChmmrAvatar*)ship)->weaponDamage += 1;
+    ((ChmmrAvatar*)ship)->weaponDamage /= 2;
+    ((ChmmrAvatar*)ship)->specialForce *= 2;
+    ((ChmmrAvatar*)ship)->specialRange *= 2;
+  }
+  int sb, bz;
+  sb = 1 + e / 4;
+  if (sb > 2) sb -= 1;
+  bz = (e - 9) / 2;
+  if (bz > 1) bz -= 1;
+  if (sb < 0) sb = 0;
+	if (bz < 0) bz = 0;
+	ge->init(ship, sb, bz);
+	add(ship->get_ship_phaser());
+	//add(ship);
+	return;
+}
+
+void GobEnemy::init(Ship *ship, int kill_starbucks, int kill_buckazoids) {
+  STACKTRACE;
+	this->ship = ship;
+	this->starbucks = kill_starbucks;
+	this->buckazoids = kill_buckazoids;
+	return;
+	}
+void GobEnemy::died(SpaceLocation *what) {
+  STACKTRACE;
+	GobPlayer *p = gobgame->get_player(what);
+	if (p) {
+		p->starbucks += starbucks;
+		p->buckazoids += buckazoids;
+		p->kills += 1;
+	}
+	return;
+}
+
+
+GobPlayer::~GobPlayer() {
+	free (pair_list);
+}
+void GobPlayer::init(Control *c, TeamCode team) {
+  STACKTRACE;
+  channel = c->channel;
+  starbucks = 0;
+  buckazoids = 0;
+  kills = 0;
+  value_starbucks = 0;
+  value_buckazoids = 0;
+  num_pairs = 0;
+  pair_list = NULL;
+  ship = NULL;
+  panel = NULL;
+  control = c;
+  total = 0;
+  this->team = team;
+  int i, j;
+  for (i = 0; ::upgrade_list[i]; i += 1) ::upgrade_list[i]->index = i;
+  upgrade_list = new Upgrade*[i+1];
+  upgrade_list[i] = NULL;
+  for (j = 0; j < i; j += 1) {
+    upgrade_list[j] = ::upgrade_list[j]->duplicate();
+    upgrade_list[j]->clear(NULL, NULL, this);
+  }
+  return;
+}
+GobPlayer::pair *GobPlayer::_get_pair(const char *id) {
+  STACKTRACE;
+  if (!pair_list) return NULL;
+  int i;
+  for (i = 0; i < num_pairs; i += 1) {
+    if (!strcmp(pair_list[i].id, id)) 
+			return &pair_list[i];
+  }
+  return NULL;
+}
+void GobPlayer::_add_pair(const char *id, int value) {
+  STACKTRACE;
+  if (_get_pair(id)) 
+    {
+      tw_error("GobPlayer::_add_pair - \"%s\" already exists", id);
+      return;
+    }
+  pair_list = (pair*)realloc(pair_list, sizeof(pair) * (num_pairs+1));
+  pair_list[num_pairs].id = strdup(id);
+  pair_list[num_pairs].value = value;
+  num_pairs += 1;
+  return;
+}
+
+int GobPlayer::read_pair(const char *id) {
+  STACKTRACE;
+  pair *p = _get_pair(id);
+  if (p) return p->value;
+  return -1;
+}
+
+void GobPlayer::write_pair(const char *id, int value) {
+  STACKTRACE;
+  pair *p = _get_pair(id);
+  if (p) p->value = value;
+  else _add_pair(id, value);
+  return;
+}
+int GobPlayer::charge (char *name, int price_starbucks, int price_buckazoids) {
+  char buffy1[512];
+  sprintf(buffy1, "Price: %d starbucks plus %d buckazoids", price_starbucks, price_buckazoids);
+  if ((starbucks < price_starbucks) || (buckazoids < price_buckazoids)) {
+    if (game->is_local(channel)) 
+      alert("You don't have enough.", name, buffy1, "Cancel", NULL, 0, 0);
+    return 0;
+  }
+  int r = 0;
+  if (game->is_local(channel)) 
+    r = alert ("Do you wish to make this purchase?", name, buffy1, "&No", "&Yes", 'n', 'y');
+  game->log_int(channel, r);
+  if (r == 2) {
+    starbucks -= price_starbucks;
+    buckazoids -= price_buckazoids;
+    return 1;
+  }
+  return 0;
+}
+void GobPlayer::new_ship(ShipType *type) {
+  STACKTRACE;
+  Ship *old = ship;
+  Vector2 pos = 0;
+  double a = 0;
+  int i;
+  if (old) {
+    pos = old->normal_pos();
+    a = old->get_angle();
+  }
+  
+  ship = game->create_ship ( type->id, control, pos, a, team);
+  
+  
+  if (panel) panel->die();
+	panel = NULL;
+	panel = new ShipPanel(ship);
+	panel->always_redraw = true;
+	panel->window->init(game->window);
+	if (game->is_local(control->channel)) {
+		panel->window->locate(
+			0,0.9,
+			0,0,
+			0,0.1,
+			0,0.25
+		);
+	}
+	else {
+		panel->window->locate(
+			0,0.9,
+			0,0.25,
+			0,0.1,
+			0,0.25
+		);
+	}
+	panel->set_depth(10);
+	game->add(panel);
+
+	for (i = 0; upgrade_list[i]; i += 1) {
+		upgrade_list[i]->clear(old, ship, this);
+		}
+	if (old) {
+		old->die();
+		game->add(ship);
+		}
+	else game->add(ship->get_ship_phaser());
+	return;
+	}
+
+void GobStation::buy_new_ship_menu(GobPlayer *s) {
+  STACKTRACE;
+
+  char buffy1[512], buffy2[512];
+  ShipType *otype = s->ship->type;
+  ShipType *ntype = shiptype(build_type);
+  if (otype == ntype) {
+    sprintf (buffy1, "You already have a %s", ntype->name);
+    if (game->is_local(s->channel)) 
+      alert(buffy1, NULL, NULL, "&Cancel", NULL, 'c', 0);
+    return;
+  }
+  int ossb = (s->value_starbucks*3) / 4 + (s->ship->type->cost*1)/1;
+  int osbz = (s->value_buckazoids*3) / 4 + (s->ship->type->cost*1)/1;
+  int nssb = ntype->cost;
+  int nsbz = ntype->cost;
+  sprintf (buffy1, "You have a %s worth %d s$ / %d b$", otype->name, ossb, osbz);
+  sprintf (buffy2, "A %s costs %d s$ / %d b$", ntype->name, nssb, nsbz);
+  if ((nssb <= (ossb + s->starbucks)) && (nsbz <= (osbz + s->buckazoids))) {
+    int i = 0;
+    if (game->is_local(s->channel))
+      i = alert(buffy1, buffy2, "Do you wish to buy it?", "Yeah!", "No", 'y', 'n');
+    game->log_int(s->channel, i);
+    if (i == 1) {
+      s->starbucks -= nssb - ossb;
+      s->buckazoids -= nsbz - osbz;
+      s->new_ship(ntype);
+    }
+  }
+  else {
+    if (game->is_local(s->channel)) 
+      alert (buffy1, buffy2, "You don't have enough to buy it", "Cancel", NULL, 0, 0);
+  }
+  return;
+}
+
+GobStation::GobStation ( SpaceSprite *pic, SpaceLocation *orbit_me, const char *ship, const char *background) : 
+  Orbiter(pic, orbit_me, random() % 200 + 500) 
+{
+  build_type = ship;
+  background_pic = background;
+  layer = LAYER_CBODIES;
+  mass = 99;
+}
+
+#define STATION_DIALOG_DEPART  0
+#define STATION_DIALOG_UPGRADE 1
+#define STATION_DIALOG_NEWSHIP 2
+#define STATION_DIALOG_REPAIR  3
+static DIALOG station_dialog[] =
+{// (dialog proc)     (x)   (y)   (w)   (h)   (fg)  (bg)  (key) (flags)     (d1)  (d2)  (dp)
+  { d_agup_button_proc,     385,  50,   150,  30,   255,  0,    0,    D_EXIT,     0,    0,    (void *)"Depart Station" , NULL, NULL },
+  { d_agup_button_proc,     385,  90,   150,  30,   255,  0,    0,    D_EXIT,     0,    0,    (void *)"Upgrade Ship" , NULL, NULL },
+  { d_agup_button_proc,     385,  130,  150,  30,   255,  0,    0,    D_EXIT,     0,    0,    (void *)"Buy New Ship" , NULL, NULL },
+  { d_agup_button_proc,     385,  170,  150,  30,   255,  0,    0,    D_EXIT,     0,    0,    (void *)"Repair Ship" , NULL, NULL },
+  { d_agup_text_proc,       185,  420,  270,  30,   255,  0,    0,    0,          0,    0,    dialog_string[0], NULL, NULL },
+  { d_tw_yield_proc,        0,    0,    0,    0,  255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },
+  { NULL,              0,    0,    0,    0,    255,  0,    0,    0,          0,    0,    NULL, NULL, NULL }
+};
+void GobStation::station_screen(GobPlayer *s) 
+{
+  STACKTRACE;
+  BITMAP *background = load_bitmap(data_full_path(background_pic).c_str(), NULL);
+  if (!background) {
+    message.print(1000, 15, "%s", background_pic);
+    tw_error ("couldn't load station background");
+  }
+  game->window->lock();
+  aa_set_mode(AA_DITHER);
+  aa_stretch_blit(background, game->window->surface, 
+		  0,0,background->w,background->h, 
+		  game->window->x,game->window->y,game->window->w, game->window->h);
+  game->window->unlock();
+  while (true) {
+    sprintf(dialog_string[0], "%03d Starbucks  %03d Buckazoids", s->starbucks, s->buckazoids);
+    int r = 0;
+    if (game->is_local(s->channel)) 
+      r = tw_do_dialog(game->window, station_dialog, STATION_DIALOG_DEPART);
+		game->log_int(s->channel, r);
+		switch (r) {
+		case STATION_DIALOG_UPGRADE: {
+		  upgrade_menu(this, s);
+				aa_set_mode(AA_DITHER);
+				aa_stretch_blit(background, game->window->surface, 
+						0,0,background->w,background->h, 
+						game->window->x,game->window->y,
+						game->window->w, game->window->h);
+		}
+		  break;
+		case STATION_DIALOG_NEWSHIP: {
+		  buy_new_ship_menu(s);
+		}
+			break;
+		case STATION_DIALOG_REPAIR: {
+		  if (s->ship->crew == s->ship->crew_max) {
+		    if (game->is_local(s->channel)) 
+		      alert("You don't need repairs", "", "", "Oh, okay", "I knew that", 0, 0);
+		    
+		    break;
+		  }
+		  int p = 0;
+		  if (game->is_local(s->channel)) 
+		    p = alert3("Which would you prefer", "to pay for your repairs", "", "1 &Starbuck", "1 &Buckazoid", "&Nothing!", 's', 'b', 'n');
+		  game->log_int(s->channel, p);
+		  switch (p) {
+		  case 1: {
+		    if (s->starbucks) {
+		      s->starbucks -= 1;
+		      s->ship->crew = s->ship->crew_max;
+		    }
+		    else {
+		      if (game->is_local(s->channel)) 
+			alert("You don't have enough!", NULL, NULL, "&Shit", NULL, 's', 0);
+		    }
+						}
+		    break;
+		  case 2: {
+		    if (s->buckazoids) {
+		      s->buckazoids -= 1;
+		      s->ship->crew = s->ship->crew_max;
+		    }
+		    else {
+							if (game->is_local(s->channel)) 
+							  alert("You don't have enough!", NULL, NULL, "&Shit", NULL, 's', 0);
+		    }
+		  }
+		    break;
+		  case 3: {
+		    r = STATION_DIALOG_DEPART;
+		  }
+					break;
+		  }
+		}
+		  break;
+			}
+		if (r == STATION_DIALOG_DEPART) break;
+  }
+  return;
+}
+void GobStation::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
+	SpaceObject::inflict_damage(other);
+	if (!other->isShip()) return;
+	GobPlayer *p = gobgame->get_player(other);
+	if (!p) return;
+	gobgame->pause();
+	char buffy[256];
+	int a;
+	sprintf(buffy, "First visited station %s at time", build_type);
+	a = p->read_pair(buffy);
+	if (a == -1) p->write_pair(buffy, game->game_time);
+	sprintf(buffy, "Visited station %s N times", build_type);
+	a = p->read_pair(buffy);
+	if (a == -1) a = 0;
+	p->write_pair(buffy, a+1);
+	station_screen(p);
+	gobgame->unpause();
+	return;
+	}
+
+
+
+int num_upgrade_indexes;
+int upgrade_index[999];
+GobPlayer *upgrade_list_for;
+char *upgradeListboxGetter(int index, int *list_size) {
+	static char tmp[150];
+	if(index < 0) {
+		*list_size = num_upgrade_indexes;
+		return NULL;
+		}
+	int i = upgrade_index[index];
+	sprintf(tmp, "%1d %3d s$ / %3d b$  :  %s", upgrade_list_for->upgrade_list[i]->num, upgrade_list_for->upgrade_list[i]->starbucks, upgrade_list_for->upgrade_list[i]->buckazoids, upgrade_list_for->upgrade_list[i]->name);
+	return tmp;
+	}
+#define UPGRADE_DIALOG_EXIT 0
+#define UPGRADE_DIALOG_LIST 3
+static DIALOG upgrade_dialog[] =
+{// (dialog proc)     (x)   (y)   (w)   (h)   (fg)  (bg)  (key) (flags)     (d1)  (d2)  (dp)
+  { d_agup_button_proc,     10,  415,  170,  30,   255,  0,    0,    D_EXIT,     0,    0,    (void *)"Station menu" , NULL, NULL },
+  { d_agup_textbox_proc,    20,  40,   250,  40,   255,  0,    0,    D_EXIT,     0,    0,    (void *)"Upgrade Menu", NULL, NULL },
+  { d_agup_text_proc,       10,  100,  540,  20,   255,  0,    0,    D_EXIT,     0,    0,    (void *)" # Starbucks Buckazoids Description                     ", NULL, NULL },
+  { d_agup_list_proc,       10,  120,  540,  280,  255,  0,    0,    D_EXIT,     0,    0,    (void *) upgradeListboxGetter, NULL, NULL },
+  { d_agup_text_proc,       185, 420,  270,  30,   255,  0,    0,    0,          0,    0,    dialog_string[0], NULL, NULL },
+  { d_tw_yield_proc,        0,    0,    0,    0,  255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },
+  { NULL,              0,    0,    0,    0,   255,  0,    0,    0,          0,    0,    NULL, NULL, NULL }
+};
+
+void GobStation::upgrade_menu(GobStation *station, GobPlayer *gs) {
+  STACKTRACE;
+  int i;
+  upgrade_list_for = gs;
+  clear_to_color(screen, palette_color[8]);
+  while (true) {
+    sprintf(dialog_string[0], "%03d Starbucks  %03d Buckazoids", gs->starbucks, gs->buckazoids);
+    int j = 0;
+    for (i = 0; gs->upgrade_list[i]; i += 1) {
+      if (gs->upgrade_list[i]->update(gs->ship, station, gs)) {
+	upgrade_index[j] = i;
+	j += 1;
+      }
+    }
+    num_upgrade_indexes = j;
+    int m = 0;
+    if (game->is_local(gs->channel))
+      m = tw_do_dialog(game->window, upgrade_dialog, UPGRADE_DIALOG_EXIT);
+    game->log_int(gs->channel, m);
+		if (m == UPGRADE_DIALOG_EXIT) return;
+		if (m == UPGRADE_DIALOG_LIST) {
+			int i = 0;
+			if (game->is_local(gs->channel))
+				i = upgrade_dialog[UPGRADE_DIALOG_LIST].d1;
+			game->log_int(gs->channel, i);
+			i = upgrade_index[i];
+			Upgrade *u = gs->upgrade_list[i];
+			if (gs->charge(u->name, u->starbucks, u->buckazoids)) {
+				u->execute(gs->ship, station, gs);
+				u->charge(gs);
+				}
+			}
+		}
+	return;
+	}
+
+GobDefender::GobDefender ( Ship *ship) 
+: SpaceObject (ship, ship->normal_pos(), 0, gobgame->defenderSprite)
+{
+	base_phase = 0;
+	next_shoot_time = 0;
+	collide_flag_anyone = 0;
+}
+void GobDefender::calculate() {
+  STACKTRACE;
+	SpaceObject::calculate();
+	if (!ship) {
+		die();
+		return;
+	}
+	if (next_shoot_time < gobgame->game_time) {
+		SpaceObject *target = NULL;
+		Query q;
+		q.begin(this, OBJECT_LAYERS &~ bit(LAYER_SHIPS), 300);
+		while (q.currento && !target) {
+			if (!q.currento->sameTeam(ship)) {
+				SpaceLine *l = new PointLaser ( 
+					this, palette_color[4], 2, 150, 
+					this, q.currento
+					);
+				add(l);
+				if (l->exists()) target = q.currento;
+			}
+			q.next();
+		}
+		if (target) {
+			next_shoot_time = gobgame->game_time + 400;
+		}
+	}
+	double a = base_phase + (gobgame->game_time % 120000) * ( PI2 / 1000.0) / 6;
+	angle = normalize(a,PI2);
+	pos = normalize(ship->normal_pos() + 270 * unit_vector ( angle ));
+	return;
+}
+
+RainbowRift::RainbowRift () 
+//: SpaceLocation ( NULL, 12800, 12800, 0) 
+: SpaceLocation ( NULL, random(map_size), 0) 
+{
+	int i;
+	collide_flag_sameship = 0;
+	collide_flag_sameteam = 0;
+	collide_flag_anyone = 0;
+	for (i = n*6-6; i < n*6+2; i += 1) {
+		p[i] = 75 + random(150.0);
+	}
+	for (i = 0; i < n; i += 1) {
+		squiggle();
+	}
+	next_time = game->game_time;
+	next_time2 = game->game_time;
+}
+void RainbowRift::animate( Frame *frame ) {
+  STACKTRACE;
+	Vector2 s;
+	s = corner(pos, Vector2(300,300));
+	if ((s.x < -500) || (s.x > space_view_size.x + 500) || 
+		(s.y < -500) || (s.y > space_view_size.y + 500))
+		return;
+	int b[n*6+2];
+	int i;
+	for (i = 0; i < n*6+2; i += 2) { 
+		b[i] = iround(s.x + p[i] * space_zoom);
+		b[i+1] = iround(s.y + p[i+1] * space_zoom);
+	}
+	for (i = 0; i < n; i += 1) {
+		RGB tc = c[n-i-1];
+		int a = tw_color(tc.r, tc.g, tc.b);
+		spline ( frame->surface, &b[i*6], a );
+	}
+	frame->add_box ( 
+		iround(s.x - 2), iround(s.y -2), 
+		iround(300 * space_zoom+5), iround(300 * space_zoom+5)
+		);
+	return;
+}
+void RainbowRift::squiggle() {
+  STACKTRACE;
+	int i;
+	int m = n*6+2;
+	for (i = 0; i < m - 6; i += 1) {
+		p[i] = p[i+6];
+	}
+	p[m-6] = p[m-8] * 2 - p[m-10];
+	p[m-5] = p[m-7] * 2 - p[m-9];
+	p[m-4] = 75 + random(150.0);
+	p[m-3] = 75 + random(150.0);
+	p[m-2] = 75 + random(150.0);
+	p[m-1] = 75 + random(150.0);
+	for (i = 0; i < n-1; i += 1) {
+		c[i] = c[i+1];
+	}
+	int r, g, b;
+	r = int(game->game_time * 0.5) % 360;
+	hsv_to_rgb( r, 1.0, 1.0, &r, &g, &b );
+	c[n-1].r = r;
+	c[n-1].g = g;
+	c[n-1].b = b;
+	return;
+}
+void RainbowRift::calculate() {
+  STACKTRACE;
+	while (game->game_time > next_time) {
+		next_time += 25;
+		squiggle();
+	}
+	while (game->game_time > next_time2) {
+		next_time2 += random() % 10000;
+		Query q;
+		for (q.begin(this, bit(LAYER_SHIPS), 40); q.current; q.next()) {
+			GobPlayer *p = gobgame->get_player(q.currento);
+			if (q.currento == p->ship) {
+				int i = 0;
+				i = p->control->choose_ship(game->window, "You found the Rainbow Rift!", reference_fleet);
+				game->log_int(p->channel, i);
+				if (i == -1) 
+				  i = random(reference_fleet->getSize());
+				game->redraw();
+				if (reference_fleet->getShipType(i) == p->ship->type) {
+					p->starbucks += random() % 80;
+					p->buckazoids += random() % 80;
+					game->add(new RainbowRift());
+				}
+				else {
+					p->starbucks += random() % (1+p->value_starbucks);
+					p->buckazoids += random() % (1+p->value_buckazoids);
+					p->new_ship(reference_fleet->getShipType(i));
+				}
+				die();
+			}
+		}
+	}
+	return;
+}
+
+
+REGISTER_GAME(GobGame, "GOB")
+
+
+
+/* intended upgrades:
+
+faster marines       == faster Orz Marines, cost 4s
+upgrade battle armor == tougher Orz Marines, cost 4s/4b
+improve range        == long range Orz cannons, cost 3s
+regeneration         == crew regeneration for Orz, cost 10s/25b, only purchasable once
+sharper shurikens    == +1 damage for Kohr-Ah blades, cost 5s
+faster shurikens     == higher velocity for Kohr-Ah blades, cost 4s
+larger corona        == longer range for Kohr-Ah FRIED, cost 15s, only purchasable once
+hotter corona        == double damage for Kohr-Ah FRIED, cost 10s, only purchasable once
+divine favor         == pkunk respawn, only available from one base, cost 48s/0b, only purchasable once, kept when ship is sold
+sentinel system      == Chmmr ZapSats, only available from one base, cost 30s/30b
+
+long range scanners  == can zoom farther out, gives radar, only available from one base, cost 8s/20b
+
+*/

Added: trunk/source/games/ggob.h
===================================================================
--- trunk/source/games/ggob.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/games/ggob.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,171 @@
+/*
+This file is part of "TW-Light" 
+                    http://tw-light.berlios.de/
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#ifndef TW_GOB_H_INCLUDES
+#define TW_GOB_H_INCLUDES
+
+#include "melee.h"
+#include "melee/mframe.h"
+#include "melee/mgame.h"
+#include "melee/mitems.h"
+
+class Upgrade;
+class GobStation;
+
+/// Player possession (ship, money, upgrades)
+class GobPlayer 
+{
+ public:
+  int channel;
+  ~GobPlayer();
+  Ship *ship;
+  Control *control;
+  ShipPanel *panel;
+  struct pair 
+  {
+    char *id;
+    int value;
+  };
+  pair *pair_list;
+  int num_pairs;
+  void _add_pair(const char *id, int value);
+  pair *_get_pair(const char *id);
+  void write_pair(const char *id, int value);
+  int read_pair(const char *id);
+  int total;         ///<total upgrades purchased, used in calculating price of future upgrades
+  int starbucks;
+  int buckazoids;
+  int kills;
+  int value_starbucks;
+  int value_buckazoids;
+  TeamCode team;
+  void init(Control *c, TeamCode team);
+  void died(SpaceLocation *killer);
+  void new_ship(ShipType *type);
+  int charge (char *name, int price_starbucks, int price_buckazoids) ;
+  Upgrade **upgrade_list;
+} ;
+
+/// Enemy starship, reward for it
+class GobEnemy 
+{
+ public:
+  Ship *ship;
+  int starbucks;
+  int buckazoids;
+  void init(Ship *ship, int kill_starbucks, int kill_buckazoids);
+  void died (SpaceLocation *what);
+} ;
+
+/// Asteroid that add money to it's killer
+class GobAsteroid : public Asteroid 
+{
+ public:
+  virtual int handle_damage (SpaceLocation *source, double normal, double direct);
+  virtual void death();
+};
+
+/// Full future adventure game
+class GobGame : public Game 
+{
+ public:
+  virtual ~GobGame();
+
+  TeamCode enemy_team;
+
+  virtual void calculate();
+  virtual void ship_died(Ship *who, SpaceLocation *source);
+  virtual void preinit();
+  virtual void init (Log *log);
+
+  virtual void play_sound (SAMPLE *sample, SpaceLocation *source, int vol = 256, int freq = 1000);
+	
+  int gobplayers;
+  GobPlayer **gobplayer;
+  virtual void add_gobplayer(Control *control);
+  virtual GobPlayer *get_player(SpaceLocation *what);
+  int gobenemies, max_enemies;
+  GobEnemy **gobenemy;
+  virtual int get_enemy_index(SpaceLocation *what);
+  
+  //	protected:
+  virtual void fps ();
+  
+  void add_new_enemy();
+  
+  int next_add_new_enemy_time;
+  
+  SpaceSprite *stationSprite[3];
+  char *station_pic_name[3];
+  char *station_build_name[3];
+  SpaceSprite *defenderSprite;
+  
+ public:
+  int num_planets;
+  Planet *planet[16];
+  GobStation *station[16];
+  void add_planet_and_station ( SpaceSprite *planet_sprite, int planet_index, SpaceSprite *station_sprite, const char *builds, const char *background);
+};
+
+/// Station where player can buy upgrades and repair his ship
+class GobStation : public Orbiter {
+ public:
+  const char *build_type;
+  const char *background_pic;
+  GobStation ( SpaceSprite *pic, SpaceLocation *orbit_me, const char *ship, const char *background);
+  virtual void buy_new_ship_menu(GobPlayer *s) ;
+  virtual void inflict_damage(SpaceObject *other);
+  virtual void station_screen (GobPlayer *s);
+  virtual void upgrade_menu(GobStation *station, GobPlayer *gs) ;
+};
+
+/// Custom upgrade to ship
+class Upgrade 
+{
+ public:
+  enum {
+    active, inactive
+  };
+  char *name;
+  int starbucks;
+  int buckazoids;
+  int status;
+  int num;
+  int index;
+  virtual bool update(Ship *ship, GobStation *station, GobPlayer *gp) = 0;
+  //true if listed
+  virtual void execute(Ship *ship, GobStation *station, GobPlayer *gp) = 0;
+  virtual void charge(GobPlayer *gp);
+  virtual void clear(Ship *oship, Ship *nship, GobPlayer *gp);
+  virtual Upgrade *duplicate() = 0;
+};
+
+/// Strange space location
+class RainbowRift : public SpaceLocation 
+{
+ public:
+  enum { n = 2 };
+  float p[n * 6 + 2];
+  RGB c[n];
+  int next_time, next_time2;
+  RainbowRift ();
+  virtual void animate ( Frame *frame );
+  virtual void calculate () ;
+  void squiggle();
+};
+
+#endif // TW_GOB_H_INCLUDES
+

Added: trunk/source/libraries/lua/Makefile
===================================================================
--- trunk/source/libraries/lua/Makefile	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/Makefile	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,85 @@
+# makefile for Lua core library
+
+LUA= ..
+
+include $(LUA)/config
+
+OBJS=	\
+	lapi.o \
+	lcode.o \
+	ldebug.o \
+	ldo.o \
+	ldump.o \
+	lfunc.o \
+	lgc.o \
+	llex.o \
+	lmem.o \
+	lobject.o \
+	lopcodes.o \
+	lparser.o \
+	lstate.o \
+	lstring.o \
+	ltable.o \
+	ltests.o \
+	ltm.o \
+	lundump.o \
+	lvm.o \
+	lzio.o
+
+SRCS=	\
+	lapi.c \
+	lcode.c \
+	ldebug.c \
+	ldo.c \
+	ldump.c \
+	lfunc.c \
+	lgc.c \
+	llex.c \
+	lmem.c \
+	lobject.c \
+	lopcodes.c \
+	lparser.c \
+	lstate.c \
+	lstring.c \
+	ltable.c \
+	ltests.c \
+	ltm.c \
+	lundump.c \
+	lvm.c \
+	lzio.c \
+	lapi.h \
+	lcode.h \
+	ldebug.h \
+	ldo.h \
+	lfunc.h \
+	lgc.h \
+	llex.h \
+	llimits.h \
+	lmem.h \
+	lobject.h \
+	lopcodes.h \
+	lparser.h \
+	lstate.h \
+	lstring.h \
+	ltable.h \
+	ltm.h \
+	lundump.h \
+	lvm.h \
+	lzio.h
+
+T= $(LIB)/liblua.a
+
+all:	$T
+
+$T:	$(OBJS)
+	$(AR) $@ $(OBJS)
+	$(RANLIB) $@
+
+clean:
+	rm -f $(OBJS) $T
+
+co:
+	co -q -f -M $(SRCS)
+
+klean:	clean
+	rm -f $(SRCS)

Added: trunk/source/libraries/lua/README
===================================================================
--- trunk/source/libraries/lua/README	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/README	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,5 @@
+This is the Lua core.
+
+The standard Lua library are in lib/.
+A sample interpreter is in lua/.
+A standalone compiler is in luac/.

Added: trunk/source/libraries/lua/lapi.c
===================================================================
--- trunk/source/libraries/lua/lapi.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lapi.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,922 @@
+/*
+** $Id: lapi.c,v 1.235 2003/04/07 14:36:08 roberto Exp $
+** Lua API
+** See Copyright Notice in lua.h
+*/
+
+
+#include <assert.h>
+#include <string.h>
+
+#define lapi_c
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lundump.h"
+#include "lvm.h"
+
+
+const char lua_ident[] =
+  "$Lua: " LUA_VERSION " " LUA_COPYRIGHT " $\n"
+  "$Authors: " LUA_AUTHORS " $\n"
+  "$URL: www.lua.org $\n";
+
+
+
+#ifndef api_check
+#define api_check(L, o)		/*{ assert(o); }*/
+#endif
+
+#define api_checknelems(L, n)	api_check(L, (n) <= (L->top - L->base))
+
+#define api_incr_top(L)   {api_check(L, L->top < L->ci->top); L->top++;}
+
+
+
+
+static TObject *negindex (lua_State *L, int idx) {
+  if (idx > LUA_REGISTRYINDEX) {
+    api_check(L, idx != 0 && -idx <= L->top - L->base);
+    return L->top+idx;
+  }
+  else switch (idx) {  /* pseudo-indices */
+    case LUA_REGISTRYINDEX: return registry(L);
+    case LUA_GLOBALSINDEX: return gt(L);
+    default: {
+      TObject *func = (L->base - 1);
+      idx = LUA_GLOBALSINDEX - idx;
+      lua_assert(iscfunction(func));
+      return (idx <= clvalue(func)->c.nupvalues)
+                ? &clvalue(func)->c.upvalue[idx-1]
+                : NULL;
+    }
+  }
+}
+
+
+static TObject *luaA_index (lua_State *L, int idx) {
+  if (idx > 0) {
+    api_check(L, idx <= L->top - L->base);
+    return L->base + idx - 1;
+  }
+  else {
+    TObject *o = negindex(L, idx);
+    api_check(L, o != NULL);
+    return o;
+  }
+}
+
+
+static TObject *luaA_indexAcceptable (lua_State *L, int idx) {
+  if (idx > 0) {
+    TObject *o = L->base+(idx-1);
+    api_check(L, idx <= L->stack_last - L->base);
+    if (o >= L->top) return NULL;
+    else return o;
+  }
+  else
+    return negindex(L, idx);
+}
+
+
+void luaA_pushobject (lua_State *L, const TObject *o) {
+  setobj2s(L->top, o);
+  incr_top(L);
+}
+
+
+LUA_API int lua_checkstack (lua_State *L, int size) {
+  int res;
+  lua_lock(L);
+  if ((L->top - L->base + size) > LUA_MAXCSTACK)
+    res = 0;  /* stack overflow */
+  else {
+    luaD_checkstack(L, size);
+    if (L->ci->top < L->top + size)
+      L->ci->top = L->top + size;
+    res = 1;
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
+  int i;
+  lua_lock(to);
+  api_checknelems(from, n);
+  from->top -= n;
+  for (i = 0; i < n; i++) {
+    setobj2s(to->top, from->top + i);
+    api_incr_top(to);
+  }
+  lua_unlock(to);
+}
+
+
+LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {
+  lua_CFunction old;
+  lua_lock(L);
+  old = G(L)->panic;
+  G(L)->panic = panicf;
+  lua_unlock(L);
+  return old;
+}
+
+
+LUA_API lua_State *lua_newthread (lua_State *L) {
+  lua_State *L1;
+  lua_lock(L);
+  luaC_checkGC(L);
+  L1 = luaE_newthread(L);
+  setthvalue(L->top, L1);
+  api_incr_top(L);
+  lua_unlock(L);
+  lua_userstateopen(L1);
+  return L1;
+}
+
+
+
+/*
+** basic stack manipulation
+*/
+
+
+LUA_API int lua_gettop (lua_State *L) {
+  return (L->top - L->base);
+}
+
+
+LUA_API void lua_settop (lua_State *L, int idx) {
+  lua_lock(L);
+  if (idx >= 0) {
+    api_check(L, idx <= L->stack_last - L->base);
+    while (L->top < L->base + idx)
+      setnilvalue(L->top++);
+    L->top = L->base + idx;
+  }
+  else {
+    api_check(L, -(idx+1) <= (L->top - L->base));
+    L->top += idx+1;  /* `subtract' index (index is negative) */
+  }
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_remove (lua_State *L, int idx) {
+  StkId p;
+  lua_lock(L);
+  p = luaA_index(L, idx);
+  while (++p < L->top) setobjs2s(p-1, p);
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_insert (lua_State *L, int idx) {
+  StkId p;
+  StkId q;
+  lua_lock(L);
+  p = luaA_index(L, idx);
+  for (q = L->top; q>p; q--) setobjs2s(q, q-1);
+  setobjs2s(p, L->top);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_replace (lua_State *L, int idx) {
+  lua_lock(L);
+  api_checknelems(L, 1);
+  setobj(luaA_index(L, idx), L->top - 1);  /* write barrier */
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushvalue (lua_State *L, int idx) {
+  lua_lock(L);
+  setobj2s(L->top, luaA_index(L, idx));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API int lua_type (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  return (o == NULL) ? LUA_TNONE : ttype(o);
+}
+
+
+LUA_API const char *lua_typename (lua_State *L, int t) {
+  UNUSED(L);
+  return (t == LUA_TNONE) ? "no value" : luaT_typenames[t];
+}
+
+
+LUA_API int lua_iscfunction (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  return (o == NULL) ? 0 : iscfunction(o);
+}
+
+
+LUA_API int lua_isnumber (lua_State *L, int idx) {
+  TObject n;
+  const TObject *o = luaA_indexAcceptable(L, idx);
+  return (o != NULL && tonumber(o, &n));
+}
+
+
+LUA_API int lua_isstring (lua_State *L, int idx) {
+  int t = lua_type(L, idx);
+  return (t == LUA_TSTRING || t == LUA_TNUMBER);
+}
+
+
+LUA_API int lua_isuserdata (lua_State *L, int idx) {
+  const TObject *o = luaA_indexAcceptable(L, idx);
+  return (o != NULL && (ttisuserdata(o) || ttislightuserdata(o)));
+}
+
+
+LUA_API int lua_rawequal (lua_State *L, int index1, int index2) {
+  StkId o1 = luaA_indexAcceptable(L, index1);
+  StkId o2 = luaA_indexAcceptable(L, index2);
+  return (o1 == NULL || o2 == NULL) ? 0  /* index out of range */
+                                    : luaO_rawequalObj(o1, o2);
+}
+
+
+LUA_API int lua_equal (lua_State *L, int index1, int index2) {
+  StkId o1, o2;
+  int i;
+  lua_lock(L);  /* may call tag method */
+  o1 = luaA_indexAcceptable(L, index1);
+  o2 = luaA_indexAcceptable(L, index2);
+  i = (o1 == NULL || o2 == NULL) ? 0  /* index out of range */
+                                 : equalobj(L, o1, o2);
+  lua_unlock(L);
+  return i;
+}
+
+
+LUA_API int lua_lessthan (lua_State *L, int index1, int index2) {
+  StkId o1, o2;
+  int i;
+  lua_lock(L);  /* may call tag method */
+  o1 = luaA_indexAcceptable(L, index1);
+  o2 = luaA_indexAcceptable(L, index2);
+  i = (o1 == NULL || o2 == NULL) ? 0  /* index out-of-range */
+                                 : luaV_lessthan(L, o1, o2);
+  lua_unlock(L);
+  return i;
+}
+
+
+
+LUA_API lua_Number lua_tonumber (lua_State *L, int idx) {
+  TObject n;
+  const TObject *o = luaA_indexAcceptable(L, idx);
+  if (o != NULL && tonumber(o, &n))
+    return nvalue(o);
+  else
+    return 0;
+}
+
+
+LUA_API int lua_toboolean (lua_State *L, int idx) {
+  const TObject *o = luaA_indexAcceptable(L, idx);
+  return (o != NULL) && !l_isfalse(o);
+}
+
+
+LUA_API const char *lua_tostring (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  if (o == NULL)
+    return NULL;
+  else if (ttisstring(o))
+    return svalue(o);
+  else {
+    const char *s;
+    lua_lock(L);  /* `luaV_tostring' may create a new string */
+    s = (luaV_tostring(L, o) ? svalue(o) : NULL);
+    luaC_checkGC(L);
+    lua_unlock(L);
+    return s;
+  }
+}
+
+
+LUA_API size_t lua_strlen (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  if (o == NULL)
+    return 0;
+  else if (ttisstring(o))
+    return tsvalue(o)->tsv.len;
+  else {
+    size_t l;
+    lua_lock(L);  /* `luaV_tostring' may create a new string */
+    l = (luaV_tostring(L, o) ? tsvalue(o)->tsv.len : 0);
+    lua_unlock(L);
+    return l;
+  }
+}
+
+
+LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  return (o == NULL || !iscfunction(o)) ? NULL : clvalue(o)->c.f;
+}
+
+
+LUA_API void *lua_touserdata (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  if (o == NULL) return NULL;
+  switch (ttype(o)) {
+    case LUA_TUSERDATA: return (uvalue(o) + 1);
+    case LUA_TLIGHTUSERDATA: return pvalue(o);
+    default: return NULL;
+  }
+}
+
+
+LUA_API lua_State *lua_tothread (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  return (o == NULL || !ttisthread(o)) ? NULL : thvalue(o);
+}
+
+
+LUA_API const void *lua_topointer (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  if (o == NULL) return NULL;
+  else {
+    switch (ttype(o)) {
+      case LUA_TTABLE: return hvalue(o);
+      case LUA_TFUNCTION: return clvalue(o);
+      case LUA_TTHREAD: return thvalue(o);
+      case LUA_TUSERDATA:
+      case LUA_TLIGHTUSERDATA:
+        return lua_touserdata(L, idx);
+      default: return NULL;
+    }
+  }
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushnil (lua_State *L) {
+  lua_lock(L);
+  setnilvalue(L->top);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {
+  lua_lock(L);
+  setnvalue(L->top, n);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushlstring (lua_State *L, const char *s, size_t len) {
+  lua_lock(L);
+  luaC_checkGC(L);
+  setsvalue2s(L->top, luaS_newlstr(L, s, len));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushstring (lua_State *L, const char *s) {
+  if (s == NULL)
+    lua_pushnil(L);
+  else
+    lua_pushlstring(L, s, strlen(s));
+}
+
+
+LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
+                                      va_list argp) {
+  const char *ret;
+  lua_lock(L);
+  luaC_checkGC(L);
+  ret = luaO_pushvfstring(L, fmt, argp);
+  lua_unlock(L);
+  return ret;
+}
+
+
+LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {
+  const char *ret;
+  va_list argp;
+  lua_lock(L);
+  luaC_checkGC(L);
+  va_start(argp, fmt);
+  ret = luaO_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  lua_unlock(L);
+  return ret;
+}
+
+
+LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {
+  Closure *cl;
+  lua_lock(L);
+  luaC_checkGC(L);
+  api_checknelems(L, n);
+  cl = luaF_newCclosure(L, n);
+  cl->c.f = fn;
+  L->top -= n;
+  while (n--)
+    setobj2n(&cl->c.upvalue[n], L->top+n);
+  setclvalue(L->top, cl);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushboolean (lua_State *L, int b) {
+  lua_lock(L);
+  setbvalue(L->top, (b != 0));  /* ensure that true is 1 */
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {
+  lua_lock(L);
+  setpvalue(L->top, p);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+
+/*
+** get functions (Lua -> stack)
+*/
+
+
+LUA_API void lua_gettable (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = luaA_index(L, idx);
+  setobj2s(L->top - 1, luaV_gettable(L, t, L->top - 1, 0));
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawget (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = luaA_index(L, idx);
+  api_check(L, ttistable(t));
+  setobj2s(L->top - 1, luaH_get(hvalue(t), L->top - 1));
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawgeti (lua_State *L, int idx, int n) {
+  StkId o;
+  lua_lock(L);
+  o = luaA_index(L, idx);
+  api_check(L, ttistable(o));
+  setobj2s(L->top, luaH_getnum(hvalue(o), n));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_newtable (lua_State *L) {
+  lua_lock(L);
+  luaC_checkGC(L);
+  sethvalue(L->top, luaH_new(L, 0, 0));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_getmetatable (lua_State *L, int objindex) {
+  const TObject *obj;
+  Table *mt = NULL;
+  int res;
+  lua_lock(L);
+  obj = luaA_indexAcceptable(L, objindex);
+  if (obj != NULL) {
+    switch (ttype(obj)) {
+      case LUA_TTABLE:
+        mt = hvalue(obj)->metatable;
+        break;
+      case LUA_TUSERDATA:
+        mt = uvalue(obj)->uv.metatable;
+        break;
+    }
+  }
+  if (mt == NULL || mt == hvalue(defaultmeta(L)))
+    res = 0;
+  else {
+    sethvalue(L->top, mt);
+    api_incr_top(L);
+    res = 1;
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API void lua_getfenv (lua_State *L, int idx) {
+  StkId o;
+  lua_lock(L);
+  o = luaA_index(L, idx);
+  setobj2s(L->top, isLfunction(o) ? &clvalue(o)->l.g : gt(L));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+/*
+** set functions (stack -> Lua)
+*/
+
+
+LUA_API void lua_settable (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 2);
+  t = luaA_index(L, idx);
+  luaV_settable(L, t, L->top - 2, L->top - 1);
+  L->top -= 2;  /* pop index and value */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawset (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 2);
+  t = luaA_index(L, idx);
+  api_check(L, ttistable(t));
+  setobj2t(luaH_set(L, hvalue(t), L->top-2), L->top-1);  /* write barrier */
+  L->top -= 2;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawseti (lua_State *L, int idx, int n) {
+  StkId o;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = luaA_index(L, idx);
+  api_check(L, ttistable(o));
+  setobj2t(luaH_setnum(L, hvalue(o), n), L->top-1);  /* write barrier */
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_setmetatable (lua_State *L, int objindex) {
+  TObject *obj, *mt;
+  int res = 1;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  obj = luaA_index(L, objindex);
+  mt = (!ttisnil(L->top - 1)) ? L->top - 1 : defaultmeta(L);
+  api_check(L, ttistable(mt));
+  switch (ttype(obj)) {
+    case LUA_TTABLE: {
+      hvalue(obj)->metatable = hvalue(mt);  /* write barrier */
+      break;
+    }
+    case LUA_TUSERDATA: {
+      uvalue(obj)->uv.metatable = hvalue(mt);  /* write barrier */
+      break;
+    }
+    default: {
+      res = 0;  /* cannot set */
+      break;
+    }
+  }
+  L->top--;
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API int lua_setfenv (lua_State *L, int idx) {
+  StkId o;
+  int res = 0;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = luaA_index(L, idx);
+  L->top--;
+  api_check(L, ttistable(L->top));
+  if (isLfunction(o)) {
+    res = 1;
+    clvalue(o)->l.g = *(L->top);
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+/*
+** `load' and `call' functions (run Lua code)
+*/
+
+LUA_API void lua_call (lua_State *L, int nargs, int nresults) {
+  StkId func;
+  lua_lock(L);
+  api_checknelems(L, nargs+1);
+  func = L->top - (nargs+1);
+  luaD_call(L, func, nresults);
+  lua_unlock(L);
+}
+
+
+
+/*
+** Execute a protected call.
+*/
+struct CallS {  /* data to `f_call' */
+  StkId func;
+  int nresults;
+};
+
+
+static void f_call (lua_State *L, void *ud) {
+  struct CallS *c = cast(struct CallS *, ud);
+  luaD_call(L, c->func, c->nresults);
+}
+
+
+
+LUA_API int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc) {
+  struct CallS c;
+  int status;
+  ptrdiff_t func;
+  lua_lock(L);
+  func = (errfunc == 0) ? 0 : savestack(L, luaA_index(L, errfunc));
+  c.func = L->top - (nargs+1);  /* function to be called */
+  c.nresults = nresults;
+  status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);
+  lua_unlock(L);
+  return status;
+}
+
+
+/*
+** Execute a protected C call.
+*/
+struct CCallS {  /* data to `f_Ccall' */
+  lua_CFunction func;
+  void *ud;
+};
+
+
+static void f_Ccall (lua_State *L, void *ud) {
+  struct CCallS *c = cast(struct CCallS *, ud);
+  Closure *cl;
+  cl = luaF_newCclosure(L, 0);
+  cl->c.f = c->func;
+  setclvalue(L->top, cl);  /* push function */
+  incr_top(L);
+  setpvalue(L->top, c->ud);  /* push only argument */
+  incr_top(L);
+  luaD_call(L, L->top - 2, 0);
+}
+
+
+LUA_API int lua_cpcall (lua_State *L, lua_CFunction func, void *ud) {
+  struct CCallS c;
+  int status;
+  lua_lock(L);
+  c.func = func;
+  c.ud = ud;
+  status = luaD_pcall(L, f_Ccall, &c, savestack(L, L->top), 0);
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_load (lua_State *L, lua_Chunkreader reader, void *data,
+                      const char *chunkname) {
+  ZIO z;
+  int status;
+  int c;
+  lua_lock(L);
+  if (!chunkname) chunkname = "?";
+  luaZ_init(&z, reader, data, chunkname);
+  c = luaZ_lookahead(&z);
+  status = luaD_protectedparser(L, &z, (c == LUA_SIGNATURE[0]));
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_dump (lua_State *L, lua_Chunkwriter writer, void *data) {
+  int status;
+  TObject *o;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = L->top - 1;
+  if (isLfunction(o) && clvalue(o)->l.nupvalues == 0) {
+    luaU_dump(L, clvalue(o)->l.p, writer, data);
+    status = 1;
+  }
+  else
+    status = 0;
+  lua_unlock(L);
+  return status;
+}
+
+
+/*
+** Garbage-collection functions
+*/
+
+/* GC values are expressed in Kbytes: #bytes/2^10 */
+#define GCscalel(x)		((x)>>10)
+#define GCscale(x)		(cast(int, GCscalel(x)))
+#define GCunscale(x)		(cast(lu_mem, x)<<10)
+
+LUA_API int lua_getgcthreshold (lua_State *L) {
+  int threshold;
+  lua_lock(L);
+  threshold = GCscale(G(L)->GCthreshold);
+  lua_unlock(L);
+  return threshold;
+}
+
+LUA_API int lua_getgccount (lua_State *L) {
+  int count;
+  lua_lock(L);
+  count = GCscale(G(L)->nblocks);
+  lua_unlock(L);
+  return count;
+}
+
+LUA_API void lua_setgcthreshold (lua_State *L, int newthreshold) {
+  lua_lock(L);
+  if (cast(lu_mem, newthreshold) > GCscalel(MAX_LUMEM))
+    G(L)->GCthreshold = MAX_LUMEM;
+  else
+    G(L)->GCthreshold = GCunscale(newthreshold);
+  luaC_checkGC(L);
+  lua_unlock(L);
+}
+
+
+/*
+** miscellaneous functions
+*/
+
+
+LUA_API const char *lua_version (void) {
+  return LUA_VERSION;
+}
+
+
+LUA_API int lua_error (lua_State *L) {
+  lua_lock(L);
+  api_checknelems(L, 1);
+  luaG_errormsg(L);
+  lua_unlock(L);
+  return 0;  /* to avoid warnings */
+}
+
+
+LUA_API int lua_next (lua_State *L, int idx) {
+  StkId t;
+  int more;
+  lua_lock(L);
+  t = luaA_index(L, idx);
+  api_check(L, ttistable(t));
+  more = luaH_next(L, hvalue(t), L->top - 1);
+  if (more) {
+    api_incr_top(L);
+  }
+  else  /* no more elements */
+    L->top -= 1;  /* remove key */
+  lua_unlock(L);
+  return more;
+}
+
+
+LUA_API void lua_concat (lua_State *L, int n) {
+  lua_lock(L);
+  luaC_checkGC(L);
+  api_checknelems(L, n);
+  if (n >= 2) {
+    luaV_concat(L, n, L->top - L->base - 1);
+    L->top -= (n-1);
+  }
+  else if (n == 0) {  /* push empty string */
+    setsvalue2s(L->top, luaS_newlstr(L, NULL, 0));
+    api_incr_top(L);
+  }
+  /* else n == 1; nothing to do */
+  lua_unlock(L);
+}
+
+
+LUA_API void *lua_newuserdata (lua_State *L, size_t size) {
+  Udata *u;
+  lua_lock(L);
+  luaC_checkGC(L);
+  u = luaS_newudata(L, size);
+  setuvalue(L->top, u);
+  api_incr_top(L);
+  lua_unlock(L);
+  return u + 1;
+}
+
+
+LUA_API int lua_pushupvalues (lua_State *L) {
+  Closure *func;
+  int n, i;
+  lua_lock(L);
+  api_check(L, iscfunction(L->base - 1));
+  func = clvalue(L->base - 1);
+  n = func->c.nupvalues;
+  luaD_checkstack(L, n + LUA_MINSTACK);
+  for (i=0; i<n; i++) {
+    setobj2s(L->top, &func->c.upvalue[i]);
+    L->top++;
+  }
+  lua_unlock(L);
+  return n;
+}
+
+
+static const char *aux_upvalue (lua_State *L, int funcindex, int n,
+                                TObject **val) {
+  Closure *f;
+  StkId fi = luaA_index(L, funcindex);
+  if (!ttisfunction(fi)) return NULL;
+  f = clvalue(fi);
+  if (f->c.isC) {
+    if (n > f->c.nupvalues) return NULL;
+    *val = &f->c.upvalue[n-1];
+    return "";
+  }
+  else {
+    Proto *p = f->l.p;
+    if (n > p->sizeupvalues) return NULL;
+    *val = f->l.upvals[n-1]->v;
+    return getstr(p->upvalues[n-1]);
+  }
+}
+
+
+LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {
+  const char *name;
+  TObject *val;
+  lua_lock(L);
+  name = aux_upvalue(L, funcindex, n, &val);
+  if (name) {
+    setobj2s(L->top, val);
+    api_incr_top(L);
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {
+  const char *name;
+  TObject *val;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  name = aux_upvalue(L, funcindex, n, &val);
+  if (name) {
+    L->top--;
+    setobj(val, L->top);  /* write barrier */
+  }
+  lua_unlock(L);
+  return name;
+}
+

Added: trunk/source/libraries/lua/lapi.h
===================================================================
--- trunk/source/libraries/lua/lapi.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lapi.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,16 @@
+/*
+** $Id: lapi.h,v 1.21 2002/03/04 21:29:41 roberto Exp $
+** Auxiliary functions from Lua API
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lapi_h
+#define lapi_h
+
+
+#include "lobject.h"
+
+
+void luaA_pushobject (lua_State *L, const TObject *o);
+
+#endif

Added: trunk/source/libraries/lua/lauxlib.h
===================================================================
--- trunk/source/libraries/lua/lauxlib.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lauxlib.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,145 @@
+/*
+** $Id: lauxlib.h,v 1.60 2003/04/03 13:35:34 roberto Exp $
+** Auxiliary functions for building Lua libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lauxlib_h
+#define lauxlib_h
+
+
+#include <stddef.h>
+#include <stdio.h>
+
+#include "lua.h"
+
+
+#ifndef LUALIB_API
+#define LUALIB_API	LUA_API
+#endif
+
+
+
+typedef struct luaL_reg {
+  const char *name;
+  lua_CFunction func;
+} luaL_reg;
+
+
+LUALIB_API void luaL_openlib (lua_State *L, const char *libname,
+                               const luaL_reg *l, int nup);
+LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *e);
+LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *e);
+LUALIB_API int luaL_typerror (lua_State *L, int narg, const char *tname);
+LUALIB_API int luaL_argerror (lua_State *L, int numarg, const char *extramsg);
+LUALIB_API const char *luaL_checklstring (lua_State *L, int numArg, size_t *l);
+LUALIB_API const char *luaL_optlstring (lua_State *L, int numArg,
+                                           const char *def, size_t *l);
+LUALIB_API lua_Number luaL_checknumber (lua_State *L, int numArg);
+LUALIB_API lua_Number luaL_optnumber (lua_State *L, int nArg, lua_Number def);
+
+LUALIB_API void luaL_checkstack (lua_State *L, int sz, const char *msg);
+LUALIB_API void luaL_checktype (lua_State *L, int narg, int t);
+LUALIB_API void luaL_checkany (lua_State *L, int narg);
+
+LUALIB_API int   luaL_newmetatable (lua_State *L, const char *tname);
+LUALIB_API void  luaL_getmetatable (lua_State *L, const char *tname);
+LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname);
+
+LUALIB_API void luaL_where (lua_State *L, int lvl);
+LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...);
+
+LUALIB_API int luaL_findstring (const char *st, const char *const lst[]);
+
+LUALIB_API int luaL_ref (lua_State *L, int t);
+LUALIB_API void luaL_unref (lua_State *L, int t, int ref);
+
+LUALIB_API int luaL_getn (lua_State *L, int t);
+LUALIB_API void luaL_setn (lua_State *L, int t, int n);
+
+LUALIB_API int luaL_loadfile (lua_State *L, const char *filename);
+LUALIB_API int luaL_loadbuffer (lua_State *L, const char *buff, size_t sz,
+                                const char *name);
+
+
+
+/*
+** ===============================================================
+** some useful macros
+** ===============================================================
+*/
+
+#define luaL_argcheck(L, cond,numarg,extramsg) if (!(cond)) \
+                                               luaL_argerror(L, numarg,extramsg)
+#define luaL_checkstring(L,n)	(luaL_checklstring(L, (n), NULL))
+#define luaL_optstring(L,n,d)	(luaL_optlstring(L, (n), (d), NULL))
+#define luaL_checkint(L,n)	((int)luaL_checknumber(L, n))
+#define luaL_checklong(L,n)	((long)luaL_checknumber(L, n))
+#define luaL_optint(L,n,d)	((int)luaL_optnumber(L, n,(lua_Number)(d)))
+#define luaL_optlong(L,n,d)	((long)luaL_optnumber(L, n,(lua_Number)(d)))
+
+
+/*
+** {======================================================
+** Generic Buffer manipulation
+** =======================================================
+*/
+
+
+#ifndef LUAL_BUFFERSIZE
+#define LUAL_BUFFERSIZE	  BUFSIZ
+#endif
+
+
+typedef struct luaL_Buffer {
+  char *p;			/* current position in buffer */
+  int lvl;  /* number of strings in the stack (level) */
+  lua_State *L;
+  char buffer[LUAL_BUFFERSIZE];
+} luaL_Buffer;
+
+#define luaL_putchar(B,c) \
+  ((void)((B)->p < ((B)->buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), \
+   (*(B)->p++ = (char)(c)))
+
+#define luaL_addsize(B,n)	((B)->p += (n))
+
+LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B);
+LUALIB_API char *luaL_prepbuffer (luaL_Buffer *B);
+LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);
+LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s);
+LUALIB_API void luaL_addvalue (luaL_Buffer *B);
+LUALIB_API void luaL_pushresult (luaL_Buffer *B);
+
+
+/* }====================================================== */
+
+
+
+/*
+** Compatibility macros and functions
+*/
+
+LUALIB_API int   lua_dofile (lua_State *L, const char *filename);
+LUALIB_API int   lua_dostring (lua_State *L, const char *str);
+LUALIB_API int   lua_dobuffer (lua_State *L, const char *buff, size_t sz,
+                               const char *n);
+
+
+#define luaL_check_lstr 	luaL_checklstring
+#define luaL_opt_lstr 	luaL_optlstring 
+#define luaL_check_number 	luaL_checknumber 
+#define luaL_opt_number	luaL_optnumber
+#define luaL_arg_check	luaL_argcheck
+#define luaL_check_string	luaL_checkstring
+#define luaL_opt_string	luaL_optstring
+#define luaL_check_int	luaL_checkint
+#define luaL_check_long	luaL_checklong
+#define luaL_opt_int	luaL_optint
+#define luaL_opt_long	luaL_optlong
+
+
+#endif
+
+

Added: trunk/source/libraries/lua/lcode.c
===================================================================
--- trunk/source/libraries/lua/lcode.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lcode.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,714 @@
+/*
+** $Id: lcode.c,v 1.117 2003/04/03 13:35:34 roberto Exp $
+** Code generator for Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+
+#define lcode_c
+
+#include "lua.h"
+
+#include "lcode.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "llex.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+#include "ltable.h"
+
+
+#define hasjumps(e)	((e)->t != (e)->f)
+
+
+void luaK_nil (FuncState *fs, int from, int n) {
+  Instruction *previous;
+  if (fs->pc > fs->lasttarget &&  /* no jumps to current position? */
+      GET_OPCODE(*(previous = &fs->f->code[fs->pc-1])) == OP_LOADNIL) {
+    int pfrom = GETARG_A(*previous);
+    int pto = GETARG_B(*previous);
+    if (pfrom <= from && from <= pto+1) {  /* can connect both? */
+      if (from+n-1 > pto)
+        SETARG_B(*previous, from+n-1);
+      return;
+    }
+  }
+  luaK_codeABC(fs, OP_LOADNIL, from, from+n-1, 0);  /* else no optimization */
+}
+
+
+int luaK_jump (FuncState *fs) {
+  int jpc = fs->jpc;  /* save list of jumps to here */
+  int j;
+  fs->jpc = NO_JUMP;
+  j = luaK_codeAsBx(fs, OP_JMP, 0, NO_JUMP);
+  luaK_concat(fs, &j, jpc);  /* keep them on hold */
+  return j;
+}
+
+
+static int luaK_condjump (FuncState *fs, OpCode op, int A, int B, int C) {
+  luaK_codeABC(fs, op, A, B, C);
+  return luaK_jump(fs);
+}
+
+
+static void luaK_fixjump (FuncState *fs, int pc, int dest) {
+  Instruction *jmp = &fs->f->code[pc];
+  int offset = dest-(pc+1);
+  lua_assert(dest != NO_JUMP);
+  if (abs(offset) > MAXARG_sBx)
+    luaX_syntaxerror(fs->ls, "control structure too long");
+  SETARG_sBx(*jmp, offset);
+}
+
+
+/*
+** returns current `pc' and marks it as a jump target (to avoid wrong
+** optimizations with consecutive instructions not in the same basic block).
+*/
+int luaK_getlabel (FuncState *fs) {
+  fs->lasttarget = fs->pc;
+  return fs->pc;
+}
+
+
+static int luaK_getjump (FuncState *fs, int pc) {
+  int offset = GETARG_sBx(fs->f->code[pc]);
+  if (offset == NO_JUMP)  /* point to itself represents end of list */
+    return NO_JUMP;  /* end of list */
+  else
+    return (pc+1)+offset;  /* turn offset into absolute position */
+}
+
+
+static Instruction *getjumpcontrol (FuncState *fs, int pc) {
+  Instruction *pi = &fs->f->code[pc];
+  if (pc >= 1 && testOpMode(GET_OPCODE(*(pi-1)), OpModeT))
+    return pi-1;
+  else
+    return pi;
+}
+
+
+/*
+** check whether list has any jump that do not produce a value
+** (or produce an inverted value)
+*/
+static int need_value (FuncState *fs, int list, int cond) {
+  for (; list != NO_JUMP; list = luaK_getjump(fs, list)) {
+    Instruction i = *getjumpcontrol(fs, list);
+    if (GET_OPCODE(i) != OP_TEST || GETARG_C(i) != cond) return 1;
+  }
+  return 0;  /* not found */
+}
+
+
+static void patchtestreg (Instruction *i, int reg) {
+  if (reg == NO_REG) reg = GETARG_B(*i);
+  SETARG_A(*i, reg);
+}
+
+
+static void luaK_patchlistaux (FuncState *fs, int list,
+          int ttarget, int treg, int ftarget, int freg, int dtarget) {
+  while (list != NO_JUMP) {
+    int next = luaK_getjump(fs, list);
+    Instruction *i = getjumpcontrol(fs, list);
+    if (GET_OPCODE(*i) != OP_TEST) {
+      lua_assert(dtarget != NO_JUMP);
+      luaK_fixjump(fs, list, dtarget);  /* jump to default target */
+    }
+    else {
+      if (GETARG_C(*i)) {
+        lua_assert(ttarget != NO_JUMP);
+        patchtestreg(i, treg);
+        luaK_fixjump(fs, list, ttarget);
+      }
+      else {
+        lua_assert(ftarget != NO_JUMP);
+        patchtestreg(i, freg);
+        luaK_fixjump(fs, list, ftarget);
+      }
+    }
+    list = next;
+  }
+}
+
+
+static void luaK_dischargejpc (FuncState *fs) {
+  luaK_patchlistaux(fs, fs->jpc, fs->pc, NO_REG, fs->pc, NO_REG, fs->pc);
+  fs->jpc = NO_JUMP;
+}
+
+
+void luaK_patchlist (FuncState *fs, int list, int target) {
+  if (target == fs->pc)
+    luaK_patchtohere(fs, list);
+  else {
+    lua_assert(target < fs->pc);
+    luaK_patchlistaux(fs, list, target, NO_REG, target, NO_REG, target);
+  }
+}
+
+
+void luaK_patchtohere (FuncState *fs, int list) {
+  luaK_getlabel(fs);
+  luaK_concat(fs, &fs->jpc, list);
+}
+
+
+void luaK_concat (FuncState *fs, int *l1, int l2) {
+  if (l2 == NO_JUMP) return;
+  else if (*l1 == NO_JUMP)
+    *l1 = l2;
+  else {
+    int list = *l1;
+    int next;
+    while ((next = luaK_getjump(fs, list)) != NO_JUMP)  /* find last element */
+      list = next;
+    luaK_fixjump(fs, list, l2);
+  }
+}
+
+
+void luaK_checkstack (FuncState *fs, int n) {
+  int newstack = fs->freereg + n;
+  if (newstack > fs->f->maxstacksize) {
+    if (newstack >= MAXSTACK)
+      luaX_syntaxerror(fs->ls, "function or expression too complex");
+    fs->f->maxstacksize = cast(lu_byte, newstack);
+  }
+}
+
+
+void luaK_reserveregs (FuncState *fs, int n) {
+  luaK_checkstack(fs, n);
+  fs->freereg += n;
+}
+
+
+static void freereg (FuncState *fs, int reg) {
+  if (reg >= fs->nactvar && reg < MAXSTACK) {
+    fs->freereg--;
+    lua_assert(reg == fs->freereg);
+  }
+}
+
+
+static void freeexp (FuncState *fs, expdesc *e) {
+  if (e->k == VNONRELOC)
+    freereg(fs, e->info);
+}
+
+
+static int addk (FuncState *fs, TObject *k, TObject *v) {
+  const TObject *idx = luaH_get(fs->h, k);
+  if (ttisnumber(idx)) {
+    lua_assert(luaO_rawequalObj(&fs->f->k[cast(int, nvalue(idx))], v));
+    return cast(int, nvalue(idx));
+  }
+  else {  /* constant not found; create a new entry */
+    Proto *f = fs->f;
+    luaM_growvector(fs->L, f->k, fs->nk, f->sizek, TObject,
+                    MAXARG_Bx, "constant table overflow");
+    setobj2n(&f->k[fs->nk], v);
+    setnvalue(luaH_set(fs->L, fs->h, k), cast(lua_Number, fs->nk));
+    return fs->nk++;
+  }
+}
+
+
+int luaK_stringK (FuncState *fs, TString *s) {
+  TObject o;
+  setsvalue(&o, s);
+  return addk(fs, &o, &o);
+}
+
+
+int luaK_numberK (FuncState *fs, lua_Number r) {
+  TObject o;
+  setnvalue(&o, r);
+  return addk(fs, &o, &o);
+}
+
+
+static int nil_constant (FuncState *fs) {
+  TObject k, v;
+  setnilvalue(&v);
+  sethvalue(&k, fs->h);  /* cannot use nil as key; instead use table itself */
+  return addk(fs, &k, &v);
+}
+
+
+void luaK_setcallreturns (FuncState *fs, expdesc *e, int nresults) {
+  if (e->k == VCALL) {  /* expression is an open function call? */
+    SETARG_C(getcode(fs, e), nresults+1);
+    if (nresults == 1) {  /* `regular' expression? */
+      e->k = VNONRELOC;
+      e->info = GETARG_A(getcode(fs, e));
+    }
+  }
+}
+
+
+void luaK_dischargevars (FuncState *fs, expdesc *e) {
+  switch (e->k) {
+    case VLOCAL: {
+      e->k = VNONRELOC;
+      break;
+    }
+    case VUPVAL: {
+      e->info = luaK_codeABC(fs, OP_GETUPVAL, 0, e->info, 0);
+      e->k = VRELOCABLE;
+      break;
+    }
+    case VGLOBAL: {
+      e->info = luaK_codeABx(fs, OP_GETGLOBAL, 0, e->info);
+      e->k = VRELOCABLE;
+      break;
+    }
+    case VINDEXED: {
+      freereg(fs, e->aux);
+      freereg(fs, e->info);
+      e->info = luaK_codeABC(fs, OP_GETTABLE, 0, e->info, e->aux);
+      e->k = VRELOCABLE;
+      break;
+    }
+    case VCALL: {
+      luaK_setcallreturns(fs, e, 1);
+      break;
+    }
+    default: break;  /* there is one value available (somewhere) */
+  }
+}
+
+
+static int code_label (FuncState *fs, int A, int b, int jump) {
+  luaK_getlabel(fs);  /* those instructions may be jump targets */
+  return luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);
+}
+
+
+static void discharge2reg (FuncState *fs, expdesc *e, int reg) {
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VNIL: {
+      luaK_nil(fs, reg, 1);
+      break;
+    }
+    case VFALSE:  case VTRUE: {
+      luaK_codeABC(fs, OP_LOADBOOL, reg, e->k == VTRUE, 0);
+      break;
+    }
+    case VK: {
+      luaK_codeABx(fs, OP_LOADK, reg, e->info);
+      break;
+    }
+    case VRELOCABLE: {
+      Instruction *pc = &getcode(fs, e);
+      SETARG_A(*pc, reg);
+      break;
+    }
+    case VNONRELOC: {
+      if (reg != e->info)
+        luaK_codeABC(fs, OP_MOVE, reg, e->info, 0);
+      break;
+    }
+    default: {
+      lua_assert(e->k == VVOID || e->k == VJMP);
+      return;  /* nothing to do... */
+    }
+  }
+  e->info = reg;
+  e->k = VNONRELOC;
+}
+
+
+static void discharge2anyreg (FuncState *fs, expdesc *e) {
+  if (e->k != VNONRELOC) {
+    luaK_reserveregs(fs, 1);
+    discharge2reg(fs, e, fs->freereg-1);
+  }
+}
+
+
+static void luaK_exp2reg (FuncState *fs, expdesc *e, int reg) {
+  discharge2reg(fs, e, reg);
+  if (e->k == VJMP)
+    luaK_concat(fs, &e->t, e->info);  /* put this jump in `t' list */
+  if (hasjumps(e)) {
+    int final;  /* position after whole expression */
+    int p_f = NO_JUMP;  /* position of an eventual LOAD false */
+    int p_t = NO_JUMP;  /* position of an eventual LOAD true */
+    if (need_value(fs, e->t, 1) || need_value(fs, e->f, 0)) {
+      int fj = NO_JUMP;  /* first jump (over LOAD ops.) */
+      if (e->k != VJMP)
+        fj = luaK_jump(fs);
+      p_f = code_label(fs, reg, 0, 1);
+      p_t = code_label(fs, reg, 1, 0);
+      luaK_patchtohere(fs, fj);
+    }
+    final = luaK_getlabel(fs);
+    luaK_patchlistaux(fs, e->f, p_f, NO_REG, final, reg, p_f);
+    luaK_patchlistaux(fs, e->t, final, reg, p_t, NO_REG, p_t);
+  }
+  e->f = e->t = NO_JUMP;
+  e->info = reg;
+  e->k = VNONRELOC;
+}
+
+
+void luaK_exp2nextreg (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  freeexp(fs, e);
+  luaK_reserveregs(fs, 1);
+  luaK_exp2reg(fs, e, fs->freereg - 1);
+}
+
+
+int luaK_exp2anyreg (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  if (e->k == VNONRELOC) {
+    if (!hasjumps(e)) return e->info;  /* exp is already in a register */ 
+    if (e->info >= fs->nactvar) {  /* reg. is not a local? */
+      luaK_exp2reg(fs, e, e->info);  /* put value on it */
+      return e->info;
+    }
+  }
+  luaK_exp2nextreg(fs, e);  /* default */
+  return e->info;
+}
+
+
+void luaK_exp2val (FuncState *fs, expdesc *e) {
+  if (hasjumps(e))
+    luaK_exp2anyreg(fs, e);
+  else
+    luaK_dischargevars(fs, e);
+}
+
+
+int luaK_exp2RK (FuncState *fs, expdesc *e) {
+  luaK_exp2val(fs, e);
+  switch (e->k) {
+    case VNIL: {
+      if (fs->nk + MAXSTACK <= MAXARG_C) {  /* constant fit in argC? */
+        e->info = nil_constant(fs);
+        e->k = VK;
+        return e->info + MAXSTACK;
+      }
+      else break;
+    }
+    case VK: {
+      if (e->info + MAXSTACK <= MAXARG_C)  /* constant fit in argC? */
+        return e->info + MAXSTACK;
+      else break;
+    }
+    default: break;
+  }
+  /* not a constant in the right range: put it in a register */
+  return luaK_exp2anyreg(fs, e);
+}
+
+
+void luaK_storevar (FuncState *fs, expdesc *var, expdesc *exp) {
+  switch (var->k) {
+    case VLOCAL: {
+      freeexp(fs, exp);
+      luaK_exp2reg(fs, exp, var->info);
+      return;
+    }
+    case VUPVAL: {
+      int e = luaK_exp2anyreg(fs, exp);
+      luaK_codeABC(fs, OP_SETUPVAL, e, var->info, 0);
+      break;
+    }
+    case VGLOBAL: {
+      int e = luaK_exp2anyreg(fs, exp);
+      luaK_codeABx(fs, OP_SETGLOBAL, e, var->info);
+      break;
+    }
+    case VINDEXED: {
+      int e = luaK_exp2RK(fs, exp);
+      luaK_codeABC(fs, OP_SETTABLE, var->info, var->aux, e);
+      break;
+    }
+    default: {
+      lua_assert(0);  /* invalid var kind to store */
+      break;
+    }
+  }
+  freeexp(fs, exp);
+}
+
+
+void luaK_self (FuncState *fs, expdesc *e, expdesc *key) {
+  int func;
+  luaK_exp2anyreg(fs, e);
+  freeexp(fs, e);
+  func = fs->freereg;
+  luaK_reserveregs(fs, 2);
+  luaK_codeABC(fs, OP_SELF, func, e->info, luaK_exp2RK(fs, key));
+  freeexp(fs, key);
+  e->info = func;
+  e->k = VNONRELOC;
+}
+
+
+static void invertjump (FuncState *fs, expdesc *e) {
+  Instruction *pc = getjumpcontrol(fs, e->info);
+  lua_assert(testOpMode(GET_OPCODE(*pc), OpModeT) &&
+             GET_OPCODE(*pc) != OP_TEST);
+  SETARG_A(*pc, !(GETARG_A(*pc)));
+}
+
+
+static int jumponcond (FuncState *fs, expdesc *e, int cond) {
+  if (e->k == VRELOCABLE) {
+    Instruction ie = getcode(fs, e);
+    if (GET_OPCODE(ie) == OP_NOT) {
+      fs->pc--;  /* remove previous OP_NOT */
+      return luaK_condjump(fs, OP_TEST, NO_REG, GETARG_B(ie), !cond);
+    }
+    /* else go through */
+  }
+  discharge2anyreg(fs, e);
+  freeexp(fs, e);
+  return luaK_condjump(fs, OP_TEST, NO_REG, e->info, cond);
+}
+
+
+void luaK_goiftrue (FuncState *fs, expdesc *e) {
+  int pc;  /* pc of last jump */
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VK: case VTRUE: {
+      pc = NO_JUMP;  /* always true; do nothing */
+      break;
+    }
+    case VFALSE: {
+      pc = luaK_jump(fs);  /* always jump */
+      break;
+    }
+    case VJMP: {
+      invertjump(fs, e);
+      pc = e->info;
+      break;
+    }
+    default: {
+      pc = jumponcond(fs, e, 0);
+      break;
+    }
+  }
+  luaK_concat(fs, &e->f, pc);  /* insert last jump in `f' list */
+}
+
+
+void luaK_goiffalse (FuncState *fs, expdesc *e) {
+  int pc;  /* pc of last jump */
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VNIL: case VFALSE: {
+      pc = NO_JUMP;  /* always false; do nothing */
+      break;
+    }
+    case VTRUE: {
+      pc = luaK_jump(fs);  /* always jump */
+      break;
+    }
+    case VJMP: {
+      pc = e->info;
+      break;
+    }
+    default: {
+      pc = jumponcond(fs, e, 1);
+      break;
+    }
+  }
+  luaK_concat(fs, &e->t, pc);  /* insert last jump in `t' list */
+}
+
+
+static void codenot (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VNIL: case VFALSE: {
+      e->k = VTRUE;
+      break;
+    }
+    case VK: case VTRUE: {
+      e->k = VFALSE;
+      break;
+    }
+    case VJMP: {
+      invertjump(fs, e);
+      break;
+    }
+    case VRELOCABLE:
+    case VNONRELOC: {
+      discharge2anyreg(fs, e);
+      freeexp(fs, e);
+      e->info = luaK_codeABC(fs, OP_NOT, 0, e->info, 0);
+      e->k = VRELOCABLE;
+      break;
+    }
+    default: {
+      lua_assert(0);  /* cannot happen */
+      break;
+    }
+  }
+  /* interchange true and false lists */
+  { int temp = e->f; e->f = e->t; e->t = temp; }
+}
+
+
+void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {
+  t->aux = luaK_exp2RK(fs, k);
+  t->k = VINDEXED;
+}
+
+
+void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e) {
+  if (op == OPR_MINUS) {
+    luaK_exp2val(fs, e);
+    if (e->k == VK && ttisnumber(&fs->f->k[e->info]))
+      e->info = luaK_numberK(fs, -nvalue(&fs->f->k[e->info]));
+    else {
+      luaK_exp2anyreg(fs, e);
+      freeexp(fs, e);
+      e->info = luaK_codeABC(fs, OP_UNM, 0, e->info, 0);
+      e->k = VRELOCABLE;
+    }
+  }
+  else  /* op == NOT */
+    codenot(fs, e);
+}
+
+
+void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
+  switch (op) {
+    case OPR_AND: {
+      luaK_goiftrue(fs, v);
+      luaK_patchtohere(fs, v->t);
+      v->t = NO_JUMP;
+      break;
+    }
+    case OPR_OR: {
+      luaK_goiffalse(fs, v);
+      luaK_patchtohere(fs, v->f);
+      v->f = NO_JUMP;
+      break;
+    }
+    case OPR_CONCAT: {
+      luaK_exp2nextreg(fs, v);  /* operand must be on the `stack' */
+      break;
+    }
+    default: {
+      luaK_exp2RK(fs, v);
+      break;
+    }
+  }
+}
+
+
+static void codebinop (FuncState *fs, expdesc *res, BinOpr op,
+                       int o1, int o2) {
+  if (op <= OPR_POW) {  /* arithmetic operator? */
+    OpCode opc = cast(OpCode, (op - OPR_ADD) + OP_ADD);  /* ORDER OP */
+    res->info = luaK_codeABC(fs, opc, 0, o1, o2);
+    res->k = VRELOCABLE;
+  }
+  else {  /* test operator */
+    static const OpCode ops[] = {OP_EQ, OP_EQ, OP_LT, OP_LE, OP_LT, OP_LE};
+    int cond = 1;
+    if (op >= OPR_GT) {  /* `>' or `>='? */
+      int temp;  /* exchange args and replace by `<' or `<=' */
+      temp = o1; o1 = o2; o2 = temp;  /* o1 <==> o2 */
+    }
+    else if (op == OPR_NE) cond = 0;
+    res->info = luaK_condjump(fs, ops[op - OPR_NE], cond, o1, o2);
+    res->k = VJMP;
+  }
+}
+
+
+void luaK_posfix (FuncState *fs, BinOpr op, expdesc *e1, expdesc *e2) {
+  switch (op) {
+    case OPR_AND: {
+      lua_assert(e1->t == NO_JUMP);  /* list must be closed */
+      luaK_dischargevars(fs, e2);
+      luaK_concat(fs, &e1->f, e2->f);
+      e1->k = e2->k; e1->info = e2->info; e1->aux = e2->aux; e1->t = e2->t;
+      break;
+    }
+    case OPR_OR: {
+      lua_assert(e1->f == NO_JUMP);  /* list must be closed */
+      luaK_dischargevars(fs, e2);
+      luaK_concat(fs, &e1->t, e2->t);
+      e1->k = e2->k; e1->info = e2->info; e1->aux = e2->aux; e1->f = e2->f;
+      break;
+    }
+    case OPR_CONCAT: {
+      luaK_exp2val(fs, e2);
+      if (e2->k == VRELOCABLE && GET_OPCODE(getcode(fs, e2)) == OP_CONCAT) {
+        lua_assert(e1->info == GETARG_B(getcode(fs, e2))-1);
+        freeexp(fs, e1);
+        SETARG_B(getcode(fs, e2), e1->info);
+        e1->k = e2->k; e1->info = e2->info;
+      }
+      else {
+        luaK_exp2nextreg(fs, e2);
+        freeexp(fs, e2);
+        freeexp(fs, e1);
+        e1->info = luaK_codeABC(fs, OP_CONCAT, 0, e1->info, e2->info);
+        e1->k = VRELOCABLE;
+      }
+      break;
+    }
+    default: {
+      int o1 = luaK_exp2RK(fs, e1);
+      int o2 = luaK_exp2RK(fs, e2);
+      freeexp(fs, e2);
+      freeexp(fs, e1);
+      codebinop(fs, e1, op, o1, o2);
+    }
+  }
+}
+
+
+void luaK_fixline (FuncState *fs, int line) {
+  fs->f->lineinfo[fs->pc - 1] = line;
+}
+
+
+int luaK_code (FuncState *fs, Instruction i, int line) {
+  Proto *f = fs->f;
+  luaK_dischargejpc(fs);  /* `pc' will change */
+  /* put new instruction in code array */
+  luaM_growvector(fs->L, f->code, fs->pc, f->sizecode, Instruction,
+                  MAX_INT, "code size overflow");
+  f->code[fs->pc] = i;
+  /* save corresponding line information */
+  luaM_growvector(fs->L, f->lineinfo, fs->pc, f->sizelineinfo, int,
+                  MAX_INT, "code size overflow");
+  f->lineinfo[fs->pc] = line;
+  return fs->pc++;
+}
+
+
+int luaK_codeABC (FuncState *fs, OpCode o, int a, int b, int c) {
+  lua_assert(getOpMode(o) == iABC);
+  return luaK_code(fs, CREATE_ABC(o, a, b, c), fs->ls->lastline);
+}
+
+
+int luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {
+  lua_assert(getOpMode(o) == iABx || getOpMode(o) == iAsBx);
+  return luaK_code(fs, CREATE_ABx(o, a, bc), fs->ls->lastline);
+}
+

Added: trunk/source/libraries/lua/lcode.h
===================================================================
--- trunk/source/libraries/lua/lcode.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lcode.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,74 @@
+/*
+** $Id: lcode.h,v 1.38 2002/12/11 12:34:22 roberto Exp $
+** Code generator for Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lcode_h
+#define lcode_h
+
+#include "llex.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+
+
+/*
+** Marks the end of a patch list. It is an invalid value both as an absolute
+** address, and as a list link (would link an element to itself).
+*/
+#define NO_JUMP (-1)
+
+
+/*
+** grep "ORDER OPR" if you change these enums
+*/
+typedef enum BinOpr {
+  OPR_ADD, OPR_SUB, OPR_MULT, OPR_DIV, OPR_POW,
+  OPR_CONCAT,
+  OPR_NE, OPR_EQ,
+  OPR_LT, OPR_LE, OPR_GT, OPR_GE,
+  OPR_AND, OPR_OR,
+  OPR_NOBINOPR
+} BinOpr;
+
+#define binopistest(op)	((op) >= OPR_NE)
+
+typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_NOUNOPR } UnOpr;
+
+
+#define getcode(fs,e)	((fs)->f->code[(e)->info])
+
+#define luaK_codeAsBx(fs,o,A,sBx)	luaK_codeABx(fs,o,A,(sBx)+MAXARG_sBx)
+
+int luaK_code (FuncState *fs, Instruction i, int line);
+int luaK_codeABx (FuncState *fs, OpCode o, int A, unsigned int Bx);
+int luaK_codeABC (FuncState *fs, OpCode o, int A, int B, int C);
+void luaK_fixline (FuncState *fs, int line);
+void luaK_nil (FuncState *fs, int from, int n);
+void luaK_reserveregs (FuncState *fs, int n);
+void luaK_checkstack (FuncState *fs, int n);
+int luaK_stringK (FuncState *fs, TString *s);
+int luaK_numberK (FuncState *fs, lua_Number r);
+void luaK_dischargevars (FuncState *fs, expdesc *e);
+int luaK_exp2anyreg (FuncState *fs, expdesc *e);
+void luaK_exp2nextreg (FuncState *fs, expdesc *e);
+void luaK_exp2val (FuncState *fs, expdesc *e);
+int luaK_exp2RK (FuncState *fs, expdesc *e);
+void luaK_self (FuncState *fs, expdesc *e, expdesc *key);
+void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k);
+void luaK_goiftrue (FuncState *fs, expdesc *e);
+void luaK_goiffalse (FuncState *fs, expdesc *e);
+void luaK_storevar (FuncState *fs, expdesc *var, expdesc *e);
+void luaK_setcallreturns (FuncState *fs, expdesc *var, int nresults);
+int luaK_jump (FuncState *fs);
+void luaK_patchlist (FuncState *fs, int list, int target);
+void luaK_patchtohere (FuncState *fs, int list);
+void luaK_concat (FuncState *fs, int *l1, int l2);
+int luaK_getlabel (FuncState *fs);
+void luaK_prefix (FuncState *fs, UnOpr op, expdesc *v);
+void luaK_infix (FuncState *fs, BinOpr op, expdesc *v);
+void luaK_posfix (FuncState *fs, BinOpr op, expdesc *v1, expdesc *v2);
+
+
+#endif

Added: trunk/source/libraries/lua/ldebug.c
===================================================================
--- trunk/source/libraries/lua/ldebug.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ldebug.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,585 @@
+/*
+** $Id: ldebug.c,v 1.150 2003/03/19 21:24:04 roberto Exp $
+** Debug Interface
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+#include <string.h>
+
+#define ldebug_c
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "lcode.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lvm.h"
+
+
+
+static const char *getfuncname (CallInfo *ci, const char **name);
+
+
+#define isLua(ci)	(!((ci)->state & CI_C))
+
+
+static int currentpc (CallInfo *ci) {
+  if (!isLua(ci)) return -1;  /* function is not a Lua function? */
+  if (ci->state & CI_HASFRAME)  /* function has a frame? */
+    ci->u.l.savedpc = *ci->u.l.pc;  /* use `pc' from there */
+  /* function's pc is saved */
+  return pcRel(ci->u.l.savedpc, ci_func(ci)->l.p);
+}
+
+
+static int currentline (CallInfo *ci) {
+  int pc = currentpc(ci);
+  if (pc < 0)
+    return -1;  /* only active lua functions have current-line information */
+  else
+    return getline(ci_func(ci)->l.p, pc);
+}
+
+
+void luaG_inithooks (lua_State *L) {
+  CallInfo *ci;
+  for (ci = L->ci; ci != L->base_ci; ci--)  /* update all `savedpc's */
+    currentpc(ci);
+  L->hookinit = 1;
+}
+
+
+/*
+** this function can be called asynchronous (e.g. during a signal)
+*/
+LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
+  if (func == NULL || mask == 0) {  /* turn off hooks? */
+    mask = 0;
+    func = NULL;
+  }
+  L->hook = func;
+  L->basehookcount = count;
+  resethookcount(L);
+  L->hookmask = cast(lu_byte, mask);
+  L->hookinit = 0;
+  return 1;
+}
+
+
+LUA_API lua_Hook lua_gethook (lua_State *L) {
+  return L->hook;
+}
+
+
+LUA_API int lua_gethookmask (lua_State *L) {
+  return L->hookmask;
+}
+
+
+LUA_API int lua_gethookcount (lua_State *L) {
+  return L->basehookcount;
+}
+
+
+LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {
+  int status;
+  CallInfo *ci;
+  lua_lock(L);
+  for (ci = L->ci; level > 0 && ci > L->base_ci; ci--) {
+    level--;
+    if (!(ci->state & CI_C))  /* Lua function? */
+      level -= ci->u.l.tailcalls;  /* skip lost tail calls */
+  }
+  if (level > 0 || ci == L->base_ci) status = 0;  /* there is no such level */
+  else if (level < 0) {  /* level is of a lost tail call */
+    status = 1;
+    ar->i_ci = 0;
+  }
+  else {
+    status = 1;
+    ar->i_ci = ci - L->base_ci;
+  }
+  lua_unlock(L);
+  return status;
+}
+
+
+static Proto *getluaproto (CallInfo *ci) {
+  return (isLua(ci) ? ci_func(ci)->l.p : NULL);
+}
+
+
+LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {
+  const char *name;
+  CallInfo *ci;
+  Proto *fp;
+  lua_lock(L);
+  name = NULL;
+  ci = L->base_ci + ar->i_ci;
+  fp = getluaproto(ci);
+  if (fp) {  /* is a Lua function? */
+    name = luaF_getlocalname(fp, n, currentpc(ci));
+    if (name)
+      luaA_pushobject(L, ci->base+(n-1));  /* push value */
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {
+  const char *name;
+  CallInfo *ci;
+  Proto *fp;
+  lua_lock(L);
+  name = NULL;
+  ci = L->base_ci + ar->i_ci;
+  fp = getluaproto(ci);
+  L->top--;  /* pop new value */
+  if (fp) {  /* is a Lua function? */
+    name = luaF_getlocalname(fp, n, currentpc(ci));
+    if (!name || name[0] == '(')  /* `(' starts private locals */
+      name = NULL;
+    else
+      setobjs2s(ci->base+(n-1), L->top);
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+static void funcinfo (lua_Debug *ar, StkId func) {
+  Closure *cl = clvalue(func);
+  if (cl->c.isC) {
+    ar->source = "=[C]";
+    ar->linedefined = -1;
+    ar->what = "C";
+  }
+  else {
+    ar->source = getstr(cl->l.p->source);
+    ar->linedefined = cl->l.p->lineDefined;
+    ar->what = (ar->linedefined == 0) ? "main" : "Lua";
+  }
+  luaO_chunkid(ar->short_src, ar->source, LUA_IDSIZE);
+}
+
+
+static const char *travglobals (lua_State *L, const TObject *o) {
+  Table *g = hvalue(gt(L));
+  int i = sizenode(g);
+  while (i--) {
+    Node *n = gnode(g, i);
+    if (luaO_rawequalObj(o, gval(n)) && ttisstring(gkey(n)))
+      return getstr(tsvalue(gkey(n)));
+  }
+  return NULL;
+}
+
+
+static void info_tailcall (lua_State *L, lua_Debug *ar) {
+  ar->name = ar->namewhat = "";
+  ar->what = "tail";
+  ar->linedefined = ar->currentline = -1;
+  ar->source = "=(tail call)";
+  luaO_chunkid(ar->short_src, ar->source, LUA_IDSIZE);
+  ar->nups = 0;
+  setnilvalue(L->top);
+}
+
+
+static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
+                    StkId f, CallInfo *ci) {
+  int status = 1;
+  for (; *what; what++) {
+    switch (*what) {
+      case 'S': {
+        funcinfo(ar, f);
+        break;
+      }
+      case 'l': {
+        ar->currentline = (ci) ? currentline(ci) : -1;
+        break;
+      }
+      case 'u': {
+        ar->nups = clvalue(f)->c.nupvalues;
+        break;
+      }
+      case 'n': {
+        ar->namewhat = (ci) ? getfuncname(ci, &ar->name) : NULL;
+        if (ar->namewhat == NULL) {
+          /* try to find a global name */
+          if ((ar->name = travglobals(L, f)) != NULL)
+            ar->namewhat = "global";
+          else ar->namewhat = "";  /* not found */
+        }
+        break;
+      }
+      case 'f': {
+        setobj2s(L->top, f);
+        break;
+      }
+      default: status = 0;  /* invalid option */
+    }
+  }
+  return status;
+}
+
+
+LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
+  int status = 1;
+  lua_lock(L);
+  if (*what == '>') {
+    StkId f = L->top - 1;
+    if (!ttisfunction(f))
+      luaG_runerror(L, "value for `lua_getinfo' is not a function");
+    status = auxgetinfo(L, what + 1, ar, f, NULL);
+    L->top--;  /* pop function */
+  }
+  else if (ar->i_ci != 0) {  /* no tail call? */
+    CallInfo *ci = L->base_ci + ar->i_ci;
+    lua_assert(ttisfunction(ci->base - 1));
+    status = auxgetinfo(L, what, ar, ci->base - 1, ci);
+  }
+  else
+    info_tailcall(L, ar);
+  if (strchr(what, 'f')) incr_top(L);
+  lua_unlock(L);
+  return status;
+}
+
+
+/*
+** {======================================================
+** Symbolic Execution and code checker
+** =======================================================
+*/
+
+#define check(x)		if (!(x)) return 0;
+
+#define checkjump(pt,pc)	check(0 <= pc && pc < pt->sizecode)
+
+#define checkreg(pt,reg)	check((reg) < (pt)->maxstacksize)
+
+
+
+static int precheck (const Proto *pt) {
+  check(pt->maxstacksize <= MAXSTACK);
+  check(pt->sizelineinfo == pt->sizecode || pt->sizelineinfo == 0);
+  lua_assert(pt->numparams+pt->is_vararg <= pt->maxstacksize);
+  check(GET_OPCODE(pt->code[pt->sizecode-1]) == OP_RETURN);
+  return 1;
+}
+
+
+static int checkopenop (const Proto *pt, int pc) {
+  Instruction i = pt->code[pc+1];
+  switch (GET_OPCODE(i)) {
+    case OP_CALL:
+    case OP_TAILCALL:
+    case OP_RETURN: {
+      check(GETARG_B(i) == 0);
+      return 1;
+    }
+    case OP_SETLISTO: return 1;
+    default: return 0;  /* invalid instruction after an open call */
+  }
+}
+
+
+static int checkRK (const Proto *pt, int r) {
+  return (r < pt->maxstacksize || (r >= MAXSTACK && r-MAXSTACK < pt->sizek));
+}
+
+
+static Instruction luaG_symbexec (const Proto *pt, int lastpc, int reg) {
+  int pc;
+  int last;  /* stores position of last instruction that changed `reg' */
+  last = pt->sizecode-1;  /* points to final return (a `neutral' instruction) */
+  check(precheck(pt));
+  for (pc = 0; pc < lastpc; pc++) {
+    const Instruction i = pt->code[pc];
+    OpCode op = GET_OPCODE(i);
+    int a = GETARG_A(i);
+    int b = 0;
+    int c = 0;
+    checkreg(pt, a);
+    switch (getOpMode(op)) {
+      case iABC: {
+        b = GETARG_B(i);
+        c = GETARG_C(i);
+        if (testOpMode(op, OpModeBreg)) {
+          checkreg(pt, b);
+        }
+        else if (testOpMode(op, OpModeBrk))
+          check(checkRK(pt, b));
+        if (testOpMode(op, OpModeCrk))
+          check(checkRK(pt, c));
+        break;
+      }
+      case iABx: {
+        b = GETARG_Bx(i);
+        if (testOpMode(op, OpModeK)) check(b < pt->sizek);
+        break;
+      }
+      case iAsBx: {
+        b = GETARG_sBx(i);
+        break;
+      }
+    }
+    if (testOpMode(op, OpModesetA)) {
+      if (a == reg) last = pc;  /* change register `a' */
+    }
+    if (testOpMode(op, OpModeT)) {
+      check(pc+2 < pt->sizecode);  /* check skip */
+      check(GET_OPCODE(pt->code[pc+1]) == OP_JMP);
+    }
+    switch (op) {
+      case OP_LOADBOOL: {
+        check(c == 0 || pc+2 < pt->sizecode);  /* check its jump */
+        break;
+      }
+      case OP_LOADNIL: {
+        if (a <= reg && reg <= b)
+          last = pc;  /* set registers from `a' to `b' */
+        break;
+      }
+      case OP_GETUPVAL:
+      case OP_SETUPVAL: {
+        check(b < pt->nups);
+        break;
+      }
+      case OP_GETGLOBAL:
+      case OP_SETGLOBAL: {
+        check(ttisstring(&pt->k[b]));
+        break;
+      }
+      case OP_SELF: {
+        checkreg(pt, a+1);
+        if (reg == a+1) last = pc;
+        break;
+      }
+      case OP_CONCAT: {
+        /* `c' is a register, and at least two operands */
+        check(c < MAXSTACK && b < c);
+        break;
+      }
+      case OP_TFORLOOP:
+        checkreg(pt, a+c+5);
+        if (reg >= a) last = pc;  /* affect all registers above base */
+        /* go through */
+      case OP_FORLOOP:
+        checkreg(pt, a+2);
+        /* go through */
+      case OP_JMP: {
+        int dest = pc+1+b;
+	check(0 <= dest && dest < pt->sizecode);
+        /* not full check and jump is forward and do not skip `lastpc'? */
+        if (reg != NO_REG && pc < dest && dest <= lastpc)
+          pc += b;  /* do the jump */
+        break;
+      }
+      case OP_CALL:
+      case OP_TAILCALL: {
+        if (b != 0) {
+          checkreg(pt, a+b-1);
+        }
+        c--;  /* c = num. returns */
+        if (c == LUA_MULTRET) {
+          check(checkopenop(pt, pc));
+        }
+        else if (c != 0)
+          checkreg(pt, a+c-1);
+        if (reg >= a) last = pc;  /* affect all registers above base */
+        break;
+      }
+      case OP_RETURN: {
+        b--;  /* b = num. returns */
+        if (b > 0) checkreg(pt, a+b-1);
+        break;
+      }
+      case OP_SETLIST: {
+        checkreg(pt, a + (b&(LFIELDS_PER_FLUSH-1)) + 1);
+        break;
+      }
+      case OP_CLOSURE: {
+        int nup;
+        check(b < pt->sizep);
+        nup = pt->p[b]->nups;
+        check(pc + nup < pt->sizecode);
+        for (; nup>0; nup--) {
+          OpCode op1 = GET_OPCODE(pt->code[pc+nup]);
+          check(op1 == OP_GETUPVAL || op1 == OP_MOVE);
+        }
+        break;
+      }
+      default: break;
+    }
+  }
+  return pt->code[last];
+}
+
+#undef check
+#undef checkjump
+#undef checkreg
+
+/* }====================================================== */
+
+
+int luaG_checkcode (const Proto *pt) {
+  return luaG_symbexec(pt, pt->sizecode, NO_REG);
+}
+
+
+static const char *kname (Proto *p, int c) {
+  c = c - MAXSTACK;
+  if (c >= 0 && ttisstring(&p->k[c]))
+    return svalue(&p->k[c]);
+  else
+    return "?";
+}
+
+
+static const char *getobjname (CallInfo *ci, int stackpos, const char **name) {
+  if (isLua(ci)) {  /* a Lua function? */
+    Proto *p = ci_func(ci)->l.p;
+    int pc = currentpc(ci);
+    Instruction i;
+    *name = luaF_getlocalname(p, stackpos+1, pc);
+    if (*name)  /* is a local? */
+      return "local";
+    i = luaG_symbexec(p, pc, stackpos);  /* try symbolic execution */
+    lua_assert(pc != -1);
+    switch (GET_OPCODE(i)) {
+      case OP_GETGLOBAL: {
+        int g = GETARG_Bx(i);  /* global index */
+        lua_assert(ttisstring(&p->k[g]));
+        *name = svalue(&p->k[g]);
+        return "global";
+      }
+      case OP_MOVE: {
+        int a = GETARG_A(i);
+        int b = GETARG_B(i);  /* move from `b' to `a' */
+        if (b < a)
+          return getobjname(ci, b, name);  /* get name for `b' */
+        break;
+      }
+      case OP_GETTABLE: {
+        int k = GETARG_C(i);  /* key index */
+        *name = kname(p, k);
+        return "field";
+      }
+      case OP_SELF: {
+        int k = GETARG_C(i);  /* key index */
+        *name = kname(p, k);
+        return "method";
+      }
+      default: break;
+    }
+  }
+  return NULL;  /* no useful name found */
+}
+
+
+static const char *getfuncname (CallInfo *ci, const char **name) {
+  Instruction i;
+  if ((isLua(ci) && ci->u.l.tailcalls > 0) || !isLua(ci - 1))
+    return NULL;  /* calling function is not Lua (or is unknown) */
+  ci--;  /* calling function */
+  i = ci_func(ci)->l.p->code[currentpc(ci)];
+  if (GET_OPCODE(i) == OP_CALL || GET_OPCODE(i) == OP_TAILCALL)
+    return getobjname(ci, GETARG_A(i), name);
+  else
+    return NULL;  /* no useful name can be found */
+}
+
+
+/* only ANSI way to check whether a pointer points to an array */
+static int isinstack (CallInfo *ci, const TObject *o) {
+  StkId p;
+  for (p = ci->base; p < ci->top; p++)
+    if (o == p) return 1;
+  return 0;
+}
+
+
+void luaG_typeerror (lua_State *L, const TObject *o, const char *op) {
+  const char *name = NULL;
+  const char *t = luaT_typenames[ttype(o)];
+  const char *kind = (isinstack(L->ci, o)) ?
+                         getobjname(L->ci, o - L->base, &name) : NULL;
+  if (kind)
+    luaG_runerror(L, "attempt to %s %s `%s' (a %s value)",
+                op, kind, name, t);
+  else
+    luaG_runerror(L, "attempt to %s a %s value", op, t);
+}
+
+
+void luaG_concaterror (lua_State *L, StkId p1, StkId p2) {
+  if (ttisstring(p1)) p1 = p2;
+  lua_assert(!ttisstring(p1));
+  luaG_typeerror(L, p1, "concatenate");
+}
+
+
+void luaG_aritherror (lua_State *L, const TObject *p1, const TObject *p2) {
+  TObject temp;
+  if (luaV_tonumber(p1, &temp) == NULL)
+    p2 = p1;  /* first operand is wrong */
+  luaG_typeerror(L, p2, "perform arithmetic on");
+}
+
+
+int luaG_ordererror (lua_State *L, const TObject *p1, const TObject *p2) {
+  const char *t1 = luaT_typenames[ttype(p1)];
+  const char *t2 = luaT_typenames[ttype(p2)];
+  if (t1[2] == t2[2])
+    luaG_runerror(L, "attempt to compare two %s values", t1);
+  else
+    luaG_runerror(L, "attempt to compare %s with %s", t1, t2);
+  return 0;
+}
+
+
+static void addinfo (lua_State *L, const char *msg) {
+  CallInfo *ci = L->ci;
+  if (isLua(ci)) {  /* is Lua code? */
+    char buff[LUA_IDSIZE];  /* add file:line information */
+    int line = currentline(ci);
+    luaO_chunkid(buff, getstr(getluaproto(ci)->source), LUA_IDSIZE);
+    luaO_pushfstring(L, "%s:%d: %s", buff, line, msg);
+  }
+}
+
+
+void luaG_errormsg (lua_State *L) {
+  if (L->errfunc != 0) {  /* is there an error handling function? */
+    StkId errfunc = restorestack(L, L->errfunc);
+    if (!ttisfunction(errfunc)) luaD_throw(L, LUA_ERRERR);
+    setobjs2s(L->top, L->top - 1);  /* move argument */
+    setobjs2s(L->top - 1, errfunc);  /* push function */
+    incr_top(L);
+    luaD_call(L, L->top - 2, 1);  /* call it */
+  }
+  luaD_throw(L, LUA_ERRRUN);
+}
+
+
+void luaG_runerror (lua_State *L, const char *fmt, ...) {
+  va_list argp;
+  va_start(argp, fmt);
+  addinfo(L, luaO_pushvfstring(L, fmt, argp));
+  va_end(argp);
+  luaG_errormsg(L);
+}
+

Added: trunk/source/libraries/lua/ldebug.h
===================================================================
--- trunk/source/libraries/lua/ldebug.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ldebug.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,31 @@
+/*
+** $Id: ldebug.h,v 1.32 2002/11/18 11:01:55 roberto Exp $
+** Auxiliary functions from Debug Interface module
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ldebug_h
+#define ldebug_h
+
+
+#include "lstate.h"
+
+
+#define pcRel(pc, p)	(cast(int, (pc) - (p)->code) - 1)
+
+#define getline(f,pc)	(((f)->lineinfo) ? (f)->lineinfo[pc] : 0)
+
+#define resethookcount(L)	(L->hookcount = L->basehookcount)
+
+
+void luaG_inithooks (lua_State *L);
+void luaG_typeerror (lua_State *L, const TObject *o, const char *opname);
+void luaG_concaterror (lua_State *L, StkId p1, StkId p2);
+void luaG_aritherror (lua_State *L, const TObject *p1, const TObject *p2);
+int luaG_ordererror (lua_State *L, const TObject *p1, const TObject *p2);
+void luaG_runerror (lua_State *L, const char *fmt, ...);
+void luaG_errormsg (lua_State *L);
+int luaG_checkcode (const Proto *pt);
+
+
+#endif

Added: trunk/source/libraries/lua/ldo.c
===================================================================
--- trunk/source/libraries/lua/ldo.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ldo.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,458 @@
+/*
+** $Id: ldo.c,v 1.217 2003/04/03 13:35:34 roberto Exp $
+** Stack and Call structure of Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#include <setjmp.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define ldo_c
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lundump.h"
+#include "lvm.h"
+#include "lzio.h"
+
+
+
+
+/*
+** {======================================================
+** Error-recovery functions (based on long jumps)
+** =======================================================
+*/
+
+
+/* chain list of long jump buffers */
+struct lua_longjmp {
+  struct lua_longjmp *previous;
+  jmp_buf b;
+  volatile int status;  /* error code */
+};
+
+
+static void seterrorobj (lua_State *L, int errcode, StkId oldtop) {
+  switch (errcode) {
+    case LUA_ERRMEM: {
+      setsvalue2s(oldtop, luaS_new(L, MEMERRMSG));
+      break;
+    }
+    case LUA_ERRERR: {
+      setsvalue2s(oldtop, luaS_new(L, "error in error handling"));
+      break;
+    }
+    case LUA_ERRSYNTAX:
+    case LUA_ERRRUN: {
+      setobjs2s(oldtop, L->top - 1);  /* error message on current top */
+      break;
+    }
+  }
+  L->top = oldtop + 1;
+}
+
+
+void luaD_throw (lua_State *L, int errcode) {
+  if (L->errorJmp) {
+    L->errorJmp->status = errcode;
+    longjmp(L->errorJmp->b, 1);
+  }
+  else {
+    G(L)->panic(L);
+    exit(EXIT_FAILURE);
+  }
+}
+
+
+int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
+  struct lua_longjmp lj;
+  lj.status = 0;
+  lj.previous = L->errorJmp;  /* chain new error handler */
+  L->errorJmp = &lj;
+  if (setjmp(lj.b) == 0)
+    (*f)(L, ud);
+  L->errorJmp = lj.previous;  /* restore old error handler */
+  return lj.status;
+}
+
+
+static void restore_stack_limit (lua_State *L) {
+  L->stack_last = L->stack+L->stacksize-1;
+  if (L->size_ci > LUA_MAXCALLS) {  /* there was an overflow? */
+    int inuse = (L->ci - L->base_ci);
+    if (inuse + 1 < LUA_MAXCALLS)  /* can `undo' overflow? */
+      luaD_reallocCI(L, LUA_MAXCALLS);
+  }
+}
+
+/* }====================================================== */
+
+
+static void correctstack (lua_State *L, TObject *oldstack) {
+  CallInfo *ci;
+  GCObject *up;
+  L->top = (L->top - oldstack) + L->stack;
+  for (up = L->openupval; up != NULL; up = up->gch.next)
+    gcotouv(up)->v = (gcotouv(up)->v - oldstack) + L->stack;
+  for (ci = L->base_ci; ci <= L->ci; ci++) {
+    ci->top = (ci->top - oldstack) + L->stack;
+    ci->base = (ci->base - oldstack) + L->stack;
+  }
+  L->base = L->ci->base;
+}
+
+
+void luaD_reallocstack (lua_State *L, int newsize) {
+  TObject *oldstack = L->stack;
+  luaM_reallocvector(L, L->stack, L->stacksize, newsize, TObject);
+  L->stacksize = newsize;
+  L->stack_last = L->stack+newsize-1-EXTRA_STACK;
+  correctstack(L, oldstack);
+}
+
+
+void luaD_reallocCI (lua_State *L, int newsize) {
+  CallInfo *oldci = L->base_ci;
+  luaM_reallocvector(L, L->base_ci, L->size_ci, newsize, CallInfo);
+  L->size_ci = cast(unsigned short, newsize);
+  L->ci = (L->ci - oldci) + L->base_ci;
+  L->end_ci = L->base_ci + L->size_ci;
+}
+
+
+void luaD_growstack (lua_State *L, int n) {
+  if (n <= L->stacksize)  /* double size is enough? */
+    luaD_reallocstack(L, 2*L->stacksize);
+  else
+    luaD_reallocstack(L, L->stacksize + n + EXTRA_STACK);
+}
+
+
+static void luaD_growCI (lua_State *L) {
+  if (L->size_ci > LUA_MAXCALLS)  /* overflow while handling overflow? */
+    luaD_throw(L, LUA_ERRERR);
+  else {
+    luaD_reallocCI(L, 2*L->size_ci);
+    if (L->size_ci > LUA_MAXCALLS)
+      luaG_runerror(L, "stack overflow");
+  }
+}
+
+
+void luaD_callhook (lua_State *L, int event, int line) {
+  lua_Hook hook = L->hook;
+  if (hook && L->allowhook) {
+    ptrdiff_t top = savestack(L, L->top);
+    ptrdiff_t ci_top = savestack(L, L->ci->top);
+    lua_Debug ar;
+    ar.event = event;
+    ar.currentline = line;
+    if (event == LUA_HOOKTAILRET)
+      ar.i_ci = 0;  /* tail call; no debug information about it */
+    else
+      ar.i_ci = L->ci - L->base_ci;
+    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
+    L->ci->top = L->top + LUA_MINSTACK;
+    L->allowhook = 0;  /* cannot call hooks inside a hook */
+    lua_unlock(L);
+    (*hook)(L, &ar);
+    lua_lock(L);
+    lua_assert(!L->allowhook);
+    L->allowhook = 1;
+    L->ci->top = restorestack(L, ci_top);
+    L->top = restorestack(L, top);
+  }
+}
+
+
+static void adjust_varargs (lua_State *L, int nfixargs, StkId base) {
+  int i;
+  Table *htab;
+  TObject nname;
+  int actual = L->top - base;  /* actual number of arguments */
+  if (actual < nfixargs) {
+    luaD_checkstack(L, nfixargs - actual);
+    for (; actual < nfixargs; ++actual)
+      setnilvalue(L->top++);
+  }
+  actual -= nfixargs;  /* number of extra arguments */
+  htab = luaH_new(L, actual, 1);  /* create `arg' table */
+  for (i=0; i<actual; i++)  /* put extra arguments into `arg' table */
+    setobj2n(luaH_setnum(L, htab, i+1), L->top - actual + i);
+  /* store counter in field `n' */
+  setsvalue(&nname, luaS_newliteral(L, "n"));
+  setnvalue(luaH_set(L, htab, &nname), cast(lua_Number, actual));
+  L->top -= actual;  /* remove extra elements from the stack */
+  sethvalue(L->top, htab);
+  incr_top(L);
+}
+
+
+static StkId tryfuncTM (lua_State *L, StkId func) {
+  const TObject *tm = luaT_gettmbyobj(L, func, TM_CALL);
+  StkId p;
+  ptrdiff_t funcr = savestack(L, func);
+  if (!ttisfunction(tm))
+    luaG_typeerror(L, func, "call");
+  /* Open a hole inside the stack at `func' */
+  for (p = L->top; p > func; p--) setobjs2s(p, p-1);
+  incr_top(L);
+  func = restorestack(L, funcr);  /* previous call may change stack */
+  setobj2s(func, tm);  /* tag method is the new function to be called */
+  return func;
+}
+
+
+StkId luaD_precall (lua_State *L, StkId func) {
+  LClosure *cl;
+  ptrdiff_t funcr = savestack(L, func);
+  if (!ttisfunction(func)) /* `func' is not a function? */
+    func = tryfuncTM(L, func);  /* check the `function' tag method */
+  if (L->ci + 1 == L->end_ci) luaD_growCI(L);
+  else condhardstacktests(luaD_reallocCI(L, L->size_ci));
+  cl = &clvalue(func)->l;
+  if (!cl->isC) {  /* Lua function? prepare its call */
+    CallInfo *ci;
+    Proto *p = cl->p;
+    if (p->is_vararg)  /* varargs? */
+      adjust_varargs(L, p->numparams, func+1);
+    luaD_checkstack(L, p->maxstacksize);
+    ci = ++L->ci;  /* now `enter' new function */
+    L->base = L->ci->base = restorestack(L, funcr) + 1;
+    ci->top = L->base + p->maxstacksize;
+    ci->u.l.savedpc = p->code;  /* starting point */
+    ci->u.l.tailcalls = 0;
+    ci->state = CI_SAVEDPC;
+    while (L->top < ci->top)
+      setnilvalue(L->top++);
+    L->top = ci->top;
+    return NULL;
+  }
+  else {  /* if is a C function, call it */
+    CallInfo *ci;
+    int n;
+    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
+    ci = ++L->ci;  /* now `enter' new function */
+    L->base = L->ci->base = restorestack(L, funcr) + 1;
+    ci->top = L->top + LUA_MINSTACK;
+    ci->state = CI_C;  /* a C function */
+    if (L->hookmask & LUA_MASKCALL)
+      luaD_callhook(L, LUA_HOOKCALL, -1);
+    lua_unlock(L);
+#ifdef LUA_COMPATUPVALUES
+    lua_pushupvalues(L);
+#endif
+    n = (*clvalue(L->base - 1)->c.f)(L);  /* do the actual call */
+    lua_lock(L);
+    return L->top - n;
+  }
+}
+
+
+static StkId callrethooks (lua_State *L, StkId firstResult) {
+  ptrdiff_t fr = savestack(L, firstResult);  /* next call may change stack */
+  luaD_callhook(L, LUA_HOOKRET, -1);
+  if (!(L->ci->state & CI_C)) {  /* Lua function? */
+    while (L->ci->u.l.tailcalls--)  /* call hook for eventual tail calls */
+      luaD_callhook(L, LUA_HOOKTAILRET, -1);
+  }
+  return restorestack(L, fr);
+}
+
+
+void luaD_poscall (lua_State *L, int wanted, StkId firstResult) { 
+  StkId res;
+  if (L->hookmask & LUA_MASKRET)
+    firstResult = callrethooks(L, firstResult);
+  res = L->base - 1;  /* res == final position of 1st result */
+  L->ci--;
+  L->base = L->ci->base;  /* restore base */
+  /* move results to correct place */
+  while (wanted != 0 && firstResult < L->top) {
+    setobjs2s(res++, firstResult++);
+    wanted--;
+  }
+  while (wanted-- > 0)
+    setnilvalue(res++);
+  L->top = res;
+}
+
+
+/*
+** Call a function (C or Lua). The function to be called is at *func.
+** The arguments are on the stack, right after the function.
+** When returns, all the results are on the stack, starting at the original
+** function position.
+*/ 
+void luaD_call (lua_State *L, StkId func, int nResults) {
+  StkId firstResult;
+  lua_assert(!(L->ci->state & CI_CALLING));
+  if (++L->nCcalls >= LUA_MAXCCALLS) {
+    if (L->nCcalls == LUA_MAXCCALLS)
+      luaG_runerror(L, "C stack overflow");
+    else if (L->nCcalls >= (LUA_MAXCCALLS + (LUA_MAXCCALLS>>3)))
+      luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */
+  }
+  firstResult = luaD_precall(L, func);
+  if (firstResult == NULL)  /* is a Lua function? */
+    firstResult = luaV_execute(L);  /* call it */
+  luaD_poscall(L, nResults, firstResult);
+  L->nCcalls--;
+  luaC_checkGC(L);
+}
+
+
+static void resume (lua_State *L, void *ud) {
+  StkId firstResult;
+  int nargs = *cast(int *, ud);
+  CallInfo *ci = L->ci;
+  if (ci == L->base_ci) {  /* no activation record? */
+    if (nargs >= L->top - L->base)
+      luaG_runerror(L, "cannot resume dead coroutine");
+    luaD_precall(L, L->top - (nargs + 1));  /* start coroutine */
+  }
+  else if (ci->state & CI_YIELD) {  /* inside a yield? */
+    if (ci->state & CI_C) {  /* `common' yield? */
+      /* finish interrupted execution of `OP_CALL' */
+      int nresults;
+      lua_assert((ci-1)->state & CI_SAVEDPC);
+      lua_assert(GET_OPCODE(*((ci-1)->u.l.savedpc - 1)) == OP_CALL ||
+                 GET_OPCODE(*((ci-1)->u.l.savedpc - 1)) == OP_TAILCALL);
+      nresults = GETARG_C(*((ci-1)->u.l.savedpc - 1)) - 1;
+      luaD_poscall(L, nresults, L->top - nargs);  /* complete it */
+      if (nresults >= 0) L->top = L->ci->top;
+    }
+    else {  /* yielded inside a hook: just continue its execution */
+      ci->state &= ~CI_YIELD;
+    }
+  }
+  else
+    luaG_runerror(L, "cannot resume non-suspended coroutine");
+  firstResult = luaV_execute(L);
+  if (firstResult != NULL)   /* return? */
+    luaD_poscall(L, LUA_MULTRET, firstResult);  /* finalize this coroutine */
+}
+
+
+LUA_API int lua_resume (lua_State *L, int nargs) {
+  int status;
+  lu_byte old_allowhooks;
+  lua_lock(L);
+  old_allowhooks = L->allowhook;
+  lua_assert(L->errfunc == 0 && L->nCcalls == 0);
+  status = luaD_rawrunprotected(L, resume, &nargs);
+  if (status != 0) {  /* error? */
+    L->ci = L->base_ci;  /* go back to initial level */
+    L->base = L->ci->base;
+    L->nCcalls = 0;
+    luaF_close(L, L->base);  /* close eventual pending closures */
+    seterrorobj(L, status, L->base);
+    L->allowhook = old_allowhooks;
+    restore_stack_limit(L);
+  }
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_yield (lua_State *L, int nresults) {
+  CallInfo *ci;
+  lua_lock(L);
+  ci = L->ci;
+  if (L->nCcalls > 0)
+    luaG_runerror(L, "attempt to yield across metamethod/C-call boundary");
+  if (ci->state & CI_C) {  /* usual yield */
+    if ((ci-1)->state & CI_C)
+      luaG_runerror(L, "cannot yield a C function");
+    if (L->top - nresults > L->base) {  /* is there garbage in the stack? */
+      int i;
+      for (i=0; i<nresults; i++)  /* move down results */
+        setobjs2s(L->base + i, L->top - nresults + i);
+      L->top = L->base + nresults;
+    }
+  } /* else it's an yield inside a hook: nothing to do */
+  ci->state |= CI_YIELD;
+  lua_unlock(L);
+  return -1;
+}
+
+
+int luaD_pcall (lua_State *L, Pfunc func, void *u,
+                ptrdiff_t old_top, ptrdiff_t ef) {
+  int status;
+  unsigned short oldnCcalls = L->nCcalls;
+  ptrdiff_t old_ci = saveci(L, L->ci);
+  lu_byte old_allowhooks = L->allowhook;
+  ptrdiff_t old_errfunc = L->errfunc;
+  L->errfunc = ef;
+  status = luaD_rawrunprotected(L, func, u);
+  if (status != 0) {  /* an error occurred? */
+    StkId oldtop = restorestack(L, old_top);
+    luaF_close(L, oldtop);  /* close eventual pending closures */
+    seterrorobj(L, status, oldtop);
+    L->nCcalls = oldnCcalls;
+    L->ci = restoreci(L, old_ci);
+    L->base = L->ci->base;
+    L->allowhook = old_allowhooks;
+    restore_stack_limit(L);
+  }
+  L->errfunc = old_errfunc;
+  return status;
+}
+
+
+
+/*
+** Execute a protected parser.
+*/
+struct SParser {  /* data to `f_parser' */
+  ZIO *z;
+  Mbuffer buff;  /* buffer to be used by the scanner */
+  int bin;
+};
+
+static void f_parser (lua_State *L, void *ud) {
+  struct SParser *p;
+  Proto *tf;
+  Closure *cl;
+  luaC_checkGC(L);
+  p = cast(struct SParser *, ud);
+  tf = p->bin ? luaU_undump(L, p->z, &p->buff) : luaY_parser(L, p->z, &p->buff);
+  cl = luaF_newLclosure(L, 0, gt(L));
+  cl->l.p = tf;
+  setclvalue(L->top, cl);
+  incr_top(L);
+}
+
+
+int luaD_protectedparser (lua_State *L, ZIO *z, int bin) {
+  struct SParser p;
+  int status;
+  ptrdiff_t oldtopr = savestack(L, L->top);  /* save current top */
+  p.z = z; p.bin = bin;
+  luaZ_initbuffer(L, &p.buff);
+  status = luaD_rawrunprotected(L, f_parser, &p);
+  luaZ_freebuffer(L, &p.buff);
+  if (status != 0) {  /* error? */
+    StkId oldtop = restorestack(L, oldtopr);
+    seterrorobj(L, status, oldtop);
+  }
+  return status;
+}
+
+

Added: trunk/source/libraries/lua/ldo.h
===================================================================
--- trunk/source/libraries/lua/ldo.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ldo.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,60 @@
+/*
+** $Id: ldo.h,v 1.56 2002/12/04 17:29:32 roberto Exp $
+** Stack and Call structure of Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ldo_h
+#define ldo_h
+
+
+#include "lobject.h"
+#include "lstate.h"
+#include "lzio.h"
+
+
+/*
+** macro to control inclusion of some hard tests on stack reallocation
+*/ 
+#ifndef HARDSTACKTESTS
+#define condhardstacktests(x)	{ /* empty */ }
+#else
+#define condhardstacktests(x)	x
+#endif
+
+
+#define luaD_checkstack(L,n)	\
+  if ((char *)L->stack_last - (char *)L->top <= (n)*(int)sizeof(TObject)) \
+    luaD_growstack(L, n); \
+  else condhardstacktests(luaD_reallocstack(L, L->stacksize));
+
+
+#define incr_top(L) {luaD_checkstack(L,1); L->top++;}
+
+#define savestack(L,p)		((char *)(p) - (char *)L->stack)
+#define restorestack(L,n)	((TObject *)((char *)L->stack + (n)))
+
+#define saveci(L,p)		((char *)(p) - (char *)L->base_ci)
+#define restoreci(L,n)		((CallInfo *)((char *)L->base_ci + (n)))
+
+
+/* type of protected functions, to be ran by `runprotected' */
+typedef void (*Pfunc) (lua_State *L, void *ud);
+
+void luaD_resetprotection (lua_State *L);
+int luaD_protectedparser (lua_State *L, ZIO *z, int bin);
+void luaD_callhook (lua_State *L, int event, int line);
+StkId luaD_precall (lua_State *L, StkId func);
+void luaD_call (lua_State *L, StkId func, int nResults);
+int luaD_pcall (lua_State *L, Pfunc func, void *u,
+                ptrdiff_t oldtop, ptrdiff_t ef);
+void luaD_poscall (lua_State *L, int wanted, StkId firstResult);
+void luaD_reallocCI (lua_State *L, int newsize);
+void luaD_reallocstack (lua_State *L, int newsize);
+void luaD_growstack (lua_State *L, int n);
+
+void luaD_throw (lua_State *L, int errcode);
+int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud);
+
+
+#endif

Added: trunk/source/libraries/lua/ldump.c
===================================================================
--- trunk/source/libraries/lua/ldump.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ldump.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,170 @@
+/*
+** $Id: ldump.c,v 1.4 2003/02/11 23:52:12 lhf Exp $
+** save bytecodes
+** See Copyright Notice in lua.h
+*/
+
+#include <stddef.h>
+
+#define ldump_c
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lstate.h"
+#include "lundump.h"
+
+#define DumpVector(b,n,size,D)	DumpBlock(b,(n)*(size),D)
+#define DumpLiteral(s,D)	DumpBlock("" s,(sizeof(s))-1,D)
+
+typedef struct {
+ lua_State* L;
+ lua_Chunkwriter write;
+ void* data;
+} DumpState;
+
+static void DumpBlock(const void* b, size_t size, DumpState* D)
+{
+ lua_unlock(D->L);
+ (*D->write)(D->L,b,size,D->data);
+ lua_lock(D->L);
+}
+
+static void DumpByte(int y, DumpState* D)
+{
+ char x=(char)y;
+ DumpBlock(&x,sizeof(x),D);
+}
+
+static void DumpInt(int x, DumpState* D)
+{
+ DumpBlock(&x,sizeof(x),D);
+}
+
+static void DumpSize(size_t x, DumpState* D)
+{
+ DumpBlock(&x,sizeof(x),D);
+}
+
+static void DumpNumber(lua_Number x, DumpState* D)
+{
+ DumpBlock(&x,sizeof(x),D);
+}
+
+static void DumpString(TString* s, DumpState* D)
+{
+ if (s==NULL || getstr(s)==NULL)
+  DumpSize(0,D);
+ else
+ {
+  size_t size=s->tsv.len+1;		/* include trailing '\0' */
+  DumpSize(size,D);
+  DumpBlock(getstr(s),size,D);
+ }
+}
+
+static void DumpCode(const Proto* f, DumpState* D)
+{
+ DumpInt(f->sizecode,D);
+ DumpVector(f->code,f->sizecode,sizeof(*f->code),D);
+}
+
+static void DumpLocals(const Proto* f, DumpState* D)
+{
+ int i,n=f->sizelocvars;
+ DumpInt(n,D);
+ for (i=0; i<n; i++)
+ {
+  DumpString(f->locvars[i].varname,D);
+  DumpInt(f->locvars[i].startpc,D);
+  DumpInt(f->locvars[i].endpc,D);
+ }
+}
+
+static void DumpLines(const Proto* f, DumpState* D)
+{
+ DumpInt(f->sizelineinfo,D);
+ DumpVector(f->lineinfo,f->sizelineinfo,sizeof(*f->lineinfo),D);
+}
+
+static void DumpUpvalues(const Proto* f, DumpState* D)
+{
+ int i,n=f->sizeupvalues;
+ DumpInt(n,D);
+ for (i=0; i<n; i++) DumpString(f->upvalues[i],D);
+}
+
+static void DumpFunction(const Proto* f, const TString* p, DumpState* D);
+
+static void DumpConstants(const Proto* f, DumpState* D)
+{
+ int i,n;
+ DumpInt(n=f->sizek,D);
+ for (i=0; i<n; i++)
+ {
+  const TObject* o=&f->k[i];
+  DumpByte(ttype(o),D);
+  switch (ttype(o))
+  {
+   case LUA_TNUMBER:
+	DumpNumber(nvalue(o),D);
+	break;
+   case LUA_TSTRING:
+	DumpString(tsvalue(o),D);
+	break;
+   case LUA_TNIL:
+	break;
+   default:
+	lua_assert(0);			/* cannot happen */
+	break;
+  }
+ }
+ DumpInt(n=f->sizep,D);
+ for (i=0; i<n; i++) DumpFunction(f->p[i],f->source,D);
+}
+
+static void DumpFunction(const Proto* f, const TString* p, DumpState* D)
+{
+ DumpString((f->source==p) ? NULL : f->source,D);
+ DumpInt(f->lineDefined,D);
+ DumpByte(f->nups,D);
+ DumpByte(f->numparams,D);
+ DumpByte(f->is_vararg,D);
+ DumpByte(f->maxstacksize,D);
+ DumpLines(f,D);
+ DumpLocals(f,D);
+ DumpUpvalues(f,D);
+ DumpConstants(f,D);
+ DumpCode(f,D);
+}
+
+static void DumpHeader(DumpState* D)
+{
+ DumpLiteral(LUA_SIGNATURE,D);
+ DumpByte(VERSION,D);
+ DumpByte(luaU_endianness(),D);
+ DumpByte(sizeof(int),D);
+ DumpByte(sizeof(size_t),D);
+ DumpByte(sizeof(Instruction),D);
+ DumpByte(SIZE_OP,D);
+ DumpByte(SIZE_A,D);
+ DumpByte(SIZE_B,D);
+ DumpByte(SIZE_C,D);
+ DumpByte(sizeof(lua_Number),D);
+ DumpNumber(TEST_NUMBER,D);
+}
+
+/*
+** dump function as precompiled chunk
+*/
+void luaU_dump (lua_State* L, const Proto* Main, lua_Chunkwriter w, void* data)
+{
+ DumpState D;
+ D.L=L;
+ D.write=w;
+ D.data=data;
+ DumpHeader(&D);
+ DumpFunction(Main,NULL,&D);
+}
+

Added: trunk/source/libraries/lua/lfunc.c
===================================================================
--- trunk/source/libraries/lua/lfunc.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lfunc.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,135 @@
+/*
+** $Id: lfunc.c,v 1.67 2003/03/18 12:50:04 roberto Exp $
+** Auxiliary functions to manipulate prototypes and closures
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+
+#define lfunc_c
+
+#include "lua.h"
+
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+
+
+#define sizeCclosure(n)	(cast(int, sizeof(CClosure)) + \
+                         cast(int, sizeof(TObject)*((n)-1)))
+
+#define sizeLclosure(n)	(cast(int, sizeof(LClosure)) + \
+                         cast(int, sizeof(TObject *)*((n)-1)))
+
+
+
+Closure *luaF_newCclosure (lua_State *L, int nelems) {
+  Closure *c = cast(Closure *, luaM_malloc(L, sizeCclosure(nelems)));
+  luaC_link(L, valtogco(c), LUA_TFUNCTION);
+  c->c.isC = 1;
+  c->c.nupvalues = cast(lu_byte, nelems);
+  return c;
+}
+
+
+Closure *luaF_newLclosure (lua_State *L, int nelems, TObject *e) {
+  Closure *c = cast(Closure *, luaM_malloc(L, sizeLclosure(nelems)));
+  luaC_link(L, valtogco(c), LUA_TFUNCTION);
+  c->l.isC = 0;
+  c->l.g = *e;
+  c->l.nupvalues = cast(lu_byte, nelems);
+  return c;
+}
+
+
+UpVal *luaF_findupval (lua_State *L, StkId level) {
+  GCObject **pp = &L->openupval;
+  UpVal *p;
+  UpVal *v;
+  while ((p = ngcotouv(*pp)) != NULL && p->v >= level) {
+    if (p->v == level) return p;
+    pp = &p->next;
+  }
+  v = luaM_new(L, UpVal);  /* not found: create a new one */
+  v->tt = LUA_TUPVAL;
+  v->marked = 1;  /* open upvalues should not be collected */
+  v->v = level;  /* current value lives in the stack */
+  v->next = *pp;  /* chain it in the proper position */
+  *pp = valtogco(v);
+  return v;
+}
+
+
+void luaF_close (lua_State *L, StkId level) {
+  UpVal *p;
+  while ((p = ngcotouv(L->openupval)) != NULL && p->v >= level) {
+    setobj(&p->value, p->v);  /* save current value (write barrier) */
+    p->v = &p->value;  /* now current value lives here */
+    L->openupval = p->next;  /* remove from `open' list */
+    luaC_link(L, valtogco(p), LUA_TUPVAL);
+  }
+}
+
+
+Proto *luaF_newproto (lua_State *L) {
+  Proto *f = luaM_new(L, Proto);
+  luaC_link(L, valtogco(f), LUA_TPROTO);
+  f->k = NULL;
+  f->sizek = 0;
+  f->p = NULL;
+  f->sizep = 0;
+  f->code = NULL;
+  f->sizecode = 0;
+  f->sizelineinfo = 0;
+  f->sizeupvalues = 0;
+  f->nups = 0;
+  f->upvalues = NULL;
+  f->numparams = 0;
+  f->is_vararg = 0;
+  f->maxstacksize = 0;
+  f->lineinfo = NULL;
+  f->sizelocvars = 0;
+  f->locvars = NULL;
+  f->lineDefined = 0;
+  f->source = NULL;
+  return f;
+}
+
+
+void luaF_freeproto (lua_State *L, Proto *f) {
+  luaM_freearray(L, f->code, f->sizecode, Instruction);
+  luaM_freearray(L, f->p, f->sizep, Proto *);
+  luaM_freearray(L, f->k, f->sizek, TObject);
+  luaM_freearray(L, f->lineinfo, f->sizelineinfo, int);
+  luaM_freearray(L, f->locvars, f->sizelocvars, struct LocVar);
+  luaM_freearray(L, f->upvalues, f->sizeupvalues, TString *);
+  luaM_freelem(L, f);
+}
+
+
+void luaF_freeclosure (lua_State *L, Closure *c) {
+  int size = (c->c.isC) ? sizeCclosure(c->c.nupvalues) :
+                          sizeLclosure(c->l.nupvalues);
+  luaM_free(L, c, size);
+}
+
+
+/*
+** Look for n-th local variable at line `line' in function `func'.
+** Returns NULL if not found.
+*/
+const char *luaF_getlocalname (const Proto *f, int local_number, int pc) {
+  int i;
+  for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {
+    if (pc < f->locvars[i].endpc) {  /* is variable active? */
+      local_number--;
+      if (local_number == 0)
+        return getstr(f->locvars[i].varname);
+    }
+  }
+  return NULL;  /* not found */
+}
+

Added: trunk/source/libraries/lua/lfunc.h
===================================================================
--- trunk/source/libraries/lua/lfunc.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lfunc.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,25 @@
+/*
+** $Id: lfunc.h,v 1.21 2003/03/18 12:50:04 roberto Exp $
+** Auxiliary functions to manipulate prototypes and closures
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lfunc_h
+#define lfunc_h
+
+
+#include "lobject.h"
+
+
+Proto *luaF_newproto (lua_State *L);
+Closure *luaF_newCclosure (lua_State *L, int nelems);
+Closure *luaF_newLclosure (lua_State *L, int nelems, TObject *e);
+UpVal *luaF_findupval (lua_State *L, StkId level);
+void luaF_close (lua_State *L, StkId level);
+void luaF_freeproto (lua_State *L, Proto *f);
+void luaF_freeclosure (lua_State *L, Closure *c);
+
+const char *luaF_getlocalname (const Proto *func, int local_number, int pc);
+
+
+#endif

Added: trunk/source/libraries/lua/lgc.c
===================================================================
--- trunk/source/libraries/lua/lgc.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lgc.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,493 @@
+/*
+** $Id: lgc.c,v 1.171 2003/04/03 13:35:34 roberto Exp $
+** Garbage Collector
+** See Copyright Notice in lua.h
+*/
+
+#include <string.h>
+
+#define lgc_c
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+
+
+typedef struct GCState {
+  GCObject *tmark;  /* list of marked objects to be traversed */
+  GCObject *wk;  /* list of traversed key-weak tables (to be cleared) */
+  GCObject *wv;  /* list of traversed value-weak tables */
+  GCObject *wkv;  /* list of traversed key-value weak tables */
+  global_State *g;
+} GCState;
+
+
+/*
+** some userful bit tricks
+*/
+#define setbit(x,b)	((x) |= (1<<(b)))
+#define resetbit(x,b)	((x) &= cast(lu_byte, ~(1<<(b))))
+#define testbit(x,b)	((x) & (1<<(b)))
+
+#define unmark(x)	resetbit((x)->gch.marked, 0)
+#define ismarked(x)	((x)->gch.marked & ((1<<4)|1))
+
+#define stringmark(s)	setbit((s)->tsv.marked, 0)
+
+
+#define isfinalized(u)		(!testbit((u)->uv.marked, 1))
+#define markfinalized(u)	resetbit((u)->uv.marked, 1)
+
+
+#define KEYWEAKBIT    1
+#define VALUEWEAKBIT  2
+#define KEYWEAK         (1<<KEYWEAKBIT)
+#define VALUEWEAK       (1<<VALUEWEAKBIT)
+
+
+
+#define markobject(st,o) { checkconsistency(o); \
+  if (iscollectable(o) && !ismarked(gcvalue(o))) reallymarkobject(st,gcvalue(o)); }
+
+#define condmarkobject(st,o,c) { checkconsistency(o); \
+  if (iscollectable(o) && !ismarked(gcvalue(o)) && (c)) \
+    reallymarkobject(st,gcvalue(o)); }
+
+#define markvalue(st,t) { if (!ismarked(valtogco(t))) \
+		reallymarkobject(st, valtogco(t)); }
+
+
+
+static void reallymarkobject (GCState *st, GCObject *o) {
+  lua_assert(!ismarked(o));
+  setbit(o->gch.marked, 0);  /* mark object */
+  switch (o->gch.tt) {
+    case LUA_TUSERDATA: {
+      markvalue(st, gcotou(o)->uv.metatable);
+      break;
+    }
+    case LUA_TFUNCTION: {
+      gcotocl(o)->c.gclist = st->tmark;
+      st->tmark = o;
+      break;
+    }
+    case LUA_TTABLE: {
+      gcotoh(o)->gclist = st->tmark;
+      st->tmark = o;
+      break;
+    }
+    case LUA_TTHREAD: {
+      gcototh(o)->gclist = st->tmark;
+      st->tmark = o;
+      break;
+    }
+    case LUA_TPROTO: {
+      gcotop(o)->gclist = st->tmark;
+      st->tmark = o;
+      break;
+    }
+    default: lua_assert(o->gch.tt == LUA_TSTRING);
+  }
+}
+
+
+static void marktmu (GCState *st) {
+  GCObject *u;
+  for (u = st->g->tmudata; u; u = u->gch.next) {
+    unmark(u);  /* may be marked, if left from previous GC */
+    reallymarkobject(st, u);
+  }
+}
+
+
+/* move `dead' udata that need finalization to list `tmudata' */
+void luaC_separateudata (lua_State *L) {
+  GCObject **p = &G(L)->rootudata;
+  GCObject *curr;
+  GCObject *collected = NULL;  /* to collect udata with gc event */
+  GCObject **lastcollected = &collected;
+  while ((curr = *p) != NULL) {
+    lua_assert(curr->gch.tt == LUA_TUSERDATA);
+    if (ismarked(curr) || isfinalized(gcotou(curr)))
+      p = &curr->gch.next;  /* don't bother with them */
+
+    else if (fasttm(L, gcotou(curr)->uv.metatable, TM_GC) == NULL) {
+      markfinalized(gcotou(curr));  /* don't need finalization */
+      p = &curr->gch.next;
+    }
+    else {  /* must call its gc method */
+      *p = curr->gch.next;
+      curr->gch.next = NULL;  /* link `curr' at the end of `collected' list */
+      *lastcollected = curr;
+      lastcollected = &curr->gch.next;
+    }
+  }
+  /* insert collected udata with gc event into `tmudata' list */
+  *lastcollected = G(L)->tmudata;
+  G(L)->tmudata = collected;
+}
+
+
+static void removekey (Node *n) {
+  setnilvalue(gval(n));  /* remove corresponding value ... */
+  if (iscollectable(gkey(n)))
+    setttype(gkey(n), LUA_TNONE);  /* dead key; remove it */
+}
+
+
+static void traversetable (GCState *st, Table *h) {
+  int i;
+  int weakkey = 0;
+  int weakvalue = 0;
+  const TObject *mode;
+  markvalue(st, h->metatable);
+  lua_assert(h->lsizenode || h->node == st->g->dummynode);
+  mode = gfasttm(st->g, h->metatable, TM_MODE);
+  if (mode && ttisstring(mode)) {  /* is there a weak mode? */
+    weakkey = (strchr(svalue(mode), 'k') != NULL);
+    weakvalue = (strchr(svalue(mode), 'v') != NULL);
+    if (weakkey || weakvalue) {  /* is really weak? */
+      GCObject **weaklist;
+      h->marked &= ~(KEYWEAK | VALUEWEAK);  /* clear bits */
+      h->marked |= cast(lu_byte, (weakkey << KEYWEAKBIT) |
+                                 (weakvalue << VALUEWEAKBIT));
+      weaklist = (weakkey && weakvalue) ? &st->wkv :
+                              (weakkey) ? &st->wk :
+                                          &st->wv;
+      h->gclist = *weaklist;  /* must be cleared after GC, ... */
+      *weaklist = valtogco(h);  /* ... so put in the appropriate list */
+    }
+  }
+  if (!weakvalue) {
+    i = h->sizearray;
+    while (i--)
+      markobject(st, &h->array[i]);
+  }
+  i = sizenode(h);
+  while (i--) {
+    Node *n = gnode(h, i);
+    if (!ttisnil(gval(n))) {
+      lua_assert(!ttisnil(gkey(n)));
+      condmarkobject(st, gkey(n), !weakkey);
+      condmarkobject(st, gval(n), !weakvalue);
+    }
+  }
+}
+
+
+static void traverseproto (GCState *st, Proto *f) {
+  int i;
+  stringmark(f->source);
+  for (i=0; i<f->sizek; i++) {  /* mark literal strings */
+    if (ttisstring(f->k+i))
+      stringmark(tsvalue(f->k+i));
+  }
+  for (i=0; i<f->sizeupvalues; i++)  /* mark upvalue names */
+    stringmark(f->upvalues[i]);
+  for (i=0; i<f->sizep; i++)  /* mark nested protos */
+    markvalue(st, f->p[i]);
+  for (i=0; i<f->sizelocvars; i++)  /* mark local-variable names */
+    stringmark(f->locvars[i].varname);
+  lua_assert(luaG_checkcode(f));
+}
+
+
+
+static void traverseclosure (GCState *st, Closure *cl) {
+  if (cl->c.isC) {
+    int i;
+    for (i=0; i<cl->c.nupvalues; i++)  /* mark its upvalues */
+      markobject(st, &cl->c.upvalue[i]);
+  }
+  else {
+    int i;
+    lua_assert(cl->l.nupvalues == cl->l.p->nups);
+    markvalue(st, hvalue(&cl->l.g));
+    markvalue(st, cl->l.p);
+    for (i=0; i<cl->l.nupvalues; i++) {  /* mark its upvalues */
+      UpVal *u = cl->l.upvals[i];
+      if (!u->marked) {
+        markobject(st, &u->value);
+        u->marked = 1;
+      }
+    }
+  }
+}
+
+
+static void checkstacksizes (lua_State *L, StkId max) {
+  int used = L->ci - L->base_ci;  /* number of `ci' in use */
+  if (4*used < L->size_ci && 2*BASIC_CI_SIZE < L->size_ci)
+    luaD_reallocCI(L, L->size_ci/2);  /* still big enough... */
+  else condhardstacktests(luaD_reallocCI(L, L->size_ci));
+  used = max - L->stack;  /* part of stack in use */
+  if (4*used < L->stacksize && 2*(BASIC_STACK_SIZE+EXTRA_STACK) < L->stacksize)
+    luaD_reallocstack(L, L->stacksize/2);  /* still big enough... */
+  else condhardstacktests(luaD_reallocstack(L, L->stacksize));
+}
+
+
+static void traversestack (GCState *st, lua_State *L1) {
+  StkId o, lim;
+  CallInfo *ci;
+  markobject(st, gt(L1));
+  lim = L1->top;
+  for (ci = L1->base_ci; ci <= L1->ci; ci++) {
+    lua_assert(ci->top <= L1->stack_last);
+    lua_assert(ci->state & (CI_C | CI_HASFRAME | CI_SAVEDPC));
+    if (!(ci->state & CI_C) && lim < ci->top)
+      lim = ci->top;
+  }
+  for (o = L1->stack; o < L1->top; o++)
+    markobject(st, o);
+  for (; o <= lim; o++)
+    setnilvalue(o);
+  checkstacksizes(L1, lim);
+}
+
+
+static void propagatemarks (GCState *st) {
+  while (st->tmark) {  /* traverse marked objects */
+    switch (st->tmark->gch.tt) {
+      case LUA_TTABLE: {
+        Table *h = gcotoh(st->tmark);
+        st->tmark = h->gclist;
+        traversetable(st, h);
+        break;
+      }
+      case LUA_TFUNCTION: {
+        Closure *cl = gcotocl(st->tmark);
+        st->tmark = cl->c.gclist;
+        traverseclosure(st, cl);
+        break;
+      }
+      case LUA_TTHREAD: {
+        lua_State *th = gcototh(st->tmark);
+        st->tmark = th->gclist;
+        traversestack(st, th);
+        break;
+      }
+      case LUA_TPROTO: {
+        Proto *p = gcotop(st->tmark);
+        st->tmark = p->gclist;
+        traverseproto(st, p);
+        break;
+      }
+      default: lua_assert(0);
+    }
+  }
+}
+
+
+static int valismarked (const TObject *o) {
+  if (ttisstring(o))
+    stringmark(tsvalue(o));  /* strings are `values', so are never weak */
+  return !iscollectable(o) || testbit(o->value.gc->gch.marked, 0);
+}
+
+
+/*
+** clear collected keys from weaktables
+*/
+static void cleartablekeys (GCObject *l) {
+  while (l) {
+    Table *h = gcotoh(l);
+    int i = sizenode(h);
+    lua_assert(h->marked & KEYWEAK);
+    while (i--) {
+      Node *n = gnode(h, i);
+      if (!valismarked(gkey(n)))  /* key was collected? */
+        removekey(n);  /* remove entry from table */
+    }
+    l = h->gclist;
+  }
+}
+
+
+/*
+** clear collected values from weaktables
+*/
+static void cleartablevalues (GCObject *l) {
+  while (l) {
+    Table *h = gcotoh(l);
+    int i = h->sizearray;
+    lua_assert(h->marked & VALUEWEAK);
+    while (i--) {
+      TObject *o = &h->array[i];
+      if (!valismarked(o))  /* value was collected? */
+        setnilvalue(o);  /* remove value */
+    }
+    i = sizenode(h);
+    while (i--) {
+      Node *n = gnode(h, i);
+      if (!valismarked(gval(n)))  /* value was collected? */
+        removekey(n);  /* remove entry from table */
+    }
+    l = h->gclist;
+  }
+}
+
+
+static void freeobj (lua_State *L, GCObject *o) {
+  switch (o->gch.tt) {
+    case LUA_TPROTO: luaF_freeproto(L, gcotop(o)); break;
+    case LUA_TFUNCTION: luaF_freeclosure(L, gcotocl(o)); break;
+    case LUA_TUPVAL: luaM_freelem(L, gcotouv(o)); break;
+    case LUA_TTABLE: luaH_free(L, gcotoh(o)); break;
+    case LUA_TTHREAD: {
+      lua_assert(gcototh(o) != L && gcototh(o) != G(L)->mainthread);
+      luaE_freethread(L, gcototh(o));
+      break;
+    }
+    case LUA_TSTRING: {
+      luaM_free(L, o, sizestring(gcotots(o)->tsv.len));
+      break;
+    }
+    case LUA_TUSERDATA: {
+      luaM_free(L, o, sizeudata(gcotou(o)->uv.len));
+      break;
+    }
+    default: lua_assert(0);
+  }
+}
+
+
+static int sweeplist (lua_State *L, GCObject **p, int limit) {
+  GCObject *curr;
+  int count = 0;  /* number of collected items */
+  while ((curr = *p) != NULL) {
+    if (curr->gch.marked > limit) {
+      unmark(curr);
+      p = &curr->gch.next;
+    }
+    else {
+      count++;
+      *p = curr->gch.next;
+      freeobj(L, curr);
+    }
+  }
+  return count;
+}
+
+
+static void sweepstrings (lua_State *L, int all) {
+  int i;
+  for (i=0; i<G(L)->strt.size; i++) {  /* for each list */
+    G(L)->strt.nuse -= sweeplist(L, &G(L)->strt.hash[i], all);
+  }
+}
+
+
+static void checkSizes (lua_State *L) {
+  /* check size of string hash */
+  if (G(L)->strt.nuse < cast(ls_nstr, G(L)->strt.size/4) &&
+      G(L)->strt.size > MINSTRTABSIZE*2)
+    luaS_resize(L, G(L)->strt.size/2);  /* table is too big */
+  /* check size of buffer */
+  if (luaZ_sizebuffer(&G(L)->buff) > LUA_MINBUFFER*2) {  /* buffer too big? */
+    size_t newsize = luaZ_sizebuffer(&G(L)->buff) / 2;
+    luaZ_resizebuffer(L, &G(L)->buff, newsize);
+  }
+  G(L)->GCthreshold = 2*G(L)->nblocks;  /* new threshold */
+}
+
+
+static void do1gcTM (lua_State *L, Udata *udata) {
+  const TObject *tm = fasttm(L, udata->uv.metatable, TM_GC);
+  if (tm != NULL) {
+    setobj2s(L->top, tm);
+    setuvalue(L->top+1, udata);
+    L->top += 2;
+    luaD_call(L, L->top - 2, 0);
+  }
+}
+
+
+void luaC_callGCTM (lua_State *L) {
+  lu_byte oldah = L->allowhook;
+  L->allowhook = 0;  /* stop debug hooks during GC tag methods */
+  L->top++;  /* reserve space to keep udata while runs its gc method */
+  while (G(L)->tmudata != NULL) {
+    GCObject *o = G(L)->tmudata;
+    Udata *udata = gcotou(o);
+    G(L)->tmudata = udata->uv.next;  /* remove udata from `tmudata' */
+    udata->uv.next = G(L)->rootudata;  /* return it to `root' list */
+    G(L)->rootudata = o;
+    setuvalue(L->top - 1, udata);  /* keep a reference to it */
+    unmark(o);
+    markfinalized(udata);
+    do1gcTM(L, udata);
+  }
+  L->top--;
+  L->allowhook = oldah;  /* restore hooks */
+}
+
+
+void luaC_sweep (lua_State *L, int all) {
+  if (all) all = 256;  /* larger than any mark */
+  sweeplist(L, &G(L)->rootudata, all);
+  sweepstrings(L, all);
+  sweeplist(L, &G(L)->rootgc, all);
+}
+
+
+/* mark root set */
+static void markroot (GCState *st, lua_State *L) {
+  global_State *g = st->g;
+  markobject(st, defaultmeta(L));
+  markobject(st, registry(L));
+  traversestack(st, g->mainthread);
+  if (L != g->mainthread)  /* another thread is running? */
+    markvalue(st, L);  /* cannot collect it */
+}
+
+
+static void mark (lua_State *L) {
+  GCState st;
+  GCObject *wkv;
+  st.g = G(L);
+  st.tmark = NULL;
+  st.wkv = st.wk = st.wv = NULL;
+  markroot(&st, L);
+  propagatemarks(&st);  /* mark all reachable objects */
+  cleartablevalues(st.wkv);
+  cleartablevalues(st.wv);
+  wkv = st.wkv;  /* keys must be cleared after preserving udata */
+  st.wkv = NULL;
+  st.wv = NULL;
+  luaC_separateudata(L);  /* separate userdata to be preserved */
+  marktmu(&st);  /* mark `preserved' userdata */
+  propagatemarks(&st);  /* remark, to propagate `preserveness' */
+  cleartablekeys(wkv);
+  /* `propagatemarks' may resuscitate some weak tables; clear them too */
+  cleartablekeys(st.wk);
+  cleartablevalues(st.wv);
+  cleartablekeys(st.wkv);
+  cleartablevalues(st.wkv);
+}
+
+
+void luaC_collectgarbage (lua_State *L) {
+  mark(L);
+  luaC_sweep(L, 0);
+  checkSizes(L);
+  luaC_callGCTM(L);
+}
+
+
+void luaC_link (lua_State *L, GCObject *o, lu_byte tt) {
+  o->gch.next = G(L)->rootgc;
+  G(L)->rootgc = o;
+  o->gch.marked = 0;
+  o->gch.tt = tt;
+}
+

Added: trunk/source/libraries/lua/lgc.h
===================================================================
--- trunk/source/libraries/lua/lgc.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lgc.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,25 @@
+/*
+** $Id: lgc.h,v 1.19 2003/02/28 19:45:15 roberto Exp $
+** Garbage Collector
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lgc_h
+#define lgc_h
+
+
+#include "lobject.h"
+
+
+#define luaC_checkGC(L) { lua_assert(!(L->ci->state & CI_CALLING)); \
+	if (G(L)->nblocks >= G(L)->GCthreshold) luaC_collectgarbage(L); }
+
+
+void luaC_separateudata (lua_State *L);
+void luaC_callGCTM (lua_State *L);
+void luaC_sweep (lua_State *L, int all);
+void luaC_collectgarbage (lua_State *L);
+void luaC_link (lua_State *L, GCObject *o, lu_byte tt);
+
+
+#endif

Added: trunk/source/libraries/lua/lib/Makefile
===================================================================
--- trunk/source/libraries/lua/lib/Makefile	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/Makefile	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,27 @@
+# makefile for Lua standard library
+
+LUA= ../..
+
+include $(LUA)/config
+
+EXTRA_DEFS= $(POPEN) $(TMPNAM) $(DEGREES) $(LOADLIB)
+
+OBJS= lauxlib.o lbaselib.o ldblib.o liolib.o lmathlib.o ltablib.o lstrlib.o loadlib.o
+SRCS= lauxlib.c lbaselib.c ldblib.c liolib.c lmathlib.c ltablib.c lstrlib.c loadlib.c
+
+T= $(LIB)/liblualib.a
+
+all:	$T
+
+$T:	$(OBJS)
+	$(AR) $@ $(OBJS)
+	$(RANLIB) $@
+
+clean:
+	rm -f $(OBJS) $T
+
+co:
+	co -q -f -M $(SRCS)
+
+klean:	clean
+	rm -f $(SRCS)

Added: trunk/source/libraries/lua/lib/README
===================================================================
--- trunk/source/libraries/lua/lib/README	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/README	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,8 @@
+This is the standard Lua library.
+
+The code of the standard library can be read as an example of how to export
+C functions to Lua. The easiest library to read is lmathlib.c.
+
+The library is implemented entirely on top of the official Lua API as declared
+in lua.h, using lauxlib.c, which contains several useful functions for writing
+libraries. We encourage developers to use lauxlib.c in their own libraries.

Added: trunk/source/libraries/lua/lib/lauxlib.c
===================================================================
--- trunk/source/libraries/lua/lib/lauxlib.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/lauxlib.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,591 @@
+/*
+** $Id: lauxlib.c,v 1.100 2003/04/07 14:35:00 roberto Exp $
+** Auxiliary functions for building Lua libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#include <ctype.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+
+
+/* This file uses only the official API of Lua.
+** Any function declared here could be written as an application function.
+*/
+
+#define lauxlib_c
+
+#include "lua.h"
+
+#include "lauxlib.h"
+
+
+/* number of prereserved references (for internal use) */
+#define RESERVED_REFS	2
+
+/* reserved references */
+#define FREELIST_REF	1	/* free list of references */
+#define ARRAYSIZE_REF	2	/* array sizes */
+
+
+/* convert a stack index to positive */
+#define abs_index(L, i)		((i) > 0 || (i) <= LUA_REGISTRYINDEX ? (i) : \
+					lua_gettop(L) + (i) + 1)
+
+
+/*
+** {======================================================
+** Error-report functions
+** =======================================================
+*/
+
+
+LUALIB_API int luaL_argerror (lua_State *L, int narg, const char *extramsg) {
+  lua_Debug ar;
+  lua_getstack(L, 0, &ar);
+  lua_getinfo(L, "n", &ar);
+  if (strcmp(ar.namewhat, "method") == 0) {
+    narg--;  /* do not count `self' */
+    if (narg == 0)  /* error is in the self argument itself? */
+      return luaL_error(L, "calling `%s' on bad self (%s)", ar.name, extramsg);
+  }
+  if (ar.name == NULL)
+    ar.name = "?";
+  return luaL_error(L, "bad argument #%d to `%s' (%s)",
+                        narg, ar.name, extramsg);
+}
+
+
+LUALIB_API int luaL_typerror (lua_State *L, int narg, const char *tname) {
+  const char *msg = lua_pushfstring(L, "%s expected, got %s",
+                                    tname, lua_typename(L, lua_type(L,narg)));
+  return luaL_argerror(L, narg, msg);
+}
+
+
+static void tag_error (lua_State *L, int narg, int tag) {
+  luaL_typerror(L, narg, lua_typename(L, tag)); 
+}
+
+
+LUALIB_API void luaL_where (lua_State *L, int level) {
+  lua_Debug ar;
+  if (lua_getstack(L, level, &ar)) {  /* check function at level */
+    lua_getinfo(L, "Snl", &ar);  /* get info about it */
+    if (ar.currentline > 0) {  /* is there info? */
+      lua_pushfstring(L, "%s:%d: ", ar.short_src, ar.currentline);
+      return;
+    }
+  }
+  lua_pushliteral(L, "");  /* else, no information available... */
+}
+
+
+LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {
+  va_list argp;
+  va_start(argp, fmt);
+  luaL_where(L, 1);
+  lua_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  lua_concat(L, 2);
+  return lua_error(L);
+}
+
+/* }====================================================== */
+
+
+LUALIB_API int luaL_findstring (const char *name, const char *const list[]) {
+  int i;
+  for (i=0; list[i]; i++)
+    if (strcmp(list[i], name) == 0)
+      return i;
+  return -1;  /* name not found */
+}
+
+
+LUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {
+  lua_pushstring(L, tname);
+  lua_rawget(L, LUA_REGISTRYINDEX);  /* get registry.name */
+  if (!lua_isnil(L, -1))  /* name already in use? */
+    return 0;  /* leave previous value on top, but return 0 */
+  lua_pop(L, 1);
+  lua_newtable(L);  /* create metatable */
+  lua_pushstring(L, tname);
+  lua_pushvalue(L, -2);
+  lua_rawset(L, LUA_REGISTRYINDEX);  /* registry.name = metatable */
+  lua_pushvalue(L, -1);
+  lua_pushstring(L, tname);
+  lua_rawset(L, LUA_REGISTRYINDEX);  /* registry[metatable] = name */
+  return 1;
+}
+
+
+LUALIB_API void  luaL_getmetatable (lua_State *L, const char *tname) {
+  lua_pushstring(L, tname);
+  lua_rawget(L, LUA_REGISTRYINDEX);
+}
+
+
+LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {
+  const char *tn;
+  if (!lua_getmetatable(L, ud)) return NULL;  /* no metatable? */
+  lua_rawget(L, LUA_REGISTRYINDEX);  /* get registry[metatable] */
+  tn = lua_tostring(L, -1);
+  if (tn && (strcmp(tn, tname) == 0)) {
+    lua_pop(L, 1);
+    return lua_touserdata(L, ud);
+  }
+  else {
+    lua_pop(L, 1);
+    return NULL;
+  }
+}
+
+
+LUALIB_API void luaL_checkstack (lua_State *L, int space, const char *mes) {
+  if (!lua_checkstack(L, space))
+    luaL_error(L, "stack overflow (%s)", mes);
+}
+
+
+LUALIB_API void luaL_checktype (lua_State *L, int narg, int t) {
+  if (lua_type(L, narg) != t)
+    tag_error(L, narg, t);
+}
+
+
+LUALIB_API void luaL_checkany (lua_State *L, int narg) {
+  if (lua_type(L, narg) == LUA_TNONE)
+    luaL_argerror(L, narg, "value expected");
+}
+
+
+LUALIB_API const char *luaL_checklstring (lua_State *L, int narg, size_t *len) {
+  const char *s = lua_tostring(L, narg);
+  if (!s) tag_error(L, narg, LUA_TSTRING);
+  if (len) *len = lua_strlen(L, narg);
+  return s;
+}
+
+
+LUALIB_API const char *luaL_optlstring (lua_State *L, int narg,
+                                        const char *def, size_t *len) {
+  if (lua_isnoneornil(L, narg)) {
+    if (len)
+      *len = (def ? strlen(def) : 0);
+    return def;
+  }
+  else return luaL_checklstring(L, narg, len);
+}
+
+
+LUALIB_API lua_Number luaL_checknumber (lua_State *L, int narg) {
+  lua_Number d = lua_tonumber(L, narg);
+  if (d == 0 && !lua_isnumber(L, narg))  /* avoid extra test when d is not 0 */
+    tag_error(L, narg, LUA_TNUMBER);
+  return d;
+}
+
+
+LUALIB_API lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number def) {
+  if (lua_isnoneornil(L, narg)) return def;
+  else return luaL_checknumber(L, narg);
+}
+
+
+LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {
+  if (!lua_getmetatable(L, obj))  /* no metatable? */
+    return 0;
+  lua_pushstring(L, event);
+  lua_rawget(L, -2);
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 2);  /* remove metatable and metafield */
+    return 0;
+  }
+  else {
+    lua_remove(L, -2);  /* remove only metatable */
+    return 1;
+  }
+}
+
+
+LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {
+  obj = abs_index(L, obj);
+  if (!luaL_getmetafield(L, obj, event))  /* no metafield? */
+    return 0;
+  lua_pushvalue(L, obj);
+  lua_call(L, 1, 1);
+  return 1;
+}
+
+
+LUALIB_API void luaL_openlib (lua_State *L, const char *libname,
+                              const luaL_reg *l, int nup) {
+  if (libname) {
+    lua_pushstring(L, libname);
+    lua_gettable(L, LUA_GLOBALSINDEX);  /* check whether lib already exists */
+    if (lua_isnil(L, -1)) {  /* no? */
+      lua_pop(L, 1);
+      lua_newtable(L);  /* create it */
+      lua_pushstring(L, libname);
+      lua_pushvalue(L, -2);
+      lua_settable(L, LUA_GLOBALSINDEX);  /* register it with given name */
+    }
+    lua_insert(L, -(nup+1));  /* move library table to below upvalues */
+  }
+  for (; l->name; l++) {
+    int i;
+    lua_pushstring(L, l->name);
+    for (i=0; i<nup; i++)  /* copy upvalues to the top */
+      lua_pushvalue(L, -(nup+1));
+    lua_pushcclosure(L, l->func, nup);
+    lua_settable(L, -(nup+3));
+  }
+  lua_pop(L, nup);  /* remove upvalues */
+}
+
+
+
+/*
+** {======================================================
+** getn-setn: size for arrays
+** =======================================================
+*/
+
+static int checkint (lua_State *L, int topop) {
+  int n = (int)lua_tonumber(L, -1);
+  if (n == 0 && !lua_isnumber(L, -1)) n = -1;
+  lua_pop(L, topop);
+  return n;
+}
+
+
+static void getsizes (lua_State *L) {
+  lua_rawgeti(L, LUA_REGISTRYINDEX, ARRAYSIZE_REF);
+  if (lua_isnil(L, -1)) {  /* no `size' table? */
+    lua_pop(L, 1);  /* remove nil */
+    lua_newtable(L);  /* create it */
+    lua_pushvalue(L, -1);  /* `size' will be its own metatable */
+    lua_setmetatable(L, -2);
+    lua_pushliteral(L, "__mode");
+    lua_pushliteral(L, "k");
+    lua_rawset(L, -3);  /* metatable(N).__mode = "k" */
+    lua_pushvalue(L, -1);
+    lua_rawseti(L, LUA_REGISTRYINDEX, ARRAYSIZE_REF);  /* store in register */
+  }
+}
+
+
+void luaL_setn (lua_State *L, int t, int n) {
+  t = abs_index(L, t);
+  lua_pushliteral(L, "n");
+  lua_rawget(L, t);
+  if (checkint(L, 1) >= 0) {  /* is there a numeric field `n'? */
+    lua_pushliteral(L, "n");  /* use it */
+    lua_pushnumber(L, (lua_Number)n);
+    lua_rawset(L, t);
+  }
+  else {  /* use `sizes' */
+    getsizes(L);
+    lua_pushvalue(L, t);
+    lua_pushnumber(L, (lua_Number)n);
+    lua_rawset(L, -3);  /* sizes[t] = n */
+    lua_pop(L, 1);  /* remove `sizes' */
+  }
+}
+
+
+int luaL_getn (lua_State *L, int t) {
+  int n;
+  t = abs_index(L, t);
+  lua_pushliteral(L, "n");  /* try t.n */
+  lua_rawget(L, t);
+  if ((n = checkint(L, 1)) >= 0) return n;
+  getsizes(L);  /* else try sizes[t] */
+  lua_pushvalue(L, t);
+  lua_rawget(L, -2);
+  if ((n = checkint(L, 2)) >= 0) return n;
+  for (n = 1; ; n++) {  /* else must count elements */
+    lua_rawgeti(L, t, n);
+    if (lua_isnil(L, -1)) break;
+    lua_pop(L, 1);
+  }
+  lua_pop(L, 1);
+  return n - 1;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** Generic Buffer manipulation
+** =======================================================
+*/
+
+
+#define bufflen(B)	((B)->p - (B)->buffer)
+#define bufffree(B)	((size_t)(LUAL_BUFFERSIZE - bufflen(B)))
+
+#define LIMIT	(LUA_MINSTACK/2)
+
+
+static int emptybuffer (luaL_Buffer *B) {
+  size_t l = bufflen(B);
+  if (l == 0) return 0;  /* put nothing on stack */
+  else {
+    lua_pushlstring(B->L, B->buffer, l);
+    B->p = B->buffer;
+    B->lvl++;
+    return 1;
+  }
+}
+
+
+static void adjuststack (luaL_Buffer *B) {
+  if (B->lvl > 1) {
+    lua_State *L = B->L;
+    int toget = 1;  /* number of levels to concat */
+    size_t toplen = lua_strlen(L, -1);
+    do {
+      size_t l = lua_strlen(L, -(toget+1));
+      if (B->lvl - toget + 1 >= LIMIT || toplen > l) {
+        toplen += l;
+        toget++;
+      }
+      else break;
+    } while (toget < B->lvl);
+    lua_concat(L, toget);
+    B->lvl = B->lvl - toget + 1;
+  }
+}
+
+
+LUALIB_API char *luaL_prepbuffer (luaL_Buffer *B) {
+  if (emptybuffer(B))
+    adjuststack(B);
+  return B->buffer;
+}
+
+
+LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {
+  while (l--)
+    luaL_putchar(B, *s++);
+}
+
+
+LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {
+  luaL_addlstring(B, s, strlen(s));
+}
+
+
+LUALIB_API void luaL_pushresult (luaL_Buffer *B) {
+  emptybuffer(B);
+  lua_concat(B->L, B->lvl);
+  B->lvl = 1;
+}
+
+
+LUALIB_API void luaL_addvalue (luaL_Buffer *B) {
+  lua_State *L = B->L;
+  size_t vl = lua_strlen(L, -1);
+  if (vl <= bufffree(B)) {  /* fit into buffer? */
+    memcpy(B->p, lua_tostring(L, -1), vl);  /* put it there */
+    B->p += vl;
+    lua_pop(L, 1);  /* remove from stack */
+  }
+  else {
+    if (emptybuffer(B))
+      lua_insert(L, -2);  /* put buffer before new value */
+    B->lvl++;  /* add new value into B stack */
+    adjuststack(B);
+  }
+}
+
+
+LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {
+  B->L = L;
+  B->p = B->buffer;
+  B->lvl = 0;
+}
+
+/* }====================================================== */
+
+
+LUALIB_API int luaL_ref (lua_State *L, int t) {
+  int ref;
+  t = abs_index(L, t);
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 1);  /* remove from stack */
+    return LUA_REFNIL;  /* `nil' has a unique fixed reference */
+  }
+  lua_rawgeti(L, t, FREELIST_REF);  /* get first free element */
+  ref = (int)lua_tonumber(L, -1);  /* ref = t[FREELIST_REF] */
+  lua_pop(L, 1);  /* remove it from stack */
+  if (ref != 0) {  /* any free element? */
+    lua_rawgeti(L, t, ref);  /* remove it from list */
+    lua_rawseti(L, t, FREELIST_REF);  /* (t[FREELIST_REF] = t[ref]) */
+  }
+  else {  /* no free elements */
+    ref = luaL_getn(L, t);
+    if (ref < RESERVED_REFS)
+      ref = RESERVED_REFS;  /* skip reserved references */
+    ref++;  /* create new reference */
+    luaL_setn(L, t, ref);
+  }
+  lua_rawseti(L, t, ref);
+  return ref;
+}
+
+
+LUALIB_API void luaL_unref (lua_State *L, int t, int ref) {
+  if (ref >= 0) {
+    t = abs_index(L, t);
+    lua_rawgeti(L, t, FREELIST_REF);
+    lua_rawseti(L, t, ref);  /* t[ref] = t[FREELIST_REF] */
+    lua_pushnumber(L, (lua_Number)ref);
+    lua_rawseti(L, t, FREELIST_REF);  /* t[FREELIST_REF] = ref */
+  }
+}
+
+
+
+/*
+** {======================================================
+** Load functions
+** =======================================================
+*/
+
+typedef struct LoadF {
+  FILE *f;
+  char buff[LUAL_BUFFERSIZE];
+} LoadF;
+
+
+static const char *getF (lua_State *L, void *ud, size_t *size) {
+  LoadF *lf = (LoadF *)ud;
+  (void)L;
+  if (feof(lf->f)) return NULL;
+  *size = fread(lf->buff, 1, LUAL_BUFFERSIZE, lf->f);
+  return (*size > 0) ? lf->buff : NULL;
+}
+
+
+static int errfile (lua_State *L, int fnameindex) {
+  const char *filename = lua_tostring(L, fnameindex) + 1;
+  lua_pushfstring(L, "cannot read %s: %s", filename, strerror(errno));
+  lua_remove(L, fnameindex);
+  return LUA_ERRFILE;
+}
+
+
+LUALIB_API int luaL_loadfile (lua_State *L, const char *filename) {
+  LoadF lf;
+  int status, readstatus;
+  int c;
+  int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */
+  if (filename == NULL) {
+    lua_pushliteral(L, "=stdin");
+    lf.f = stdin;
+  }
+  else {
+    lua_pushfstring(L, "@%s", filename);
+    lf.f = fopen(filename, "r");
+  }
+  if (lf.f == NULL) return errfile(L, fnameindex);  /* unable to open file */
+  c = ungetc(getc(lf.f), lf.f);
+  if (!(isspace(c) || isprint(c)) && lf.f != stdin) {  /* binary file? */
+    fclose(lf.f);
+    lf.f = fopen(filename, "rb");  /* reopen in binary mode */
+    if (lf.f == NULL) return errfile(L, fnameindex); /* unable to reopen file */
+  }
+  status = lua_load(L, getF, &lf, lua_tostring(L, -1));
+  readstatus = ferror(lf.f);
+  if (lf.f != stdin) fclose(lf.f);  /* close file (even in case of errors) */
+  if (readstatus) {
+    lua_settop(L, fnameindex);  /* ignore results from `lua_load' */
+    return errfile(L, fnameindex);
+  }
+  lua_remove(L, fnameindex);
+  return status;
+}
+
+
+typedef struct LoadS {
+  const char *s;
+  size_t size;
+} LoadS;
+
+
+static const char *getS (lua_State *L, void *ud, size_t *size) {
+  LoadS *ls = (LoadS *)ud;
+  (void)L;
+  if (ls->size == 0) return NULL;
+  *size = ls->size;
+  ls->size = 0;
+  return ls->s;
+}
+
+
+LUALIB_API int luaL_loadbuffer (lua_State *L, const char *buff, size_t size,
+                                const char *name) {
+  LoadS ls;
+  ls.s = buff;
+  ls.size = size;
+  return lua_load(L, getS, &ls, name);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** compatibility code
+** =======================================================
+*/
+
+
+static void callalert (lua_State *L, int status) {
+  if (status != 0) {
+    lua_getglobal(L, "_ALERT");
+    if (lua_isfunction(L, -1)) {
+      lua_insert(L, -2);
+      lua_call(L, 1, 0);
+    }
+    else {  /* no _ALERT function; print it on stderr */
+      fprintf(stderr, "%s\n", lua_tostring(L, -2));
+      lua_pop(L, 2);  /* remove error message and _ALERT */
+    }
+  }
+}
+
+
+static int aux_do (lua_State *L, int status) {
+  if (status == 0) {  /* parse OK? */
+    status = lua_pcall(L, 0, LUA_MULTRET, 0);  /* call main */
+  }
+  callalert(L, status);
+  return status;
+}
+
+
+LUALIB_API int lua_dofile (lua_State *L, const char *filename) {
+  return aux_do(L, luaL_loadfile(L, filename));
+}
+
+
+LUALIB_API int lua_dobuffer (lua_State *L, const char *buff, size_t size,
+                          const char *name) {
+  return aux_do(L, luaL_loadbuffer(L, buff, size, name));
+}
+
+
+LUALIB_API int lua_dostring (lua_State *L, const char *str) {
+  return lua_dobuffer(L, str, strlen(str), str);
+}
+
+/* }====================================================== */

Added: trunk/source/libraries/lua/lib/lbaselib.c
===================================================================
--- trunk/source/libraries/lua/lib/lbaselib.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/lbaselib.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,674 @@
+/*
+** $Id: lbaselib.c,v 1.130 2003/04/03 13:35:34 roberto Exp $
+** Basic library
+** See Copyright Notice in lua.h
+*/
+
+
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lbaselib_c
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+
+
+/*
+** If your system does not support `stdout', you can just remove this function.
+** If you need, you can define your own `print' function, following this
+** model but changing `fputs' to put the strings at a proper place
+** (a console window or a log file, for instance).
+*/
+static int luaB_print (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  int i;
+  lua_getglobal(L, "tostring");
+  for (i=1; i<=n; i++) {
+    const char *s;
+    lua_pushvalue(L, -1);  /* function to be called */
+    lua_pushvalue(L, i);   /* value to print */
+    lua_call(L, 1, 1);
+    s = lua_tostring(L, -1);  /* get result */
+    if (s == NULL)
+      return luaL_error(L, "`tostring' must return a string to `print'");
+    if (i>1) fputs("\t", stdout);
+    fputs(s, stdout);
+    lua_pop(L, 1);  /* pop result */
+  }
+  fputs("\n", stdout);
+  return 0;
+}
+
+
+static int luaB_tonumber (lua_State *L) {
+  int base = luaL_optint(L, 2, 10);
+  if (base == 10) {  /* standard conversion */
+    luaL_checkany(L, 1);
+    if (lua_isnumber(L, 1)) {
+      lua_pushnumber(L, lua_tonumber(L, 1));
+      return 1;
+    }
+  }
+  else {
+    const char *s1 = luaL_checkstring(L, 1);
+    char *s2;
+    unsigned long n;
+    luaL_argcheck(L, 2 <= base && base <= 36, 2, "base out of range");
+    n = strtoul(s1, &s2, base);
+    if (s1 != s2) {  /* at least one valid digit? */
+      while (isspace((unsigned char)(*s2))) s2++;  /* skip trailing spaces */
+      if (*s2 == '\0') {  /* no invalid trailing characters? */
+        lua_pushnumber(L, (lua_Number)n);
+        return 1;
+      }
+    }
+  }
+  lua_pushnil(L);  /* else not a number */
+  return 1;
+}
+
+
+static int luaB_error (lua_State *L) {
+  int level = luaL_optint(L, 2, 1);
+  luaL_checkany(L, 1);
+  if (!lua_isstring(L, 1) || level == 0)
+    lua_pushvalue(L, 1);  /* propagate error message without changes */
+  else {  /* add extra information */
+    luaL_where(L, level);
+    lua_pushvalue(L, 1);
+    lua_concat(L, 2);
+  }
+  return lua_error(L);
+}
+
+
+static int luaB_getmetatable (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (!lua_getmetatable(L, 1)) {
+    lua_pushnil(L);
+    return 1;  /* no metatable */
+  }
+  luaL_getmetafield(L, 1, "__metatable");
+  return 1;  /* returns either __metatable field (if present) or metatable */
+}
+
+
+static int luaB_setmetatable (lua_State *L) {
+  int t = lua_type(L, 2);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
+                    "nil or table expected");
+  if (luaL_getmetafield(L, 1, "__metatable"))
+    luaL_error(L, "cannot change a protected metatable");
+  lua_settop(L, 2);
+  lua_setmetatable(L, 1);
+  return 1;
+}
+
+
+static void getfunc (lua_State *L) {
+  if (lua_isfunction(L, 1)) lua_pushvalue(L, 1);
+  else {
+    lua_Debug ar;
+    int level = luaL_optint(L, 1, 1);
+    luaL_argcheck(L, level >= 0, 1, "level must be non-negative");
+    if (lua_getstack(L, level, &ar) == 0)
+      luaL_argerror(L, 1, "invalid level");
+    lua_getinfo(L, "f", &ar);
+    if (lua_isnil(L, -1))
+      luaL_error(L, "no function environment for tail call at level %d",
+                    level);
+  }
+}
+
+
+static int aux_getfenv (lua_State *L) {
+  lua_getfenv(L, -1);
+  lua_pushliteral(L, "__fenv");
+  lua_rawget(L, -2);
+  return !lua_isnil(L, -1);
+}
+
+
+static int luaB_getfenv (lua_State *L) {
+  getfunc(L);
+  if (!aux_getfenv(L))  /* __fenv not defined? */
+    lua_pop(L, 1);  /* remove it, to return real environment */
+  return 1;
+}
+
+
+static int luaB_setfenv (lua_State *L) {
+  luaL_checktype(L, 2, LUA_TTABLE);
+  getfunc(L);
+  if (aux_getfenv(L))  /* __fenv defined? */
+    luaL_error(L, "`setfenv' cannot change a protected environment");
+  else
+    lua_pop(L, 2);  /* remove __fenv and real environment table */
+  lua_pushvalue(L, 2);
+  if (lua_isnumber(L, 1) && lua_tonumber(L, 1) == 0)
+    lua_replace(L, LUA_GLOBALSINDEX);
+  else if (lua_setfenv(L, -2) == 0)
+    luaL_error(L, "`setfenv' cannot change environment of given function");
+  return 0;
+}
+
+
+static int luaB_rawequal (lua_State *L) {
+  luaL_checkany(L, 1);
+  luaL_checkany(L, 2);
+  lua_pushboolean(L, lua_rawequal(L, 1, 2));
+  return 1;
+}
+
+
+static int luaB_rawget (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checkany(L, 2);
+  lua_rawget(L, 1);
+  return 1;
+}
+
+static int luaB_rawset (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checkany(L, 2);
+  luaL_checkany(L, 3);
+  lua_rawset(L, 1);
+  return 1;
+}
+
+
+static int luaB_gcinfo (lua_State *L) {
+  lua_pushnumber(L, (lua_Number)lua_getgccount(L));
+  lua_pushnumber(L, (lua_Number)lua_getgcthreshold(L));
+  return 2;
+}
+
+
+static int luaB_collectgarbage (lua_State *L) {
+  lua_setgcthreshold(L, luaL_optint(L, 1, 0));
+  return 0;
+}
+
+
+static int luaB_type (lua_State *L) {
+  luaL_checkany(L, 1);
+  lua_pushstring(L, lua_typename(L, lua_type(L, 1)));
+  return 1;
+}
+
+
+static int luaB_next (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  lua_settop(L, 2);  /* create a 2nd argument if there isn't one */
+  if (lua_next(L, 1))
+    return 2;
+  else {
+    lua_pushnil(L);
+    return 1;
+  }
+}
+
+
+static int luaB_pairs (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  lua_pushliteral(L, "next");
+  lua_rawget(L, LUA_GLOBALSINDEX);  /* return generator, */
+  lua_pushvalue(L, 1);  /* state, */
+  lua_pushnil(L);  /* and initial value */
+  return 3;
+}
+
+
+static int luaB_ipairs (lua_State *L) {
+  lua_Number i = lua_tonumber(L, 2);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  if (i == 0 && lua_isnone(L, 2)) {  /* `for' start? */
+    lua_pushliteral(L, "ipairs");
+    lua_rawget(L, LUA_GLOBALSINDEX);  /* return generator, */
+    lua_pushvalue(L, 1);  /* state, */
+    lua_pushnumber(L, 0);  /* and initial value */
+    return 3;
+  }
+  else {  /* `for' step */
+    i++;  /* next value */
+    lua_pushnumber(L, i);
+    lua_rawgeti(L, 1, (int)i);
+    return (lua_isnil(L, -1)) ? 0 : 2;
+  }
+}
+
+
+static int load_aux (lua_State *L, int status) {
+  if (status == 0)  /* OK? */
+    return 1;
+  else {
+    lua_pushnil(L);
+    lua_insert(L, -2);  /* put before error message */
+    return 2;  /* return nil plus error message */
+  }
+}
+
+
+static int luaB_loadstring (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &l);
+  const char *chunkname = luaL_optstring(L, 2, s);
+  return load_aux(L, luaL_loadbuffer(L, s, l, chunkname));
+}
+
+
+static int luaB_loadfile (lua_State *L) {
+  const char *fname = luaL_optstring(L, 1, NULL);
+  return load_aux(L, luaL_loadfile(L, fname));
+}
+
+
+static int luaB_dofile (lua_State *L) {
+  const char *fname = luaL_optstring(L, 1, NULL);
+  int status = luaL_loadfile(L, fname);
+  if (status != 0) lua_error(L);
+  lua_call(L, 0, LUA_MULTRET);
+  return lua_gettop(L) - 1;
+}
+
+
+static int luaB_assert (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (!lua_toboolean(L, 1))
+    return luaL_error(L, "%s", luaL_optstring(L, 2, "assertion failed!"));
+  lua_settop(L, 1);
+  return 1;
+}
+
+
+static int luaB_unpack (lua_State *L) {
+  int n, i;
+  luaL_checktype(L, 1, LUA_TTABLE);
+  n = luaL_getn(L, 1);
+  luaL_checkstack(L, n, "table too big to unpack");
+  for (i=1; i<=n; i++)  /* push arg[1...n] */
+    lua_rawgeti(L, 1, i);
+  return n;
+}
+
+
+static int luaB_pcall (lua_State *L) {
+  int status;
+  luaL_checkany(L, 1);
+  status = lua_pcall(L, lua_gettop(L) - 1, LUA_MULTRET, 0);
+  lua_pushboolean(L, (status == 0));
+  lua_insert(L, 1);
+  return lua_gettop(L);  /* return status + all results */
+}
+
+
+static int luaB_xpcall (lua_State *L) {
+  int status;
+  luaL_checkany(L, 2);
+  lua_settop(L, 2);
+  lua_insert(L, 1);  /* put error function under function to be called */
+  status = lua_pcall(L, 0, LUA_MULTRET, 1);
+  lua_pushboolean(L, (status == 0));
+  lua_replace(L, 1);
+  return lua_gettop(L);  /* return status + all results */
+}
+
+
+static int luaB_tostring (lua_State *L) {
+  char buff[64];
+  luaL_checkany(L, 1);
+  if (luaL_callmeta(L, 1, "__tostring"))  /* is there a metafield? */
+    return 1;  /* use its value */
+  switch (lua_type(L, 1)) {
+    case LUA_TNUMBER:
+      lua_pushstring(L, lua_tostring(L, 1));
+      return 1;
+    case LUA_TSTRING:
+      lua_pushvalue(L, 1);
+      return 1;
+    case LUA_TBOOLEAN:
+      lua_pushstring(L, (lua_toboolean(L, 1) ? "true" : "false"));
+      return 1;
+    case LUA_TTABLE:
+      sprintf(buff, "table: %p", lua_topointer(L, 1));
+      break;
+    case LUA_TFUNCTION:
+      sprintf(buff, "function: %p", lua_topointer(L, 1));
+      break;
+    case LUA_TUSERDATA:
+    case LUA_TLIGHTUSERDATA:
+      sprintf(buff, "userdata: %p", lua_touserdata(L, 1));
+      break;
+    case LUA_TTHREAD:
+      sprintf(buff, "thread: %p", (void *)lua_tothread(L, 1));
+      break;
+    case LUA_TNIL:
+      lua_pushliteral(L, "nil");
+      return 1;
+  }
+  lua_pushstring(L, buff);
+  return 1;
+}
+
+
+static int luaB_newproxy (lua_State *L) {
+  lua_settop(L, 1);
+  lua_newuserdata(L, 0);  /* create proxy */
+  if (lua_toboolean(L, 1) == 0)
+    return 1;  /* no metatable */
+  else if (lua_isboolean(L, 1)) {
+    lua_newtable(L);  /* create a new metatable `m' ... */
+    lua_pushvalue(L, -1);  /* ... and mark `m' as a valid metatable */
+    lua_pushboolean(L, 1);
+    lua_rawset(L, lua_upvalueindex(1));  /* weaktable[m] = true */
+  }
+  else {
+    int validproxy = 0;  /* to check if weaktable[metatable(u)] == true */
+    if (lua_getmetatable(L, 1)) {
+      lua_rawget(L, lua_upvalueindex(1));
+      validproxy = lua_toboolean(L, -1);
+      lua_pop(L, 1);  /* remove value */
+    }
+    luaL_argcheck(L, validproxy, 1, "boolean or proxy expected");
+    lua_getmetatable(L, 1);  /* metatable is valid; get it */
+  }
+  lua_setmetatable(L, 2);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** `require' function
+** =======================================================
+*/
+
+
+/* name of global that holds table with loaded packages */
+#define REQTAB		"_LOADED"
+
+/* name of global that holds the search path for packages */
+#define LUA_PATH	"LUA_PATH"
+
+#ifndef LUA_PATH_SEP
+#define LUA_PATH_SEP	';'
+#endif
+
+#ifndef LUA_PATH_MARK
+#define LUA_PATH_MARK	'?'
+#endif
+
+#ifndef LUA_PATH_DEFAULT
+#define LUA_PATH_DEFAULT	"?;?.lua"
+#endif
+
+
+static const char *getpath (lua_State *L) {
+  const char *path;
+  lua_getglobal(L, LUA_PATH);  /* try global variable */
+  path = lua_tostring(L, -1);
+  lua_pop(L, 1);
+  if (path) return path;
+  path = getenv(LUA_PATH);  /* else try environment variable */
+  if (path) return path;
+  return LUA_PATH_DEFAULT;  /* else use default */
+}
+
+
+static const char *pushnextpath (lua_State *L, const char *path) {
+  const char *l;
+  if (*path == '\0') return NULL;  /* no more paths */
+  if (*path == LUA_PATH_SEP) path++;  /* skip separator */
+  l = strchr(path, LUA_PATH_SEP);  /* find next separator */
+  if (l == NULL) l = path+strlen(path);
+  lua_pushlstring(L, path, l - path);  /* directory name */
+  return l;
+}
+
+
+static void pushcomposename (lua_State *L) {
+  const char *path = lua_tostring(L, -1);
+  const char *wild;
+  int n = 1;
+  while ((wild = strchr(path, LUA_PATH_MARK)) != NULL) {
+    /* is there stack space for prefix, name, and eventual last sufix? */
+    luaL_checkstack(L, 3, "too many marks in a path component");
+    lua_pushlstring(L, path, wild - path);  /* push prefix */
+    lua_pushvalue(L, 1);  /* push package name (in place of MARK) */
+    path = wild + 1;  /* continue after MARK */
+    n += 2;
+  }
+  lua_pushstring(L, path);  /* push last sufix (`n' already includes this) */
+  lua_concat(L, n);
+}
+
+
+static int luaB_require (lua_State *L) {
+  const char *path;
+  int status = LUA_ERRFILE;  /* not found (yet) */
+  luaL_checkstring(L, 1);
+  lua_settop(L, 1);
+  lua_getglobal(L, REQTAB);
+  if (!lua_istable(L, 2)) return luaL_error(L, "`" REQTAB "' is not a table");
+  path = getpath(L);
+  lua_pushvalue(L, 1);  /* check package's name in book-keeping table */
+  lua_rawget(L, 2);
+  if (lua_toboolean(L, -1))  /* is it there? */
+    return 1;  /* package is already loaded; return its result */
+  else {  /* must load it */
+    while (status == LUA_ERRFILE) {
+      lua_settop(L, 3);  /* reset stack position */
+      if ((path = pushnextpath(L, path)) == NULL) break;
+      pushcomposename(L);
+      status = luaL_loadfile(L, lua_tostring(L, -1));  /* try to load it */
+    }
+  }
+  switch (status) {
+    case 0: {
+      lua_getglobal(L, "_REQUIREDNAME");  /* save previous name */
+      lua_insert(L, -2);  /* put it below function */
+      lua_pushvalue(L, 1);
+      lua_setglobal(L, "_REQUIREDNAME");  /* set new name */
+      lua_call(L, 0, 1);  /* run loaded module */
+      lua_insert(L, -2);  /* put result below previous name */
+      lua_setglobal(L, "_REQUIREDNAME");  /* reset to previous name */
+      if (lua_isnil(L, -1)) {  /* no/nil return? */
+        lua_pushboolean(L, 1);
+        lua_replace(L, -2);  /* replace to true */
+      }
+      lua_pushvalue(L, 1);
+      lua_pushvalue(L, -2);
+      lua_rawset(L, 2);  /* mark it as loaded */
+      return 1;  /* return value */
+    }
+    case LUA_ERRFILE: {  /* file not found */
+      return luaL_error(L, "could not load package `%s' from path `%s'",
+                            lua_tostring(L, 1), getpath(L));
+    }
+    default: {
+      return luaL_error(L, "error loading package `%s' (%s)",
+                           lua_tostring(L, 1), lua_tostring(L, -1));
+    }
+  }
+}
+
+/* }====================================================== */
+
+
+static const luaL_reg base_funcs[] = {
+  {"error", luaB_error},
+  {"getmetatable", luaB_getmetatable},
+  {"setmetatable", luaB_setmetatable},
+  {"getfenv", luaB_getfenv},
+  {"setfenv", luaB_setfenv},
+  {"next", luaB_next},
+  {"ipairs", luaB_ipairs},
+  {"pairs", luaB_pairs},
+  {"print", luaB_print},
+  {"tonumber", luaB_tonumber},
+  {"tostring", luaB_tostring},
+  {"type", luaB_type},
+  {"assert", luaB_assert},
+  {"unpack", luaB_unpack},
+  {"rawequal", luaB_rawequal},
+  {"rawget", luaB_rawget},
+  {"rawset", luaB_rawset},
+  {"pcall", luaB_pcall},
+  {"xpcall", luaB_xpcall},
+  {"collectgarbage", luaB_collectgarbage},
+  {"gcinfo", luaB_gcinfo},
+  {"loadfile", luaB_loadfile},
+  {"dofile", luaB_dofile},
+  {"loadstring", luaB_loadstring},
+  {"require", luaB_require},
+  {NULL, NULL}
+};
+
+
+/*
+** {======================================================
+** Coroutine library
+** =======================================================
+*/
+
+static int auxresume (lua_State *L, lua_State *co, int narg) {
+  int status;
+  if (!lua_checkstack(co, narg))
+    luaL_error(L, "too many arguments to resume");
+  lua_xmove(L, co, narg);
+  status = lua_resume(co, narg);
+  if (status == 0) {
+    int nres = lua_gettop(co);
+    if (!lua_checkstack(L, nres))
+      luaL_error(L, "too many results to resume");
+    lua_xmove(co, L, nres);  /* move yielded values */
+    return nres;
+  }
+  else {
+    lua_xmove(co, L, 1);  /* move error message */
+    return -1;  /* error flag */
+  }
+}
+
+
+static int luaB_coresume (lua_State *L) {
+  lua_State *co = lua_tothread(L, 1);
+  int r;
+  luaL_argcheck(L, co, 1, "coroutine expected");
+  r = auxresume(L, co, lua_gettop(L) - 1);
+  if (r < 0) {
+    lua_pushboolean(L, 0);
+    lua_insert(L, -2);
+    return 2;  /* return false + error message */
+  }
+  else {
+    lua_pushboolean(L, 1);
+    lua_insert(L, -(r + 1));
+    return r + 1;  /* return true + `resume' returns */
+  }
+}
+
+
+static int luaB_auxwrap (lua_State *L) {
+  lua_State *co = lua_tothread(L, lua_upvalueindex(1));
+  int r = auxresume(L, co, lua_gettop(L));
+  if (r < 0) {
+    if (lua_isstring(L, -1)) {  /* error object is a string? */
+      luaL_where(L, 1);  /* add extra info */
+      lua_insert(L, -2);
+      lua_concat(L, 2);
+    }
+    lua_error(L);  /* propagate error */
+  }
+  return r;
+}
+
+
+static int luaB_cocreate (lua_State *L) {
+  lua_State *NL = lua_newthread(L);
+  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1), 1,
+    "Lua function expected");
+  lua_pushvalue(L, 1);  /* move function to top */
+  lua_xmove(L, NL, 1);  /* move function from L to NL */
+  return 1;
+}
+
+
+static int luaB_cowrap (lua_State *L) {
+  luaB_cocreate(L);
+  lua_pushcclosure(L, luaB_auxwrap, 1);
+  return 1;
+}
+
+
+static int luaB_yield (lua_State *L) {
+  return lua_yield(L, lua_gettop(L));
+}
+
+
+static int luaB_costatus (lua_State *L) {
+  lua_State *co = lua_tothread(L, 1);
+  luaL_argcheck(L, co, 1, "coroutine expected");
+  if (L == co) lua_pushliteral(L, "running");
+  else {
+    lua_Debug ar;
+    if (lua_getstack(co, 0, &ar) == 0 && lua_gettop(co) == 0)
+      lua_pushliteral(L, "dead");
+    else
+      lua_pushliteral(L, "suspended");
+  }
+  return 1;
+}
+
+
+static const luaL_reg co_funcs[] = {
+  {"create", luaB_cocreate},
+  {"wrap", luaB_cowrap},
+  {"resume", luaB_coresume},
+  {"yield", luaB_yield},
+  {"status", luaB_costatus},
+  {NULL, NULL}
+};
+
+/* }====================================================== */
+
+
+
+static void base_open (lua_State *L) {
+  lua_pushliteral(L, "_G");
+  lua_pushvalue(L, LUA_GLOBALSINDEX);
+  luaL_openlib(L, NULL, base_funcs, 0);  /* open lib into global table */
+  lua_pushliteral(L, "_VERSION");
+  lua_pushliteral(L, LUA_VERSION);
+  lua_rawset(L, -3);  /* set global _VERSION */
+  /* `newproxy' needs a weaktable as upvalue */
+  lua_pushliteral(L, "newproxy");
+  lua_newtable(L);  /* new table `w' */
+  lua_pushvalue(L, -1);  /* `w' will be its own metatable */
+  lua_setmetatable(L, -2);
+  lua_pushliteral(L, "__mode");
+  lua_pushliteral(L, "k");
+  lua_rawset(L, -3);  /* metatable(w).__mode = "k" */
+  lua_pushcclosure(L, luaB_newproxy, 1);
+  lua_rawset(L, -3);  /* set global `newproxy' */
+  lua_rawset(L, -1);  /* set global _G */
+}
+
+
+LUALIB_API int luaopen_base (lua_State *L) {
+  base_open(L);
+  luaL_openlib(L, LUA_COLIBNAME, co_funcs, 0);
+  lua_newtable(L);
+  lua_setglobal(L, REQTAB);
+  return 0;
+}
+

Added: trunk/source/libraries/lua/lib/ldblib.c
===================================================================
--- trunk/source/libraries/lua/lib/ldblib.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/ldblib.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,299 @@
+/*
+** $Id: ldblib.c,v 1.80 2003/04/03 13:35:34 roberto Exp $
+** Interface from Lua to its debug API
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define ldblib_c
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+
+static void settabss (lua_State *L, const char *i, const char *v) {
+  lua_pushstring(L, i);
+  lua_pushstring(L, v);
+  lua_rawset(L, -3);
+}
+
+
+static void settabsi (lua_State *L, const char *i, int v) {
+  lua_pushstring(L, i);
+  lua_pushnumber(L, (lua_Number)v);
+  lua_rawset(L, -3);
+}
+
+
+static int getinfo (lua_State *L) {
+  lua_Debug ar;
+  const char *options = luaL_optstring(L, 2, "flnSu");
+  if (lua_isnumber(L, 1)) {
+    if (!lua_getstack(L, (int)(lua_tonumber(L, 1)), &ar)) {
+      lua_pushnil(L);  /* level out of range */
+      return 1;
+    }
+  }
+  else if (lua_isfunction(L, 1)) {
+    lua_pushfstring(L, ">%s", options);
+    options = lua_tostring(L, -1);
+    lua_pushvalue(L, 1);
+  }
+  else
+    return luaL_argerror(L, 1, "function or level expected");
+  if (!lua_getinfo(L, options, &ar))
+    return luaL_argerror(L, 2, "invalid option");
+  lua_newtable(L);
+  for (; *options; options++) {
+    switch (*options) {
+      case 'S':
+        settabss(L, "source", ar.source);
+        settabss(L, "short_src", ar.short_src);
+        settabsi(L, "linedefined", ar.linedefined);
+        settabss(L, "what", ar.what);
+        break;
+      case 'l':
+        settabsi(L, "currentline", ar.currentline);
+        break;
+      case 'u':
+        settabsi(L, "nups", ar.nups);
+        break;
+      case 'n':
+        settabss(L, "name", ar.name);
+        settabss(L, "namewhat", ar.namewhat);
+        break;
+      case 'f':
+        lua_pushliteral(L, "func");
+        lua_pushvalue(L, -3);
+        lua_rawset(L, -3);
+        break;
+    }
+  }
+  return 1;  /* return table */
+}
+    
+
+static int getlocal (lua_State *L) {
+  lua_Debug ar;
+  const char *name;
+  if (!lua_getstack(L, luaL_checkint(L, 1), &ar))  /* level out of range? */
+    return luaL_argerror(L, 1, "level out of range");
+  name = lua_getlocal(L, &ar, luaL_checkint(L, 2));
+  if (name) {
+    lua_pushstring(L, name);
+    lua_pushvalue(L, -2);
+    return 2;
+  }
+  else {
+    lua_pushnil(L);
+    return 1;
+  }
+}
+
+
+static int setlocal (lua_State *L) {
+  lua_Debug ar;
+  if (!lua_getstack(L, luaL_checkint(L, 1), &ar))  /* level out of range? */
+    return luaL_argerror(L, 1, "level out of range");
+  luaL_checkany(L, 3);
+  lua_pushstring(L, lua_setlocal(L, &ar, luaL_checkint(L, 2)));
+  return 1;
+}
+
+
+static int auxupvalue (lua_State *L, int get) {
+  const char *name;
+  int n = luaL_checkint(L, 2);
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  if (lua_iscfunction(L, 1)) return 0;  /* cannot touch C upvalues from Lua */
+  name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);
+  if (name == NULL) return 0;
+  lua_pushstring(L, name);
+  lua_insert(L, -(get+1));
+  return get + 1;
+}
+
+
+static int getupvalue (lua_State *L) {
+  return auxupvalue(L, 1);
+}
+
+
+static int setupvalue (lua_State *L) {
+  luaL_checkany(L, 3);
+  return auxupvalue(L, 0);
+}
+
+
+
+static const char KEY_HOOK = 'h';
+
+
+static void hookf (lua_State *L, lua_Debug *ar) {
+  static const char *const hooknames[] =
+    {"call", "return", "line", "count", "tail return"};
+  lua_pushlightuserdata(L, (void *)&KEY_HOOK);
+  lua_rawget(L, LUA_REGISTRYINDEX);
+  if (lua_isfunction(L, -1)) {
+    lua_pushstring(L, hooknames[(int)ar->event]);
+    if (ar->currentline >= 0)
+      lua_pushnumber(L, (lua_Number)ar->currentline);
+    else lua_pushnil(L);
+    lua_assert(lua_getinfo(L, "lS", ar));
+    lua_call(L, 2, 0);
+  }
+  else
+    lua_pop(L, 1);  /* pop result from gettable */
+}
+
+
+static int makemask (const char *smask, int count) {
+  int mask = 0;
+  if (strchr(smask, 'c')) mask |= LUA_MASKCALL;
+  if (strchr(smask, 'r')) mask |= LUA_MASKRET;
+  if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
+  if (count > 0) mask |= LUA_MASKCOUNT;
+  return mask;
+}
+
+
+static char *unmakemask (int mask, char *smask) {
+  int i = 0;
+  if (mask & LUA_MASKCALL) smask[i++] = 'c';
+  if (mask & LUA_MASKRET) smask[i++] = 'r';
+  if (mask & LUA_MASKLINE) smask[i++] = 'l';
+  smask[i] = '\0';
+  return smask;
+}
+
+
+static int sethook (lua_State *L) {
+  if (lua_isnoneornil(L, 1)) {
+    lua_settop(L, 1);
+    lua_sethook(L, NULL, 0, 0);  /* turn off hooks */
+  }
+  else {
+    const char *smask = luaL_checkstring(L, 2);
+    int count = luaL_optint(L, 3, 0);
+    luaL_checktype(L, 1, LUA_TFUNCTION);
+    lua_sethook(L, hookf, makemask(smask, count), count);
+  }
+  lua_pushlightuserdata(L, (void *)&KEY_HOOK);
+  lua_pushvalue(L, 1);
+  lua_rawset(L, LUA_REGISTRYINDEX);  /* set new hook */
+  return 0;
+}
+
+
+static int gethook (lua_State *L) {
+  char buff[5];
+  int mask = lua_gethookmask(L);
+  lua_Hook hook = lua_gethook(L);
+  if (hook != NULL && hook != hookf)  /* external hook? */
+    lua_pushliteral(L, "external hook");
+  else {
+    lua_pushlightuserdata(L, (void *)&KEY_HOOK);
+    lua_rawget(L, LUA_REGISTRYINDEX);   /* get hook */
+  }
+  lua_pushstring(L, unmakemask(mask, buff));
+  lua_pushnumber(L, (lua_Number)lua_gethookcount(L));
+  return 3;
+}
+
+
+static int debug (lua_State *L) {
+  for (;;) {
+    char buffer[250];
+    fputs("lua_debug> ", stderr);
+    if (fgets(buffer, sizeof(buffer), stdin) == 0 ||
+        strcmp(buffer, "cont\n") == 0)
+      return 0;
+    lua_dostring(L, buffer);
+    lua_settop(L, 0);  /* remove eventual returns */
+  }
+}
+
+
+#define LEVELS1	12	/* size of the first part of the stack */
+#define LEVELS2	10	/* size of the second part of the stack */
+
+static int errorfb (lua_State *L) {
+  int level = 1;  /* skip level 0 (it's this function) */
+  int firstpart = 1;  /* still before eventual `...' */
+  lua_Debug ar;
+  if (lua_gettop(L) == 0)
+    lua_pushliteral(L, "");
+  else if (!lua_isstring(L, 1)) return 1;  /* no string message */
+  else lua_pushliteral(L, "\n");
+  lua_pushliteral(L, "stack traceback:");
+  while (lua_getstack(L, level++, &ar)) {
+    if (level > LEVELS1 && firstpart) {
+      /* no more than `LEVELS2' more levels? */
+      if (!lua_getstack(L, level+LEVELS2, &ar))
+        level--;  /* keep going */
+      else {
+        lua_pushliteral(L, "\n\t...");  /* too many levels */
+        while (lua_getstack(L, level+LEVELS2, &ar))  /* find last levels */
+          level++;
+      }
+      firstpart = 0;
+      continue;
+    }
+    lua_pushliteral(L, "\n\t");
+    lua_getinfo(L, "Snl", &ar);
+    lua_pushfstring(L, "%s:", ar.short_src);
+    if (ar.currentline > 0)
+      lua_pushfstring(L, "%d:", ar.currentline);
+    switch (*ar.namewhat) {
+      case 'g':  /* global */ 
+      case 'l':  /* local */
+      case 'f':  /* field */
+      case 'm':  /* method */
+        lua_pushfstring(L, " in function `%s'", ar.name);
+        break;
+      default: {
+        if (*ar.what == 'm')  /* main? */
+          lua_pushfstring(L, " in main chunk");
+        else if (*ar.what == 'C' || *ar.what == 't')
+          lua_pushliteral(L, " ?");  /* C function or tail call */
+        else
+          lua_pushfstring(L, " in function <%s:%d>",
+                             ar.short_src, ar.linedefined);
+      }
+    }
+    lua_concat(L, lua_gettop(L));
+  }
+  lua_concat(L, lua_gettop(L));
+  return 1;
+}
+
+
+static const luaL_reg dblib[] = {
+  {"getlocal", getlocal},
+  {"getinfo", getinfo},
+  {"gethook", gethook},
+  {"getupvalue", getupvalue},
+  {"sethook", sethook},
+  {"setlocal", setlocal},
+  {"setupvalue", setupvalue},
+  {"debug", debug},
+  {"traceback", errorfb},
+  {NULL, NULL}
+};
+
+
+LUALIB_API int luaopen_debug (lua_State *L) {
+  luaL_openlib(L, LUA_DBLIBNAME, dblib, 0);
+  lua_pushliteral(L, "_TRACEBACK");
+  lua_pushcfunction(L, errorfb);
+  lua_settable(L, LUA_GLOBALSINDEX);
+  return 1;
+}
+

Added: trunk/source/libraries/lua/lib/liolib.c
===================================================================
--- trunk/source/libraries/lua/lib/liolib.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/liolib.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,750 @@
+/*
+** $Id: liolib.c,v 2.39 2003/03/19 21:16:12 roberto Exp $
+** Standard I/O (and system) library
+** See Copyright Notice in lua.h
+*/
+
+
+#include <errno.h>
+#include <locale.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#define liolib_c
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+
+/*
+** by default, gcc does not get `tmpname'
+*/
+#ifndef USE_TMPNAME
+#ifdef __GNUC__
+#define USE_TMPNAME	0
+#else
+#define USE_TMPNAME	1
+#endif
+#endif
+
+
+/*
+** by default, posix systems get `popen'
+*/
+#ifndef USE_POPEN
+#ifdef _POSIX_C_SOURCE
+#if _POSIX_C_SOURCE >= 2
+#define USE_POPEN	1
+#endif
+#endif
+#endif
+
+#ifndef USE_POPEN
+#define USE_POPEN	0
+#endif
+
+
+
+
+/*
+** {======================================================
+** FILE Operations
+** =======================================================
+*/
+
+
+#if !USE_POPEN
+#define pclose(f)    (-1)
+#endif
+
+
+#define FILEHANDLE		"FILE*"
+
+#define IO_INPUT		"_input"
+#define IO_OUTPUT		"_output"
+
+
+static int pushresult (lua_State *L, int i, const char *filename) {
+  if (i) {
+    lua_pushboolean(L, 1);
+    return 1;
+  }
+  else {
+    lua_pushnil(L);
+    if (filename)
+      lua_pushfstring(L, "%s: %s", filename, strerror(errno));
+    else
+      lua_pushfstring(L, "%s", strerror(errno));
+    lua_pushnumber(L, errno);
+    return 3;
+  }
+}
+
+
+static FILE **topfile (lua_State *L, int findex) {
+  FILE **f = (FILE **)luaL_checkudata(L, findex, FILEHANDLE);
+  if (f == NULL) luaL_argerror(L, findex, "bad file");
+  return f;
+}
+
+
+static int io_type (lua_State *L) {
+  FILE **f = (FILE **)luaL_checkudata(L, 1, FILEHANDLE);
+  if (f == NULL) lua_pushnil(L);
+  else if (*f == NULL)
+    lua_pushliteral(L, "closed file");
+  else
+    lua_pushliteral(L, "file");
+  return 1;
+}
+
+
+static FILE *tofile (lua_State *L, int findex) {
+  FILE **f = topfile(L, findex);
+  if (*f == NULL)
+    luaL_error(L, "attempt to use a closed file");
+  return *f;
+}
+
+
+
+/*
+** When creating file handles, always creates a `closed' file handle
+** before opening the actual file; so, if there is a memory error, the
+** file is not left opened.
+*/
+static FILE **newfile (lua_State *L) {
+  FILE **pf = (FILE **)lua_newuserdata(L, sizeof(FILE *));
+  *pf = NULL;  /* file handle is currently `closed' */
+  luaL_getmetatable(L, FILEHANDLE);
+  lua_setmetatable(L, -2);
+  return pf;
+}
+
+
+/*
+** assumes that top of the stack is the `io' library, and next is
+** the `io' metatable
+*/
+static void registerfile (lua_State *L, FILE *f, const char *name,
+                                                 const char *impname) {
+  lua_pushstring(L, name);
+  *newfile(L) = f;
+  if (impname) {
+    lua_pushstring(L, impname);
+    lua_pushvalue(L, -2);
+    lua_settable(L, -6);  /* metatable[impname] = file */
+  }
+  lua_settable(L, -3);  /* io[name] = file */
+}
+
+
+static int aux_close (lua_State *L) {
+  FILE *f = tofile(L, 1);
+  if (f == stdin || f == stdout || f == stderr)
+    return 0;  /* file cannot be closed */
+  else {
+    int ok = (pclose(f) != -1) || (fclose(f) == 0);
+    if (ok)
+      *(FILE **)lua_touserdata(L, 1) = NULL;  /* mark file as closed */
+    return ok;
+  }
+}
+
+
+static int io_close (lua_State *L) {
+  if (lua_isnone(L, 1)) {
+    lua_pushstring(L, IO_OUTPUT);
+    lua_rawget(L, lua_upvalueindex(1));
+  }
+  return pushresult(L, aux_close(L), NULL);
+}
+
+
+static int io_gc (lua_State *L) {
+  FILE **f = topfile(L, 1);
+  if (*f != NULL)  /* ignore closed files */
+    aux_close(L);
+  return 0;
+}
+
+
+static int io_tostring (lua_State *L) {
+  char buff[32];
+  FILE **f = topfile(L, 1);
+  if (*f == NULL)
+    strcpy(buff, "closed");
+  else
+    sprintf(buff, "%p", lua_touserdata(L, 1));
+  lua_pushfstring(L, "file (%s)", buff);
+  return 1;
+}
+
+
+static int io_open (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  const char *mode = luaL_optstring(L, 2, "r");
+  FILE **pf = newfile(L);
+  *pf = fopen(filename, mode);
+  return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
+}
+
+
+static int io_popen (lua_State *L) {
+#if !USE_POPEN
+  luaL_error(L, "`popen' not supported");
+  return 0;
+#else
+  const char *filename = luaL_checkstring(L, 1);
+  const char *mode = luaL_optstring(L, 2, "r");
+  FILE **pf = newfile(L);
+  *pf = popen(filename, mode);
+  return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
+#endif
+}
+
+
+static int io_tmpfile (lua_State *L) {
+  FILE **pf = newfile(L);
+  *pf = tmpfile();
+  return (*pf == NULL) ? pushresult(L, 0, NULL) : 1;
+}
+
+
+static FILE *getiofile (lua_State *L, const char *name) {
+  lua_pushstring(L, name);
+  lua_rawget(L, lua_upvalueindex(1));
+  return tofile(L, -1);
+}
+
+
+static int g_iofile (lua_State *L, const char *name, const char *mode) {
+  if (!lua_isnoneornil(L, 1)) {
+    const char *filename = lua_tostring(L, 1);
+    lua_pushstring(L, name);
+    if (filename) {
+      FILE **pf = newfile(L);
+      *pf = fopen(filename, mode);
+      if (*pf == NULL) {
+        lua_pushfstring(L, "%s: %s", filename, strerror(errno));
+        luaL_argerror(L, 1, lua_tostring(L, -1));
+      }
+    }
+    else {
+      tofile(L, 1);  /* check that it's a valid file handle */
+      lua_pushvalue(L, 1);
+    }
+    lua_rawset(L, lua_upvalueindex(1));
+  }
+  /* return current value */
+  lua_pushstring(L, name);
+  lua_rawget(L, lua_upvalueindex(1));
+  return 1;
+}
+
+
+static int io_input (lua_State *L) {
+  return g_iofile(L, IO_INPUT, "r");
+}
+
+
+static int io_output (lua_State *L) {
+  return g_iofile(L, IO_OUTPUT, "w");
+}
+
+
+static int io_readline (lua_State *L);
+
+
+static void aux_lines (lua_State *L, int idx, int close) {
+  lua_pushliteral(L, FILEHANDLE);
+  lua_rawget(L, LUA_REGISTRYINDEX);
+  lua_pushvalue(L, idx);
+  lua_pushboolean(L, close);  /* close/not close file when finished */
+  lua_pushcclosure(L, io_readline, 3);
+}
+
+
+static int f_lines (lua_State *L) {
+  tofile(L, 1);  /* check that it's a valid file handle */
+  aux_lines(L, 1, 0);
+  return 1;
+}
+
+
+static int io_lines (lua_State *L) {
+  if (lua_isnoneornil(L, 1)) {  /* no arguments? */
+    lua_pushstring(L, IO_INPUT);
+    lua_rawget(L, lua_upvalueindex(1));  /* will iterate over default input */
+    return f_lines(L);
+  }
+  else {
+    const char *filename = luaL_checkstring(L, 1);
+    FILE **pf = newfile(L);
+    *pf = fopen(filename, "r");
+    luaL_argcheck(L, *pf, 1,  strerror(errno));
+    aux_lines(L, lua_gettop(L), 1);
+    return 1;
+  }
+}
+
+
+/*
+** {======================================================
+** READ
+** =======================================================
+*/
+
+
+static int read_number (lua_State *L, FILE *f) {
+  lua_Number d;
+  if (fscanf(f, LUA_NUMBER_SCAN, &d) == 1) {
+    lua_pushnumber(L, d);
+    return 1;
+  }
+  else return 0;  /* read fails */
+}
+
+
+static int test_eof (lua_State *L, FILE *f) {
+  int c = getc(f);
+  ungetc(c, f);
+  lua_pushlstring(L, NULL, 0);
+  return (c != EOF);
+}
+
+
+static int read_line (lua_State *L, FILE *f) {
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  for (;;) {
+    size_t l;
+    char *p = luaL_prepbuffer(&b);
+    if (fgets(p, LUAL_BUFFERSIZE, f) == NULL) {  /* eof? */
+      luaL_pushresult(&b);  /* close buffer */
+      return (lua_strlen(L, -1) > 0);  /* check whether read something */
+    }
+    l = strlen(p);
+    if (p[l-1] != '\n')
+      luaL_addsize(&b, l);
+    else {
+      luaL_addsize(&b, l - 1);  /* do not include `eol' */
+      luaL_pushresult(&b);  /* close buffer */
+      return 1;  /* read at least an `eol' */
+    }
+  }
+}
+
+
+static int read_chars (lua_State *L, FILE *f, size_t n) {
+  size_t rlen;  /* how much to read */
+  size_t nr;  /* number of chars actually read */
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  rlen = LUAL_BUFFERSIZE;  /* try to read that much each time */
+  do {
+    char *p = luaL_prepbuffer(&b);
+    if (rlen > n) rlen = n;  /* cannot read more than asked */
+    nr = fread(p, sizeof(char), rlen, f);
+    luaL_addsize(&b, nr);
+    n -= nr;  /* still have to read `n' chars */
+  } while (n > 0 && nr == rlen);  /* until end of count or eof */
+  luaL_pushresult(&b);  /* close buffer */
+  return (n == 0 || lua_strlen(L, -1) > 0);
+}
+
+
+static int g_read (lua_State *L, FILE *f, int first) {
+  int nargs = lua_gettop(L) - 1;
+  int success;
+  int n;
+  if (nargs == 0) {  /* no arguments? */
+    success = read_line(L, f);
+    n = first+1;  /* to return 1 result */
+  }
+  else {  /* ensure stack space for all results and for auxlib's buffer */
+    luaL_checkstack(L, nargs+LUA_MINSTACK, "too many arguments");
+    success = 1;
+    for (n = first; nargs-- && success; n++) {
+      if (lua_type(L, n) == LUA_TNUMBER) {
+        size_t l = (size_t)lua_tonumber(L, n);
+        success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);
+      }
+      else {
+        const char *p = lua_tostring(L, n);
+        luaL_argcheck(L, p && p[0] == '*', n, "invalid option");
+        switch (p[1]) {
+          case 'n':  /* number */
+            success = read_number(L, f);
+            break;
+          case 'l':  /* line */
+            success = read_line(L, f);
+            break;
+          case 'a':  /* file */
+            read_chars(L, f, ~((size_t)0));  /* read MAX_SIZE_T chars */
+            success = 1; /* always success */
+            break;
+          case 'w':  /* word */
+            return luaL_error(L, "obsolete option `*w' to `read'");
+          default:
+            return luaL_argerror(L, n, "invalid format");
+        }
+      }
+    }
+  }
+  if (!success) {
+    lua_pop(L, 1);  /* remove last result */
+    lua_pushnil(L);  /* push nil instead */
+  }
+  return n - first;
+}
+
+
+static int io_read (lua_State *L) {
+  return g_read(L, getiofile(L, IO_INPUT), 1);
+}
+
+
+static int f_read (lua_State *L) {
+  return g_read(L, tofile(L, 1), 2);
+}
+
+
+static int io_readline (lua_State *L) {
+  FILE *f = *(FILE **)lua_touserdata(L, lua_upvalueindex(2));
+  if (f == NULL)  /* file is already closed? */
+    luaL_error(L, "file is already closed");
+  if (read_line(L, f)) return 1;
+  else {  /* EOF */
+    if (lua_toboolean(L, lua_upvalueindex(3))) {  /* generator created file? */
+      lua_settop(L, 0);
+      lua_pushvalue(L, lua_upvalueindex(2));
+      aux_close(L);  /* close it */
+    }
+    return 0;
+  }
+}
+
+/* }====================================================== */
+
+
+static int g_write (lua_State *L, FILE *f, int arg) {
+  int nargs = lua_gettop(L) - 1;
+  int status = 1;
+  for (; nargs--; arg++) {
+    if (lua_type(L, arg) == LUA_TNUMBER) {
+      /* optimization: could be done exactly as for strings */
+      status = status &&
+          fprintf(f, LUA_NUMBER_FMT, lua_tonumber(L, arg)) > 0;
+    }
+    else {
+      size_t l;
+      const char *s = luaL_checklstring(L, arg, &l);
+      status = status && (fwrite(s, sizeof(char), l, f) == l);
+    }
+  }
+  return pushresult(L, status, NULL);
+}
+
+
+static int io_write (lua_State *L) {
+  return g_write(L, getiofile(L, IO_OUTPUT), 1);
+}
+
+
+static int f_write (lua_State *L) {
+  return g_write(L, tofile(L, 1), 2);
+}
+
+
+static int f_seek (lua_State *L) {
+  static const int mode[] = {SEEK_SET, SEEK_CUR, SEEK_END};
+  static const char *const modenames[] = {"set", "cur", "end", NULL};
+  FILE *f = tofile(L, 1);
+  int op = luaL_findstring(luaL_optstring(L, 2, "cur"), modenames);
+  long offset = luaL_optlong(L, 3, 0);
+  luaL_argcheck(L, op != -1, 2, "invalid mode");
+  op = fseek(f, offset, mode[op]);
+  if (op)
+    return pushresult(L, 0, NULL);  /* error */
+  else {
+    lua_pushnumber(L, ftell(f));
+    return 1;
+  }
+}
+
+
+static int io_flush (lua_State *L) {
+  return pushresult(L, fflush(getiofile(L, IO_OUTPUT)) == 0, NULL);
+}
+
+
+static int f_flush (lua_State *L) {
+  return pushresult(L, fflush(tofile(L, 1)) == 0, NULL);
+}
+
+
+static const luaL_reg iolib[] = {
+  {"input", io_input},
+  {"output", io_output},
+  {"lines", io_lines},
+  {"close", io_close},
+  {"flush", io_flush},
+  {"open", io_open},
+  {"popen", io_popen},
+  {"read", io_read},
+  {"tmpfile", io_tmpfile},
+  {"type", io_type},
+  {"write", io_write},
+  {NULL, NULL}
+};
+
+
+static const luaL_reg flib[] = {
+  {"flush", f_flush},
+  {"read", f_read},
+  {"lines", f_lines},
+  {"seek", f_seek},
+  {"write", f_write},
+  {"close", io_close},
+  {"__gc", io_gc},
+  {"__tostring", io_tostring},
+  {NULL, NULL}
+};
+
+
+static void createmeta (lua_State *L) {
+  luaL_newmetatable(L, FILEHANDLE);  /* create new metatable for file handles */
+  /* file methods */
+  lua_pushliteral(L, "__index");
+  lua_pushvalue(L, -2);  /* push metatable */
+  lua_rawset(L, -3);  /* metatable.__index = metatable */
+  luaL_openlib(L, NULL, flib, 0);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Other O.S. Operations
+** =======================================================
+*/
+
+static int io_execute (lua_State *L) {
+  lua_pushnumber(L, system(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+
+static int io_remove (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  return pushresult(L, remove(filename) == 0, filename);
+}
+
+
+static int io_rename (lua_State *L) {
+  const char *fromname = luaL_checkstring(L, 1);
+  const char *toname = luaL_checkstring(L, 2);
+  return pushresult(L, rename(fromname, toname) == 0, fromname);
+}
+
+
+static int io_tmpname (lua_State *L) {
+#if !USE_TMPNAME
+  luaL_error(L, "`tmpname' not supported");
+  return 0;
+#else
+  char buff[L_tmpnam];
+  if (tmpnam(buff) != buff)
+    return luaL_error(L, "unable to generate a unique filename in `tmpname'");
+  lua_pushstring(L, buff);
+  return 1;
+#endif
+}
+
+
+static int io_getenv (lua_State *L) {
+  lua_pushstring(L, getenv(luaL_checkstring(L, 1)));  /* if NULL push nil */
+  return 1;
+}
+
+
+static int io_clock (lua_State *L) {
+  lua_pushnumber(L, ((lua_Number)clock())/(lua_Number)CLOCKS_PER_SEC);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** Time/Date operations
+** { year=%Y, month=%m, day=%d, hour=%H, min=%M, sec=%S,
+**   wday=%w+1, yday=%j, isdst=? }
+** =======================================================
+*/
+
+static void setfield (lua_State *L, const char *key, int value) {
+  lua_pushstring(L, key);
+  lua_pushnumber(L, value);
+  lua_rawset(L, -3);
+}
+
+static void setboolfield (lua_State *L, const char *key, int value) {
+  lua_pushstring(L, key);
+  lua_pushboolean(L, value);
+  lua_rawset(L, -3);
+}
+
+static int getboolfield (lua_State *L, const char *key) {
+  int res;
+  lua_pushstring(L, key);
+  lua_gettable(L, -2);
+  res = lua_toboolean(L, -1);
+  lua_pop(L, 1);
+  return res;
+}
+
+
+static int getfield (lua_State *L, const char *key, int d) {
+  int res;
+  lua_pushstring(L, key);
+  lua_gettable(L, -2);
+  if (lua_isnumber(L, -1))
+    res = (int)(lua_tonumber(L, -1));
+  else {
+    if (d == -2)
+      return luaL_error(L, "field `%s' missing in date table", key);
+    res = d;
+  }
+  lua_pop(L, 1);
+  return res;
+}
+
+
+static int io_date (lua_State *L) {
+  const char *s = luaL_optstring(L, 1, "%c");
+  time_t t = (time_t)(luaL_optnumber(L, 2, -1));
+  struct tm *stm;
+  if (t == (time_t)(-1))  /* no time given? */
+    t = time(NULL);  /* use current time */
+  if (*s == '!') {  /* UTC? */
+    stm = gmtime(&t);
+    s++;  /* skip `!' */
+  }
+  else
+    stm = localtime(&t);
+  if (stm == NULL)  /* invalid date? */
+    lua_pushnil(L);
+  else if (strcmp(s, "*t") == 0) {
+    lua_newtable(L);
+    setfield(L, "sec", stm->tm_sec);
+    setfield(L, "min", stm->tm_min);
+    setfield(L, "hour", stm->tm_hour);
+    setfield(L, "day", stm->tm_mday);
+    setfield(L, "month", stm->tm_mon+1);
+    setfield(L, "year", stm->tm_year+1900);
+    setfield(L, "wday", stm->tm_wday+1);
+    setfield(L, "yday", stm->tm_yday+1);
+    setboolfield(L, "isdst", stm->tm_isdst);
+  }
+  else {
+    char b[256];
+    if (strftime(b, sizeof(b), s, stm))
+      lua_pushstring(L, b);
+    else
+      return luaL_error(L, "`date' format too long");
+  }
+  return 1;
+}
+
+
+static int io_time (lua_State *L) {
+  if (lua_isnoneornil(L, 1))  /* called without args? */
+    lua_pushnumber(L, time(NULL));  /* return current time */
+  else {
+    time_t t;
+    struct tm ts;
+    luaL_checktype(L, 1, LUA_TTABLE);
+    lua_settop(L, 1);  /* make sure table is at the top */
+    ts.tm_sec = getfield(L, "sec", 0);
+    ts.tm_min = getfield(L, "min", 0);
+    ts.tm_hour = getfield(L, "hour", 12);
+    ts.tm_mday = getfield(L, "day", -2);
+    ts.tm_mon = getfield(L, "month", -2) - 1;
+    ts.tm_year = getfield(L, "year", -2) - 1900;
+    ts.tm_isdst = getboolfield(L, "isdst");
+    t = mktime(&ts);
+    if (t == (time_t)(-1))
+      lua_pushnil(L);
+    else
+      lua_pushnumber(L, t);
+  }
+  return 1;
+}
+
+
+static int io_difftime (lua_State *L) {
+  lua_pushnumber(L, difftime((time_t)(luaL_checknumber(L, 1)),
+                             (time_t)(luaL_optnumber(L, 2, 0))));
+  return 1;
+}
+
+/* }====================================================== */
+
+
+static int io_setloc (lua_State *L) {
+  static const int cat[] = {LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY,
+                      LC_NUMERIC, LC_TIME};
+  static const char *const catnames[] = {"all", "collate", "ctype", "monetary",
+     "numeric", "time", NULL};
+  const char *l = lua_tostring(L, 1);
+  int op = luaL_findstring(luaL_optstring(L, 2, "all"), catnames);
+  luaL_argcheck(L, l || lua_isnoneornil(L, 1), 1, "string expected");
+  luaL_argcheck(L, op != -1, 2, "invalid option");
+  lua_pushstring(L, setlocale(cat[op], l));
+  return 1;
+}
+
+
+static int io_exit (lua_State *L) {
+  exit(luaL_optint(L, 1, EXIT_SUCCESS));
+  return 0;  /* to avoid warnings */
+}
+
+static const luaL_reg syslib[] = {
+  {"clock",     io_clock},
+  {"date",      io_date},
+  {"difftime",  io_difftime},
+  {"execute",   io_execute},
+  {"exit",      io_exit},
+  {"getenv",    io_getenv},
+  {"remove",    io_remove},
+  {"rename",    io_rename},
+  {"setlocale", io_setloc},
+  {"time",      io_time},
+  {"tmpname",   io_tmpname},
+  {NULL, NULL}
+};
+
+/* }====================================================== */
+
+
+
+LUALIB_API int luaopen_io (lua_State *L) {
+  luaL_openlib(L, LUA_OSLIBNAME, syslib, 0);
+  createmeta(L);
+  lua_pushvalue(L, -1);
+  luaL_openlib(L, LUA_IOLIBNAME, iolib, 1);
+  /* put predefined file handles into `io' table */
+  registerfile(L, stdin, "stdin", IO_INPUT);
+  registerfile(L, stdout, "stdout", IO_OUTPUT);
+  registerfile(L, stderr, "stderr", NULL);
+  return 1;
+}
+

Added: trunk/source/libraries/lua/lib/lmathlib.c
===================================================================
--- trunk/source/libraries/lua/lib/lmathlib.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/lmathlib.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,246 @@
+/*
+** $Id: lmathlib.c,v 1.56 2003/03/11 12:30:37 roberto Exp $
+** Standard mathematical library
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+#include <math.h>
+
+#define lmathlib_c
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#undef PI
+#define PI (3.14159265358979323846)
+#define RADIANS_PER_DEGREE (PI/180.0)
+
+
+
+/*
+** If you want Lua to operate in degrees (instead of radians),
+** define USE_DEGREES
+*/
+#ifdef USE_DEGREES
+#define FROMRAD(a)	((a)/RADIANS_PER_DEGREE)
+#define TORAD(a)	((a)*RADIANS_PER_DEGREE)
+#else
+#define FROMRAD(a)	(a)
+#define TORAD(a)	(a)
+#endif
+
+
+static int math_abs (lua_State *L) {
+  lua_pushnumber(L, fabs(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_sin (lua_State *L) {
+  lua_pushnumber(L, sin(TORAD(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_cos (lua_State *L) {
+  lua_pushnumber(L, cos(TORAD(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_tan (lua_State *L) {
+  lua_pushnumber(L, tan(TORAD(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_asin (lua_State *L) {
+  lua_pushnumber(L, FROMRAD(asin(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_acos (lua_State *L) {
+  lua_pushnumber(L, FROMRAD(acos(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_atan (lua_State *L) {
+  lua_pushnumber(L, FROMRAD(atan(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_atan2 (lua_State *L) {
+  lua_pushnumber(L, FROMRAD(atan2(luaL_checknumber(L, 1), luaL_checknumber(L, 2))));
+  return 1;
+}
+
+static int math_ceil (lua_State *L) {
+  lua_pushnumber(L, ceil(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_floor (lua_State *L) {
+  lua_pushnumber(L, floor(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_mod (lua_State *L) {
+  lua_pushnumber(L, fmod(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int math_sqrt (lua_State *L) {
+  lua_pushnumber(L, sqrt(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_pow (lua_State *L) {
+  lua_pushnumber(L, pow(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int math_log (lua_State *L) {
+  lua_pushnumber(L, log(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_log10 (lua_State *L) {
+  lua_pushnumber(L, log10(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_exp (lua_State *L) {
+  lua_pushnumber(L, exp(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_deg (lua_State *L) {
+  lua_pushnumber(L, luaL_checknumber(L, 1)/RADIANS_PER_DEGREE);
+  return 1;
+}
+
+static int math_rad (lua_State *L) {
+  lua_pushnumber(L, luaL_checknumber(L, 1)*RADIANS_PER_DEGREE);
+  return 1;
+}
+
+static int math_frexp (lua_State *L) {
+  int e;
+  lua_pushnumber(L, frexp(luaL_checknumber(L, 1), &e));
+  lua_pushnumber(L, e);
+  return 2;
+}
+
+static int math_ldexp (lua_State *L) {
+  lua_pushnumber(L, ldexp(luaL_checknumber(L, 1), luaL_checkint(L, 2)));
+  return 1;
+}
+
+
+
+static int math_min (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  lua_Number dmin = luaL_checknumber(L, 1);
+  int i;
+  for (i=2; i<=n; i++) {
+    lua_Number d = luaL_checknumber(L, i);
+    if (d < dmin)
+      dmin = d;
+  }
+  lua_pushnumber(L, dmin);
+  return 1;
+}
+
+
+static int math_max (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  lua_Number dmax = luaL_checknumber(L, 1);
+  int i;
+  for (i=2; i<=n; i++) {
+    lua_Number d = luaL_checknumber(L, i);
+    if (d > dmax)
+      dmax = d;
+  }
+  lua_pushnumber(L, dmax);
+  return 1;
+}
+
+
+static int math_random (lua_State *L) {
+  /* the `%' avoids the (rare) case of r==1, and is needed also because on
+     some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
+  lua_Number r = (lua_Number)(rand()%RAND_MAX) / (lua_Number)RAND_MAX;
+  switch (lua_gettop(L)) {  /* check number of arguments */
+    case 0: {  /* no arguments */
+      lua_pushnumber(L, r);  /* Number between 0 and 1 */
+      break;
+    }
+    case 1: {  /* only upper limit */
+      int u = luaL_checkint(L, 1);
+      luaL_argcheck(L, 1<=u, 1, "interval is empty");
+      lua_pushnumber(L, (int)floor(r*u)+1);  /* int between 1 and `u' */
+      break;
+    }
+    case 2: {  /* lower and upper limits */
+      int l = luaL_checkint(L, 1);
+      int u = luaL_checkint(L, 2);
+      luaL_argcheck(L, l<=u, 2, "interval is empty");
+      lua_pushnumber(L, (int)floor(r*(u-l+1))+l);  /* int between `l' and `u' */
+      break;
+    }
+    default: return luaL_error(L, "wrong number of arguments");
+  }
+  return 1;
+}
+
+
+static int math_randomseed (lua_State *L) {
+  srand(luaL_checkint(L, 1));
+  return 0;
+}
+
+
+static const luaL_reg mathlib[] = {
+  {"abs",   math_abs},
+  {"sin",   math_sin},
+  {"cos",   math_cos},
+  {"tan",   math_tan},
+  {"asin",  math_asin},
+  {"acos",  math_acos},
+  {"atan",  math_atan},
+  {"atan2", math_atan2},
+  {"ceil",  math_ceil},
+  {"floor", math_floor},
+  {"mod",   math_mod},
+  {"frexp", math_frexp},
+  {"ldexp", math_ldexp},
+  {"sqrt",  math_sqrt},
+  {"min",   math_min},
+  {"max",   math_max},
+  {"log",   math_log},
+  {"log10", math_log10},
+  {"exp",   math_exp},
+  {"deg",   math_deg},
+  {"pow",   math_pow},
+  {"rad",   math_rad},
+  {"random",     math_random},
+  {"randomseed", math_randomseed},
+  {NULL, NULL}
+};
+
+
+/*
+** Open math library
+*/
+LUALIB_API int luaopen_math (lua_State *L) {
+  luaL_openlib(L, LUA_MATHLIBNAME, mathlib, 0);
+  lua_pushliteral(L, "pi");
+  lua_pushnumber(L, PI);
+  lua_settable(L, -3);
+  lua_pushliteral(L, "__pow");
+  lua_pushcfunction(L, math_pow);
+  lua_settable(L, LUA_GLOBALSINDEX);
+  return 1;
+}
+

Added: trunk/source/libraries/lua/lib/loadlib.c
===================================================================
--- trunk/source/libraries/lua/lib/loadlib.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/loadlib.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,205 @@
+/*
+** $Id: loadlib.c,v 1.4 2003/04/07 20:11:53 roberto Exp $
+** Dynamic library loader for Lua
+** See Copyright Notice in lua.h
+*
+* This  Lua library  exports a  single function,  called loadlib,  which is
+* called from Lua  as loadlib(lib,init), where lib is the  full name of the
+* library to be  loaded (including the complete path) and  init is the name
+* of a function  to be called after the library  is loaded. Typically, this
+* function will register other functions,  thus making the complete library
+* available  to Lua.  The init  function is  *not* automatically  called by
+* loadlib. Instead,  loadlib returns  the init function  as a  Lua function
+* that the client  can call when it  thinks is appropriate. In  the case of
+* errors,  loadlib  returns  nil  and two  strings  describing  the  error.
+* The  first string  is  supplied by  the operating  system;  it should  be
+* informative and useful  for error messages. The second  string is "open",
+* "init", or  "absent" to identify  the error and is  meant to be  used for
+* making  decisions without  having to  look into  the first  string (whose
+* format is system-dependent).
+*
+* This module contains  an implementation of loadlib for  Unix systems that
+* have dlfcn, an implementation for Windows,  and a stub for other systems.
+* See  the list  at  the end  of  this  file for  some  links to  available
+* implementations of dlfcn  and interfaces to other  native dynamic loaders
+* on top of which loadlib could be implemented.
+*
+*/
+
+#include "lua.h"
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#undef LOADLIB
+
+
+#ifdef USE_DLOPEN
+#define LOADLIB
+/*
+* This is an implementation of loadlib based on the dlfcn interface.
+* The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,
+* NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least
+* as an emulation layer on top of native functions.
+*/
+
+#include <dlfcn.h>
+
+static int loadlib(lua_State *L)
+{
+ const char *path=luaL_checkstring(L,1);
+ const char *init=luaL_checkstring(L,2);
+ void *lib=dlopen(path,RTLD_NOW);
+ if (lib!=NULL)
+ {
+  lua_CFunction f=(lua_CFunction) dlsym(lib,init);
+  if (f!=NULL)
+  {
+   lua_pushlightuserdata(L,lib);
+   lua_pushcclosure(L,f,1);
+   return 1;
+  }
+ }
+ /* else return appropriate error messages */
+ lua_pushnil(L);
+ lua_pushstring(L,dlerror());
+ lua_pushstring(L,(lib!=NULL) ? "init" : "open");
+ if (lib!=NULL) dlclose(lib);
+ return 3;
+}
+
+#endif
+
+
+
+/*
+** In Windows, default is to use dll; otherwise, default is not to use dll
+*/
+#ifndef USE_DLL
+#ifdef _WIN32
+#define USE_DLL	1
+#else
+#define USE_DLL	0
+#endif
+#endif
+
+
+#if USE_DLL
+#define LOADLIB
+/*
+* This is an implementation of loadlib for Windows using native functions.
+*/
+
+#include <windows.h>
+
+static void pusherror(lua_State *L)
+{
+ int error=GetLastError();
+ char buffer[128];
+ if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
+	0, error, 0, buffer, sizeof(buffer), 0))
+  lua_pushstring(L,buffer);
+ else
+  lua_pushfstring(L,"system error %d\n",error);
+}
+
+static int loadlib(lua_State *L)
+{
+ const char *path=luaL_checkstring(L,1);
+ const char *init=luaL_checkstring(L,2);
+ HINSTANCE lib=LoadLibrary(path);
+ if (lib!=NULL)
+ {
+  lua_CFunction f=(lua_CFunction) GetProcAddress(lib,init);
+  if (f!=NULL)
+  {
+   lua_pushlightuserdata(L,lib);
+   lua_pushcclosure(L,f,1);
+   return 1;
+  }
+ }
+ lua_pushnil(L);
+ pusherror(L);
+ lua_pushstring(L,(lib!=NULL) ? "init" : "open");
+ if (lib!=NULL) FreeLibrary(lib);
+ return 3;
+}
+
+#endif
+
+
+
+#ifndef LOADLIB
+/* Fallback for other systems */
+
+/*
+** Those systems support dlopen, so they should have defined USE_DLOPEN.
+** The default (no)implementation gives them a special error message.
+*/
+#ifdef linux
+#define LOADLIB
+#endif
+
+#ifdef sun
+#define LOADLIB
+#endif
+
+#ifdef sgi
+#define LOADLIB
+#endif
+
+#ifdef BSD
+#define LOADLIB
+#endif
+
+#ifdef _WIN32
+#define LOADLIB
+#endif
+
+#ifdef LOADLIB
+#undef LOADLIB
+#define LOADLIB	"`loadlib' not installed (check your Lua configuration)"
+#else
+#define LOADLIB	"`loadlib' not supported"
+#endif
+
+static int loadlib(lua_State *L)
+{
+ lua_pushnil(L);
+ lua_pushliteral(L,LOADLIB);
+ lua_pushliteral(L,"absent");
+ return 3;
+}
+#endif
+
+LUALIB_API int luaopen_loadlib (lua_State *L)
+{
+ lua_register(L,"loadlib",loadlib);
+ return 0;
+}
+
+/*
+* Here are some links to available implementations of dlfcn and
+* interfaces to other native dynamic loaders on top of which loadlib
+* could be implemented. Please send contributions and corrections to us.
+*
+* AIX
+* Starting with AIX 4.2, dlfcn is included in the base OS.
+* There is also an emulation package available.
+* http://www.faqs.org/faqs/aix-faq/part4/section-21.html
+*
+* HPUX 
+* HPUX 11 has dlfcn. For HPUX 10 use shl_*.
+* http://www.geda.seul.org/mailinglist/geda-dev37/msg00094.html
+* http://www.stat.umn.edu/~luke/xls/projects/dlbasics/dlbasics.html
+*
+* Macintosh, Windows
+* http://www.stat.umn.edu/~luke/xls/projects/dlbasics/dlbasics.html
+*
+* Mac OS X/Darwin
+* http://www.opendarwin.org/projects/dlcompat/
+*
+* GLIB has wrapper code for BeOS, OS2, Unix and Windows
+* http://cvs.gnome.org/lxr/source/glib/gmodule/
+*
+*/

Added: trunk/source/libraries/lua/lib/lstrlib.c
===================================================================
--- trunk/source/libraries/lua/lib/lstrlib.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/lstrlib.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,770 @@
+/*
+** $Id: lstrlib.c,v 1.98 2003/04/03 13:35:34 roberto Exp $
+** Standard library for string operations and pattern-matching
+** See Copyright Notice in lua.h
+*/
+
+
+#include <ctype.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lstrlib_c
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/* macro to `unsign' a character */
+#ifndef uchar
+#define uchar(c)        ((unsigned char)(c))
+#endif
+
+
+typedef long sint32;	/* a signed version for size_t */
+
+
+static int str_len (lua_State *L) {
+  size_t l;
+  luaL_checklstring(L, 1, &l);
+  lua_pushnumber(L, (lua_Number)l);
+  return 1;
+}
+
+
+static sint32 posrelat (sint32 pos, size_t len) {
+  /* relative string position: negative means back from end */
+  return (pos>=0) ? pos : (sint32)len+pos+1;
+}
+
+
+static int str_sub (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &l);
+  sint32 start = posrelat(luaL_checklong(L, 2), l);
+  sint32 end = posrelat(luaL_optlong(L, 3, -1), l);
+  if (start < 1) start = 1;
+  if (end > (sint32)l) end = (sint32)l;
+  if (start <= end)
+    lua_pushlstring(L, s+start-1, end-start+1);
+  else lua_pushliteral(L, "");
+  return 1;
+}
+
+
+static int str_lower (lua_State *L) {
+  size_t l;
+  size_t i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &l);
+  luaL_buffinit(L, &b);
+  for (i=0; i<l; i++)
+    luaL_putchar(&b, tolower(uchar(s[i])));
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+static int str_upper (lua_State *L) {
+  size_t l;
+  size_t i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &l);
+  luaL_buffinit(L, &b);
+  for (i=0; i<l; i++)
+    luaL_putchar(&b, toupper(uchar(s[i])));
+  luaL_pushresult(&b);
+  return 1;
+}
+
+static int str_rep (lua_State *L) {
+  size_t l;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &l);
+  int n = luaL_checkint(L, 2);
+  luaL_buffinit(L, &b);
+  while (n-- > 0)
+    luaL_addlstring(&b, s, l);
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+static int str_byte (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &l);
+  sint32 pos = posrelat(luaL_optlong(L, 2, 1), l);
+  if (pos <= 0 || (size_t)(pos) > l)  /* index out of range? */
+    return 0;  /* no answer */
+  lua_pushnumber(L, uchar(s[pos-1]));
+  return 1;
+}
+
+
+static int str_char (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  int i;
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  for (i=1; i<=n; i++) {
+    int c = luaL_checkint(L, i);
+    luaL_argcheck(L, uchar(c) == c, i, "invalid value");
+    luaL_putchar(&b, uchar(c));
+  }
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+static int writer (lua_State *L, const void* b, size_t size, void* B) {
+  (void)L;
+  luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
+  return 1;
+}
+
+
+static int str_dump (lua_State *L) {
+  luaL_Buffer b;
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  luaL_buffinit(L,&b);
+  if (!lua_dump(L, writer, &b))
+    luaL_error(L, "unable to dump given function");
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+
+/*
+** {======================================================
+** PATTERN MATCHING
+** =======================================================
+*/
+
+#ifndef MAX_CAPTURES
+#define MAX_CAPTURES 32  /* arbitrary limit */
+#endif
+
+
+#define CAP_UNFINISHED	(-1)
+#define CAP_POSITION	(-2)
+
+typedef struct MatchState {
+  const char *src_init;  /* init of source string */
+  const char *src_end;  /* end (`\0') of source string */
+  lua_State *L;
+  int level;  /* total number of captures (finished or unfinished) */
+  struct {
+    const char *init;
+    sint32 len;
+  } capture[MAX_CAPTURES];
+} MatchState;
+
+
+#define ESC		'%'
+#define SPECIALS	"^$*+?.([%-"
+
+
+static int check_capture (MatchState *ms, int l) {
+  l -= '1';
+  if (l < 0 || l >= ms->level || ms->capture[l].len == CAP_UNFINISHED)
+    return luaL_error(ms->L, "invalid capture index");
+  return l;
+}
+
+
+static int capture_to_close (MatchState *ms) {
+  int level = ms->level;
+  for (level--; level>=0; level--)
+    if (ms->capture[level].len == CAP_UNFINISHED) return level;
+  return luaL_error(ms->L, "invalid pattern capture");
+}
+
+
+static const char *luaI_classend (MatchState *ms, const char *p) {
+  switch (*p++) {
+    case ESC: {
+      if (*p == '\0')
+        luaL_error(ms->L, "malformed pattern (ends with `%')");
+      return p+1;
+    }
+    case '[': {
+      if (*p == '^') p++;
+      do {  /* look for a `]' */
+        if (*p == '\0')
+          luaL_error(ms->L, "malformed pattern (missing `]')");
+        if (*(p++) == ESC && *p != '\0')
+          p++;  /* skip escapes (e.g. `%]') */
+      } while (*p != ']');
+      return p+1;
+    }
+    default: {
+      return p;
+    }
+  }
+}
+
+
+static int match_class (int c, int cl) {
+  int res;
+  switch (tolower(cl)) {
+    case 'a' : res = isalpha(c); break;
+    case 'c' : res = iscntrl(c); break;
+    case 'd' : res = isdigit(c); break;
+    case 'l' : res = islower(c); break;
+    case 'p' : res = ispunct(c); break;
+    case 's' : res = isspace(c); break;
+    case 'u' : res = isupper(c); break;
+    case 'w' : res = isalnum(c); break;
+    case 'x' : res = isxdigit(c); break;
+    case 'z' : res = (c == 0); break;
+    default: return (cl == c);
+  }
+  return (islower(cl) ? res : !res);
+}
+
+
+static int matchbracketclass (int c, const char *p, const char *ec) {
+  int sig = 1;
+  if (*(p+1) == '^') {
+    sig = 0;
+    p++;  /* skip the `^' */
+  }
+  while (++p < ec) {
+    if (*p == ESC) {
+      p++;
+      if (match_class(c, *p))
+        return sig;
+    }
+    else if ((*(p+1) == '-') && (p+2 < ec)) {
+      p+=2;
+      if (uchar(*(p-2)) <= c && c <= uchar(*p))
+        return sig;
+    }
+    else if (uchar(*p) == c) return sig;
+  }
+  return !sig;
+}
+
+
+static int luaI_singlematch (int c, const char *p, const char *ep) {
+  switch (*p) {
+    case '.': return 1;  /* matches any char */
+    case ESC: return match_class(c, *(p+1));
+    case '[': return matchbracketclass(c, p, ep-1);
+    default:  return (uchar(*p) == c);
+  }
+}
+
+
+static const char *match (MatchState *ms, const char *s, const char *p);
+
+
+static const char *matchbalance (MatchState *ms, const char *s,
+                                   const char *p) {
+  if (*p == 0 || *(p+1) == 0)
+    luaL_error(ms->L, "unbalanced pattern");
+  if (*s != *p) return NULL;
+  else {
+    int b = *p;
+    int e = *(p+1);
+    int cont = 1;
+    while (++s < ms->src_end) {
+      if (*s == e) {
+        if (--cont == 0) return s+1;
+      }
+      else if (*s == b) cont++;
+    }
+  }
+  return NULL;  /* string ends out of balance */
+}
+
+
+static const char *max_expand (MatchState *ms, const char *s,
+                                 const char *p, const char *ep) {
+  sint32 i = 0;  /* counts maximum expand for item */
+  while ((s+i)<ms->src_end && luaI_singlematch(uchar(*(s+i)), p, ep))
+    i++;
+  /* keeps trying to match with the maximum repetitions */
+  while (i>=0) {
+    const char *res = match(ms, (s+i), ep+1);
+    if (res) return res;
+    i--;  /* else didn't match; reduce 1 repetition to try again */
+  }
+  return NULL;
+}
+
+
+static const char *min_expand (MatchState *ms, const char *s,
+                                 const char *p, const char *ep) {
+  for (;;) {
+    const char *res = match(ms, s, ep+1);
+    if (res != NULL)
+      return res;
+    else if (s<ms->src_end && luaI_singlematch(uchar(*s), p, ep))
+      s++;  /* try with one more repetition */
+    else return NULL;
+  }
+}
+
+
+static const char *start_capture (MatchState *ms, const char *s,
+                                    const char *p, int what) {
+  const char *res;
+  int level = ms->level;
+  if (level >= MAX_CAPTURES) luaL_error(ms->L, "too many captures");
+  ms->capture[level].init = s;
+  ms->capture[level].len = what;
+  ms->level = level+1;
+  if ((res=match(ms, s, p)) == NULL)  /* match failed? */
+    ms->level--;  /* undo capture */
+  return res;
+}
+
+
+static const char *end_capture (MatchState *ms, const char *s,
+                                  const char *p) {
+  int l = capture_to_close(ms);
+  const char *res;
+  ms->capture[l].len = s - ms->capture[l].init;  /* close capture */
+  if ((res = match(ms, s, p)) == NULL)  /* match failed? */
+    ms->capture[l].len = CAP_UNFINISHED;  /* undo capture */
+  return res;
+}
+
+
+static const char *match_capture (MatchState *ms, const char *s, int l) {
+  size_t len;
+  l = check_capture(ms, l);
+  len = ms->capture[l].len;
+  if ((size_t)(ms->src_end-s) >= len &&
+      memcmp(ms->capture[l].init, s, len) == 0)
+    return s+len;
+  else return NULL;
+}
+
+
+static const char *match (MatchState *ms, const char *s, const char *p) {
+  init: /* using goto's to optimize tail recursion */
+  switch (*p) {
+    case '(': {  /* start capture */
+      if (*(p+1) == ')')  /* position capture? */
+        return start_capture(ms, s, p+2, CAP_POSITION);
+      else
+        return start_capture(ms, s, p+1, CAP_UNFINISHED);
+    }
+    case ')': {  /* end capture */
+      return end_capture(ms, s, p+1);
+    }
+    case ESC: {
+      switch (*(p+1)) {
+        case 'b': {  /* balanced string? */
+          s = matchbalance(ms, s, p+2);
+          if (s == NULL) return NULL;
+          p+=4; goto init;  /* else return match(ms, s, p+4); */
+        }
+        case 'f': {  /* frontier? */
+          const char *ep; char previous;
+          p += 2;
+          if (*p != '[')
+            luaL_error(ms->L, "missing `[' after `%%f' in pattern");
+          ep = luaI_classend(ms, p);  /* points to what is next */
+          previous = (s == ms->src_init) ? '\0' : *(s-1);
+          if (matchbracketclass(uchar(previous), p, ep-1) ||
+             !matchbracketclass(uchar(*s), p, ep-1)) return NULL;
+          p=ep; goto init;  /* else return match(ms, s, ep); */
+        }
+        default: {
+          if (isdigit(uchar(*(p+1)))) {  /* capture results (%0-%9)? */
+            s = match_capture(ms, s, *(p+1));
+            if (s == NULL) return NULL;
+            p+=2; goto init;  /* else return match(ms, s, p+2) */
+          }
+          goto dflt;  /* case default */
+        }
+      }
+    }
+    case '\0': {  /* end of pattern */
+      return s;  /* match succeeded */
+    }
+    case '$': {
+      if (*(p+1) == '\0')  /* is the `$' the last char in pattern? */
+        return (s == ms->src_end) ? s : NULL;  /* check end of string */
+      else goto dflt;
+    }
+    default: dflt: {  /* it is a pattern item */
+      const char *ep = luaI_classend(ms, p);  /* points to what is next */
+      int m = s<ms->src_end && luaI_singlematch(uchar(*s), p, ep);
+      switch (*ep) {
+        case '?': {  /* optional */
+          const char *res;
+          if (m && ((res=match(ms, s+1, ep+1)) != NULL))
+            return res;
+          p=ep+1; goto init;  /* else return match(ms, s, ep+1); */
+        }
+        case '*': {  /* 0 or more repetitions */
+          return max_expand(ms, s, p, ep);
+        }
+        case '+': {  /* 1 or more repetitions */
+          return (m ? max_expand(ms, s+1, p, ep) : NULL);
+        }
+        case '-': {  /* 0 or more repetitions (minimum) */
+          return min_expand(ms, s, p, ep);
+        }
+        default: {
+          if (!m) return NULL;
+          s++; p=ep; goto init;  /* else return match(ms, s+1, ep); */
+        }
+      }
+    }
+  }
+}
+
+
+
+static const char *lmemfind (const char *s1, size_t l1,
+                               const char *s2, size_t l2) {
+  if (l2 == 0) return s1;  /* empty strings are everywhere */
+  else if (l2 > l1) return NULL;  /* avoids a negative `l1' */
+  else {
+    const char *init;  /* to search for a `*s2' inside `s1' */
+    l2--;  /* 1st char will be checked by `memchr' */
+    l1 = l1-l2;  /* `s2' cannot be found after that */
+    while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != NULL) {
+      init++;   /* 1st char is already checked */
+      if (memcmp(init, s2+1, l2) == 0)
+        return init-1;
+      else {  /* correct `l1' and `s1' to try again */
+        l1 -= init-s1;
+        s1 = init;
+      }
+    }
+    return NULL;  /* not found */
+  }
+}
+
+
+static void push_onecapture (MatchState *ms, int i) {
+  int l = ms->capture[i].len;
+  if (l == CAP_UNFINISHED) luaL_error(ms->L, "unfinished capture");
+  if (l == CAP_POSITION)
+    lua_pushnumber(ms->L, (lua_Number)(ms->capture[i].init - ms->src_init + 1));
+  else
+    lua_pushlstring(ms->L, ms->capture[i].init, l);
+}
+
+
+static int push_captures (MatchState *ms, const char *s, const char *e) {
+  int i;
+  luaL_checkstack(ms->L, ms->level, "too many captures");
+  if (ms->level == 0 && s) {  /* no explicit captures? */
+    lua_pushlstring(ms->L, s, e-s);  /* return whole match */
+    return 1;
+  }
+  else {  /* return all captures */
+    for (i=0; i<ms->level; i++)
+      push_onecapture(ms, i);
+    return ms->level;  /* number of strings pushed */
+  }
+}
+
+
+static int str_find (lua_State *L) {
+  size_t l1, l2;
+  const char *s = luaL_checklstring(L, 1, &l1);
+  const char *p = luaL_checklstring(L, 2, &l2);
+  sint32 init = posrelat(luaL_optlong(L, 3, 1), l1) - 1;
+  if (init < 0) init = 0;
+  else if ((size_t)(init) > l1) init = (sint32)l1;
+  if (lua_toboolean(L, 4) ||  /* explicit request? */
+      strpbrk(p, SPECIALS) == NULL) {  /* or no special characters? */
+    /* do a plain search */
+    const char *s2 = lmemfind(s+init, l1-init, p, l2);
+    if (s2) {
+      lua_pushnumber(L, (lua_Number)(s2-s+1));
+      lua_pushnumber(L, (lua_Number)(s2-s+l2));
+      return 2;
+    }
+  }
+  else {
+    MatchState ms;
+    int anchor = (*p == '^') ? (p++, 1) : 0;
+    const char *s1=s+init;
+    ms.L = L;
+    ms.src_init = s;
+    ms.src_end = s+l1;
+    do {
+      const char *res;
+      ms.level = 0;
+      if ((res=match(&ms, s1, p)) != NULL) {
+        lua_pushnumber(L, (lua_Number)(s1-s+1));  /* start */
+        lua_pushnumber(L, (lua_Number)(res-s));   /* end */
+        return push_captures(&ms, NULL, 0) + 2;
+      }
+    } while (s1++<ms.src_end && !anchor);
+  }
+  lua_pushnil(L);  /* not found */
+  return 1;
+}
+
+
+static int gfind_aux (lua_State *L) {
+  MatchState ms;
+  const char *s = lua_tostring(L, lua_upvalueindex(1));
+  size_t ls = lua_strlen(L, lua_upvalueindex(1));
+  const char *p = lua_tostring(L, lua_upvalueindex(2));
+  const char *src;
+  ms.L = L;
+  ms.src_init = s;
+  ms.src_end = s+ls;
+  for (src = s + (size_t)lua_tonumber(L, lua_upvalueindex(3));
+       src <= ms.src_end;
+       src++) {
+    const char *e;
+    ms.level = 0;
+    if ((e = match(&ms, src, p)) != NULL) {
+      int newstart = e-s;
+      if (e == src) newstart++;  /* empty match? go at least one position */
+      lua_pushnumber(L, (lua_Number)newstart);
+      lua_replace(L, lua_upvalueindex(3));
+      return push_captures(&ms, src, e);
+    }
+  }
+  return 0;  /* not found */
+}
+
+
+static int gfind (lua_State *L) {
+  luaL_checkstring(L, 1);
+  luaL_checkstring(L, 2);
+  lua_settop(L, 2);
+  lua_pushnumber(L, 0);
+  lua_pushcclosure(L, gfind_aux, 3);
+  return 1;
+}
+
+
+static void add_s (MatchState *ms, luaL_Buffer *b,
+                   const char *s, const char *e) {
+  lua_State *L = ms->L;
+  if (lua_isstring(L, 3)) {
+    const char *news = lua_tostring(L, 3);
+    size_t l = lua_strlen(L, 3);
+    size_t i;
+    for (i=0; i<l; i++) {
+      if (news[i] != ESC)
+        luaL_putchar(b, news[i]);
+      else {
+        i++;  /* skip ESC */
+        if (!isdigit(uchar(news[i])))
+          luaL_putchar(b, news[i]);
+        else {
+          int level = check_capture(ms, news[i]);
+          push_onecapture(ms, level);
+          luaL_addvalue(b);  /* add capture to accumulated result */
+        }
+      }
+    }
+  }
+  else {  /* is a function */
+    int n;
+    lua_pushvalue(L, 3);
+    n = push_captures(ms, s, e);
+    lua_call(L, n, 1);
+    if (lua_isstring(L, -1))
+      luaL_addvalue(b);  /* add return to accumulated result */
+    else
+      lua_pop(L, 1);  /* function result is not a string: pop it */
+  }
+}
+
+
+static int str_gsub (lua_State *L) {
+  size_t srcl;
+  const char *src = luaL_checklstring(L, 1, &srcl);
+  const char *p = luaL_checkstring(L, 2);
+  int max_s = luaL_optint(L, 4, srcl+1);
+  int anchor = (*p == '^') ? (p++, 1) : 0;
+  int n = 0;
+  MatchState ms;
+  luaL_Buffer b;
+  luaL_argcheck(L,
+    lua_gettop(L) >= 3 && (lua_isstring(L, 3) || lua_isfunction(L, 3)),
+    3, "string or function expected");
+  luaL_buffinit(L, &b);
+  ms.L = L;
+  ms.src_init = src;
+  ms.src_end = src+srcl;
+  while (n < max_s) {
+    const char *e;
+    ms.level = 0;
+    e = match(&ms, src, p);
+    if (e) {
+      n++;
+      add_s(&ms, &b, src, e);
+    }
+    if (e && e>src) /* non empty match? */
+      src = e;  /* skip it */
+    else if (src < ms.src_end)
+      luaL_putchar(&b, *src++);
+    else break;
+    if (anchor) break;
+  }
+  luaL_addlstring(&b, src, ms.src_end-src);
+  luaL_pushresult(&b);
+  lua_pushnumber(L, (lua_Number)n);  /* number of substitutions */
+  return 2;
+}
+
+/* }====================================================== */
+
+
+/* maximum size of each formatted item (> len(format('%99.99f', -1e308))) */
+#define MAX_ITEM	512
+/* maximum size of each format specification (such as '%-099.99d') */
+#define MAX_FORMAT	20
+
+
+static void luaI_addquoted (lua_State *L, luaL_Buffer *b, int arg) {
+  size_t l;
+  const char *s = luaL_checklstring(L, arg, &l);
+  luaL_putchar(b, '"');
+  while (l--) {
+    switch (*s) {
+      case '"': case '\\': case '\n': {
+        luaL_putchar(b, '\\');
+        luaL_putchar(b, *s);
+        break;
+      }
+      case '\0': {
+        luaL_addlstring(b, "\\000", 4);
+        break;
+      }
+      default: {
+        luaL_putchar(b, *s);
+        break;
+      }
+    }
+    s++;
+  }
+  luaL_putchar(b, '"');
+}
+
+
+static const char *scanformat (lua_State *L, const char *strfrmt,
+                                 char *form, int *hasprecision) {
+  const char *p = strfrmt;
+  while (strchr("-+ #0", *p)) p++;  /* skip flags */
+  if (isdigit(uchar(*p))) p++;  /* skip width */
+  if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
+  if (*p == '.') {
+    p++;
+    *hasprecision = 1;
+    if (isdigit(uchar(*p))) p++;  /* skip precision */
+    if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
+  }
+  if (isdigit(uchar(*p)))
+    luaL_error(L, "invalid format (width or precision too long)");
+  if (p-strfrmt+2 > MAX_FORMAT)  /* +2 to include `%' and the specifier */
+    luaL_error(L, "invalid format (too long)");
+  form[0] = '%';
+  strncpy(form+1, strfrmt, p-strfrmt+1);
+  form[p-strfrmt+2] = 0;
+  return p;
+}
+
+
+static int str_format (lua_State *L) {
+  int arg = 1;
+  size_t sfl;
+  const char *strfrmt = luaL_checklstring(L, arg, &sfl);
+  const char *strfrmt_end = strfrmt+sfl;
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  while (strfrmt < strfrmt_end) {
+    if (*strfrmt != '%')
+      luaL_putchar(&b, *strfrmt++);
+    else if (*++strfrmt == '%')
+      luaL_putchar(&b, *strfrmt++);  /* %% */
+    else { /* format item */
+      char form[MAX_FORMAT];  /* to store the format (`%...') */
+      char buff[MAX_ITEM];  /* to store the formatted item */
+      int hasprecision = 0;
+      if (isdigit(uchar(*strfrmt)) && *(strfrmt+1) == '$')
+        return luaL_error(L, "obsolete option (d$) to `format'");
+      arg++;
+      strfrmt = scanformat(L, strfrmt, form, &hasprecision);
+      switch (*strfrmt++) {
+        case 'c':  case 'd':  case 'i': {
+          sprintf(buff, form, luaL_checkint(L, arg));
+          break;
+        }
+        case 'o':  case 'u':  case 'x':  case 'X': {
+          sprintf(buff, form, (unsigned int)(luaL_checknumber(L, arg)));
+          break;
+        }
+        case 'e':  case 'E': case 'f':
+        case 'g': case 'G': {
+          sprintf(buff, form, luaL_checknumber(L, arg));
+          break;
+        }
+        case 'q': {
+          luaI_addquoted(L, &b, arg);
+          continue;  /* skip the `addsize' at the end */
+        }
+        case 's': {
+          size_t l;
+          const char *s = luaL_checklstring(L, arg, &l);
+          if (!hasprecision && l >= 100) {
+            /* no precision and string is too long to be formatted;
+               keep original string */
+            lua_pushvalue(L, arg);
+            luaL_addvalue(&b);
+            continue;  /* skip the `addsize' at the end */
+          }
+          else {
+            sprintf(buff, form, s);
+            break;
+          }
+        }
+        default: {  /* also treat cases `pnLlh' */
+          return luaL_error(L, "invalid option to `format'");
+        }
+      }
+      luaL_addlstring(&b, buff, strlen(buff));
+    }
+  }
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+static const luaL_reg strlib[] = {
+  {"len", str_len},
+  {"sub", str_sub},
+  {"lower", str_lower},
+  {"upper", str_upper},
+  {"char", str_char},
+  {"rep", str_rep},
+  {"byte", str_byte},
+  {"format", str_format},
+  {"dump", str_dump},
+  {"find", str_find},
+  {"gfind", gfind},
+  {"gsub", str_gsub},
+  {NULL, NULL}
+};
+
+
+/*
+** Open string library
+*/
+LUALIB_API int luaopen_string (lua_State *L) {
+  luaL_openlib(L, LUA_STRLIBNAME, strlib, 0);
+  return 1;
+}
+

Added: trunk/source/libraries/lua/lib/ltablib.c
===================================================================
--- trunk/source/libraries/lua/lib/ltablib.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/ltablib.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,250 @@
+/*
+** $Id: ltablib.c,v 1.21 2003/04/03 13:35:34 roberto Exp $
+** Library for Table Manipulation
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stddef.h>
+
+#define ltablib_c
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#define aux_getn(L,n)	(luaL_checktype(L, n, LUA_TTABLE), luaL_getn(L, n))
+
+
+static int luaB_foreachi (lua_State *L) {
+  int i;
+  int n = aux_getn(L, 1);
+  luaL_checktype(L, 2, LUA_TFUNCTION);
+  for (i=1; i<=n; i++) {
+    lua_pushvalue(L, 2);  /* function */
+    lua_pushnumber(L, (lua_Number)i);  /* 1st argument */
+    lua_rawgeti(L, 1, i);  /* 2nd argument */
+    lua_call(L, 2, 1);
+    if (!lua_isnil(L, -1))
+      return 1;
+    lua_pop(L, 1);  /* remove nil result */
+  }
+  return 0;
+}
+
+
+static int luaB_foreach (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checktype(L, 2, LUA_TFUNCTION);
+  lua_pushnil(L);  /* first key */
+  for (;;) {
+    if (lua_next(L, 1) == 0)
+      return 0;
+    lua_pushvalue(L, 2);  /* function */
+    lua_pushvalue(L, -3);  /* key */
+    lua_pushvalue(L, -3);  /* value */
+    lua_call(L, 2, 1);
+    if (!lua_isnil(L, -1))
+      return 1;
+    lua_pop(L, 2);  /* remove value and result */
+  }
+}
+
+
+static int luaB_getn (lua_State *L) {
+  lua_pushnumber(L, (lua_Number)aux_getn(L, 1));
+  return 1;
+}
+
+
+static int luaB_setn (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_setn(L, 1, luaL_checkint(L, 2));
+  return 0;
+}
+
+
+static int luaB_tinsert (lua_State *L) {
+  int v = lua_gettop(L);  /* number of arguments */
+  int n = aux_getn(L, 1) + 1;
+  int pos;  /* where to insert new element */
+  if (v == 2)  /* called with only 2 arguments */
+    pos = n;  /* insert new element at the end */
+  else {
+    pos = luaL_checkint(L, 2);  /* 2nd argument is the position */
+    if (pos > n) n = pos;  /* `grow' array if necessary */
+    v = 3;  /* function may be called with more than 3 args */
+  }
+  luaL_setn(L, 1, n);  /* new size */
+  while (--n >= pos) {  /* move up elements */
+    lua_rawgeti(L, 1, n);
+    lua_rawseti(L, 1, n+1);  /* t[n+1] = t[n] */
+  }
+  lua_pushvalue(L, v);
+  lua_rawseti(L, 1, pos);  /* t[pos] = v */
+  return 0;
+}
+
+
+static int luaB_tremove (lua_State *L) {
+  int n = aux_getn(L, 1);
+  int pos = luaL_optint(L, 2, n);
+  if (n <= 0) return 0;  /* table is `empty' */
+  luaL_setn(L, 1, n-1);  /* t.n = n-1 */
+  lua_rawgeti(L, 1, pos);  /* result = t[pos] */
+  for ( ;pos<n; pos++) {
+    lua_rawgeti(L, 1, pos+1);
+    lua_rawseti(L, 1, pos);  /* t[pos] = t[pos+1] */
+  }
+  lua_pushnil(L);
+  lua_rawseti(L, 1, n);  /* t[n] = nil */
+  return 1;
+}
+
+
+static int str_concat (lua_State *L) {
+  luaL_Buffer b;
+  size_t lsep;
+  const char *sep = luaL_optlstring(L, 2, "", &lsep);
+  int i = luaL_optint(L, 3, 1);
+  int n = luaL_optint(L, 4, 0);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  if (n == 0) n = luaL_getn(L, 1);
+  luaL_buffinit(L, &b);
+  for (; i <= n; i++) {
+    lua_rawgeti(L, 1, i);
+    luaL_argcheck(L, lua_isstring(L, -1), 1, "table contains non-strings");
+    luaL_addvalue(&b);
+    if (i != n)
+      luaL_addlstring(&b, sep, lsep);
+  }
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+
+/*
+** {======================================================
+** Quicksort
+** (based on `Algorithms in MODULA-3', Robert Sedgewick;
+**  Addison-Wesley, 1993.)
+*/
+
+
+static void set2 (lua_State *L, int i, int j) {
+  lua_rawseti(L, 1, i);
+  lua_rawseti(L, 1, j);
+}
+
+static int sort_comp (lua_State *L, int a, int b) {
+  if (!lua_isnil(L, 2)) {  /* function? */
+    int res;
+    lua_pushvalue(L, 2);
+    lua_pushvalue(L, a-1);  /* -1 to compensate function */
+    lua_pushvalue(L, b-2);  /* -2 to compensate function and `a' */
+    lua_call(L, 2, 1);
+    res = lua_toboolean(L, -1);
+    lua_pop(L, 1);
+    return res;
+  }
+  else  /* a < b? */
+    return lua_lessthan(L, a, b);
+}
+
+static void auxsort (lua_State *L, int l, int u) {
+  while (l < u) {  /* for tail recursion */
+    int i, j;
+    /* sort elements a[l], a[(l+u)/2] and a[u] */
+    lua_rawgeti(L, 1, l);
+    lua_rawgeti(L, 1, u);
+    if (sort_comp(L, -1, -2))  /* a[u] < a[l]? */
+      set2(L, l, u);  /* swap a[l] - a[u] */
+    else
+      lua_pop(L, 2);
+    if (u-l == 1) break;  /* only 2 elements */
+    i = (l+u)/2;
+    lua_rawgeti(L, 1, i);
+    lua_rawgeti(L, 1, l);
+    if (sort_comp(L, -2, -1))  /* a[i]<a[l]? */
+      set2(L, i, l);
+    else {
+      lua_pop(L, 1);  /* remove a[l] */
+      lua_rawgeti(L, 1, u);
+      if (sort_comp(L, -1, -2))  /* a[u]<a[i]? */
+        set2(L, i, u);
+      else
+        lua_pop(L, 2);
+    }
+    if (u-l == 2) break;  /* only 3 elements */
+    lua_rawgeti(L, 1, i);  /* Pivot */
+    lua_pushvalue(L, -1);
+    lua_rawgeti(L, 1, u-1);
+    set2(L, i, u-1);
+    /* a[l] <= P == a[u-1] <= a[u], only need to sort from l+1 to u-2 */
+    i = l; j = u-1;
+    for (;;) {  /* invariant: a[l..i] <= P <= a[j..u] */
+      /* repeat ++i until a[i] >= P */
+      while (lua_rawgeti(L, 1, ++i), sort_comp(L, -1, -2)) {
+        if (i>u) luaL_error(L, "invalid order function for sorting");
+        lua_pop(L, 1);  /* remove a[i] */
+      }
+      /* repeat --j until a[j] <= P */
+      while (lua_rawgeti(L, 1, --j), sort_comp(L, -3, -1)) {
+        if (j<l) luaL_error(L, "invalid order function for sorting");
+        lua_pop(L, 1);  /* remove a[j] */
+      }
+      if (j<i) {
+        lua_pop(L, 3);  /* pop pivot, a[i], a[j] */
+        break;
+      }
+      set2(L, i, j);
+    }
+    lua_rawgeti(L, 1, u-1);
+    lua_rawgeti(L, 1, i);
+    set2(L, u-1, i);  /* swap pivot (a[u-1]) with a[i] */
+    /* a[l..i-1] <= a[i] == P <= a[i+1..u] */
+    /* adjust so that smaller half is in [j..i] and larger one in [l..u] */
+    if (i-l < u-i) {
+      j=l; i=i-1; l=i+2;
+    }
+    else {
+      j=i+1; i=u; u=j-2;
+    }
+    auxsort(L, j, i);  /* call recursively the smaller one */
+  }  /* repeat the routine for the larger one */
+}
+
+static int luaB_sort (lua_State *L) {
+  int n = aux_getn(L, 1);
+  luaL_checkstack(L, 40, "");  /* assume array is smaller than 2^40 */
+  if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */
+    luaL_checktype(L, 2, LUA_TFUNCTION);
+  lua_settop(L, 2);  /* make sure there is two arguments */
+  auxsort(L, 1, n);
+  return 0;
+}
+
+/* }====================================================== */
+
+
+static const luaL_reg tab_funcs[] = {
+  {"concat", str_concat},
+  {"foreach", luaB_foreach},
+  {"foreachi", luaB_foreachi},
+  {"getn", luaB_getn},
+  {"setn", luaB_setn},
+  {"sort", luaB_sort},
+  {"insert", luaB_tinsert},
+  {"remove", luaB_tremove},
+  {NULL, NULL}
+};
+
+
+LUALIB_API int luaopen_table (lua_State *L) {
+  luaL_openlib(L, LUA_TABLIBNAME, tab_funcs, 0);
+  return 1;
+}
+

Added: trunk/source/libraries/lua/llex.c
===================================================================
--- trunk/source/libraries/lua/llex.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/llex.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,417 @@
+/*
+** $Id: llex.c,v 1.119 2003/03/24 12:39:34 roberto Exp $
+** Lexical Analyzer
+** See Copyright Notice in lua.h
+*/
+
+
+#include <ctype.h>
+#include <string.h>
+
+#define llex_c
+
+#include "lua.h"
+
+#include "ldo.h"
+#include "llex.h"
+#include "lobject.h"
+#include "lparser.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "lzio.h"
+
+
+
+#define next(LS) (LS->current = zgetc(LS->z))
+
+
+
+/* ORDER RESERVED */
+static const char *const token2string [] = {
+    "and", "break", "do", "else", "elseif",
+    "end", "false", "for", "function", "if",
+    "in", "local", "nil", "not", "or", "repeat",
+    "return", "then", "true", "until", "while", "*name",
+    "..", "...", "==", ">=", "<=", "~=",
+    "*number", "*string", "<eof>"
+};
+
+
+void luaX_init (lua_State *L) {
+  int i;
+  for (i=0; i<NUM_RESERVED; i++) {
+    TString *ts = luaS_new(L, token2string[i]);
+    luaS_fix(ts);  /* reserved words are never collected */
+    lua_assert(strlen(token2string[i])+1 <= TOKEN_LEN);
+    ts->tsv.reserved = cast(lu_byte, i+1);  /* reserved word */
+  }
+}
+
+
+#define MAXSRC          80
+
+
+void luaX_checklimit (LexState *ls, int val, int limit, const char *msg) {
+  if (val > limit) {
+    msg = luaO_pushfstring(ls->L, "too many %s (limit=%d)", msg, limit);
+    luaX_syntaxerror(ls, msg);
+  }
+}
+
+
+void luaX_errorline (LexState *ls, const char *s, const char *token, int line) {
+  lua_State *L = ls->L;
+  char buff[MAXSRC];
+  luaO_chunkid(buff, getstr(ls->source), MAXSRC);
+  luaO_pushfstring(L, "%s:%d: %s near `%s'", buff, line, s, token); 
+  luaD_throw(L, LUA_ERRSYNTAX);
+}
+
+
+static void luaX_error (LexState *ls, const char *s, const char *token) {
+  luaX_errorline(ls, s, token, ls->linenumber);
+}
+
+
+void luaX_syntaxerror (LexState *ls, const char *msg) {
+  const char *lasttoken;
+  switch (ls->t.token) {
+    case TK_NAME:
+      lasttoken = getstr(ls->t.seminfo.ts);
+      break;
+    case TK_STRING:
+    case TK_NUMBER:
+      lasttoken = luaZ_buffer(ls->buff);
+      break;
+    default:
+      lasttoken = luaX_token2str(ls, ls->t.token);
+      break;
+  }
+  luaX_error(ls, msg, lasttoken);
+}
+
+
+const char *luaX_token2str (LexState *ls, int token) {
+  if (token < FIRST_RESERVED) {
+    lua_assert(token == (unsigned char)token);
+    return luaO_pushfstring(ls->L, "%c", token);
+  }
+  else
+    return token2string[token-FIRST_RESERVED];
+}
+
+
+static void luaX_lexerror (LexState *ls, const char *s, int token) {
+  if (token == TK_EOS)
+    luaX_error(ls, s, luaX_token2str(ls, token));
+  else
+    luaX_error(ls, s, luaZ_buffer(ls->buff));
+}
+
+
+static void inclinenumber (LexState *LS) {
+  next(LS);  /* skip `\n' */
+  ++LS->linenumber;
+  luaX_checklimit(LS, LS->linenumber, MAX_INT, "lines in a chunk");
+}
+
+
+void luaX_setinput (lua_State *L, LexState *LS, ZIO *z, TString *source) {
+  LS->L = L;
+  LS->lookahead.token = TK_EOS;  /* no look-ahead token */
+  LS->z = z;
+  LS->fs = NULL;
+  LS->linenumber = 1;
+  LS->lastline = 1;
+  LS->source = source;
+  next(LS);  /* read first char */
+  if (LS->current == '#') {
+    do {  /* skip first line */
+      next(LS);
+    } while (LS->current != '\n' && LS->current != EOZ);
+  }
+}
+
+
+
+/*
+** =======================================================
+** LEXICAL ANALYZER
+** =======================================================
+*/
+
+
+/* use buffer to store names, literal strings and numbers */
+
+/* extra space to allocate when growing buffer */
+#define EXTRABUFF	32
+
+/* maximum number of chars that can be read without checking buffer size */
+#define MAXNOCHECK	5
+
+#define checkbuffer(LS, len)	\
+    if (((len)+MAXNOCHECK)*sizeof(char) > luaZ_sizebuffer((LS)->buff)) \
+      luaZ_openspace((LS)->L, (LS)->buff, (len)+EXTRABUFF)
+
+#define save(LS, c, l) \
+	(luaZ_buffer((LS)->buff)[l++] = cast(char, c))
+#define save_and_next(LS, l)  (save(LS, LS->current, l), next(LS))
+
+
+static size_t readname (LexState *LS) {
+  size_t l = 0;
+  checkbuffer(LS, l);
+  do {
+    checkbuffer(LS, l);
+    save_and_next(LS, l);
+  } while (isalnum(LS->current) || LS->current == '_');
+  save(LS, '\0', l);
+  return l-1;
+}
+
+
+/* LUA_NUMBER */
+static void read_numeral (LexState *LS, int comma, SemInfo *seminfo) {
+  size_t l = 0;
+  checkbuffer(LS, l);
+  if (comma) save(LS, '.', l);
+  while (isdigit(LS->current)) {
+    checkbuffer(LS, l);
+    save_and_next(LS, l);
+  }
+  if (LS->current == '.') {
+    save_and_next(LS, l);
+    if (LS->current == '.') {
+      save_and_next(LS, l);
+      save(LS, '\0', l);
+      luaX_lexerror(LS,
+                 "ambiguous syntax (decimal point x string concatenation)",
+                 TK_NUMBER);
+    }
+  }
+  while (isdigit(LS->current)) {
+    checkbuffer(LS, l);
+    save_and_next(LS, l);
+  }
+  if (LS->current == 'e' || LS->current == 'E') {
+    save_and_next(LS, l);  /* read `E' */
+    if (LS->current == '+' || LS->current == '-')
+      save_and_next(LS, l);  /* optional exponent sign */
+    while (isdigit(LS->current)) {
+      checkbuffer(LS, l);
+      save_and_next(LS, l);
+    }
+  }
+  save(LS, '\0', l);
+  if (!luaO_str2d(luaZ_buffer(LS->buff), &seminfo->r))
+    luaX_lexerror(LS, "malformed number", TK_NUMBER);
+}
+
+
+static void read_long_string (LexState *LS, SemInfo *seminfo) {
+  int cont = 0;
+  size_t l = 0;
+  checkbuffer(LS, l);
+  save(LS, '[', l);  /* save first `[' */
+  save_and_next(LS, l);  /* pass the second `[' */
+  if (LS->current == '\n')  /* string starts with a newline? */
+    inclinenumber(LS);  /* skip it */
+  for (;;) {
+    checkbuffer(LS, l);
+    switch (LS->current) {
+      case EOZ:
+        save(LS, '\0', l);
+        luaX_lexerror(LS, (seminfo) ? "unfinished long string" :
+                                   "unfinished long comment", TK_EOS);
+        break;  /* to avoid warnings */
+      case '[':
+        save_and_next(LS, l);
+        if (LS->current == '[') {
+          cont++;
+          save_and_next(LS, l);
+        }
+        continue;
+      case ']':
+        save_and_next(LS, l);
+        if (LS->current == ']') {
+          if (cont == 0) goto endloop;
+          cont--;
+          save_and_next(LS, l);
+        }
+        continue;
+      case '\n':
+        save(LS, '\n', l);
+        inclinenumber(LS);
+        if (!seminfo) l = 0;  /* reset buffer to avoid wasting space */
+        continue;
+      default:
+        save_and_next(LS, l);
+    }
+  } endloop:
+  save_and_next(LS, l);  /* skip the second `]' */
+  save(LS, '\0', l);
+  if (seminfo)
+    seminfo->ts = luaS_newlstr(LS->L, luaZ_buffer(LS->buff) + 2, l - 5);
+}
+
+
+static void read_string (LexState *LS, int del, SemInfo *seminfo) {
+  size_t l = 0;
+  checkbuffer(LS, l);
+  save_and_next(LS, l);
+  while (LS->current != del) {
+    checkbuffer(LS, l);
+    switch (LS->current) {
+      case EOZ:
+        save(LS, '\0', l);
+        luaX_lexerror(LS, "unfinished string", TK_EOS);
+        break;  /* to avoid warnings */
+      case '\n':
+        save(LS, '\0', l);
+        luaX_lexerror(LS, "unfinished string", TK_STRING);
+        break;  /* to avoid warnings */
+      case '\\':
+        next(LS);  /* do not save the `\' */
+        switch (LS->current) {
+          case 'a': save(LS, '\a', l); next(LS); break;
+          case 'b': save(LS, '\b', l); next(LS); break;
+          case 'f': save(LS, '\f', l); next(LS); break;
+          case 'n': save(LS, '\n', l); next(LS); break;
+          case 'r': save(LS, '\r', l); next(LS); break;
+          case 't': save(LS, '\t', l); next(LS); break;
+          case 'v': save(LS, '\v', l); next(LS); break;
+          case '\n': save(LS, '\n', l); inclinenumber(LS); break;
+          case EOZ: break;  /* will raise an error next loop */
+          default: {
+            if (!isdigit(LS->current))
+              save_and_next(LS, l);  /* handles \\, \", \', and \? */
+            else {  /* \xxx */
+              int c = 0;
+              int i = 0;
+              do {
+                c = 10*c + (LS->current-'0');
+                next(LS);
+              } while (++i<3 && isdigit(LS->current));
+              if (c > UCHAR_MAX) {
+                save(LS, '\0', l);
+                luaX_lexerror(LS, "escape sequence too large", TK_STRING);
+              }
+              save(LS, c, l);
+            }
+          }
+        }
+        break;
+      default:
+        save_and_next(LS, l);
+    }
+  }
+  save_and_next(LS, l);  /* skip delimiter */
+  save(LS, '\0', l);
+  seminfo->ts = luaS_newlstr(LS->L, luaZ_buffer(LS->buff) + 1, l - 3);
+}
+
+
+int luaX_lex (LexState *LS, SemInfo *seminfo) {
+  for (;;) {
+    switch (LS->current) {
+
+      case '\n': {
+        inclinenumber(LS);
+        continue;
+      }
+      case '-': {
+        next(LS);
+        if (LS->current != '-') return '-';
+        /* else is a comment */
+        next(LS);
+        if (LS->current == '[' && (next(LS), LS->current == '['))
+          read_long_string(LS, NULL);  /* long comment */
+        else  /* short comment */
+          while (LS->current != '\n' && LS->current != EOZ)
+            next(LS);
+        continue;
+      }
+      case '[': {
+        next(LS);
+        if (LS->current != '[') return '[';
+        else {
+          read_long_string(LS, seminfo);
+          return TK_STRING;
+        }
+      }
+      case '=': {
+        next(LS);
+        if (LS->current != '=') return '=';
+        else { next(LS); return TK_EQ; }
+      }
+      case '<': {
+        next(LS);
+        if (LS->current != '=') return '<';
+        else { next(LS); return TK_LE; }
+      }
+      case '>': {
+        next(LS);
+        if (LS->current != '=') return '>';
+        else { next(LS); return TK_GE; }
+      }
+      case '~': {
+        next(LS);
+        if (LS->current != '=') return '~';
+        else { next(LS); return TK_NE; }
+      }
+      case '"':
+      case '\'': {
+        read_string(LS, LS->current, seminfo);
+        return TK_STRING;
+      }
+      case '.': {
+        next(LS);
+        if (LS->current == '.') {
+          next(LS);
+          if (LS->current == '.') {
+            next(LS);
+            return TK_DOTS;   /* ... */
+          }
+          else return TK_CONCAT;   /* .. */
+        }
+        else if (!isdigit(LS->current)) return '.';
+        else {
+          read_numeral(LS, 1, seminfo);
+          return TK_NUMBER;
+        }
+      }
+      case EOZ: {
+        return TK_EOS;
+      }
+      default: {
+        if (isspace(LS->current)) {
+          next(LS);
+          continue;
+        }
+        else if (isdigit(LS->current)) {
+          read_numeral(LS, 0, seminfo);
+          return TK_NUMBER;
+        }
+        else if (isalpha(LS->current) || LS->current == '_') {
+          /* identifier or reserved word */
+          size_t l = readname(LS);
+          TString *ts = luaS_newlstr(LS->L, luaZ_buffer(LS->buff), l);
+          if (ts->tsv.reserved > 0)  /* reserved word? */
+            return ts->tsv.reserved - 1 + FIRST_RESERVED;
+          seminfo->ts = ts;
+          return TK_NAME;
+        }
+        else {
+          int c = LS->current;
+          if (iscntrl(c))
+            luaX_error(LS, "invalid control char",
+                           luaO_pushfstring(LS->L, "char(%d)", c));
+          next(LS);
+          return c;  /* single-char tokens (+ - / ...) */
+        }
+      }
+    }
+  }
+}
+
+#undef next

Added: trunk/source/libraries/lua/llex.h
===================================================================
--- trunk/source/libraries/lua/llex.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/llex.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,75 @@
+/*
+** $Id: llex.h,v 1.47 2003/02/28 17:19:47 roberto Exp $
+** Lexical Analyzer
+** See Copyright Notice in lua.h
+*/
+
+#ifndef llex_h
+#define llex_h
+
+#include "lobject.h"
+#include "lzio.h"
+
+
+#define FIRST_RESERVED	257
+
+/* maximum length of a reserved word */
+#define TOKEN_LEN	(sizeof("function")/sizeof(char))
+
+
+/*
+* WARNING: if you change the order of this enumeration,
+* grep "ORDER RESERVED"
+*/
+enum RESERVED {
+  /* terminal symbols denoted by reserved words */
+  TK_AND = FIRST_RESERVED, TK_BREAK,
+  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,
+  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,
+  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,
+  /* other terminal symbols */
+  TK_NAME, TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,
+  TK_STRING, TK_EOS
+};
+
+/* number of reserved words */
+#define NUM_RESERVED	(cast(int, TK_WHILE-FIRST_RESERVED+1))
+
+
+typedef union {
+  lua_Number r;
+  TString *ts;
+} SemInfo;  /* semantics information */
+
+
+typedef struct Token {
+  int token;
+  SemInfo seminfo;
+} Token;
+
+
+typedef struct LexState {
+  int current;  /* current character (charint) */
+  int linenumber;  /* input line counter */
+  int lastline;  /* line of last token `consumed' */
+  Token t;  /* current token */
+  Token lookahead;  /* look ahead token */
+  struct FuncState *fs;  /* `FuncState' is private to the parser */
+  struct lua_State *L;
+  ZIO *z;  /* input stream */
+  Mbuffer *buff;  /* buffer for tokens */
+  TString *source;  /* current source name */
+  int nestlevel;  /* level of nested non-terminals */
+} LexState;
+
+
+void luaX_init (lua_State *L);
+void luaX_setinput (lua_State *L, LexState *LS, ZIO *z, TString *source);
+int luaX_lex (LexState *LS, SemInfo *seminfo);
+void luaX_checklimit (LexState *ls, int val, int limit, const char *msg);
+void luaX_syntaxerror (LexState *ls, const char *s);
+void luaX_errorline (LexState *ls, const char *s, const char *token, int line);
+const char *luaX_token2str (LexState *ls, int token);
+
+
+#endif

Added: trunk/source/libraries/lua/llimits.h
===================================================================
--- trunk/source/libraries/lua/llimits.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/llimits.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,185 @@
+/*
+** $Id: llimits.h,v 1.52 2003/02/20 19:33:23 roberto Exp $
+** Limits, basic types, and some other `installation-dependent' definitions
+** See Copyright Notice in lua.h
+*/
+
+#ifndef llimits_h
+#define llimits_h
+
+
+#include <limits.h>
+#include <stddef.h>
+
+
+#include "lua.h"
+
+
+/*
+** try to find number of bits in an integer
+*/
+#ifndef BITS_INT
+/* avoid overflows in comparison */
+#if INT_MAX-20 < 32760
+#define	BITS_INT	16
+#else
+#if INT_MAX > 2147483640L
+/* machine has at least 32 bits */
+#define BITS_INT	32
+#else
+#error "you must define BITS_INT with number of bits in an integer"
+#endif
+#endif
+#endif
+
+
+/*
+** the following types define integer types for values that may not
+** fit in a `small int' (16 bits), but may waste space in a
+** `large long' (64 bits). The current definitions should work in
+** any machine, but may not be optimal.
+*/
+
+/* an unsigned integer to hold hash values */
+typedef unsigned int lu_hash;
+/* its signed equivalent */
+typedef int ls_hash;
+
+/* an unsigned integer big enough to count the total memory used by Lua; */
+/* it should be at least as large as size_t */
+typedef unsigned long lu_mem;
+
+#define MAX_LUMEM	ULONG_MAX
+
+
+/* an integer big enough to count the number of strings in use */
+typedef long ls_nstr;
+
+/* chars used as small naturals (so that `char' is reserved for characters) */
+typedef unsigned char lu_byte;
+
+
+#define MAX_SIZET	((size_t)(~(size_t)0)-2)
+
+
+#define MAX_INT (INT_MAX-2)  /* maximum value of an int (-2 for safety) */
+
+/*
+** conversion of pointer to integer
+** this is for hashing only; there is no problem if the integer
+** cannot hold the whole pointer value
+*/
+#define IntPoint(p)  ((lu_hash)(p))
+
+
+
+/* type to ensure maximum alignment */
+#ifndef LUSER_ALIGNMENT_T
+typedef union { double u; void *s; long l; } L_Umaxalign;
+#else
+typedef LUSER_ALIGNMENT_T L_Umaxalign;
+#endif
+
+
+/* result of `usual argument conversion' over lua_Number */
+#ifndef LUA_UACNUMBER
+typedef double l_uacNumber;
+#else
+typedef LUA_UACNUMBER l_uacNumber;
+#endif
+
+
+#ifndef lua_assert
+#define lua_assert(c)		/* empty */
+#endif
+
+
+#ifndef check_exp
+#define check_exp(c,e)	(e)
+#endif
+
+
+#ifndef UNUSED
+#define UNUSED(x)	((void)(x))	/* to avoid warnings */
+#endif
+
+
+#ifndef cast
+#define cast(t, exp)	((t)(exp))
+#endif
+
+
+
+/*
+** type for virtual-machine instructions
+** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h)
+*/
+typedef unsigned long Instruction;
+
+
+/* maximum depth for calls (unsigned short) */
+#ifndef LUA_MAXCALLS
+#define LUA_MAXCALLS        4096
+#endif
+
+
+/*
+** maximum depth for C calls (unsigned short): Not too big, or may
+** overflow the C stack...
+*/
+
+#ifndef LUA_MAXCCALLS
+#define LUA_MAXCCALLS        200
+#endif
+
+
+/* maximum size for the C stack */
+#ifndef LUA_MAXCSTACK
+#define LUA_MAXCSTACK        2048
+#endif
+
+
+/* maximum stack for a Lua function */
+#define MAXSTACK	250
+
+
+/* maximum number of variables declared in a function */
+#ifndef MAXVARS
+#define MAXVARS 200           /* arbitrary limit (<MAXSTACK) */
+#endif
+
+
+/* maximum number of upvalues per function */
+#ifndef MAXUPVALUES
+#define MAXUPVALUES	32
+#endif
+
+
+/* maximum number of parameters in a function */
+#ifndef MAXPARAMS
+#define MAXPARAMS 100           /* arbitrary limit (<MAXLOCALS) */
+#endif
+
+
+/* minimum size for the string table (must be power of 2) */
+#ifndef MINSTRTABSIZE
+#define MINSTRTABSIZE	32
+#endif
+
+
+/* minimum size for string buffer */
+#ifndef LUA_MINBUFFER
+#define LUA_MINBUFFER	32
+#endif
+
+
+/*
+** maximum number of syntactical nested non-terminals: Not too big,
+** or may overflow the C stack...
+*/
+#ifndef LUA_MAXPARSERLEVEL
+#define LUA_MAXPARSERLEVEL	200
+#endif
+
+
+#endif

Added: trunk/source/libraries/lua/lmem.c
===================================================================
--- trunk/source/libraries/lua/lmem.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lmem.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,91 @@
+/*
+** $Id: lmem.c,v 1.61 2002/12/04 17:38:31 roberto Exp $
+** Interface to Memory Manager
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+
+#define lmem_c
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+
+
+
+/*
+** definition for realloc function. It must assure that l_realloc(NULL,
+** 0, x) allocates a new block (ANSI C assures that). (`os' is the old
+** block size; some allocators may use that.)
+*/
+#ifndef l_realloc
+#define l_realloc(b,os,s)	realloc(b,s)
+#endif
+
+/*
+** definition for free function. (`os' is the old block size; some
+** allocators may use that.)
+*/
+#ifndef l_free
+#define l_free(b,os)	free(b)
+#endif
+
+
+#define MINSIZEARRAY	4
+
+
+void *luaM_growaux (lua_State *L, void *block, int *size, int size_elems,
+                    int limit, const char *errormsg) {
+  void *newblock;
+  int newsize = (*size)*2;
+  if (newsize < MINSIZEARRAY)
+    newsize = MINSIZEARRAY;  /* minimum size */
+  else if (*size >= limit/2) {  /* cannot double it? */
+    if (*size < limit - MINSIZEARRAY)  /* try something smaller... */
+      newsize = limit;  /* still have at least MINSIZEARRAY free places */
+    else luaG_runerror(L, errormsg);
+  }
+  newblock = luaM_realloc(L, block,
+                          cast(lu_mem, *size)*cast(lu_mem, size_elems),
+                          cast(lu_mem, newsize)*cast(lu_mem, size_elems));
+  *size = newsize;  /* update only when everything else is OK */
+  return newblock;
+}
+
+
+/*
+** generic allocation routine.
+*/
+void *luaM_realloc (lua_State *L, void *block, lu_mem oldsize, lu_mem size) {
+  lua_assert((oldsize == 0) == (block == NULL));
+  if (size == 0) {
+    if (block != NULL) {
+      l_free(block, oldsize);
+      block = NULL;
+    }
+    else return NULL;  /* avoid `nblocks' computations when oldsize==size==0 */
+  }
+  else if (size >= MAX_SIZET)
+    luaG_runerror(L, "memory allocation error: block too big");
+  else {
+    block = l_realloc(block, oldsize, size);
+    if (block == NULL) {
+      if (L)
+        luaD_throw(L, LUA_ERRMEM);
+      else return NULL;  /* error before creating state! */
+    }
+  }
+  if (L) {
+    lua_assert(G(L) != NULL && G(L)->nblocks > 0);
+    G(L)->nblocks -= oldsize;
+    G(L)->nblocks += size;
+  }
+  return block;
+}
+

Added: trunk/source/libraries/lua/lmem.h
===================================================================
--- trunk/source/libraries/lua/lmem.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lmem.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,44 @@
+/*
+** $Id: lmem.h,v 1.26 2002/05/01 20:40:42 roberto Exp $
+** Interface to Memory Manager
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lmem_h
+#define lmem_h
+
+
+#include <stddef.h>
+
+#include "llimits.h"
+#include "lua.h"
+
+#define MEMERRMSG	"not enough memory"
+
+
+void *luaM_realloc (lua_State *L, void *oldblock, lu_mem oldsize, lu_mem size);
+
+void *luaM_growaux (lua_State *L, void *block, int *size, int size_elem,
+                    int limit, const char *errormsg);
+
+#define luaM_free(L, b, s)	luaM_realloc(L, (b), (s), 0)
+#define luaM_freelem(L, b)	luaM_realloc(L, (b), sizeof(*(b)), 0)
+#define luaM_freearray(L, b, n, t)	luaM_realloc(L, (b), \
+                                      cast(lu_mem, n)*cast(lu_mem, sizeof(t)), 0)
+
+#define luaM_malloc(L, t)	luaM_realloc(L, NULL, 0, (t))
+#define luaM_new(L, t)          cast(t *, luaM_malloc(L, sizeof(t)))
+#define luaM_newvector(L, n,t)  cast(t *, luaM_malloc(L, \
+                                         cast(lu_mem, n)*cast(lu_mem, sizeof(t))))
+
+#define luaM_growvector(L,v,nelems,size,t,limit,e) \
+          if (((nelems)+1) > (size)) \
+            ((v)=cast(t *, luaM_growaux(L,v,&(size),sizeof(t),limit,e)))
+
+#define luaM_reallocvector(L, v,oldn,n,t) \
+   ((v)=cast(t *, luaM_realloc(L, v,cast(lu_mem, oldn)*cast(lu_mem, sizeof(t)), \
+                                    cast(lu_mem, n)*cast(lu_mem, sizeof(t)))))
+
+
+#endif
+

Added: trunk/source/libraries/lua/lobject.c
===================================================================
--- trunk/source/libraries/lua/lobject.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lobject.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,195 @@
+/*
+** $Id: lobject.c,v 1.97 2003/04/03 13:35:34 roberto Exp $
+** Some generic functions over Lua objects
+** See Copyright Notice in lua.h
+*/
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lobject_c
+
+#include "lua.h"
+
+#include "ldo.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "lvm.h"
+
+
+/* function to convert a string to a lua_Number */
+#ifndef lua_str2number
+#define lua_str2number(s,p)     strtod((s), (p))
+#endif
+
+
+const TObject luaO_nilobject = {LUA_TNIL, {NULL}};
+
+
+/*
+** converts an integer to a "floating point byte", represented as
+** (mmmmmxxx), where the real value is (xxx) * 2^(mmmmm)
+*/
+int luaO_int2fb (unsigned int x) {
+  int m = 0;  /* mantissa */
+  while (x >= (1<<3)) {
+    x = (x+1) >> 1;
+    m++;
+  }
+  return (m << 3) | cast(int, x);
+}
+
+
+int luaO_log2 (unsigned int x) {
+  static const lu_byte log_8[255] = {
+    0,
+    1,1,
+    2,2,2,2,
+    3,3,3,3,3,3,3,3,
+    4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
+  };
+  if (x >= 0x00010000) {
+    if (x >= 0x01000000) return log_8[((x>>24) & 0xff) - 1]+24;
+    else return log_8[((x>>16) & 0xff) - 1]+16;
+  }
+  else {
+    if (x >= 0x00000100) return log_8[((x>>8) & 0xff) - 1]+8;
+    else if (x) return log_8[(x & 0xff) - 1];
+    return -1;  /* special `log' for 0 */
+  }
+}
+
+
+int luaO_rawequalObj (const TObject *t1, const TObject *t2) {
+  if (ttype(t1) != ttype(t2)) return 0;
+  else switch (ttype(t1)) {
+    case LUA_TNIL:
+      return 1;
+    case LUA_TNUMBER:
+      return nvalue(t1) == nvalue(t2);
+    case LUA_TBOOLEAN:
+      return bvalue(t1) == bvalue(t2);  /* boolean true must be 1 !! */
+    case LUA_TLIGHTUSERDATA:
+      return pvalue(t1) == pvalue(t2);
+    default:
+      lua_assert(iscollectable(t1));
+      return gcvalue(t1) == gcvalue(t2);
+  }
+}
+
+
+int luaO_str2d (const char *s, lua_Number *result) {
+  char *endptr;
+  lua_Number res = lua_str2number(s, &endptr);
+  if (endptr == s) return 0;  /* no conversion */
+  while (isspace((unsigned char)(*endptr))) endptr++;
+  if (*endptr != '\0') return 0;  /* invalid trailing characters? */
+  *result = res;
+  return 1;
+}
+
+
+
+static void pushstr (lua_State *L, const char *str) {
+  setsvalue2s(L->top, luaS_new(L, str));
+  incr_top(L);
+}
+
+
+/* this function handles only `%d', `%c', %f, and `%s' formats */
+const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {
+  int n = 1;
+  pushstr(L, "");
+  for (;;) {
+    const char *e = strchr(fmt, '%');
+    if (e == NULL) break;
+    setsvalue2s(L->top, luaS_newlstr(L, fmt, e-fmt));
+    incr_top(L);
+    switch (*(e+1)) {
+      case 's':
+        pushstr(L, va_arg(argp, char *));
+        break;
+      case 'c': {
+        char buff[2];
+        buff[0] = cast(char, va_arg(argp, int));
+        buff[1] = '\0';
+        pushstr(L, buff);
+        break;
+      }
+      case 'd':
+        setnvalue(L->top, cast(lua_Number, va_arg(argp, int)));
+        incr_top(L);
+        break;
+      case 'f':
+        setnvalue(L->top, cast(lua_Number, va_arg(argp, l_uacNumber)));
+        incr_top(L);
+        break;
+      case '%':
+        pushstr(L, "%");
+        break;
+      default: lua_assert(0);
+    }
+    n += 2;
+    fmt = e+2;
+  }
+  pushstr(L, fmt);
+  luaV_concat(L, n+1, L->top - L->base - 1);
+  L->top -= n;
+  return svalue(L->top - 1);
+}
+
+
+const char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {
+  const char *msg;
+  va_list argp;
+  va_start(argp, fmt);
+  msg = luaO_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  return msg;
+}
+
+
+void luaO_chunkid (char *out, const char *source, int bufflen) {
+  if (*source == '=') {
+    strncpy(out, source+1, bufflen);  /* remove first char */
+    out[bufflen-1] = '\0';  /* ensures null termination */
+  }
+  else {  /* out = "source", or "...source" */
+    if (*source == '@') {
+      int l;
+      source++;  /* skip the `@' */
+      bufflen -= sizeof(" `...' ");
+      l = strlen(source);
+      strcpy(out, "");
+      if (l>bufflen) {
+        source += (l-bufflen);  /* get last part of file name */
+        strcat(out, "...");
+      }
+      strcat(out, source);
+    }
+    else {  /* out = [string "string"] */
+      int len = strcspn(source, "\n");  /* stop at first newline */
+      bufflen -= sizeof(" [string \"...\"] ");
+      if (len > bufflen) len = bufflen;
+      strcpy(out, "[string \"");
+      if (source[len] != '\0') {  /* must truncate? */
+        strncat(out, source, len);
+        strcat(out, "...");
+      }
+      else
+        strcat(out, source);
+      strcat(out, "\"]");
+    }
+  }
+}

Added: trunk/source/libraries/lua/lobject.h
===================================================================
--- trunk/source/libraries/lua/lobject.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lobject.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,336 @@
+/*
+** $Id: lobject.h,v 1.159 2003/03/18 12:50:04 roberto Exp $
+** Type definitions for Lua objects
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lobject_h
+#define lobject_h
+
+
+#include "llimits.h"
+#include "lua.h"
+
+
+/* tags for values visible from Lua */
+#define NUM_TAGS	LUA_TTHREAD
+
+
+/*
+** Extra tags for non-values
+*/
+#define LUA_TPROTO	(NUM_TAGS+1)
+#define LUA_TUPVAL	(NUM_TAGS+2)
+
+
+/*
+** Union of all collectable objects
+*/
+typedef union GCObject GCObject;
+
+
+/*
+** Common Header for all collectable objects (in macro form, to be
+** included in other objects)
+*/
+#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked
+
+
+/*
+** Common header in struct form
+*/
+typedef struct GCheader {
+  CommonHeader;
+} GCheader;
+
+
+
+
+/*
+** Union of all Lua values
+*/
+typedef union {
+  GCObject *gc;
+  void *p;
+  lua_Number n;
+  int b;
+} Value;
+
+
+/*
+** Lua values (or `tagged objects')
+*/
+typedef struct lua_TObject {
+  int tt;
+  Value value;
+} TObject;
+
+
+/* Macros to test type */
+#define ttisnil(o)	(ttype(o) == LUA_TNIL)
+#define ttisnumber(o)	(ttype(o) == LUA_TNUMBER)
+#define ttisstring(o)	(ttype(o) == LUA_TSTRING)
+#define ttistable(o)	(ttype(o) == LUA_TTABLE)
+#define ttisfunction(o)	(ttype(o) == LUA_TFUNCTION)
+#define ttisboolean(o)	(ttype(o) == LUA_TBOOLEAN)
+#define ttisuserdata(o)	(ttype(o) == LUA_TUSERDATA)
+#define ttisthread(o)	(ttype(o) == LUA_TTHREAD)
+#define ttislightuserdata(o)	(ttype(o) == LUA_TLIGHTUSERDATA)
+
+/* Macros to access values */
+#define ttype(o)	((o)->tt)
+#define gcvalue(o)	check_exp(iscollectable(o), (o)->value.gc)
+#define pvalue(o)	check_exp(ttislightuserdata(o), (o)->value.p)
+#define nvalue(o)	check_exp(ttisnumber(o), (o)->value.n)
+#define tsvalue(o)	check_exp(ttisstring(o), &(o)->value.gc->ts)
+#define uvalue(o)	check_exp(ttisuserdata(o), &(o)->value.gc->u)
+#define clvalue(o)	check_exp(ttisfunction(o), &(o)->value.gc->cl)
+#define hvalue(o)	check_exp(ttistable(o), &(o)->value.gc->h)
+#define bvalue(o)	check_exp(ttisboolean(o), (o)->value.b)
+#define thvalue(o)	check_exp(ttisthread(o), &(o)->value.gc->th)
+
+#define l_isfalse(o)	(ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))
+
+/* Macros to set values */
+#define setnvalue(obj,x) \
+  { TObject *i_o=(obj); i_o->tt=LUA_TNUMBER; i_o->value.n=(x); }
+
+#define chgnvalue(obj,x) \
+	check_exp(ttype(obj)==LUA_TNUMBER, (obj)->value.n=(x))
+
+#define setpvalue(obj,x) \
+  { TObject *i_o=(obj); i_o->tt=LUA_TLIGHTUSERDATA; i_o->value.p=(x); }
+
+#define setbvalue(obj,x) \
+  { TObject *i_o=(obj); i_o->tt=LUA_TBOOLEAN; i_o->value.b=(x); }
+
+#define setsvalue(obj,x) \
+  { TObject *i_o=(obj); i_o->tt=LUA_TSTRING; \
+    i_o->value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o->value.gc->gch.tt == LUA_TSTRING); }
+
+#define setuvalue(obj,x) \
+  { TObject *i_o=(obj); i_o->tt=LUA_TUSERDATA; \
+    i_o->value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o->value.gc->gch.tt == LUA_TUSERDATA); }
+
+#define setthvalue(obj,x) \
+  { TObject *i_o=(obj); i_o->tt=LUA_TTHREAD; \
+    i_o->value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o->value.gc->gch.tt == LUA_TTHREAD); }
+
+#define setclvalue(obj,x) \
+  { TObject *i_o=(obj); i_o->tt=LUA_TFUNCTION; \
+    i_o->value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o->value.gc->gch.tt == LUA_TFUNCTION); }
+
+#define sethvalue(obj,x) \
+  { TObject *i_o=(obj); i_o->tt=LUA_TTABLE; \
+    i_o->value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o->value.gc->gch.tt == LUA_TTABLE); }
+
+#define setnilvalue(obj) ((obj)->tt=LUA_TNIL)
+
+
+
+/*
+** for internal debug only
+*/
+#define checkconsistency(obj) \
+  lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)->value.gc->gch.tt))
+
+
+#define setobj(obj1,obj2) \
+  { const TObject *o2=(obj2); TObject *o1=(obj1); \
+    checkconsistency(o2); \
+    o1->tt=o2->tt; o1->value = o2->value; }
+
+
+/*
+** different types of sets, according to destination
+*/
+
+/* from stack to (same) stack */
+#define setobjs2s	setobj
+/* to stack (not from same stack) */
+#define setobj2s	setobj
+#define setsvalue2s	setsvalue
+/* from table to same table */
+#define setobjt2t	setobj
+/* to table */
+#define setobj2t	setobj
+/* to new object */
+#define setobj2n	setobj
+#define setsvalue2n	setsvalue
+
+#define setttype(obj, tt) (ttype(obj) = (tt))
+
+
+#define iscollectable(o)	(ttype(o) >= LUA_TSTRING)
+
+
+
+typedef TObject *StkId;  /* index to stack elements */
+
+
+/*
+** String headers for string table
+*/
+typedef union TString {
+  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
+  struct {
+    CommonHeader;
+    lu_byte reserved;
+    lu_hash hash;
+    size_t len;
+  } tsv;
+} TString;
+
+
+#define getstr(ts)	cast(const char *, (ts) + 1)
+#define svalue(o)       getstr(tsvalue(o))
+
+
+
+typedef union Udata {
+  L_Umaxalign dummy;  /* ensures maximum alignment for `local' udata */
+  struct {
+    CommonHeader;
+    struct Table *metatable;
+    size_t len;
+  } uv;
+} Udata;
+
+
+
+
+/*
+** Function Prototypes
+*/
+typedef struct Proto {
+  CommonHeader;
+  TObject *k;  /* constants used by the function */
+  Instruction *code;
+  struct Proto **p;  /* functions defined inside the function */
+  int *lineinfo;  /* map from opcodes to source lines */
+  struct LocVar *locvars;  /* information about local variables */
+  TString **upvalues;  /* upvalue names */
+  TString  *source;
+  int sizeupvalues;
+  int sizek;  /* size of `k' */
+  int sizecode;
+  int sizelineinfo;
+  int sizep;  /* size of `p' */
+  int sizelocvars;
+  int lineDefined;
+  GCObject *gclist;
+  lu_byte nups;  /* number of upvalues */
+  lu_byte numparams;
+  lu_byte is_vararg;
+  lu_byte maxstacksize;
+} Proto;
+
+
+typedef struct LocVar {
+  TString *varname;
+  int startpc;  /* first point where variable is active */
+  int endpc;    /* first point where variable is dead */
+} LocVar;
+
+
+
+/*
+** Upvalues
+*/
+
+typedef struct UpVal {
+  CommonHeader;
+  TObject *v;  /* points to stack or to its own value */
+  TObject value;  /* the value (when closed) */
+} UpVal;
+
+
+/*
+** Closures
+*/
+
+#define ClosureHeader \
+	CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist
+
+typedef struct CClosure {
+  ClosureHeader;
+  lua_CFunction f;
+  TObject upvalue[1];
+} CClosure;
+
+
+typedef struct LClosure {
+  ClosureHeader;
+  struct Proto *p;
+  TObject g;  /* global table for this closure */
+  UpVal *upvals[1];
+} LClosure;
+
+
+typedef union Closure {
+  CClosure c;
+  LClosure l;
+} Closure;
+
+
+#define iscfunction(o)	(ttype(o) == LUA_TFUNCTION && clvalue(o)->c.isC)
+#define isLfunction(o)	(ttype(o) == LUA_TFUNCTION && !clvalue(o)->c.isC)
+
+
+/*
+** Tables
+*/
+
+typedef struct Node {
+  TObject i_key;
+  TObject i_val;
+  struct Node *next;  /* for chaining */
+} Node;
+
+
+typedef struct Table {
+  CommonHeader;
+  lu_byte flags;  /* 1<<p means tagmethod(p) is not present */ 
+  lu_byte lsizenode;  /* log2 of size of `node' array */
+  struct Table *metatable;
+  TObject *array;  /* array part */
+  Node *node;
+  Node *firstfree;  /* this position is free; all positions after it are full */
+  GCObject *gclist;
+  int sizearray;  /* size of `array' array */
+} Table;
+
+
+
+/*
+** `module' operation for hashing (size is always a power of 2)
+*/
+#define lmod(s,size) \
+	check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1))))
+
+
+#define twoto(x)	(1<<(x))
+#define sizenode(t)	(twoto((t)->lsizenode))
+
+
+
+extern const TObject luaO_nilobject;
+
+int luaO_log2 (unsigned int x);
+int luaO_int2fb (unsigned int x);
+#define fb2int(x)	(((x) & 7) << ((x) >> 3))
+
+int luaO_rawequalObj (const TObject *t1, const TObject *t2);
+int luaO_str2d (const char *s, lua_Number *result);
+
+const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp);
+const char *luaO_pushfstring (lua_State *L, const char *fmt, ...);
+void luaO_chunkid (char *out, const char *source, int len);
+
+
+#endif

Added: trunk/source/libraries/lua/lopcodes.c
===================================================================
--- trunk/source/libraries/lua/lopcodes.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lopcodes.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,102 @@
+/*
+** $Id: lopcodes.c,v 1.22 2002/12/04 17:38:31 roberto Exp $
+** extracted automatically from lopcodes.h by mkprint.lua
+** DO NOT EDIT
+** See Copyright Notice in lua.h
+*/
+
+
+#define lopcodes_c
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "lopcodes.h"
+
+
+#ifdef LUA_OPNAMES
+
+const char *const luaP_opnames[] = {
+  "MOVE",
+  "LOADK",
+  "LOADBOOL",
+  "LOADNIL",
+  "GETUPVAL",
+  "GETGLOBAL",
+  "GETTABLE",
+  "SETGLOBAL",
+  "SETUPVAL",
+  "SETTABLE",
+  "NEWTABLE",
+  "SELF",
+  "ADD",
+  "SUB",
+  "MUL",
+  "DIV",
+  "POW",
+  "UNM",
+  "NOT",
+  "CONCAT",
+  "JMP",
+  "EQ",
+  "LT",
+  "LE",
+  "TEST",
+  "CALL",
+  "TAILCALL",
+  "RETURN",
+  "FORLOOP",
+  "TFORLOOP",
+  "TFORPREP",
+  "SETLIST",
+  "SETLISTO",
+  "CLOSE",
+  "CLOSURE"
+};
+
+#endif
+
+#define opmode(t,b,bk,ck,sa,k,m) (((t)<<OpModeT) | \
+   ((b)<<OpModeBreg) | ((bk)<<OpModeBrk) | ((ck)<<OpModeCrk) | \
+   ((sa)<<OpModesetA) | ((k)<<OpModeK) | (m))
+
+
+const lu_byte luaP_opmodes[NUM_OPCODES] = {
+/*       T  B Bk Ck sA  K  mode			   opcode    */
+  opmode(0, 1, 0, 0, 1, 0, iABC)		/* OP_MOVE */
+ ,opmode(0, 0, 0, 0, 1, 1, iABx)		/* OP_LOADK */
+ ,opmode(0, 0, 0, 0, 1, 0, iABC)		/* OP_LOADBOOL */
+ ,opmode(0, 1, 0, 0, 1, 0, iABC)		/* OP_LOADNIL */
+ ,opmode(0, 0, 0, 0, 1, 0, iABC)		/* OP_GETUPVAL */
+ ,opmode(0, 0, 0, 0, 1, 1, iABx)		/* OP_GETGLOBAL */
+ ,opmode(0, 1, 0, 1, 1, 0, iABC)		/* OP_GETTABLE */
+ ,opmode(0, 0, 0, 0, 0, 1, iABx)		/* OP_SETGLOBAL */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_SETUPVAL */
+ ,opmode(0, 0, 1, 1, 0, 0, iABC)		/* OP_SETTABLE */
+ ,opmode(0, 0, 0, 0, 1, 0, iABC)		/* OP_NEWTABLE */
+ ,opmode(0, 1, 0, 1, 1, 0, iABC)		/* OP_SELF */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_ADD */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_SUB */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_MUL */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_DIV */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_POW */
+ ,opmode(0, 1, 0, 0, 1, 0, iABC)		/* OP_UNM */
+ ,opmode(0, 1, 0, 0, 1, 0, iABC)		/* OP_NOT */
+ ,opmode(0, 1, 0, 1, 1, 0, iABC)		/* OP_CONCAT */
+ ,opmode(0, 0, 0, 0, 0, 0, iAsBx)		/* OP_JMP */
+ ,opmode(1, 0, 1, 1, 0, 0, iABC)		/* OP_EQ */
+ ,opmode(1, 0, 1, 1, 0, 0, iABC)		/* OP_LT */
+ ,opmode(1, 0, 1, 1, 0, 0, iABC)		/* OP_LE */
+ ,opmode(1, 1, 0, 0, 1, 0, iABC)		/* OP_TEST */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_CALL */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_TAILCALL */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_RETURN */
+ ,opmode(0, 0, 0, 0, 0, 0, iAsBx)		/* OP_FORLOOP */
+ ,opmode(1, 0, 0, 0, 0, 0, iABC)		/* OP_TFORLOOP */
+ ,opmode(0, 0, 0, 0, 0, 0, iAsBx)		/* OP_TFORPREP */
+ ,opmode(0, 0, 0, 0, 0, 0, iABx)		/* OP_SETLIST */
+ ,opmode(0, 0, 0, 0, 0, 0, iABx)		/* OP_SETLISTO */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_CLOSE */
+ ,opmode(0, 0, 0, 0, 1, 0, iABx)		/* OP_CLOSURE */
+};
+

Added: trunk/source/libraries/lua/lopcodes.h
===================================================================
--- trunk/source/libraries/lua/lopcodes.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lopcodes.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,238 @@
+/*
+** $Id: lopcodes.h,v 1.102 2002/08/21 18:56:09 roberto Exp $
+** Opcodes for Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lopcodes_h
+#define lopcodes_h
+
+#include "llimits.h"
+
+
+/*===========================================================================
+  We assume that instructions are unsigned numbers.
+  All instructions have an opcode in the first 6 bits.
+  Instructions can have the following fields:
+	`A' : 8 bits
+	`B' : 9 bits
+	`C' : 9 bits
+	`Bx' : 18 bits (`B' and `C' together)
+	`sBx' : signed Bx
+
+  A signed argument is represented in excess K; that is, the number
+  value is the unsigned value minus K. K is exactly the maximum value
+  for that argument (so that -max is represented by 0, and +max is
+  represented by 2*max), which is half the maximum for the corresponding
+  unsigned argument.
+===========================================================================*/
+
+
+enum OpMode {iABC, iABx, iAsBx};  /* basic instruction format */
+
+
+/*
+** size and position of opcode arguments.
+*/
+#define SIZE_C		9
+#define SIZE_B		9
+#define SIZE_Bx		(SIZE_C + SIZE_B)
+#define SIZE_A		8
+
+#define SIZE_OP		6
+
+#define POS_C		SIZE_OP
+#define POS_B		(POS_C + SIZE_C)
+#define POS_Bx		POS_C
+#define POS_A		(POS_B + SIZE_B)
+
+
+/*
+** limits for opcode arguments.
+** we use (signed) int to manipulate most arguments,
+** so they must fit in BITS_INT-1 bits (-1 for sign)
+*/
+#if SIZE_Bx < BITS_INT-1
+#define MAXARG_Bx        ((1<<SIZE_Bx)-1)
+#define MAXARG_sBx        (MAXARG_Bx>>1)         /* `sBx' is signed */
+#else
+#define MAXARG_Bx        MAX_INT
+#define MAXARG_sBx        MAX_INT
+#endif
+
+
+#define MAXARG_A        ((1<<SIZE_A)-1)
+#define MAXARG_B        ((1<<SIZE_B)-1)
+#define MAXARG_C        ((1<<SIZE_C)-1)
+
+
+/* creates a mask with `n' 1 bits at position `p' */
+#define MASK1(n,p)	((~((~(Instruction)0)<<n))<<p)
+
+/* creates a mask with `n' 0 bits at position `p' */
+#define MASK0(n,p)	(~MASK1(n,p))
+
+/*
+** the following macros help to manipulate instructions
+*/
+
+#define GET_OPCODE(i)	(cast(OpCode, (i)&MASK1(SIZE_OP,0)))
+#define SET_OPCODE(i,o)	((i) = (((i)&MASK0(SIZE_OP,0)) | cast(Instruction, o)))
+
+#define GETARG_A(i)	(cast(int, (i)>>POS_A))
+#define SETARG_A(i,u)	((i) = (((i)&MASK0(SIZE_A,POS_A)) | \
+		((cast(Instruction, u)<<POS_A)&MASK1(SIZE_A,POS_A))))
+
+#define GETARG_B(i)	(cast(int, ((i)>>POS_B) & MASK1(SIZE_B,0)))
+#define SETARG_B(i,b)	((i) = (((i)&MASK0(SIZE_B,POS_B)) | \
+		((cast(Instruction, b)<<POS_B)&MASK1(SIZE_B,POS_B))))
+
+#define GETARG_C(i)	(cast(int, ((i)>>POS_C) & MASK1(SIZE_C,0)))
+#define SETARG_C(i,b)	((i) = (((i)&MASK0(SIZE_C,POS_C)) | \
+		((cast(Instruction, b)<<POS_C)&MASK1(SIZE_C,POS_C))))
+
+#define GETARG_Bx(i)	(cast(int, ((i)>>POS_Bx) & MASK1(SIZE_Bx,0)))
+#define SETARG_Bx(i,b)	((i) = (((i)&MASK0(SIZE_Bx,POS_Bx)) | \
+		((cast(Instruction, b)<<POS_Bx)&MASK1(SIZE_Bx,POS_Bx))))
+
+#define GETARG_sBx(i)	(GETARG_Bx(i)-MAXARG_sBx)
+#define SETARG_sBx(i,b)	SETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))
+
+
+#define CREATE_ABC(o,a,b,c)	(cast(Instruction, o) \
+			| (cast(Instruction, a)<<POS_A) \
+			| (cast(Instruction, b)<<POS_B) \
+			| (cast(Instruction, c)<<POS_C))
+
+#define CREATE_ABx(o,a,bc)	(cast(Instruction, o) \
+			| (cast(Instruction, a)<<POS_A) \
+			| (cast(Instruction, bc)<<POS_Bx))
+
+
+
+
+/*
+** invalid register that fits in 8 bits
+*/
+#define NO_REG		MAXARG_A
+
+
+/*
+** R(x) - register
+** Kst(x) - constant (in constant table)
+** RK(x) == if x < MAXSTACK then R(x) else Kst(x-MAXSTACK)
+*/
+
+
+/*
+** grep "ORDER OP" if you change these enums
+*/
+
+typedef enum {
+/*----------------------------------------------------------------------
+name		args	description
+------------------------------------------------------------------------*/
+OP_MOVE,/*	A B	R(A) := R(B)					*/
+OP_LOADK,/*	A Bx	R(A) := Kst(Bx)					*/
+OP_LOADBOOL,/*	A B C	R(A) := (Bool)B; if (C) PC++			*/
+OP_LOADNIL,/*	A B	R(A) := ... := R(B) := nil			*/
+OP_GETUPVAL,/*	A B	R(A) := UpValue[B]				*/
+
+OP_GETGLOBAL,/*	A Bx	R(A) := Gbl[Kst(Bx)]				*/
+OP_GETTABLE,/*	A B C	R(A) := R(B)[RK(C)]				*/
+
+OP_SETGLOBAL,/*	A Bx	Gbl[Kst(Bx)] := R(A)				*/
+OP_SETUPVAL,/*	A B	UpValue[B] := R(A)				*/
+OP_SETTABLE,/*	A B C	R(A)[RK(B)] := RK(C)				*/
+
+OP_NEWTABLE,/*	A B C	R(A) := {} (size = B,C)				*/
+
+OP_SELF,/*	A B C	R(A+1) := R(B); R(A) := R(B)[RK(C)]		*/
+
+OP_ADD,/*	A B C	R(A) := RK(B) + RK(C)				*/
+OP_SUB,/*	A B C	R(A) := RK(B) - RK(C)				*/
+OP_MUL,/*	A B C	R(A) := RK(B) * RK(C)				*/
+OP_DIV,/*	A B C	R(A) := RK(B) / RK(C)				*/
+OP_POW,/*	A B C	R(A) := RK(B) ^ RK(C)				*/
+OP_UNM,/*	A B	R(A) := -R(B)					*/
+OP_NOT,/*	A B	R(A) := not R(B)				*/
+
+OP_CONCAT,/*	A B C	R(A) := R(B).. ... ..R(C)			*/
+
+OP_JMP,/*	sBx	PC += sBx					*/
+
+OP_EQ,/*	A B C	if ((RK(B) == RK(C)) ~= A) then pc++		*/
+OP_LT,/*	A B C	if ((RK(B) <  RK(C)) ~= A) then pc++  		*/
+OP_LE,/*	A B C	if ((RK(B) <= RK(C)) ~= A) then pc++  		*/
+
+OP_TEST,/*	A B C	if (R(B) <=> C) then R(A) := R(B) else pc++	*/ 
+
+OP_CALL,/*	A B C	R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */
+OP_TAILCALL,/*	A B C	return R(A)(R(A+1), ... ,R(A+B-1))		*/
+OP_RETURN,/*	A B	return R(A), ... ,R(A+B-2)	(see note)	*/
+
+OP_FORLOOP,/*	A sBx	R(A)+=R(A+2); if R(A) <?= R(A+1) then PC+= sBx	*/
+
+OP_TFORLOOP,/*	A C	R(A+2), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); 
+                        if R(A+2) ~= nil then pc++			*/
+OP_TFORPREP,/*	A sBx	if type(R(A)) == table then R(A+1):=R(A), R(A):=next;
+			PC += sBx					*/
+
+OP_SETLIST,/*	A Bx	R(A)[Bx-Bx%FPF+i] := R(A+i), 1 <= i <= Bx%FPF+1	*/
+OP_SETLISTO,/*	A Bx							*/
+
+OP_CLOSE,/*	A 	close all variables in the stack up to (>=) R(A)*/
+OP_CLOSURE/*	A Bx	R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))	*/
+} OpCode;
+
+
+#define NUM_OPCODES	(cast(int, OP_CLOSURE+1))
+
+
+
+/*===========================================================================
+  Notes:
+  (1) In OP_CALL, if (B == 0) then B = top. C is the number of returns - 1,
+      and can be 0: OP_CALL then sets `top' to last_result+1, so
+      next open instruction (OP_CALL, OP_RETURN, OP_SETLIST) may use `top'.
+
+  (2) In OP_RETURN, if (B == 0) then return up to `top'
+
+  (3) For comparisons, B specifies what conditions the test should accept.
+
+  (4) All `skips' (pc++) assume that next instruction is a jump
+===========================================================================*/
+
+
+/*
+** masks for instruction properties
+*/  
+enum OpModeMask {
+  OpModeBreg = 2,       /* B is a register */
+  OpModeBrk,		/* B is a register/constant */
+  OpModeCrk,           /* C is a register/constant */
+  OpModesetA,           /* instruction set register A */
+  OpModeK,              /* Bx is a constant */
+  OpModeT		/* operator is a test */
+  
+};
+
+
+extern const lu_byte luaP_opmodes[NUM_OPCODES];
+
+#define getOpMode(m)            (cast(enum OpMode, luaP_opmodes[m] & 3))
+#define testOpMode(m, b)        (luaP_opmodes[m] & (1 << (b)))
+
+
+#ifdef LUA_OPNAMES
+extern const char *const luaP_opnames[];  /* opcode names */
+#endif
+
+
+
+/* number of list items to accumulate before a SETLIST instruction */
+/* (must be a power of 2) */
+#define LFIELDS_PER_FLUSH	32
+
+
+#endif

Added: trunk/source/libraries/lua/lparser.c
===================================================================
--- trunk/source/libraries/lua/lparser.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lparser.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,1329 @@
+/*
+** $Id: lparser.c,v 1.208 2003/04/03 13:35:34 roberto Exp $
+** Lua Parser
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define lparser_c
+
+#include "lua.h"
+
+#include "lcode.h"
+#include "ldebug.h"
+#include "lfunc.h"
+#include "llex.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+#include "lstate.h"
+#include "lstring.h"
+
+
+
+
+#define getlocvar(fs, i)	((fs)->f->locvars[(fs)->actvar[i]])
+
+
+#define enterlevel(ls)	if (++(ls)->nestlevel > LUA_MAXPARSERLEVEL) \
+		luaX_syntaxerror(ls, "too many syntax levels");
+#define leavelevel(ls)	((ls)->nestlevel--)
+
+
+/*
+** nodes for block list (list of active blocks)
+*/
+typedef struct BlockCnt {
+  struct BlockCnt *previous;  /* chain */
+  int breaklist;  /* list of jumps out of this loop */
+  int nactvar;  /* # active local variables outside the breakable structure */
+  int upval;  /* true if some variable in the block is an upvalue */
+  int isbreakable;  /* true if `block' is a loop */
+} BlockCnt;
+
+
+
+/*
+** prototypes for recursive non-terminal functions
+*/
+static void chunk (LexState *ls);
+static void expr (LexState *ls, expdesc *v);
+
+
+
+static void next (LexState *ls) {
+  ls->lastline = ls->linenumber;
+  if (ls->lookahead.token != TK_EOS) {  /* is there a look-ahead token? */
+    ls->t = ls->lookahead;  /* use this one */
+    ls->lookahead.token = TK_EOS;  /* and discharge it */
+  }
+  else
+    ls->t.token = luaX_lex(ls, &ls->t.seminfo);  /* read next token */
+}
+
+
+static void lookahead (LexState *ls) {
+  lua_assert(ls->lookahead.token == TK_EOS);
+  ls->lookahead.token = luaX_lex(ls, &ls->lookahead.seminfo);
+}
+
+
+static void error_expected (LexState *ls, int token) {
+  luaX_syntaxerror(ls,
+         luaO_pushfstring(ls->L, "`%s' expected", luaX_token2str(ls, token)));
+}
+
+
+static int testnext (LexState *ls, int c) {
+  if (ls->t.token == c) {
+    next(ls);
+    return 1;
+  }
+  else return 0;
+}
+
+
+static void check (LexState *ls, int c) {
+  if (!testnext(ls, c))
+    error_expected(ls, c);
+}
+
+
+#define check_condition(ls,c,msg)	{ if (!(c)) luaX_syntaxerror(ls, msg); }
+
+
+
+static void check_match (LexState *ls, int what, int who, int where) {
+  if (!testnext(ls, what)) {
+    if (where == ls->linenumber)
+      error_expected(ls, what);
+    else {
+      luaX_syntaxerror(ls, luaO_pushfstring(ls->L,
+             "`%s' expected (to close `%s' at line %d)",
+              luaX_token2str(ls, what), luaX_token2str(ls, who), where));
+    }
+  }
+}
+
+
+static TString *str_checkname (LexState *ls) {
+  TString *ts;
+  check_condition(ls, (ls->t.token == TK_NAME), "<name> expected");
+  ts = ls->t.seminfo.ts;
+  next(ls);
+  return ts;
+}
+
+
+static void init_exp (expdesc *e, expkind k, int i) {
+  e->f = e->t = NO_JUMP;
+  e->k = k;
+  e->info = i;
+}
+
+
+static void codestring (LexState *ls, expdesc *e, TString *s) {
+  init_exp(e, VK, luaK_stringK(ls->fs, s));
+}
+
+
+static void checkname(LexState *ls, expdesc *e) {
+  codestring(ls, e, str_checkname(ls));
+}
+
+
+static int luaI_registerlocalvar (LexState *ls, TString *varname) {
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;
+  luaM_growvector(ls->L, f->locvars, fs->nlocvars, f->sizelocvars,
+                  LocVar, MAX_INT, "");
+  f->locvars[fs->nlocvars].varname = varname;
+  return fs->nlocvars++;
+}
+
+
+static void new_localvar (LexState *ls, TString *name, int n) {
+  FuncState *fs = ls->fs;
+  luaX_checklimit(ls, fs->nactvar+n+1, MAXVARS, "local variables");
+  fs->actvar[fs->nactvar+n] = luaI_registerlocalvar(ls, name);
+}
+
+
+static void adjustlocalvars (LexState *ls, int nvars) {
+  FuncState *fs = ls->fs;
+  fs->nactvar += nvars;
+  for (; nvars; nvars--) {
+    getlocvar(fs, fs->nactvar - nvars).startpc = fs->pc;
+  }
+}
+
+
+static void removevars (LexState *ls, int tolevel) {
+  FuncState *fs = ls->fs;
+  while (fs->nactvar > tolevel)
+    getlocvar(fs, --fs->nactvar).endpc = fs->pc;
+}
+
+
+static void new_localvarstr (LexState *ls, const char *name, int n) {
+  new_localvar(ls, luaS_new(ls->L, name), n);
+}
+
+
+static void create_local (LexState *ls, const char *name) {
+  new_localvarstr(ls, name, 0);
+  adjustlocalvars(ls, 1);
+}
+
+
+static int indexupvalue (FuncState *fs, TString *name, expdesc *v) {
+  int i;
+  Proto *f = fs->f;
+  for (i=0; i<f->nups; i++) {
+    if (fs->upvalues[i].k == v->k && fs->upvalues[i].info == v->info) {
+      lua_assert(fs->f->upvalues[i] == name);
+      return i;
+    }
+  }
+  /* new one */
+  luaX_checklimit(fs->ls, f->nups + 1, MAXUPVALUES, "upvalues");
+  luaM_growvector(fs->L, fs->f->upvalues, f->nups, fs->f->sizeupvalues,
+                  TString *, MAX_INT, "");
+  fs->f->upvalues[f->nups] = name;
+  fs->upvalues[f->nups] = *v;
+  return f->nups++;
+}
+
+
+static int searchvar (FuncState *fs, TString *n) {
+  int i;
+  for (i=fs->nactvar-1; i >= 0; i--) {
+    if (n == getlocvar(fs, i).varname)
+      return i;
+  }
+  return -1;  /* not found */
+}
+
+
+static void markupval (FuncState *fs, int level) {
+  BlockCnt *bl = fs->bl;
+  while (bl && bl->nactvar > level) bl = bl->previous;
+  if (bl) bl->upval = 1;
+}
+
+
+static void singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {
+  if (fs == NULL)  /* no more levels? */
+    init_exp(var, VGLOBAL, NO_REG);  /* default is global variable */
+  else {
+    int v = searchvar(fs, n);  /* look up at current level */
+    if (v >= 0) {
+      init_exp(var, VLOCAL, v);
+      if (!base)
+        markupval(fs, v);  /* local will be used as an upval */
+    }
+    else {  /* not found at current level; try upper one */
+      singlevaraux(fs->prev, n, var, 0);
+      if (var->k == VGLOBAL) {
+        if (base)
+          var->info = luaK_stringK(fs, n);  /* info points to global name */
+      }
+      else {  /* LOCAL or UPVAL */
+        var->info = indexupvalue(fs, n, var);
+        var->k = VUPVAL;  /* upvalue in this level */
+      }
+    }
+  }
+}
+
+
+static TString *singlevar (LexState *ls, expdesc *var, int base) {
+  TString *varname = str_checkname(ls);
+  singlevaraux(ls->fs, varname, var, base);
+  return varname;
+}
+
+
+static void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {
+  FuncState *fs = ls->fs;
+  int extra = nvars - nexps;
+  if (e->k == VCALL) {
+    extra++;  /* includes call itself */
+    if (extra <= 0) extra = 0;
+    else luaK_reserveregs(fs, extra-1);
+    luaK_setcallreturns(fs, e, extra);  /* call provides the difference */
+  }
+  else {
+    if (e->k != VVOID) luaK_exp2nextreg(fs, e);  /* close last expression */
+    if (extra > 0) {
+      int reg = fs->freereg;
+      luaK_reserveregs(fs, extra);
+      luaK_nil(fs, reg, extra);
+    }
+  }
+}
+
+
+static void code_params (LexState *ls, int nparams, int dots) {
+  FuncState *fs = ls->fs;
+  adjustlocalvars(ls, nparams);
+  luaX_checklimit(ls, fs->nactvar, MAXPARAMS, "parameters");
+  fs->f->numparams = cast(lu_byte, fs->nactvar);
+  fs->f->is_vararg = cast(lu_byte, dots);
+  if (dots)
+    create_local(ls, "arg");
+  luaK_reserveregs(fs, fs->nactvar);  /* reserve register for parameters */
+}
+
+
+static void enterblock (FuncState *fs, BlockCnt *bl, int isbreakable) {
+  bl->breaklist = NO_JUMP;
+  bl->isbreakable = isbreakable;
+  bl->nactvar = fs->nactvar;
+  bl->upval = 0;
+  bl->previous = fs->bl;
+  fs->bl = bl;
+  lua_assert(fs->freereg == fs->nactvar);
+}
+
+
+static void leaveblock (FuncState *fs) {
+  BlockCnt *bl = fs->bl;
+  fs->bl = bl->previous;
+  removevars(fs->ls, bl->nactvar);
+  if (bl->upval)
+    luaK_codeABC(fs, OP_CLOSE, bl->nactvar, 0, 0);
+  lua_assert(bl->nactvar == fs->nactvar);
+  fs->freereg = fs->nactvar;  /* free registers */
+  luaK_patchtohere(fs, bl->breaklist);
+}
+
+
+static void pushclosure (LexState *ls, FuncState *func, expdesc *v) {
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;
+  int i;
+  luaM_growvector(ls->L, f->p, fs->np, f->sizep, Proto *,
+                  MAXARG_Bx, "constant table overflow");
+  f->p[fs->np++] = func->f;
+  init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np-1));
+  for (i=0; i<func->f->nups; i++) {
+    OpCode o = (func->upvalues[i].k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;
+    luaK_codeABC(fs, o, 0, func->upvalues[i].info, 0);
+  }
+}
+
+
+static void open_func (LexState *ls, FuncState *fs) {
+  Proto *f = luaF_newproto(ls->L);
+  fs->f = f;
+  fs->prev = ls->fs;  /* linked list of funcstates */
+  fs->ls = ls;
+  fs->L = ls->L;
+  ls->fs = fs;
+  fs->pc = 0;
+  fs->lasttarget = 0;
+  fs->jpc = NO_JUMP;
+  fs->freereg = 0;
+  fs->nk = 0;
+  fs->h = luaH_new(ls->L, 0, 0);
+  fs->np = 0;
+  fs->nlocvars = 0;
+  fs->nactvar = 0;
+  fs->bl = NULL;
+  f->source = ls->source;
+  f->maxstacksize = 2;  /* registers 0/1 are always valid */
+}
+
+
+static void close_func (LexState *ls) {
+  lua_State *L = ls->L;
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;
+  removevars(ls, 0);
+  luaK_codeABC(fs, OP_RETURN, 0, 1, 0);  /* final return */
+  luaM_reallocvector(L, f->code, f->sizecode, fs->pc, Instruction);
+  f->sizecode = fs->pc;
+  luaM_reallocvector(L, f->lineinfo, f->sizelineinfo, fs->pc, int);
+  f->sizelineinfo = fs->pc;
+  luaM_reallocvector(L, f->k, f->sizek, fs->nk, TObject);
+  f->sizek = fs->nk;
+  luaM_reallocvector(L, f->p, f->sizep, fs->np, Proto *);
+  f->sizep = fs->np;
+  luaM_reallocvector(L, f->locvars, f->sizelocvars, fs->nlocvars, LocVar);
+  f->sizelocvars = fs->nlocvars;
+  luaM_reallocvector(L, f->upvalues, f->sizeupvalues, f->nups, TString *);
+  f->sizeupvalues = f->nups;
+  lua_assert(luaG_checkcode(f));
+  lua_assert(fs->bl == NULL);
+  ls->fs = fs->prev;
+}
+
+
+Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff) {
+  struct LexState lexstate;
+  struct FuncState funcstate;
+  lexstate.buff = buff;
+  lexstate.nestlevel = 0;
+  luaX_setinput(L, &lexstate, z, luaS_new(L, zname(z)));
+  open_func(&lexstate, &funcstate);
+  next(&lexstate);  /* read first token */
+  chunk(&lexstate);
+  check_condition(&lexstate, (lexstate.t.token == TK_EOS), "<eof> expected");
+  close_func(&lexstate);
+  lua_assert(funcstate.prev == NULL);
+  lua_assert(funcstate.f->nups == 0);
+  lua_assert(lexstate.nestlevel == 0);
+  return funcstate.f;
+}
+
+
+
+/*============================================================*/
+/* GRAMMAR RULES */
+/*============================================================*/
+
+
+static void luaY_field (LexState *ls, expdesc *v) {
+  /* field -> ['.' | ':'] NAME */
+  FuncState *fs = ls->fs;
+  expdesc key;
+  luaK_exp2anyreg(fs, v);
+  next(ls);  /* skip the dot or colon */
+  checkname(ls, &key);
+  luaK_indexed(fs, v, &key);
+}
+
+
+static void luaY_index (LexState *ls, expdesc *v) {
+  /* index -> '[' expr ']' */
+  next(ls);  /* skip the '[' */
+  expr(ls, v);
+  luaK_exp2val(ls->fs, v);
+  check(ls, ']');
+}
+
+
+/*
+** {======================================================================
+** Rules for Constructors
+** =======================================================================
+*/
+
+
+struct ConsControl {
+  expdesc v;  /* last list item read */
+  expdesc *t;  /* table descriptor */
+  int nh;  /* total number of `record' elements */
+  int na;  /* total number of array elements */
+  int tostore;  /* number of array elements pending to be stored */
+};
+
+
+static void recfield (LexState *ls, struct ConsControl *cc) {
+  /* recfield -> (NAME | `['exp1`]') = exp1 */
+  FuncState *fs = ls->fs;
+  int reg = ls->fs->freereg;
+  expdesc key, val;
+  if (ls->t.token == TK_NAME) {
+    luaX_checklimit(ls, cc->nh, MAX_INT, "items in a constructor");
+    cc->nh++;
+    checkname(ls, &key);
+  }
+  else  /* ls->t.token == '[' */
+    luaY_index(ls, &key);
+  check(ls, '=');
+  luaK_exp2RK(fs, &key);
+  expr(ls, &val);
+  luaK_codeABC(fs, OP_SETTABLE, cc->t->info, luaK_exp2RK(fs, &key),
+                                             luaK_exp2RK(fs, &val));
+  fs->freereg = reg;  /* free registers */
+}
+
+
+static void closelistfield (FuncState *fs, struct ConsControl *cc) {
+  if (cc->v.k == VVOID) return;  /* there is no list item */
+  luaK_exp2nextreg(fs, &cc->v);
+  cc->v.k = VVOID;
+  if (cc->tostore == LFIELDS_PER_FLUSH) {
+    luaK_codeABx(fs, OP_SETLIST, cc->t->info, cc->na-1);  /* flush */
+    cc->tostore = 0;  /* no more items pending */
+    fs->freereg = cc->t->info + 1;  /* free registers */
+  }
+}
+
+
+static void lastlistfield (FuncState *fs, struct ConsControl *cc) {
+  if (cc->tostore == 0) return;
+  if (cc->v.k == VCALL) {
+    luaK_setcallreturns(fs, &cc->v, LUA_MULTRET);
+    luaK_codeABx(fs, OP_SETLISTO, cc->t->info, cc->na-1);
+  }
+  else {
+    if (cc->v.k != VVOID)
+      luaK_exp2nextreg(fs, &cc->v);
+    luaK_codeABx(fs, OP_SETLIST, cc->t->info, cc->na-1);
+  }
+  fs->freereg = cc->t->info + 1;  /* free registers */
+}
+
+
+static void listfield (LexState *ls, struct ConsControl *cc) {
+  expr(ls, &cc->v);
+  luaX_checklimit(ls, cc->na, MAXARG_Bx, "items in a constructor");
+  cc->na++;
+  cc->tostore++;
+}
+
+
+static void constructor (LexState *ls, expdesc *t) {
+  /* constructor -> ?? */
+  FuncState *fs = ls->fs;
+  int line = ls->linenumber;
+  int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
+  struct ConsControl cc;
+  cc.na = cc.nh = cc.tostore = 0;
+  cc.t = t;
+  init_exp(t, VRELOCABLE, pc);
+  init_exp(&cc.v, VVOID, 0);  /* no value (yet) */
+  luaK_exp2nextreg(ls->fs, t);  /* fix it at stack top (for gc) */
+  check(ls, '{');
+  do {
+    lua_assert(cc.v.k == VVOID || cc.tostore > 0);
+    testnext(ls, ';');  /* compatibility only */
+    if (ls->t.token == '}') break;
+    closelistfield(fs, &cc);
+    switch(ls->t.token) {
+      case TK_NAME: {  /* may be listfields or recfields */
+        lookahead(ls);
+        if (ls->lookahead.token != '=')  /* expression? */
+          listfield(ls, &cc);
+        else
+          recfield(ls, &cc);
+        break;
+      }
+      case '[': {  /* constructor_item -> recfield */
+        recfield(ls, &cc);
+        break;
+      }
+      default: {  /* constructor_part -> listfield */
+        listfield(ls, &cc);
+        break;
+      }
+    }
+  } while (testnext(ls, ',') || testnext(ls, ';'));
+  check_match(ls, '}', '{', line);
+  lastlistfield(fs, &cc);
+  SETARG_B(fs->f->code[pc], luaO_int2fb(cc.na)); /* set initial array size */
+  SETARG_C(fs->f->code[pc], luaO_log2(cc.nh)+1);  /* set initial table size */
+}
+
+/* }====================================================================== */
+
+
+
+static void parlist (LexState *ls) {
+  /* parlist -> [ param { `,' param } ] */
+  int nparams = 0;
+  int dots = 0;
+  if (ls->t.token != ')') {  /* is `parlist' not empty? */
+    do {
+      switch (ls->t.token) {
+        case TK_DOTS: dots = 1; next(ls); break;
+        case TK_NAME: new_localvar(ls, str_checkname(ls), nparams++); break;
+        default: luaX_syntaxerror(ls, "<name> or `...' expected");
+      }
+    } while (!dots && testnext(ls, ','));
+  }
+  code_params(ls, nparams, dots);
+}
+
+
+static void body (LexState *ls, expdesc *e, int needself, int line) {
+  /* body ->  `(' parlist `)' chunk END */
+  FuncState new_fs;
+  open_func(ls, &new_fs);
+  new_fs.f->lineDefined = line;
+  check(ls, '(');
+  if (needself)
+    create_local(ls, "self");
+  parlist(ls);
+  check(ls, ')');
+  chunk(ls);
+  check_match(ls, TK_END, TK_FUNCTION, line);
+  close_func(ls);
+  pushclosure(ls, &new_fs, e);
+}
+
+
+static int explist1 (LexState *ls, expdesc *v) {
+  /* explist1 -> expr { `,' expr } */
+  int n = 1;  /* at least one expression */
+  expr(ls, v);
+  while (testnext(ls, ',')) {
+    luaK_exp2nextreg(ls->fs, v);
+    expr(ls, v);
+    n++;
+  }
+  return n;
+}
+
+
+static void funcargs (LexState *ls, expdesc *f) {
+  FuncState *fs = ls->fs;
+  expdesc args;
+  int base, nparams;
+  int line = ls->linenumber;
+  switch (ls->t.token) {
+    case '(': {  /* funcargs -> `(' [ explist1 ] `)' */
+      if (line != ls->lastline)
+        luaX_syntaxerror(ls,"ambiguous syntax (function call x new statement)");
+      next(ls);
+      if (ls->t.token == ')')  /* arg list is empty? */
+        args.k = VVOID;
+      else {
+        explist1(ls, &args);
+        luaK_setcallreturns(fs, &args, LUA_MULTRET);
+      }
+      check_match(ls, ')', '(', line);
+      break;
+    }
+    case '{': {  /* funcargs -> constructor */
+      constructor(ls, &args);
+      break;
+    }
+    case TK_STRING: {  /* funcargs -> STRING */
+      codestring(ls, &args, ls->t.seminfo.ts);
+      next(ls);  /* must use `seminfo' before `next' */
+      break;
+    }
+    default: {
+      luaX_syntaxerror(ls, "function arguments expected");
+      return;
+    }
+  }
+  lua_assert(f->k == VNONRELOC);
+  base = f->info;  /* base register for call */
+  if (args.k == VCALL)
+    nparams = LUA_MULTRET;  /* open call */
+  else {
+    if (args.k != VVOID)
+      luaK_exp2nextreg(fs, &args);  /* close last argument */
+    nparams = fs->freereg - (base+1);
+  }
+  init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));
+  luaK_fixline(fs, line);
+  fs->freereg = base+1;  /* call remove function and arguments and leaves
+                            (unless changed) one result */
+}
+
+
+
+
+/*
+** {======================================================================
+** Expression parsing
+** =======================================================================
+*/
+
+
+static void prefixexp (LexState *ls, expdesc *v) {
+  /* prefixexp -> NAME | '(' expr ')' */
+  switch (ls->t.token) {
+    case '(': {
+      int line = ls->linenumber;
+      next(ls);
+      expr(ls, v);
+      check_match(ls, ')', '(', line);
+      luaK_dischargevars(ls->fs, v);
+      return;
+    }
+    case TK_NAME: {
+      singlevar(ls, v, 1);
+      return;
+    }
+#ifdef LUA_COMPATUPSYNTAX
+    case '%': {  /* for compatibility only */
+      TString *varname;
+      int line = ls->linenumber;
+      next(ls);  /* skip `%' */
+      varname = singlevar(ls, v, 1);
+      if (v->k != VUPVAL)
+        luaX_errorline(ls, "global upvalues are obsolete",
+                           getstr(varname), line);
+      return;
+    }
+#endif
+    default: {
+      luaX_syntaxerror(ls, "unexpected symbol");
+      return;
+    }
+  }
+}
+
+
+static void primaryexp (LexState *ls, expdesc *v) {
+  /* primaryexp ->
+        prefixexp { `.' NAME | `[' exp `]' | `:' NAME funcargs | funcargs } */
+  FuncState *fs = ls->fs;
+  prefixexp(ls, v);
+  for (;;) {
+    switch (ls->t.token) {
+      case '.': {  /* field */
+        luaY_field(ls, v);
+        break;
+      }
+      case '[': {  /* `[' exp1 `]' */
+        expdesc key;
+        luaK_exp2anyreg(fs, v);
+        luaY_index(ls, &key);
+        luaK_indexed(fs, v, &key);
+        break;
+      }
+      case ':': {  /* `:' NAME funcargs */
+        expdesc key;
+        next(ls);
+        checkname(ls, &key);
+        luaK_self(fs, v, &key);
+        funcargs(ls, v);
+        break;
+      }
+      case '(': case TK_STRING: case '{': {  /* funcargs */
+        luaK_exp2nextreg(fs, v);
+        funcargs(ls, v);
+        break;
+      }
+      default: return;
+    }
+  }
+}
+
+
+static void simpleexp (LexState *ls, expdesc *v) {
+  /* simpleexp -> NUMBER | STRING | NIL | constructor | FUNCTION body
+               | primaryexp */
+  switch (ls->t.token) {
+    case TK_NUMBER: {
+      init_exp(v, VK, luaK_numberK(ls->fs, ls->t.seminfo.r));
+      next(ls);  /* must use `seminfo' before `next' */
+      break;
+    }
+    case TK_STRING: {
+      codestring(ls, v, ls->t.seminfo.ts);
+      next(ls);  /* must use `seminfo' before `next' */
+      break;
+    }
+    case TK_NIL: {
+      init_exp(v, VNIL, 0);
+      next(ls);
+      break;
+    }
+    case TK_TRUE: {
+      init_exp(v, VTRUE, 0);
+      next(ls);
+      break;
+    }
+    case TK_FALSE: {
+      init_exp(v, VFALSE, 0);
+      next(ls);
+      break;
+    }
+    case '{': {  /* constructor */
+      constructor(ls, v);
+      break;
+    }
+    case TK_FUNCTION: {
+      next(ls);
+      body(ls, v, 0, ls->linenumber);
+      break;
+    }
+    default: {
+      primaryexp(ls, v);
+      break;
+    }
+  }
+}
+
+
+static UnOpr getunopr (int op) {
+  switch (op) {
+    case TK_NOT: return OPR_NOT;
+    case '-': return OPR_MINUS;
+    default: return OPR_NOUNOPR;
+  }
+}
+
+
+static BinOpr getbinopr (int op) {
+  switch (op) {
+    case '+': return OPR_ADD;
+    case '-': return OPR_SUB;
+    case '*': return OPR_MULT;
+    case '/': return OPR_DIV;
+    case '^': return OPR_POW;
+    case TK_CONCAT: return OPR_CONCAT;
+    case TK_NE: return OPR_NE;
+    case TK_EQ: return OPR_EQ;
+    case '<': return OPR_LT;
+    case TK_LE: return OPR_LE;
+    case '>': return OPR_GT;
+    case TK_GE: return OPR_GE;
+    case TK_AND: return OPR_AND;
+    case TK_OR: return OPR_OR;
+    default: return OPR_NOBINOPR;
+  }
+}
+
+
+static const struct {
+  lu_byte left;  /* left priority for each binary operator */
+  lu_byte right; /* right priority */
+} priority[] = {  /* ORDER OPR */
+   {6, 6}, {6, 6}, {7, 7}, {7, 7},  /* arithmetic */
+   {10, 9}, {5, 4},                 /* power and concat (right associative) */
+   {3, 3}, {3, 3},                  /* equality */
+   {3, 3}, {3, 3}, {3, 3}, {3, 3},  /* order */
+   {2, 2}, {1, 1}                   /* logical (and/or) */
+};
+
+#define UNARY_PRIORITY	8  /* priority for unary operators */
+
+
+/*
+** subexpr -> (simplexep | unop subexpr) { binop subexpr }
+** where `binop' is any binary operator with a priority higher than `limit'
+*/
+static BinOpr subexpr (LexState *ls, expdesc *v, int limit) {
+  BinOpr op;
+  UnOpr uop;
+  enterlevel(ls);
+  uop = getunopr(ls->t.token);
+  if (uop != OPR_NOUNOPR) {
+    next(ls);
+    subexpr(ls, v, UNARY_PRIORITY);
+    luaK_prefix(ls->fs, uop, v);
+  }
+  else simpleexp(ls, v);
+  /* expand while operators have priorities higher than `limit' */
+  op = getbinopr(ls->t.token);
+  while (op != OPR_NOBINOPR && cast(int, priority[op].left) > limit) {
+    expdesc v2;
+    BinOpr nextop;
+    next(ls);
+    luaK_infix(ls->fs, op, v);
+    /* read sub-expression with higher priority */
+    nextop = subexpr(ls, &v2, cast(int, priority[op].right));
+    luaK_posfix(ls->fs, op, v, &v2);
+    op = nextop;
+  }
+  leavelevel(ls);
+  return op;  /* return first untreated operator */
+}
+
+
+static void expr (LexState *ls, expdesc *v) {
+  subexpr(ls, v, -1);
+}
+
+/* }==================================================================== */
+
+
+
+/*
+** {======================================================================
+** Rules for Statements
+** =======================================================================
+*/
+
+
+static int block_follow (int token) {
+  switch (token) {
+    case TK_ELSE: case TK_ELSEIF: case TK_END:
+    case TK_UNTIL: case TK_EOS:
+      return 1;
+    default: return 0;
+  }
+}
+
+
+static void block (LexState *ls) {
+  /* block -> chunk */
+  FuncState *fs = ls->fs;
+  BlockCnt bl;
+  enterblock(fs, &bl, 0);
+  chunk(ls);
+  lua_assert(bl.breaklist == NO_JUMP);
+  leaveblock(fs);
+}
+
+
+/*
+** structure to chain all variables in the left-hand side of an
+** assignment
+*/
+struct LHS_assign {
+  struct LHS_assign *prev;
+  expdesc v;  /* variable (global, local, upvalue, or indexed) */
+};
+
+
+/*
+** check whether, in an assignment to a local variable, the local variable
+** is needed in a previous assignment (to a table). If so, save original
+** local value in a safe place and use this safe copy in the previous
+** assignment.
+*/
+static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {
+  FuncState *fs = ls->fs;
+  int extra = fs->freereg;  /* eventual position to save local variable */
+  int conflict = 0;
+  for (; lh; lh = lh->prev) {
+    if (lh->v.k == VINDEXED) {
+      if (lh->v.info == v->info) {  /* conflict? */
+        conflict = 1;
+        lh->v.info = extra;  /* previous assignment will use safe copy */
+      }
+      if (lh->v.aux == v->info) {  /* conflict? */
+        conflict = 1;
+        lh->v.aux = extra;  /* previous assignment will use safe copy */
+      }
+    }
+  }
+  if (conflict) {
+    luaK_codeABC(fs, OP_MOVE, fs->freereg, v->info, 0);  /* make copy */
+    luaK_reserveregs(fs, 1);
+  }
+}
+
+
+static void assignment (LexState *ls, struct LHS_assign *lh, int nvars) {
+  expdesc e;
+  check_condition(ls, VLOCAL <= lh->v.k && lh->v.k <= VINDEXED,
+                      "syntax error");
+  if (testnext(ls, ',')) {  /* assignment -> `,' primaryexp assignment */
+    struct LHS_assign nv;
+    nv.prev = lh;
+    primaryexp(ls, &nv.v);
+    if (nv.v.k == VLOCAL)
+      check_conflict(ls, lh, &nv.v);
+    assignment(ls, &nv, nvars+1);
+  }
+  else {  /* assignment -> `=' explist1 */
+    int nexps;
+    check(ls, '=');
+    nexps = explist1(ls, &e);
+    if (nexps != nvars) {
+      adjust_assign(ls, nvars, nexps, &e);
+      if (nexps > nvars)
+        ls->fs->freereg -= nexps - nvars;  /* remove extra values */
+    }
+    else {
+      luaK_setcallreturns(ls->fs, &e, 1);  /* close last expression */
+      luaK_storevar(ls->fs, &lh->v, &e);
+      return;  /* avoid default */
+    }
+  }
+  init_exp(&e, VNONRELOC, ls->fs->freereg-1);  /* default assignment */
+  luaK_storevar(ls->fs, &lh->v, &e);
+}
+
+
+static void cond (LexState *ls, expdesc *v) {
+  /* cond -> exp */
+  expr(ls, v);  /* read condition */
+  if (v->k == VNIL) v->k = VFALSE;  /* `falses' are all equal here */
+  luaK_goiftrue(ls->fs, v);
+  luaK_patchtohere(ls->fs, v->t);
+}
+
+
+/*
+** The while statement optimizes its code by coding the condition
+** after its body (and thus avoiding one jump in the loop).
+*/
+
+/*
+** maximum size of expressions for optimizing `while' code
+*/
+#ifndef MAXEXPWHILE
+#define MAXEXPWHILE	100
+#endif
+
+/*
+** the call `luaK_goiffalse' may grow the size of an expression by
+** at most this:
+*/
+#define EXTRAEXP	5
+
+static void whilestat (LexState *ls, int line) {
+  /* whilestat -> WHILE cond DO block END */
+  Instruction codeexp[MAXEXPWHILE + EXTRAEXP];
+  int lineexp;
+  int i;
+  int sizeexp;
+  FuncState *fs = ls->fs;
+  int whileinit, blockinit, expinit;
+  expdesc v;
+  BlockCnt bl;
+  next(ls);  /* skip WHILE */
+  whileinit = luaK_jump(fs);  /* jump to condition (which will be moved) */
+  expinit = luaK_getlabel(fs);
+  expr(ls, &v);  /* parse condition */
+  if (v.k == VK) v.k = VTRUE;  /* `trues' are all equal here */
+  lineexp = ls->linenumber;
+  luaK_goiffalse(fs, &v);
+  luaK_concat(fs, &v.f, fs->jpc);
+  fs->jpc = NO_JUMP;
+  sizeexp = fs->pc - expinit;  /* size of expression code */
+  if (sizeexp > MAXEXPWHILE) 
+    luaX_syntaxerror(ls, "`while' condition too complex");
+  for (i = 0; i < sizeexp; i++)  /* save `exp' code */
+    codeexp[i] = fs->f->code[expinit + i];
+  fs->pc = expinit;  /* remove `exp' code */
+  enterblock(fs, &bl, 1);
+  check(ls, TK_DO);
+  blockinit = luaK_getlabel(fs);
+  block(ls);
+  luaK_patchtohere(fs, whileinit);  /* initial jump jumps to here */
+  /* move `exp' back to code */
+  if (v.t != NO_JUMP) v.t += fs->pc - expinit;
+  if (v.f != NO_JUMP) v.f += fs->pc - expinit;
+  for (i=0; i<sizeexp; i++)
+    luaK_code(fs, codeexp[i], lineexp);
+  check_match(ls, TK_END, TK_WHILE, line);
+  leaveblock(fs);
+  luaK_patchlist(fs, v.t, blockinit);  /* true conditions go back to loop */
+  luaK_patchtohere(fs, v.f);  /* false conditions finish the loop */
+}
+
+
+static void repeatstat (LexState *ls, int line) {
+  /* repeatstat -> REPEAT block UNTIL cond */
+  FuncState *fs = ls->fs;
+  int repeat_init = luaK_getlabel(fs);
+  expdesc v;
+  BlockCnt bl;
+  enterblock(fs, &bl, 1);
+  next(ls);
+  block(ls);
+  check_match(ls, TK_UNTIL, TK_REPEAT, line);
+  cond(ls, &v);
+  luaK_patchlist(fs, v.f, repeat_init);
+  leaveblock(fs);
+}
+
+
+static int exp1 (LexState *ls) {
+  expdesc e;
+  int k;
+  expr(ls, &e);
+  k = e.k;
+  luaK_exp2nextreg(ls->fs, &e);
+  return k;
+}
+
+
+static void forbody (LexState *ls, int base, int line, int nvars, int isnum) {
+  BlockCnt bl;
+  FuncState *fs = ls->fs;
+  int prep, endfor;
+  adjustlocalvars(ls, nvars);  /* scope for all variables */
+  check(ls, TK_DO);
+  enterblock(fs, &bl, 1);  /* loop block */
+  prep = luaK_getlabel(fs);
+  block(ls);
+  luaK_patchtohere(fs, prep-1);
+  endfor = (isnum) ? luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP) :
+                     luaK_codeABC(fs, OP_TFORLOOP, base, 0, nvars - 3);
+  luaK_fixline(fs, line);  /* pretend that `OP_FOR' starts the loop */
+  luaK_patchlist(fs, (isnum) ? endfor : luaK_jump(fs), prep);
+  leaveblock(fs);
+}
+
+
+static void fornum (LexState *ls, TString *varname, int line) {
+  /* fornum -> NAME = exp1,exp1[,exp1] DO body */
+  FuncState *fs = ls->fs;
+  int base = fs->freereg;
+  new_localvar(ls, varname, 0);
+  new_localvarstr(ls, "(for limit)", 1);
+  new_localvarstr(ls, "(for step)", 2);
+  check(ls, '=');
+  exp1(ls);  /* initial value */
+  check(ls, ',');
+  exp1(ls);  /* limit */
+  if (testnext(ls, ','))
+    exp1(ls);  /* optional step */
+  else {  /* default step = 1 */
+    luaK_codeABx(fs, OP_LOADK, fs->freereg, luaK_numberK(fs, 1));
+    luaK_reserveregs(fs, 1);
+  }
+  luaK_codeABC(fs, OP_SUB, fs->freereg - 3, fs->freereg - 3, fs->freereg - 1);
+  luaK_jump(fs);
+  forbody(ls, base, line, 3, 1);
+}
+
+
+static void forlist (LexState *ls, TString *indexname) {
+  /* forlist -> NAME {,NAME} IN explist1 DO body */
+  FuncState *fs = ls->fs;
+  expdesc e;
+  int nvars = 0;
+  int line;
+  int base = fs->freereg;
+  new_localvarstr(ls, "(for generator)", nvars++);
+  new_localvarstr(ls, "(for state)", nvars++);
+  new_localvar(ls, indexname, nvars++);
+  while (testnext(ls, ','))
+    new_localvar(ls, str_checkname(ls), nvars++);
+  check(ls, TK_IN);
+  line = ls->linenumber;
+  adjust_assign(ls, nvars, explist1(ls, &e), &e);
+  luaK_checkstack(fs, 3);  /* extra space to call generator */
+  luaK_codeAsBx(fs, OP_TFORPREP, base, NO_JUMP);
+  forbody(ls, base, line, nvars, 0);
+}
+
+
+static void forstat (LexState *ls, int line) {
+  /* forstat -> fornum | forlist */
+  FuncState *fs = ls->fs;
+  TString *varname;
+  BlockCnt bl;
+  enterblock(fs, &bl, 0);  /* block to control variable scope */
+  next(ls);  /* skip `for' */
+  varname = str_checkname(ls);  /* first variable name */
+  switch (ls->t.token) {
+    case '=': fornum(ls, varname, line); break;
+    case ',': case TK_IN: forlist(ls, varname); break;
+    default: luaX_syntaxerror(ls, "`=' or `in' expected");
+  }
+  check_match(ls, TK_END, TK_FOR, line);
+  leaveblock(fs);
+}
+
+
+static void test_then_block (LexState *ls, expdesc *v) {
+  /* test_then_block -> [IF | ELSEIF] cond THEN block */
+  next(ls);  /* skip IF or ELSEIF */
+  cond(ls, v);
+  check(ls, TK_THEN);
+  block(ls);  /* `then' part */
+}
+
+
+static void ifstat (LexState *ls, int line) {
+  /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
+  FuncState *fs = ls->fs;
+  expdesc v;
+  int escapelist = NO_JUMP;
+  test_then_block(ls, &v);  /* IF cond THEN block */
+  while (ls->t.token == TK_ELSEIF) {
+    luaK_concat(fs, &escapelist, luaK_jump(fs));
+    luaK_patchtohere(fs, v.f);
+    test_then_block(ls, &v);  /* ELSEIF cond THEN block */
+  }
+  if (ls->t.token == TK_ELSE) {
+    luaK_concat(fs, &escapelist, luaK_jump(fs));
+    luaK_patchtohere(fs, v.f);
+    next(ls);  /* skip ELSE (after patch, for correct line info) */
+    block(ls);  /* `else' part */
+  }
+  else
+    luaK_concat(fs, &escapelist, v.f);
+  luaK_patchtohere(fs, escapelist);
+  check_match(ls, TK_END, TK_IF, line);
+}
+
+
+static void localfunc (LexState *ls) {
+  expdesc v, b;
+  new_localvar(ls, str_checkname(ls), 0);
+  init_exp(&v, VLOCAL, ls->fs->freereg++);
+  adjustlocalvars(ls, 1);
+  body(ls, &b, 0, ls->linenumber);
+  luaK_storevar(ls->fs, &v, &b);
+}
+
+
+static void localstat (LexState *ls) {
+  /* stat -> LOCAL NAME {`,' NAME} [`=' explist1] */
+  int nvars = 0;
+  int nexps;
+  expdesc e;
+  do {
+    new_localvar(ls, str_checkname(ls), nvars++);
+  } while (testnext(ls, ','));
+  if (testnext(ls, '='))
+    nexps = explist1(ls, &e);
+  else {
+    e.k = VVOID;
+    nexps = 0;
+  }
+  adjust_assign(ls, nvars, nexps, &e);
+  adjustlocalvars(ls, nvars);
+}
+
+
+static int funcname (LexState *ls, expdesc *v) {
+  /* funcname -> NAME {field} [`:' NAME] */
+  int needself = 0;
+  singlevar(ls, v, 1);
+  while (ls->t.token == '.')
+    luaY_field(ls, v);
+  if (ls->t.token == ':') {
+    needself = 1;
+    luaY_field(ls, v);
+  }
+  return needself;
+}
+
+
+static void funcstat (LexState *ls, int line) {
+  /* funcstat -> FUNCTION funcname body */
+  int needself;
+  expdesc v, b;
+  next(ls);  /* skip FUNCTION */
+  needself = funcname(ls, &v);
+  body(ls, &b, needself, line);
+  luaK_storevar(ls->fs, &v, &b);
+  luaK_fixline(ls->fs, line);  /* definition `happens' in the first line */
+}
+
+
+static void exprstat (LexState *ls) {
+  /* stat -> func | assignment */
+  FuncState *fs = ls->fs;
+  struct LHS_assign v;
+  primaryexp(ls, &v.v);
+  if (v.v.k == VCALL) {  /* stat -> func */
+    luaK_setcallreturns(fs, &v.v, 0);  /* call statement uses no results */
+  }
+  else {  /* stat -> assignment */
+    v.prev = NULL;
+    assignment(ls, &v, 1);
+  }
+}
+
+
+static void retstat (LexState *ls) {
+  /* stat -> RETURN explist */
+  FuncState *fs = ls->fs;
+  expdesc e;
+  int first, nret;  /* registers with returned values */
+  next(ls);  /* skip RETURN */
+  if (block_follow(ls->t.token) || ls->t.token == ';')
+    first = nret = 0;  /* return no values */
+  else {
+    nret = explist1(ls, &e);  /* optional return values */
+    if (e.k == VCALL) {
+      luaK_setcallreturns(fs, &e, LUA_MULTRET);
+      if (nret == 1) {  /* tail call? */
+        SET_OPCODE(getcode(fs,&e), OP_TAILCALL);
+        lua_assert(GETARG_A(getcode(fs,&e)) == fs->nactvar);
+      }
+      first = fs->nactvar;
+      nret = LUA_MULTRET;  /* return all values */
+    }
+    else {
+      if (nret == 1)  /* only one single value? */
+        first = luaK_exp2anyreg(fs, &e);
+      else {
+        luaK_exp2nextreg(fs, &e);  /* values must go to the `stack' */
+        first = fs->nactvar;  /* return all `active' values */
+        lua_assert(nret == fs->freereg - first);
+      }
+    }
+  }
+  luaK_codeABC(fs, OP_RETURN, first, nret+1, 0);
+}
+
+
+static void breakstat (LexState *ls) {
+  /* stat -> BREAK [NAME] */
+  FuncState *fs = ls->fs;
+  BlockCnt *bl = fs->bl;
+  int upval = 0;
+  next(ls);  /* skip BREAK */
+  while (bl && !bl->isbreakable) {
+    upval |= bl->upval;
+    bl = bl->previous;
+  }
+  if (!bl)
+    luaX_syntaxerror(ls, "no loop to break");
+  if (upval)
+    luaK_codeABC(fs, OP_CLOSE, bl->nactvar, 0, 0);
+  luaK_concat(fs, &bl->breaklist, luaK_jump(fs));
+}
+
+
+static int statement (LexState *ls) {
+  int line = ls->linenumber;  /* may be needed for error messages */
+  switch (ls->t.token) {
+    case TK_IF: {  /* stat -> ifstat */
+      ifstat(ls, line);
+      return 0;
+    }
+    case TK_WHILE: {  /* stat -> whilestat */
+      whilestat(ls, line);
+      return 0;
+    }
+    case TK_DO: {  /* stat -> DO block END */
+      next(ls);  /* skip DO */
+      block(ls);
+      check_match(ls, TK_END, TK_DO, line);
+      return 0;
+    }
+    case TK_FOR: {  /* stat -> forstat */
+      forstat(ls, line);
+      return 0;
+    }
+    case TK_REPEAT: {  /* stat -> repeatstat */
+      repeatstat(ls, line);
+      return 0;
+    }
+    case TK_FUNCTION: {
+      funcstat(ls, line);  /* stat -> funcstat */
+      return 0;
+    }
+    case TK_LOCAL: {  /* stat -> localstat */
+      next(ls);  /* skip LOCAL */
+      if (testnext(ls, TK_FUNCTION))  /* local function? */
+        localfunc(ls);
+      else
+        localstat(ls);
+      return 0;
+    }
+    case TK_RETURN: {  /* stat -> retstat */
+      retstat(ls);
+      return 1;  /* must be last statement */
+    }
+    case TK_BREAK: {  /* stat -> breakstat */
+      breakstat(ls);
+      return 1;  /* must be last statement */
+    }
+    default: {
+      exprstat(ls);
+      return 0;  /* to avoid warnings */
+    }
+  }
+}
+
+
+static void chunk (LexState *ls) {
+  /* chunk -> { stat [`;'] } */
+  int islast = 0;
+  enterlevel(ls);
+  while (!islast && !block_follow(ls->t.token)) {
+    islast = statement(ls);
+    testnext(ls, ';');
+    lua_assert(ls->fs->freereg >= ls->fs->nactvar);
+    ls->fs->freereg = ls->fs->nactvar;  /* free registers */
+  }
+  leavelevel(ls);
+}
+
+/* }====================================================================== */

Added: trunk/source/libraries/lua/lparser.h
===================================================================
--- trunk/source/libraries/lua/lparser.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lparser.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,71 @@
+/*
+** $Id: lparser.h,v 1.47 2003/02/11 10:46:24 roberto Exp $
+** Lua Parser
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lparser_h
+#define lparser_h
+
+#include "llimits.h"
+#include "lobject.h"
+#include "ltable.h"
+#include "lzio.h"
+
+
+/*
+** Expression descriptor
+*/
+
+typedef enum {
+  VVOID,	/* no value */
+  VNIL,
+  VTRUE,
+  VFALSE,
+  VK,		/* info = index of constant in `k' */
+  VLOCAL,	/* info = local register */
+  VUPVAL,       /* info = index of upvalue in `upvalues' */
+  VGLOBAL,	/* info = index of table; aux = index of global name in `k' */
+  VINDEXED,	/* info = table register; aux = index register (or `k') */
+  VJMP,		/* info = instruction pc */
+  VRELOCABLE,	/* info = instruction pc */
+  VNONRELOC,	/* info = result register */
+  VCALL		/* info = result register */
+} expkind;
+
+typedef struct expdesc {
+  expkind k;
+  int info, aux;
+  int t;  /* patch list of `exit when true' */
+  int f;  /* patch list of `exit when false' */
+} expdesc;
+
+
+struct BlockCnt;  /* defined in lparser.c */
+
+
+/* state needed to generate code for a given function */
+typedef struct FuncState {
+  Proto *f;  /* current function header */
+  Table *h;  /* table to find (and reuse) elements in `k' */
+  struct FuncState *prev;  /* enclosing function */
+  struct LexState *ls;  /* lexical state */
+  struct lua_State *L;  /* copy of the Lua state */
+  struct BlockCnt *bl;  /* chain of current blocks */
+  int pc;  /* next position to code (equivalent to `ncode') */
+  int lasttarget;   /* `pc' of last `jump target' */
+  int jpc;  /* list of pending jumps to `pc' */
+  int freereg;  /* first free register */
+  int nk;  /* number of elements in `k' */
+  int np;  /* number of elements in `p' */
+  int nlocvars;  /* number of elements in `locvars' */
+  int nactvar;  /* number of active local variables */
+  expdesc upvalues[MAXUPVALUES];  /* upvalues */
+  int actvar[MAXVARS];  /* declared-variable stack */
+} FuncState;
+
+
+Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff);
+
+
+#endif

Added: trunk/source/libraries/lua/lstate.c
===================================================================
--- trunk/source/libraries/lua/lstate.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lstate.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,220 @@
+/*
+** $Id: lstate.c,v 1.123 2003/04/03 13:35:34 roberto Exp $
+** Global State
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+
+#define lstate_c
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "llex.h"
+#include "lmem.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+
+
+/*
+** macro to allow the inclusion of user information in Lua state
+*/
+#ifndef LUA_USERSTATE
+#define EXTRASPACE	0
+#else
+union UEXTRASPACE {L_Umaxalign a; LUA_USERSTATE b;};
+#define EXTRASPACE (sizeof(union UEXTRASPACE))
+#endif
+
+
+
+/*
+** you can change this function through the official API:
+** call `lua_setpanicf'
+*/
+static int default_panic (lua_State *L) {
+  UNUSED(L);
+  return 0;
+}
+
+
+static lua_State *mallocstate (lua_State *L) {
+  lu_byte *block = (lu_byte *)luaM_malloc(L, sizeof(lua_State) + EXTRASPACE);
+  if (block == NULL) return NULL;
+  else {
+    block += EXTRASPACE;
+    return cast(lua_State *, block);
+  }
+}
+
+
+static void freestate (lua_State *L, lua_State *L1) {
+  luaM_free(L, cast(lu_byte *, L1) - EXTRASPACE,
+               sizeof(lua_State) + EXTRASPACE);
+}
+
+
+static void stack_init (lua_State *L1, lua_State *L) {
+  L1->stack = luaM_newvector(L, BASIC_STACK_SIZE + EXTRA_STACK, TObject);
+  L1->stacksize = BASIC_STACK_SIZE + EXTRA_STACK;
+  L1->top = L1->stack;
+  L1->stack_last = L1->stack+(L1->stacksize - EXTRA_STACK)-1;
+  L1->base_ci = luaM_newvector(L, BASIC_CI_SIZE, CallInfo);
+  L1->ci = L1->base_ci;
+  L1->ci->state = CI_C;  /*  not a Lua function */
+  setnilvalue(L1->top++);  /* `function' entry for this `ci' */
+  L1->base = L1->ci->base = L1->top;
+  L1->ci->top = L1->top + LUA_MINSTACK;
+  L1->size_ci = BASIC_CI_SIZE;
+  L1->end_ci = L1->base_ci + L1->size_ci;
+}
+
+
+static void freestack (lua_State *L, lua_State *L1) {
+  luaM_freearray(L, L1->base_ci, L1->size_ci, CallInfo);
+  luaM_freearray(L, L1->stack, L1->stacksize, TObject);
+}
+
+
+/*
+** open parts that may cause memory-allocation errors
+*/
+static void f_luaopen (lua_State *L, void *ud) {
+  /* create a new global state */
+  global_State *g = luaM_new(NULL, global_State);
+  UNUSED(ud);
+  if (g == NULL) luaD_throw(L, LUA_ERRMEM);
+  L->l_G = g;
+  g->mainthread = L;
+  g->GCthreshold = 0;  /* mark it as unfinished state */
+  g->strt.size = 0;
+  g->strt.nuse = 0;
+  g->strt.hash = NULL;
+  setnilvalue(defaultmeta(L));
+  setnilvalue(registry(L));
+  luaZ_initbuffer(L, &g->buff);
+  g->panic = default_panic;
+  g->rootgc = NULL;
+  g->rootudata = NULL;
+  g->tmudata = NULL;
+  setnilvalue(gkey(g->dummynode));
+  setnilvalue(gval(g->dummynode));
+  g->dummynode->next = NULL;
+  g->nblocks = sizeof(lua_State) + sizeof(global_State);
+  stack_init(L, L);  /* init stack */
+  /* create default meta table with a dummy table, and then close the loop */
+  defaultmeta(L)->tt = LUA_TTABLE;
+  sethvalue(defaultmeta(L), luaH_new(L, 0, 0));
+  hvalue(defaultmeta(L))->metatable = hvalue(defaultmeta(L));
+  sethvalue(gt(L), luaH_new(L, 0, 4));  /* table of globals */
+  sethvalue(registry(L), luaH_new(L, 4, 4));  /* registry */
+  luaS_resize(L, MINSTRTABSIZE);  /* initial size of string table */
+  luaT_init(L);
+  luaX_init(L);
+  luaS_fix(luaS_newliteral(L, MEMERRMSG));
+  g->GCthreshold = 4*G(L)->nblocks;
+}
+
+
+static void preinit_state (lua_State *L) {
+  L->stack = NULL;
+  L->stacksize = 0;
+  L->errorJmp = NULL;
+  L->hook = NULL;
+  L->hookmask = L->hookinit = 0;
+  L->basehookcount = 0;
+  L->allowhook = 1;
+  resethookcount(L);
+  L->openupval = NULL;
+  L->size_ci = 0;
+  L->nCcalls = 0;
+  L->base_ci = L->ci = NULL;
+  L->errfunc = 0;
+  setnilvalue(gt(L));
+}
+
+
+static void close_state (lua_State *L) {
+  luaF_close(L, L->stack);  /* close all upvalues for this thread */
+  if (G(L)) {  /* close global state */
+    luaC_sweep(L, 1);  /* collect all elements */
+    lua_assert(G(L)->rootgc == NULL);
+    lua_assert(G(L)->rootudata == NULL);
+    luaS_freeall(L);
+    luaZ_freebuffer(L, &G(L)->buff);
+  }
+  freestack(L, L);
+  if (G(L)) {
+    lua_assert(G(L)->nblocks == sizeof(lua_State) + sizeof(global_State));
+    luaM_freelem(NULL, G(L));
+  }
+  freestate(NULL, L);
+}
+
+
+lua_State *luaE_newthread (lua_State *L) {
+  lua_State *L1 = mallocstate(L);
+  luaC_link(L, valtogco(L1), LUA_TTHREAD);
+  preinit_state(L1);
+  L1->l_G = L->l_G;
+  stack_init(L1, L);  /* init stack */
+  setobj2n(gt(L1), gt(L));  /* share table of globals */
+  return L1;
+}
+
+
+void luaE_freethread (lua_State *L, lua_State *L1) {
+  luaF_close(L1, L1->stack);  /* close all upvalues for this thread */
+  lua_assert(L1->openupval == NULL);
+  freestack(L, L1);
+  freestate(L, L1);
+}
+
+
+LUA_API lua_State *lua_open (void) {
+  lua_State *L = mallocstate(NULL);
+  if (L) {  /* allocation OK? */
+    L->tt = LUA_TTHREAD;
+    L->marked = 0;
+    L->next = L->gclist = NULL;
+    preinit_state(L);
+    L->l_G = NULL;
+    if (luaD_rawrunprotected(L, f_luaopen, NULL) != 0) {
+      /* memory allocation error: free partial state */
+      close_state(L);
+      L = NULL;
+    }
+  }
+  lua_userstateopen(L);
+  return L;
+}
+
+
+static void callallgcTM (lua_State *L, void *ud) {
+  UNUSED(ud);
+  luaC_callGCTM(L);  /* call GC metamethods for all udata */
+}
+
+
+LUA_API void lua_close (lua_State *L) {
+  lua_lock(L);
+  L = G(L)->mainthread;  /* only the main thread can be closed */
+  luaF_close(L, L->stack);  /* close all upvalues for this thread */
+  luaC_separateudata(L);  /* separate udata that have GC metamethods */
+  L->errfunc = 0;  /* no error function during GC metamethods */
+  do {  /* repeat until no more errors */
+    L->ci = L->base_ci;
+    L->base = L->top = L->ci->base;
+    L->nCcalls = 0;
+  } while (luaD_rawrunprotected(L, callallgcTM, NULL) != 0);
+  lua_assert(G(L)->tmudata == NULL);
+  close_state(L);
+}
+

Added: trunk/source/libraries/lua/lstate.h
===================================================================
--- trunk/source/libraries/lua/lstate.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lstate.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,195 @@
+/*
+** $Id: lstate.h,v 1.109 2003/02/27 11:52:30 roberto Exp $
+** Global State
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lstate_h
+#define lstate_h
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "ltm.h"
+#include "lzio.h"
+
+
+/*
+** macros for thread synchronization inside Lua core machine:
+** all accesses to the global state and to global objects are synchronized.
+** Because threads can read the stack of other threads
+** (when running garbage collection),
+** a thread must also synchronize any write-access to its own stack.
+** Unsynchronized accesses are allowed only when reading its own stack,
+** or when reading immutable fields from global objects
+** (such as string values and udata values). 
+*/
+#ifndef lua_lock
+#define lua_lock(L)	((void) 0)
+#endif
+
+#ifndef lua_unlock
+#define lua_unlock(L)	((void) 0)
+#endif
+
+
+#ifndef lua_userstateopen
+#define lua_userstateopen(l)
+#endif
+
+
+
+struct lua_longjmp;  /* defined in ldo.c */
+
+
+/* default meta table (both for tables and udata) */
+#define defaultmeta(L)	(&G(L)->_defaultmeta)
+
+/* table of globals */
+#define gt(L)	(&L->_gt)
+
+/* registry */
+#define registry(L)	(&G(L)->_registry)
+
+
+/* extra stack space to handle TM calls and some other extras */
+#define EXTRA_STACK   5
+
+
+#define BASIC_CI_SIZE           8
+
+#define BASIC_STACK_SIZE        (2*LUA_MINSTACK)
+
+
+
+typedef struct stringtable {
+  GCObject **hash;
+  ls_nstr nuse;  /* number of elements */
+  int size;
+} stringtable;
+
+
+/*
+** informations about a call
+*/
+typedef struct CallInfo {
+  StkId base;  /* base for called function */
+  StkId	top;  /* top for this function */
+  int state;  /* bit fields; see below */
+  union {
+    struct {  /* for Lua functions */
+      const Instruction *savedpc;
+      const Instruction **pc;  /* points to `pc' variable in `luaV_execute' */
+      int tailcalls;  /* number of tail calls lost under this entry */
+    } l;
+    struct {  /* for C functions */
+      int dummy;  /* just to avoid an empty struct */
+    } c;
+  } u;
+} CallInfo;
+
+
+/*
+** bit fields for `CallInfo.state'
+*/
+#define CI_C		(1<<0)  /* 1 if function is a C function */
+/* 1 if (Lua) function has an active `luaV_execute' running it */
+#define CI_HASFRAME	(1<<1)
+/* 1 if Lua function is calling another Lua function (and therefore its
+   `pc' is being used by the other, and therefore CI_SAVEDPC is 1 too) */
+#define CI_CALLING	(1<<2)
+#define CI_SAVEDPC	(1<<3)  /* 1 if `savedpc' is updated */
+#define CI_YIELD	(1<<4)  /* 1 if thread is suspended */
+
+
+#define ci_func(ci)	(clvalue((ci)->base - 1))
+
+
+/*
+** `global state', shared by all threads of this state
+*/
+typedef struct global_State {
+  stringtable strt;  /* hash table for strings */
+  GCObject *rootgc;  /* list of (almost) all collectable objects */
+  GCObject *rootudata;   /* (separated) list of all userdata */
+  GCObject *tmudata;  /* list of userdata to be GC */
+  Mbuffer buff;  /* temporary buffer for string concatentation */
+  lu_mem GCthreshold;
+  lu_mem nblocks;  /* number of `bytes' currently allocated */
+  lua_CFunction panic;  /* to be called in unprotected errors */
+  TObject _registry;
+  TObject _defaultmeta;
+  struct lua_State *mainthread;
+  Node dummynode[1];  /* common node array for all empty tables */
+  TString *tmname[TM_N];  /* array with tag-method names */
+} global_State;
+
+
+/*
+** `per thread' state
+*/
+struct lua_State {
+  CommonHeader;
+  StkId top;  /* first free slot in the stack */
+  StkId base;  /* base of current function */
+  global_State *l_G;
+  CallInfo *ci;  /* call info for current function */
+  StkId stack_last;  /* last free slot in the stack */
+  StkId stack;  /* stack base */
+  int stacksize;
+  CallInfo *end_ci;  /* points after end of ci array*/
+  CallInfo *base_ci;  /* array of CallInfo's */
+  unsigned short size_ci;  /* size of array `base_ci' */
+  unsigned short nCcalls;  /* number of nested C calls */
+  lu_byte hookmask;
+  lu_byte allowhook;
+  lu_byte hookinit;
+  int basehookcount;
+  int hookcount;
+  lua_Hook hook;
+  TObject _gt;  /* table of globals */
+  GCObject *openupval;  /* list of open upvalues in this stack */
+  GCObject *gclist;
+  struct lua_longjmp *errorJmp;  /* current error recover point */
+  ptrdiff_t errfunc;  /* current error handling function (stack index) */
+};
+
+
+#define G(L)	(L->l_G)
+
+
+/*
+** Union of all collectable objects
+*/
+union GCObject {
+  GCheader gch;
+  union TString ts;
+  union Udata u;
+  union Closure cl;
+  struct Table h;
+  struct Proto p;
+  struct UpVal uv;
+  struct lua_State th;  /* thread */
+};
+
+
+/* macros to convert a GCObject into a specific value */
+#define gcotots(o)	check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
+#define gcotou(o)	check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
+#define gcotocl(o)	check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
+#define gcotoh(o)	check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
+#define gcotop(o)	check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
+#define gcotouv(o)	check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
+#define ngcotouv(o) \
+	check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
+#define gcototh(o)	check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
+
+/* macro to convert any value into a GCObject */
+#define valtogco(v)	(cast(GCObject *, (v)))
+
+
+lua_State *luaE_newthread (lua_State *L);
+void luaE_freethread (lua_State *L, lua_State *L1);
+
+#endif
+

Added: trunk/source/libraries/lua/lstring.c
===================================================================
--- trunk/source/libraries/lua/lstring.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lstring.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,102 @@
+/*
+** $Id: lstring.c,v 1.78 2002/12/04 17:38:31 roberto Exp $
+** String table (keeps all strings handled by Lua)
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define lstring_c
+
+#include "lua.h"
+
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+
+
+
+void luaS_freeall (lua_State *L) {
+  lua_assert(G(L)->strt.nuse==0);
+  luaM_freearray(L, G(L)->strt.hash, G(L)->strt.size, TString *);
+}
+
+
+void luaS_resize (lua_State *L, int newsize) {
+  GCObject **newhash = luaM_newvector(L, newsize, GCObject *);
+  stringtable *tb = &G(L)->strt;
+  int i;
+  for (i=0; i<newsize; i++) newhash[i] = NULL;
+  /* rehash */
+  for (i=0; i<tb->size; i++) {
+    GCObject *p = tb->hash[i];
+    while (p) {  /* for each node in the list */
+      GCObject *next = p->gch.next;  /* save next */
+      lu_hash h = gcotots(p)->tsv.hash;
+      int h1 = lmod(h, newsize);  /* new position */
+      lua_assert(cast(int, h%newsize) == lmod(h, newsize));
+      p->gch.next = newhash[h1];  /* chain it */
+      newhash[h1] = p;
+      p = next;
+    }
+  }
+  luaM_freearray(L, tb->hash, tb->size, TString *);
+  tb->size = newsize;
+  tb->hash = newhash;
+}
+
+
+static TString *newlstr (lua_State *L, const char *str, size_t l, lu_hash h) {
+  TString *ts = cast(TString *, luaM_malloc(L, sizestring(l)));
+  stringtable *tb;
+  ts->tsv.len = l;
+  ts->tsv.hash = h;
+  ts->tsv.marked = 0;
+  ts->tsv.tt = LUA_TSTRING;
+  ts->tsv.reserved = 0;
+  memcpy(ts+1, str, l*sizeof(char));
+  ((char *)(ts+1))[l] = '\0';  /* ending 0 */
+  tb = &G(L)->strt;
+  h = lmod(h, tb->size);
+  ts->tsv.next = tb->hash[h];  /* chain new entry */
+  tb->hash[h] = valtogco(ts);
+  tb->nuse++;
+  if (tb->nuse > cast(ls_nstr, tb->size) && tb->size <= MAX_INT/2)
+    luaS_resize(L, tb->size*2);  /* too crowded */
+  return ts;
+}
+
+
+TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
+  GCObject *o;
+  lu_hash h = (lu_hash)l;  /* seed */
+  size_t step = (l>>5)+1;  /* if string is too long, don't hash all its chars */
+  size_t l1;
+  for (l1=l; l1>=step; l1-=step)  /* compute hash */
+    h = h ^ ((h<<5)+(h>>2)+(unsigned char)(str[l1-1]));
+  for (o = G(L)->strt.hash[lmod(h, G(L)->strt.size)];
+       o != NULL;
+       o = o->gch.next) {
+    TString *ts = gcotots(o);
+    if (ts->tsv.len == l && (memcmp(str, getstr(ts), l) == 0))
+      return ts;
+  }
+  return newlstr(L, str, l, h);  /* not found */
+}
+
+
+Udata *luaS_newudata (lua_State *L, size_t s) {
+  Udata *u;
+  u = cast(Udata *, luaM_malloc(L, sizeudata(s)));
+  u->uv.marked = (1<<1);  /* is not finalized */
+  u->uv.tt = LUA_TUSERDATA;
+  u->uv.len = s;
+  u->uv.metatable = hvalue(defaultmeta(L));
+  /* chain it on udata list */
+  u->uv.next = G(L)->rootudata;
+  G(L)->rootudata = valtogco(u);
+  return u;
+}
+

Added: trunk/source/libraries/lua/lstring.h
===================================================================
--- trunk/source/libraries/lua/lstring.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lstring.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,33 @@
+/*
+** $Id: lstring.h,v 1.37 2002/08/16 14:45:55 roberto Exp $
+** String table (keep all strings handled by Lua)
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lstring_h
+#define lstring_h
+
+
+#include "lobject.h"
+#include "lstate.h"
+
+
+
+#define sizestring(l)	(cast(lu_mem, sizeof(union TString))+ \
+                         (cast(lu_mem, l)+1)*sizeof(char))
+
+#define sizeudata(l)	(cast(lu_mem, sizeof(union Udata))+(l))
+
+#define luaS_new(L, s)	(luaS_newlstr(L, s, strlen(s)))
+#define luaS_newliteral(L, s)	(luaS_newlstr(L, "" s, \
+                                 (sizeof(s)/sizeof(char))-1))
+
+#define luaS_fix(s)	((s)->tsv.marked |= (1<<4))
+
+void luaS_resize (lua_State *L, int newsize);
+Udata *luaS_newudata (lua_State *L, size_t s);
+void luaS_freeall (lua_State *L);
+TString *luaS_newlstr (lua_State *L, const char *str, size_t l);
+
+
+#endif

Added: trunk/source/libraries/lua/ltable.c
===================================================================
--- trunk/source/libraries/lua/ltable.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ltable.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,509 @@
+/*
+** $Id: ltable.c,v 1.132 2003/04/03 13:35:34 roberto Exp $
+** Lua tables (hash)
+** See Copyright Notice in lua.h
+*/
+
+
+/*
+** Implementation of tables (aka arrays, objects, or hash tables).
+** Tables keep its elements in two parts: an array part and a hash part.
+** Non-negative integer keys are all candidates to be kept in the array
+** part. The actual size of the array is the largest `n' such that at
+** least half the slots between 0 and n are in use.
+** Hash uses a mix of chained scatter table with Brent's variation.
+** A main invariant of these tables is that, if an element is not
+** in its main position (i.e. the `original' position that its hash gives
+** to it), then the colliding element is in its own main position.
+** In other words, there are collisions only when two elements have the
+** same main position (i.e. the same hash values for that table size).
+** Because of that, the load factor of these tables can be 100% without
+** performance penalties.
+*/
+
+#include <string.h>
+
+#define ltable_c
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "ltable.h"
+
+
+/*
+** max size of array part is 2^MAXBITS
+*/
+#if BITS_INT > 26
+#define MAXBITS		24
+#else
+#define MAXBITS		(BITS_INT-2)
+#endif
+
+/* check whether `x' < 2^MAXBITS */
+#define toobig(x)	((((x)-1) >> MAXBITS) != 0)
+
+
+/* function to convert a lua_Number to int (with any rounding method) */
+#ifndef lua_number2int
+#define lua_number2int(i,n)	((i)=(int)(n))
+#endif
+
+
+#define hashpow2(t,n)      (gnode(t, lmod((n), sizenode(t))))
+  
+#define hashstr(t,str)  hashpow2(t, (str)->tsv.hash)
+#define hashboolean(t,p)        hashpow2(t, p)
+
+
+/*
+** for some types, it is better to avoid modulus by power of 2, as
+** they tend to have many 2 factors.
+*/
+#define hashmod(t,n)	(gnode(t, ((n) % ((sizenode(t)-1)|1))))
+
+
+#define hashpointer(t,p)	hashmod(t, IntPoint(p))
+
+
+/*
+** number of ints inside a lua_Number
+*/
+#define numints		cast(int, sizeof(lua_Number)/sizeof(int))
+
+
+/*
+** hash for lua_Numbers
+*/
+static Node *hashnum (const Table *t, lua_Number n) {
+  unsigned int a[numints];
+  int i;
+  n += 1;  /* normalize number (avoid -0) */
+  lua_assert(sizeof(a) <= sizeof(n));
+  memcpy(a, &n, sizeof(a));
+  for (i = 1; i < numints; i++) a[0] += a[i];
+  return hashmod(t, cast(lu_hash, a[0]));
+}
+
+
+
+/*
+** returns the `main' position of an element in a table (that is, the index
+** of its hash value)
+*/
+Node *luaH_mainposition (const Table *t, const TObject *key) {
+  switch (ttype(key)) {
+    case LUA_TNUMBER:
+      return hashnum(t, nvalue(key));
+    case LUA_TSTRING:
+      return hashstr(t, tsvalue(key));
+    case LUA_TBOOLEAN:
+      return hashboolean(t, bvalue(key));
+    case LUA_TLIGHTUSERDATA:
+      return hashpointer(t, pvalue(key));
+    default:
+      return hashpointer(t, gcvalue(key));
+  }
+}
+
+
+/*
+** returns the index for `key' if `key' is an appropriate key to live in
+** the array part of the table, -1 otherwise.
+*/
+static int arrayindex (const TObject *key) {
+  if (ttisnumber(key)) {
+    int k;
+    lua_number2int(k, (nvalue(key)));
+    if (cast(lua_Number, k) == nvalue(key) && k >= 1 && !toobig(k))
+      return k;
+  }
+  return -1;  /* `key' did not match some condition */
+}
+
+
+/*
+** returns the index of a `key' for table traversals. First goes all
+** elements in the array part, then elements in the hash part. The
+** beginning and end of a traversal are signalled by -1.
+*/
+static int luaH_index (lua_State *L, Table *t, StkId key) {
+  int i;
+  if (ttisnil(key)) return -1;  /* first iteration */
+  i = arrayindex(key);
+  if (0 <= i && i <= t->sizearray) {  /* is `key' inside array part? */
+    return i-1;  /* yes; that's the index (corrected to C) */
+  }
+  else {
+    const TObject *v = luaH_get(t, key);
+    if (v == &luaO_nilobject)
+      luaG_runerror(L, "invalid key for `next'");
+    i = cast(int, (cast(const lu_byte *, v) -
+                   cast(const lu_byte *, gval(gnode(t, 0)))) / sizeof(Node));
+    return i + t->sizearray;  /* hash elements are numbered after array ones */
+  }
+}
+
+
+int luaH_next (lua_State *L, Table *t, StkId key) {
+  int i = luaH_index(L, t, key);  /* find original element */
+  for (i++; i < t->sizearray; i++) {  /* try first array part */
+    if (!ttisnil(&t->array[i])) {  /* a non-nil value? */
+      setnvalue(key, cast(lua_Number, i+1));
+      setobj2s(key+1, &t->array[i]);
+      return 1;
+    }
+  }
+  for (i -= t->sizearray; i < sizenode(t); i++) {  /* then hash part */
+    if (!ttisnil(gval(gnode(t, i)))) {  /* a non-nil value? */
+      setobj2s(key, gkey(gnode(t, i)));
+      setobj2s(key+1, gval(gnode(t, i)));
+      return 1;
+    }
+  }
+  return 0;  /* no more elements */
+}
+
+
+/*
+** {=============================================================
+** Rehash
+** ==============================================================
+*/
+
+
+static void computesizes  (int nums[], int ntotal, int *narray, int *nhash) {
+  int i;
+  int a = nums[0];  /* number of elements smaller than 2^i */
+  int na = a;  /* number of elements to go to array part */
+  int n = (na == 0) ? -1 : 0;  /* (log of) optimal size for array part */
+  for (i = 1; a < *narray && *narray >= twoto(i-1); i++) {
+    if (nums[i] > 0) {
+      a += nums[i];
+      if (a >= twoto(i-1)) {  /* more than half elements in use? */
+        n = i;
+        na = a;
+      }
+    }
+  }
+  lua_assert(na <= *narray && *narray <= ntotal);
+  *nhash = ntotal - na;
+  *narray = (n == -1) ? 0 : twoto(n);
+  lua_assert(na <= *narray && na >= *narray/2);
+}
+
+
+static void numuse (const Table *t, int *narray, int *nhash) {
+  int nums[MAXBITS+1];
+  int i, lg;
+  int totaluse = 0;
+  /* count elements in array part */
+  for (i=0, lg=0; lg<=MAXBITS; lg++) {  /* for each slice [2^(lg-1) to 2^lg) */
+    int ttlg = twoto(lg);  /* 2^lg */
+    if (ttlg > t->sizearray) {
+      ttlg = t->sizearray;
+      if (i >= ttlg) break;
+    }
+    nums[lg] = 0;
+    for (; i<ttlg; i++) {
+      if (!ttisnil(&t->array[i])) {
+        nums[lg]++;
+        totaluse++;
+      }
+    }
+  }
+  for (; lg<=MAXBITS; lg++) nums[lg] = 0;  /* reset other counts */
+  *narray = totaluse;  /* all previous uses were in array part */
+  /* count elements in hash part */
+  i = sizenode(t);
+  while (i--) {
+    Node *n = &t->node[i];
+    if (!ttisnil(gval(n))) {
+      int k = arrayindex(gkey(n));
+      if (k >= 0) {  /* is `key' an appropriate array index? */
+        nums[luaO_log2(k-1)+1]++;  /* count as such */
+        (*narray)++;
+      }
+      totaluse++;
+    }
+  }
+  computesizes(nums, totaluse, narray, nhash);
+}
+
+
+static void setarrayvector (lua_State *L, Table *t, int size) {
+  int i;
+  luaM_reallocvector(L, t->array, t->sizearray, size, TObject);
+  for (i=t->sizearray; i<size; i++)
+     setnilvalue(&t->array[i]);
+  t->sizearray = size;
+}
+
+
+static void setnodevector (lua_State *L, Table *t, int lsize) {
+  int i;
+  int size = twoto(lsize);
+  if (lsize > MAXBITS)
+    luaG_runerror(L, "table overflow");
+  if (lsize == 0) {  /* no elements to hash part? */
+    t->node = G(L)->dummynode;  /* use common `dummynode' */
+    lua_assert(ttisnil(gkey(t->node)));  /* assert invariants: */
+    lua_assert(ttisnil(gval(t->node)));
+    lua_assert(t->node->next == NULL);  /* (`dummynode' must be empty) */
+  }
+  else {
+    t->node = luaM_newvector(L, size, Node);
+    for (i=0; i<size; i++) {
+      t->node[i].next = NULL;
+      setnilvalue(gkey(gnode(t, i)));
+      setnilvalue(gval(gnode(t, i)));
+    }
+  }
+  t->lsizenode = cast(lu_byte, lsize);
+  t->firstfree = gnode(t, size-1);  /* first free position to be used */
+}
+
+
+static void resize (lua_State *L, Table *t, int nasize, int nhsize) {
+  int i;
+  int oldasize = t->sizearray;
+  int oldhsize = t->lsizenode;
+  Node *nold;
+  Node temp[1];
+  if (oldhsize)
+    nold = t->node;  /* save old hash ... */
+  else {  /* old hash is `dummynode' */
+    lua_assert(t->node == G(L)->dummynode);
+    temp[0] = t->node[0];  /* copy it to `temp' */
+    nold = temp;
+    setnilvalue(gkey(G(L)->dummynode));  /* restate invariant */
+    setnilvalue(gval(G(L)->dummynode));
+    lua_assert(G(L)->dummynode->next == NULL);
+  }
+  if (nasize > oldasize)  /* array part must grow? */
+    setarrayvector(L, t, nasize);
+  /* create new hash part with appropriate size */
+  setnodevector(L, t, nhsize);  
+  /* re-insert elements */
+  if (nasize < oldasize) {  /* array part must shrink? */
+    t->sizearray = nasize;
+    /* re-insert elements from vanishing slice */
+    for (i=nasize; i<oldasize; i++) {
+      if (!ttisnil(&t->array[i]))
+        setobjt2t(luaH_setnum(L, t, i+1), &t->array[i]);
+    }
+    /* shrink array */
+    luaM_reallocvector(L, t->array, oldasize, nasize, TObject);
+  }
+  /* re-insert elements in hash part */
+  for (i = twoto(oldhsize) - 1; i >= 0; i--) {
+    Node *old = nold+i;
+    if (!ttisnil(gval(old)))
+      setobjt2t(luaH_set(L, t, gkey(old)), gval(old));
+  }
+  if (oldhsize)
+    luaM_freearray(L, nold, twoto(oldhsize), Node);  /* free old array */
+}
+
+
+static void rehash (lua_State *L, Table *t) {
+  int nasize, nhsize;
+  numuse(t, &nasize, &nhsize);  /* compute new sizes for array and hash parts */
+  resize(L, t, nasize, luaO_log2(nhsize)+1);
+}
+
+
+
+/*
+** }=============================================================
+*/
+
+
+Table *luaH_new (lua_State *L, int narray, int lnhash) {
+  Table *t = luaM_new(L, Table);
+  luaC_link(L, valtogco(t), LUA_TTABLE);
+  t->metatable = hvalue(defaultmeta(L));
+  t->flags = cast(lu_byte, ~0);
+  /* temporary values (kept only if some malloc fails) */
+  t->array = NULL;
+  t->sizearray = 0;
+  t->lsizenode = 0;
+  t->node = NULL;
+  setarrayvector(L, t, narray);
+  setnodevector(L, t, lnhash);
+  return t;
+}
+
+
+void luaH_free (lua_State *L, Table *t) {
+  if (t->lsizenode)
+    luaM_freearray(L, t->node, sizenode(t), Node);
+  luaM_freearray(L, t->array, t->sizearray, TObject);
+  luaM_freelem(L, t);
+}
+
+
+#if 0
+/*
+** try to remove an element from a hash table; cannot move any element
+** (because gc can call `remove' during a table traversal)
+*/
+void luaH_remove (Table *t, Node *e) {
+  Node *mp = luaH_mainposition(t, gkey(e));
+  if (e != mp) {  /* element not in its main position? */
+    while (mp->next != e) mp = mp->next;  /* find previous */
+    mp->next = e->next;  /* remove `e' from its list */
+  }
+  else {
+    if (e->next != NULL) ??
+  }
+  lua_assert(ttisnil(gval(node)));
+  setnilvalue(gkey(e));  /* clear node `e' */
+  e->next = NULL;
+}
+#endif
+
+
+/*
+** inserts a new key into a hash table; first, check whether key's main 
+** position is free. If not, check whether colliding node is in its main 
+** position or not: if it is not, move colliding node to an empty place and 
+** put new key in its main position; otherwise (colliding node is in its main 
+** position), new key goes to an empty position. 
+*/
+static TObject *newkey (lua_State *L, Table *t, const TObject *key) {
+  TObject *val;
+  Node *mp = luaH_mainposition(t, key);
+  if (!ttisnil(gval(mp))) {  /* main position is not free? */
+    Node *othern = luaH_mainposition(t, gkey(mp));  /* `mp' of colliding node */
+    Node *n = t->firstfree;  /* get a free place */
+    if (othern != mp) {  /* is colliding node out of its main position? */
+      /* yes; move colliding node into free position */
+      while (othern->next != mp) othern = othern->next;  /* find previous */
+      othern->next = n;  /* redo the chain with `n' in place of `mp' */
+      *n = *mp;  /* copy colliding node into free pos. (mp->next also goes) */
+      mp->next = NULL;  /* now `mp' is free */
+      setnilvalue(gval(mp));
+    }
+    else {  /* colliding node is in its own main position */
+      /* new node will go into free position */
+      n->next = mp->next;  /* chain new position */
+      mp->next = n;
+      mp = n;
+    }
+  }
+  setobj2t(gkey(mp), key);  /* write barrier */
+  lua_assert(ttisnil(gval(mp)));
+  for (;;) {  /* correct `firstfree' */
+    if (ttisnil(gkey(t->firstfree)))
+      return gval(mp);  /* OK; table still has a free place */
+    else if (t->firstfree == t->node) break;  /* cannot decrement from here */
+    else (t->firstfree)--;
+  }
+  /* no more free places; must create one */
+  setbvalue(gval(mp), 0);  /* avoid new key being removed */
+  rehash(L, t);  /* grow table */
+  val = cast(TObject *, luaH_get(t, key));  /* get new position */
+  lua_assert(ttisboolean(val));
+  setnilvalue(val);
+  return val;
+}
+
+
+/*
+** generic search function
+*/
+static const TObject *luaH_getany (Table *t, const TObject *key) {
+  if (ttisnil(key)) return &luaO_nilobject;
+  else {
+    Node *n = luaH_mainposition(t, key);
+    do {  /* check whether `key' is somewhere in the chain */
+      if (luaO_rawequalObj(gkey(n), key)) return gval(n);  /* that's it */
+      else n = n->next;
+    } while (n);
+    return &luaO_nilobject;
+  }
+}
+
+
+/*
+** search function for integers
+*/
+const TObject *luaH_getnum (Table *t, int key) {
+  if (1 <= key && key <= t->sizearray)
+    return &t->array[key-1];
+  else {
+    lua_Number nk = cast(lua_Number, key);
+    Node *n = hashnum(t, nk);
+    do {  /* check whether `key' is somewhere in the chain */
+      if (ttisnumber(gkey(n)) && nvalue(gkey(n)) == nk)
+        return gval(n);  /* that's it */
+      else n = n->next;
+    } while (n);
+    return &luaO_nilobject;
+  }
+}
+
+
+/*
+** search function for strings
+*/
+const TObject *luaH_getstr (Table *t, TString *key) {
+  Node *n = hashstr(t, key);
+  do {  /* check whether `key' is somewhere in the chain */
+    if (ttisstring(gkey(n)) && tsvalue(gkey(n)) == key)
+      return gval(n);  /* that's it */
+    else n = n->next;
+  } while (n);
+  return &luaO_nilobject;
+}
+
+
+/*
+** main search function
+*/
+const TObject *luaH_get (Table *t, const TObject *key) {
+  switch (ttype(key)) {
+    case LUA_TSTRING: return luaH_getstr(t, tsvalue(key));
+    case LUA_TNUMBER: {
+      int k;
+      lua_number2int(k, (nvalue(key)));
+      if (cast(lua_Number, k) == nvalue(key))  /* is an integer index? */
+        return luaH_getnum(t, k);  /* use specialized version */
+      /* else go through */
+    }
+    default: return luaH_getany(t, key);
+  }
+}
+
+
+TObject *luaH_set (lua_State *L, Table *t, const TObject *key) {
+  const TObject *p = luaH_get(t, key);
+  t->flags = 0;
+  if (p != &luaO_nilobject)
+    return cast(TObject *, p);
+  else {
+    if (ttisnil(key)) luaG_runerror(L, "table index is nil");
+    else if (ttisnumber(key) && nvalue(key) != nvalue(key))
+      luaG_runerror(L, "table index is NaN");
+    return newkey(L, t, key);
+  }
+}
+
+
+TObject *luaH_setnum (lua_State *L, Table *t, int key) {
+  const TObject *p = luaH_getnum(t, key);
+  if (p != &luaO_nilobject)
+    return cast(TObject *, p);
+  else {
+    TObject k;
+    setnvalue(&k, cast(lua_Number, key));
+    return newkey(L, t, &k);
+  }
+}
+

Added: trunk/source/libraries/lua/ltable.h
===================================================================
--- trunk/source/libraries/lua/ltable.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ltable.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,31 @@
+/*
+** $Id: ltable.h,v 1.44 2003/03/18 12:50:04 roberto Exp $
+** Lua tables (hash)
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ltable_h
+#define ltable_h
+
+#include "lobject.h"
+
+
+#define gnode(t,i)	(&(t)->node[i])
+#define gkey(n)		(&(n)->i_key)
+#define gval(n)		(&(n)->i_val)
+
+
+const TObject *luaH_getnum (Table *t, int key);
+TObject *luaH_setnum (lua_State *L, Table *t, int key);
+const TObject *luaH_getstr (Table *t, TString *key);
+const TObject *luaH_get (Table *t, const TObject *key);
+TObject *luaH_set (lua_State *L, Table *t, const TObject *key);
+Table *luaH_new (lua_State *L, int narray, int lnhash);
+void luaH_free (lua_State *L, Table *t);
+int luaH_next (lua_State *L, Table *t, StkId key);
+
+/* exported only for debugging */
+Node *luaH_mainposition (const Table *t, const TObject *key);
+
+
+#endif

Added: trunk/source/libraries/lua/ltests.c
===================================================================
--- trunk/source/libraries/lua/ltests.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ltests.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,852 @@
+/*
+** $Id: ltests.c,v 1.158 2003/04/07 14:35:00 roberto Exp $
+** Internal Module for Debugging of the Lua Implementation
+** See Copyright Notice in lua.h
+*/
+
+
+#include <ctype.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define ltests_c
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "lauxlib.h"
+#include "lcode.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lmem.h"
+#include "lopcodes.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "lualib.h"
+
+
+
+/*
+** The whole module only makes sense with LUA_DEBUG on
+*/
+#ifdef LUA_DEBUG
+
+
+#define lua_pushintegral(L,i)	lua_pushnumber(L, cast(lua_Number, (i)))
+
+
+static lua_State *lua_state = NULL;
+
+int islocked = 0;
+
+
+#define func_at(L,k)	(L->ci->base+(k) - 1)
+
+
+static void setnameval (lua_State *L, const char *name, int val) {
+  lua_pushstring(L, name);
+  lua_pushintegral(L, val);
+  lua_settable(L, -3);
+}
+
+
+/*
+** {======================================================================
+** Controlled version for realloc.
+** =======================================================================
+*/
+
+#define MARK		0x55  /* 01010101 (a nice pattern) */
+
+#ifndef EXTERNMEMCHECK
+/* full memory check */
+#define HEADER	(sizeof(L_Umaxalign)) /* ensures maximum alignment for HEADER */
+#define MARKSIZE	16  /* size of marks after each block */
+#define blockhead(b)	(cast(char *, b) - HEADER)
+#define setsize(newblock, size)	(*cast(size_t *, newblock) = size)
+#define checkblocksize(b, size) (size == (*cast(size_t *, blockhead(b))))
+#define fillmem(mem,size)	memset(mem, -MARK, size)
+#else
+/* external memory check: don't do it twice */
+#define HEADER		0
+#define MARKSIZE	0
+#define blockhead(b)	(b)
+#define setsize(newblock, size)	/* empty */
+#define checkblocksize(b,size)	(1)
+#define fillmem(mem,size)	/* empty */
+#endif
+
+unsigned long memdebug_numblocks = 0;
+unsigned long memdebug_total = 0;
+unsigned long memdebug_maxmem = 0;
+unsigned long memdebug_memlimit = ULONG_MAX;
+
+
+static void *checkblock (void *block, size_t size) {
+  void *b = blockhead(block);
+  int i;
+  for (i=0;i<MARKSIZE;i++)
+    lua_assert(*(cast(char *, b)+HEADER+size+i) == MARK+i); /* corrupted block? */
+  return b;
+}
+
+
+static void freeblock (void *block, size_t size) {
+  if (block) {
+    lua_assert(checkblocksize(block, size));
+    block = checkblock(block, size);
+    fillmem(block, size+HEADER+MARKSIZE);  /* erase block */
+    free(block);  /* free original block */
+    memdebug_numblocks--;
+    memdebug_total -= size;
+  }
+}
+
+
+void *debug_realloc (void *block, size_t oldsize, size_t size) {
+  lua_assert(oldsize == 0 || checkblocksize(block, oldsize));
+  /* ISO does not specify what realloc(NULL, 0) does */
+  lua_assert(block != NULL || size > 0);
+  if (size == 0) {
+    freeblock(block, oldsize);
+    return NULL;
+  }
+  else if (size > oldsize && memdebug_total+size-oldsize > memdebug_memlimit)
+    return NULL;  /* to test memory allocation errors */
+  else {
+    void *newblock;
+    int i;
+    size_t realsize = HEADER+size+MARKSIZE;
+    size_t commonsize = (oldsize < size) ? oldsize : size;
+    if (realsize < size) return NULL;  /* overflow! */
+    newblock = malloc(realsize);  /* alloc a new block */
+    if (newblock == NULL) return NULL;
+    if (block) {
+      memcpy(cast(char *, newblock)+HEADER, block, commonsize);
+      freeblock(block, oldsize);  /* erase (and check) old copy */
+    }
+    /* initialize new part of the block with something `weird' */
+    fillmem(cast(char *, newblock)+HEADER+commonsize, size-commonsize);
+    memdebug_total += size;
+    if (memdebug_total > memdebug_maxmem)
+      memdebug_maxmem = memdebug_total;
+    memdebug_numblocks++;
+    setsize(newblock, size);
+    for (i=0;i<MARKSIZE;i++)
+      *(cast(char *, newblock)+HEADER+size+i) = cast(char, MARK+i);
+    return cast(char *, newblock)+HEADER;
+  }
+}
+
+
+/* }====================================================================== */
+
+
+
+/*
+** {======================================================
+** Disassembler
+** =======================================================
+*/
+
+
+static char *buildop (Proto *p, int pc, char *buff) {
+  Instruction i = p->code[pc];
+  OpCode o = GET_OPCODE(i);
+  const char *name = luaP_opnames[o];
+  int line = getline(p, pc);
+  sprintf(buff, "(%4d) %4d - ", line, pc);
+  switch (getOpMode(o)) {  
+    case iABC:
+      sprintf(buff+strlen(buff), "%-12s%4d %4d %4d", name,
+              GETARG_A(i), GETARG_B(i), GETARG_C(i));
+      break;
+    case iABx:
+      sprintf(buff+strlen(buff), "%-12s%4d %4d", name, GETARG_A(i), GETARG_Bx(i));
+      break;
+    case iAsBx:
+      sprintf(buff+strlen(buff), "%-12s%4d %4d", name, GETARG_A(i), GETARG_sBx(i));
+      break;
+  }
+  return buff;
+}
+
+
+#if 0
+void luaI_printcode (Proto *pt, int size) {
+  int pc;
+  for (pc=0; pc<size; pc++) {
+    char buff[100];
+    printf("%s\n", buildop(pt, pc, buff));
+  }
+  printf("-------\n");
+}
+#endif
+
+
+static int listcode (lua_State *L) {
+  int pc;
+  Proto *p;
+  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),
+                 1, "Lua function expected");
+  p = clvalue(func_at(L, 1))->l.p;
+  lua_newtable(L);
+  setnameval(L, "maxstack", p->maxstacksize);
+  setnameval(L, "numparams", p->numparams);
+  for (pc=0; pc<p->sizecode; pc++) {
+    char buff[100];
+    lua_pushintegral(L, pc+1);
+    lua_pushstring(L, buildop(p, pc, buff));
+    lua_settable(L, -3);
+  }
+  return 1;
+}
+
+
+static int listk (lua_State *L) {
+  Proto *p;
+  int i;
+  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),
+                 1, "Lua function expected");
+  p = clvalue(func_at(L, 1))->l.p;
+  lua_newtable(L);
+  for (i=0; i<p->sizek; i++) {
+    lua_pushintegral(L, i+1);
+    luaA_pushobject(L, p->k+i);
+    lua_settable(L, -3);
+  }
+  return 1;
+}
+
+
+static int listlocals (lua_State *L) {
+  Proto *p;
+  int pc = luaL_checkint(L, 2) - 1;
+  int i = 0;
+  const char *name;
+  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),
+                 1, "Lua function expected");
+  p = clvalue(func_at(L, 1))->l.p;
+  while ((name = luaF_getlocalname(p, ++i, pc)) != NULL)
+    lua_pushstring(L, name);
+  return i-1;
+}
+
+/* }====================================================== */
+
+
+
+
+static int get_limits (lua_State *L) {
+  lua_newtable(L);
+  setnameval(L, "BITS_INT", BITS_INT);
+  setnameval(L, "LFPF", LFIELDS_PER_FLUSH);
+  setnameval(L, "MAXVARS", MAXVARS);
+  setnameval(L, "MAXPARAMS", MAXPARAMS);
+  setnameval(L, "MAXSTACK", MAXSTACK);
+  setnameval(L, "MAXUPVALUES", MAXUPVALUES);
+  return 1;
+}
+
+
+static int mem_query (lua_State *L) {
+  if (lua_isnone(L, 1)) {
+    lua_pushintegral(L, memdebug_total);
+    lua_pushintegral(L, memdebug_numblocks);
+    lua_pushintegral(L, memdebug_maxmem);
+    return 3;
+  }
+  else {
+    memdebug_memlimit = luaL_checkint(L, 1);
+    return 0;
+  }
+}
+
+
+static int hash_query (lua_State *L) {
+  if (lua_isnone(L, 2)) {
+    luaL_argcheck(L, lua_type(L, 1) == LUA_TSTRING, 1, "string expected");
+    lua_pushintegral(L, tsvalue(func_at(L, 1))->tsv.hash);
+  }
+  else {
+    TObject *o = func_at(L, 1);
+    Table *t;
+    luaL_checktype(L, 2, LUA_TTABLE);
+    t = hvalue(func_at(L, 2));
+    lua_pushintegral(L, luaH_mainposition(t, o) - t->node);
+  }
+  return 1;
+}
+
+
+static int stacklevel (lua_State *L) {
+  unsigned long a = 0;
+  lua_pushintegral(L, (int)(L->top - L->stack));
+  lua_pushintegral(L, (int)(L->stack_last - L->stack));
+  lua_pushintegral(L, (int)(L->ci - L->base_ci));
+  lua_pushintegral(L, (int)(L->end_ci - L->base_ci));
+  lua_pushintegral(L, (unsigned long)&a);
+  return 5;
+}
+
+
+static int table_query (lua_State *L) {
+  const Table *t;
+  int i = luaL_optint(L, 2, -1);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  t = hvalue(func_at(L, 1));
+  if (i == -1) {
+    lua_pushintegral(L, t->sizearray);
+    lua_pushintegral(L, sizenode(t));
+    lua_pushintegral(L, t->firstfree - t->node);
+  }
+  else if (i < t->sizearray) {
+    lua_pushintegral(L, i);
+    luaA_pushobject(L, &t->array[i]);
+    lua_pushnil(L); 
+  }
+  else if ((i -= t->sizearray) < sizenode(t)) {
+    if (!ttisnil(gval(gnode(t, i))) ||
+        ttisnil(gkey(gnode(t, i))) ||
+        ttisnumber(gkey(gnode(t, i)))) {
+      luaA_pushobject(L, gkey(gnode(t, i)));
+    }
+    else
+      lua_pushstring(L, "<undef>");
+    luaA_pushobject(L, gval(gnode(t, i)));
+    if (t->node[i].next)
+      lua_pushintegral(L, t->node[i].next - t->node);
+    else
+      lua_pushnil(L);
+  }
+  return 3;
+}
+
+
+static int string_query (lua_State *L) {
+  stringtable *tb = &G(L)->strt;
+  int s = luaL_optint(L, 2, 0) - 1;
+  if (s==-1) {
+    lua_pushintegral(L ,tb->nuse);
+    lua_pushintegral(L ,tb->size);
+    return 2;
+  }
+  else if (s < tb->size) {
+    GCObject *ts;
+    int n = 0;
+    for (ts = tb->hash[s]; ts; ts = ts->gch.next) {
+      setsvalue2s(L->top, gcotots(ts));
+      incr_top(L);
+      n++;
+    }
+    return n;
+  }
+  return 0;
+}
+
+
+static int tref (lua_State *L) {
+  int level = lua_gettop(L);
+  int lock = luaL_optint(L, 2, 1);
+  luaL_checkany(L, 1);
+  lua_pushvalue(L, 1);
+  lua_pushintegral(L, lua_ref(L, lock));
+  assert(lua_gettop(L) == level+1);  /* +1 for result */
+  return 1;
+}
+
+static int getref (lua_State *L) {
+  int level = lua_gettop(L);
+  lua_getref(L, luaL_checkint(L, 1));
+  assert(lua_gettop(L) == level+1);
+  return 1;
+}
+
+static int unref (lua_State *L) {
+  int level = lua_gettop(L);
+  lua_unref(L, luaL_checkint(L, 1));
+  assert(lua_gettop(L) == level);
+  return 0;
+}
+
+static int metatable (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (lua_isnone(L, 2)) {
+    if (lua_getmetatable(L, 1) == 0)
+      lua_pushnil(L);
+  }
+  else {
+    lua_settop(L, 2);
+    luaL_checktype(L, 2, LUA_TTABLE);
+    lua_setmetatable(L, 1);
+  }
+  return 1;
+}
+
+
+static int upvalue (lua_State *L) {
+  int n = luaL_checkint(L, 2);
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  if (lua_isnone(L, 3)) {
+    const char *name = lua_getupvalue(L, 1, n);
+    if (name == NULL) return 0;
+    lua_pushstring(L, name);
+    return 2;
+  }
+  else {
+    const char *name = lua_setupvalue(L, 1, n);
+    lua_pushstring(L, name);
+    return 1;
+  }
+}
+
+
+static int newuserdata (lua_State *L) {
+  size_t size = luaL_checkint(L, 1);
+  char *p = cast(char *, lua_newuserdata(L, size));
+  while (size--) *p++ = '\0';
+  return 1;
+}
+
+
+static int pushuserdata (lua_State *L) {
+  lua_pushlightuserdata(L, cast(void *, luaL_checkint(L, 1)));
+  return 1;
+}
+
+
+static int udataval (lua_State *L) {
+  lua_pushintegral(L, cast(int, lua_touserdata(L, 1)));
+  return 1;
+}
+
+
+static int doonnewstack (lua_State *L) {
+  lua_State *L1 = lua_newthread(L);
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &l);
+  int status = luaL_loadbuffer(L1, s, l, s);
+  if (status == 0)
+    status = lua_pcall(L1, 0, 0, 0);
+  lua_pushintegral(L, status);
+  return 1;
+}
+
+
+static int s2d (lua_State *L) {
+  lua_pushnumber(L, *cast(const double *, luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int d2s (lua_State *L) {
+  double d = luaL_checknumber(L, 1);
+  lua_pushlstring(L, cast(char *, &d), sizeof(d));
+  return 1;
+}
+
+
+static int newstate (lua_State *L) {
+  lua_State *L1 = lua_open();
+  if (L1) {
+    lua_userstateopen(L1);  /* init lock */
+    lua_pushintegral(L, (unsigned long)L1);
+  }
+  else
+    lua_pushnil(L);
+  return 1;
+}
+
+
+static int loadlib (lua_State *L) {
+  static const luaL_reg libs[] = {
+    {"mathlibopen", luaopen_math},
+    {"strlibopen", luaopen_string},
+    {"iolibopen", luaopen_io},
+    {"tablibopen", luaopen_table},
+    {"dblibopen", luaopen_debug},
+    {"baselibopen", luaopen_base},
+    {NULL, NULL}
+  };
+  lua_State *L1 = cast(lua_State *,
+                       cast(unsigned long, luaL_checknumber(L, 1)));
+  lua_pushvalue(L1, LUA_GLOBALSINDEX);
+  luaL_openlib(L1, NULL, libs, 0);
+  return 0;
+}
+
+static int closestate (lua_State *L) {
+  lua_State *L1 = cast(lua_State *, cast(unsigned long, luaL_checknumber(L, 1)));
+  lua_close(L1);
+  lua_unlock(L);  /* close cannot unlock that */
+  return 0;
+}
+
+static int doremote (lua_State *L) {
+  lua_State *L1 = cast(lua_State *,cast(unsigned long,luaL_checknumber(L, 1)));
+  size_t lcode;
+  const char *code = luaL_checklstring(L, 2, &lcode);
+  int status;
+  lua_settop(L1, 0);
+  status = luaL_loadbuffer(L1, code, lcode, code);
+  if (status == 0)
+    status = lua_pcall(L1, 0, LUA_MULTRET, 0);
+  if (status != 0) {
+    lua_pushnil(L);
+    lua_pushintegral(L, status);
+    lua_pushstring(L, lua_tostring(L1, -1));
+    return 3;
+  }
+  else {
+    int i = 0;
+    while (!lua_isnone(L1, ++i))
+      lua_pushstring(L, lua_tostring(L1, i));
+    lua_pop(L1, i-1);
+    return i-1;
+  }
+}
+
+
+static int log2_aux (lua_State *L) {
+  lua_pushintegral(L, luaO_log2(luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int int2fb_aux (lua_State *L) {
+  int b = luaO_int2fb(luaL_checkint(L, 1));
+  lua_pushintegral(L, b);
+  lua_pushintegral(L, fb2int(b));
+  return 2;
+}
+
+
+static int test_do (lua_State *L) {
+  const char *p = luaL_checkstring(L, 1);
+  if (*p == '@')
+    lua_dofile(L, p+1);
+  else
+    lua_dostring(L, p);
+  return lua_gettop(L);
+}
+
+
+
+/*
+** {======================================================
+** function to test the API with C. It interprets a kind of assembler
+** language with calls to the API, so the test can be driven by Lua code
+** =======================================================
+*/
+
+static const char *const delimits = " \t\n,;";
+
+static void skip (const char **pc) {
+  while (**pc != '\0' && strchr(delimits, **pc)) (*pc)++;
+}
+
+static int getnum_aux (lua_State *L, const char **pc) {
+  int res = 0;
+  int sig = 1;
+  skip(pc);
+  if (**pc == '.') {
+    res = cast(int, lua_tonumber(L, -1));
+    lua_pop(L, 1);
+    (*pc)++;
+    return res;
+  }
+  else if (**pc == '-') {
+    sig = -1;
+    (*pc)++;
+  }
+  while (isdigit(cast(int, **pc))) res = res*10 + (*(*pc)++) - '0';
+  return sig*res;
+}
+  
+static const char *getname_aux (char *buff, const char **pc) {
+  int i = 0;
+  skip(pc);
+  while (**pc != '\0' && !strchr(delimits, **pc))
+    buff[i++] = *(*pc)++;
+  buff[i] = '\0';
+  return buff;
+}
+
+
+#define EQ(s1)	(strcmp(s1, inst) == 0)
+
+#define getnum	(getnum_aux(L, &pc))
+#define getname	(getname_aux(buff, &pc))
+
+
+static int testC (lua_State *L) {
+  char buff[30];
+  const char *pc = luaL_checkstring(L, 1);
+  for (;;) {
+    const char *inst = getname;
+    if EQ("") return 0;
+    else if EQ("isnumber") {
+      lua_pushintegral(L, lua_isnumber(L, getnum));
+    }
+    else if EQ("isstring") {
+      lua_pushintegral(L, lua_isstring(L, getnum));
+    }
+    else if EQ("istable") {
+      lua_pushintegral(L, lua_istable(L, getnum));
+    }
+    else if EQ("iscfunction") {
+      lua_pushintegral(L, lua_iscfunction(L, getnum));
+    }
+    else if EQ("isfunction") {
+      lua_pushintegral(L, lua_isfunction(L, getnum));
+    }
+    else if EQ("isuserdata") {
+      lua_pushintegral(L, lua_isuserdata(L, getnum));
+    }
+    else if EQ("isudataval") {
+      lua_pushintegral(L, lua_islightuserdata(L, getnum));
+    }
+    else if EQ("isnil") {
+      lua_pushintegral(L, lua_isnil(L, getnum));
+    }
+    else if EQ("isnull") {
+      lua_pushintegral(L, lua_isnone(L, getnum));
+    }
+    else if EQ("tonumber") {
+      lua_pushnumber(L, lua_tonumber(L, getnum));
+    }
+    else if EQ("tostring") {
+      const char *s = lua_tostring(L, getnum);
+      lua_pushstring(L, s);
+    }
+    else if EQ("strlen") {
+      lua_pushintegral(L, lua_strlen(L, getnum));
+    }
+    else if EQ("tocfunction") {
+      lua_pushcfunction(L, lua_tocfunction(L, getnum));
+    }
+    else if EQ("return") {
+      return getnum;
+    }
+    else if EQ("gettop") {
+      lua_pushintegral(L, lua_gettop(L));
+    }
+    else if EQ("settop") {
+      lua_settop(L, getnum);
+    }
+    else if EQ("pop") {
+      lua_pop(L, getnum);
+    }
+    else if EQ("pushnum") {
+      lua_pushintegral(L, getnum);
+    }
+    else if EQ("pushnil") {
+      lua_pushnil(L);
+    }
+    else if EQ("pushbool") {
+      lua_pushboolean(L, getnum);
+    }
+    else if EQ("tobool") {
+      lua_pushintegral(L, lua_toboolean(L, getnum));
+    }
+    else if EQ("pushvalue") {
+      lua_pushvalue(L, getnum);
+    }
+    else if EQ("pushcclosure") {
+      lua_pushcclosure(L, testC, getnum);
+    }
+    else if EQ("pushupvalues") {
+      lua_pushupvalues(L);
+    }
+    else if EQ("remove") {
+      lua_remove(L, getnum);
+    }
+    else if EQ("insert") {
+      lua_insert(L, getnum);
+    }
+    else if EQ("replace") {
+      lua_replace(L, getnum);
+    }
+    else if EQ("gettable") {
+      lua_gettable(L, getnum);
+    }
+    else if EQ("settable") {
+      lua_settable(L, getnum);
+    }
+    else if EQ("next") {
+      lua_next(L, -2);
+    }
+    else if EQ("concat") {
+      lua_concat(L, getnum);
+    }
+    else if EQ("lessthan") {
+      int a = getnum;
+      lua_pushboolean(L, lua_lessthan(L, a, getnum));
+    }
+    else if EQ("equal") {
+      int a = getnum;
+      lua_pushboolean(L, lua_equal(L, a, getnum));
+    }
+    else if EQ("rawcall") {
+      int narg = getnum;
+      int nres = getnum;
+      lua_call(L, narg, nres);
+    }
+    else if EQ("call") {
+      int narg = getnum;
+      int nres = getnum;
+      lua_pcall(L, narg, nres, 0);
+    }
+    else if EQ("loadstring") {
+      size_t sl;
+      const char *s = luaL_checklstring(L, getnum, &sl);
+      luaL_loadbuffer(L, s, sl, s);
+    }
+    else if EQ("loadfile") {
+      luaL_loadfile(L, luaL_checkstring(L, getnum));
+    }
+    else if EQ("setmetatable") {
+      lua_setmetatable(L, getnum);
+    }
+    else if EQ("getmetatable") {
+      if (lua_getmetatable(L, getnum) == 0)
+        lua_pushnil(L);
+    }
+    else if EQ("type") {
+      lua_pushstring(L, lua_typename(L, lua_type(L, getnum)));
+    }
+    else if EQ("getn") {
+      int i = getnum;
+      lua_pushintegral(L, luaL_getn(L, i));
+    }
+    else if EQ("setn") {
+      int i = getnum;
+      int n = cast(int, lua_tonumber(L, -1));
+      luaL_setn(L, i, n);
+      lua_pop(L, 1);
+    }
+    else luaL_error(L, "unknown instruction %s", buff);
+  }
+  return 0;
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** tests for yield inside hooks
+** =======================================================
+*/
+
+static void yieldf (lua_State *L, lua_Debug *ar) {
+  lua_yield(L, 0);
+}
+
+static int setyhook (lua_State *L) {
+  if (lua_isnoneornil(L, 1))
+    lua_sethook(L, NULL, 0, 0);  /* turn off hooks */
+  else {
+    const char *smask = luaL_checkstring(L, 1);
+    int count = luaL_optint(L, 2, 0);
+    int mask = 0;
+    if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
+    if (count > 0) mask |= LUA_MASKCOUNT;
+    lua_sethook(L, yieldf, mask, count);
+  }
+  return 0;
+}
+
+
+static int coresume (lua_State *L) {
+  int status;
+  lua_State *co = lua_tothread(L, 1);
+  luaL_argcheck(L, co, 1, "coroutine expected");
+  status = lua_resume(co, 0);
+  if (status != 0) {
+    lua_pushboolean(L, 0);
+    lua_insert(L, -2);
+    return 2;  /* return false + error message */
+  }
+  else {
+    lua_pushboolean(L, 1);
+    return 1;
+  }
+}
+
+/* }====================================================== */
+
+
+
+static const struct luaL_reg tests_funcs[] = {
+  {"hash", hash_query},
+  {"limits", get_limits},
+  {"listcode", listcode},
+  {"listk", listk},
+  {"listlocals", listlocals},
+  {"loadlib", loadlib},
+  {"stacklevel", stacklevel},
+  {"querystr", string_query},
+  {"querytab", table_query},
+  {"doit", test_do},
+  {"testC", testC},
+  {"ref", tref},
+  {"getref", getref},
+  {"unref", unref},
+  {"d2s", d2s},
+  {"s2d", s2d},
+  {"metatable", metatable},
+  {"upvalue", upvalue},
+  {"newuserdata", newuserdata},
+  {"pushuserdata", pushuserdata},
+  {"udataval", udataval},
+  {"doonnewstack", doonnewstack},
+  {"newstate", newstate},
+  {"closestate", closestate},
+  {"doremote", doremote},
+  {"log2", log2_aux},
+  {"int2fb", int2fb_aux},
+  {"totalmem", mem_query},
+  {"resume", coresume},
+  {"setyhook", setyhook},
+  {NULL, NULL}
+};
+
+
+static void fim (void) {
+  if (!islocked)
+    lua_close(lua_state);
+  lua_assert(memdebug_numblocks == 0);
+  lua_assert(memdebug_total == 0);
+}
+
+
+static int l_panic (lua_State *L) {
+  UNUSED(L);
+  fprintf(stderr, "unable to recover; exiting\n");
+  return 0;
+}
+
+
+int luaB_opentests (lua_State *L) {
+  lua_atpanic(L, l_panic);
+  lua_userstateopen(L);  /* init lock */
+  lua_state = L;  /* keep first state to be opened */
+  luaL_openlib(L, "T", tests_funcs, 0);
+  atexit(fim);
+  return 0;
+}
+
+
+#undef main
+int main (int argc, char *argv[]) {
+  char *limit = getenv("MEMLIMIT");
+  if (limit)
+    memdebug_memlimit = strtoul(limit, NULL, 10);
+  l_main(argc, argv);
+  return 0;
+}
+
+#endif

Added: trunk/source/libraries/lua/ltm.c
===================================================================
--- trunk/source/libraries/lua/ltm.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ltm.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,70 @@
+/*
+** $Id: ltm.c,v 1.106 2003/04/03 13:35:34 roberto Exp $
+** Tag methods
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define ltm_c
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+
+
+
+const char *const luaT_typenames[] = {
+  "nil", "boolean", "userdata", "number",
+  "string", "table", "function", "userdata", "thread"
+};
+
+
+void luaT_init (lua_State *L) {
+  static const char *const luaT_eventname[] = {  /* ORDER TM */
+    "__index", "__newindex",
+    "__gc", "__mode", "__eq",
+    "__add", "__sub", "__mul", "__div",
+    "__pow", "__unm", "__lt", "__le",
+    "__concat", "__call"
+  };
+  int i;
+  for (i=0; i<TM_N; i++) {
+    G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);
+    luaS_fix(G(L)->tmname[i]);  /* never collect these names */
+  }
+}
+
+
+/*
+** function to be used with macro "fasttm": optimized for absence of
+** tag methods
+*/
+const TObject *luaT_gettm (Table *events, TMS event, TString *ename) {
+  const TObject *tm = luaH_getstr(events, ename);
+  lua_assert(event <= TM_EQ);
+  if (ttisnil(tm)) {  /* no tag method? */
+    events->flags |= cast(lu_byte, 1u<<event);  /* cache this fact */
+    return NULL;
+  }
+  else return tm;
+}
+
+
+const TObject *luaT_gettmbyobj (lua_State *L, const TObject *o, TMS event) {
+  TString *ename = G(L)->tmname[event];
+  switch (ttype(o)) {
+    case LUA_TTABLE:
+      return luaH_getstr(hvalue(o)->metatable, ename);
+    case LUA_TUSERDATA:
+      return luaH_getstr(uvalue(o)->uv.metatable, ename);
+    default:
+      return &luaO_nilobject;
+  }
+}
+

Added: trunk/source/libraries/lua/ltm.h
===================================================================
--- trunk/source/libraries/lua/ltm.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ltm.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,51 @@
+/*
+** $Id: ltm.h,v 1.41 2002/11/14 11:51:50 roberto Exp $
+** Tag methods
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ltm_h
+#define ltm_h
+
+
+#include "lobject.h"
+
+
+/*
+* WARNING: if you change the order of this enumeration,
+* grep "ORDER TM"
+*/
+typedef enum {
+  TM_INDEX,
+  TM_NEWINDEX,
+  TM_GC,
+  TM_MODE,
+  TM_EQ,  /* last tag method with `fast' access */
+  TM_ADD,
+  TM_SUB,
+  TM_MUL,
+  TM_DIV,
+  TM_POW,
+  TM_UNM,
+  TM_LT,
+  TM_LE,
+  TM_CONCAT,
+  TM_CALL,
+  TM_N		/* number of elements in the enum */
+} TMS;
+
+
+
+#define gfasttm(g,et,e) \
+  (((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
+
+#define fasttm(l,et,e)	gfasttm(G(l), et, e)
+
+
+const TObject *luaT_gettm (Table *events, TMS event, TString *ename);
+const TObject *luaT_gettmbyobj (lua_State *L, const TObject *o, TMS event);
+void luaT_init (lua_State *L);
+
+extern const char *const luaT_typenames[];
+
+#endif

Added: trunk/source/libraries/lua/lua.h
===================================================================
--- trunk/source/libraries/lua/lua.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lua.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,391 @@
+/*
+** $Id: lua.h,v 1.175 2003/03/18 12:31:39 roberto Exp $
+** Lua - An Extensible Extension Language
+** Tecgraf: Computer Graphics Technology Group, PUC-Rio, Brazil
+** http://www.lua.org	mailto:info at lua.org
+** See Copyright Notice at the end of this file
+*/
+
+
+#ifndef lua_h
+#define lua_h
+
+#include <stdarg.h>
+#include <stddef.h>
+
+
+#define LUA_VERSION	"Lua 5.0"
+#define LUA_COPYRIGHT	"Copyright (C) 1994-2003 Tecgraf, PUC-Rio"
+#define LUA_AUTHORS 	"R. Ierusalimschy, L. H. de Figueiredo & W. Celes"
+
+
+
+/* option for multiple returns in `lua_pcall' and `lua_call' */
+#define LUA_MULTRET	(-1)
+
+
+/*
+** pseudo-indices
+*/
+#define LUA_REGISTRYINDEX	(-10000)
+#define LUA_GLOBALSINDEX	(-10001)
+#define lua_upvalueindex(i)	(LUA_GLOBALSINDEX-(i))
+
+
+/* error codes for `lua_load' and `lua_pcall' */
+#define LUA_ERRRUN	1
+#define LUA_ERRFILE	2
+#define LUA_ERRSYNTAX	3
+#define LUA_ERRMEM	4
+#define LUA_ERRERR	5
+
+
+typedef struct lua_State lua_State;
+
+typedef int (*lua_CFunction) (lua_State *L);
+
+
+/*
+** functions that read/write blocks when loading/dumping Lua chunks
+*/
+typedef const char * (*lua_Chunkreader) (lua_State *L, void *ud, size_t *sz);
+
+typedef int (*lua_Chunkwriter) (lua_State *L, const void* p,
+                                size_t sz, void* ud);
+
+
+/*
+** basic types
+*/
+#define LUA_TNONE	(-1)
+
+#define LUA_TNIL	0
+#define LUA_TBOOLEAN	1
+#define LUA_TLIGHTUSERDATA	2
+#define LUA_TNUMBER	3
+#define LUA_TSTRING	4
+#define LUA_TTABLE	5
+#define LUA_TFUNCTION	6
+#define LUA_TUSERDATA	7
+#define LUA_TTHREAD	8
+
+
+/* minimum Lua stack available to a C function */
+#define LUA_MINSTACK	20
+
+
+/*
+** generic extra include file
+*/
+#ifdef LUA_USER_H
+#include LUA_USER_H
+#endif
+
+
+/* type of numbers in Lua */
+#ifndef LUA_NUMBER
+typedef double lua_Number;
+#else
+typedef LUA_NUMBER lua_Number;
+#endif
+
+
+/* mark for all API functions */
+#ifndef LUA_API
+#define LUA_API		extern
+#endif
+
+
+/*
+** state manipulation
+*/
+LUA_API lua_State *lua_open (void);
+LUA_API void       lua_close (lua_State *L);
+LUA_API lua_State *lua_newthread (lua_State *L);
+
+LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);
+
+
+/*
+** basic stack manipulation
+*/
+LUA_API int   lua_gettop (lua_State *L);
+LUA_API void  lua_settop (lua_State *L, int idx);
+LUA_API void  lua_pushvalue (lua_State *L, int idx);
+LUA_API void  lua_remove (lua_State *L, int idx);
+LUA_API void  lua_insert (lua_State *L, int idx);
+LUA_API void  lua_replace (lua_State *L, int idx);
+LUA_API int   lua_checkstack (lua_State *L, int sz);
+
+LUA_API void  lua_xmove (lua_State *from, lua_State *to, int n);
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API int             lua_isnumber (lua_State *L, int idx);
+LUA_API int             lua_isstring (lua_State *L, int idx);
+LUA_API int             lua_iscfunction (lua_State *L, int idx);
+LUA_API int             lua_isuserdata (lua_State *L, int idx);
+LUA_API int             lua_type (lua_State *L, int idx);
+LUA_API const char     *lua_typename (lua_State *L, int tp);
+
+LUA_API int            lua_equal (lua_State *L, int idx1, int idx2);
+LUA_API int            lua_rawequal (lua_State *L, int idx1, int idx2);
+LUA_API int            lua_lessthan (lua_State *L, int idx1, int idx2);
+
+LUA_API lua_Number      lua_tonumber (lua_State *L, int idx);
+LUA_API int             lua_toboolean (lua_State *L, int idx);
+LUA_API const char     *lua_tostring (lua_State *L, int idx);
+LUA_API size_t          lua_strlen (lua_State *L, int idx);
+LUA_API lua_CFunction   lua_tocfunction (lua_State *L, int idx);
+LUA_API void	       *lua_touserdata (lua_State *L, int idx);
+LUA_API lua_State      *lua_tothread (lua_State *L, int idx);
+LUA_API const void     *lua_topointer (lua_State *L, int idx);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void  lua_pushnil (lua_State *L);
+LUA_API void  lua_pushnumber (lua_State *L, lua_Number n);
+LUA_API void  lua_pushlstring (lua_State *L, const char *s, size_t l);
+LUA_API void  lua_pushstring (lua_State *L, const char *s);
+LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
+                                                    va_list argp);
+LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...);
+LUA_API void  lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);
+LUA_API void  lua_pushboolean (lua_State *L, int b);
+LUA_API void  lua_pushlightuserdata (lua_State *L, void *p);
+
+
+/*
+** get functions (Lua -> stack)
+*/
+LUA_API void  lua_gettable (lua_State *L, int idx);
+LUA_API void  lua_rawget (lua_State *L, int idx);
+LUA_API void  lua_rawgeti (lua_State *L, int idx, int n);
+LUA_API void  lua_newtable (lua_State *L);
+LUA_API void *lua_newuserdata (lua_State *L, size_t sz);
+LUA_API int   lua_getmetatable (lua_State *L, int objindex);
+LUA_API void  lua_getfenv (lua_State *L, int idx);
+
+
+/*
+** set functions (stack -> Lua)
+*/
+LUA_API void  lua_settable (lua_State *L, int idx);
+LUA_API void  lua_rawset (lua_State *L, int idx);
+LUA_API void  lua_rawseti (lua_State *L, int idx, int n);
+LUA_API int   lua_setmetatable (lua_State *L, int objindex);
+LUA_API int   lua_setfenv (lua_State *L, int idx);
+
+
+/*
+** `load' and `call' functions (load and run Lua code)
+*/
+LUA_API void  lua_call (lua_State *L, int nargs, int nresults);
+LUA_API int   lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);
+LUA_API int lua_cpcall (lua_State *L, lua_CFunction func, void *ud);
+LUA_API int   lua_load (lua_State *L, lua_Chunkreader reader, void *dt,
+                        const char *chunkname);
+
+LUA_API int lua_dump (lua_State *L, lua_Chunkwriter writer, void *data);
+
+
+/*
+** coroutine functions
+*/
+LUA_API int  lua_yield (lua_State *L, int nresults);
+LUA_API int  lua_resume (lua_State *L, int narg);
+
+/*
+** garbage-collection functions
+*/
+LUA_API int   lua_getgcthreshold (lua_State *L);
+LUA_API int   lua_getgccount (lua_State *L);
+LUA_API void  lua_setgcthreshold (lua_State *L, int newthreshold);
+
+/*
+** miscellaneous functions
+*/
+
+LUA_API const char *lua_version (void);
+
+LUA_API int   lua_error (lua_State *L);
+
+LUA_API int   lua_next (lua_State *L, int idx);
+
+LUA_API void  lua_concat (lua_State *L, int n);
+
+
+
+/* 
+** ===============================================================
+** some useful macros
+** ===============================================================
+*/
+
+#define lua_boxpointer(L,u) \
+	(*(void **)(lua_newuserdata(L, sizeof(void *))) = (u))
+
+#define lua_unboxpointer(L,i)	(*(void **)(lua_touserdata(L, i)))
+
+#define lua_pop(L,n)		lua_settop(L, -(n)-1)
+
+#define lua_register(L,n,f) \
+	(lua_pushstring(L, n), \
+	 lua_pushcfunction(L, f), \
+	 lua_settable(L, LUA_GLOBALSINDEX))
+
+#define lua_pushcfunction(L,f)	lua_pushcclosure(L, f, 0)
+
+#define lua_isfunction(L,n)	(lua_type(L,n) == LUA_TFUNCTION)
+#define lua_istable(L,n)	(lua_type(L,n) == LUA_TTABLE)
+#define lua_islightuserdata(L,n)	(lua_type(L,n) == LUA_TLIGHTUSERDATA)
+#define lua_isnil(L,n)		(lua_type(L,n) == LUA_TNIL)
+#define lua_isboolean(L,n)	(lua_type(L,n) == LUA_TBOOLEAN)
+#define lua_isnone(L,n)		(lua_type(L,n) == LUA_TNONE)
+#define lua_isnoneornil(L, n)	(lua_type(L,n) <= 0)
+
+#define lua_pushliteral(L, s)	\
+	lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
+
+
+
+/*
+** compatibility macros and functions
+*/
+
+
+LUA_API int lua_pushupvalues (lua_State *L);
+
+#define lua_getregistry(L)	lua_pushvalue(L, LUA_REGISTRYINDEX)
+#define lua_setglobal(L,s)	\
+   (lua_pushstring(L, s), lua_insert(L, -2), lua_settable(L, LUA_GLOBALSINDEX))
+
+#define lua_getglobal(L,s)	\
+		(lua_pushstring(L, s), lua_gettable(L, LUA_GLOBALSINDEX))
+
+
+/* compatibility with ref system */
+
+/* pre-defined references */
+#define LUA_NOREF	(-2)
+#define LUA_REFNIL	(-1)
+
+#define lua_ref(L,lock)	((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : \
+      (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))
+
+#define lua_unref(L,ref)	luaL_unref(L, LUA_REGISTRYINDEX, (ref))
+
+#define lua_getref(L,ref)	lua_rawgeti(L, LUA_REGISTRYINDEX, ref)
+
+
+
+/*
+** {======================================================================
+** useful definitions for Lua kernel and libraries
+** =======================================================================
+*/
+
+/* formats for Lua numbers */
+#ifndef LUA_NUMBER_SCAN
+#define LUA_NUMBER_SCAN		"%lf"
+#endif
+
+#ifndef LUA_NUMBER_FMT
+#define LUA_NUMBER_FMT		"%.14g"
+#endif
+
+/* }====================================================================== */
+
+
+/*
+** {======================================================================
+** Debug API
+** =======================================================================
+*/
+
+
+/*
+** Event codes
+*/
+#define LUA_HOOKCALL	0
+#define LUA_HOOKRET	1
+#define LUA_HOOKLINE	2
+#define LUA_HOOKCOUNT	3
+#define LUA_HOOKTAILRET 4
+
+
+/*
+** Event masks
+*/
+#define LUA_MASKCALL	(1 << LUA_HOOKCALL)
+#define LUA_MASKRET	(1 << LUA_HOOKRET)
+#define LUA_MASKLINE	(1 << LUA_HOOKLINE)
+#define LUA_MASKCOUNT	(1 << LUA_HOOKCOUNT)
+
+typedef struct lua_Debug lua_Debug;  /* activation record */
+
+typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);
+
+
+LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar);
+LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);
+LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);
+LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);
+LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n);
+LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n);
+
+LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count);
+LUA_API lua_Hook lua_gethook (lua_State *L);
+LUA_API int lua_gethookmask (lua_State *L);
+LUA_API int lua_gethookcount (lua_State *L);
+
+
+#define LUA_IDSIZE	60
+
+struct lua_Debug {
+  int event;
+  const char *name;	/* (n) */
+  const char *namewhat;	/* (n) `global', `local', `field', `method' */
+  const char *what;	/* (S) `Lua', `C', `main', `tail' */
+  const char *source;	/* (S) */
+  int currentline;	/* (l) */
+  int nups;		/* (u) number of upvalues */
+  int linedefined;	/* (S) */
+  char short_src[LUA_IDSIZE]; /* (S) */
+  /* private part */
+  int i_ci;  /* active function */
+};
+
+/* }====================================================================== */
+
+
+/******************************************************************************
+* Copyright (C) 1994-2003 Tecgraf, PUC-Rio.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining
+* a copy of this software and associated documentation files (the
+* "Software"), to deal in the Software without restriction, including
+* without limitation the rights to use, copy, modify, merge, publish,
+* distribute, sublicense, and/or sell copies of the Software, and to
+* permit persons to whom the Software is furnished to do so, subject to
+* the following conditions:
+*
+* The above copyright notice and this permission notice shall be
+* included in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+******************************************************************************/
+
+
+#endif

Added: trunk/source/libraries/lua/lualib.h
===================================================================
--- trunk/source/libraries/lua/lualib.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lualib.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,56 @@
+/*
+** $Id: lualib.h,v 1.28 2003/03/18 12:24:26 roberto Exp $
+** Lua standard libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lualib_h
+#define lualib_h
+
+#include "lua.h"
+
+
+#ifndef LUALIB_API
+#define LUALIB_API	LUA_API
+#endif
+
+
+#define LUA_COLIBNAME	"coroutine"
+LUALIB_API int luaopen_base (lua_State *L);
+
+#define LUA_TABLIBNAME	"table"
+LUALIB_API int luaopen_table (lua_State *L);
+
+#define LUA_IOLIBNAME	"io"
+#define LUA_OSLIBNAME	"os"
+LUALIB_API int luaopen_io (lua_State *L);
+
+#define LUA_STRLIBNAME	"string"
+LUALIB_API int luaopen_string (lua_State *L);
+
+#define LUA_MATHLIBNAME	"math"
+LUALIB_API int luaopen_math (lua_State *L);
+
+#define LUA_DBLIBNAME	"debug"
+LUALIB_API int luaopen_debug (lua_State *L);
+
+
+LUALIB_API int luaopen_loadlib (lua_State *L);
+
+
+/* to help testing the libraries */
+#ifndef lua_assert
+#define lua_assert(c)		/* empty */
+#endif
+
+
+/* compatibility code */
+#define lua_baselibopen	luaopen_base
+#define lua_tablibopen	luaopen_table
+#define lua_iolibopen	luaopen_io
+#define lua_strlibopen	luaopen_string
+#define lua_mathlibopen	luaopen_math
+#define lua_dblibopen	luaopen_debug
+
+#endif

Added: trunk/source/libraries/lua/lundump.c
===================================================================
--- trunk/source/libraries/lua/lundump.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lundump.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,286 @@
+/*
+** $Id: lundump.c,v 1.49 2003/04/07 20:34:20 lhf Exp $
+** load pre-compiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#define lundump_c
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "lfunc.h"
+#include "lmem.h"
+#include "lopcodes.h"
+#include "lstring.h"
+#include "lundump.h"
+#include "lzio.h"
+
+#define	LoadByte	(lu_byte) ezgetc
+
+typedef struct {
+ lua_State* L;
+ ZIO* Z;
+ Mbuffer* b;
+ int swap;
+ const char* name;
+} LoadState;
+
+static void unexpectedEOZ (LoadState* S)
+{
+ luaG_runerror(S->L,"unexpected end of file in %s",S->name);
+}
+
+static int ezgetc (LoadState* S)
+{
+ int c=zgetc(S->Z);
+ if (c==EOZ) unexpectedEOZ(S);
+ return c;
+}
+
+static void ezread (LoadState* S, void* b, int n)
+{
+ int r=luaZ_read(S->Z,b,n);
+ if (r!=0) unexpectedEOZ(S);
+}
+
+static void LoadBlock (LoadState* S, void* b, size_t size)
+{
+ if (S->swap)
+ {
+  char* p=(char*) b+size-1;
+  int n=size;
+  while (n--) *p--=(char)ezgetc(S);
+ }
+ else
+  ezread(S,b,size);
+}
+
+static void LoadVector (LoadState* S, void* b, int m, size_t size)
+{
+ if (S->swap)
+ {
+  char* q=(char*) b;
+  while (m--)
+  {
+   char* p=q+size-1;
+   int n=size;
+   while (n--) *p--=(char)ezgetc(S);
+   q+=size;
+  }
+ }
+ else
+  ezread(S,b,m*size);
+}
+
+static int LoadInt (LoadState* S)
+{
+ int x;
+ LoadBlock(S,&x,sizeof(x));
+ if (x<0) luaG_runerror(S->L,"bad integer in %s",S->name);
+ return x;
+}
+
+static size_t LoadSize (LoadState* S)
+{
+ size_t x;
+ LoadBlock(S,&x,sizeof(x));
+ return x;
+}
+
+static lua_Number LoadNumber (LoadState* S)
+{
+ lua_Number x;
+ LoadBlock(S,&x,sizeof(x));
+ return x;
+}
+
+static TString* LoadString (LoadState* S)
+{
+ size_t size=LoadSize(S);
+ if (size==0)
+  return NULL;
+ else
+ {
+  char* s=luaZ_openspace(S->L,S->b,size);
+  ezread(S,s,size);
+  return luaS_newlstr(S->L,s,size-1);		/* remove trailing '\0' */
+ }
+}
+
+static void LoadCode (LoadState* S, Proto* f)
+{
+ int size=LoadInt(S);
+ f->code=luaM_newvector(S->L,size,Instruction);
+ f->sizecode=size;
+ LoadVector(S,f->code,size,sizeof(*f->code));
+}
+
+static void LoadLocals (LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ f->locvars=luaM_newvector(S->L,n,LocVar);
+ f->sizelocvars=n;
+ for (i=0; i<n; i++)
+ {
+  f->locvars[i].varname=LoadString(S);
+  f->locvars[i].startpc=LoadInt(S);
+  f->locvars[i].endpc=LoadInt(S);
+ }
+}
+
+static void LoadLines (LoadState* S, Proto* f)
+{
+ int size=LoadInt(S);
+ f->lineinfo=luaM_newvector(S->L,size,int);
+ f->sizelineinfo=size;
+ LoadVector(S,f->lineinfo,size,sizeof(*f->lineinfo));
+}
+
+static void LoadUpvalues (LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ if (n!=0 && n!=f->nups) 
+  luaG_runerror(S->L,"bad nupvalues in %s: read %d; expected %d",
+		S->name,n,f->nups);
+ f->upvalues=luaM_newvector(S->L,n,TString*);
+ f->sizeupvalues=n;
+ for (i=0; i<n; i++) f->upvalues[i]=LoadString(S);
+}
+
+static Proto* LoadFunction (LoadState* S, TString* p);
+
+static void LoadConstants (LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ f->k=luaM_newvector(S->L,n,TObject);
+ f->sizek=n;
+ for (i=0; i<n; i++)
+ {
+  TObject* o=&f->k[i];
+  int t=LoadByte(S);
+  switch (t)
+  {
+   case LUA_TNUMBER:
+	setnvalue(o,LoadNumber(S));
+	break;
+   case LUA_TSTRING:
+	setsvalue2n(o,LoadString(S));
+	break;
+   case LUA_TNIL:
+   	setnilvalue(o);
+	break;
+   default:
+	luaG_runerror(S->L,"bad constant type (%d) in %s",t,S->name);
+	break;
+  }
+ }
+ n=LoadInt(S);
+ f->p=luaM_newvector(S->L,n,Proto*);
+ f->sizep=n;
+ for (i=0; i<n; i++) f->p[i]=LoadFunction(S,f->source);
+}
+
+static Proto* LoadFunction (LoadState* S, TString* p)
+{
+ Proto* f=luaF_newproto(S->L);
+ f->source=LoadString(S); if (f->source==NULL) f->source=p;
+ f->lineDefined=LoadInt(S);
+ f->nups=LoadByte(S);
+ f->numparams=LoadByte(S);
+ f->is_vararg=LoadByte(S);
+ f->maxstacksize=LoadByte(S);
+ LoadLines(S,f);
+ LoadLocals(S,f);
+ LoadUpvalues(S,f);
+ LoadConstants(S,f);
+ LoadCode(S,f);
+#ifndef TRUST_BINARIES
+ if (!luaG_checkcode(f)) luaG_runerror(S->L,"bad code in %s",S->name);
+#endif
+ return f;
+}
+
+static void LoadSignature (LoadState* S)
+{
+ const char* s=LUA_SIGNATURE;
+ while (*s!=0 && ezgetc(S)==*s)
+  ++s;
+ if (*s!=0) luaG_runerror(S->L,"bad signature in %s",S->name);
+}
+
+static void TestSize (LoadState* S, int s, const char* what)
+{
+ int r=LoadByte(S);
+ if (r!=s)
+  luaG_runerror(S->L,"virtual machine mismatch in %s: "
+	"size of %s is %d but read %d",S->name,what,s,r);
+}
+
+#define TESTSIZE(s,w)	TestSize(S,s,w)
+#define V(v)		v/16,v%16
+
+static void LoadHeader (LoadState* S)
+{
+ int version;
+ lua_Number x,tx=TEST_NUMBER;
+ LoadSignature(S);
+ version=LoadByte(S);
+ if (version>VERSION)
+  luaG_runerror(S->L,"%s too new: "
+	"read version %d.%d; expected at most %d.%d",
+	S->name,V(version),V(VERSION));
+ if (version<VERSION0)				/* check last major change */
+  luaG_runerror(S->L,"%s too old: "
+	"read version %d.%d; expected at least %d.%d",
+	S->name,V(version),V(VERSION0));
+ S->swap=(luaU_endianness()!=LoadByte(S));	/* need to swap bytes? */
+ TESTSIZE(sizeof(int),"int");
+ TESTSIZE(sizeof(size_t), "size_t");
+ TESTSIZE(sizeof(Instruction), "Instruction");
+ TESTSIZE(SIZE_OP, "OP");
+ TESTSIZE(SIZE_A, "A");
+ TESTSIZE(SIZE_B, "B");
+ TESTSIZE(SIZE_C, "C");
+ TESTSIZE(sizeof(lua_Number), "number");
+ x=LoadNumber(S);
+ if ((long)x!=(long)tx)		/* disregard errors in last bits of fraction */
+  luaG_runerror(S->L,"unknown number format in %s",S->name);
+}
+
+static Proto* LoadChunk (LoadState* S)
+{
+ LoadHeader(S);
+ return LoadFunction(S,NULL);
+}
+
+/*
+** load precompiled chunk
+*/
+Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff)
+{
+ LoadState S;
+ const char* s=zname(Z);
+ if (*s=='@' || *s=='=')
+  S.name=s+1;
+ else if (*s==LUA_SIGNATURE[0])
+  S.name="binary string";
+ else
+  S.name=s;
+ S.L=L;
+ S.Z=Z;
+ S.b=buff;
+ return LoadChunk(&S);
+}
+
+/*
+** find byte order
+*/
+int luaU_endianness (void)
+{
+ int x=1;
+ return *(char*)&x;
+}

Added: trunk/source/libraries/lua/lundump.h
===================================================================
--- trunk/source/libraries/lua/lundump.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lundump.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,34 @@
+/*
+** $Id: lundump.h,v 1.30 2003/04/07 20:34:20 lhf Exp $
+** load pre-compiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lundump_h
+#define lundump_h
+
+#include "lobject.h"
+#include "lzio.h"
+
+/* load one chunk; from lundump.c */
+Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff);
+
+/* find byte order; from lundump.c */
+int luaU_endianness (void);
+
+/* dump one chunk; from ldump.c */
+void luaU_dump (lua_State* L, const Proto* Main, lua_Chunkwriter w, void* data);
+
+/* print one chunk; from print.c */
+void luaU_print (const Proto* Main);
+
+/* definitions for headers of binary files */
+#define	LUA_SIGNATURE	"\033Lua"	/* binary files start with "<esc>Lua" */
+#define	VERSION		0x50		/* last format change was in 5.0 */
+#define	VERSION0	0x50		/* last major  change was in 5.0 */
+
+/* a multiple of PI for testing native format */
+/* multiplying by 1E7 gives non-trivial integer values */
+#define	TEST_NUMBER	((lua_Number)3.14159265358979323846E7)
+
+#endif

Added: trunk/source/libraries/lua/lvm.c
===================================================================
--- trunk/source/libraries/lua/lvm.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lvm.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,780 @@
+/*
+** $Id: lvm.c,v 1.284 2003/04/03 13:35:34 roberto Exp $
+** Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+
+/* needed only when `lua_number2str' uses `sprintf' */
+#include <stdio.h>
+
+#define lvm_c
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lvm.h"
+
+
+
+/* function to convert a lua_Number to a string */
+#ifndef lua_number2str
+#define lua_number2str(s,n)     sprintf((s), LUA_NUMBER_FMT, (n))
+#endif
+
+
+/* limit for table tag-method chains (to avoid loops) */
+#define MAXTAGLOOP	100
+
+
+const TObject *luaV_tonumber (const TObject *obj, TObject *n) {
+  lua_Number num;
+  if (ttisnumber(obj)) return obj;
+  if (ttisstring(obj) && luaO_str2d(svalue(obj), &num)) {
+    setnvalue(n, num);
+    return n;
+  }
+  else
+    return NULL;
+}
+
+
+int luaV_tostring (lua_State *L, StkId obj) {
+  if (!ttisnumber(obj))
+    return 0;
+  else {
+    char s[32];  /* 16 digits, sign, point and \0  (+ some extra...) */
+    lua_number2str(s, nvalue(obj));
+    setsvalue2s(obj, luaS_new(L, s));
+    return 1;
+  }
+}
+
+
+static void traceexec (lua_State *L) {
+  lu_byte mask = L->hookmask;
+  if (mask > LUA_MASKLINE) {  /* instruction-hook set? */
+    if (L->hookcount == 0) {
+      resethookcount(L);
+      luaD_callhook(L, LUA_HOOKCOUNT, -1);
+      return;
+    }
+  }
+  if (mask & LUA_MASKLINE) {
+    CallInfo *ci = L->ci;
+    Proto *p = ci_func(ci)->l.p;
+    int newline = getline(p, pcRel(*ci->u.l.pc, p));
+    if (!L->hookinit) {
+      luaG_inithooks(L);
+      return;
+    }
+    lua_assert(ci->state & CI_HASFRAME);
+    if (pcRel(*ci->u.l.pc, p) == 0)  /* tracing may be starting now? */
+      ci->u.l.savedpc = *ci->u.l.pc;  /* initialize `savedpc' */
+    /* calls linehook when enters a new line or jumps back (loop) */
+    if (*ci->u.l.pc <= ci->u.l.savedpc ||
+        newline != getline(p, pcRel(ci->u.l.savedpc, p))) {
+      luaD_callhook(L, LUA_HOOKLINE, newline);
+      ci = L->ci;  /* previous call may reallocate `ci' */
+    }
+    ci->u.l.savedpc = *ci->u.l.pc;
+  }
+}
+
+
+static void callTMres (lua_State *L, const TObject *f,
+                       const TObject *p1, const TObject *p2) {
+  setobj2s(L->top, f);  /* push function */
+  setobj2s(L->top+1, p1);  /* 1st argument */
+  setobj2s(L->top+2, p2);  /* 2nd argument */
+  luaD_checkstack(L, 3);  /* cannot check before (could invalidate p1, p2) */
+  L->top += 3;
+  luaD_call(L, L->top - 3, 1);
+  L->top--;  /* result will be in L->top */
+}
+
+
+
+static void callTM (lua_State *L, const TObject *f,
+                    const TObject *p1, const TObject *p2, const TObject *p3) {
+  setobj2s(L->top, f);  /* push function */
+  setobj2s(L->top+1, p1);  /* 1st argument */
+  setobj2s(L->top+2, p2);  /* 2nd argument */
+  setobj2s(L->top+3, p3);  /* 3th argument */
+  luaD_checkstack(L, 4);  /* cannot check before (could invalidate p1...p3) */
+  L->top += 4;
+  luaD_call(L, L->top - 4, 0);
+}
+
+
+static const TObject *luaV_index (lua_State *L, const TObject *t,
+                                  TObject *key, int loop) {
+  const TObject *tm = fasttm(L, hvalue(t)->metatable, TM_INDEX);
+  if (tm == NULL) return &luaO_nilobject;  /* no TM */
+  if (ttisfunction(tm)) {
+    callTMres(L, tm, t, key);
+    return L->top;
+  }
+  else return luaV_gettable(L, tm, key, loop);
+}
+
+static const TObject *luaV_getnotable (lua_State *L, const TObject *t,
+                                       TObject *key, int loop) {
+  const TObject *tm = luaT_gettmbyobj(L, t, TM_INDEX);
+  if (ttisnil(tm))
+    luaG_typeerror(L, t, "index");
+  if (ttisfunction(tm)) {
+    callTMres(L, tm, t, key);
+    return L->top;
+  }
+  else return luaV_gettable(L, tm, key, loop);
+}
+
+
+/*
+** Function to index a table.
+** Receives the table at `t' and the key at `key'.
+** leaves the result at `res'.
+*/
+const TObject *luaV_gettable (lua_State *L, const TObject *t, TObject *key,
+                              int loop) {
+  if (loop > MAXTAGLOOP)
+    luaG_runerror(L, "loop in gettable");
+  if (ttistable(t)) {  /* `t' is a table? */
+    Table *h = hvalue(t);
+    const TObject *v = luaH_get(h, key);  /* do a primitive get */
+    if (!ttisnil(v)) return v;
+    else return luaV_index(L, t, key, loop+1);
+  }
+  else return luaV_getnotable(L, t, key, loop+1);
+}
+
+
+/*
+** Receives table at `t', key at `key' and value at `val'.
+*/
+void luaV_settable (lua_State *L, const TObject *t, TObject *key, StkId val) {
+  const TObject *tm;
+  int loop = 0;
+  do {
+    if (ttistable(t)) {  /* `t' is a table? */
+      Table *h = hvalue(t);
+      TObject *oldval = luaH_set(L, h, key); /* do a primitive set */
+      if (!ttisnil(oldval) ||  /* result is no nil? */
+          (tm = fasttm(L, h->metatable, TM_NEWINDEX)) == NULL) { /* or no TM? */
+        setobj2t(oldval, val);  /* write barrier */
+        return;
+      }
+      /* else will try the tag method */
+    }
+    else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))
+      luaG_typeerror(L, t, "index");
+    if (ttisfunction(tm)) {
+      callTM(L, tm, t, key, val);
+      return;
+    }
+    t = tm;  /* else repeat with `tm' */ 
+  } while (++loop <= MAXTAGLOOP);
+  luaG_runerror(L, "loop in settable");
+}
+
+
+static int call_binTM (lua_State *L, const TObject *p1, const TObject *p2,
+                       StkId res, TMS event) {
+  ptrdiff_t result = savestack(L, res);
+  const TObject *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */
+  if (ttisnil(tm))
+    tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */
+  if (!ttisfunction(tm)) return 0;
+  callTMres(L, tm, p1, p2);
+  res = restorestack(L, result);  /* previous call may change stack */
+  setobjs2s(res, L->top);
+  return 1;
+}
+
+
+static const TObject *get_compTM (lua_State *L, Table *mt1, Table *mt2,
+                                  TMS event) {
+  const TObject *tm1 = fasttm(L, mt1, event);
+  const TObject *tm2;
+  if (tm1 == NULL) return NULL;  /* no metamethod */
+  if (mt1 == mt2) return tm1;  /* same metatables => same metamethods */
+  tm2 = fasttm(L, mt2, event);
+  if (tm2 == NULL) return NULL;  /* no metamethod */
+  if (luaO_rawequalObj(tm1, tm2))  /* same metamethods? */
+    return tm1;
+  return NULL;
+}
+
+
+static int call_orderTM (lua_State *L, const TObject *p1, const TObject *p2,
+                         TMS event) {
+  const TObject *tm1 = luaT_gettmbyobj(L, p1, event);
+  const TObject *tm2;
+  if (ttisnil(tm1)) return -1;  /* no metamethod? */
+  tm2 = luaT_gettmbyobj(L, p2, event);
+  if (!luaO_rawequalObj(tm1, tm2))  /* different metamethods? */
+    return -1;
+  callTMres(L, tm1, p1, p2);
+  return !l_isfalse(L->top);
+}
+
+
+static int luaV_strcmp (const TString *ls, const TString *rs) {
+  const char *l = getstr(ls);
+  size_t ll = ls->tsv.len;
+  const char *r = getstr(rs);
+  size_t lr = rs->tsv.len;
+  for (;;) {
+    int temp = strcoll(l, r);
+    if (temp != 0) return temp;
+    else {  /* strings are equal up to a `\0' */
+      size_t len = strlen(l);  /* index of first `\0' in both strings */
+      if (len == lr)  /* r is finished? */
+        return (len == ll) ? 0 : 1;
+      else if (len == ll)  /* l is finished? */
+        return -1;  /* l is smaller than r (because r is not finished) */
+      /* both strings longer than `len'; go on comparing (after the `\0') */
+      len++;
+      l += len; ll -= len; r += len; lr -= len;
+    }
+  }
+}
+
+
+int luaV_lessthan (lua_State *L, const TObject *l, const TObject *r) {
+  int res;
+  if (ttype(l) != ttype(r))
+    return luaG_ordererror(L, l, r);
+  else if (ttisnumber(l))
+    return nvalue(l) < nvalue(r);
+  else if (ttisstring(l))
+    return luaV_strcmp(tsvalue(l), tsvalue(r)) < 0;
+  else if ((res = call_orderTM(L, l, r, TM_LT)) != -1)
+    return res;
+  return luaG_ordererror(L, l, r);
+}
+
+
+static int luaV_lessequal (lua_State *L, const TObject *l, const TObject *r) {
+  int res;
+  if (ttype(l) != ttype(r))
+    return luaG_ordererror(L, l, r);
+  else if (ttisnumber(l))
+    return nvalue(l) <= nvalue(r);
+  else if (ttisstring(l))
+    return luaV_strcmp(tsvalue(l), tsvalue(r)) <= 0;
+  else if ((res = call_orderTM(L, l, r, TM_LE)) != -1)  /* first try `le' */
+    return res;
+  else if ((res = call_orderTM(L, r, l, TM_LT)) != -1)  /* else try `lt' */
+    return !res;
+  return luaG_ordererror(L, l, r);
+}
+
+
+int luaV_equalval (lua_State *L, const TObject *t1, const TObject *t2) {
+  const TObject *tm;
+  lua_assert(ttype(t1) == ttype(t2));
+  switch (ttype(t1)) {
+    case LUA_TNIL: return 1;
+    case LUA_TNUMBER: return nvalue(t1) == nvalue(t2);
+    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */
+    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
+    case LUA_TUSERDATA: {
+      if (uvalue(t1) == uvalue(t2)) return 1;
+      tm = get_compTM(L, uvalue(t1)->uv.metatable, uvalue(t2)->uv.metatable,
+                         TM_EQ);
+      break;  /* will try TM */
+    }
+    case LUA_TTABLE: {
+      if (hvalue(t1) == hvalue(t2)) return 1;
+      tm = get_compTM(L, hvalue(t1)->metatable, hvalue(t2)->metatable, TM_EQ);
+      break;  /* will try TM */
+    }
+    default: return gcvalue(t1) == gcvalue(t2);
+  }
+  if (tm == NULL) return 0;  /* no TM? */
+  callTMres(L, tm, t1, t2);  /* call TM */
+  return !l_isfalse(L->top);
+}
+
+
+void luaV_concat (lua_State *L, int total, int last) {
+  do {
+    StkId top = L->base + last + 1;
+    int n = 2;  /* number of elements handled in this pass (at least 2) */
+    if (!tostring(L, top-2) || !tostring(L, top-1)) {
+      if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))
+        luaG_concaterror(L, top-2, top-1);
+    } else if (tsvalue(top-1)->tsv.len > 0) {  /* if len=0, do nothing */
+      /* at least two string values; get as many as possible */
+      lu_mem tl = cast(lu_mem, tsvalue(top-1)->tsv.len) +
+                  cast(lu_mem, tsvalue(top-2)->tsv.len);
+      char *buffer;
+      int i;
+      while (n < total && tostring(L, top-n-1)) {  /* collect total length */
+        tl += tsvalue(top-n-1)->tsv.len;
+        n++;
+      }
+      if (tl > MAX_SIZET) luaG_runerror(L, "string size overflow");
+      buffer = luaZ_openspace(L, &G(L)->buff, tl);
+      tl = 0;
+      for (i=n; i>0; i--) {  /* concat all strings */
+        size_t l = tsvalue(top-i)->tsv.len;
+        memcpy(buffer+tl, svalue(top-i), l);
+        tl += l;
+      }
+      setsvalue2s(top-n, luaS_newlstr(L, buffer, tl));
+    }
+    total -= n-1;  /* got `n' strings to create 1 new */
+    last -= n-1;
+  } while (total > 1);  /* repeat until only 1 result left */
+}
+
+
+static void Arith (lua_State *L, StkId ra,
+                   const TObject *rb, const TObject *rc, TMS op) {
+  TObject tempb, tempc;
+  const TObject *b, *c;
+  if ((b = luaV_tonumber(rb, &tempb)) != NULL &&
+      (c = luaV_tonumber(rc, &tempc)) != NULL) {
+    switch (op) {
+      case TM_ADD: setnvalue(ra, nvalue(b) + nvalue(c)); break;
+      case TM_SUB: setnvalue(ra, nvalue(b) - nvalue(c)); break;
+      case TM_MUL: setnvalue(ra, nvalue(b) * nvalue(c)); break;
+      case TM_DIV: setnvalue(ra, nvalue(b) / nvalue(c)); break;
+      case TM_POW: {
+        const TObject *f = luaH_getstr(hvalue(gt(L)), G(L)->tmname[TM_POW]);
+        ptrdiff_t res = savestack(L, ra);
+        if (!ttisfunction(f))
+          luaG_runerror(L, "`__pow' (`^' operator) is not a function");
+        callTMres(L, f, b, c);
+        ra = restorestack(L, res);  /* previous call may change stack */
+        setobjs2s(ra, L->top);
+        break;
+      }
+      default: lua_assert(0); break;
+    }
+  }
+  else if (!call_binTM(L, rb, rc, ra, op))
+    luaG_aritherror(L, rb, rc);
+}
+
+
+
+/*
+** some macros for common tasks in `luaV_execute'
+*/
+
+#define runtime_check(L, c)	{ if (!(c)) return 0; }
+
+#define RA(i)	(base+GETARG_A(i))
+/* to be used after possible stack reallocation */
+#define XRA(i)	(L->base+GETARG_A(i))
+#define RB(i)	(base+GETARG_B(i))
+#define RKB(i)	((GETARG_B(i) < MAXSTACK) ? RB(i) : k+GETARG_B(i)-MAXSTACK)
+#define RC(i)	(base+GETARG_C(i))
+#define RKC(i)	((GETARG_C(i) < MAXSTACK) ? RC(i) : k+GETARG_C(i)-MAXSTACK)
+#define KBx(i)	(k+GETARG_Bx(i))
+
+
+#define dojump(pc, i)	((pc) += (i))
+
+
+StkId luaV_execute (lua_State *L) {
+  LClosure *cl;
+  TObject *k;
+  const Instruction *pc;
+ callentry:  /* entry point when calling new functions */
+  L->ci->u.l.pc = &pc;
+  if (L->hookmask & LUA_MASKCALL)
+    luaD_callhook(L, LUA_HOOKCALL, -1);
+ retentry:  /* entry point when returning to old functions */
+  lua_assert(L->ci->state == CI_SAVEDPC ||
+             L->ci->state == (CI_SAVEDPC | CI_CALLING));
+  L->ci->state = CI_HASFRAME;  /* activate frame */
+  pc = L->ci->u.l.savedpc;
+  cl = &clvalue(L->base - 1)->l;
+  k = cl->p->k;
+  /* main loop of interpreter */
+  for (;;) {
+    const Instruction i = *pc++;
+    StkId base, ra;
+    if ((L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) &&
+        (--L->hookcount == 0 || L->hookmask & LUA_MASKLINE)) {
+      traceexec(L);
+      if (L->ci->state & CI_YIELD) {  /* did hook yield? */
+        L->ci->u.l.savedpc = pc - 1;
+        L->ci->state = CI_YIELD | CI_SAVEDPC;
+        return NULL;
+      }
+    }
+    /* warning!! several calls may realloc the stack and invalidate `ra' */
+    base = L->base;
+    ra = RA(i);
+    lua_assert(L->ci->state & CI_HASFRAME);
+    lua_assert(base == L->ci->base);
+    lua_assert(L->top <= L->stack + L->stacksize && L->top >= base);
+    lua_assert(L->top == L->ci->top ||
+         GET_OPCODE(i) == OP_CALL ||   GET_OPCODE(i) == OP_TAILCALL ||
+         GET_OPCODE(i) == OP_RETURN || GET_OPCODE(i) == OP_SETLISTO);
+    switch (GET_OPCODE(i)) {
+      case OP_MOVE: {
+        setobjs2s(ra, RB(i));
+        break;
+      }
+      case OP_LOADK: {
+        setobj2s(ra, KBx(i));
+        break;
+      }
+      case OP_LOADBOOL: {
+        setbvalue(ra, GETARG_B(i));
+        if (GETARG_C(i)) pc++;  /* skip next instruction (if C) */
+        break;
+      }
+      case OP_LOADNIL: {
+        TObject *rb = RB(i);
+        do {
+          setnilvalue(rb--);
+        } while (rb >= ra);
+        break;
+      }
+      case OP_GETUPVAL: {
+        int b = GETARG_B(i);
+        setobj2s(ra, cl->upvals[b]->v);
+        break;
+      }
+      case OP_GETGLOBAL: {
+        TObject *rb = KBx(i);
+        const TObject *v;
+        lua_assert(ttisstring(rb) && ttistable(&cl->g));
+        v = luaH_getstr(hvalue(&cl->g), tsvalue(rb));
+        if (!ttisnil(v)) { setobj2s(ra, v); }
+        else
+          setobj2s(XRA(i), luaV_index(L, &cl->g, rb, 0));
+        break;
+      }
+      case OP_GETTABLE: {
+        StkId rb = RB(i);
+        TObject *rc = RKC(i);
+        if (ttistable(rb)) {
+          const TObject *v = luaH_get(hvalue(rb), rc);
+          if (!ttisnil(v)) { setobj2s(ra, v); }
+          else
+            setobj2s(XRA(i), luaV_index(L, rb, rc, 0));
+        }
+        else
+          setobj2s(XRA(i), luaV_getnotable(L, rb, rc, 0));
+        break;
+      }
+      case OP_SETGLOBAL: {
+        lua_assert(ttisstring(KBx(i)) && ttistable(&cl->g));
+        luaV_settable(L, &cl->g, KBx(i), ra);
+        break;
+      }
+      case OP_SETUPVAL: {
+        int b = GETARG_B(i);
+        setobj(cl->upvals[b]->v, ra);  /* write barrier */
+        break;
+      }
+      case OP_SETTABLE: {
+        luaV_settable(L, ra, RKB(i), RKC(i));
+        break;
+      }
+      case OP_NEWTABLE: {
+        int b = GETARG_B(i);
+        b = fb2int(b);
+        sethvalue(ra, luaH_new(L, b, GETARG_C(i)));
+        luaC_checkGC(L);
+        break;
+      }
+      case OP_SELF: {
+        StkId rb = RB(i);
+        TObject *rc = RKC(i);
+        runtime_check(L, ttisstring(rc));
+        setobjs2s(ra+1, rb);
+        if (ttistable(rb)) {
+          const TObject *v = luaH_getstr(hvalue(rb), tsvalue(rc));
+          if (!ttisnil(v)) { setobj2s(ra, v); }
+          else
+            setobj2s(XRA(i), luaV_index(L, rb, rc, 0));
+        }
+        else
+          setobj2s(XRA(i), luaV_getnotable(L, rb, rc, 0));
+        break;
+      }
+      case OP_ADD: {
+        TObject *rb = RKB(i);
+        TObject *rc = RKC(i);
+        if (ttisnumber(rb) && ttisnumber(rc)) {
+          setnvalue(ra, nvalue(rb) + nvalue(rc));
+        }
+        else
+          Arith(L, ra, rb, rc, TM_ADD);
+        break;
+      }
+      case OP_SUB: {
+        TObject *rb = RKB(i);
+        TObject *rc = RKC(i);
+        if (ttisnumber(rb) && ttisnumber(rc)) {
+          setnvalue(ra, nvalue(rb) - nvalue(rc));
+        }
+        else
+          Arith(L, ra, rb, rc, TM_SUB);
+        break;
+      }
+      case OP_MUL: {
+        TObject *rb = RKB(i);
+        TObject *rc = RKC(i);
+        if (ttisnumber(rb) && ttisnumber(rc)) {
+          setnvalue(ra, nvalue(rb) * nvalue(rc));
+        }
+        else
+          Arith(L, ra, rb, rc, TM_MUL);
+        break;
+      }
+      case OP_DIV: {
+        TObject *rb = RKB(i);
+        TObject *rc = RKC(i);
+        if (ttisnumber(rb) && ttisnumber(rc)) {
+          setnvalue(ra, nvalue(rb) / nvalue(rc));
+        }
+        else
+          Arith(L, ra, rb, rc, TM_DIV);
+        break;
+      }
+      case OP_POW: {
+        Arith(L, ra, RKB(i), RKC(i), TM_POW);
+        break;
+      }
+      case OP_UNM: {
+        const TObject *rb = RB(i);
+        TObject temp;
+        if (tonumber(rb, &temp)) {
+          setnvalue(ra, -nvalue(rb));
+        }
+        else {
+          setnilvalue(&temp);
+          if (!call_binTM(L, RB(i), &temp, ra, TM_UNM))
+            luaG_aritherror(L, RB(i), &temp);
+        }
+        break;
+      }
+      case OP_NOT: {
+        int res = l_isfalse(RB(i));  /* next assignment may change this value */
+        setbvalue(ra, res);
+        break;
+      }
+      case OP_CONCAT: {
+        int b = GETARG_B(i);
+        int c = GETARG_C(i);
+        luaV_concat(L, c-b+1, c);  /* may change `base' (and `ra') */
+        base = L->base;
+        setobjs2s(RA(i), base+b);
+        luaC_checkGC(L);
+        break;
+      }
+      case OP_JMP: {
+        dojump(pc, GETARG_sBx(i));
+        break;
+      }
+      case OP_EQ: {
+        if (equalobj(L, RKB(i), RKC(i)) != GETARG_A(i)) pc++;
+        else dojump(pc, GETARG_sBx(*pc) + 1);
+        break;
+      }
+      case OP_LT: {
+        if (luaV_lessthan(L, RKB(i), RKC(i)) != GETARG_A(i)) pc++;
+        else dojump(pc, GETARG_sBx(*pc) + 1);
+        break;
+      }
+      case OP_LE: {
+        if (luaV_lessequal(L, RKB(i), RKC(i)) != GETARG_A(i)) pc++;
+        else dojump(pc, GETARG_sBx(*pc) + 1);
+        break;
+      }
+      case OP_TEST: {
+        TObject *rb = RB(i);
+        if (l_isfalse(rb) == GETARG_C(i)) pc++;
+        else {
+          setobjs2s(ra, rb);
+          dojump(pc, GETARG_sBx(*pc) + 1);
+        }
+        break;
+      }
+      case OP_CALL:
+      case OP_TAILCALL: {
+        StkId firstResult;
+        int b = GETARG_B(i);
+        int nresults;
+        if (b != 0) L->top = ra+b;  /* else previous instruction set top */
+        nresults = GETARG_C(i) - 1;
+        firstResult = luaD_precall(L, ra);
+        if (firstResult) {
+          if (firstResult > L->top) {  /* yield? */
+            lua_assert(L->ci->state == (CI_C | CI_YIELD));
+            (L->ci - 1)->u.l.savedpc = pc;
+            (L->ci - 1)->state = CI_SAVEDPC;
+            return NULL;
+          }
+          /* it was a C function (`precall' called it); adjust results */
+          luaD_poscall(L, nresults, firstResult);
+          if (nresults >= 0) L->top = L->ci->top;
+        }
+        else {  /* it is a Lua function */
+          if (GET_OPCODE(i) == OP_CALL) {  /* regular call? */
+            (L->ci-1)->u.l.savedpc = pc;  /* save `pc' to return later */
+            (L->ci-1)->state = (CI_SAVEDPC | CI_CALLING);
+          }
+          else {  /* tail call: put new frame in place of previous one */
+            int aux;
+            base = (L->ci - 1)->base;  /* `luaD_precall' may change the stack */
+            ra = RA(i);
+            if (L->openupval) luaF_close(L, base);
+            for (aux = 0; ra+aux < L->top; aux++)  /* move frame down */
+              setobjs2s(base+aux-1, ra+aux);
+            (L->ci - 1)->top = L->top = base+aux;  /* correct top */
+            lua_assert(L->ci->state & CI_SAVEDPC);
+            (L->ci - 1)->u.l.savedpc = L->ci->u.l.savedpc;
+            (L->ci - 1)->u.l.tailcalls++;  /* one more call lost */
+            (L->ci - 1)->state = CI_SAVEDPC;
+            L->ci--;  /* remove new frame */
+            L->base = L->ci->base;
+          }
+          goto callentry;
+        }
+        break;
+      }
+      case OP_RETURN: {
+        CallInfo *ci = L->ci - 1;  /* previous function frame */
+        int b = GETARG_B(i);
+        if (b != 0) L->top = ra+b-1;
+        lua_assert(L->ci->state & CI_HASFRAME);
+        if (L->openupval) luaF_close(L, base);
+        L->ci->state = CI_SAVEDPC;  /* deactivate current function */
+        L->ci->u.l.savedpc = pc;
+        /* previous function was running `here'? */
+        if (!(ci->state & CI_CALLING)) {
+          lua_assert((ci->state & CI_C) || ci->u.l.pc != &pc);
+          return ra;  /* no: return */
+        }
+        else {  /* yes: continue its execution */
+          int nresults;
+          lua_assert(ci->u.l.pc == &pc &&
+                     ttisfunction(ci->base - 1) &&
+                     (ci->state & CI_SAVEDPC));
+          lua_assert(GET_OPCODE(*(ci->u.l.savedpc - 1)) == OP_CALL);
+          nresults = GETARG_C(*(ci->u.l.savedpc - 1)) - 1;
+          luaD_poscall(L, nresults, ra);
+          if (nresults >= 0) L->top = L->ci->top;
+          goto retentry;
+        }
+      }
+      case OP_FORLOOP: {
+        lua_Number step, idx, limit;
+        const TObject *plimit = ra+1;
+        const TObject *pstep = ra+2;
+        if (!ttisnumber(ra))
+          luaG_runerror(L, "`for' initial value must be a number");
+        if (!tonumber(plimit, ra+1))
+          luaG_runerror(L, "`for' limit must be a number");
+        if (!tonumber(pstep, ra+2))
+          luaG_runerror(L, "`for' step must be a number");
+        step = nvalue(pstep);
+        idx = nvalue(ra) + step;  /* increment index */
+        limit = nvalue(plimit);
+        if (step > 0 ? idx <= limit : idx >= limit) {
+          dojump(pc, GETARG_sBx(i));  /* jump back */
+          chgnvalue(ra, idx);  /* update index */
+        }
+        break;
+      }
+      case OP_TFORLOOP: {
+        int nvar = GETARG_C(i) + 1;
+        StkId cb = ra + nvar + 2;  /* call base */
+        setobjs2s(cb, ra);
+        setobjs2s(cb+1, ra+1);
+        setobjs2s(cb+2, ra+2);
+        L->top = cb+3;  /* func. + 2 args (state and index) */
+        luaD_call(L, cb, nvar);
+        L->top = L->ci->top;
+        ra = XRA(i) + 2;  /* final position of first result */
+        cb = ra + nvar;
+        do {  /* move results to proper positions */
+          nvar--;
+          setobjs2s(ra+nvar, cb+nvar);
+        } while (nvar > 0);
+        if (ttisnil(ra))  /* break loop? */
+          pc++;  /* skip jump (break loop) */
+        else
+          dojump(pc, GETARG_sBx(*pc) + 1);  /* jump back */
+        break;
+      }
+      case OP_TFORPREP: {  /* for compatibility only */
+        if (ttistable(ra)) {
+          setobjs2s(ra+1, ra);
+          setobj2s(ra, luaH_getstr(hvalue(gt(L)), luaS_new(L, "next")));
+        }
+        dojump(pc, GETARG_sBx(i));
+        break;
+      }
+      case OP_SETLIST:
+      case OP_SETLISTO: {
+        int bc;
+        int n;
+        Table *h;
+        runtime_check(L, ttistable(ra));
+        h = hvalue(ra);
+        bc = GETARG_Bx(i);
+        if (GET_OPCODE(i) == OP_SETLIST)
+          n = (bc&(LFIELDS_PER_FLUSH-1)) + 1;
+        else {
+          n = L->top - ra - 1;
+          L->top = L->ci->top;
+        }
+        bc &= ~(LFIELDS_PER_FLUSH-1);  /* bc = bc - bc%FPF */
+        for (; n > 0; n--)
+          setobj2t(luaH_setnum(L, h, bc+n), ra+n);  /* write barrier */
+        break;
+      }
+      case OP_CLOSE: {
+        luaF_close(L, ra);
+        break;
+      }
+      case OP_CLOSURE: {
+        Proto *p;
+        Closure *ncl;
+        int nup, j;
+        p = cl->p->p[GETARG_Bx(i)];
+        nup = p->nups;
+        ncl = luaF_newLclosure(L, nup, &cl->g);
+        ncl->l.p = p;
+        for (j=0; j<nup; j++, pc++) {
+          if (GET_OPCODE(*pc) == OP_GETUPVAL)
+            ncl->l.upvals[j] = cl->upvals[GETARG_B(*pc)];
+          else {
+            lua_assert(GET_OPCODE(*pc) == OP_MOVE);
+            ncl->l.upvals[j] = luaF_findupval(L, base + GETARG_B(*pc));
+          }
+        }
+        setclvalue(ra, ncl);
+        luaC_checkGC(L);
+        break;
+      }
+    }
+  }
+}
+

Added: trunk/source/libraries/lua/lvm.h
===================================================================
--- trunk/source/libraries/lua/lvm.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lvm.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,35 @@
+/*
+** $Id: lvm.h,v 1.47 2002/11/14 16:16:21 roberto Exp $
+** Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lvm_h
+#define lvm_h
+
+
+#include "ldo.h"
+#include "lobject.h"
+#include "ltm.h"
+
+
+#define tostring(L,o) ((ttype(o) == LUA_TSTRING) || (luaV_tostring(L, o)))
+
+#define tonumber(o,n)	(ttype(o) == LUA_TNUMBER || \
+                         (((o) = luaV_tonumber(o,n)) != NULL))
+
+#define equalobj(L,o1,o2) \
+	(ttype(o1) == ttype(o2) && luaV_equalval(L, o1, o2))
+
+
+int luaV_lessthan (lua_State *L, const TObject *l, const TObject *r);
+int luaV_equalval (lua_State *L, const TObject *t1, const TObject *t2);
+const TObject *luaV_tonumber (const TObject *obj, TObject *n);
+int luaV_tostring (lua_State *L, StkId obj);
+const TObject *luaV_gettable (lua_State *L, const TObject *t, TObject *key,
+                              int loop);
+void luaV_settable (lua_State *L, const TObject *t, TObject *key, StkId val);
+StkId luaV_execute (lua_State *L);
+void luaV_concat (lua_State *L, int total, int last);
+
+#endif

Added: trunk/source/libraries/lua/lzio.c
===================================================================
--- trunk/source/libraries/lua/lzio.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lzio.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,81 @@
+/*
+** $Id: lzio.c,v 1.24 2003/03/20 16:00:56 roberto Exp $
+** a generic input stream interface
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define lzio_c
+
+#include "lua.h"
+
+#include "llimits.h"
+#include "lmem.h"
+#include "lzio.h"
+
+
+int luaZ_fill (ZIO *z) {
+  size_t size;
+  const char *buff = z->reader(NULL, z->data, &size);
+  if (buff == NULL || size == 0) return EOZ;
+  z->n = size - 1;
+  z->p = buff;
+  return char2int(*(z->p++));
+}
+
+
+int luaZ_lookahead (ZIO *z) {
+  if (z->n == 0) {
+    int c = luaZ_fill(z);
+    if (c == EOZ) return c;
+    z->n++;
+    z->p--;
+  }
+  return char2int(*z->p);
+}
+
+
+void luaZ_init (ZIO *z, lua_Chunkreader reader, void *data, const char *name) {
+  z->reader = reader;
+  z->data = data;
+  z->name = name;
+  z->n = 0;
+  z->p = NULL;
+}
+
+
+/* --------------------------------------------------------------- read --- */
+size_t luaZ_read (ZIO *z, void *b, size_t n) {
+  while (n) {
+    size_t m;
+    if (z->n == 0) {
+      if (luaZ_fill(z) == EOZ)
+        return n;  /* return number of missing bytes */
+      else {
+        ++z->n;  /* filbuf removed first byte; put back it */
+        --z->p;
+      }
+    }
+    m = (n <= z->n) ? n : z->n;  /* min. between n and z->n */
+    memcpy(b, z->p, m);
+    z->n -= m;
+    z->p += m;
+    b = (char *)b + m;
+    n -= m;
+  }
+  return 0;
+}
+
+/* ------------------------------------------------------------------------ */
+char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n) {
+  if (n > buff->buffsize) {
+    if (n < LUA_MINBUFFER) n = LUA_MINBUFFER;
+    luaM_reallocvector(L, buff->buffer, buff->buffsize, n, char);
+    buff->buffsize = n;
+  }
+  return buff->buffer;
+}
+
+

Added: trunk/source/libraries/lua/lzio.h
===================================================================
--- trunk/source/libraries/lua/lzio.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lzio.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,64 @@
+/*
+** $Id: lzio.h,v 1.15 2003/03/20 16:00:56 roberto Exp $
+** Buffered streams
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lzio_h
+#define lzio_h
+
+#include "lua.h"
+
+
+#define EOZ	(-1)			/* end of stream */
+
+typedef struct Zio ZIO;
+
+
+#define char2int(c)	cast(int, cast(unsigned char, (c)))
+
+#define zgetc(z)  (((z)->n--)>0 ?  char2int(*(z)->p++) : luaZ_fill(z))
+
+#define zname(z)	((z)->name)
+
+void luaZ_init (ZIO *z, lua_Chunkreader reader, void *data, const char *name);
+size_t luaZ_read (ZIO* z, void* b, size_t n);	/* read next n bytes */
+int luaZ_lookahead (ZIO *z);
+
+
+
+typedef struct Mbuffer {
+  char *buffer;
+  size_t buffsize;
+} Mbuffer;
+
+
+char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n);
+
+#define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
+
+#define luaZ_sizebuffer(buff)	((buff)->buffsize)
+#define luaZ_buffer(buff)	((buff)->buffer)
+
+#define luaZ_resizebuffer(L, buff, size) \
+	(luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), \
+	(buff)->buffsize = size)
+
+#define luaZ_freebuffer(L, buff)	luaZ_resizebuffer(L, buff, 0)
+
+
+/* --------- Private Part ------------------ */
+
+struct Zio {
+  size_t n;			/* bytes still unread */
+  const char *p;		/* current position in buffer */
+  lua_Chunkreader reader;
+  void* data;			/* additional data */
+  const char *name;
+};
+
+
+int luaZ_fill (ZIO *z);
+
+#endif

Added: trunk/source/other/gup.cpp
===================================================================
--- trunk/source/other/gup.cpp	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/other/gup.cpp	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,713 @@
+#include <string.h>
+#include <allegro.h>
+#include "melee.h"
+
+#include "melee/mframe.h"
+#include "melee/mship.h"
+#include "melee/mcbodies.h"
+#include "melee/mview.h"
+#include "frame.h"
+#include "sc1ships.h"
+#include "sc2ships.h"
+#include "games/ggob.h"
+#include "gup.h"
+
+/* this file contains the ship upgrades used by Gob */
+
+/*
+Generic Upgrades
+*/
+
+/*
+NOTE that execute() is called BEFORE charge(), so 
+num is not yet incremented when execute() is running
+*/
+void Upgrade::clear(Ship *oship, Ship *nship, GobPlayer *gs) {
+  STACKTRACE;
+	if (oship) gs->total -= num;
+	num = 0;
+	return;
+	}
+void Upgrade::charge(GobPlayer *gs) {
+  STACKTRACE; //called AFTER execute
+	gs->total += 1;
+	num += 1;
+	gs->value_starbucks += this->starbucks;
+	gs->value_buckazoids += this->buckazoids;
+	return;
+	}
+
+#define UPGRADE(a) virtual Upgrade *duplicate() {return new a();}
+class UpCrewpod : public Upgrade {
+	UPGRADE(UpCrewpod)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Add Crewpod";
+		if (ship->crew_max >= 42) return false;
+		starbucks = 2;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship->crew_max += 4;
+		if (ship->crew_max > 42) ship->crew_max = 42;
+		ship->crew += 4;
+		if (ship->crew > 42) ship->crew = 42;
+		}
+	} crewpod;
+
+class UpBattery : public Upgrade {
+	UPGRADE(UpBattery)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Add Battery";
+		if (ship->batt_max >= 42) return false;
+		starbucks = 1;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship->batt_max += 8;
+		if (ship->batt_max > 42) ship->batt_max = 42;
+		ship->batt += 8;
+		if (ship->batt > 42) ship->batt = 42;
+		}
+	} battery;
+
+class UpThrusters : public Upgrade {
+	UPGRADE(UpThrusters)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Thrusters";
+		starbucks = 3 + num * 3;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship->speed_max *=  1 + .3  / (.25*num + 1);
+		ship->accel_rate *= 1 + .18 / (.12*num + 1);
+		}
+	} thrusters;
+
+class UpControlJets : public Upgrade {
+	UPGRADE(UpControlJets)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Control Jets";
+		starbucks = 2 + num * 2;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship->turn_rate  *=  1 + .3  / (num + 1);
+		ship->accel_rate *=  1 + .1  / (.0*num + 1);
+		}
+	} controljets;
+
+class UpDynamo : public Upgrade {
+	UPGRADE(UpDynamo)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Dynamo";
+		starbucks = 16 / (1 + ship->recharge_amount-num) + num;
+		if (ship->recharge_amount == 0) starbucks *= 6;
+		if (ship->weapon_rate < 100) starbucks /= 2;
+		if (ship->special_drain > 16) starbucks *= 2;
+		if (!strcmp("supbl", ship->type->id)) starbucks /= 2;
+		buckazoids = gs->total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship->recharge_amount += 1;
+	}
+} dynamo;
+
+/*
+Supox Upgrades
+*/
+
+class UpSupoxRange : public Upgrade {
+	UPGRADE(UpSupoxRange)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Glob Hurler (Supox)";
+		if (strcmp("supbl", ship->type->id)) return false;
+		starbucks = 2 + num;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((SupoxBlade*)ship)->weaponRange *= 1 + .25 / (1 + num*.1);
+		((SupoxBlade*)ship)->weaponVelocity *= 1.15;
+		}
+	} supoxrange;
+
+class UpSupoxDamage : public Upgrade {
+	UPGRADE(UpSupoxDamage)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Glob Former (Supox)";
+		if (strcmp("supbl", ship->type->id)) return false;
+		if (gs->ship->recharge_amount < (1<<num)) return false;
+		if (num > 7) return false;
+		starbucks = 5;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((SupoxBlade*)ship)->weaponDamage += 1;
+		((SupoxBlade*)ship)->weaponArmour += 1;
+		((SupoxBlade*)ship)->weapon_drain += num + 1;
+		if (num > 1) ((SupoxBlade*)ship)->recharge_amount += 1;
+		}
+	} supoxdamage;
+
+class UpSupoxBLADE : public Upgrade {
+	UPGRADE(UpSupoxBLADE)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Add B.L.A.D.E. (Supox)";
+		if (strcmp("supbl", ship->type->id)) return false;
+		starbucks = 2 + num;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((SupoxBlade*)ship)->damage_factor += 3;
+		}
+	} supoxblade;
+
+/*
+Orz Upgrades
+*/
+
+class UpOrzMissile : public Upgrade {
+	UPGRADE(UpOrzMissile)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Missiles (ORZ)";
+		if (strcmp("orzne", ship->type->id)) return false;
+		starbucks = 6;
+		buckazoids = gs->total / 2 + 2;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((OrzNemesis*)ship)->weaponDamage += 1;
+		((OrzNemesis*)ship)->weaponArmour += 1;
+		((OrzNemesis*)ship)->weaponRange *= 1.15;
+		((OrzNemesis*)ship)->weapon_drain += 1;
+		}
+	} orzmissile;
+
+class UpOrzMarineSpeed : public Upgrade {
+	UPGRADE(UpOrzMarineSpeed)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Marine Suits (ORZ)";
+		if (strcmp("orzne", ship->type->id)) return false;
+		starbucks = 3 + num * 2;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((OrzNemesis*)ship)->specialArmour += 1;
+		((OrzNemesis*)ship)->specialSpeedMax *= 1 + .2 / (.2*num+1);
+		((OrzNemesis*)ship)->specialAccelRate *= 1.15;
+		}
+	} orzmarinespeed;
+
+class UpOrzAbsorbtion : public Upgrade {
+	UPGRADE(UpOrzAbsorbtion)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Absorbtion (ORZ)";
+		if (strcmp("orzne", ship->type->id)) return false;
+		if (num) return false;
+		starbucks = 15;
+		buckazoids = gs->total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((OrzNemesis*)ship)->absorption = 256 / 3;
+	}
+	void charge(GobPlayer *gs) {
+		Upgrade::charge(gs);
+		gs->total += 2;
+	}
+} orzabsorption;
+
+/*
+Kohr-Ah Upgrades
+*/
+
+class UpKohrAhBladeDamage : public Upgrade {
+	UPGRADE(UpKohrAhBladeDamage)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Increase Shuriken Sharpness (Kohr-Ah)";
+		if (strcmp("kohma", ship->type->id)) return false;
+		starbucks = 2 + num;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((KohrAhMarauder*)ship)->weaponDamage += 1;
+		((KohrAhMarauder*)ship)->weaponArmour += 1;
+		((KohrAhMarauder*)ship)->weapon_drain += 1;
+		}
+	} kohrahbladedamage;
+
+class UpKohrAhBladeSpeed : public Upgrade {
+	UPGRADE(UpKohrAhBladeSpeed)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		if (strcmp("kohma", ship->type->id)) return false;
+		name = "Increase Shuriken Velocity (Kohr-Ah)";
+		starbucks = 2 + num * 2;
+		buckazoids = gs->total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((KohrAhMarauder*)ship)->weaponVelocity *= 1.2;
+	}
+} kohrahbladespeed;
+
+class UpKohrAhFireRange : public Upgrade {
+	UPGRADE(UpKohrAhFireRange)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "double F.R.I.E.D. range (Kohr-Ah)";
+		if (strcmp("kohma", ship->type->id)) return false;
+		if (num) return false;
+		starbucks = 30;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((KohrAhMarauder*)ship)->specialRange *= 2;
+		((KohrAhMarauder*)ship)->specialVelocity *= 1.4;
+		((KohrAhMarauder*)ship)->special_drain += 12;
+		}
+	} kohrahfirerange;
+
+class UpKohrAhFireDamage : public Upgrade {
+	UPGRADE(UpKohrAhFireDamage)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "double F.R.I.E.D. damage (Kohr-Ah)";
+		if (strcmp("kohma", ship->type->id)) return false;
+		if (num) return false;
+		starbucks = 13;
+		buckazoids = gs->total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((KohrAhMarauder*)ship)->specialDamage *= 2;
+		((KohrAhMarauder*)ship)->special_drain += 6;
+	}
+} kohrahfiredamage;
+
+/*
+Utwig Upgrades
+*/
+
+class UpUtwigJuggerRange : public Upgrade {
+	UPGRADE(UpUtwigJuggerRange)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Bolt Regulator (Utwig)";
+		if (strcmp("utwju", ship->type->id)) return false;
+		starbucks = 3;
+		buckazoids = gs->total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((UtwigJugger*)ship)->weaponRange += 100;
+	}
+} utwigrange;
+class UpUtwigJuggerDamage : public Upgrade {
+	UPGRADE(UpUtwigJuggerDamage)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Bolt Charger (Utwig)";
+		if (strcmp("utwju", ship->type->id)) return false;
+		starbucks = (num + 3) * 5;
+		buckazoids = gs->total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((UtwigJugger*)ship)->weaponDamage += 1;
+		ship->weapon_rate += 250;
+	}
+} utwigdamage;
+class UpUtwigJuggerROF : public Upgrade {
+	UPGRADE(UpUtwigJuggerROF)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Bolt Generator (Utwig)";
+		if (strcmp("utwju", ship->type->id)) return false;
+		if (ship->weapon_rate < 425) return false;
+		starbucks = num / 2 + 2;
+		buckazoids = gs->total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship->weapon_rate -= 50;
+	}
+} utwigrof;
+class UpUtwigJuggerMaskOfHonestDemeanor : public Upgrade {
+	UPGRADE(UpUtwigJuggerMaskOfHonestDemeanor)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Mask of Honest Demeanor (max 1 mask)";
+		if (strcmp("utwju", ship->type->id)) return false;
+		if ((num + gs->upgrade_list[UpgradeIndex::utwigmask2]->num) == 1) return false;
+		starbucks = 99;
+		buckazoids = 0;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		gs->value_starbucks += 251;
+		gs->value_buckazoids += 250;
+	}
+} utwigmask1;
+class UpUtwigJuggerMaskOfElephantineFortitude : public Upgrade {
+	UPGRADE(UpUtwigJuggerMaskOfElephantineFortitude)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Mask of Elephantine Fortitude (max 1 mask)";
+		if (strcmp("utwju", ship->type->id)) return false;
+		if ((num + gs->upgrade_list[UpgradeIndex::utwigmask1]->num) == 1) return false;
+		starbucks = 99;
+		buckazoids = 0;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((UtwigJugger*)ship)->fortitude = 1;
+	}
+} utwigmask2;
+
+/*
+Special Upgrades
+*/
+
+class UpDivineFavor : public Upgrade {
+	UPGRADE(UpDivineFavor)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Divine Favor (unique)";
+		if (strcmp(station->build_type, "orzne")) return false;
+		if (num) return false;
+		starbucks = 150;
+		buckazoids = 0;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		}
+	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
+		if (!oship) num = 0;
+		return;
+		}
+	void charge(GobPlayer *gs) {
+		num += 1;
+		}
+	} divinefavor;
+
+class UpUnholyAura : public Upgrade {
+	UPGRADE(UpUnholyAura)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "the Devil protects his own...";
+		starbucks = 6;
+		buckazoids = 66;
+		//if (strcmp(station->build_type, "orzne")) return false;
+		if (num) return false;
+		if (((game->game_time / 1000) % 1000) == 666) return true;
+		if (((game->game_time / 1000) % 666) == 0) return true;
+		//666, 1332, 1666, 1998, etc.
+		return false;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		game->add ( new UnholyAura ( ship ) );
+		}
+	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
+		if (!oship) num = 0;
+		else if (num) {
+			game->add ( new UnholyAura ( nship ) );
+		}
+		return;
+		}
+	void charge(GobPlayer *gs) {
+		num += 1;
+		}
+	} unholyaura;
+
+
+class UpDefender : public Upgrade {
+	UPGRADE(UpDefender)
+	GobDefender *def[6];
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "External Defense System";
+		if (strcmp(station->build_type, "kohma")) return false;
+		if (num >= 6) return false;
+		starbucks = 5 + 5 * (num+1) * num;
+		buckazoids = 12;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		def[num] = new GobDefender(ship);
+		int i;
+		for (i = 0; i <= num; i += 1) def[i]->base_phase = i * PI2 / (num+1);
+		gobgame->add (def[num]);
+	}
+	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
+		if (!oship) num = 0;
+		if (oship) {
+			for (int i = 0; i < num; i += 1) {
+				def[i]->die();
+				def[i] = new GobDefender(nship);
+				def[i]->base_phase = i * PI2 / num;
+				game->add(def[i]);
+			}
+		}
+		//Upgrade::clear(oship, nship, gs);
+		return;
+	}
+	void charge(GobPlayer *gs) {
+		gs->total += 1;
+		num += 1;
+	}
+} defender;
+
+class UpPlanetLocater : public Upgrade {
+	UPGRADE(UpPlanetLocater)
+	Presence **locater;
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Planet Locater";
+		if (strcmp(station->build_type, "supbl")) return false;
+		if (num) return false;
+		starbucks = 4;
+		buckazoids = 5;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		locater = new Presence *[gobgame->num_planets];
+		for (int i = 0; i < gobgame->num_planets; i += 1) {
+			locater[i] = new WedgeIndicator ( gobgame->planet[i], 80, 2 );
+			gobgame->add (locater[i] );
+		}
+	}
+	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
+		Upgrade::clear(oship, nship, gs);
+		if (oship && locater) for (int i = 0; i < gobgame->num_planets; i += 1) {
+			locater[i]->die();
+		}
+		locater = NULL;
+		return;
+	}
+} planetlocater;
+
+class UpHyperDynamo : public Upgrade {
+	UPGRADE(UpHyperDynamo)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Hyper Dynamo (ancient artifact)";
+		if (game->game_time / 1000 < 21 * 60) return false;
+		starbucks = 720 / (game->game_time / (1000*60*10) - 1);
+		//unavailable before 20 minutes
+		//720 starbucks at 20 minutes
+		//360 starbucks at 30 minutes
+		//240 starbucks at 40 minutes
+		//180 starbucks at 50 minutes
+		//144 starbucks at 60 minutes
+		//120 starbucks at 70 minutes
+		//102 starbucks at 80 minutes
+		//90 starbucks at 90 minutes
+		buckazoids = starbucks/2 + gs->total / 3;
+		if (gs->starbucks < starbucks / 4) return false;
+		if (ship->recharge_amount == 0) return false;
+		if (num) return false;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship->recharge_rate /= 2;
+	}
+} hyperdynamo;
+
+/*class UpRoswellDevice : public Upgrade {
+	UPGRADE(UpUnholyAura)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Roswell Device";
+		if (((game->game_time / 1000) % 1000) < 700) return false;
+		starbucks = 99;
+		buckazoids = 9;
+		if (strcmp(station->build_type, "utwju")) return false;
+		if (num) return false;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		game->add ( new RoswellDevice ( ship ) );
+	}
+	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
+		if (!oship) num = 0;
+		else if (num) {
+			game->add ( new RoswellDevice ( nship ) );
+		}
+		return;
+	}
+	void charge(GobPlayer *gs) {
+		num += 1;
+	}
+} roswelldevice;*/
+
+/*
+note to future coders:
+in order for an upgrade to show up, it must be added to this list
+anything added to this list MUST be added, in the same order, to 
+the enum in gup.h
+*/
+static Upgrade *_upgrade_list[] = {
+	&crewpod,
+	&battery,
+	&thrusters,
+	&controljets,
+	&dynamo,
+	&supoxrange,
+	&supoxdamage,
+	&supoxblade,
+	&orzmissile,
+	&orzmarinespeed,
+	&orzabsorption,
+	&kohrahbladedamage,
+	&kohrahbladespeed,
+	&kohrahfirerange,
+	&kohrahfiredamage,
+	&utwigrange,
+	&utwigdamage,
+	&utwigrof,
+	&utwigmask1,
+	&utwigmask2,
+	&divinefavor,
+	&unholyaura,
+	&defender,
+	&planetlocater,
+	&hyperdynamo,
+//	&roswelldevice,
+	NULL
+	};
+
+Upgrade **upgrade_list = _upgrade_list;
+
+UnholyAura::UnholyAura ( SpaceLocation * ship ) {
+	focus = ship;
+	angle = 0;
+}
+void UnholyAura::animate (Frame *frame) {
+	Vector2 p = corner(focus->normal_pos());
+	const int speed = 1500;
+	int color = game->game_time % speed;
+	if (color > speed/2) color = speed - color;
+	color = tw_color ( color * 255 * 2 / speed, 0, 0);
+	Vector2 r;
+	r.y = space_zoom * 240;
+	r.x = r.y * 1.5;
+	double a = angle;
+	line (frame->surface, 
+		p + r *(unit_vector(a +   0 * ANGLE_RATIO)), 
+		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
+		color);
+	a += 72 * ANGLE_RATIO;
+	line (frame->surface, 
+		p + r * (unit_vector(a +   0 * ANGLE_RATIO)), 
+		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
+		color);
+	a += 72 * ANGLE_RATIO;
+	line (frame->surface, 
+		p + r * (unit_vector(a +   0 * ANGLE_RATIO)), 
+		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
+		color);
+	a += 72 * ANGLE_RATIO;
+	line (frame->surface, 
+		p + r * (unit_vector(a +   0 * ANGLE_RATIO)), 
+		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
+		color);
+	a += 72 * ANGLE_RATIO;
+	line (frame->surface, 
+		p + r * (unit_vector(a +   0 * ANGLE_RATIO)), 
+		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
+		color);
+	frame->add_box(iround(p.x - r.x-1), iround(p.y - r.y-1), iround(r.x*2+3), iround(r.y*2+3));
+}
+void UnholyAura::calculate () {
+	if (!focus->exists()) die();
+	angle -= frame_time / 10.0;
+	if (angle < 0) angle += 360;
+	if (random(1700) < frame_time) {
+		Query q;
+		q.begin(focus, OBJECT_LAYERS, 666);
+		for (;q.current; q.next() ) {
+			if (!(focus->sameTeam(q.current))) q.current->handle_damage(focus, 0, random() % 6);
+		}
+	}
+}
+/*
+void GobRadar::animate_item ( SpaceLocation *item ) {
+	int type = 0;
+	int color = 0;
+	double angle = 0;
+	double radius = 0;
+	double x, y;
+	x = normalize(item->normal_x() - gx + X_MAX/2, X_MAX) - X_MAX/200+gx/2;
+	x *= window->w / gw;
+	y = normalize(item->normal_y() - gy + Y_MAX/2, Y_MAX) - Y_MAX/200+gy/2;
+	y *= window->h / gh;
+	TeamCode t = item->get_team();
+	if (t == 0) color = palette_color[6];
+	else if (t == team) color = palette_color[7];
+	else color = palette_color[4];
+	color = palette_color[7];
+	if (item->isObject()) {
+		SpaceSprite *sprite = ((SpaceObject*)item)->get_sprite();
+		if (sprite) radius = 
+			sqrt(sprite->width() * sprite->width() + sprite->height() * sprite->height()) / 2 / gw;
+		else return;
+		if (radius < 5) radius = sqrt(radius * 5);
+	}
+	else if (item->isLine()) {
+		type = 1;
+		radius = (((SpaceLine*)item)->get_length()) / gw;
+		angle = (((SpaceLine*)item)->get_angle());
+	}
+
+
+	if (type == 0) {
+		circlefill ( window->surface, 
+			window->x + x, 
+			window->y + y, 
+			radius,
+			color
+		);
+	}
+	else if (type == 1) {
+		line (  window->surface,
+			window->x + x, 
+			window->y + y,
+			window->x + x + cos(angle) * radius,
+			window->y + y + sin(angle) * radius,
+			color
+		);
+	}
+}
+
+void GobRadar::animate ( Frame * frame ) {
+	Query q;
+	if (!window->surface) return;
+
+	window->lock();
+
+	rectfill(window->surface, 
+		window->x, window->y, 
+		window->x + window->w,
+		window->y + window->h,
+		0
+		);
+	for (q.begin(0, 0, ALL_LAYERS, 999999999999);q.current;q.next()) {
+		if (!q.current->exists()) continue;
+		if (q.current->isInvisible())
+			continue;
+		animate_item(q.current);
+	}
+	q.end();
+
+	window->unlock();
+}
+
+GobRadar::GobRadar() {
+  STACKTRACE;
+	attributes &= ~ATTRIB_SYNCHED;
+	team = 0;
+	gx = 0;
+	gy = 0;
+	gw = X_MAX;
+	gh = Y_MAX;
+	window = new VideoWindow();
+	window->preinit();
+}
+*/

Added: trunk/source/other/gup.h
===================================================================
--- trunk/source/other/gup.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/other/gup.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,74 @@
+class Upgrade;
+extern Upgrade **upgrade_list;
+
+class UpgradeIndex {
+public:
+	enum {
+		crewpod,
+		battery,
+		thrusters,
+		controljets,
+		dynamo,
+		supoxrange,
+		supoxdamage,
+		supoxblade,
+		orzmissile,
+		orzmarinespeed,
+		orzabsorption,
+		kohrahbladedamage,
+		kohrahbladespeed,
+		kohrahfirerange,
+		kohrahfiredamage,
+		utwigrange,
+		utwigdamage,
+		utwigrof,
+		utwigmask1,
+		utwigmask2,
+		divinefavor,
+		unholyaura,
+		defender,
+		planetlocater,
+		hyperdynamo,
+		//gobradar,
+		//roswelldevice,
+		NULL_UPGRADE
+	};
+};
+
+class GobDefender : public SpaceObject {
+	public:
+	GobDefender ( Ship *ship);
+	double base_phase;
+	virtual void calculate();
+	int next_shoot_time;
+};
+
+/*class RoswellDevice : public Presence {
+	public:
+	RoswellDevice ( Ship *ship, double angle );
+	virtual void calculate();
+	int next_shoot_time;
+	double phase;
+};*/
+
+class UnholyAura : public Presence {
+public:
+	SpaceLocation *focus;
+	double angle;
+	virtual void calculate ();
+	virtual void animate ( Frame * frame);
+	UnholyAura ( SpaceLocation *ship );
+};
+
+/*
+class GobRadar : public Presence {
+public:
+	TeamCode team;
+	double gx, gy, gw, gh;
+	VideoWindow *window;
+	//virtual void calculate ();
+	virtual void animate ( Frame * frame );
+	virtual void animate_item ( SpaceLocation *item);
+	GobRadar();
+};*/
+

Modified: trunk/source/scp.h
===================================================================
--- trunk/source/scp.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/scp.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -18,12 +18,13 @@
 #ifndef __SCP_H__
 #define __SCP_H__
 
-class VideoWindow;
+
 #include "allegro.h"
 
 //class SAMPLE;
 
 #include <string>
+class VideoWindow;
 
 /// \brief run tests
 bool RunTests();

Modified: trunk/sources.lst
===================================================================
--- trunk/sources.lst	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/sources.lst	2004-09-26 08:30:59 UTC (rev 64)
@@ -17,6 +17,7 @@
 source/util/endian.cpp
 source/util/pmask.c
 source/util/base.cpp
+source/games/ggob.cpp
 source/games/gflmelee.cpp
 source/melee/mlog.cpp
 source/melee/mitems.cpp
@@ -45,6 +46,7 @@
 source/other/vtarget.cpp
 source/other/twconfig.cpp
 source/other/vbodies.cpp
+source/other/gup.cpp
 source/other/objanim.cpp
 source/other/nullphas.cpp
 source/other/planet3d.cpp
@@ -85,6 +87,34 @@
 source/twgui/twpopup.cpp
 source/twgui/twwindow.cpp
 source/twgui/utils.cpp
+source/libraries/lua/lib/ldblib.c
+source/libraries/lua/lib/lauxlib.c
+source/libraries/lua/lib/lbaselib.c
+source/libraries/lua/lib/loadlib.c
+source/libraries/lua/lib/ltablib.c
+source/libraries/lua/lib/lmathlib.c
+source/libraries/lua/lib/lstrlib.c
+source/libraries/lua/lib/liolib.c
+source/libraries/lua/lundump.c
+source/libraries/lua/ldebug.c
+source/libraries/lua/ldo.c
+source/libraries/lua/lgc.c
+source/libraries/lua/ltm.c
+source/libraries/lua/lvm.c
+source/libraries/lua/lcode.c
+source/libraries/lua/ldump.c
+source/libraries/lua/lfunc.c
+source/libraries/lua/lparser.c
+source/libraries/lua/ltable.c
+source/libraries/lua/ltests.c
+source/libraries/lua/lstate.c
+source/libraries/lua/lapi.c
+source/libraries/lua/llex.c
+source/libraries/lua/lmem.c
+source/libraries/lua/lzio.c
+source/libraries/lua/lopcodes.c
+source/libraries/lua/lobject.c
+source/libraries/lua/lstring.c
 source/libraries/agup/aphoton.c
 source/libraries/agup/ans.c
 source/libraries/agup/awin95.c



From yurand at sheep.berlios.de  Sun Sep 26 15:47:59 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 26 Sep 2004 15:47:59 +0200
Subject: [Tw-light-svn] r65 - in trunk: . doc gamedata source source/games
Message-ID: <200409261347.i8QDlxj1027517@sheep.berlios.de>

Author: yurand
Date: 2004-09-26 15:47:54 +0200 (Sun, 26 Sep 2004)
New Revision: 65

Added:
   trunk/source/games/gdefender.cpp
Modified:
   trunk/doc/Doxyfile
   trunk/gamedata/ingame.txt
   trunk/source/doxygen.cpp
   trunk/source/scp.cpp
   trunk/sources.lst
Log:
Defender game type added
Documentation updated


Modified: trunk/doc/Doxyfile
===================================================================
--- trunk/doc/Doxyfile	2004-09-26 08:30:59 UTC (rev 64)
+++ trunk/doc/Doxyfile	2004-09-26 13:47:54 UTC (rev 65)
@@ -4,7 +4,7 @@
 # General configuration options
 #---------------------------------------------------------------------------
 PROJECT_NAME           = TW-Light
-PROJECT_NUMBER         = 0.1b2
+PROJECT_NUMBER         = 0.3b64
 OUTPUT_DIRECTORY       = ./
 OUTPUT_LANGUAGE        = English
 USE_WINDOWS_ENCODING   = YES

Modified: trunk/gamedata/ingame.txt
===================================================================
--- trunk/gamedata/ingame.txt	2004-09-26 08:30:59 UTC (rev 64)
+++ trunk/gamedata/ingame.txt	2004-09-26 13:47:54 UTC (rev 65)
@@ -1,98 +1,113 @@
 Global keys:
-        F1 brings up the help screen
-        F2 brings up the options menu
-        F3 switches camera focus
-        F4 is fast-forward (speeds up in-game time greatly)
-        F5 displays fleet status
-        F7 changes game tic rate (physics quality)
-        F8 changes camera mode
-        F10 quits (so does ESCAPE)
-        F11 saves screenshots
-        F12 displays framerates / performance data
-        - zooms out on some viewing modes.
-        + (or =) zooms in on some viewing modes.
-        0 and 9 also effect the camera in some viewing modes.
-        ctrl+T = toggle team indicators on/off
-        ctrl+H = toggle healthbar indicators on/off
+  F1 brings up the help screen
+  F2 brings up the options menu
+  F3 switches camera focus
+  F4 is fast-forward (speeds up in-game time greatly)
+  F5 displays fleet status
+  F7 changes game tic rate (physics quality)
+  F8 changes camera mode
+  F10 quits (so does ESCAPE)
+  F11 saves screenshots
+  F12 displays framerates / performance data
+  - zooms out on some viewing modes.
+  + (or =) zooms in on some viewing modes.
+  0 and 9 also effect the camera in some viewing modes.
+  ctrl+T = toggle team indicators on/off
+  ctrl+H = toggle healthbar indicators on/off
 
 Melee:  
+  Starts a battle with the current team settings.
 
-	Starts a battle with the current team settings.
-
 Extras Menu:
 
-	Play Game:
-               Select different gametypes.  For this version, only Melee is available.
-	Key Tester:
-               Use this utility to check keys combination for conflicts.
-	Show License:
-		Shows the license of this program.
-	Ship Info:
-		Here you can get detail information about every 
-             ship in the game.  Disabled in this release, sorry!
-	Diagnostic:
-                Show comlile options and version information. 
-	Main Menu:
-                This returns to the main menu.
-		
+  Play Game:
+    Select different gametypes.  Currently:
+    1) Melee - simple starfleet combat
+    2) GOB - Game goals:
+              Avoid dieing.  
+              Try to get as bad-ass a ship as you can.  
+              Kill lots of enemies.
 
+       If you survive for long enough and accumulate 
+       enough wealth, you will eventually be able to 
+       purchase the "Hyper Dynamo" upgrade.  Once you
+       get that, you can basically consider yourself 
+       to have won the game. Try to win Gob with as 
+       many different ships as you can.  
+
+    3) Defender - protect starbase as long as you can
+
+  Key Tester:
+    Use this utility to check keys combination for conflicts.
+  Show License:
+    Shows the license of this program.
+  Ship Info:
+    Here you can get detail information about every 
+    ship in the game.  
+  Diagnostic:
+    Show comlile options and version information. 
+  Main Menu:
+    This returns to the main menu.	
+
 Teams:
 
-        Select Controller:
-                Select the player (i.e. "Player 1" or "Player 2")
-              you wish to alter from the list on the left, and
-              the controller (i.e. "Keyboard", "MoronBot") you
-              want to control that player from the list on the
-              left.  Then either click on the "Select
-              Controller" button or double click on the
-              controller name.
-	Change Team #: 
-	        This switches the player allys. 
-	      Note that team 0 mean no allys.
-        Change Config #:
-                 This switches the configuration used by the
-               currently highlighted controller.  
-        Edit Configuration:
-                 This is used to setup up keys when the currently
-               highlighted player is using the keyboard.  It
-               may eventually allow the configuration of AIs
-               and calibration of joysticks.
-        Edit Fleet:
-                 This button brings up the fleet selection menu for
-               the currently highlighted player.  
-        Main Menu:
-                 This returns to the main menu.
+  Select Controller:
+    Select the player (i.e. "Player 1" or "Player 2")
+    you wish to alter from the list on the left, and
+    the controller (i.e. "Keyboard", "MoronBot") you
+    want to control that player from the list on the
+    left.  Then either click on the "Select
+    Controller" button or double click on the
+    controller name.
+  Change Team #: 
+    This switches the player allys. 
+    Note that team 0 mean no allys.
+  Change Config #:
+    This switches the configuration used by the
+    currently highlighted controller.  
+  Edit Configuration:
+    This is used to setup up keys when the currently
+    highlighted player is using the keyboard.  It
+    may eventually allow the configuration of AIs
+    and calibration of joysticks.
+  Edit Fleet:
+    This button brings up the fleet selection menu for
+    the currently highlighted player.  
+  Main Menu:
+    This returns to the main menu.
 
 Options:
 
-        Most things on this menu are self-explanatory, but a few
-          need special mention.
+  Most things on this menu are self-explanatory, but a few
+  need special mention.
 
-        Gamma correction:
-                This makes things brighter during combat.  This
-                  should not be changed from the middle of combat,
-                  or colors could get weird.  
-        Antialiasing:
-                If this box is checked then TimeWarp will use
-                  higher quality graphics, but run slower.  
-        Color Depth:
-                You cannot change this from the middle of combat.  
-        Camera Mode:
-                This allows you to control what is shown on your
-                  screen in combat.  
+  Gamma correction:
+    This makes things brighter during combat.  This
+    should not be changed from the middle of combat,
+    or colors could get weird.  
+  Antialiasing:
+    If this box is checked then TimeWarp will use
+    higher quality graphics, but run slower.  
+  Color Depth:
+    You cannot change this from the middle of combat.  
+  Camera Mode:
+    This allows you to control what is shown on your
+    screen in combat.  
 
-                "Enemy_Discrete"
-                  is just like Star Control on the PC, where
-                  the camera moved to keep both you and your
-                  enemy onscreen, and zoomed in by factors of
-                  2.
-                "Enemy"
-                  is like Star Control on the Genesis or 3DO,
-                  where the camera zoomed in smoothly.
-                "Hero"
-                  makes the camera stay focused on Player 1,
-                  and zoom in/out when + and - are pressed.
-                "Everything"
-                  makes the camera stay on the planet and zoom
-                  way out so that everything is visible.  This
-                  mode is slightly buggy (visual artifacts).  
+    "Enemy_Discrete"
+       is just like Star Control on the PC, where
+       the camera moved to keep both you and your
+       enemy onscreen, and zoomed in by factors of 2.
+
+     "Enemy"
+       is like Star Control on the Genesis or 3DO,
+       where the camera zoomed in smoothly.
+
+     "Hero"
+       makes the camera stay focused on Player 1,
+       and zoom in/out when + and - are pressed.
+
+     "Everything"
+       makes the camera stay on the planet and zoom
+       way out so that everything is visible.  This
+       mode is slightly buggy (visual artifacts).  

Modified: trunk/source/doxygen.cpp
===================================================================
--- trunk/source/doxygen.cpp	2004-09-26 08:30:59 UTC (rev 64)
+++ trunk/source/doxygen.cpp	2004-09-26 13:47:54 UTC (rev 65)
@@ -1,7 +1,6 @@
-/* $Id: doxygen.cpp,v 1.3 2004/08/07 13:10:51 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -19,9 +18,9 @@
  * 
  *  \section overview_sec Overview: What is TW-Light?
  *  
- *  TW-Light is lightweighted version of Star Control: TimeWarp. Currently it includes only a combat 
- *  portion with the best TW ships but without network support. There are some plans to expand it to 
- *  include an epic adventure. 
+ *  TW-Light is an open source clone/sequel to the epic cross-genre game Star Control II. 
+ *  Currently it includes only a combat portion, although epic adventure part that is 
+ *  called TW:Legacies is actively developed now. 
  *
  *  \section getting_started_sec Getting Started
  * 
@@ -39,7 +38,7 @@
  *       - F12 displays framerates / performance data
  *       - - zooms out on some viewing modes.
  *       - + (or =) zooms in on some viewing modes.
- *       - 0 and 9 also effect the camera in some viewing modes.
+ *       - 0 also effect the camera in some viewing modes.
  *       - ctrl+T = toggle team indicators on/off
  *       - ctrl+H = toggle healthbar indicators on/off
  *       - Also, if some controllers are set to keyboard, customizable
@@ -48,94 +47,20 @@
  *               - left:   Keypad 4
  *               - thrust: Keypad 8
  *               - right:  Keypad 6
- *               - fire:   Quote (")
- *               -  special:Semicolon (;)
+ *               - fire:   Enter 
+ *               -  special:Ctrl 
  *               - next:   Closebrace (])
  *               - prev:   Openbrace ([)
  *               - near:   P
- *       - Config 1:
- *               - left:   A
- *               - thrust: S
- *               - right:  D
- *               - fire:   B
- *               - special:V
- *               - next:   F
- *               - prev:   G
- *               - near:   H
- * - Extended Menu:
- *	- Play Game:
- *              - Same as "Melee" now
- *      - Key Tester:
- *              - Use this utility to check keys combination for conflicts.
- *	- Ship Info:
- *		- Here you can get detail information about every ship in the game.
- * 	- Diagnostic:
- *              - Show comlile options and version information. 
- *	- Main Menu:
- *              - This returns to the main menu.
- *		
- * - Teams:
- *      - Select Controller:
- *             - Select the player (i.e. "Player 1" or "Player 2")
- *              you wish to alter from the list on the left, and
- *              the controller (i.e. "Keyboard", "MoronBot") you
- *              want to control that player from the list on the
- *             left.  Then either click on the "Select
- *             Controller" button or double click on the
- *             controller name.
- *	- Change Team #: 
- *	       - This switches the player allys. 
- *	      Note that team 0 mean no allys.
- *      - Change Config #:
- *             -   This switches the configuration used by the
- *              currently highlighted controller.  
- *      - Edit Configuration:
- *             -   This is used to setup up keys when the currently
- *              highlighted player is using the keyboard.  It
- *              may eventually allow the configuration of AIs
- *              and calibration of joysticks.
- *      - Edit Fleet:
- *             -   This button brings up the fleet selection menu for
- *              the currently highlighted player.  
- *      - Main Menu:
- *             -   This returns to the main menu.
- * - Options:
- *      -  Most things on this menu are self-explanatory, but a few
- *         need special mention.
- *
- *      - Gamma correction:
- *             -  This makes things brighter during combat.  This
- *                 should not be changed from the middle of combat,
- *                 or colors could get weird.  
- *      - Antialiasing:
- *             -  If this box is checked then TimeWarp will use
- *                higher quality graphics, but run slower.  
- *      - Color Depth:
- *             -  You cannot change this from the middle of combat.  
- *      -  Camera Mode:
- *             -  This allows you to control what is shown on your
- *                 screen in combat.  
- *
- *             - "Enemy_Discrete"
- *                 is just like Star Control on the PC, where
- *                 the camera moved to keep both you and your
- *                 enemy onscreen, and zoomed in by factors of
- *                 2.
- *             -  "Enemy"
- *                 is like Star Control on the Genesis or 3DO,
- *                 where the camera zoomed in smoothly.
- *             -  "Hero"
- *                 makes the camera stay focused on Player 1,
- *                 and zoom in/out when + and - are pressed.
- *             -  "Everything"
- *                 makes the camera stay on the planet and zoom
- *                 way out so that everything is visible.  This
- *                 mode is slightly buggy (visual artifacts).  
- *
+ * 
+ *   See ingame help for controls description.
+ *  
  * \section development Development
  * 
+ * Full developer documentation can be produced using doxygen tool.
+ * 
  * Following documents describes some of the issues concerning contributing 
- * to Timewarp
+ * to TW-Light
  * 		- \ref coding_page
  * 		- \ref howto_document
  *  
@@ -156,13 +81,10 @@
  *   - The Chorali Extractor
  *   - Confed Cargotran
  *   - Confederation Hornet
- *   - Djinni Lancer
  *   - Drax Griffon
- *   - Earthling Crusader MK2
  *   - Earthling Crusader MK3
  *   - Zekfahan Shocker
  *   - Garash Tyrant
- *   - Hydrovar
  *   - Ilwrath Spider
  *   - Kahr Boomerang
  *   - Re-Koj Assassin
@@ -175,7 +97,7 @@
  *
  * \subsection simplyfy_subsec Simplify and fix melee engine
  * 
- *  We are working on it.
+ *  Almost done.
  * 
  * \subsection TML_subsec Add TimeWarp Markup Language (TML) support
  * 
@@ -183,7 +105,7 @@
  * 
  * \subsection plot_subsec Write plot
  * 
- *  No progress.
+ *  The Plot is fully writen.
  *
  * \subsection plot_impl_subsec  Implement plot with TML
  * 
@@ -206,8 +128,10 @@
  *
  * \section credits_sec Credits
  *
- * TW-Light is derivative work from <a href="timewarp.sourceforge.net">Star Control: TimeWarp</a>
-
+ * - TW-Light is derivative work from <a href="timewarp.sourceforge.net">Star Control: TimeWarp</a>
+ * - Some code and documents were taken from <a href="www.wesnoth.org">Battle for Wesnoth</a>
+ * - UQM Ships description were taken from Ultronomicon (http://uqm.stack.nl/wiki/)
+ * - Some battle music were written by Robeter Productions Inc. 
  */
 
  /*! \page coding_page A guide to a few of the wierder issues with programming for TW-Light.  
@@ -252,23 +176,15 @@
  * \section trivial_conventions_sec Trivial Conventions
  * 
  * It would be nice if the following conventions were followed in TW-Light code:
- * -#  The proper indentation amount is 1 tab.  If you don't like that (or if
- * your editor produces spaces when you hit tab), then try 2 spaces instead.
- * If you don't like that either, AT LEAST BE INTERNALLY CONSISTENT IN YOUR
- * INDENTATION POLICY!  YES, THIS MEANS YOU!!!
- * -#  In the same vein, do not use an editor that transparently replaces N
- * spaces with the "equivalent" tabs.  Or, if you must do so, make sure that
- * your indentation amount exactly matches the tab size.  Otherwise your
- * indentation will apear totally fucked up on other editors with different tab
- * sizes.  And don't use an editor that replaces tabs with spaces either.  
- * Don't use strange characters in file names.  To be specific, the 26 
+ * -#  The proper indentation amount is 2 spaces. If you don't like it, AT LEAST 
+ * BE INTERNALLY CONSISTENT IN YOUR INDENTATION POLICY!  YES, THIS MEANS YOU!!!
+ * -#  Don't use strange characters in file names.  To be specific, the 26 
  * english characters and underscores and up to one period per file name 
  * are okay.  I guess numbers would be ok too.  Use lower case letters, 
  * never upper case.  
  * -# Don't name two source files exactly the same thing, even if they're in 
  * different directories. The same rule applies to headers.  
- * -# All source files should have extensions of either .cpp or .h .  No .c 
- * or .cc files.  Exception: .c files are permitted in the util directory.  
+ * -# All source files should have extensions of either .c .cpp or .h .  No .cc files.    
  * 
  * \section collisions_sec Collisions
  * 
@@ -300,10 +216,11 @@
  * \section report_error_sec Reporting Errors
  * 
  * If you wish to report an error condition, you can say something like:
+ * //simple error message<br>
  * tw_error("Oh no! an error occured!");
- * //simple error message
+ * //error message using more complex printf-style stuff<br>
  * tw_error("This error was brought to you by the letter %c and the number %d", 'g', 3);
- * //error message using more complex printf-style stuff
+ * 
  * When you report an error in this manner, a box will pop up and tell
  * the user your message, and the source file and line number from which
  * tw_error() was called.  The user will be presented with a number of buttons,

Added: trunk/source/games/gdefender.cpp
===================================================================
--- trunk/source/games/gdefender.cpp	2004-09-26 08:30:59 UTC (rev 64)
+++ trunk/source/games/gdefender.cpp	2004-09-26 13:47:54 UTC (rev 65)
@@ -0,0 +1,246 @@
+
+
+#include <stdio.h>   //standard io libary (needed for sprintf)
+#include <allegro.h> //allegro library header
+
+#include "melee.h"          //used by all TW source files.  well, mostly. 
+#include "melee/mgame.h"    //Game stuff
+#include "melee/mcbodies.h" //asteroids & planets
+#include "melee/mship.h"    //ships
+#include "melee/mshot.h"   //shots, missiles, lasers
+#include "melee/mlog.h"     //networking / demo recording / demo playback
+#include "melee/mcontrol.h" //controllers & AIs
+#include "melee/mview.h"    //Views & messages
+#include "melee/mshppan.h"  //ship panels...
+
+#include "melee/mitems.h"  //ship panels...
+#include "melee/manim.h"  //ship panels...
+#include "scp.h"
+#include "other/dialogs.h"
+
+
+// Defender of the Starbase
+
+/// define the starbase
+class DefenderStation : public Orbiter {
+public:
+  double health, maxhealth; ///< current and maximum starbase health
+  int healtime, nexthealtime;   ///< rate & phase of ship healing
+  int regentime, nextregentime; ///< rate & phase of self healing
+  /// handle_damage lets the starbase be hurt & die
+  virtual int handle_damage(SpaceLocation *source, double normal, double direct = 0);
+  /// calculate does the continuous things like regeneration
+  virtual void calculate ();
+  //the constructor.  all game items must have constructors
+  //this one just sets up values for health, etc.
+  DefenderStation ( SpaceSprite *sprite, SpaceLocation *orbit );
+};
+
+
+/// DefenderGame 
+///
+/// Idea:
+///
+/// defend a starbase
+///
+/// Current status:
+///
+/// Seems to be working, but needs more work perhaps I should add a 
+/// high-score table?
+class DefenderGame : public Game 
+{
+public:
+  TeamCode player_team, enemy_team;
+  SpaceSprite *stationsprite; ///< this holds the graphics for the space station
+  
+  ///initialize all pointers to NULL, so that the destructor won't 
+  ///crash if it's called early for some reason
+  virtual void preinit ();
+  
+  virtual ~DefenderGame();
+  
+  virtual void init ( Log *_log ) ;
+
+  //begin the game
+  void restart();
+
+  /// here we check to see if the player lost the game and we add new enemies if it's time for that
+  virtual void calculate ( ) ;
+  /// this is used to display the starbases current health
+  virtual void fps();
+	
+  /// a pointer at the player
+  Control *player;
+
+  /// a pointer at the starbase  
+  DefenderStation *starbase;
+
+  /// rate of enemy ships spawning
+  int time_for_next_attack;
+  /// phase of enemy ships spawning
+  int time_between_attacks;
+
+};
+
+#define defendergame ((DefenderGame*)game)
+
+int DefenderStation::handle_damage ( SpaceLocation *source, double normal, double direct) 
+{
+  double old = health;
+  health -= normal;
+  health -= direct;
+  if (health <= 0) 
+    {
+      add ( new Animation ( this, pos, meleedata.kaboomSprite, 0, 
+			    meleedata.kaboomSprite->frames(), 50, DEPTH_EXPLOSIONS) );
+      state = 0;
+    }
+  return iround(old-health);
+}
+
+DefenderStation::DefenderStation( SpaceSprite *sprite, SpaceLocation *orbit)
+: Orbiter ( sprite, orbit, 600 ) 
+{
+  health = maxhealth = 30;
+  regentime = 6000;
+  nextregentime = 0;
+  healtime = 2000;
+  nexthealtime = 0;
+}
+
+void DefenderStation::calculate ( ) 
+{
+  Orbiter::calculate();
+  if ( (health < maxhealth) && (nextregentime <= game->game_time) ) 
+    {
+      health += 1;
+      nextregentime = game->game_time + regentime;
+    }
+  Ship *ship = defendergame->player->ship;
+  if ( ship && (distance(ship) < 300) && (nexthealtime <= game->game_time) && 
+       (ship->crew < ship->crew_max) && (magnitude_sqr(ship->get_vel() - vel) < 0.01) ) 
+    {
+      ship->handle_damage(this, -1);
+      nexthealtime = game->game_time + healtime;
+      SpaceLocation *l = new PointLaser ( this, palette_color[10], 0, 150, this, ship, 0);
+      game->add ( l );
+      l->set_depth(DEPTH_SHIPS + 0.2);
+    }
+  accelerate(this, trajectory_angle(center), 0.00005, MAX_SPEED);
+  return;
+}
+
+static int num_ships = 4;
+static const char *someships[] = { "thrto", "supbl", "syrpe", "shosc", NULL };
+
+void DefenderGame::calculate ( ) 
+{
+  Game::calculate();
+  static bool first = true;
+  if ((!starbase || !starbase->exists())&& first) 
+    {
+      first = false;
+      starbase = NULL;
+      char buffy[1024];
+      sprintf(buffy, "You lost after %d seconds", game_time/1000);
+      message.print(9999000, 15, buffy);
+    }
+  else if (game_time >= time_for_next_attack) 
+    {
+      time_for_next_attack += time_between_attacks + (random(10000)) - 4000;
+      time_between_attacks -= 10;
+      time_between_attacks = iround(time_between_attacks * 0.975);
+      time_between_attacks += 10;
+      SpaceObject *whatever = create_ship ( channel_none, someships[random(num_ships)], "WussieBot", Vector2(0, 2000), 0, enemy_team);
+      add (whatever);
+    }
+  return;
+}
+
+void DefenderGame::preinit() 
+{
+  Game::preinit();
+  //because the desctructor deals with stationsprite, we have to initialize it here
+  //just in case the normal init() function doesn't get called
+  stationsprite = NULL;
+}
+
+DefenderGame::~DefenderGame() 
+{
+  //we have to manually unload space station graphics since they aren't part of a ship
+  if (stationsprite) 
+    delete stationsprite;
+}
+
+void DefenderGame::fps() 
+{
+  int s = 0;
+  if (starbase) 
+    s = iround(starbase->health);
+  message.print((int)msecs_per_fps, 15, "Current Time: %d", game->game_time / 1000);
+  message.print((int)msecs_per_fps, 12, "Starbase Health: %d", s);
+  int p = 0;
+  if (player->ship) 
+    p = iround(player->ship->getCrew());
+  message.print((int)msecs_per_fps, 12, "Your Health: %d", p);
+}
+
+void DefenderGame::restart() 
+{  
+  for(std::list<SpaceLocation*>::iterator i = item.begin();
+      i != item.end(); i++)
+    {
+      if ((*i)->exists()) 
+	(*i)->die();
+    }
+  game_time = 0;
+	
+  Ship *ship = create_ship("supbl", player, Vector2(500, 200), 270);
+  add(ship);
+  
+  Planet *planet = new Planet ( 0, meleedata.planetSprite, random(3) );
+  add ( planet );
+  
+  starbase =  new DefenderStation ( stationsprite, planet);
+  add ( starbase );
+  starbase->change_owner ( ship );
+  gametargets.add(starbase);
+  
+  time_for_next_attack = game_time + 3 * 1000; // first attack in 3 seconds from now
+  time_between_attacks = 24 * 1000; //24 seconds between attacks
+
+
+  message.out("Defend the starbase!", 30000);
+
+}
+
+void DefenderGame::init( Log * _log) 
+{
+  Game::init(_log);
+  
+  prepare();
+  add ( new Stars() );
+  
+  player = create_control ( channel_server, "Human" );
+  add_focus(player);
+  
+  DATAFILE *tmpdata; 
+  tmpdata = load_datafile_object(data_full_path("gob.dat").c_str(), "station0sprite");
+  if (!tmpdata) 
+    tw_error( "couldn't find gob.dat#station0sprite");
+  stationsprite = new SpaceSprite(tmpdata, 1, SpaceSprite::MASKED, 64);
+  stationsprite->permanent_phase_shift(8);
+  unload_datafile_object(tmpdata);
+
+  this->change_view("Hero");  
+  restart();
+  
+  message.out("An enemy ship will attack it every 20-30 seconds", 20000, 7);
+  message.out("The starbase will heal you if you fly close to", 20000, 7);
+  message.out("  it and match its velocity", 20000, 7);
+  message.out("It can also heal itself, but slowly", 20000, 7);
+  return;
+}
+
+REGISTER_GAME ( DefenderGame, "Defender" )
+

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2004-09-26 08:30:59 UTC (rev 64)
+++ trunk/source/scp.cpp	2004-09-26 13:47:54 UTC (rev 65)
@@ -58,14 +58,47 @@
 #include "melee/mship.h" //remove
 #include "melee/mfleet.h"
 
+
+/// Get SVN revision number from version file (this function work if user does not have subversion)
+std::string GetSVNFromVersionFile()
+{
+  int i;
+  char buffy [16000] = {0};
+  PACKFILE *f;
+  
+  f = pack_fopen (data_full_path("version.txt").c_str(), F_READ);
+  if (!f)
+    {
+      tw_error("Unable to retrive version information");
+    }
+  else 
+    {
+      i = pack_fread (buffy, 15999, f);
+      pack_fclose(f);
+      buffy[i] = 0;
+    }
+  char *s = strchr(buffy, 'r');
+  if(!s)
+    {
+      return "";
+    }
+
+  char ver[30] = {0};
+  sscanf(s+1, "%s", ver);
+  return ver;
+}
+
 std::string tw_version() 
 {
   STACKTRACE;
   std::string tw_version_string;
-	
+
+  std::string tw_svn_version = TW_SVNVERSION;
+  if(tw_svn_version=="exported"||tw_svn_version == "")
+    tw_svn_version = GetSVNFromVersionFile();
   tw_version_string += std::string(APPLICATION_NAME) + " "  + std::string(TW_MAJOR_VERSION) 
     + "r" 
-    + std::string(TW_SVNVERSION)
+    + tw_svn_version
     + " Built: "
     + __DATE__
     + " "

Modified: trunk/sources.lst
===================================================================
--- trunk/sources.lst	2004-09-26 08:30:59 UTC (rev 64)
+++ trunk/sources.lst	2004-09-26 13:47:54 UTC (rev 65)
@@ -19,6 +19,7 @@
 source/util/base.cpp
 source/games/ggob.cpp
 source/games/gflmelee.cpp
+source/games/gdefender.cpp
 source/melee/mlog.cpp
 source/melee/mitems.cpp
 source/melee/mnet1.cpp



From yurand at sheep.berlios.de  Sun Sep 26 20:31:47 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 26 Sep 2004 20:31:47 +0200
Subject: [Tw-light-svn] r66 - in trunk: gamedata/default_ini/ships source
Message-ID: <200409261831.i8QIVlYp006988@sheep.berlios.de>

Author: yurand
Date: 2004-09-26 20:31:46 +0200 (Sun, 26 Sep 2004)
New Revision: 66

Modified:
   trunk/gamedata/default_ini/ships/shpalabc.ini
   trunk/gamedata/default_ini/ships/shpandgu.ini
   trunk/gamedata/default_ini/ships/shparisk.ini
   trunk/gamedata/default_ini/ships/shpbahbu.ini
   trunk/gamedata/default_ini/ships/shpbipka.ini
   trunk/gamedata/default_ini/ships/shpchebr.ini
   trunk/gamedata/default_ini/ships/shpchmav.ini
   trunk/gamedata/default_ini/ships/shpchoex.ini
   trunk/gamedata/default_ini/ships/shpconca.ini
   trunk/gamedata/default_ini/ships/shpconho.ini
   trunk/gamedata/default_ini/ships/shpdragr.ini
   trunk/gamedata/default_ini/ships/shpdruma.ini
   trunk/gamedata/default_ini/ships/shpearc3.ini
   trunk/gamedata/default_ini/ships/shpearcr.ini
   trunk/gamedata/default_ini/ships/shpforsh.ini
   trunk/gamedata/default_ini/ships/shpgarty.ini
   trunk/gamedata/default_ini/ships/shpilwav.ini
   trunk/gamedata/default_ini/ships/shpilwsp.ini
   trunk/gamedata/default_ini/ships/shpkahbo.ini
   trunk/gamedata/default_ini/ships/shpkohma.ini
   trunk/gamedata/default_ini/ships/shpkzedr.ini
   trunk/gamedata/default_ini/ships/shpmeltr.ini
   trunk/gamedata/default_ini/ships/shpmmrxf.ini
   trunk/gamedata/default_ini/ships/shpmycpo.ini
   trunk/gamedata/default_ini/ships/shporzne.ini
   trunk/gamedata/default_ini/ships/shppkufu.ini
   trunk/gamedata/default_ini/ships/shprogsq.ini
   trunk/gamedata/default_ini/ships/shpshosc.ini
   trunk/gamedata/default_ini/ships/shpslypr.ini
   trunk/gamedata/default_ini/ships/shpspael.ini
   trunk/gamedata/default_ini/ships/shpstaba.ini
   trunk/gamedata/default_ini/ships/shpsupbl.ini
   trunk/gamedata/default_ini/ships/shpsyrpe.ini
   trunk/gamedata/default_ini/ships/shptauar.ini
   trunk/gamedata/default_ini/ships/shptauda.ini
   trunk/gamedata/default_ini/ships/shptausl.ini
   trunk/gamedata/default_ini/ships/shptauto.ini
   trunk/gamedata/default_ini/ships/shpthrto.ini
   trunk/gamedata/default_ini/ships/shpumgdr.ini
   trunk/gamedata/default_ini/ships/shputwju.ini
   trunk/gamedata/default_ini/ships/shpvuxin.ini
   trunk/gamedata/default_ini/ships/shpyehte.ini
   trunk/gamedata/default_ini/ships/shpzeksh.ini
   trunk/gamedata/default_ini/ships/shpzfpst.ini
   trunk/source/scp.cpp
Log:
Old incapable ship ini files will be replaced with new in user ini folder.


Modified: trunk/gamedata/default_ini/ships/shpalabc.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpalabc.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpalabc.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -1,27 +1,28 @@
 [Info]
-TWCost  = 90
+TWCost = 90
 Name1 = Alary
 Name2 = BattleCruiser
 Origin = TWs
 Coders = Tau
 code = AlaryBC
+Version = 65M
 
 [Ship]
-Crew           = 42
-CrewMax        = 42
-Batt           = 42
-BattMax        = 42
-SpeedMax       = 20
-AccelRate      = 4
-TurnRate       = 8
+Crew = 42
+CrewMax = 42
+Batt = 42
+BattMax = 42
+SpeedMax = 20
+AccelRate = 4
+TurnRate = 8
 RechargeAmount = 1
-RechargeRate   = 2
-WeaponDrain    = 24
-WeaponRate     = 18
-SpecialDrain   = 2
-SpecialRate    = 6
-HotspotRate    = 5
-Mass           = 75
+RechargeRate = 2
+WeaponDrain = 24
+WeaponRate = 18
+SpecialDrain = 2
+SpecialRate = 6
+HotspotRate = 5
+Mass = 75
 EnginesArmour = 12
 
 [Weapon]
@@ -29,7 +30,7 @@
 Accel = 8
 TurnRate = 17
 Lifetime = 5200
-Armour   = 3
+Armour = 3
 Proximity = 15
 WarheadRange = 39.5
 WarheadVelocity = 62
@@ -104,16 +105,16 @@
 
 
 [Objects]
-ShipSprites      = 1r128
-WeaponSprites    = 1r +alpha
-WeaponSamples    = 3
-WeaponExplosion  = 10 +alpha
-SpecialSprites   = 1r +alpha
-SpecialSamples   = 2
+ShipSprites = 1r128
+WeaponSprites = 1r +alpha
+WeaponSamples = 3
+WeaponExplosion = 10 +alpha
+SpecialSprites = 1r +alpha
+SpecialSamples = 2
 SpecialExplosion = 10 +alpha
-ExtraSprites     = 1r +alpha
-ExtraSamples     = 2
-ExtraExplosion   = 10 +alpha
+ExtraSprites = 1r +alpha
+ExtraSamples = 2
+ExtraExplosion = 10 +alpha
 ExtraExtraSprites0_ = 1r128 +alpha
 ExtraExtraSprites1_ = 1r128 +alpha
 ExtraExtraSprites2_ = 4 +alpha
@@ -123,19 +124,19 @@
 ExtraExtraSprites6_ = 2 +alpha
 ExtraExtraSprites7_ = 12 +alpha
 ExtraExtraSprites8_ = 12 +alpha
-PanelBitmaps     = 15
+PanelBitmaps = 15
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpalabc/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpalabc/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpalabc/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpalabc/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpalabc/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpalabc/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpalabc/SHIP_P06_PCX.bmp
-PanelBitmaps7  = images/ships/shpalabc/ship_p10.bmp
-PanelBitmaps8  = images/ships/shpalabc/ship_p11.bmp
-PanelBitmaps9  = images/ships/shpalabc/ship_p12.bmp
+PanelBitmaps0 = images/ships/shpalabc/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpalabc/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpalabc/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpalabc/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpalabc/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpalabc/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpalabc/SHIP_P06_PCX.bmp
+PanelBitmaps7 = images/ships/shpalabc/ship_p10.bmp
+PanelBitmaps8 = images/ships/shpalabc/ship_p11.bmp
+PanelBitmaps9 = images/ships/shpalabc/ship_p12.bmp
 PanelBitmaps10 = images/ships/shpalabc/ship_p13.bmp
 PanelBitmaps11 = images/ships/shpalabc/ship_p20.bmp
 PanelBitmaps12 = images/ships/shpalabc/ship_p21.bmp

Modified: trunk/gamedata/default_ini/ships/shpandgu.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpandgu.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpandgu.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -7,6 +7,7 @@
 Origin = UQM
 Code = AndrosynthGuardian
 Coders = The Fly
+Version = 65M
 
 [Ship]
 Crew = 20
@@ -84,29 +85,29 @@
 [Sound]
 WeaponSample0 = sound/ships/shpandgu/WAVE_A01_WAV.wav
 
-SpecialSample0 =sound/ships/shpandgu/WAVE_B01_WAV.wav
+SpecialSample0 = sound/ships/shpandgu/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 1r11 +alpha
-WeaponSamples    = 1
-WeaponExplosion  = 6 +alpha
-SpecialSprites   = 1r +alpha
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r11 +alpha
+WeaponSamples = 1
+WeaponExplosion = 6 +alpha
+SpecialSprites = 1r +alpha
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 1
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 1
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpandgu/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpandgu/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpandgu/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpandgu/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpandgu/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpandgu/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpandgu/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpandgu/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpandgu/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpandgu/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpandgu/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpandgu/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpandgu/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpandgu/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpandgu/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shparisk.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shparisk.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shparisk.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -8,6 +8,7 @@
 Origin = UQM
 Coders = The Fly
 Code = ArilouSkiff
+Version = 65M
 
 [Ship]
 Crew = 6
@@ -67,29 +68,29 @@
 [Sound]
 WeaponSample0 = sound/ships/shparisk/WAVE_A01_WAV.wav
 
-SpecialSample0 =sound/ships/shparisk/WAVE_B01_WAV.wav
+SpecialSample0 = sound/ships/shparisk/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 0
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 40 +alpha
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 0
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 40 +alpha
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shparisk/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shparisk/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shparisk/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shparisk/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shparisk/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shparisk/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shparisk/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shparisk/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shparisk/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shparisk/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shparisk/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shparisk/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shparisk/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shparisk/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shparisk/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpbahbu.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpbahbu.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpbahbu.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -1,44 +1,45 @@
 [Info]
 Origin = TW
-TWCost  = 20
+TWCost = 20
 Name = Bahoid Buzzsaw
 Name1 = Bahoid
 Name2 = Buzzsaw
 Coders = Reddish
 Code = BahaoidBuzzsaw
+Version = 65M
 
 [Ship]
-Crew           = 24
-CrewMax        = 24
-Batt           = 20
-BattMax        = 20
-SpeedMax       = 25
-AccelRate      = 6
-TurnRate       = 4
+Crew = 24
+CrewMax = 24
+Batt = 20
+BattMax = 20
+SpeedMax = 25
+AccelRate = 6
+TurnRate = 4
 RechargeAmount = 1
-RechargeRate   = 4
-WeaponDrain    = 0
-WeaponRate     = 0
-SpecialDrain   = 4
-SpecialRate    = 10
-HotspotRate    = 2
-Mass           = 12
+RechargeRate = 4
+WeaponDrain = 0
+WeaponRate = 0
+SpecialDrain = 4
+SpecialRate = 10
+HotspotRate = 2
+Mass = 12
 
 [Weapon]
-Range    = 2
-Damage   = 1
-Speed    = .8
-Color    = 10
+Range = 2
+Damage = 1
+Speed = .8
+Color = 10
 
 [Special]
-Range    = 20
+Range = 20
 Velocity = 10
-Damage   = 6
-Armour   = 10
-Timer    = 13000
-Radius   = 8
-Seek     = 5.5
-VelSeek  = 120
+Damage = 6
+Armour = 10
+Timer = 13000
+Radius = 8
+Seek = 5.5
+VelSeek = 120
 Number = 2
 
 [AI3_Default]
@@ -57,29 +58,29 @@
 WeaponSample0 = sound/ships/shpbahbu/WAVE_A01_WAV.wav
 WeaponSample1 = sound/ships/shpbahbu/WAVE_A02_WAV.wav
 
-SpecialSample0 =sound/ships/shpbahbu/WAVE_B01_WAV.wav
+SpecialSample0 = sound/ships/shpbahbu/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 0
-WeaponSamples    = 2
-WeaponExplosion  = 0
-SpecialSprites   = 1r
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 0
+WeaponSamples = 2
+WeaponExplosion = 0
+SpecialSprites = 1r
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpbahbu/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpbahbu/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpbahbu/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpbahbu/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpbahbu/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpbahbu/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpbahbu/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpbahbu/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpbahbu/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpbahbu/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpbahbu/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpbahbu/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpbahbu/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpbahbu/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpbahbu/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpbipka.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpbipka.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpbipka.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -8,6 +8,7 @@
 Sfx = Forevian
 Ditty = Forevian
 Code = BipoleKatamaran
+Version = 65M
 
 [Ship]
 Crew = 12
@@ -65,31 +66,31 @@
 WeaponSample9 = sound/ships/shpbipka/WAVE_A10_WAV.wav
 WeaponSample10 = sound/ships/shpbipka/WAVE_A11_WAV.wav
 
-SpecialSample0 =sound/ships/shpbipka/WAVE_B01_WAV.wav
+SpecialSample0 = sound/ships/shpbipka/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 11
-WeaponExplosion  = 0
-SpecialSprites   = 1r
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 11
+WeaponExplosion = 0
+SpecialSprites = 1r
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 9
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 9
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpbipka/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpbipka/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpbipka/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpbipka/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpbipka/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpbipka/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpbipka/SHIP_P06_PCX.bmp
-PanelBitmaps7  = images/ships/shpbipka/SHIP_P07_PCX.bmp
-PanelBitmaps8  = images/ships/shpbipka/SHIP_P08_PCX.bmp
+PanelBitmaps0 = images/ships/shpbipka/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpbipka/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpbipka/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpbipka/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpbipka/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpbipka/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpbipka/SHIP_P06_PCX.bmp
+PanelBitmaps7 = images/ships/shpbipka/SHIP_P07_PCX.bmp
+PanelBitmaps8 = images/ships/shpbipka/SHIP_P08_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpbipka/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpchebr.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpchebr.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpchebr.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = ChenjesuBroodhome
+Version = 65M
 
 [Ship]
 Crew = 36
@@ -82,26 +83,26 @@
 
 [Objects]
 
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 1
-WeaponExplosion  = 20 +alpha
-SpecialSprites   = 1r
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 20 +alpha
+SpecialSprites = 1r
+SpecialSamples = 1
 SpecialExplosion = 20 +alpha
-ExtraSprites     = 1r
-ExtraSamples     = 3
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 1r
+ExtraSamples = 3
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpchebr/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpchebr/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpchebr/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpchebr/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpchebr/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpchebr/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpchebr/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpchebr/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpchebr/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpchebr/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpchebr/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpchebr/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpchebr/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpchebr/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpchebr/SHIP_S_00_TGA.bmp
@@ -152,4 +153,4 @@
 SpecialExplosion18 = images/ships/shpchebr/SHOT_D_18_TGA.bmp
 SpecialExplosion19 = images/ships/shpchebr/SHOT_D_19_TGA.bmp
 
-ExtraSprites0 = images/ships/shpchebr/SHOT_E_00_TGA.bmp
\ No newline at end of file
+ExtraSprites0 = images/ships/shpchebr/SHOT_E_00_TGA.bmp

Modified: trunk/gamedata/default_ini/ships/shpchmav.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpchmav.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpchmav.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = ChmmrAvatar
+Version = 65M
 
 [Ship]
 Crew = 42
@@ -75,26 +76,26 @@
 
 [Objects]
 
-ShipSprites      = 1r
-WeaponSprites    = 0
-WeaponSamples    = 1
-WeaponExplosion  = 40 +alpha
-SpecialSprites   = 0
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 0
+WeaponSamples = 1
+WeaponExplosion = 40 +alpha
+SpecialSprites = 0
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 64
-ExtraSamples     = 1
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 64
+ExtraSamples = 1
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpchmav/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpchmav/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpchmav/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpchmav/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpchmav/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpchmav/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpchmav/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpchmav/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpchmav/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpchmav/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpchmav/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpchmav/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpchmav/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpchmav/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpchmav/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpchoex.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpchoex.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpchoex.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -1,56 +1,57 @@
 [Info]
-TWCost  = 14
+TWCost = 14
 Name1 = Chorali
 Name2 = Extractor
 Origin = TW
 Coder = Culture20
 Code = ChoraliExtractor
+Version = 65M
 
 [Ship]
-Crew           = 18
-CrewMax        = 18
-Batt           = 20
-BattMax        = 20
-SpeedMax       = 46	; 40
-AccelRate      = 10
-TurnRate       = 2
+Crew = 18
+CrewMax = 18
+Batt = 20
+BattMax = 20
+SpeedMax = 46	; 40
+AccelRate = 10
+TurnRate = 2
 RechargeAmount = 1
-RechargeRate   = 3
-WeaponDrain    = 8
-WeaponRate     = 4
-SpecialDrain   = 1
-SpecialRate    = 0
-HotspotRate    = 4
-Mass           = 14
+RechargeRate = 3
+WeaponDrain = 8
+WeaponRate = 4
+SpecialDrain = 1
+SpecialRate = 0
+HotspotRate = 4
+Mass = 14
 
 [Weapon]
-Frames   = 6000
-Damage   = 1
+Frames = 6000
+Damage = 1
 
 [AsteroidMissile]
-Range    = 40	; 60
+Range = 40	; 60
 Velocity = 55	; 80
-Damage   = 2
-Armour   = 1
+Damage = 2
+Armour = 1
 TurnRate = 2
 
 [Special]
-Force    = 255
+Force = 255
 
 [Tractor]
-Range    = 6
-PushForce= 14
-PullForce= 1.5	; 1.0
-MaxColorR   = 0
-MaxColorG   = 160
-MaxColorB   = 255
-MinColorR   = 0
-MinColorG   = 0
-MinColorB   = 160
-Rate     = 1
-Damage   = 0
+Range = 6
+PushForce = 14
+PullForce = 1.5	; 1.0
+MaxColorR = 0
+MaxColorG = 160
+MaxColorB = 255
+MinColorR = 0
+MinColorG = 0
+MinColorB = 160
+Rate = 1
+Damage = 0
 MaxBeams = 3
-Spread   = 60
+Spread = 60
 
 [AI3_Default]
 Weapon_Range = 9
@@ -79,26 +80,26 @@
 ExtraSample1 = sound/ships/shpchoex/WAVE_C01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 10
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 10
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 1r
-ExtraSamples     = 2
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 1r
+ExtraSamples = 2
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpchoex/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpchoex/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpchoex/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpchoex/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpchoex/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpchoex/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpchoex/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpchoex/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpchoex/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpchoex/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpchoex/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpchoex/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpchoex/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpchoex/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpchoex/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpconca.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpconca.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpconca.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -5,6 +5,7 @@
 Origin = TW
 Coders = Corona688
 Code = ConfedCargotran
+Version = 65M
 
 [Ship]
 Crew = 6
@@ -50,26 +51,26 @@
 
 [Objects]
 
-ShipSprites      = 1r
-WeaponSprites    = 3r
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 1r
-SpecialSamples   = 2
+ShipSprites = 1r
+WeaponSprites = 3r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 1r
+SpecialSamples = 2
 SpecialExplosion = 0
-ExtraSprites     = 3r
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 3r
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpconca/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpconca/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpconca/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpconca/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpconca/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpconca/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpconca/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpconca/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpconca/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpconca/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpconca/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpconca/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpconca/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpconca/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpconca/SHIP_X00_BMP.bmp

Modified: trunk/gamedata/default_ini/ships/shpconho.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpconho.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpconho.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -6,6 +6,7 @@
 Origin = TW
 Coders = Slag-786B
 Code = ConfederationHornet
+Version = 65M
 
 [Ship]
 Crew = 1
@@ -66,36 +67,36 @@
 SpecialSample0 = sound/ships/shpconho/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 1r
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 1r
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 17
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 17
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpconho/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpconho/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpconho/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpconho/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpconho/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpconho/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpconho/SHIP_P06_PCX.bmp
-PanelBitmaps7  = images/ships/shpconho/SHIP_P07_PCX.bmp
-PanelBitmaps8  = images/ships/shpconho/SHIP_P08_PCX.bmp
-PanelBitmaps9  = images/ships/shpconho/SHIP_P09_PCX.bmp
-PanelBitmaps10  = images/ships/shpconho/SHIP_P10_PCX.bmp
-PanelBitmaps11  = images/ships/shpconho/SHIP_P11_PCX.bmp
-PanelBitmaps12  = images/ships/shpconho/SHIP_P12_PCX.bmp
-PanelBitmaps13  = images/ships/shpconho/SHIP_P13_PCX.bmp
-PanelBitmaps14  = images/ships/shpconho/SHIP_P14_PCX.bmp
-PanelBitmaps15  = images/ships/shpconho/SHIP_P15_PCX.bmp
-PanelBitmaps16  = images/ships/shpconho/SHIP_P16_PCX.bmp
+PanelBitmaps0 = images/ships/shpconho/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpconho/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpconho/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpconho/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpconho/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpconho/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpconho/SHIP_P06_PCX.bmp
+PanelBitmaps7 = images/ships/shpconho/SHIP_P07_PCX.bmp
+PanelBitmaps8 = images/ships/shpconho/SHIP_P08_PCX.bmp
+PanelBitmaps9 = images/ships/shpconho/SHIP_P09_PCX.bmp
+PanelBitmaps10 = images/ships/shpconho/SHIP_P10_PCX.bmp
+PanelBitmaps11 = images/ships/shpconho/SHIP_P11_PCX.bmp
+PanelBitmaps12 = images/ships/shpconho/SHIP_P12_PCX.bmp
+PanelBitmaps13 = images/ships/shpconho/SHIP_P13_PCX.bmp
+PanelBitmaps14 = images/ships/shpconho/SHIP_P14_PCX.bmp
+PanelBitmaps15 = images/ships/shpconho/SHIP_P15_PCX.bmp
+PanelBitmaps16 = images/ships/shpconho/SHIP_P16_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpconho/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpdragr.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpdragr.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpdragr.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -5,6 +5,7 @@
 Origin = TW
 Coders = Launchpad
 Code = DraxGryphon
+Version = 65M
 
 [Ship]
 Crew = 24
@@ -64,26 +65,26 @@
 
 [Objects]
 
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 2
-WeaponExplosion  = 0
-SpecialSprites   = 1r
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 2
+WeaponExplosion = 0
+SpecialSprites = 1r
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpdragr/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpdragr/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpdragr/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpdragr/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpdragr/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpdragr/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpdragr/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpdragr/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpdragr/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpdragr/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpdragr/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpdragr/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpdragr/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpdragr/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpdragr/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpdruma.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpdruma.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpdruma.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -6,6 +6,7 @@
 Origin = UQM
 Coders = The Fly
 Code = DruugeMauler
+Version = 65M
 
 [Ship]
 Crew = 14
@@ -64,26 +65,26 @@
 SpecialSample0 = sound/ships/shpdruma/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 1
-WeaponExplosion  = 5
-SpecialSprites   = 0
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 5
+SpecialSprites = 0
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpdruma/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpdruma/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpdruma/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpdruma/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpdruma/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpdruma/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpdruma/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpdruma/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpdruma/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpdruma/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpdruma/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpdruma/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpdruma/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpdruma/SHIP_P06_PCX.bmp
 
 ShipSprites0 = images/ships/shpdruma/SHIP_S00_PCX.bmp
 

Modified: trunk/gamedata/default_ini/ships/shpearc3.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpearc3.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpearc3.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -5,6 +5,7 @@
 Origin = TW
 Coders = Tau
 Code = EarthlingCruiserMk3
+Version = 65M
 
 [Ship]
 Crew = 24
@@ -74,27 +75,27 @@
 ExtraSample0 = sound/ships/shpearc3/WAVE_C00_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 33 +alpha
-WeaponSamples    = 2
-WeaponExplosion  = 20 +alpha
-SpecialSprites   = 1 +alpha
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 33 +alpha
+WeaponSamples = 2
+WeaponExplosion = 20 +alpha
+SpecialSprites = 1 +alpha
+SpecialSamples = 1
 SpecialExplosion = 1 +alpha
-ExtraSprites     = 0
-ExtraSamples     = 1
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 1
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpearc3/ship_p00.bmp
-PanelBitmaps1  = images/ships/shpearc3/ship_p01.bmp
-PanelBitmaps2  = images/ships/shpearc3/ship_p02.bmp
-PanelBitmaps3  = images/ships/shpearc3/ship_p03.bmp
-PanelBitmaps4  = images/ships/shpearc3/ship_p04.bmp
-PanelBitmaps5  = images/ships/shpearc3/ship_p05.bmp
-PanelBitmaps6  = images/ships/shpearc3/ship_p06.bmp
+PanelBitmaps0 = images/ships/shpearc3/ship_p00.bmp
+PanelBitmaps1 = images/ships/shpearc3/ship_p01.bmp
+PanelBitmaps2 = images/ships/shpearc3/ship_p02.bmp
+PanelBitmaps3 = images/ships/shpearc3/ship_p03.bmp
+PanelBitmaps4 = images/ships/shpearc3/ship_p04.bmp
+PanelBitmaps5 = images/ships/shpearc3/ship_p05.bmp
+PanelBitmaps6 = images/ships/shpearc3/ship_p06.bmp
 
 ShipSprites0 = images/ships/shpearc3/SHIP_S0_00_BMP.bmp
 

Modified: trunk/gamedata/default_ini/ships/shpearcr.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpearcr.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpearcr.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = EarthlingCruiser
+Version = 65M
 
 [Ship]
 Crew = 18
@@ -71,26 +72,26 @@
 SpecialSample0 = sound/ships/shpearcr/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 1
-WeaponExplosion  = 10 +alpha
-SpecialSprites   = 0
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 10 +alpha
+SpecialSprites = 0
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpearcr/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpearcr/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpearcr/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpearcr/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpearcr/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpearcr/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpearcr/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpearcr/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpearcr/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpearcr/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpearcr/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpearcr/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpearcr/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpearcr/SHIP_P06_PCX.bmp
 
 ShipSprites0 = images/ships/shpearcr/SHIP_S01_PCX.bmp
 

Modified: trunk/gamedata/default_ini/ships/shpforsh.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpforsh.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpforsh.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -4,6 +4,7 @@
 Name2 = Shocker
 Origin = TW
 Code = ForevianShocker
+Version = 65M
 
 [Ship]
 Crew = 42
@@ -57,27 +58,27 @@
 SpecialSample2 = sound/ships/shpforsh/WAVE_B03_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 32
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 10
-SpecialSamples   = 3
+ShipSprites = 1r
+WeaponSprites = 32
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 10
+SpecialSamples = 3
 SpecialExplosion = 0
-ExtraSprites     = 32
-ExtraSamples     = 0
-ExtraExplosion   = 32
-PanelBitmaps     = 7
+ExtraSprites = 32
+ExtraSamples = 0
+ExtraExplosion = 32
+PanelBitmaps = 7
 
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpforsh/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpforsh/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpforsh/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpforsh/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpforsh/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpforsh/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpforsh/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpforsh/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpforsh/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpforsh/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpforsh/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpforsh/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpforsh/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpforsh/SHIP_P06_PCX.bmp
 
 ShipSprites0 = images/ships/shpforsh/SHIP_SS_000_BMP.bmp
 
@@ -158,36 +159,36 @@
 ExtraSprites30 = images/ships/shpforsh/SHOT_ER_PRIMARY0031_BMP.bmp
 ExtraSprites31 = images/ships/shpforsh/SHOT_ER_PRIMARY0032_BMP.bmp
 
-ExtraExplosion0 = images/ships/shpforsh/SHOT_FR_LIGHTNING0000_BMP.bmp 
-ExtraExplosion1 = images/ships/shpforsh/SHOT_FR_LIGHTNING0001_BMP.bmp 
-ExtraExplosion2 = images/ships/shpforsh/SHOT_FR_LIGHTNING0002_BMP.bmp 
-ExtraExplosion3 = images/ships/shpforsh/SHOT_FR_LIGHTNING0003_BMP.bmp 
-ExtraExplosion4 = images/ships/shpforsh/SHOT_FR_LIGHTNING0004_BMP.bmp 
-ExtraExplosion5 = images/ships/shpforsh/SHOT_FR_LIGHTNING0005_BMP.bmp 
-ExtraExplosion6 = images/ships/shpforsh/SHOT_FR_LIGHTNING0006_BMP.bmp 
-ExtraExplosion7 = images/ships/shpforsh/SHOT_FR_LIGHTNING0007_BMP.bmp 
-ExtraExplosion8 = images/ships/shpforsh/SHOT_FR_LIGHTNING0008_BMP.bmp 
-ExtraExplosion9 = images/ships/shpforsh/SHOT_FR_LIGHTNING0009_BMP.bmp 
-ExtraExplosion10 = images/ships/shpforsh/SHOT_FR_LIGHTNING0010_BMP.bmp 
-ExtraExplosion11 = images/ships/shpforsh/SHOT_FR_LIGHTNING0011_BMP.bmp 
-ExtraExplosion12 = images/ships/shpforsh/SHOT_FR_LIGHTNING0012_BMP.bmp 
-ExtraExplosion13 = images/ships/shpforsh/SHOT_FR_LIGHTNING0013_BMP.bmp 
-ExtraExplosion14 = images/ships/shpforsh/SHOT_FR_LIGHTNING0014_BMP.bmp 
-ExtraExplosion15 = images/ships/shpforsh/SHOT_FR_LIGHTNING0015_BMP.bmp 
-ExtraExplosion16 = images/ships/shpforsh/SHOT_FR_LIGHTNING0016_BMP.bmp 
-ExtraExplosion17 = images/ships/shpforsh/SHOT_FR_LIGHTNING0017_BMP.bmp 
-ExtraExplosion18 = images/ships/shpforsh/SHOT_FR_LIGHTNING0018_BMP.bmp 
-ExtraExplosion19 = images/ships/shpforsh/SHOT_FR_LIGHTNING0019_BMP.bmp 
-ExtraExplosion20 = images/ships/shpforsh/SHOT_FR_LIGHTNING0020_BMP.bmp 
-ExtraExplosion21 = images/ships/shpforsh/SHOT_FR_LIGHTNING0021_BMP.bmp 
-ExtraExplosion22 = images/ships/shpforsh/SHOT_FR_LIGHTNING0022_BMP.bmp 
-ExtraExplosion23 = images/ships/shpforsh/SHOT_FR_LIGHTNING0023_BMP.bmp 
-ExtraExplosion24 = images/ships/shpforsh/SHOT_FR_LIGHTNING0024_BMP.bmp 
-ExtraExplosion25 = images/ships/shpforsh/SHOT_FR_LIGHTNING0025_BMP.bmp 
-ExtraExplosion26 = images/ships/shpforsh/SHOT_FR_LIGHTNING0026_BMP.bmp 
-ExtraExplosion27 = images/ships/shpforsh/SHOT_FR_LIGHTNING0027_BMP.bmp 
-ExtraExplosion28 = images/ships/shpforsh/SHOT_FR_LIGHTNING0028_BMP.bmp 
-ExtraExplosion29 = images/ships/shpforsh/SHOT_FR_LIGHTNING0029_BMP.bmp 
-ExtraExplosion30 = images/ships/shpforsh/SHOT_FR_LIGHTNING0030_BMP.bmp 
-ExtraExplosion31 = images/ships/shpforsh/SHOT_FR_LIGHTNING0031_BMP.bmp 
-              
\ No newline at end of file
+ExtraExplosion0 = images/ships/shpforsh/SHOT_FR_LIGHTNING0000_BMP.bmp
+ExtraExplosion1 = images/ships/shpforsh/SHOT_FR_LIGHTNING0001_BMP.bmp
+ExtraExplosion2 = images/ships/shpforsh/SHOT_FR_LIGHTNING0002_BMP.bmp
+ExtraExplosion3 = images/ships/shpforsh/SHOT_FR_LIGHTNING0003_BMP.bmp
+ExtraExplosion4 = images/ships/shpforsh/SHOT_FR_LIGHTNING0004_BMP.bmp
+ExtraExplosion5 = images/ships/shpforsh/SHOT_FR_LIGHTNING0005_BMP.bmp
+ExtraExplosion6 = images/ships/shpforsh/SHOT_FR_LIGHTNING0006_BMP.bmp
+ExtraExplosion7 = images/ships/shpforsh/SHOT_FR_LIGHTNING0007_BMP.bmp
+ExtraExplosion8 = images/ships/shpforsh/SHOT_FR_LIGHTNING0008_BMP.bmp
+ExtraExplosion9 = images/ships/shpforsh/SHOT_FR_LIGHTNING0009_BMP.bmp
+ExtraExplosion10 = images/ships/shpforsh/SHOT_FR_LIGHTNING0010_BMP.bmp
+ExtraExplosion11 = images/ships/shpforsh/SHOT_FR_LIGHTNING0011_BMP.bmp
+ExtraExplosion12 = images/ships/shpforsh/SHOT_FR_LIGHTNING0012_BMP.bmp
+ExtraExplosion13 = images/ships/shpforsh/SHOT_FR_LIGHTNING0013_BMP.bmp
+ExtraExplosion14 = images/ships/shpforsh/SHOT_FR_LIGHTNING0014_BMP.bmp
+ExtraExplosion15 = images/ships/shpforsh/SHOT_FR_LIGHTNING0015_BMP.bmp
+ExtraExplosion16 = images/ships/shpforsh/SHOT_FR_LIGHTNING0016_BMP.bmp
+ExtraExplosion17 = images/ships/shpforsh/SHOT_FR_LIGHTNING0017_BMP.bmp
+ExtraExplosion18 = images/ships/shpforsh/SHOT_FR_LIGHTNING0018_BMP.bmp
+ExtraExplosion19 = images/ships/shpforsh/SHOT_FR_LIGHTNING0019_BMP.bmp
+ExtraExplosion20 = images/ships/shpforsh/SHOT_FR_LIGHTNING0020_BMP.bmp
+ExtraExplosion21 = images/ships/shpforsh/SHOT_FR_LIGHTNING0021_BMP.bmp
+ExtraExplosion22 = images/ships/shpforsh/SHOT_FR_LIGHTNING0022_BMP.bmp
+ExtraExplosion23 = images/ships/shpforsh/SHOT_FR_LIGHTNING0023_BMP.bmp
+ExtraExplosion24 = images/ships/shpforsh/SHOT_FR_LIGHTNING0024_BMP.bmp
+ExtraExplosion25 = images/ships/shpforsh/SHOT_FR_LIGHTNING0025_BMP.bmp
+ExtraExplosion26 = images/ships/shpforsh/SHOT_FR_LIGHTNING0026_BMP.bmp
+ExtraExplosion27 = images/ships/shpforsh/SHOT_FR_LIGHTNING0027_BMP.bmp
+ExtraExplosion28 = images/ships/shpforsh/SHOT_FR_LIGHTNING0028_BMP.bmp
+ExtraExplosion29 = images/ships/shpforsh/SHOT_FR_LIGHTNING0029_BMP.bmp
+ExtraExplosion30 = images/ships/shpforsh/SHOT_FR_LIGHTNING0030_BMP.bmp
+ExtraExplosion31 = images/ships/shpforsh/SHOT_FR_LIGHTNING0031_BMP.bmp
+              

Modified: trunk/gamedata/default_ini/ships/shpgarty.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpgarty.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpgarty.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -6,6 +6,7 @@
 Original = Idea = Kwon
 Coders = Tamaraw
 Code = GarashTyrant
+Version = 65M
 
 [Ship]
 Crew = 42
@@ -76,26 +77,26 @@
 ExtraSample0 = sound/ships/shpgarty/WAVE_C03_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 3r
-WeaponSamples    = 1
-WeaponExplosion  = 7
-SpecialSprites   = 7
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 3r
+WeaponSamples = 1
+WeaponExplosion = 7
+SpecialSprites = 7
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 1r
-ExtraSamples     = 3
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 1r
+ExtraSamples = 3
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpgarty/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpgarty/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpgarty/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpgarty/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpgarty/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpgarty/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpgarty/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpgarty/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpgarty/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpgarty/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpgarty/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpgarty/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpgarty/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpgarty/SHIP_P06_PCX.bmp
 
 ShipSprites0 = images/ships/shpgarty/SHIP_S01_PCX.bmp
 
@@ -119,4 +120,4 @@
 SpecialSprites5 = images/ships/shpgarty/SHOT_C06_PCX.bmp
 SpecialSprites6 = images/ships/shpgarty/SHOT_C07_PCX.bmp
 
-ExtraSprites0 = images/ships/shpgarty/SHOT_D01_PCX.bmp
\ No newline at end of file
+ExtraSprites0 = images/ships/shpgarty/SHOT_D01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpilwav.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpilwav.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpilwav.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = IlwrathAvenger
+Version = 65M
 
 [Ship]
 Crew = 22
@@ -65,26 +66,26 @@
 SpecialSample1 = sound/ships/shpilwav/WAVE_B02_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 50
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 0
-SpecialSamples   = 2
+ShipSprites = 1r
+WeaponSprites = 50
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 0
+SpecialSamples = 2
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpilwav/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpilwav/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpilwav/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpilwav/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpilwav/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpilwav/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpilwav/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpilwav/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpilwav/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpilwav/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpilwav/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpilwav/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpilwav/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpilwav/SHIP_P06_PCX.bmp
 
 ShipSprites0 = images/ships/shpilwav/SHIP_S01_PCX.bmp
 

Modified: trunk/gamedata/default_ini/ships/shpilwsp.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpilwsp.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpilwsp.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -8,6 +8,7 @@
 Gfx = Forevian
 Ditty = Forevian
 Code = IlwrathSpider
+Version = 65M
 
 [Ship]
 Crew = 22
@@ -57,26 +58,26 @@
 ExtraSample0 = sound/ships/shpilwsp/WAVE_C01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 10
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 32
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 10
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 32
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 20
-ExtraSamples     = 1
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 20
+ExtraSamples = 1
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpilwsp/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpilwsp/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpilwsp/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpilwsp/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpilwsp/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpilwsp/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpilwsp/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpilwsp/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpilwsp/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpilwsp/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpilwsp/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpilwsp/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpilwsp/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpilwsp/SHIP_P06_PCX.bmp
 
 ShipSprites0 = images/ships/shpilwsp/SHIP_S01_PCX.bmp
 

Modified: trunk/gamedata/default_ini/ships/shpkahbo.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpkahbo.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpkahbo.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -5,6 +5,7 @@
 Origin = TW
 Coders = Launchpad
 Code = KahrBoomerang
+Version = 65M
 
 [Ship]
 Crew = 18
@@ -91,29 +92,29 @@
 SpecialSample0 = sound/ships/shpkahbo/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 1r
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 1r
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 1r
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 10
+ExtraSprites = 1r
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 10
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpkahbo/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpkahbo/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpkahbo/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpkahbo/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpkahbo/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpkahbo/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpkahbo/SHIP_P06_PCX.bmp
-PanelBitmaps7  = images/ships/shpkahbo/SHIP_P07_PCX.bmp
-PanelBitmaps8  = images/ships/shpkahbo/SHIP_P08_PCX.bmp
-PanelBitmaps9  = images/ships/shpkahbo/SHIP_P09_PCX.bmp
+PanelBitmaps0 = images/ships/shpkahbo/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpkahbo/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpkahbo/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpkahbo/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpkahbo/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpkahbo/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpkahbo/SHIP_P06_PCX.bmp
+PanelBitmaps7 = images/ships/shpkahbo/SHIP_P07_PCX.bmp
+PanelBitmaps8 = images/ships/shpkahbo/SHIP_P08_PCX.bmp
+PanelBitmaps9 = images/ships/shpkahbo/SHIP_P09_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpkahbo/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpkohma.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpkohma.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpkohma.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = KohrAhMarauder
+Version = 65M
 
 [Ship]
 Crew = 42
@@ -75,26 +76,26 @@
 SpecialSample0 = sound/ships/shpkohma/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 10
-WeaponSamples    = 1
-WeaponExplosion  = 20
-SpecialSprites   = 20 +alpha
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 10
+WeaponSamples = 1
+WeaponExplosion = 20
+SpecialSprites = 20 +alpha
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpkohma/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpkohma/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpkohma/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpkohma/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpkohma/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpkohma/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpkohma/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpkohma/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpkohma/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpkohma/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpkohma/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpkohma/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpkohma/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpkohma/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpkohma/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpkzedr.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpkzedr.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpkzedr.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -8,6 +8,7 @@
 Origin = UQM
 Coders = The Fly
 Code = KzerZaDreadnought
+Version = 65M
 
 [Ship]
 Crew = 42
@@ -71,30 +72,30 @@
 
 SpecialSample0 = sound/ships/shpkzedr/WAVE_B01_WAV.wav
 
-ExtraSample0 = sound/ships/shpkzedr/WAVE_C01_WAV.wav 
-ExtraSample1 = sound/ships/shpkzedr/WAVE_C02_WAV.wav 
+ExtraSample0 = sound/ships/shpkzedr/WAVE_C01_WAV.wav
+ExtraSample1 = sound/ships/shpkzedr/WAVE_C02_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 1
-WeaponExplosion  = 20 +alpha
-SpecialSprites   = 1r
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 20 +alpha
+SpecialSprites = 1r
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 2
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 2
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpkzedr/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpkzedr/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpkzedr/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpkzedr/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpkzedr/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpkzedr/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpkzedr/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpkzedr/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpkzedr/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpkzedr/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpkzedr/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpkzedr/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpkzedr/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpkzedr/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpkzedr/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpmeltr.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpmeltr.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpmeltr.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -6,6 +6,7 @@
 Origin = UQM
 Coders = The Fly
 Code = MelnormeTrader
+Version = 65M
 
 [Ship]
 Crew = 20
@@ -75,26 +76,26 @@
 SpecialSample0 = sound/ships/shpmeltr/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 40 +alpha
-WeaponSamples    = 1
-WeaponExplosion  = 80 +alpha
-SpecialSprites   = 20 +alpha
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 40 +alpha
+WeaponSamples = 1
+WeaponExplosion = 80 +alpha
+SpecialSprites = 20 +alpha
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 20
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 20
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpmeltr/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpmeltr/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpmeltr/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpmeltr/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpmeltr/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpmeltr/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpmeltr/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpmeltr/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpmeltr/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpmeltr/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpmeltr/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpmeltr/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpmeltr/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpmeltr/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpmeltr/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpmmrxf.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpmmrxf.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpmmrxf.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = MmrnmhrmXForm
+Version = 65M
 
 [Ship]
 Crew = 20
@@ -96,26 +97,26 @@
 SpecialSample0 = sound/ships/shpmmrxf/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 2
-WeaponExplosion  = 0
-SpecialSprites   = 1r
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 2
+WeaponExplosion = 0
+SpecialSprites = 1r
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpmmrxf/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpmmrxf/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpmmrxf/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpmmrxf/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpmmrxf/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpmmrxf/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpmmrxf/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpmmrxf/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpmmrxf/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpmmrxf/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpmmrxf/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpmmrxf/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpmmrxf/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpmmrxf/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpmmrxf/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpmycpo.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpmycpo.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpmycpo.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = MyconPodship
+Version = 65M
 
 [Ship]
 Crew = 20
@@ -66,26 +67,26 @@
 SpecialSample0 = sound/ships/shpmycpo/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 64 +alpha
-WeaponSamples    = 1
-WeaponExplosion  = 20 +alpha
-SpecialSprites   = 0
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 64 +alpha
+WeaponSamples = 1
+WeaponExplosion = 20 +alpha
+SpecialSprites = 0
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpmycpo/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpmycpo/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpmycpo/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpmycpo/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpmycpo/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpmycpo/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpmycpo/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpmycpo/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpmycpo/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpmycpo/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpmycpo/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpmycpo/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpmycpo/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpmycpo/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpmycpo/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shporzne.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shporzne.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shporzne.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -6,6 +6,7 @@
 Origin = UQM
 Coders = The Fly
 Code = OrzNemesis
+Version = 65M
 
 [Ship]
 Crew = 16
@@ -77,31 +78,31 @@
 SpecialSample0 = sound/ships/shporzne/WAVE_B01_WAV.wav
 SpecialSample1 = sound/ships/shporzne/WAVE_B02_WAV.wav
 
-ExtraSample0 = sound/ships/shporzne/WAVE_C01_WAV.wav 
-ExtraSample1 = sound/ships/shporzne/WAVE_C02_WAV.wav 
-ExtraSample2 = sound/ships/shporzne/WAVE_C03_WAV.wav 
+ExtraSample0 = sound/ships/shporzne/WAVE_C01_WAV.wav
+ExtraSample1 = sound/ships/shporzne/WAVE_C02_WAV.wav
+ExtraSample2 = sound/ships/shporzne/WAVE_C03_WAV.wav
 
 [Objects]
-ShipSprites      = 1r +alpha
-WeaponSprites    = 1r
-WeaponSamples    = 1
-WeaponExplosion  = 10 +alpha
-SpecialSprites   = 2
-SpecialSamples   = 1
+ShipSprites = 1r +alpha
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 10 +alpha
+SpecialSprites = 2
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 1r +alpha
-ExtraSamples     = 3
-ExtraExplosion   = 10 +alpha
-PanelBitmaps     = 7
+ExtraSprites = 1r +alpha
+ExtraSamples = 3
+ExtraExplosion = 10 +alpha
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shporzne/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shporzne/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shporzne/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shporzne/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shporzne/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shporzne/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shporzne/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shporzne/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shporzne/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shporzne/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shporzne/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shporzne/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shporzne/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shporzne/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shporzne/SHIP_S_00_TGA.bmp

Modified: trunk/gamedata/default_ini/ships/shppkufu.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shppkufu.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shppkufu.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -6,6 +6,7 @@
 Origin = UQM
 Coders = The Fly
 Code = PkunkFury
+Version = 65M
 
 [Ship]
 Crew = 8
@@ -76,26 +77,26 @@
 SpecialSample13 = sound/ships/shppkufu/WAVE_B14_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 10 +alpha
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 0
-SpecialSamples   = 14
+ShipSprites = 1r
+WeaponSprites = 10 +alpha
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 0
+SpecialSamples = 14
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 1
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 1
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shppkufu/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shppkufu/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shppkufu/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shppkufu/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shppkufu/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shppkufu/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shppkufu/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shppkufu/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shppkufu/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shppkufu/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shppkufu/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shppkufu/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shppkufu/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shppkufu/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shppkufu/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shprogsq.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shprogsq.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shprogsq.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -4,8 +4,9 @@
 Name1 = Rogue
 Name2 = Squadron
 Coders = GeomanNL
-; idea: this version, GeomanNL, but similar ideas were given by many people as well.
+; = idea: this version, GeomanNL, but similar ideas were given by many people as well.
 Code = RogueSquadron
+Version = 65M
 
 [Ship]
 Crew = 11
@@ -25,11 +26,11 @@
 Mass = 10
 
 [Weapon]
-Range    = 40
-Damage   = 1
+Range = 40
+Damage = 1
 Velocity = 100
-Color    = 0x0FFFF00	; yellow
-Length   = 20.0
+Color = 0x0FFFF00	; yellow
+Length = 20.0
 
 [Fighter]
 Crew = 2
@@ -41,7 +42,7 @@
 EvadeRotationPerSec = 720	; can do 2 turn / second to evade some object
 SuicideDamage = 1
 
-; rest is equal to mothership
+; = rest is equal to mothership
 
 [AI3_Default]
 Weapon = Missile
@@ -49,36 +50,36 @@
 SpecialFreq = 10
 
 [Formations]
-; assume the leader heads upward
-; each formation needs CrewMax entries
-; if you've casualties only the first Crew entries are used, so the order in which
-;     you define the positions is important.
-; position (0,0) is for the leader; should always be there.
+; = assume the leader heads upward
+; = each formation needs CrewMax entries
+; = if you've casualties only the first Crew entries are used, so the order in which
+; = you define the positions is important.
+; = position (0,0) is for the leader; should always be there.
 
 Nformations = 5
 
-; formation 1:
-;   ( x y ) sets
+; = formation 1:
+; = ( x y ) sets
 
-; column
+; = column
 Formation01 = 0 0  0 -100  0 -200  0 -300  0 -400  0 -500  0 -600  0 -700  0 -800  0 -900  0 -1000
 
-; row
-Formation02 =  0 0  -100 0  100 0  -200 0  200 0  -300 0  300 0  -400 0  400 0  -500 0  500 0
+; = row
+Formation02 = 0 0  -100 0  100 0  -200 0  200 0  -300 0  300 0  -400 0  400 0  -500 0  500 0
 
-; V
+; = V
 Formation03 = 0 0  -50 -50  50 -50  -100 -100  100 -100  -150 -150  150 -150  -200 -200  200 -200  -250 -250  250 -250
 
-; Circle (disabled)
+; = Circle (disabled)
 ;Formation04 = 0 0  -182 -117  198 -229  -57 -392  -151 -331  108 -32  -108 -32  57 -392  -198 -229  182 -117  151 -331
 
-; Box
+; = Box
 Formation04 = 0 0  -100 -100  0 -100  100 -100  -100 -200  0 -200  100 -200  -100 -300  0 -300  100 -300  0 -400
 
-; Tightly packed Box
+; = Tightly packed Box
 Formation05 = 0 0  -50 -50  0 -50  50 -50  -50 -100  0 -100  50 -100  -50 -150  0 -150  50 -150  0 -200
 
-; Two Rows (disabled)
+; = Two Rows (disabled)
 ;Formation06 = -150 0  -150 100  150 100  -150 200  150 200  -150 300  150 300  -150 400  150 400  -150 500  150 500
 
 [Names]
@@ -99,26 +100,26 @@
 SpecialSample0 = sound/ships/shprogsq/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 0
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 0
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shprogsq/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shprogsq/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shprogsq/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shprogsq/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shprogsq/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shprogsq/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shprogsq/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shprogsq/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shprogsq/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shprogsq/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shprogsq/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shprogsq/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shprogsq/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shprogsq/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shprogsq/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpshosc.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpshosc.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpshosc.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = ShofixtiScout
+Version = 65M
 
 [Ship]
 Crew = 6
@@ -70,27 +71,27 @@
 SpecialSample0 = sound/ships/shpshosc/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 30 +alpha
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 30 +alpha
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 8
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 8
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpshosc/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpshosc/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpshosc/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpshosc/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpshosc/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpshosc/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpshosc/SHIP_P06_PCX.bmp
-PanelBitmaps7  = images/ships/shpshosc/SHIP_P07_PCX.bmp
+PanelBitmaps0 = images/ships/shpshosc/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpshosc/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpshosc/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpshosc/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpshosc/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpshosc/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpshosc/SHIP_P06_PCX.bmp
+PanelBitmaps7 = images/ships/shpshosc/SHIP_P07_PCX.bmp
 
 ShipSprites0 = images/ships/shpshosc/SHIP_S01_PCX.bmp
 

Modified: trunk/gamedata/default_ini/ships/shpslypr.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpslypr.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpslypr.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -6,6 +6,7 @@
 Origin = UQM
 Coders = The Fly (weapon update: GeomanNL)
 Code = SlylandroProbe
+Version = 65M
 
 [Ship]
 Crew = 12
@@ -51,26 +52,26 @@
 SpecialSample0 = sound/ships/shpslypr/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 64
-WeaponSprites    = 0
-WeaponSamples    = 1
-WeaponExplosion  = 1
-SpecialSprites   = 0
-SpecialSamples   = 1
+ShipSprites = 64
+WeaponSprites = 0
+WeaponSamples = 1
+WeaponExplosion = 1
+SpecialSprites = 0
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpslypr/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpslypr/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpslypr/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpslypr/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpslypr/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpslypr/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpslypr/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpslypr/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpslypr/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpslypr/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpslypr/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpslypr/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpslypr/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpslypr/SHIP_P06_PCX.bmp
 
 ShipSprites0 = images/ships/shpslypr/SHIP_S01_PCX.bmp
 ShipSprites1 = images/ships/shpslypr/SHIP_S02_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpspael.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpspael.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpspael.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = SpathiEluder
+Version = 65M
 
 [Ship]
 Crew = 30
@@ -71,26 +72,26 @@
 SpecialSample0 = sound/ships/shpspael/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 1r
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 1r
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpspael/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpspael/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpspael/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpspael/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpspael/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpspael/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpspael/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpspael/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpspael/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpspael/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpspael/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpspael/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpspael/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpspael/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpspael/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpstaba.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpstaba.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpstaba.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -6,6 +6,7 @@
 Coders = UAF :) sort off, thanks to the creators of the other ships I
 ; = used their code for this ship :)
 Code = StarBase
+Version = 65M
 
 [Ship]
 Crew = 42
@@ -43,9 +44,9 @@
 HealColor = 1
 Range = 7
 
-[AI3_Default] 
-Special = Defense 
-SpecialFreq = 3 
+[AI3_Default]
+Special = Defense
+SpecialFreq = 3
 Reserve_Battery = 10
 Weapon = Sides
 
@@ -58,26 +59,26 @@
 SpecialSample0 = sound/ships/shpstaba/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 0
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 0
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpstaba/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpstaba/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpstaba/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpstaba/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpstaba/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpstaba/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpstaba/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpstaba/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpstaba/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpstaba/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpstaba/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpstaba/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpstaba/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpstaba/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpstaba/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpsupbl.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpsupbl.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpsupbl.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -6,6 +6,7 @@
 Origin = UQM
 Coders = The Fly
 Code = SupoxBlade
+Version = 65M
 
 [Ship]
 Crew = 12
@@ -59,26 +60,26 @@
 WeaponSample0 = sound/ships/shpsupbl/WAVE_A01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 1
-WeaponExplosion  = 10
-SpecialSprites   = 0
-SpecialSamples   = 0
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 10
+SpecialSprites = 0
+SpecialSamples = 0
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpsupbl/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpsupbl/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpsupbl/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpsupbl/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpsupbl/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpsupbl/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpsupbl/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpsupbl/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpsupbl/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpsupbl/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpsupbl/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpsupbl/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpsupbl/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpsupbl/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpsupbl/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpsyrpe.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpsyrpe.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpsyrpe.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = SyreenPenetrator
+Version = 65M
 
 [Ship]
 Crew = 12
@@ -71,26 +72,26 @@
 ExtraSample0 = sound/ships/shpsyrpe/WAVE_C01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 1r32 +alpha
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 1r32 +alpha
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 1
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 1
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpsyrpe/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpsyrpe/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpsyrpe/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpsyrpe/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpsyrpe/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpsyrpe/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpsyrpe/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpsyrpe/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpsyrpe/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpsyrpe/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpsyrpe/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpsyrpe/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpsyrpe/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpsyrpe/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpsyrpe/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shptauar.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shptauar.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shptauar.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -1,27 +1,28 @@
 [Info]
-TWCost  = 30
+TWCost = 30
 Name1 = Tau
 Name2 = Archon
 Origin = TW
 Coders = Tau (and Jad)
 Code = TauArchon
+Version = 65M
 
 [Ship]
-Crew           = 42
-CrewMax        = 42
-Batt           = 42
-BattMax        = 42
-SpeedMax       = 30
-AccelRate      = 5.7
-TurnRate       = 4.2
+Crew = 42
+CrewMax = 42
+Batt = 42
+BattMax = 42
+SpeedMax = 30
+AccelRate = 5.7
+TurnRate = 4.2
 RechargeAmount = 1
-RechargeRate   = 2.5
-WeaponDrain    = 3
-WeaponRate     = -0.5
-SpecialDrain   = 5
-SpecialRate    = 0
-HotspotRate    = 5
-Mass           = 23
+RechargeRate = 2.5
+WeaponDrain = 3
+WeaponRate = -0.5
+SpecialDrain = 5
+SpecialRate = 0
+HotspotRate = 5
+Mass = 23
 
 CoolDownThenCharge = 1
 
@@ -37,11 +38,11 @@
 SoundTimer = 250
 DoReactiveDamage = 1
 
-; The steps the ship takes to damage a ship
-; set DamageSteps to 0 to return to original (all batt first) style
+; = The steps the ship takes to damage a ship
+; = set DamageSteps to 0 to return to original (all batt first) style
 DamageSteps = 2
 
-; Batt = 1, Crew = 0.
+; = Batt = 1, Crew = 0.
 Step1 = 1
 Step2 = 0
 
@@ -74,123 +75,123 @@
 ExtraSample3 = sound/ships/shptauar/WAVE_C04_WAV.wav
 
 [Objects]
-ShipSprites      = 1r +alpha
-WeaponSprites    = 81 +alpha
-WeaponSamples    = 6
-WeaponExplosion  = 10 +alpha
-SpecialSprites   = 0
-SpecialSamples   = 1
+ShipSprites = 1r +alpha
+WeaponSprites = 81 +alpha
+WeaponSamples = 6
+WeaponExplosion = 10 +alpha
+SpecialSprites = 0
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 12
-ExtraSamples     = 4
-ExtraExplosion   = 20 +alpha
+ExtraSprites = 12
+ExtraSamples = 4
+ExtraExplosion = 20 +alpha
 ExtraExtraSprites0_ = 1r +alpha
-PanelBitmaps     = 7
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shptauar/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shptauar/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shptauar/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shptauar/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shptauar/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shptauar/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shptauar/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shptauar/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shptauar/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shptauar/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shptauar/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shptauar/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shptauar/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shptauar/SHIP_P06_PCX.bmp
 
 ShipSprites0 = images/ships/shptauar/SHIP_S0_00_TGA.bmp
 
-WeaponSprites0 = images/ships/shptauar/SHOT_A0_00_TGA.bmp 
-WeaponSprites1 = images/ships/shptauar/SHOT_A0_01_TGA.bmp 
-WeaponSprites2 = images/ships/shptauar/SHOT_A0_02_TGA.bmp 
-WeaponSprites3 = images/ships/shptauar/SHOT_A0_03_TGA.bmp 
-WeaponSprites4 = images/ships/shptauar/SHOT_A0_04_TGA.bmp 
-WeaponSprites5 = images/ships/shptauar/SHOT_A0_05_TGA.bmp 
-WeaponSprites6 = images/ships/shptauar/SHOT_A0_06_TGA.bmp 
-WeaponSprites7 = images/ships/shptauar/SHOT_A0_07_TGA.bmp 
-WeaponSprites8 = images/ships/shptauar/SHOT_A0_08_TGA.bmp 
-WeaponSprites9 = images/ships/shptauar/SHOT_A0_09_TGA.bmp 
-WeaponSprites10 = images/ships/shptauar/SHOT_A0_10_TGA.bmp 
-WeaponSprites11 = images/ships/shptauar/SHOT_A0_11_TGA.bmp 
-WeaponSprites12 = images/ships/shptauar/SHOT_A0_12_TGA.bmp 
-WeaponSprites13 = images/ships/shptauar/SHOT_A0_13_TGA.bmp 
-WeaponSprites14 = images/ships/shptauar/SHOT_A0_14_TGA.bmp 
-WeaponSprites15 = images/ships/shptauar/SHOT_A0_15_TGA.bmp 
-WeaponSprites16 = images/ships/shptauar/SHOT_A0_16_TGA.bmp 
-WeaponSprites17 = images/ships/shptauar/SHOT_A0_17_TGA.bmp 
-WeaponSprites18 = images/ships/shptauar/SHOT_A0_18_TGA.bmp 
-WeaponSprites19 = images/ships/shptauar/SHOT_A0_19_TGA.bmp 
-WeaponSprites20 = images/ships/shptauar/SHOT_A1_00_TGA.bmp 
-WeaponSprites21 = images/ships/shptauar/SHOT_A1_01_TGA.bmp 
-WeaponSprites22 = images/ships/shptauar/SHOT_A1_02_TGA.bmp 
-WeaponSprites23 = images/ships/shptauar/SHOT_A1_03_TGA.bmp 
-WeaponSprites24 = images/ships/shptauar/SHOT_A1_04_TGA.bmp 
-WeaponSprites25 = images/ships/shptauar/SHOT_A1_05_TGA.bmp 
-WeaponSprites26 = images/ships/shptauar/SHOT_A1_06_TGA.bmp 
-WeaponSprites27 = images/ships/shptauar/SHOT_A1_07_TGA.bmp 
-WeaponSprites28 = images/ships/shptauar/SHOT_A1_08_TGA.bmp 
-WeaponSprites29 = images/ships/shptauar/SHOT_A1_09_TGA.bmp 
-WeaponSprites30 = images/ships/shptauar/SHOT_A1_10_TGA.bmp 
-WeaponSprites31 = images/ships/shptauar/SHOT_A1_11_TGA.bmp 
-WeaponSprites32 = images/ships/shptauar/SHOT_A1_12_TGA.bmp 
-WeaponSprites33 = images/ships/shptauar/SHOT_A1_13_TGA.bmp 
-WeaponSprites34 = images/ships/shptauar/SHOT_A1_14_TGA.bmp 
-WeaponSprites35 = images/ships/shptauar/SHOT_A1_15_TGA.bmp 
-WeaponSprites36 = images/ships/shptauar/SHOT_A1_16_TGA.bmp 
-WeaponSprites37 = images/ships/shptauar/SHOT_A1_17_TGA.bmp 
-WeaponSprites38 = images/ships/shptauar/SHOT_A1_18_TGA.bmp 
-WeaponSprites39 = images/ships/shptauar/SHOT_A1_19_TGA.bmp 
-WeaponSprites40 = images/ships/shptauar/SHOT_A2_00_TGA.bmp 
-WeaponSprites41 = images/ships/shptauar/SHOT_A2_01_TGA.bmp 
-WeaponSprites42 = images/ships/shptauar/SHOT_A2_02_TGA.bmp 
-WeaponSprites43 = images/ships/shptauar/SHOT_A2_03_TGA.bmp 
-WeaponSprites44 = images/ships/shptauar/SHOT_A2_04_TGA.bmp 
-WeaponSprites45 = images/ships/shptauar/SHOT_A2_05_TGA.bmp 
-WeaponSprites46 = images/ships/shptauar/SHOT_A2_06_TGA.bmp 
-WeaponSprites47 = images/ships/shptauar/SHOT_A2_07_TGA.bmp 
-WeaponSprites48 = images/ships/shptauar/SHOT_A2_08_TGA.bmp 
-WeaponSprites49 = images/ships/shptauar/SHOT_A2_09_TGA.bmp 
-WeaponSprites50 = images/ships/shptauar/SHOT_A2_10_TGA.bmp 
-WeaponSprites51 = images/ships/shptauar/SHOT_A2_11_TGA.bmp 
-WeaponSprites52 = images/ships/shptauar/SHOT_A2_12_TGA.bmp 
-WeaponSprites53 = images/ships/shptauar/SHOT_A2_13_TGA.bmp 
-WeaponSprites54 = images/ships/shptauar/SHOT_A2_14_TGA.bmp 
-WeaponSprites55 = images/ships/shptauar/SHOT_A2_15_TGA.bmp 
-WeaponSprites56 = images/ships/shptauar/SHOT_A2_16_TGA.bmp 
-WeaponSprites57 = images/ships/shptauar/SHOT_A2_17_TGA.bmp 
-WeaponSprites58 = images/ships/shptauar/SHOT_A2_18_TGA.bmp 
-WeaponSprites59 = images/ships/shptauar/SHOT_A2_19_TGA.bmp 
-WeaponSprites60 = images/ships/shptauar/SHOT_A3_00_TGA.bmp 
-WeaponSprites61 = images/ships/shptauar/SHOT_A3_01_TGA.bmp 
-WeaponSprites62 = images/ships/shptauar/SHOT_A3_02_TGA.bmp 
-WeaponSprites63 = images/ships/shptauar/SHOT_A3_03_TGA.bmp 
-WeaponSprites64 = images/ships/shptauar/SHOT_A3_04_TGA.bmp 
-WeaponSprites65 = images/ships/shptauar/SHOT_A3_05_TGA.bmp 
-WeaponSprites66 = images/ships/shptauar/SHOT_A3_06_TGA.bmp 
-WeaponSprites67 = images/ships/shptauar/SHOT_A3_07_TGA.bmp 
-WeaponSprites68 = images/ships/shptauar/SHOT_A3_08_TGA.bmp 
-WeaponSprites69 = images/ships/shptauar/SHOT_A3_09_TGA.bmp 
-WeaponSprites70 = images/ships/shptauar/SHOT_A3_10_TGA.bmp 
-WeaponSprites71 = images/ships/shptauar/SHOT_A3_11_TGA.bmp 
-WeaponSprites72 = images/ships/shptauar/SHOT_A3_12_TGA.bmp 
-WeaponSprites73 = images/ships/shptauar/SHOT_A3_13_TGA.bmp 
-WeaponSprites74 = images/ships/shptauar/SHOT_A3_14_TGA.bmp 
-WeaponSprites75 = images/ships/shptauar/SHOT_A3_15_TGA.bmp 
-WeaponSprites76 = images/ships/shptauar/SHOT_A3_16_TGA.bmp 
-WeaponSprites77 = images/ships/shptauar/SHOT_A3_17_TGA.bmp 
-WeaponSprites78 = images/ships/shptauar/SHOT_A3_18_TGA.bmp 
-WeaponSprites79 = images/ships/shptauar/SHOT_A3_19_TGA.bmp 
-WeaponSprites80 = images/ships/shptauar/SHOT_AX_00_TGA.bmp 
+WeaponSprites0 = images/ships/shptauar/SHOT_A0_00_TGA.bmp
+WeaponSprites1 = images/ships/shptauar/SHOT_A0_01_TGA.bmp
+WeaponSprites2 = images/ships/shptauar/SHOT_A0_02_TGA.bmp
+WeaponSprites3 = images/ships/shptauar/SHOT_A0_03_TGA.bmp
+WeaponSprites4 = images/ships/shptauar/SHOT_A0_04_TGA.bmp
+WeaponSprites5 = images/ships/shptauar/SHOT_A0_05_TGA.bmp
+WeaponSprites6 = images/ships/shptauar/SHOT_A0_06_TGA.bmp
+WeaponSprites7 = images/ships/shptauar/SHOT_A0_07_TGA.bmp
+WeaponSprites8 = images/ships/shptauar/SHOT_A0_08_TGA.bmp
+WeaponSprites9 = images/ships/shptauar/SHOT_A0_09_TGA.bmp
+WeaponSprites10 = images/ships/shptauar/SHOT_A0_10_TGA.bmp
+WeaponSprites11 = images/ships/shptauar/SHOT_A0_11_TGA.bmp
+WeaponSprites12 = images/ships/shptauar/SHOT_A0_12_TGA.bmp
+WeaponSprites13 = images/ships/shptauar/SHOT_A0_13_TGA.bmp
+WeaponSprites14 = images/ships/shptauar/SHOT_A0_14_TGA.bmp
+WeaponSprites15 = images/ships/shptauar/SHOT_A0_15_TGA.bmp
+WeaponSprites16 = images/ships/shptauar/SHOT_A0_16_TGA.bmp
+WeaponSprites17 = images/ships/shptauar/SHOT_A0_17_TGA.bmp
+WeaponSprites18 = images/ships/shptauar/SHOT_A0_18_TGA.bmp
+WeaponSprites19 = images/ships/shptauar/SHOT_A0_19_TGA.bmp
+WeaponSprites20 = images/ships/shptauar/SHOT_A1_00_TGA.bmp
+WeaponSprites21 = images/ships/shptauar/SHOT_A1_01_TGA.bmp
+WeaponSprites22 = images/ships/shptauar/SHOT_A1_02_TGA.bmp
+WeaponSprites23 = images/ships/shptauar/SHOT_A1_03_TGA.bmp
+WeaponSprites24 = images/ships/shptauar/SHOT_A1_04_TGA.bmp
+WeaponSprites25 = images/ships/shptauar/SHOT_A1_05_TGA.bmp
+WeaponSprites26 = images/ships/shptauar/SHOT_A1_06_TGA.bmp
+WeaponSprites27 = images/ships/shptauar/SHOT_A1_07_TGA.bmp
+WeaponSprites28 = images/ships/shptauar/SHOT_A1_08_TGA.bmp
+WeaponSprites29 = images/ships/shptauar/SHOT_A1_09_TGA.bmp
+WeaponSprites30 = images/ships/shptauar/SHOT_A1_10_TGA.bmp
+WeaponSprites31 = images/ships/shptauar/SHOT_A1_11_TGA.bmp
+WeaponSprites32 = images/ships/shptauar/SHOT_A1_12_TGA.bmp
+WeaponSprites33 = images/ships/shptauar/SHOT_A1_13_TGA.bmp
+WeaponSprites34 = images/ships/shptauar/SHOT_A1_14_TGA.bmp
+WeaponSprites35 = images/ships/shptauar/SHOT_A1_15_TGA.bmp
+WeaponSprites36 = images/ships/shptauar/SHOT_A1_16_TGA.bmp
+WeaponSprites37 = images/ships/shptauar/SHOT_A1_17_TGA.bmp
+WeaponSprites38 = images/ships/shptauar/SHOT_A1_18_TGA.bmp
+WeaponSprites39 = images/ships/shptauar/SHOT_A1_19_TGA.bmp
+WeaponSprites40 = images/ships/shptauar/SHOT_A2_00_TGA.bmp
+WeaponSprites41 = images/ships/shptauar/SHOT_A2_01_TGA.bmp
+WeaponSprites42 = images/ships/shptauar/SHOT_A2_02_TGA.bmp
+WeaponSprites43 = images/ships/shptauar/SHOT_A2_03_TGA.bmp
+WeaponSprites44 = images/ships/shptauar/SHOT_A2_04_TGA.bmp
+WeaponSprites45 = images/ships/shptauar/SHOT_A2_05_TGA.bmp
+WeaponSprites46 = images/ships/shptauar/SHOT_A2_06_TGA.bmp
+WeaponSprites47 = images/ships/shptauar/SHOT_A2_07_TGA.bmp
+WeaponSprites48 = images/ships/shptauar/SHOT_A2_08_TGA.bmp
+WeaponSprites49 = images/ships/shptauar/SHOT_A2_09_TGA.bmp
+WeaponSprites50 = images/ships/shptauar/SHOT_A2_10_TGA.bmp
+WeaponSprites51 = images/ships/shptauar/SHOT_A2_11_TGA.bmp
+WeaponSprites52 = images/ships/shptauar/SHOT_A2_12_TGA.bmp
+WeaponSprites53 = images/ships/shptauar/SHOT_A2_13_TGA.bmp
+WeaponSprites54 = images/ships/shptauar/SHOT_A2_14_TGA.bmp
+WeaponSprites55 = images/ships/shptauar/SHOT_A2_15_TGA.bmp
+WeaponSprites56 = images/ships/shptauar/SHOT_A2_16_TGA.bmp
+WeaponSprites57 = images/ships/shptauar/SHOT_A2_17_TGA.bmp
+WeaponSprites58 = images/ships/shptauar/SHOT_A2_18_TGA.bmp
+WeaponSprites59 = images/ships/shptauar/SHOT_A2_19_TGA.bmp
+WeaponSprites60 = images/ships/shptauar/SHOT_A3_00_TGA.bmp
+WeaponSprites61 = images/ships/shptauar/SHOT_A3_01_TGA.bmp
+WeaponSprites62 = images/ships/shptauar/SHOT_A3_02_TGA.bmp
+WeaponSprites63 = images/ships/shptauar/SHOT_A3_03_TGA.bmp
+WeaponSprites64 = images/ships/shptauar/SHOT_A3_04_TGA.bmp
+WeaponSprites65 = images/ships/shptauar/SHOT_A3_05_TGA.bmp
+WeaponSprites66 = images/ships/shptauar/SHOT_A3_06_TGA.bmp
+WeaponSprites67 = images/ships/shptauar/SHOT_A3_07_TGA.bmp
+WeaponSprites68 = images/ships/shptauar/SHOT_A3_08_TGA.bmp
+WeaponSprites69 = images/ships/shptauar/SHOT_A3_09_TGA.bmp
+WeaponSprites70 = images/ships/shptauar/SHOT_A3_10_TGA.bmp
+WeaponSprites71 = images/ships/shptauar/SHOT_A3_11_TGA.bmp
+WeaponSprites72 = images/ships/shptauar/SHOT_A3_12_TGA.bmp
+WeaponSprites73 = images/ships/shptauar/SHOT_A3_13_TGA.bmp
+WeaponSprites74 = images/ships/shptauar/SHOT_A3_14_TGA.bmp
+WeaponSprites75 = images/ships/shptauar/SHOT_A3_15_TGA.bmp
+WeaponSprites76 = images/ships/shptauar/SHOT_A3_16_TGA.bmp
+WeaponSprites77 = images/ships/shptauar/SHOT_A3_17_TGA.bmp
+WeaponSprites78 = images/ships/shptauar/SHOT_A3_18_TGA.bmp
+WeaponSprites79 = images/ships/shptauar/SHOT_A3_19_TGA.bmp
+WeaponSprites80 = images/ships/shptauar/SHOT_AX_00_TGA.bmp
 
 
-WeaponExplosion0 = images/ships/shptauar/SHOT_B_00_TGA.bmp 
-WeaponExplosion1 = images/ships/shptauar/SHOT_B_01_TGA.bmp 
-WeaponExplosion2 = images/ships/shptauar/SHOT_B_02_TGA.bmp 
-WeaponExplosion3 = images/ships/shptauar/SHOT_B_03_TGA.bmp 
-WeaponExplosion4 = images/ships/shptauar/SHOT_B_04_TGA.bmp 
-WeaponExplosion5 = images/ships/shptauar/SHOT_B_05_TGA.bmp 
-WeaponExplosion6 = images/ships/shptauar/SHOT_B_06_TGA.bmp 
-WeaponExplosion7 = images/ships/shptauar/SHOT_B_07_TGA.bmp 
-WeaponExplosion8 = images/ships/shptauar/SHOT_B_08_TGA.bmp 
-WeaponExplosion9 = images/ships/shptauar/SHOT_B_09_TGA.bmp 
+WeaponExplosion0 = images/ships/shptauar/SHOT_B_00_TGA.bmp
+WeaponExplosion1 = images/ships/shptauar/SHOT_B_01_TGA.bmp
+WeaponExplosion2 = images/ships/shptauar/SHOT_B_02_TGA.bmp
+WeaponExplosion3 = images/ships/shptauar/SHOT_B_03_TGA.bmp
+WeaponExplosion4 = images/ships/shptauar/SHOT_B_04_TGA.bmp
+WeaponExplosion5 = images/ships/shptauar/SHOT_B_05_TGA.bmp
+WeaponExplosion6 = images/ships/shptauar/SHOT_B_06_TGA.bmp
+WeaponExplosion7 = images/ships/shptauar/SHOT_B_07_TGA.bmp
+WeaponExplosion8 = images/ships/shptauar/SHOT_B_08_TGA.bmp
+WeaponExplosion9 = images/ships/shptauar/SHOT_B_09_TGA.bmp
 
 SpecialSprites0 = images/ships/shptauar/SHOT_C0_00_TGA.bmp
 SpecialSprites1 = images/ships/shptauar/SHOT_C1_00_TGA.bmp
@@ -216,18 +217,18 @@
 SpecialExplosion18 = images/ships/shptauar/SHOT_D_18_TGA.bmp
 SpecialExplosion19 = images/ships/shptauar/SHOT_D_19_TGA.bmp
 
-ExtraSprites0 = images/ships/shptauar/SHOT_C01_PCX.bmp 
-ExtraSprites1 = images/ships/shptauar/SHOT_C02_PCX.bmp 
-ExtraSprites2 = images/ships/shptauar/SHOT_C03_PCX.bmp 
-ExtraSprites3 = images/ships/shptauar/SHOT_C04_PCX.bmp 
-ExtraSprites4 = images/ships/shptauar/SHOT_C05_PCX.bmp 
-ExtraSprites5 = images/ships/shptauar/SHOT_C06_PCX.bmp 
-ExtraSprites6 = images/ships/shptauar/SHOT_C07_PCX.bmp 
-ExtraSprites7 = images/ships/shptauar/SHOT_C08_PCX.bmp 
-ExtraSprites8 = images/ships/shptauar/SHOT_C09_PCX.bmp 
-ExtraSprites9 = images/ships/shptauar/SHOT_C10_PCX.bmp 
-ExtraSprites10 = images/ships/shptauar/SHOT_C11_PCX.bmp 
-ExtraSprites11 = images/ships/shptauar/SHOT_C12_PCX.bmp 
+ExtraSprites0 = images/ships/shptauar/SHOT_C01_PCX.bmp
+ExtraSprites1 = images/ships/shptauar/SHOT_C02_PCX.bmp
+ExtraSprites2 = images/ships/shptauar/SHOT_C03_PCX.bmp
+ExtraSprites3 = images/ships/shptauar/SHOT_C04_PCX.bmp
+ExtraSprites4 = images/ships/shptauar/SHOT_C05_PCX.bmp
+ExtraSprites5 = images/ships/shptauar/SHOT_C06_PCX.bmp
+ExtraSprites6 = images/ships/shptauar/SHOT_C07_PCX.bmp
+ExtraSprites7 = images/ships/shptauar/SHOT_C08_PCX.bmp
+ExtraSprites8 = images/ships/shptauar/SHOT_C09_PCX.bmp
+ExtraSprites9 = images/ships/shptauar/SHOT_C10_PCX.bmp
+ExtraSprites10 = images/ships/shptauar/SHOT_C11_PCX.bmp
+ExtraSprites11 = images/ships/shptauar/SHOT_C12_PCX.bmp
 
 ExtraExplosion0 = images/ships/shptauar/SHOT_F_00_TGA.bmp
 ExtraExplosion1 = images/ships/shptauar/SHOT_F_01_TGA.bmp
@@ -250,4 +251,4 @@
 ExtraExplosion18 = images/ships/shptauar/SHOT_F_18_TGA.bmp
 ExtraExplosion19 = images/ships/shptauar/SHOT_F_19_TGA.bmp
 
-ExtraExtraSprites0_0 = images/ships/shptauar/SHOT_X0_00_BMP.bmp 
+ExtraExtraSprites0_0 = images/ships/shptauar/SHOT_X0_00_BMP.bmp

Modified: trunk/gamedata/default_ini/ships/shptauda.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shptauda.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shptauda.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -1,27 +1,28 @@
 [Info]
-TWCost  = 12
+TWCost = 12
 Name1 = Tau
 Name2 = Dagger
 Origin = TW
 Coders = Tau
 Code = TauDagger
+Version = 65M
 
 [Ship]
-Crew           = 8
-CrewMax        = 8
-Batt           = 12
-BattMax        = 12
-SpeedMax       = 47
-AccelRate      = 13
-TurnRate       = 1
+Crew = 8
+CrewMax = 8
+Batt = 12
+BattMax = 12
+SpeedMax = 47
+AccelRate = 13
+TurnRate = 1
 RechargeAmount = 1
-RechargeRate   = 3
-WeaponDrain    = 6
-WeaponRate     = 11
-SpecialDrain   = 12
-SpecialRate    = 0
-HotspotRate    = 1
-Mass           = 6
+RechargeRate = 3
+WeaponDrain = 6
+WeaponRate = 11
+SpecialDrain = 12
+SpecialRate = 0
+HotspotRate = 1
+Mass = 6
 
 [Weapon]
 Range = 4.5
@@ -45,26 +46,26 @@
 SpecialSample1 = sound/ships/shptauda/WAVE_B02_WAV.wav
 
 [Objects]
-ShipSprites      = 1r +alpha
-WeaponSprites    = 0
-WeaponSamples    = 1
-WeaponExplosion  = 1 +alpha
-SpecialSprites   = 2r +alpha
-SpecialSamples   = 2
+ShipSprites = 1r +alpha
+WeaponSprites = 0
+WeaponSamples = 1
+WeaponExplosion = 1 +alpha
+SpecialSprites = 2r +alpha
+SpecialSamples = 2
 SpecialExplosion = 20 +alpha
-ExtraSprites     = 10 +alpha
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 10 +alpha
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shptauda/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shptauda/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shptauda/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shptauda/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shptauda/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shptauda/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shptauda/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shptauda/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shptauda/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shptauda/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shptauda/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shptauda/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shptauda/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shptauda/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shptauda/SHIP_S_00_TGA.bmp
@@ -95,13 +96,13 @@
 SpecialExplosion18 = images/ships/shptauda/SHOT_D_18_TGA.bmp
 SpecialExplosion19 = images/ships/shptauda/SHOT_D_19_TGA.bmp
 
-ExtraSprites0 = images/ships/shptauda/SHOT_E_00_TGA.bmp 
-ExtraSprites1 = images/ships/shptauda/SHOT_E_01_TGA.bmp 
-ExtraSprites2 = images/ships/shptauda/SHOT_E_02_TGA.bmp 
-ExtraSprites3 = images/ships/shptauda/SHOT_E_03_TGA.bmp 
-ExtraSprites4 = images/ships/shptauda/SHOT_E_04_TGA.bmp 
-ExtraSprites5 = images/ships/shptauda/SHOT_E_05_TGA.bmp 
-ExtraSprites6 = images/ships/shptauda/SHOT_E_06_TGA.bmp 
-ExtraSprites7 = images/ships/shptauda/SHOT_E_07_TGA.bmp 
-ExtraSprites8 = images/ships/shptauda/SHOT_E_08_TGA.bmp 
-ExtraSprites9 = images/ships/shptauda/SHOT_E_09_TGA.bmp 
+ExtraSprites0 = images/ships/shptauda/SHOT_E_00_TGA.bmp
+ExtraSprites1 = images/ships/shptauda/SHOT_E_01_TGA.bmp
+ExtraSprites2 = images/ships/shptauda/SHOT_E_02_TGA.bmp
+ExtraSprites3 = images/ships/shptauda/SHOT_E_03_TGA.bmp
+ExtraSprites4 = images/ships/shptauda/SHOT_E_04_TGA.bmp
+ExtraSprites5 = images/ships/shptauda/SHOT_E_05_TGA.bmp
+ExtraSprites6 = images/ships/shptauda/SHOT_E_06_TGA.bmp
+ExtraSprites7 = images/ships/shptauda/SHOT_E_07_TGA.bmp
+ExtraSprites8 = images/ships/shptauda/SHOT_E_08_TGA.bmp
+ExtraSprites9 = images/ships/shptauda/SHOT_E_09_TGA.bmp

Modified: trunk/gamedata/default_ini/ships/shptausl.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shptausl.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shptausl.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -1,32 +1,33 @@
 [Info]
 Origin = TW
-TWCost  = 20
+TWCost = 20
 Name1 = Tau
 Name2 = Slider
 Coders = Tau
 Code = TauSlider
+Version = 65M
 
 [Ship]
-Crew           = 22
-CrewMax        = 22
-Batt           = 22
-BattMax        = 22
-SpeedMax       = 42
-AccelRate      = 9
-TurnRate       = 1
+Crew = 22
+CrewMax = 22
+Batt = 22
+BattMax = 22
+SpeedMax = 42
+AccelRate = 9
+TurnRate = 1
 RechargeAmount = 1
-RechargeRate   = 2
-WeaponDrain    = 3
-WeaponRate     = 1
-SpecialDrain   = 3
-SpecialRate    = 4
-HotspotRate    = 3
-Mass           = 16
+RechargeRate = 2
+WeaponDrain = 3
+WeaponRate = 1
+SpecialDrain = 3
+SpecialRate = 4
+HotspotRate = 3
+Mass = 16
 
 [Weapon]
-Range    = 15
+Range = 15
 Velocity = 110
-Length  = 10
+Length = 10
 
 [Special]
 Range0 = 0
@@ -52,26 +53,26 @@
 SpecialSample1 = sound/ships/shptausl/WAVE_B03_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 0
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 0
-SpecialSamples   = 3
+ShipSprites = 1r
+WeaponSprites = 0
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 0
+SpecialSamples = 3
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shptausl/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shptausl/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shptausl/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shptausl/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shptausl/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shptausl/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shptausl/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shptausl/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shptausl/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shptausl/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shptausl/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shptausl/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shptausl/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shptausl/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shptausl/SHIP_S00_BMP.bmp

Modified: trunk/gamedata/default_ini/ships/shptauto.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shptauto.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shptauto.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -1,40 +1,41 @@
 [Info]
 Origin = TW
-TWCost  = 22
+TWCost = 22
 Name1 = Tau
 Name2 = Torrent
 Coders = Tau
-Ditty  = Lestat
+Ditty = Lestat
 Code = TauTor
+Version = 65M
 
 [Ship]
-Crew           = 20
-CrewMax        = 20
-Batt           = 20
-BattMax        = 20
-SpeedMax       = 50
-AccelRate      = 5
-TurnRate       = 3
+Crew = 20
+CrewMax = 20
+Batt = 20
+BattMax = 20
+SpeedMax = 50
+AccelRate = 5
+TurnRate = 3
 RechargeAmount = 1
-RechargeRate   = 3
-WeaponDrain    = 10
-WeaponRate     = 20
-SpecialDrain   = 1
-SpecialRate    = 1
-HotspotRate    = 1
-Mass           = 21
+RechargeRate = 3
+WeaponDrain = 10
+WeaponRate = 20
+SpecialDrain = 1
+SpecialRate = 1
+HotspotRate = 1
+Mass = 21
 
 [Weapon]
-Range    = 50
+Range = 50
 Velocity = 130
-Damage   = 6
-Armour   = 999
+Damage = 6
+Armour = 999
 
 [Special]
-Range    = 14
+Range = 14
 Velocity = 80
-Damage   = 2
-Armour   = 1
+Damage = 2
+Armour = 1
 
 [Extra]
 StartDrain = 6
@@ -61,26 +62,26 @@
 ExtraSample1 = sound/ships/shptauto/WAVE_C02_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 6
-WeaponSamples    = 2
-WeaponExplosion  = 12
-SpecialSprites   = 6
-SpecialSamples   = 0
+ShipSprites = 1r
+WeaponSprites = 6
+WeaponSamples = 2
+WeaponExplosion = 12
+SpecialSprites = 6
+SpecialSamples = 0
 SpecialExplosion = 12
-ExtraSprites     = 12
-ExtraSamples     = 2
-ExtraExplosion   = 1r
-PanelBitmaps     = 7
+ExtraSprites = 12
+ExtraSamples = 2
+ExtraExplosion = 1r
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shptauto/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shptauto/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shptauto/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shptauto/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shptauto/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shptauto/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shptauto/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shptauto/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shptauto/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shptauto/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shptauto/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shptauto/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shptauto/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shptauto/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shptauto/SHIP_S00_BMP.bmp
@@ -125,17 +126,17 @@
 SpecialExplosion10 = images/ships/shptauto/SHOT_D10_BMP.bmp
 SpecialExplosion11 = images/ships/shptauto/SHOT_D11_BMP.bmp
 
-ExtraSprites0 = images/ships/shptauto/SHOT_E0000_BMP.bmp 
-ExtraSprites1 = images/ships/shptauto/SHOT_E0001_BMP.bmp 
-ExtraSprites2 = images/ships/shptauto/SHOT_E0002_BMP.bmp 
-ExtraSprites3 = images/ships/shptauto/SHOT_E0003_BMP.bmp 
-ExtraSprites4 = images/ships/shptauto/SHOT_E0004_BMP.bmp 
-ExtraSprites5 = images/ships/shptauto/SHOT_E0005_BMP.bmp 
-ExtraSprites6 = images/ships/shptauto/SHOT_E0006_BMP.bmp 
-ExtraSprites7 = images/ships/shptauto/SHOT_E0007_BMP.bmp 
-ExtraSprites8 = images/ships/shptauto/SHOT_E0008_BMP.bmp 
-ExtraSprites9 = images/ships/shptauto/SHOT_E0009_BMP.bmp 
-ExtraSprites10 = images/ships/shptauto/SHOT_E0010_BMP.bmp 
-ExtraSprites11 = images/ships/shptauto/SHOT_E0011_BMP.bmp 
+ExtraSprites0 = images/ships/shptauto/SHOT_E0000_BMP.bmp
+ExtraSprites1 = images/ships/shptauto/SHOT_E0001_BMP.bmp
+ExtraSprites2 = images/ships/shptauto/SHOT_E0002_BMP.bmp
+ExtraSprites3 = images/ships/shptauto/SHOT_E0003_BMP.bmp
+ExtraSprites4 = images/ships/shptauto/SHOT_E0004_BMP.bmp
+ExtraSprites5 = images/ships/shptauto/SHOT_E0005_BMP.bmp
+ExtraSprites6 = images/ships/shptauto/SHOT_E0006_BMP.bmp
+ExtraSprites7 = images/ships/shptauto/SHOT_E0007_BMP.bmp
+ExtraSprites8 = images/ships/shptauto/SHOT_E0008_BMP.bmp
+ExtraSprites9 = images/ships/shptauto/SHOT_E0009_BMP.bmp
+ExtraSprites10 = images/ships/shptauto/SHOT_E0010_BMP.bmp
+ExtraSprites11 = images/ships/shptauto/SHOT_E0011_BMP.bmp
 
 ExtraExplosion0 = images/ships/shptauto/SHOT_F00_BMP.bmp

Modified: trunk/gamedata/default_ini/ships/shpthrto.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpthrto.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpthrto.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -6,6 +6,7 @@
 Origin = UQM
 Coders = The Fly
 Code = ThraddashTorch
+Version = 65M
 
 [Ship]
 Crew = 8
@@ -68,26 +69,26 @@
 SpecialSample0 = sound/ships/shpthrto/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 39 +alpha
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 39 +alpha
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpthrto/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpthrto/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpthrto/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpthrto/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpthrto/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpthrto/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpthrto/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpthrto/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpthrto/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpthrto/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpthrto/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpthrto/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpthrto/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpthrto/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpthrto/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpumgdr.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpumgdr.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpumgdr.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = UmgahDrone
+Version = 65M
 
 [Ship]
 Crew = 10
@@ -65,26 +66,26 @@
 SpecialSample0 = sound/ships/shpumgdr/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 6r +noaa
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 0
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 6r +noaa
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 0
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpumgdr/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpumgdr/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpumgdr/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpumgdr/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpumgdr/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpumgdr/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpumgdr/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpumgdr/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpumgdr/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpumgdr/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpumgdr/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpumgdr/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpumgdr/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpumgdr/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpumgdr/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shputwju.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shputwju.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shputwju.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -6,6 +6,7 @@
 Origin = UQM
 Coders = The Fly
 Code = UtwigJugger
+Version = 65M
 
 [Ship]
 Crew = 20
@@ -62,26 +63,26 @@
 SpecialSample0 = sound/ships/shputwju/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 0
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 0
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shputwju/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shputwju/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shputwju/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shputwju/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shputwju/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shputwju/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shputwju/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shputwju/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shputwju/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shputwju/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shputwju/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shputwju/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shputwju/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shputwju/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shputwju/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpvuxin.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpvuxin.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpvuxin.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = VuxIntruder
+Version = 65M
 
 [Ship]
 Crew = 20
@@ -71,26 +72,26 @@
 SpecialSample1 = sound/ships/shpvuxin/WAVE_B02_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 3r
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 11
-SpecialSamples   = 2
+ShipSprites = 1r
+WeaponSprites = 3r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 11
+SpecialSamples = 2
 SpecialExplosion = 0
-ExtraSprites     = 3r
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 3r
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpvuxin/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpvuxin/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpvuxin/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpvuxin/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpvuxin/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpvuxin/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpvuxin/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpvuxin/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpvuxin/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpvuxin/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpvuxin/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpvuxin/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpvuxin/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpvuxin/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpvuxin/SHIP_S00_PCX.bmp
@@ -111,7 +112,7 @@
 SpecialSprites9 = images/ships/shpvuxin/SHOT_A10_PCX.bmp
 SpecialSprites10 = images/ships/shpvuxin/SHOT_A11_PCX.bmp
               
-ExtraSprites0  = images/ships/shpvuxin/SHOT_E00_PCX.bmp
-ExtraSprites1  = images/ships/shpvuxin/SHOT_E01_PCX.bmp
-ExtraSprites2  = images/ships/shpvuxin/SHOT_E02_PCS.bmp
+ExtraSprites0 = images/ships/shpvuxin/SHOT_E00_PCX.bmp
+ExtraSprites1 = images/ships/shpvuxin/SHOT_E01_PCX.bmp
+ExtraSprites2 = images/ships/shpvuxin/SHOT_E02_PCS.bmp
 

Modified: trunk/gamedata/default_ini/ships/shpyehte.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpyehte.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpyehte.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = YehatTerminator
+Version = 65M
 
 [Ship]
 Crew = 20
@@ -66,26 +67,26 @@
 SpecialSample0 = sound/ships/shpyehte/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 1r
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 1r
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 1r
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpyehte/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpyehte/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpyehte/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpyehte/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpyehte/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpyehte/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpyehte/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpyehte/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpyehte/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpyehte/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpyehte/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpyehte/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpyehte/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpyehte/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpyehte/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpzeksh.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpzeksh.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpzeksh.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -5,6 +5,7 @@
 Origin = TW
 Coders = Richardyzo
 Code = ZekfahanShocker
+Version = 65M
 
 [Ship]
 Crew = 42
@@ -47,26 +48,26 @@
 SpecialSample2 = sound/ships/shpzeksh/WAVE_B03_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 5
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 6
-SpecialSamples   = 3
+ShipSprites = 1r
+WeaponSprites = 5
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 6
+SpecialSamples = 3
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
-PanelBitmaps0  = images/ships/shpzeksh/SHIP_P00_PCX.bmp
-PanelBitmaps1  = images/ships/shpzeksh/SHIP_P01_PCX.bmp
-PanelBitmaps2  = images/ships/shpzeksh/SHIP_P02_PCX.bmp
-PanelBitmaps3  = images/ships/shpzeksh/SHIP_P03_PCX.bmp
-PanelBitmaps4  = images/ships/shpzeksh/SHIP_P04_PCX.bmp
-PanelBitmaps5  = images/ships/shpzeksh/SHIP_P05_PCX.bmp
-PanelBitmaps6  = images/ships/shpzeksh/SHIP_P06_PCX.bmp
+PanelBitmaps0 = images/ships/shpzeksh/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpzeksh/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpzeksh/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpzeksh/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpzeksh/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpzeksh/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpzeksh/SHIP_P06_PCX.bmp
 
 
 ShipSprites0 = images/ships/shpzeksh/SHIP_S01_PCX.bmp

Modified: trunk/gamedata/default_ini/ships/shpzfpst.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpzfpst.ini	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/gamedata/default_ini/ships/shpzfpst.ini	2004-09-26 18:31:46 UTC (rev 66)
@@ -6,6 +6,7 @@
 Origin = UQM
 Coders = The Fly
 Code = ZoqFotPikStinger
+Version = 65M
 
 [Ship]
 Crew = 10
@@ -33,7 +34,7 @@
 [Special]
 Damage = 12		;4
 Licking = 0		;1
-; 0 makes it use "flat" damage
+; = 0 makes it use "flat" damage
 
 [AI3_Default]
 Tactic = Direct
@@ -70,17 +71,17 @@
 SpecialSample0 = sound/ships/shpzfpst/WAVE_B01_WAV.wav
 
 [Objects]
-ShipSprites      = 1r
-WeaponSprites    = 6
-WeaponSamples    = 1
-WeaponExplosion  = 0
-SpecialSprites   = 6r
-SpecialSamples   = 1
+ShipSprites = 1r
+WeaponSprites = 6
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 6r
+SpecialSamples = 1
 SpecialExplosion = 0
-ExtraSprites     = 0
-ExtraSamples     = 0
-ExtraExplosion   = 0
-PanelBitmaps     = 7
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
 
 [Graphic]
 PanelBitmaps0 = images/ships/shpzfpst/SHIP_P00_PCX.bmp

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2004-09-26 13:47:54 UTC (rev 65)
+++ trunk/source/scp.cpp	2004-09-26 18:31:46 UTC (rev 66)
@@ -60,8 +60,12 @@
 
 
 /// Get SVN revision number from version file (this function work if user does not have subversion)
-std::string GetSVNFromVersionFile()
+std::string GetSVNVersion()
 {
+  std::string tw_svn_version = TW_SVNVERSION;
+  if(!(tw_svn_version=="exported"||tw_svn_version == ""))
+    return tw_svn_version;
+  
   int i;
   char buffy [16000] = {0};
   PACKFILE *f;
@@ -93,12 +97,9 @@
   STACKTRACE;
   std::string tw_version_string;
 
-  std::string tw_svn_version = TW_SVNVERSION;
-  if(tw_svn_version=="exported"||tw_svn_version == "")
-    tw_svn_version = GetSVNFromVersionFile();
   tw_version_string += std::string(APPLICATION_NAME) + " "  + std::string(TW_MAJOR_VERSION) 
     + "r" 
-    + tw_svn_version
+    + GetSVNVersion()
     + " Built: "
     + __DATE__
     + " "
@@ -1651,6 +1652,16 @@
   std::string home_file = home_ini_full_path(std::string("ships/") + ship_name);
   if(!exists(home_file.c_str()))
      CopyFile(filename, home_file.c_str());
+  
+  tw_set_config_file(home_file);
+  int version = get_config_int("Info", "Version", -1);
+  if(version<64)
+    {
+      CopyFile(filename, home_file.c_str());
+      tw_set_config_file(home_file);
+      std::string ver = GetSVNVersion();
+      set_config_string("Info", "Version", ver.c_str());
+    }
 }
 
 #ifdef WIN32



From yurand at sheep.berlios.de  Mon Sep 27 22:14:30 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Mon, 27 Sep 2004 22:14:30 +0200
Subject: [Tw-light-svn] r67 - trunk/web
Message-ID: <200409272014.i8RKEUPS010426@sheep.berlios.de>

Author: yurand
Date: 2004-09-27 22:14:25 +0200 (Mon, 27 Sep 2004)
New Revision: 67

Modified:
   trunk/web/info.html
   trunk/web/links.html
   trunk/web/team.html
   trunk/web/update.sh
Log:
Web update


Modified: trunk/web/info.html
===================================================================
--- trunk/web/info.html	2004-09-26 18:31:46 UTC (rev 66)
+++ trunk/web/info.html	2004-09-27 20:14:25 UTC (rev 67)
@@ -52,7 +52,7 @@
   and a bunch of powerful friends at your side! Or so you believe...
   </p>
   <p class="indented">
-  TWX:Legacies will start right after StarControl II.
+  TW:Legacies will start right after StarControl II.
   </p>
   
   <p class="indented">

Modified: trunk/web/links.html
===================================================================
--- trunk/web/links.html	2004-09-26 18:31:46 UTC (rev 66)
+++ trunk/web/links.html	2004-09-27 20:14:25 UTC (rev 67)
@@ -38,6 +38,11 @@
     <li><a href="http://twx.sourceforge.net">TWX</a> </li>
 </ul>
 
+<h3>Other links</h3>
+<ul>
+    <li><a href="http://www.classicgaming.com/starcontrol/">The Pages of Now and Forever</a></li>
+    <li><a href="http://s93020567.onlinehome.us/scrpg2k3_play.htm">StarConRPG</a></li>
+</ul>
 </div>
 
 <p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>

Modified: trunk/web/team.html
===================================================================
--- trunk/web/team.html	2004-09-26 18:31:46 UTC (rev 66)
+++ trunk/web/team.html	2004-09-27 20:14:25 UTC (rev 67)
@@ -33,7 +33,7 @@
   <h4>Content and Plot manager:</h4>
 
   <ul>
-    <li>Asaf Hamtzany <a href="">(UAF)</a></li>
+    <li>Asaf Hamtzany <a href="mailto:uaf at users.berlios.de">(UAF)</a></li>
   </ul>
   
   <h4>Dialog Writers</h4>
@@ -42,9 +42,15 @@
     <li>Pelorki</li>
   </ul>
   
+  <h4>Graphic Designers</h>
+  <ul>
+    <li>Rick Bushie <a href="mailto:firehazurd at yahoo.com">(Firehazurd)</a></li>
+  </ul>
+  
   <h4>Special Thanks:</h4>
   <ul>
     <li>Tau</li>
+    <li>GeomanNL</li>
     <li>Officer Flubbo</li>
     <li>Captain Maim</li>
     <li>Jumping Peppers</li>

Modified: trunk/web/update.sh
===================================================================
--- trunk/web/update.sh	2004-09-26 18:31:46 UTC (rev 66)
+++ trunk/web/update.sh	2004-09-27 20:14:25 UTC (rev 67)
@@ -1,2 +1,2 @@
 #!/bin/bash
-pscp 3dlogo.jpg background.jpg dialog-editor-win32-62.zip downloads.html index.html info.html links.html team.html style.css yurand at shell.berlios.de:/home/groups/tw-light/htdocs
\ No newline at end of file
+pscp 3dlogo.jpg background.jpg downloads.html index.html info.html links.html team.html style.css yurand at shell.berlios.de:/home/groups/tw-light/htdocs
\ No newline at end of file



From yurand at sheep.berlios.de  Tue Sep 28 00:04:10 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Tue, 28 Sep 2004 00:04:10 +0200
Subject: [Tw-light-svn] r68 - in trunk: . doc gamedata gamedata/default_ini source source/games source/melee source/other source/sc1ships source/sc2ships source/ships
Message-ID: <200409272204.i8RM4AP2013504@sheep.berlios.de>

Author: yurand
Date: 2004-09-28 00:04:09 +0200 (Tue, 28 Sep 2004)
New Revision: 68

Modified:
   trunk/doc/Doxyfile
   trunk/gamedata/default_ini/scp.ini
   trunk/gamedata/readme.html
   trunk/makefile
   trunk/source/games/gdefender.cpp
   trunk/source/melee.h
   trunk/source/melee/mcbodies.cpp
   trunk/source/melee/mframe.cpp
   trunk/source/melee/mframe.h
   trunk/source/melee/mgame.cpp
   trunk/source/melee/mgame.h
   trunk/source/melee/mship.cpp
   trunk/source/melee/mshot.cpp
   trunk/source/melee/mshppan.cpp
   trunk/source/other/planet3d.cpp
   trunk/source/other/vbodies.cpp
   trunk/source/sc1ships/shpandgu.cpp
   trunk/source/sc1ships/shpmmrxf.cpp
   trunk/source/sc2ships/shpchmav.cpp
   trunk/source/sc2ships/shporzne.cpp
   trunk/source/sc2ships/shppkufu.cpp
   trunk/source/sc2ships/shpthrto.cpp
   trunk/source/scp.cpp
   trunk/source/ships/shpaktgu.cpp
   trunk/source/ships/shpalabc.cpp
   trunk/source/ships/shpbipka.cpp
   trunk/source/ships/shpchoex.cpp
   trunk/source/ships/shpconca.cpp
   trunk/source/ships/shpearc3.cpp
   trunk/source/ships/shprogsq.cpp
   trunk/source/ships/shptauda.cpp
   trunk/source/ships/shptaume.cpp
   trunk/source/ships/shptauto.cpp
Log:
Meleedata moved back to game class,
Updated documentation, updated ini


Modified: trunk/doc/Doxyfile
===================================================================
--- trunk/doc/Doxyfile	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/doc/Doxyfile	2004-09-27 22:04:09 UTC (rev 68)
@@ -4,7 +4,7 @@
 # General configuration options
 #---------------------------------------------------------------------------
 PROJECT_NAME           = TW-Light
-PROJECT_NUMBER         = 0.3b64
+PROJECT_NUMBER         = 0.3b67
 OUTPUT_DIRECTORY       = ./
 OUTPUT_LANGUAGE        = English
 USE_WINDOWS_ENCODING   = YES

Modified: trunk/gamedata/default_ini/scp.ini
===================================================================
--- trunk/gamedata/default_ini/scp.ini	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/gamedata/default_ini/scp.ini	2004-09-27 22:04:09 UTC (rev 68)
@@ -10,7 +10,7 @@
 Right = 83
 Fire = 67
 AltFire = 63
-Special = 108
+Special = 106
 Next_Target = 65
 Prev_Target = 66
 Closest_Target = 16

Modified: trunk/gamedata/readme.html
===================================================================
--- trunk/gamedata/readme.html	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/gamedata/readme.html	2004-09-27 22:04:09 UTC (rev 68)
@@ -1,216 +1,54 @@
-<html>
-<head>
-    <title>TW-Light Readme</title>
-</head>
-<body>
-
-<h1>TW-Light Readme</h1>
-
-<h2>Overview: What is TW-Light?</h2>
-
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TW-Light: TW-Light</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.3.8 -->
+<h1>TW-Light </h1>
 <p>
-TW-Light is lightweighted version of Star Control: TimeWarp.
-Currently it includes only a combat portion with the best TW ships but 
-without network support. There are some plans to expand it to include an 
-epic adventure.
-</p>
-
-<h2>Getting Started</h2>
-
-<p>
-<pre>
-Melee:  Starts a battle.  In battle the following keys do stuff:
-        F1 brings up the help screen (this file, at the moment)
-        F2 brings up the options menu
-        F3 switches camera focus
-        F4 is fast-forward (speeds up in-game time greatly)
-        F5 displays fleet status
-        F7 changes game tic rate (physics quality)
-        F8 changes camera mode
-        F9 creates planets (silly "feature")
-        F10 quits (so does ESCAPE)
-        F11 saves screenshots
-        F12 displays framerates / performance data
-        - zooms out on some viewing modes.
-        + (or =) zooms in on some viewing modes.
-        0 and 9 also effect the camera in some viewing modes.
-        ctrl+T = toggle team indicators on/off
-        ctrl+H = toggle healthbar indicators on/off
-        Also, if some controllers are set to keyboard, customizable
-        buttons may cause ship actions.  Be default these are:
-        Config 0:
-                left:   Keypad 4
-                thrust: Keypad 8
-                right:  Keypad 6
-                fire:   Quote (")
-                special:Semicolon (;)
-                next:   Closebrace (])
-                prev:   Openbrace ([)
-                near:   P
-        Config 1:
-                left:   A
-                thrust: S
-                right:  D
-                fire:   B
-                special:V
-                next:   F
-                prev:   G
-                near:   H
-Extended Menu:
-	Play Game:
-               Same as "Melee" now
-	Key Tester:
-               Use this utility to check keys combination for conflicts.
-	Ship Info:
-		Here you can get detail information about every 
-             ship in the game.
-	Diagnostic:
-                Show comlile options and version information. 
-	Main Menu:
-                This returns to the main menu.
-		
-Teams:
-        Select Controller:
-                Select the player (i.e. "Player 1" or "Player 2")
-              you wish to alter from the list on the left, and
-              the controller (i.e. "Keyboard", "MoronBot") you
-              want to control that player from the list on the
-              left.  Then either click on the "Select
-              Controller" button or double click on the
-              controller name.
-	Change Team #: 
-	        This switches the player allys. 
-	      Note that team 0 mean no allys.
-        Change Config #:
-                 This switches the configuration used by the
-               currently highlighted controller.  
-        Edit Configuration:
-                 This is used to setup up keys when the currently
-               highlighted player is using the keyboard.  It
-               may eventually allow the configuration of AIs
-               and calibration of joysticks.
-        Edit Fleet:
-                 This button brings up the fleet selection menu for
-               the currently highlighted player.  
-        Main Menu:
-                 This returns to the main menu.
-Options:
-        Most things on this menu are self-explanatory, but a few
-          need special mention.
-
-        Gamma correction:
-                This makes things brighter during combat.  This
-                  should not be changed from the middle of combat,
-                  or colors could get weird.  
-        Antialiasing:
-                If this box is checked then TimeWarp will use
-                  higher quality graphics, but run slower.  
-        Color Depth:
-                You cannot change this from the middle of combat.  
-        Camera Mode:
-                This allows you to control what is shown on your
-                  screen in combat.  
-
-                "Enemy_Discrete"
-                  is just like Star Control on the PC, where
-                  the camera moved to keep both you and your
-                  enemy onscreen, and zoomed in by factors of
-                  2.
-                "Enemy"
-                  is like Star Control on the Genesis or 3DO,
-                  where the camera zoomed in smoothly.
-                "Hero"
-                  makes the camera stay focused on Player 1,
-                  and zoom in/out when + and - are pressed.
-                "Everything"
-                  makes the camera stay on the planet and zoom
-                  way out so that everything is visible.  This
-                  mode is slightly buggy (visual artifacts).  
-</pre>
-</p>
-
-<h2>Development</h2>
-<p>
-  <ul>
-	<li>Introduce the most interesting and cool TimeWarp ships</li>
-	<li>Simplify and fix melee engine</li>
-	<li>Add TimeWarp Markup Language (TML) support</li>
-	<li>Write plot</li>
-	<li>Implement plot with TML</li>
-  </ul>
-</p>
-
-<h4>Introduce the most interesting and cool TimeWarp ships</h4>
-<p>
-Currently TW-Light includes the following ships:<br>
+<h3 align="center">0.3b68 </h3><h2><a class="anchor" name="overview_sec">
+Overview: What is TW-Light?</a></h2>
+TW-Light is an open source clone/sequel to the epic cross-genre game Star Control II. Currently it includes only a combat portion, although epic adventure part that is called TW:Legacies is actively developed now.<h2><a class="anchor" name="getting_started_sec">
+Getting Started</a></h2>
 <ul>
-	<li>Alary Battlecruiser</li>
-	<li>Bipole Katamaran</li>
-	<li>The Chorali Extractor</li>
-	<li>Confed Cargotran</li>
-	<li>Confederation Hornet</li>
-	<li>Drax Griffon</li>
-	<li>Earthling Crusader MK2</li>
-	<li>Earthling Crusader MK3</li>
-	<li>Zekfahan Shocker</li>
-	<li>Garash Tyrant</li>
-	<li>Ilwrath Spider</li>
-	<li>Kahr Boomerang</li>
-	<li>Re-Koj Assassin</li>
-	<li>Rogue Squadron</li>
-	<li>Tau Archon</li>
-	<li>Tau Dagger</li>
-	<li>Tau Slider</li>
-	<li>Tau Torrent</li>
-	<li>Zekfahan Shocker</li>
-</ul>
-</p>
-
-<h4>Simplify and fix melee engine</h4>
+<li>Melee: Starts a battle. In battle the following keys do stuff:<ul>
+<li>F1 brings up the help screen (this file, at the moment)</li><li>F2 brings up the options menu</li><li>F3 switches camera focus</li><li>F4 is fast-forward (speeds up in-game time greatly)</li><li>F5 displays fleet status</li><li>F7 changes game tic rate (physics quality)</li><li>F8 changes camera mode</li><li>F9 creates planets (silly "feature")</li><li>F10 quits (so does ESCAPE)</li><li>F11 saves screenshots</li><li>F12 displays framerates / performance data</li><li>- zooms out on some viewing modes.</li><li>+ (or =) zooms in on some viewing modes.</li><li>0 also effect the camera in some viewing modes.</li><li>ctrl+T = toggle team indicators on/off</li><li>ctrl+H = toggle healthbar indicators on/off</li><li>Also, if some controllers are set to keyboard, customizable</li><li>buttons may cause ship actions. Be default these are:</li><li>Config 0:<ul>
+<li>left: Keypad 4</li><li>thrust: Keypad 8</li><li>right: Keypad 6</li><li>fire: Enter</li><li>special:Ctrl</li><li>next: Closebrace (])</li><li>prev: Openbrace ([)</li><li>near: P</li></ul>
+</li></ul>
+</li></ul>
 <p>
-  We are working on it.
-</p>
-
-<h4>Add TimeWarp Markup Language (TML) support</h4>
+See ingame help for controls description.<h2><a class="anchor" name="development">
+Development</a></h2>
+Full developer documentation can be produced using doxygen tool.<p>
+Following documents describes some of the issues concerning contributing to TW-Light<ul>
+<li><a class="el" href="coding_page.html">A guide to a few of the wierder issues with programming for TW-Light.</a></li><li><a class="el" href="howto_document.html">Document your code</a></li></ul>
 <p>
-  No progress.
-</p>
-
-<h4>Write plot</h4>
-<p>
-  The official TW-Light plot is TW-Legacies.
-</p>
-
-<h4>Implement plot with TML</h4>
-<p>
-  No progress.
-</p>
-
-<h2>License</h2>
-
-<p>
-  Copyright (C) 2004 <a href=mailto:yurand at land.ru>Yura Semashko aka Yurand</a><br>
-  Copyright (C) 2001-2004  TimeWarp development team<br>
-<br>
-  This program is free software; you can redistribute it and/or modify <br>
-  it under the terms of the GNU General Public License as published by <br>
-  the Free Software Foundation; either version 2 of the License, or    <br>
-  (at your option) any later version. <br>
-                                          <br>
-  This program is distributed in the hope that it will be useful,<br>
-  but WITHOUT ANY WARRANTY; without even the implied warranty of<br>
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br>
-  GNU General Public License for more details.
-</p>
-
-<h2>Credits</h2>
-<pre>
-
-  TW-Light is derivative work from <a href="http://timewarp.sf.net/">Star Control: TimeWarp</a>
-
-</pre>
-
-
-</div>
+Currently we are working on the following tasks:<p>
+<ul>
+<li>Introduce the most interesting and cool TimeWarp ships</li><li>Simplify and fix melee engine</li><li>Add TimeWarp Markup Language (TML) support</li><li>Write plot</li><li>Implement plot with TML</li></ul>
+<h3><a class="anchor" name="intoro">
+Introduce the most interesting and cool TimeWarp ships</a></h3>
+Currently TW-Light includes the following ships:<p>
+<ul>
+<li>Alary Battlecruiser</li><li>Bipole Katamaran</li><li>The Chorali Extractor</li><li>Confed Cargotran</li><li>Confederation Hornet</li><li>Drax Griffon</li><li>Earthling Crusader MK3</li><li>Zekfahan Shocker</li><li>Garash Tyrant</li><li>Ilwrath Spider</li><li>Kahr Boomerang</li><li>Re-Koj Assassin</li><li>Rogue Squadron</li><li>Tau Archon</li><li>Tau Dagger</li><li>Tau Slider</li><li>Tau Torrent</li><li>Zekfahan Shocker</li></ul>
+<h3><a class="anchor" name="simplyfy_subsec">
+Simplify and fix melee engine</a></h3>
+Almost done.<h3><a class="anchor" name="TML_subsec">
+Add TimeWarp Markup Language (TML) support</a></h3>
+No progress.<h3><a class="anchor" name="plot_subsec">
+Write plot</a></h3>
+The Plot is fully writen.<h3><a class="anchor" name="plot_impl_subsec">
+Implement plot with TML</a></h3>
+No progress.<h2><a class="anchor" name="licene_sec">
+License</a></h2>
+Copyright (C) 2004 <a href="mailto:yurand at land.ru">Yura Semashko aka Yurand</a> Copyright (C) 2001-2004 TimeWarp development team<p>
+This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.<p>
+This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.<h2><a class="anchor" name="credits_sec">
+Credits</a></h2>
+<ul>
+<li>TW-Light is derivative work from <a href="timewarp.sourceforge.net">Star Control: TimeWarp</a></li><li>Some code and documents were taken from <a href="www.wesnoth.org">Battle for Wesnoth</a></li><li>UQM Ships description were taken from Ultronomicon (<a href="http://uqm.stack.nl/wiki/">http://uqm.stack.nl/wiki/</a>)</li><li>Some battle music were written by Robeter Productions Inc. </li></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Mon Sep 27 22:11:45 2004 for TW-Light by
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
 </body>
-</head>
+</html>

Modified: trunk/makefile
===================================================================
--- trunk/makefile	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/makefile	2004-09-27 22:04:09 UTC (rev 68)
@@ -206,18 +206,7 @@
 
 uninstall:
 	$(RM) $(EXECPATH)/$(NAME)
-	$(RM) $(DATAPATH)/ships/shp*.dat
-	$(RM) $(DATAPATH)/*.dat
-	$(RM) $(DATAPATH)/*.html
-	$(RM) $(DATAPATH)/*.txt
-	$(RM) $(DATAPATH)/palette
-	$(RM) $(DATAPATH)/ships/shp*.txt
-	rmdir $(DATAPATH)/ships
-	$(RM) $(DATAPATH)/default_ini/*.ini
-	$(RM) $(DATAPATH)/default_ini/ships/shp*.ini
-	rmdir $(DATAPATH)/default_ini/ships
-	rmdir $(DATAPATH)/default_ini
-	rmdir $(DATAPATH)
+	$(RM) -r $(DATAPATH)
 
 
 -include $(DEPS)

Modified: trunk/source/games/gdefender.cpp
===================================================================
--- trunk/source/games/gdefender.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/games/gdefender.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -91,8 +91,8 @@
   health -= direct;
   if (health <= 0) 
     {
-      add ( new Animation ( this, pos, meleedata.kaboomSprite, 0, 
-			    meleedata.kaboomSprite->frames(), 50, DEPTH_EXPLOSIONS) );
+      add ( new Animation ( this, pos, game->meleedata.kaboomSprite, 0, 
+			    game->meleedata.kaboomSprite->frames(), 50, DEPTH_EXPLOSIONS) );
       state = 0;
     }
   return iround(old-health);

Modified: trunk/source/melee/mcbodies.cpp
===================================================================
--- trunk/source/melee/mcbodies.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/melee/mcbodies.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -33,7 +33,7 @@
 #include "other/twconfig.h"
 
 Asteroid::Asteroid() 
-:	SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite), explosion(meleedata.asteroidExplosionSprite)
+:	SpaceObject(NULL, random(map_size), random(PI2), game->meleedata.asteroidSprite), explosion(game->meleedata.asteroidExplosionSprite)
 {
   STACKTRACE;
   collide_flag_sameteam = ALL_LAYERS;

Modified: trunk/source/melee/mframe.cpp
===================================================================
--- trunk/source/melee/mframe.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/melee/mframe.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -68,7 +68,7 @@
 int physics_time = 0;
 int render_time = 0;
 int frame_time = 1;
-DATAFILE *melee = NULL;
+//DATAFILE *melee = NULL;
 Vector2 map_size;
 double MAX_SPEED = 0;
 
@@ -939,7 +939,7 @@
   damage(other, damage_factor);
   collide_flag_anyone = collide_flag_sameship = collide_flag_sameteam = 0;
   physics->add(new Animation( this, 
-			      pos + edge(), meleedata.sparkSprite, 0, 
+			      pos + edge(), game->meleedata.sparkSprite, 0, 
 			      SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
   return;
 }

Modified: trunk/source/melee/mframe.h
===================================================================
--- trunk/source/melee/mframe.h	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/melee/mframe.h	2004-09-27 22:04:09 UTC (rev 68)
@@ -29,7 +29,7 @@
 extern Vector2 map_size;
 extern double MAX_SPEED;
 
-extern DATAFILE *melee;
+//extern DATAFILE *melee;
 
 typedef unsigned int TeamCode;
 
@@ -37,7 +37,6 @@
 class Planet;
 class Presence;
 
-
 enum {
   ATTRIB_SYNCHED         =    (1<<0), 
   ATTRIB_LOGGED          =    (1<<1), 
@@ -87,7 +86,7 @@
   
   TeamCode last_team;
   unsigned int last_ship;
-  
+
  protected:
   /// \brief calculate which object collide
   virtual void collide();

Modified: trunk/source/melee/mgame.cpp
===================================================================
--- trunk/source/melee/mgame.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/melee/mgame.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -1,7 +1,7 @@
 /* $Id: mgame.cpp,v 1.5 2004/08/08 17:36:06 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -52,77 +52,78 @@
 
 int random_seed[2];
 
-MeleeData meleedata;
 
 MeleeData::MeleeData()
 {
   STACKTRACE;
-	panelSprite             = NULL;
-	kaboomSprite            = NULL;
-	hotspotSprite           = NULL;
-	sparkSprite             = NULL;
-	asteroidExplosionSprite = NULL;
-	asteroidSprite          = NULL;
-	planetSprite            = NULL;
-	xpl1Sprite              = NULL;
+  
+  DATAFILE*  melee = load_datafile(data_full_path("melee.dat").c_str());
+  
+  if (!melee) 
+    tw_error("Error loading melee data\n");
 
-	melee = NULL;
+  panelSprite = new SpaceSprite(&melee[MELEE_PANEL], 
+				PANEL_FRAMES, SpaceSprite::IRREGULAR);
+  kaboomSprite = new SpaceSprite(&melee[MELEE_KABOOM], KABOOM_FRAMES,
+				 SpaceSprite::ALPHA | SpaceSprite::MASKED | 
+				 SpaceSprite::MIPMAPED);
+  hotspotSprite = new SpaceSprite(&melee[MELEE_HOTSPOT], HOTSPOT_FRAMES,
+				  SpaceSprite::ALPHA | SpaceSprite::MASKED | 
+				  SpaceSprite::MIPMAPED);
+  sparkSprite = new SpaceSprite(&melee[MELEE_SPARK], SPARK_FRAMES,
+				SpaceSprite::ALPHA | SpaceSprite::MASKED | 
+				SpaceSprite::MIPMAPED | 
+				SpaceSprite::MATCH_SCREEN_FORMAT);
+  asteroidExplosionSprite = new SpaceSprite(&melee[MELEE_ASTEROIDEXPLOSION], 
+					    ASTEROIDEXPLOSION_FRAMES);
+  asteroidSprite = new SpaceSprite(&melee[MELEE_ASTEROID], ASTEROID_FRAMES);
+  planetSprite = new SpaceSprite(&melee[MELEE_PLANET], PLANET_FRAMES);
+  xpl1Sprite = new SpaceSprite(&melee[MELEE_XPL1], XPL1_FRAMES,
+			       SpaceSprite::ALPHA | SpaceSprite::MASKED | 
+			       SpaceSprite::MIPMAPED);
+  unload_datafile(melee);
 }
 
-
-
-void MeleeData::init()
+MeleeData::~MeleeData()
 {
   STACKTRACE;
-  melee = load_datafile(data_full_path("melee.dat").c_str());
-  if (!melee) tw_error("Error loading melee data\n");
-
-  meleedata.panelSprite             = new SpaceSprite(&melee[MELEE_PANEL], 
-						      PANEL_FRAMES, SpaceSprite::IRREGULAR);
-  meleedata.kaboomSprite            = new SpaceSprite(&melee[MELEE_KABOOM], KABOOM_FRAMES,
-						      SpaceSprite::ALPHA | SpaceSprite::MASKED | 
-						      SpaceSprite::MIPMAPED);
-  meleedata.hotspotSprite           = new SpaceSprite(&melee[MELEE_HOTSPOT], HOTSPOT_FRAMES,
-						      SpaceSprite::ALPHA | SpaceSprite::MASKED | 
-						      SpaceSprite::MIPMAPED);
-  meleedata.sparkSprite             = new SpaceSprite(&melee[MELEE_SPARK], SPARK_FRAMES,
-						      SpaceSprite::ALPHA | SpaceSprite::MASKED | 
-						      SpaceSprite::MIPMAPED | 
-						      SpaceSprite::MATCH_SCREEN_FORMAT);
-  meleedata.asteroidExplosionSprite = new SpaceSprite(&melee[MELEE_ASTEROIDEXPLOSION], 
-						      ASTEROIDEXPLOSION_FRAMES);
-  meleedata.asteroidSprite          = new SpaceSprite(&melee[MELEE_ASTEROID], ASTEROID_FRAMES);
-  meleedata.planetSprite            = new SpaceSprite(&melee[MELEE_PLANET], PLANET_FRAMES);
-  meleedata.xpl1Sprite              = new SpaceSprite(&melee[MELEE_XPL1], XPL1_FRAMES,
-						      SpaceSprite::ALPHA | SpaceSprite::MASKED | 
-						      SpaceSprite::MIPMAPED);
-  
-  //planet_victory = (Music*) (melee[MELEE_PLANET+PLANET_FRAMES].dat);
-  //  planet_victory = std::string("melee.dat#");
+  if(panelSprite)
+    {
+      delete panelSprite;
+    }
+  if(kaboomSprite)
+    {
+      delete kaboomSprite;
+    }
+  if(hotspotSprite)
+    {
+      delete hotspotSprite;
+    }
+  if(sparkSprite)
+    {
+      delete sparkSprite;
+    }
+  if(asteroidExplosionSprite)
+    {
+      delete asteroidExplosionSprite;
+    }
+  if(asteroidSprite)
+    {
+      delete asteroidSprite;
+    }
+  if(planetSprite)
+    {
+      delete planetSprite;
+    }
+  if(xpl1Sprite)
+    {
+      delete xpl1Sprite;
+    }
 }
 
-void MeleeData::deinit()
-{
-  STACKTRACE;
-	panelSprite             = NULL;
-	kaboomSprite            = NULL;
-	hotspotSprite           = NULL;
-	sparkSprite             = NULL;
-	asteroidExplosionSprite = NULL;
-	asteroidSprite          = NULL;
-	planetSprite            = NULL;
-	xpl1Sprite              = NULL;
 
-	//	planet_victory		= "";		
 
-	unload_datafile(melee);
-	
-	melee = NULL;
-}
 
-
-
-
 int interpolate_frames = false;
 
 

Modified: trunk/source/melee/mgame.h
===================================================================
--- trunk/source/melee/mgame.h	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/melee/mgame.h	2004-09-27 22:04:09 UTC (rev 68)
@@ -51,9 +51,7 @@
 {
  public:
   MeleeData();
-  
-  void init();
-  void deinit();
+  ~MeleeData();
 	
   SpaceSprite *planetSprite;
   SpaceSprite *asteroidSprite;
@@ -72,6 +70,8 @@
  public:
   GameType *type;
   
+  MeleeData meleedata;
+  
   enum 
     {
       channel_none = -1,    /**< not a valid channel */

Modified: trunk/source/melee/mship.cpp
===================================================================
--- trunk/source/melee/mship.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/melee/mship.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -494,7 +494,7 @@
 	  for (i=0; i<2; i++) 
 	    {
 	      ff = random(25);
-	      a = new Animation(this, pos, meleedata.xpl1Sprite,
+	      a = new Animation(this, pos, game->meleedata.xpl1Sprite,
 				ff, 40-ff, 25, DEPTH_EXPLOSIONS);
 	      a->transparency = 1.0 / 4;
 	      game->add(a);
@@ -532,7 +532,7 @@
 	  crew  = 0;
 	  tw_sound->play_sound(data_full_path("sound/boom/BOOMSHIP_WAV.wav"));
 	  
-	  if (meleedata.xpl1Sprite) 
+	  if (game->meleedata.xpl1Sprite) 
 	    {
 	      death_counter = 0;
 	      death_explosion_counter = 0;
@@ -541,7 +541,7 @@
 	  else 
 	    {
 	      state = 0;
-	      game->add(new Animation(this, pos, meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS));
+	      game->add(new Animation(this, pos, game->meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS));
 	    }
 	  if (attributes & ATTRIB_NOTIFY_ON_DEATH) 
 	    {
@@ -751,8 +751,7 @@
       total += crew;
       crew  = 0;
       tw_sound->play_sound(data_full_path("sound/boom/BOOMSHIP_WAV.wav"));
-      //modified by Tau - start
-      if (meleedata.xpl1Sprite) 
+      if (game->meleedata.xpl1Sprite) 
 	{
 	  death_counter = 0;
 	  death_explosion_counter = 0;
@@ -761,7 +760,7 @@
       else 
 	{
 	  state = 0;
-	  game->add(new Animation(this, pos, meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS));
+	  game->add(new Animation(this, pos, game->meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS));
 	}
       if (attributes & ATTRIB_NOTIFY_ON_DEATH) {
 	game->ship_died(this, source);
@@ -871,7 +870,7 @@
     {
       game->add(new Animation(this,
 			      normal_pos() - unit_vector(angle) * size.x / 2.5,
-			      meleedata.hotspotSprite, 0, HOTSPOT_FRAMES, time_ratio, DEPTH_HOTSPOTS));
+			      game->meleedata.hotspotSprite, 0, HOTSPOT_FRAMES, time_ratio, DEPTH_HOTSPOTS));
       hotspot_frame += hotspot_rate;
     }
   if (hotspot_frame > 0)

Modified: trunk/source/melee/mshot.cpp
===================================================================
--- trunk/source/melee/mshot.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/melee/mshot.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -38,7 +38,7 @@
 	d(0.0),
   range(orange),
   armour(oarmour),
-  explosionSprite(meleedata.sparkSprite),
+  explosionSprite(game->meleedata.sparkSprite),
   explosionFrameCount(SPARK_FRAMES),
   explosionFrameSize(scale_frames(0))
 {

Modified: trunk/source/melee/mshppan.cpp
===================================================================
--- trunk/source/melee/mshppan.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/melee/mshppan.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -206,12 +206,12 @@
 		}
 
 	if((!batt_light) && (ship->weapon_low || ship->special_low)) {
-		meleedata.panelSprite->draw(40, 58, 2, panel);
+		game->meleedata.panelSprite->draw(40, 58, 2, panel);
 		batt_light = TRUE;
 		panel_needs_update = true;
 		}
 	else if(batt_light && (!ship->weapon_low) && (!ship->special_low)) {
-		meleedata.panelSprite->draw(40, 58, 1, panel);
+		game->meleedata.panelSprite->draw(40, 58, 1, panel);
 		batt_light = FALSE;
 		panel_needs_update = true;
 		}

Modified: trunk/source/melee.h
===================================================================
--- trunk/source/melee.h	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/melee.h	2004-09-27 22:04:09 UTC (rev 68)
@@ -252,8 +252,6 @@
 extern class GobGame *&gobgame;
 extern Vector2 map_size;
 
-extern class MeleeData meleedata;
-
 //melee/mhelpers.cpp
 
 /// \brief Config event

Modified: trunk/source/other/planet3d.cpp
===================================================================
--- trunk/source/other/planet3d.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/other/planet3d.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -71,8 +71,8 @@
     
   // create a 2D planet
   Planet *planet = new Planet (position, 
-			       meleedata.planetSprite, 
-			       random(meleedata.planetSprite->frames()));
+			       game->meleedata.planetSprite, 
+			       random(game->meleedata.planetSprite->frames()));
   game->add (planet);
   return planet;
 }

Modified: trunk/source/other/vbodies.cpp
===================================================================
--- trunk/source/other/vbodies.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/other/vbodies.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -206,7 +206,8 @@
 
 //end sprite handling routines
 
-VSpaceInstallation::VSpaceInstallation():SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite)
+VSpaceInstallation::VSpaceInstallation():SpaceObject(NULL, random(map_size), 
+						     random(PI2), game->meleedata.asteroidSprite)
 {
   STACKTRACE;
 	collide_flag_sameteam = ALL_LAYERS;
@@ -612,7 +613,7 @@
 }
 
 
-VSpaceMine::VSpaceMine():SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite)
+VSpaceMine::VSpaceMine():SpaceObject(NULL, random(map_size), random(PI2), game->meleedata.asteroidSprite)
 {
   STACKTRACE;
   this->set_sprite(VSpaceMine::mySprite);
@@ -768,7 +769,7 @@
 
 VDustCloud::VDustCloud(void)
 :
-SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite)
+SpaceObject(NULL, random(map_size), random(PI2), game->meleedata.asteroidSprite)
 {
   STACKTRACE;
   double speed, angle;
@@ -860,7 +861,7 @@
 
 VGasCloud::VGasCloud(void)
 :
-SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite)
+SpaceObject(NULL, random(map_size), random(PI2), game->meleedata.asteroidSprite)
 {
   STACKTRACE;
   double speed, angle;
@@ -1280,7 +1281,7 @@
   armour = VMetalShard::myArmour;
   damage_factor = VMetalShard::myDamage;
   mass = VMetalShard::myMass;
-  explosionSprite = meleedata.sparkSprite;
+  explosionSprite = game->meleedata.sparkSprite;
   mass = 1;
   this->willRespawn = FALSE;
 }
@@ -1296,7 +1297,7 @@
   this->set_sprite(mySprite);
   armour = VMetalShard::myArmour;
   damage_factor = VMetalShard::myArmour;
-  explosionSprite = meleedata.sparkSprite;
+  explosionSprite = game->meleedata.sparkSprite;
   mass = VMetalShard::myMass;
   //
   this->pos = pos;
@@ -1394,7 +1395,7 @@
   this->set_sprite(mySprite);
   armour = VMetalAsteroid::myArmour;
   damage_factor = VMetalAsteroid::myDamage;
-  explosionSprite = meleedata.sparkSprite;
+  explosionSprite = game->meleedata.sparkSprite;
   mass = VMetalAsteroid::myMass;
   this->willRespawn = TRUE;
 }
@@ -1511,7 +1512,7 @@
   this->set_sprite(mySprite);
   armour = VSmallAsteroid::myArmour;
   damage_factor = VSmallAsteroid::damage_factor;
-  explosionSprite = meleedata.sparkSprite;
+  explosionSprite = game->meleedata.sparkSprite;
   mass = VSmallAsteroid::mass;
   willRespawn = TRUE;
 }
@@ -1524,7 +1525,7 @@
   this->set_sprite(mySprite);
   armour = 10;
   damage_factor = 0;
-  explosionSprite = meleedata.sparkSprite;
+  explosionSprite = game->meleedata.sparkSprite;
   mass = 10;
   //
   this->pos = pos;
@@ -1621,7 +1622,7 @@
   this->set_sprite(mySprite);
   armour = VLargeAsteroid::myArmour;
   damage_factor = VLargeAsteroid::myDamage;
-  explosionSprite = meleedata.sparkSprite;
+  explosionSprite = game->meleedata.sparkSprite;
   mass = VLargeAsteroid::myMass;
   willRespawn = TRUE;
 }

Modified: trunk/source/sc1ships/shpandgu.cpp
===================================================================
--- trunk/source/sc1ships/shpandgu.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/sc1ships/shpandgu.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -112,7 +112,7 @@
 	{
 	  game->add(new Animation(this, 
 				  pos + unit_vector(trajectory_angle(other)) * 20.0,
-				  meleedata.sparkSprite, 0, SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
+				  game->meleedata.sparkSprite, 0, SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
 	  translate(-specialBounceDistance*unit_vector(angle));
 	  bounce_status = specialBounceTime;
 	  int i = iround_down(damage_factor / 2);

Modified: trunk/source/sc1ships/shpmmrxf.cpp
===================================================================
--- trunk/source/sc1ships/shpmmrxf.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/sc1ships/shpmmrxf.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -86,7 +86,7 @@
       if ((laser1->damage_factor > 0) && (laser2->damage_factor > 0))
         add(new Animation(this, 
           laser1->normal_pos() + laser1->edge(),
-          meleedata.sparkSprite, 0, SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
+          game->meleedata.sparkSprite, 0, SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
       laser1 = NULL;
       laser2 = NULL;
     }

Modified: trunk/source/sc2ships/shpchmav.cpp
===================================================================
--- trunk/source/sc2ships/shpchmav.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/sc2ships/shpchmav.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -160,7 +160,7 @@
 
 ChmmrBeam::ChmmrBeam(Ship *oship, int oframes) :
 	SpaceObject(oship, oship->normal_pos(), oship->get_angle(), 
-    meleedata.sparkSprite),
+    game->meleedata.sparkSprite),
 	frame(0),
 	frame_count(oframes),
 	ship(oship),
@@ -323,7 +323,7 @@
 			armour = 0;
 			state = 0;
 			add(new Animation(this, pos,
-					  meleedata.kaboomSprite, 0, KABOOM_FRAMES, 
+					  game->meleedata.kaboomSprite, 0, KABOOM_FRAMES, 
 					  50, DEPTH_EXPLOSIONS));
 			tw_sound->stop_sound(data_full_path(data->sampleExtra[0]));
 			tw_sound->play_sound(data_full_path(data->sampleExtra[0]));

Modified: trunk/source/sc2ships/shporzne.cpp
===================================================================
--- trunk/source/sc2ships/shporzne.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/sc2ships/shporzne.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -363,7 +363,7 @@
 	{
 	  add(new Animation(this, 
 			    normal_pos() - product(unit_vector(angle), get_size()) / 2.0,
-			    meleedata.hotspotSprite,
+			    game->meleedata.hotspotSprite,
 			    0, HOTSPOT_FRAMES, 50, DEPTH_HOTSPOTS));
 	  hotspot_frame += hotspot_rate;
 	}

Modified: trunk/source/sc2ships/shppkufu.cpp
===================================================================
--- trunk/source/sc2ships/shppkufu.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/sc2ships/shppkufu.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -50,7 +50,7 @@
     return r;
   
   tw_sound->play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
-  game->add(new Animation(this, pos,	meleedata.kaboomSprite, 0, KABOOM_FRAMES, 
+  game->add(new Animation(this, pos, game->meleedata.kaboomSprite, 0, KABOOM_FRAMES, 
 			  time_ratio, DEPTH_EXPLOSIONS));
   
   if (random() % 2) 

Modified: trunk/source/sc2ships/shpthrto.cpp
===================================================================
--- trunk/source/sc2ships/shpthrto.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/sc2ships/shpthrto.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -106,7 +106,7 @@
 	if ((armour <= 0) || (source->isObject() && ((SpaceObject*)source)->mass)) {
 		state = 0;
 		add(new Animation(this, normal_pos(), //normal_x(), normal_y(), 
-				meleedata.sparkSprite, 0, SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
+				game->meleedata.sparkSprite, 0, SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
 		}
 	return total;
 	}

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/scp.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -676,7 +676,6 @@
     set_view(v);
     init_ships();
     init_fleet();
-    meleedata.init();//mainmain
     
     if (auto_play) {// FIX ME
       if (!strcmp(auto_play, "game")) play_game(auto_param, NULL);
@@ -693,7 +692,6 @@
 	delete game;
 	game = NULL;
       }
-    meleedata.deinit();
     disable_input(); 
   }
   catch (int i) {

Modified: trunk/source/ships/shpaktgu.cpp
===================================================================
--- trunk/source/ships/shpaktgu.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/ships/shpaktgu.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -279,7 +279,7 @@
 	armour = 0;
 	state = 0;
 	game->add(new Animation(this, pos,
-				meleedata.kaboomSprite, 0, KABOOM_FRAMES, 50, LAYER_EXPLOSIONS));
+				game->meleedata.kaboomSprite, 0, KABOOM_FRAMES, 50, LAYER_EXPLOSIONS));
 	tw_sound->stop_sound(data_full_path(data->sampleExtra[0]));
 	tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
 	}

Modified: trunk/source/ships/shpalabc.cpp
===================================================================
--- trunk/source/ships/shpalabc.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/ships/shpalabc.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -389,7 +389,7 @@
     {
       game->add(new Animation(this,
 			      pos - unit_vector(angle)*size.x/3.8,
-			      meleedata.hotspotSprite, 0, HOTSPOT_FRAMES, time_ratio, LAYER_HOTSPOTS));
+			      game->meleedata.hotspotSprite, 0, HOTSPOT_FRAMES, time_ratio, LAYER_HOTSPOTS));
       hotspot_frame += hotspot_rate; 
     }
   if (hotspot_frame > 0) hotspot_frame -= frame_time;
@@ -570,7 +570,7 @@
       turret[i]->state = 0;
     tw_sound->play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
     game->add(new Animation(this, pos,
-			    meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS, 2.0));
+			    game->meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS, 2.0));
     if (attributes & ATTRIB_NOTIFY_ON_DEATH) game->ship_died(this, source);
     state = 0; return 0;
   }

Modified: trunk/source/ships/shpbipka.cpp
===================================================================
--- trunk/source/ships/shpbipka.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/ships/shpbipka.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -479,7 +479,7 @@
   STACKTRACE;
   tw_sound->play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
   game->add(new Animation(this, pos,
-			  meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, LAYER_EXPLOSIONS));
+			  game->meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, LAYER_EXPLOSIONS));
 }
 
 

Modified: trunk/source/ships/shpchoex.cpp
===================================================================
--- trunk/source/ships/shpchoex.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/ships/shpchoex.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -261,7 +261,7 @@
     int R, int Rm, int G, int Gm, int B, int Bm) :
   HomingMissile(oship, Vector2(ox,oy), oangle, ov, odamage, orange, oarmour, otrate, 
 		oship, osprite, oship->target), 
-  explosion(meleedata.asteroidExplosionSprite), frame_count(oframe_count) 
+  explosion(game->meleedata.asteroidExplosionSprite), frame_count(oframe_count) 
 {
   STACKTRACE;
 	collide_flag_sameship = bit(LAYER_SHIPS) | bit(LAYER_SHOTS);
@@ -507,7 +507,7 @@
       else
 	{
 	  grabbed->die();
-       	  add(new AsteroidMissile(0.0, (size.y * 1.0), angle, AsteroidMissileVelocity, AsteroidMissileDamage, AsteroidMissileRange, AsteroidMissileArmour, AsteroidMissileTurnRate, this, meleedata.asteroidSprite, 1,
+       	  add(new AsteroidMissile(0.0, (size.y * 1.0), angle, AsteroidMissileVelocity, AsteroidMissileDamage, AsteroidMissileRange, AsteroidMissileArmour, AsteroidMissileTurnRate, this, game->meleedata.asteroidSprite, 1,
                  tractorR, tractorRmin, tractorG, tractorGmin, tractorB, tractorBmin ));
 	  return(TRUE);
      	}

Modified: trunk/source/ships/shpconca.cpp
===================================================================
--- trunk/source/ships/shpconca.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/ships/shpconca.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -156,7 +156,7 @@
 	  do_area_damage( );
 	  
 	  tw_sound->play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
-	  game->add(new Animation(this, pos,	meleedata.kaboomSprite, 0, 
+	  game->add(new Animation(this, pos,	game->meleedata.kaboomSprite, 0, 
 				  KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS));
 	  
 	}

Modified: trunk/source/ships/shpearc3.cpp
===================================================================
--- trunk/source/ships/shpearc3.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/ships/shpearc3.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -318,7 +318,7 @@
 	int aa = get_tw_aa_mode();
 	if (!((aa & AA_BLEND) && (aa & AA_ALPHA) && (!got_spark) && !(aa & AA_NO_AA))) {
 		physics->add(new Animation( this, 
-				pos + edge(), meleedata.sparkSprite, 0, 
+				pos + edge(), game->meleedata.sparkSprite, 0, 
 				SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
 		got_spark = true; }
 

Modified: trunk/source/ships/shprogsq.cpp
===================================================================
--- trunk/source/ships/shprogsq.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/ships/shprogsq.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -673,7 +673,7 @@
 	if ( !state )
 	{
 	  tw_sound->play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
-	  game->add(new Animation(this, pos, meleedata.kaboomSprite, 0, 
+	  game->add(new Animation(this, pos, game->meleedata.kaboomSprite, 0, 
 				  KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS));
 	}
 	

Modified: trunk/source/ships/shptauda.cpp
===================================================================
--- trunk/source/ships/shptauda.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/ships/shptauda.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -156,7 +156,7 @@
 	int aa = get_tw_aa_mode();
 	if (!((aa & AA_BLEND) && (aa & AA_ALPHA) && (!got_spark) && !(aa & AA_NO_AA))) {
 		physics->add(new Animation( this, 
-				pos + edge(), meleedata.sparkSprite, 0, 
+				pos + edge(), game->meleedata.sparkSprite, 0, 
 				SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
 		got_spark = true; }
 

Modified: trunk/source/ships/shptaume.cpp
===================================================================
--- trunk/source/ships/shptaume.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/ships/shptaume.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -245,7 +245,8 @@
 	if((thrust) && (hotspot_frame <= 0)) {
 		game->add(new Animation( this, 
 				normal_pos() - unit_vector(angle) * 14,
-				meleedata.hotspotSprite, 0, HOTSPOT_FRAMES, time_ratio, DEPTH_HOTSPOTS));
+				game->meleedata.hotspotSprite, 0, HOTSPOT_FRAMES, 
+					 time_ratio, DEPTH_HOTSPOTS));
 		hotspot_frame += hotspot_rate; }
 	if (hotspot_frame > 0) hotspot_frame -= frame_time;
 	return;

Modified: trunk/source/ships/shptauto.cpp
===================================================================
--- trunk/source/ships/shptauto.cpp	2004-09-27 20:14:25 UTC (rev 67)
+++ trunk/source/ships/shptauto.cpp	2004-09-27 22:04:09 UTC (rev 68)
@@ -216,7 +216,7 @@
       else	
 	add(new Animation(this, 
 			  normal_pos() - 21 * unit_vector(angle),
-			  meleedata.hotspotSprite, 0, HOTSPOT_FRAMES, time_ratio, LAYER_HOTSPOTS));
+			  game->meleedata.hotspotSprite, 0, HOTSPOT_FRAMES, time_ratio, LAYER_HOTSPOTS));
       hotspot_frame += hotspot_rate; 
     }
   if (hotspot_frame > 0) 



From yurand at sheep.berlios.de  Tue Sep 28 01:31:40 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Tue, 28 Sep 2004 01:31:40 +0200
Subject: [Tw-light-svn] r69 - in trunk: . Util doc gamedata rawgraphic
Message-ID: <200409272331.i8RNVeTU005268@sheep.berlios.de>

Author: yurand
Date: 2004-09-28 01:31:29 +0200 (Tue, 28 Sep 2004)
New Revision: 69

Added:
   trunk/rawgraphic/
   trunk/rawgraphic/PkunkQueen.jpg
   trunk/rawgraphic/SpathiMain.jpg
Modified:
   trunk/Util/timewarp.nsi
   trunk/doc/Doxyfile
   trunk/gamedata/readme.html
   trunk/makefile
Log:
Version fixes.
New graphic added


Modified: trunk/Util/timewarp.nsi
===================================================================
--- trunk/Util/timewarp.nsi	2004-09-27 22:04:09 UTC (rev 68)
+++ trunk/Util/timewarp.nsi	2004-09-27 23:31:29 UTC (rev 69)
@@ -124,24 +124,6 @@
 
 SectionEnd
 
-Section "Source"
-  SetOutPath $INSTDIR
-  File "..\makefile"
-  File "..\tw-light.rc"
-  File "..\tw-light.ico"
-  File "..\sources.lst"
-  File "..\install-sh"
-
-  SetOutPath $INSTDIR\source
-  File /r "..\source\*.*"
-
-;  SetOutPath $INSTDIR\tests
-;  File /r "..\tests\*.*"
-  
-  SetOutPath $INSTDIR\mingw-libs
-  File /r "..\mingw-libs\*.*"
-
-SectionEnd
 ;--------------------------------
 
 ; Uninstaller

Modified: trunk/doc/Doxyfile
===================================================================
--- trunk/doc/Doxyfile	2004-09-27 22:04:09 UTC (rev 68)
+++ trunk/doc/Doxyfile	2004-09-27 23:31:29 UTC (rev 69)
@@ -4,7 +4,7 @@
 # General configuration options
 #---------------------------------------------------------------------------
 PROJECT_NAME           = TW-Light
-PROJECT_NUMBER         = 0.3b67
+PROJECT_NUMBER         = 0.3b69
 OUTPUT_DIRECTORY       = ./
 OUTPUT_LANGUAGE        = English
 USE_WINDOWS_ENCODING   = YES

Modified: trunk/gamedata/readme.html
===================================================================
--- trunk/gamedata/readme.html	2004-09-27 22:04:09 UTC (rev 68)
+++ trunk/gamedata/readme.html	2004-09-27 23:31:29 UTC (rev 69)
@@ -6,7 +6,7 @@
 <!-- Generated by Doxygen 1.3.8 -->
 <h1>TW-Light </h1>
 <p>
-<h3 align="center">0.3b68 </h3><h2><a class="anchor" name="overview_sec">
+<h3 align="center">0.3b69 </h3><h2><a class="anchor" name="overview_sec">
 Overview: What is TW-Light?</a></h2>
 TW-Light is an open source clone/sequel to the epic cross-genre game Star Control II. Currently it includes only a combat portion, although epic adventure part that is called TW:Legacies is actively developed now.<h2><a class="anchor" name="getting_started_sec">
 Getting Started</a></h2>

Modified: trunk/makefile
===================================================================
--- trunk/makefile	2004-09-27 22:04:09 UTC (rev 68)
+++ trunk/makefile	2004-09-27 23:31:29 UTC (rev 69)
@@ -7,7 +7,7 @@
 #                          {TEST=1}                                            #
 #                                                                              #
 # Define win32=1    when compiling with Mingw32 gcc compiler for windows       #
-# Define debug=1    when you want to build debug version of TimeWarp           #         
+# Define debug=1    when you want to build debug version of TimeWarp           #
 # Define xmingw=1   when compiling  win32 binary with Mingw gcc crosscompiler  #
 # Define DATAPATH   to specify where datafile stored (*nix version only)       #
 # Define EXECPATH   to specify where executable should be placed               #
@@ -16,12 +16,12 @@
 # Running just make builds the release version of TimeWarp for *nix            #
 # (Linux, FreeBSD, ...)                                                        #
 #                                                                              #
-# The game depends on Allegro (4.0.x) library, so you need to install it       #
-# before running                                                               #
+# The game depends on Allegro (4.0.x), SDL, SDL_mixer with ogg support         # 
+# libraries, so you need to install them before running.                       #
 #                                                                              #
 ################################################################################
 
-PRODUCTVERSION = 0.2
+PRODUCTVERSION = 0.3
 
 SVNVERSION = ${shell svnversion .}
 
@@ -187,6 +187,8 @@
 	svn export . $(EXPDIR)
 	$(RM) $(EXPDIR)/web/*
 	rmdir $(EXPDIR)/web
+	$(RM) $(EXPDIR)/rawgraphic/*
+	rmdir $(EXPDIR)/rawgraphic
 	echo "TW-Light $(PRODUCTVERSION)r$(SVNVERSION) - $(TIMESTAMP)" >$(EXPDIR)/gamedata/version.txt
 	echo "!define VER_VERSION $(PRODUCTVERSION)" >$(EXPDIR)/Util/ver
 	echo "!define VER_SVNVERSION $(SVNVERSION)"  >$(EXPDIR)/Util/svnver

Added: trunk/rawgraphic/PkunkQueen.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/rawgraphic/PkunkQueen.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/rawgraphic/SpathiMain.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/rawgraphic/SpathiMain.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From yurand at sheep.berlios.de  Tue Sep 28 21:44:25 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Tue, 28 Sep 2004 21:44:25 +0200
Subject: [Tw-light-svn] r70 - trunk/Util
Message-ID: <200409281944.i8SJiPcS000432@sheep.berlios.de>

Author: yurand
Date: 2004-09-28 21:44:24 +0200 (Tue, 28 Sep 2004)
New Revision: 70

Modified:
   trunk/Util/timewarp.nsi
Log:
Fixed readme link


Modified: trunk/Util/timewarp.nsi
===================================================================
--- trunk/Util/timewarp.nsi	2004-09-27 23:31:29 UTC (rev 69)
+++ trunk/Util/timewarp.nsi	2004-09-28 19:44:24 UTC (rev 70)
@@ -119,7 +119,7 @@
 !insertmacro MUI_INSTALLOPTIONS_READ $INI_VALUE "timewarp.ini" "Field 2" "State"
  StrCmp $INI_VALUE "1" "" +5
   CreateDirectory "$SMPROGRAMS\TW-Light"
-  CreateShortCut "$SMPROGRAMS\TW-Light\readme.lnk" "$INSTDIR\readme.html" "Readme.html"
+  CreateShortCut "$SMPROGRAMS\TW-Light\readme.lnk" "$INSTDIR\gamedata\readme.html" "Readme.html"
   CreateShortCut "$SMPROGRAMS\TW-Light\tw-light.lnk" "$INSTDIR\tw-light.exe" "${PRODUCT_NAME}"
 
 SectionEnd



From youbastrd at sheep.berlios.de  Tue Sep 28 21:53:13 2004
From: youbastrd at sheep.berlios.de (Paul Forest at BerliOS)
Date: Tue, 28 Sep 2004 21:53:13 +0200
Subject: [Tw-light-svn] r71 - in branches/multiplayer-branch: . Util Util/deditor doc gamedata gamedata/default_ini gamedata/default_ini/ships gamedata/images gamedata/images/ships/shpalabc gamedata/images/ships/shpandgu gamedata/images/ships/shparisk gamedata/images/ships/shpbahbu gamedata/images/ships/shpbipka gamedata/images/ships/shpchebr gamedata/images/ships/shpchmav gamedata/images/ships/shpchoex gamedata/images/ships/shpconca gamedata/images/ships/shpconho gamedata/images/ships/shpdragr gamedata/images/ships/shpdruma gamedata/images/ships/shpearc3 gamedata/images/ships/shpearcr gamedata/images/ships/shpforsh gamedata/images/ships/shpgarty gamedata/images/ships/shpilwav gamedata/images/ships/shpilwsp gamedata/images/ships/shpkahbo gamedata/images/ships/shpkohma gamedata/images/ships/shpkzedr gamedata/images/ships/shpmeltr gamedata/images/ships/shpmmrxf gamedata/images/ships/shpmycpo gamedata/images/ships/shporzne gamedata/images/ships/shppkufu gamedata/images/ships/shprogsq gamedata!
 /images/ships/shpshosc gamedata/images/ships/shpslypr gamedata/images/ships/shpspael gamedata/images/ships/shpstaba gamedata/images/ships/shpsupbl gamedata/images/ships/shpsyrpe gamedata/images/ships/shptauar gamedata/images/ships/shptauda gamedata/images/ships/shptausl gamedata/images/ships/shptauto gamedata/images/ships/shpthrto gamedata/images/ships/shpumgdr gamedata/images/ships/shputwju gamedata/images/ships/shpvuxin gamedata/images/ships/shpyehte gamedata/images/ships/shpzeksh gamedata/images/ships/shpzfpst gamedata/music gamedata/music/ditty gamedata/ships gamedata/sound gamedata/sound/ships/shpalabc gamedata/sound/ships/shpandgu gamedata/sound/ships/shparisk gamedata/sound/ships/shpbahbu gamedata/sound/ships/shpbipka gamedata/sound/ships/shpchebr gamedata/sound/ships/shpchmav gamedata/sound/ships/shpchoex gamedata/sound/ships/shpconca gamedata/sound/ships/shpconho gamedata/sound/ships/shpdragr gamedata/sound/ships/shpdruma gamedata/sound/ships/shpearc3 gamedata/soun!
 d/ships/shpearcr gamedata/sound/ships/shpforsh gamedata/sound/!
 ships/sh
Message-ID: <200409281953.i8SJrDcT001464@sheep.berlios.de>

Author: youbastrd
Date: 2004-09-28 21:53:03 +0200 (Tue, 28 Sep 2004)
New Revision: 71

Added:
   branches/multiplayer-branch/Util/addStackTrace.pl
   branches/multiplayer-branch/Util/deditor/
   branches/multiplayer-branch/gamedata/gob.dat
   branches/multiplayer-branch/gamedata/images/bspab.jpg
   branches/multiplayer-branch/gamedata/images/ships/
   branches/multiplayer-branch/gamedata/images/stangrop.jpg
   branches/multiplayer-branch/gamedata/music/ditty/
   branches/multiplayer-branch/gamedata/ships/shpmmrxf.txt
   branches/multiplayer-branch/gamedata/ships/shpthrto.txt
   branches/multiplayer-branch/gamedata/ships/shputwju.txt
   branches/multiplayer-branch/gamedata/ships/shpvuxin.txt
   branches/multiplayer-branch/gamedata/sound/ships/
   branches/multiplayer-branch/rawgraphic/
   branches/multiplayer-branch/source/games/gdefender.cpp
   branches/multiplayer-branch/source/games/ggob.cpp
   branches/multiplayer-branch/source/games/ggob.h
   branches/multiplayer-branch/source/libraries/lua/
   branches/multiplayer-branch/source/other/gup.cpp
   branches/multiplayer-branch/source/other/gup.h
   branches/multiplayer-branch/web/3dlogo.jpg
   branches/multiplayer-branch/web/background.jpg
   branches/multiplayer-branch/web/dialog-editor-win32-62.zip
   branches/multiplayer-branch/web/downloads.html
   branches/multiplayer-branch/web/info.html
   branches/multiplayer-branch/web/links.html
   branches/multiplayer-branch/web/team.html
Removed:
   branches/multiplayer-branch/gamedata/images/logo.bmp
   branches/multiplayer-branch/gamedata/ships/shpalabc.dat
   branches/multiplayer-branch/gamedata/ships/shpandgu.dat
   branches/multiplayer-branch/gamedata/ships/shparisk.dat
   branches/multiplayer-branch/gamedata/ships/shpbahbu.dat
   branches/multiplayer-branch/gamedata/ships/shpbipka.dat
   branches/multiplayer-branch/gamedata/ships/shpchebr.dat
   branches/multiplayer-branch/gamedata/ships/shpchmav.dat
   branches/multiplayer-branch/gamedata/ships/shpchoex.dat
   branches/multiplayer-branch/gamedata/ships/shpconca.dat
   branches/multiplayer-branch/gamedata/ships/shpconho.dat
   branches/multiplayer-branch/gamedata/ships/shpdragr.dat
   branches/multiplayer-branch/gamedata/ships/shpdruma.dat
   branches/multiplayer-branch/gamedata/ships/shpearc3.dat
   branches/multiplayer-branch/gamedata/ships/shpearcr.dat
   branches/multiplayer-branch/gamedata/ships/shpforsh.dat
   branches/multiplayer-branch/gamedata/ships/shpgarty.dat
   branches/multiplayer-branch/gamedata/ships/shpilwav.dat
   branches/multiplayer-branch/gamedata/ships/shpilwsp.dat
   branches/multiplayer-branch/gamedata/ships/shpkahbo.dat
   branches/multiplayer-branch/gamedata/ships/shpkohma.dat
   branches/multiplayer-branch/gamedata/ships/shpkzedr.dat
   branches/multiplayer-branch/gamedata/ships/shpmeltr.dat
   branches/multiplayer-branch/gamedata/ships/shpmmrxf.dat
   branches/multiplayer-branch/gamedata/ships/shpmycpo.dat
   branches/multiplayer-branch/gamedata/ships/shporzne.dat
   branches/multiplayer-branch/gamedata/ships/shppkufu.dat
   branches/multiplayer-branch/gamedata/ships/shprogsq.dat
   branches/multiplayer-branch/gamedata/ships/shpshosc.dat
   branches/multiplayer-branch/gamedata/ships/shpslypr.dat
   branches/multiplayer-branch/gamedata/ships/shpspael.dat
   branches/multiplayer-branch/gamedata/ships/shpstaba.dat
   branches/multiplayer-branch/gamedata/ships/shpsupbl.dat
   branches/multiplayer-branch/gamedata/ships/shpsyrpe.dat
   branches/multiplayer-branch/gamedata/ships/shptauar.dat
   branches/multiplayer-branch/gamedata/ships/shptauda.dat
   branches/multiplayer-branch/gamedata/ships/shptausl.dat
   branches/multiplayer-branch/gamedata/ships/shptauto.dat
   branches/multiplayer-branch/gamedata/ships/shpthrto.dat
   branches/multiplayer-branch/gamedata/ships/shpumgdr.dat
   branches/multiplayer-branch/gamedata/ships/shputwju.dat
   branches/multiplayer-branch/gamedata/ships/shpvuxin.dat
   branches/multiplayer-branch/gamedata/ships/shpyehte.dat
   branches/multiplayer-branch/gamedata/ships/shpzeksh.dat
   branches/multiplayer-branch/gamedata/ships/shpzfpst.dat
   branches/multiplayer-branch/source/util/sounds.cpp
   branches/multiplayer-branch/source/util/sounds.h
   branches/multiplayer-branch/vs-files/
   branches/multiplayer-branch/vs-libs/
   branches/multiplayer-branch/web/logo.png
Modified:
   branches/multiplayer-branch/Util/deditor/book.png
   branches/multiplayer-branch/Util/deditor/dialogeditor.ncb
   branches/multiplayer-branch/Util/deditor/dialogeditor.opt
   branches/multiplayer-branch/Util/deditor/dialogeditor.suo
   branches/multiplayer-branch/Util/timewarp.nsi
   branches/multiplayer-branch/doc/Doxyfile
   branches/multiplayer-branch/gamedata/default_ini/client.ini
   branches/multiplayer-branch/gamedata/default_ini/fleets.ini
   branches/multiplayer-branch/gamedata/default_ini/scp.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpalabc.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpandgu.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shparisk.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpbahbu.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpbipka.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpchebr.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpchmav.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpchoex.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpconca.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpconho.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpdragr.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpdruma.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpearc3.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpearcr.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpforsh.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpgarty.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpilwav.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpilwsp.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpkahbo.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpkohma.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpkzedr.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpmeltr.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpmmrxf.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpmycpo.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shporzne.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shppkufu.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shprogsq.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpshosc.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpslypr.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpspael.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpstaba.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpsupbl.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpsyrpe.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shptauar.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shptauda.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shptausl.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shptauto.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpthrto.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpumgdr.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shputwju.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpvuxin.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpyehte.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpzeksh.ini
   branches/multiplayer-branch/gamedata/default_ini/ships/shpzfpst.ini
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHIP_S_000_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_A_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_B_00.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_B_01.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_B_02.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_B_03.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_B_04.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_B_05.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_B_06.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_B_07.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_B_08.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_B_09.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_C_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_D_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_D_01_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_D_02_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_D_03_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_D_04_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_D_05_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_D_06_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_D_07_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_D_08_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_D_09_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_E_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_F_00.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_F_01.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_F_02.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_F_03.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_F_04.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_F_05.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_F_06.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_F_07.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_F_08.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_F_09.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_T0_000_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_T1_000_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X2_0.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X2_1.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X2_2.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X2_3.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X3_E1.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X3_E2.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X4_E1.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X4_E2.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X5_E1.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X5_E2.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X6_E1.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X6_E2.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X7_00.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X7_01.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X7_02.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X7_03.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X7_04.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X7_05.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X7_06.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X7_07.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X7_08.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X7_09.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X7_10.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X7_11.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X8_00.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X8_01.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X8_02.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X8_03.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X8_04.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X8_05.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X8_06.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X8_07.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X8_08.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X8_09.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X8_10.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/SHOT_X8_11.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/ship_p10.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/ship_p11.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/ship_p12.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/ship_p13.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/ship_p20.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/ship_p21.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/ship_p22.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpalabc/ship_p23.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpandgu/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpandgu/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpandgu/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpandgu/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpandgu/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpandgu/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpandgu/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpandgu/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpandgu/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpandgu/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpandgu/SHOT_B02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpandgu/SHOT_B03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpandgu/SHOT_B04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpandgu/SHOT_B05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpandgu/SHOT_B06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpandgu/SHOT_C01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpandgu/SHOT_EXX_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A21_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A22_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A23_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A24_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A25_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A26_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A27_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A28_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A29_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A30_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A31_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A32_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A33_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A34_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A35_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A36_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A37_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A38_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A39_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shparisk/SHOT_A40_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbahbu/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbahbu/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbahbu/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbahbu/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbahbu/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbahbu/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbahbu/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbahbu/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbahbu/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbipka/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbipka/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbipka/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbipka/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbipka/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbipka/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbipka/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbipka/SHIP_P07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbipka/SHIP_P08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbipka/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbipka/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpbipka/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHIP_S_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_A_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_01_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_02_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_03_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_04_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_05_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_06_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_07_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_08_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_09_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_10_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_11_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_12_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_13_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_14_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_15_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_16_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_17_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_18_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_B_19_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_C_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_01_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_02_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_03_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_04_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_05_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_06_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_07_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_08_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_09_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_10_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_11_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_12_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_13_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_14_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_15_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_16_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_17_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_18_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_D_19_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchebr/SHOT_E_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A0_00_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A0_01_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A0_02_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A0_03_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A0_04_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A0_05_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A0_06_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A0_07_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A0_08_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A0_09_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A1_00_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A1_01_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A1_02_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A1_03_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A1_04_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A1_05_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A1_06_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A1_07_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A1_08_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A1_09_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A2_00_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A2_01_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A2_02_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A2_03_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A2_04_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A2_05_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A2_06_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A2_07_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A2_08_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A2_09_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A3_00_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A3_01_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A3_02_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A3_03_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A3_04_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A3_05_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A3_06_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A3_07_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A3_08_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_A3_09_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B21_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B22_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B23_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B24_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B25_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B26_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B27_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B28_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B29_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B30_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B31_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B32_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B33_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B34_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B35_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B36_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B37_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B38_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B39_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B40_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B41_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B42_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B43_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B44_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B45_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B46_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B47_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B48_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B49_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B50_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B51_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B52_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B53_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B54_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B55_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B56_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B57_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B58_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B59_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B60_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B61_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B62_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B63_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchmav/SHOT_B64_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHOT_B02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHOT_B03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHOT_B04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHOT_B05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHOT_B06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHOT_B07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHOT_B08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHOT_B09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHOT_B10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpchoex/SHOT_C01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconca/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconca/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconca/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconca/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconca/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconca/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconca/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconca/SHIP_X00_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconca/SHOT_000_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconca/SHOT_001_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconca/SHOT_002_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconca/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconca/SHOT_E00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconca/SHOT_E01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconca/SHOT_E02_PCS.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHIP_P07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHIP_P08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHIP_P09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHIP_P10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHIP_P11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHIP_P12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHIP_P13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHIP_P14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHIP_P15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHIP_P16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpconho/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdragr/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdragr/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdragr/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdragr/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdragr/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdragr/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdragr/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdragr/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdragr/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdragr/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdruma/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdruma/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdruma/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdruma/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdruma/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdruma/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdruma/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdruma/SHIP_S00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdruma/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdruma/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdruma/SHOT_B02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdruma/SHOT_B03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdruma/SHOT_B04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpdruma/SHOT_B05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHIP_S0_00_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_01_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_02_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_03_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_04_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_05_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_06_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_07_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_08_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_09_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_10_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_11_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_12_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_13_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_14_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_15_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_16_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_17_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_18_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_19_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_20_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_21_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_22_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_23_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_24_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_25_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_26_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_27_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_28_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_29_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_30_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_31_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_A0_XX_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_01_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_02_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_03_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_04_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_05_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_06_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_07_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_08_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_09_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_10_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_11_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_12_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_13_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_14_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_15_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_16_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_17_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_18_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_B0_19_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_C0_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/SHOT_D0_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/ship_p00.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/ship_p01.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/ship_p02.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/ship_p03.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/ship_p04.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/ship_p05.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearc3/ship_p06.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHOT_B01_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHOT_B02_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHOT_B03_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHOT_B04_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHOT_B05_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHOT_B06_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHOT_B07_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHOT_B08_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHOT_B09_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpearcr/SHOT_B10_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHIP_SS_000_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0001_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0002_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0003_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0004_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0005_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0006_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0007_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0008_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0009_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0010_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0011_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0012_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0013_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0014_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0015_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0016_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0017_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0018_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0019_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0020_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0021_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0022_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0023_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0024_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0025_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0026_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0027_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0028_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0029_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0030_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0031_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_AR_PRIMARY_0032_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_B02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_B03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_B04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_B05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_B06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_B07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_B08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_B09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_B10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0001_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0002_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0003_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0004_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0005_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0006_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0007_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0008_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0009_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0010_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0011_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0012_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0013_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0014_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0015_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0016_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0017_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0018_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0019_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0020_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0021_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0022_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0023_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0024_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0025_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0026_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0027_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0028_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0029_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0030_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0031_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_ER_PRIMARY0032_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0000_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0001_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0002_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0003_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0004_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0005_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0006_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0007_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0008_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0009_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0010_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0011_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0012_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0013_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0014_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0015_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0016_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0017_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0018_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0019_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0020_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0021_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0022_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0023_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0024_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0025_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0026_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0027_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0028_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0029_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0030_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpforsh/SHOT_FR_LIGHTNING0031_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHOT_A02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHOT_A03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHOT_B02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHOT_B03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHOT_B04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHOT_B05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHOT_B06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHOT_B07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHOT_C01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHOT_C02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHOT_C03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHOT_C04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHOT_C05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHOT_C06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHOT_C07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpgarty/SHOT_D01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A21_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A22_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A23_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A24_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A25_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A26_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A27_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A28_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A29_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A30_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A31_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A32_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A33_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A34_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A35_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A36_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A37_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A38_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A39_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A40_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A41_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A42_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A43_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A44_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A45_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A46_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A47_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A48_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A49_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwav/SHOT_A50_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_A02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_A03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_A04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_A05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_A06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_A07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_A08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_A09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_A10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B21_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B22_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B23_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B24_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B25_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B26_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B27_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B28_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B29_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B30_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B31_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_B32_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpilwsp/SHOT_C20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkahbo/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkahbo/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkahbo/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkahbo/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkahbo/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkahbo/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkahbo/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkahbo/SHIP_P07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkahbo/SHIP_P08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkahbo/SHIP_P09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkahbo/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkahbo/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkahbo/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkahbo/SHOT_C01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_A02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_A03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_A04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_A05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_A06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_A07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_A08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_A09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_A10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_B20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkohma/SHOT_C20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_B20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpkzedr/SHOT_C01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_A02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_A03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_A04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_A05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_A06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_A07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_A08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_A09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_A10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_B02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_B03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_B04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_B05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_B06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_B07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_B08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_B09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_B10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_C01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_C02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_C03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_C04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_C05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_C06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_C07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_C08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_C09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_C10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_D01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_D02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_D03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_D04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_D05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_D06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_D07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_D08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_D09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_D10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_E20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_F20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_G20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_H20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_I20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmeltr/SHOT_J20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmmrxf/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmmrxf/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmmrxf/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmmrxf/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmmrxf/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmmrxf/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmmrxf/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmmrxf/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmmrxf/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmmrxf/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A21_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A22_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A23_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A24_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A25_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A26_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A27_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A28_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A29_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A30_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A31_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A32_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A33_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A34_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A35_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A36_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A37_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A38_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A39_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A40_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A41_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A42_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A43_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A44_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A45_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A46_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A47_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A48_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A49_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A50_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A51_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A52_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A53_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A54_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A55_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A56_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A57_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A58_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A59_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A60_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A61_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A62_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A63_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_A64_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpmycpo/SHOT_B20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHIP_S_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_B_00_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_B_01_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_B_02_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_B_03_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_B_04_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_B_05_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_B_06_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_B_07_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_B_08_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_B_09_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_C01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_C02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_D_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_E_00_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_E_01_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_E_02_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_E_03_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_E_04_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_E_05_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_E_06_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_E_07_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_E_08_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shporzne/SHOT_E_09_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shppkufu/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shppkufu/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shppkufu/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shppkufu/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shppkufu/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shppkufu/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shppkufu/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shppkufu/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shppkufu/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shppkufu/SHOT_A02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shppkufu/SHOT_A03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shppkufu/SHOT_A04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shppkufu/SHOT_A05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shppkufu/SHOT_A06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shppkufu/SHOT_A07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shppkufu/SHOT_A08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shppkufu/SHOT_A09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shppkufu/SHOT_A10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shprogsq/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shprogsq/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shprogsq/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shprogsq/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shprogsq/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shprogsq/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shprogsq/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shprogsq/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shprogsq/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHIP_P07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B21_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B22_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B23_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B24_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B25_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B26_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B27_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B28_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B29_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpshosc/SHOT_B30_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S21_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S22_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S23_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S24_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S25_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S26_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S27_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S28_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S29_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S30_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S31_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S32_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S33_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S34_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S35_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S36_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S37_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S38_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S39_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S40_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S41_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S42_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S43_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S44_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S45_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S46_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S47_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S48_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S49_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S50_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S51_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S52_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S53_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S54_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S55_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S56_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S57_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S58_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S59_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S60_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S61_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S62_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S63_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_S64_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpslypr/SHIP_W01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpspael/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpspael/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpspael/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpspael/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpspael/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpspael/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpspael/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpspael/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpspael/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpspael/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpstaba/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpstaba/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpstaba/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpstaba/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpstaba/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpstaba/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpstaba/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpstaba/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpstaba/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHOT_B02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHOT_B03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHOT_B04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHOT_B05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHOT_B06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHOT_B07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHOT_B08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHOT_B09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsupbl/SHOT_B10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsyrpe/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsyrpe/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsyrpe/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsyrpe/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsyrpe/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsyrpe/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsyrpe/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsyrpe/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsyrpe/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpsyrpe/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHIP_S0_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_01_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_02_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_03_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_04_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_05_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_06_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_07_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_08_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_09_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_10_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_11_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_12_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_13_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_14_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_15_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_16_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_17_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_18_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A0_19_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_01_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_02_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_03_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_04_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_05_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_06_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_07_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_08_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_09_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_10_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_11_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_12_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_13_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_14_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_15_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_16_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_17_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_18_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A1_19_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_01_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_02_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_03_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_04_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_05_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_06_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_07_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_08_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_09_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_10_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_11_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_12_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_13_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_14_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_15_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_16_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_17_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_18_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A2_19_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_01_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_02_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_03_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_04_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_05_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_06_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_07_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_08_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_09_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_10_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_11_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_12_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_13_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_14_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_15_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_16_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_17_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_18_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_A3_19_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_AX_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_B_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_B_01_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_B_02_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_B_03_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_B_04_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_B_05_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_B_06_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_B_07_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_B_08_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_B_09_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_C01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_C02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_C03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_C04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_C05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_C06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_C07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_C08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_C09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_C10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_C11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_C12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_01_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_02_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_03_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_04_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_05_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_06_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_07_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_08_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_09_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_10_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_11_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_12_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_13_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_14_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_15_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_16_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_17_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_18_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_F_19_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauar/SHOT_X0_00_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHIP_S_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_B_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_C0_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_C1_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_01_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_02_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_03_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_04_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_05_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_06_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_07_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_08_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_09_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_10_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_11_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_12_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_13_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_14_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_15_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_16_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_17_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_18_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_D_19_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_E_00_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_E_01_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_E_02_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_E_03_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_E_04_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_E_05_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_E_06_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_E_07_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_E_08_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauda/SHOT_E_09_TGA.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptausl/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptausl/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptausl/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptausl/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptausl/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptausl/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptausl/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptausl/SHIP_S00_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHIP_S00_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_A00_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_A01_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_A02_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_A03_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_A04_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_A05_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_B00_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_B01_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_B02_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_B03_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_B04_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_B05_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_B06_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_B07_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_B08_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_B09_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_B10_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_B11_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_C00_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_C01_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_C02_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_C03_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_C04_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_C05_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_D00_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_D01_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_D02_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_D03_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_D04_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_D05_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_D06_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_D07_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_D08_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_D09_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_D10_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_D11_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_E0000_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_E0001_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_E0002_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_E0003_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_E0004_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_E0005_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_E0006_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_E0007_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_E0008_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_E0009_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_E0010_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_E0011_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shptauto/SHOT_F00_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B12_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B13_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B14_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B15_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B16_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B17_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B18_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B19_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B20_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B21_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B22_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B23_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B24_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B25_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B26_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B27_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B28_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B29_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B30_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B31_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B32_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B33_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B34_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B35_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B36_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B37_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B38_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B39_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpthrto/SHOT_B40_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpumgdr/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpumgdr/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpumgdr/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpumgdr/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpumgdr/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpumgdr/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpumgdr/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpumgdr/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpumgdr/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpumgdr/SHOT_A02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpumgdr/SHOT_A03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpumgdr/SHOT_A04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpumgdr/SHOT_A05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpumgdr/SHOT_A06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shputwju/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shputwju/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shputwju/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shputwju/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shputwju/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shputwju/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shputwju/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shputwju/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shputwju/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHIP_S00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHOT_000_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHOT_001_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHOT_002_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHOT_A02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHOT_A03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHOT_A04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHOT_A05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHOT_A06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHOT_A07_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHOT_A08_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHOT_A09_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHOT_A10_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHOT_A11_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHOT_E00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHOT_E01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpvuxin/SHOT_E02_PCS.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpyehte/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpyehte/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpyehte/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpyehte/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpyehte/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpyehte/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpyehte/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpyehte/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpyehte/SHOT_A00_BMP.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpyehte/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHOT_A02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHOT_A03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHOT_A04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHOT_A05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHOT_B02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHOT_B03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHOT_B04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHOT_B05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzeksh/SHOT_B06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHIP_P00_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHIP_P01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHIP_P02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHIP_P03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHIP_P04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHIP_P05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHIP_P06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHIP_S01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHOT_A01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHOT_A02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHOT_A03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHOT_A04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHOT_A05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHOT_A06_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHOT_B01_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHOT_B02_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHOT_B03_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHOT_B04_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHOT_B05_PCX.bmp
   branches/multiplayer-branch/gamedata/images/ships/shpzfpst/SHOT_B06_PCX.bmp
   branches/multiplayer-branch/gamedata/ingame.txt
   branches/multiplayer-branch/gamedata/music/ditty/aladitty.xm
   branches/multiplayer-branch/gamedata/music/ditty/andditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/ariditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/bladitty.mod
   branches/multiplayer-branch/gamedata/music/ditty/cheditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/chmditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/druditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/forditty.s3m
   branches/multiplayer-branch/gamedata/music/ditty/humditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/ilwditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/melditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/mmrditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/mycditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/orzditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/pkuditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/shoditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/slyditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/spaditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/supditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/syrditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/tauditty.xm
   branches/multiplayer-branch/gamedata/music/ditty/thrditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/umgditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/urqditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/utwditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/vuxditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/yehditty.mod
   branches/multiplayer-branch/gamedata/music/ditty/zoqditty.mod
   branches/multiplayer-branch/gamedata/readme.html
   branches/multiplayer-branch/gamedata/ships/COPYING.txt
   branches/multiplayer-branch/gamedata/ships/shpalabc.txt
   branches/multiplayer-branch/gamedata/ships/shpandgu.txt
   branches/multiplayer-branch/gamedata/ships/shparisk.txt
   branches/multiplayer-branch/gamedata/ships/shpbipka.txt
   branches/multiplayer-branch/gamedata/ships/shpchebr.txt
   branches/multiplayer-branch/gamedata/ships/shpchmav.txt
   branches/multiplayer-branch/gamedata/ships/shpchoex.txt
   branches/multiplayer-branch/gamedata/ships/shpconca.txt
   branches/multiplayer-branch/gamedata/ships/shpconho.txt
   branches/multiplayer-branch/gamedata/ships/shpdruma.txt
   branches/multiplayer-branch/gamedata/ships/shpearc3.txt
   branches/multiplayer-branch/gamedata/ships/shpearcr.txt
   branches/multiplayer-branch/gamedata/ships/shpforsh.txt
   branches/multiplayer-branch/gamedata/ships/shpgarty.txt
   branches/multiplayer-branch/gamedata/ships/shpilwav.txt
   branches/multiplayer-branch/gamedata/ships/shpilwsp.txt
   branches/multiplayer-branch/gamedata/ships/shpkahbo.txt
   branches/multiplayer-branch/gamedata/ships/shpkohma.txt
   branches/multiplayer-branch/gamedata/ships/shpkzedr.txt
   branches/multiplayer-branch/gamedata/ships/shpmeltr.txt
   branches/multiplayer-branch/gamedata/ships/shpmycpo.txt
   branches/multiplayer-branch/gamedata/ships/shporzne.txt
   branches/multiplayer-branch/gamedata/ships/shprogsq.txt
   branches/multiplayer-branch/gamedata/ships/shpspael.txt
   branches/multiplayer-branch/gamedata/ships/shpsupbl.txt
   branches/multiplayer-branch/gamedata/ships/shpyehte.txt
   branches/multiplayer-branch/gamedata/ships/shpzfpst.txt
   branches/multiplayer-branch/gamedata/sound/ships/shpalabc/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpalabc/WAVE_A02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpalabc/WAVE_A03_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpalabc/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpalabc/WAVE_B02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpalabc/WAVE_C01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpalabc/WAVE_C02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpandgu/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpandgu/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shparisk/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shparisk/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpbahbu/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpbahbu/WAVE_A02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpbahbu/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpbipka/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpbipka/WAVE_A02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpbipka/WAVE_A03_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpbipka/WAVE_A04_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpbipka/WAVE_A05_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpbipka/WAVE_A06_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpbipka/WAVE_A07_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpbipka/WAVE_A08_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpbipka/WAVE_A09_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpbipka/WAVE_A10_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpbipka/WAVE_A11_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpbipka/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpchebr/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpchebr/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpchebr/WAVE_C01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpchebr/WAVE_C02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpchebr/WAVE_C03_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpchmav/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpchmav/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpchmav/WAVE_C01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpchoex/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpchoex/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpchoex/WAVE_C01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpchoex/WAVE_C02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpconca/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpconca/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpconca/WAVE_B02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpconho/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpconho/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpdragr/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpdragr/WAVE_A02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpdragr/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpdruma/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpdruma/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpearc3/WAVE_A00_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpearc3/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpearc3/WAVE_B00_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpearc3/WAVE_C00_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpearcr/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpearcr/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpforsh/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpforsh/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpforsh/WAVE_B02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpforsh/WAVE_B03_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpgarty/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpgarty/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpgarty/WAVE_C01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpgarty/WAVE_C02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpgarty/WAVE_C03_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpilwav/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpilwav/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpilwav/WAVE_B02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpilwsp/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpilwsp/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpilwsp/WAVE_C01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpkahbo/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpkahbo/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpkohma/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpkohma/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpkzedr/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpkzedr/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpkzedr/WAVE_C01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpkzedr/WAVE_C02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpmeltr/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpmeltr/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpmmrxf/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpmmrxf/WAVE_A02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpmmrxf/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpmycpo/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpmycpo/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shporzne/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shporzne/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shporzne/WAVE_C01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shporzne/WAVE_C02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shporzne/WAVE_C03_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shppkufu/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shppkufu/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shppkufu/WAVE_B02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shppkufu/WAVE_B03_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shppkufu/WAVE_B04_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shppkufu/WAVE_B05_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shppkufu/WAVE_B06_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shppkufu/WAVE_B07_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shppkufu/WAVE_B08_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shppkufu/WAVE_B09_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shppkufu/WAVE_B10_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shppkufu/WAVE_B11_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shppkufu/WAVE_B12_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shppkufu/WAVE_B13_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shppkufu/WAVE_B14_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shppkufu/WAVE_C01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shprogsq/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shprogsq/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpshosc/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpshosc/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpslypr/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpslypr/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpspael/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpspael/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpstaba/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpstaba/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpsupbl/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpsyrpe/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpsyrpe/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpsyrpe/WAVE_C01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptauar/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptauar/WAVE_A02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptauar/WAVE_A03_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptauar/WAVE_A04_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptauar/WAVE_A05_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptauar/WAVE_A06_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptauar/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptauar/WAVE_C01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptauar/WAVE_C02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptauar/WAVE_C03_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptauar/WAVE_C04_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptauda/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptauda/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptauda/WAVE_B02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptausl/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptausl/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptausl/WAVE_B02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptausl/WAVE_B03_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptauto/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptauto/WAVE_A02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptauto/WAVE_C01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shptauto/WAVE_C02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpthrto/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpthrto/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpumgdr/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpumgdr/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shputwju/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shputwju/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpvuxin/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpvuxin/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpvuxin/WAVE_B02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpyehte/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpyehte/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpzeksh/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpzeksh/WAVE_B01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpzeksh/WAVE_B02_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpzeksh/WAVE_B03_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpzfpst/WAVE_A01_WAV.wav
   branches/multiplayer-branch/gamedata/sound/ships/shpzfpst/WAVE_B01_WAV.wav
   branches/multiplayer-branch/makefile
   branches/multiplayer-branch/rawgraphic/PkunkQueen.jpg
   branches/multiplayer-branch/rawgraphic/SpathiMain.jpg
   branches/multiplayer-branch/source/ais/c_input.cpp
   branches/multiplayer-branch/source/ais/c_other.cpp
   branches/multiplayer-branch/source/ais/c_wussie.cpp
   branches/multiplayer-branch/source/doxygen.cpp
   branches/multiplayer-branch/source/frame.cpp
   branches/multiplayer-branch/source/games/gflmelee.cpp
   branches/multiplayer-branch/source/gui.cpp
   branches/multiplayer-branch/source/input.cpp
   branches/multiplayer-branch/source/melee.h
   branches/multiplayer-branch/source/melee/manim.cpp
   branches/multiplayer-branch/source/melee/mcbodies.cpp
   branches/multiplayer-branch/source/melee/mcontrol.cpp
   branches/multiplayer-branch/source/melee/mfleet.cpp
   branches/multiplayer-branch/source/melee/mframe.cpp
   branches/multiplayer-branch/source/melee/mframe.h
   branches/multiplayer-branch/source/melee/mgame.cpp
   branches/multiplayer-branch/source/melee/mgame.h
   branches/multiplayer-branch/source/melee/mhelpers.cpp
   branches/multiplayer-branch/source/melee/mitems.cpp
   branches/multiplayer-branch/source/melee/mlog.cpp
   branches/multiplayer-branch/source/melee/mmain.cpp
   branches/multiplayer-branch/source/melee/mmath.cpp
   branches/multiplayer-branch/source/melee/mnet1.cpp
   branches/multiplayer-branch/source/melee/moptions.cpp
   branches/multiplayer-branch/source/melee/mship.cpp
   branches/multiplayer-branch/source/melee/mship.h
   branches/multiplayer-branch/source/melee/mshot.cpp
   branches/multiplayer-branch/source/melee/mshot.h
   branches/multiplayer-branch/source/melee/mshpdata.cpp
   branches/multiplayer-branch/source/melee/mshppan.cpp
   branches/multiplayer-branch/source/melee/msprite.cpp
   branches/multiplayer-branch/source/melee/mtarget.cpp
   branches/multiplayer-branch/source/melee/mview.cpp
   branches/multiplayer-branch/source/other/dialogs.cpp
   branches/multiplayer-branch/source/other/dialogs.h
   branches/multiplayer-branch/source/other/nullphas.cpp
   branches/multiplayer-branch/source/other/objanim.cpp
   branches/multiplayer-branch/source/other/orbit.cpp
   branches/multiplayer-branch/source/other/planet3d.cpp
   branches/multiplayer-branch/source/other/radar.cpp
   branches/multiplayer-branch/source/other/shippart.cpp
   branches/multiplayer-branch/source/other/twconfig.cpp
   branches/multiplayer-branch/source/other/twconfig.h
   branches/multiplayer-branch/source/other/vbodies.cpp
   branches/multiplayer-branch/source/other/vtarget.cpp
   branches/multiplayer-branch/source/sc1ships/shpandgu.cpp
   branches/multiplayer-branch/source/sc1ships/shparisk.cpp
   branches/multiplayer-branch/source/sc1ships/shpchebr.cpp
   branches/multiplayer-branch/source/sc1ships/shpearcr.cpp
   branches/multiplayer-branch/source/sc1ships/shpilwav.cpp
   branches/multiplayer-branch/source/sc1ships/shpkzedr.cpp
   branches/multiplayer-branch/source/sc1ships/shpmmrxf.cpp
   branches/multiplayer-branch/source/sc1ships/shpmycpo.cpp
   branches/multiplayer-branch/source/sc1ships/shpshosc.cpp
   branches/multiplayer-branch/source/sc1ships/shpspael.cpp
   branches/multiplayer-branch/source/sc1ships/shpsyrpe.cpp
   branches/multiplayer-branch/source/sc1ships/shpumgdr.cpp
   branches/multiplayer-branch/source/sc1ships/shpvuxin.cpp
   branches/multiplayer-branch/source/sc1ships/shpyehte.cpp
   branches/multiplayer-branch/source/sc2ships/shpchmav.cpp
   branches/multiplayer-branch/source/sc2ships/shpdruma.cpp
   branches/multiplayer-branch/source/sc2ships/shpkohma.cpp
   branches/multiplayer-branch/source/sc2ships/shpmeltr.cpp
   branches/multiplayer-branch/source/sc2ships/shporzne.cpp
   branches/multiplayer-branch/source/sc2ships/shppkufu.cpp
   branches/multiplayer-branch/source/sc2ships/shpslypr.cpp
   branches/multiplayer-branch/source/sc2ships/shpsupbl.cpp
   branches/multiplayer-branch/source/sc2ships/shpthrto.cpp
   branches/multiplayer-branch/source/sc2ships/shputwju.cpp
   branches/multiplayer-branch/source/sc2ships/shpzfpst.cpp
   branches/multiplayer-branch/source/scp.cpp
   branches/multiplayer-branch/source/scp.h
   branches/multiplayer-branch/source/ship.h
   branches/multiplayer-branch/source/ships/shpaktgu.cpp
   branches/multiplayer-branch/source/ships/shpalabc.cpp
   branches/multiplayer-branch/source/ships/shpbahbu.cpp
   branches/multiplayer-branch/source/ships/shpbipka.cpp
   branches/multiplayer-branch/source/ships/shpbogce.cpp
   branches/multiplayer-branch/source/ships/shpchoex.cpp
   branches/multiplayer-branch/source/ships/shpconca.cpp
   branches/multiplayer-branch/source/ships/shpconho.cpp
   branches/multiplayer-branch/source/ships/shpdragr.cpp
   branches/multiplayer-branch/source/ships/shpearc3.cpp
   branches/multiplayer-branch/source/ships/shpforsh.cpp
   branches/multiplayer-branch/source/ships/shpgarty.cpp
   branches/multiplayer-branch/source/ships/shpilwsp.cpp
   branches/multiplayer-branch/source/ships/shpkahbo.cpp
   branches/multiplayer-branch/source/ships/shprogsq.cpp
   branches/multiplayer-branch/source/ships/shpstaba.cpp
   branches/multiplayer-branch/source/ships/shptauar.cpp
   branches/multiplayer-branch/source/ships/shptauda.cpp
   branches/multiplayer-branch/source/ships/shptaume.cpp
   branches/multiplayer-branch/source/ships/shptausl.cpp
   branches/multiplayer-branch/source/ships/shptaust.cpp
   branches/multiplayer-branch/source/ships/shptauto.cpp
   branches/multiplayer-branch/source/ships/shpwolmi.cpp
   branches/multiplayer-branch/source/ships/shpyusra.cpp
   branches/multiplayer-branch/source/ships/shpzeksh.cpp
   branches/multiplayer-branch/source/twgui/twbutton.cpp
   branches/multiplayer-branch/source/twgui/twbuttontypes.cpp
   branches/multiplayer-branch/source/twgui/twgui.cpp
   branches/multiplayer-branch/source/twgui/twhelpers.cpp
   branches/multiplayer-branch/source/twgui/twmenuexamples.cpp
   branches/multiplayer-branch/source/twgui/twpopup.cpp
   branches/multiplayer-branch/source/twgui/twwindow.cpp
   branches/multiplayer-branch/source/twgui/utils.cpp
   branches/multiplayer-branch/source/util/aastr.c
   branches/multiplayer-branch/source/util/base.cpp
   branches/multiplayer-branch/source/util/errors.cpp
   branches/multiplayer-branch/source/util/errors.h
   branches/multiplayer-branch/source/util/history.cpp
   branches/multiplayer-branch/source/util/random.cpp
   branches/multiplayer-branch/source/util/sound.cpp
   branches/multiplayer-branch/source/util/sound.h
   branches/multiplayer-branch/source/util/vector2.cpp
   branches/multiplayer-branch/sources.lst
   branches/multiplayer-branch/web/index.html
   branches/multiplayer-branch/web/style.css
   branches/multiplayer-branch/web/update.sh
Log:
(multiplayer-branch) re-synching with latest release, 

Copied: branches/multiplayer-branch/Util/addStackTrace.pl (from rev 69, trunk/Util/addStackTrace.pl)


Property changes on: branches/multiplayer-branch/Util/addStackTrace.pl
___________________________________________________________________
Name: svn:executable
   + *

Copied: branches/multiplayer-branch/Util/deditor (from rev 69, trunk/Util/deditor)

Modified: branches/multiplayer-branch/Util/timewarp.nsi
===================================================================
--- branches/multiplayer-branch/Util/timewarp.nsi	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/Util/timewarp.nsi	2004-09-28 19:53:03 UTC (rev 71)
@@ -124,24 +124,6 @@
 
 SectionEnd
 
-Section "Source"
-  SetOutPath $INSTDIR
-  File "..\makefile"
-  File "..\tw-light.rc"
-  File "..\tw-light.ico"
-  File "..\sources.lst"
-  File "..\install-sh"
-
-  SetOutPath $INSTDIR\source
-  File /r "..\source\*.*"
-
-;  SetOutPath $INSTDIR\tests
-;  File /r "..\tests\*.*"
-  
-  SetOutPath $INSTDIR\mingw-libs
-  File /r "..\mingw-libs\*.*"
-
-SectionEnd
 ;--------------------------------
 
 ; Uninstaller

Modified: branches/multiplayer-branch/doc/Doxyfile
===================================================================
--- branches/multiplayer-branch/doc/Doxyfile	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/doc/Doxyfile	2004-09-28 19:53:03 UTC (rev 71)
@@ -4,7 +4,7 @@
 # General configuration options
 #---------------------------------------------------------------------------
 PROJECT_NAME           = TW-Light
-PROJECT_NUMBER         = 0.1b2
+PROJECT_NUMBER         = 0.3b69
 OUTPUT_DIRECTORY       = ./
 OUTPUT_LANGUAGE        = English
 USE_WINDOWS_ENCODING   = YES

Modified: branches/multiplayer-branch/gamedata/default_ini/client.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/client.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/client.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,69 +1,67 @@
-[System]
-AutoUnload = 0
-
-[Video]
-ScreenWidth = 800
-ScreenHeight = 600
-
-BitsPerPixel = 32
-;valid = values are 8 (ugly), 15, 16, 24 (slow), and 32
-
-FullScreen = 1
-; = 0 = windowed, 1 = fullscreen
-
-;This = will select the theme by its string name. The names for the non-bitmap
-;themes = are: "GTK", "Win95", "Photon", "BeOS", "NeXTStep", "ASE", "Allegro".
-GuiTheme = Photon
-
-Gamma = 45
-;gamma = gamma correction, should be between 0 and 255
-
-
-
-[Sound]
-SoundOn = 2
-MusicOn = 2
-SoundVolume = 140
-MusicVolume = 115
-
-
-[Planet]
-PlanetDimension = 3
-PlanetUsespec = 1
-
-[View]
-View = Enemy
-;determines = where the camera goes
-InterpolateFrames = 1
-;0 = low quality, 1 = high quality
-Mip_min = 0
-;from = 0 to 3?  0 = normal, 1 = low quality, 2 = very low quality, ...
-Mip_max = 10
-;from = 0 to 3?  0 = high quality, 99 = normal
-Mip_bias = 0
-;from = -3? to 3?  0 = normal, -1 = high quality, 1 = low quality, 2 = very low quality
-;(Hero, = Enemy, Enemy_Discrete, Split, Everything)
-MinimumFrameRate = 15.0
-; = determines the worst-case frameskipping (between 5 and 15 recommended)
-FPS_Time = 250
-; = milliseconds per time the FPS is updated.
-
-Key_zoomin = EQUALS
-Key_zoomout = MINUS
-Key_alter1 = 0
-Key_alter2 = 9
-
-
-[Rendering]
-AA_Mode = 35
-
-
-[Stars]
-quality = 5
-;recomended = quality settings are 1, 2, and 5
-
-
-[Menu]
-SelectGame = 0
-
-
+[System]
+AutoUnload = 0
+
+[Video]
+ScreenWidth = 800
+ScreenHeight = 600
+
+BitsPerPixel = 32
+;valid = values are 8 (ugly), 15, 16, 24 (slow), and 32
+
+FullScreen = 1
+; = 0 = windowed, 1 = fullscreen
+
+;This will select the theme by its string name. The names for the non-bitmap
+;themes are: "GTK", "Win95", "Photon", "BeOS", "NeXTStep", "ASE", "Allegro".
+GuiTheme = Photon
+
+Gamma = 45
+;gamma = gamma correction, should be between 0 and 255
+
+
+
+[Sound]
+SoundVolume = 0.5
+MusicVolume = 0.5
+
+
+[Planet]
+PlanetDimension = 3
+PlanetUsespec = 1
+
+[View]
+View = Enemy
+;determines = where the camera goes
+InterpolateFrames = 1
+;0 = low quality, 1 = high quality
+Mip_min = 0
+;from = 0 to 3?  0 = normal, 1 = low quality, 2 = very low quality, ...
+Mip_max = 10
+;from = 0 to 3?  0 = high quality, 99 = normal
+Mip_bias = 0
+;from = -3? to 3?  0 = normal, -1 = high quality, 1 = low quality, 2 = very low quality
+;(Hero, = Enemy, Enemy_Discrete, Split, Everything)
+MinimumFrameRate = 15.0
+; = determines the worst-case frameskipping (between 5 and 15 recommended)
+FPS_Time = 250
+; = milliseconds per time the FPS is updated.
+
+Key_zoomin = EQUALS
+Key_zoomout = MINUS
+Key_alter1 = 0
+Key_alter2 = 9
+
+
+[Rendering]
+AA_Mode = 35
+
+
+[Stars]
+quality = 5
+;recomended = quality settings are 1, 2, and 5
+
+
+[Menu]
+SelectGame = 0
+
+

Modified: branches/multiplayer-branch/gamedata/default_ini/fleets.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/fleets.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/fleets.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,124 +1,75 @@
-[Player1]
-Slot0 = shosc
-Slot1 = andgu
-Slot2 = arisk
-Slot3 = bahbu
-Slot4 = bipka
-Slot5 = chebr
-Slot6 = chmav
-Slot7 = choex
-Slot8 = conca
-Slot9 = conho
-Slot10 = djila
-Slot11 = dragr
-Slot12 = druma
-Slot13 = earc2
-Slot14 = earc3
-Slot15 = earcr
-Slot16 = forsh
-Slot17 = garty
-Slot18 = hydcr
-Slot19 = ilwav
-Slot20 = ilwsp
-Slot21 = kahbo
-Slot22 = kohma
-Slot23 = kzedr
-Slot24 = meltr
-Size = 1
-MaxFleetCost = 500
-Name = Player1
-Type = Keyboard/Joystick
-Team = 1
-Channel = 12
-StartingFleetCost = 633
-StartingFleetSize = 24
-Slot25 = mmrxf
-Slot26 = mycpo
-Slot27 = orzne
-Slot28 = pkufu
-Slot29 = rekas
-Slot30 = shosc
-Slot31 = slypr
-Slot32 = spael
-Slot33 = staba
-Slot34 = supbl
-Slot35 = syrpe
-Slot36 = tauar
-Slot37 = tauda
-Slot38 = tausl
-Slot39 = tauto
-Slot40 = thrto
-Slot41 = umgdr
-Slot42 = utwju
-Slot43 = vuxin
-Slot44 = yehte
-Slot45 = zeksh
-Slot46 = zfpst
-
-[Player2]
-Slot0 = shosc
-Slot1 = andgu
-Slot2 = arisk
-Slot3 = bahbu
-Slot4 = bipka
-Slot5 = chebr
-Slot6 = chmav
-Slot7 = choex
-Slot8 = conca
-Slot9 = conho
-Slot10 = djila
-Slot11 = dragr
-Slot12 = druma
-Slot13 = earc2
-Slot14 = earc3
-Slot15 = earcr
-Slot16 = forsh
-Slot17 = garty
-Slot18 = hydcr
-Slot19 = ilwav
-Size = 1
-MaxFleetCost = 500
-Name = Player2
-Type = WussieBot
-Team = 2
-Channel = 12
-StartingFleetCost = 513
-StartingFleetSize = 22
-Slot20 = ilwsp
-Slot21 = kahbo
-Slot22 = kohma
-Slot23 = kzedr
-Slot24 = meltr
-Slot25 = mmrxf
-Slot26 = mycpo
-Slot27 = orzne
-Slot28 = pkufu
-Slot29 = rekas
-Slot30 = shosc
-Slot31 = slypr
-Slot32 = spael
-Slot33 = staba
-Slot34 = supbl
-Slot35 = syrpe
-Slot36 = tauar
-Slot37 = tauda
-Slot38 = tausl
-Slot39 = tauto
-Slot40 = thrto
-Slot41 = umgdr
-Slot42 = utwju
-Slot43 = vuxin
-Slot44 = yehte
-Slot45 = zeksh
-Slot46 = zfpst
-
-[Player3]
-Slot0 = alabc
-Slot1 = staba
-Size = 2
-MaxFleetCost = 500
-Type = WussieBot
-Team = 2
-Channel = 12
-StartingFleetCost = 513
-StartingFleetSize = 22
+[Player1]
+Slot0 = earcr
+Slot1 = thrto
+Slot2 = chebr
+Slot3 = orzne
+Slot4 = druma
+Slot5 = meltr
+Slot6 = chmav
+Slot7 = kohma
+Slot8 = utwju
+Slot9 = andgu
+Slot10 = ilwav
+Slot11 = kzedr
+Slot12 = yehte
+Slot13 = syrpe
+Slot14 = spael
+Slot15 = vuxin
+Slot16 = umgdr
+Slot17 = supbl
+Slot18 = pkufu
+Slot19 = slypr
+Slot20 = arisk
+Slot21 = zfpst
+Slot22 = mycpo
+Slot23 = mmrxf
+Slot24 = shosc
+Size = 25
+MaxFleetCost = 500
+Name = Player1
+Type = Keyboard/Joystick
+Team = 1
+Channel = 12
+StartingFleetCost = 633
+StartingFleetSize = 24
+
+[Player2]
+Slot0 = tauar
+Slot1 = tauda
+Slot2 = hydcr
+Slot3 = forsh
+Slot4 = dragr
+Slot5 = tausl
+Slot6 = tauto
+Slot7 = garty
+Slot8 = djila
+Slot9 = zeksh
+Slot10 = conca
+Slot11 = choex
+Slot12 = conho
+Slot13 = ilwsp
+Slot14 = rekas
+Slot15 = bahbu
+Slot16 = bipka
+Slot17 = earc2
+Slot18 = earc3
+Slot19 = kahbo
+Size = 20
+MaxFleetCost = 500
+Name = Player2
+Type = WussieBot
+Team = 2
+Channel = 12
+StartingFleetCost = 513
+StartingFleetSize = 22
+
+[Player3]
+Slot0 = alabc
+Slot1 = staba
+Size = 2
+MaxFleetCost = 500
+Type = WussieBot
+Team = 2
+Channel = 12
+StartingFleetCost = 513
+StartingFleetSize = 22

Modified: branches/multiplayer-branch/gamedata/default_ini/scp.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/scp.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/scp.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,188 +1,188 @@
-[Limits]
-MaxPlayers = 20
-MaxConfigurations = 4
-MaxTeams = 20
-
-
-[Config0]
-Thrust = 84
-Left = 82
-Right = 83
-Fire = 67
-AltFire = 63
-Special = 108
-Next_Target = 65
-Prev_Target = 66
-Closest_Target = 16
-Backwards = 85
-Extra1 = 0
-Extra2 = 0
-Extra3 = 0
-Extra4 = 0
-Extra5 = 0
-Extra6 = 28
-
-[Config1]
-Backwards = 19
-Thrust = 23
-Left = 1
-Right = 4
-Fire = 10
-AltFire = 14
-Special = 11
-Next_Target = 6
-Prev_Target = 7
-Closest_Target = 7
-Extra1 = 0
-Extra2 = 0
-Extra3 = 0
-Extra4 = 0
-Extra5 = 0
-Extra6 = 29
-
-
-[Config2]
-Thrust = 0
-Left = 0
-Right = 0
-Fire = 0
-AltFire = 0
-Special = 0
-Next_Target = 0
-Prev_Target = 0
-Closest_Target = 0
-
-
-[Config3]
-Thrust = 0
-Left = 0
-Right = 0
-Fire = 0
-AltFire = 0
-Special = 0
-Next_Target = 0
-Prev_Target = 0
-Closest_Target = 0
-
-
-[Player1]
-Type = Human
-Config = 0
-Team = 1
-
-
-[Player2]
-Type = Human
-Config = 1
-Team = 2
-
-
-[Player3]
-Type = none
-Config = 2
-Team = 2
-
-
-[Player4]
-Type = none
-Config = 3
-Team = 2
-
-
-[Player5]
-Type = none
-Config = 0
-Team = 2
-
-
-[Player6]
-Type = none
-Config = 1
-Team = 2
-
-
-[Player7]
-Type = none
-Config = 2
-Team = 1
-
-
-[Player8]
-Type = none
-Config = 3
-Team = 1
-
-
-[Player9]
-Type = none
-Config = 0
-Team = 0
-
-
-[Player10]
-Type = none
-Config = 0
-Team = 0
-
-
-[Player11]
-Type = none
-Config = 0
-Team = 0
-
-
-[Player12]
-Type = none
-Config = 0
-Team = 0
-
-
-[Player13]
-Type = none
-Config = 0
-Team = 0
-
-
-[Player14]
-Type = none
-Config = 1
-Team = 0
-
-
-[Player15]
-Type = none
-Config = 2
-Team = 0
-
-
-[Player16]
-Type = none
-Config = 3
-Team = 0
-
-
-[Player17]
-Type = none
-Config = 0
-Team = 0
-
-
-[Player18]
-Type = none
-Config = 1
-Team = 0
-
-
-[Player19]
-Type = none
-Config = 2
-Team = 0
-
-
-[Player20]
-Type = none
-Config = 3
-Team = 0
-
-
-
+[Limits]
+MaxPlayers = 20
+MaxConfigurations = 4
+MaxTeams = 6
+
+
+[Config0]
+Thrust = 84
+Left = 82
+Right = 83
+Fire = 67
+AltFire = 63
+Special = 106
+Next_Target = 65
+Prev_Target = 66
+Closest_Target = 16
+Backwards = 85
+Extra1 = 0
+Extra2 = 0
+Extra3 = 0
+Extra4 = 0
+Extra5 = 0
+Extra6 = 0
+
+[Config1]
+Backwards = 19
+Thrust = 23
+Left = 1
+Right = 4
+Fire = 10
+AltFire = 14
+Special = 11
+Next_Target = 6
+Prev_Target = 7
+Closest_Target = 7
+Extra1 = 0
+Extra2 = 0
+Extra3 = 0
+Extra4 = 0
+Extra5 = 0
+Extra6 = 0
+
+
+[Config2]
+Thrust = 0
+Left = 0
+Right = 0
+Fire = 0
+AltFire = 0
+Special = 0
+Next_Target = 0
+Prev_Target = 0
+Closest_Target = 0
+
+
+[Config3]
+Thrust = 0
+Left = 0
+Right = 0
+Fire = 0
+AltFire = 0
+Special = 0
+Next_Target = 0
+Prev_Target = 0
+Closest_Target = 0
+
+
+[Player1]
+Type = Human
+Config = 0
+Team = 1
+
+
+[Player2]
+Type = WussieBot
+Config = 1
+Team = 2
+
+
+[Player3]
+Type = WussieBot
+Config = 2
+Team = 2
+
+
+[Player4]
+Type = none
+Config = 3
+Team = 2
+
+
+[Player5]
+Type = none
+Config = 0
+Team = 2
+
+
+[Player6]
+Type = none
+Config = 1
+Team = 2
+
+
+[Player7]
+Type = none
+Config = 2
+Team = 1
+
+
+[Player8]
+Type = none
+Config = 3
+Team = 1
+
+
+[Player9]
+Type = none
+Config = 0
+Team = 0
+
+
+[Player10]
+Type = none
+Config = 0
+Team = 0
+
+
+[Player11]
+Type = none
+Config = 0
+Team = 0
+
+
+[Player12]
+Type = none
+Config = 0
+Team = 0
+
+
+[Player13]
+Type = none
+Config = 0
+Team = 0
+
+
+[Player14]
+Type = none
+Config = 1
+Team = 0
+
+
+[Player15]
+Type = none
+Config = 2
+Team = 0
+
+
+[Player16]
+Type = none
+Config = 3
+Team = 0
+
+
+[Player17]
+Type = none
+Config = 0
+Team = 0
+
+
+[Player18]
+Type = none
+Config = 1
+Team = 0
+
+
+[Player19]
+Type = none
+Config = 2
+Team = 0
+
+
+[Player20]
+Type = none
+Config = 3
+Team = 0
+
+
+

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpalabc.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpalabc.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpalabc.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,27 +1,28 @@
 [Info]
-TWCost  = 90
+TWCost = 90
 Name1 = Alary
 Name2 = BattleCruiser
 Origin = TWs
 Coders = Tau
 code = AlaryBC
+Version = 65M
 
 [Ship]
-Crew           = 42
-CrewMax        = 42
-Batt           = 42
-BattMax        = 42
-SpeedMax       = 20
-AccelRate      = 4
-TurnRate       = 8
+Crew = 42
+CrewMax = 42
+Batt = 42
+BattMax = 42
+SpeedMax = 20
+AccelRate = 4
+TurnRate = 8
 RechargeAmount = 1
-RechargeRate   = 2
-WeaponDrain    = 24
-WeaponRate     = 18
-SpecialDrain   = 2
-SpecialRate    = 6
-HotspotRate    = 5
-Mass           = 75
+RechargeRate = 2
+WeaponDrain = 24
+WeaponRate = 18
+SpecialDrain = 2
+SpecialRate = 6
+HotspotRate = 5
+Mass = 75
 EnginesArmour = 12
 
 [Weapon]
@@ -29,7 +30,7 @@
 Accel = 8
 TurnRate = 17
 Lifetime = 5200
-Armour   = 3
+Armour = 3
 Proximity = 15
 WarheadRange = 39.5
 WarheadVelocity = 62
@@ -87,3 +88,149 @@
 CaptName3 = Khryslth
 CaptName4 = J'kyyrf
 CaptName5 = Vyxyrm
+
+[Music]
+Victory = music/ditty/aladitty.xm
+
+[Sound]
+WeaponSample0 = sound/ships/shpalabc/WAVE_A01_WAV.wav
+WeaponSample1 = sound/ships/shpalabc/WAVE_A02_WAV.wav
+WeaponSample2 = sound/ships/shpalabc/WAVE_A03_WAV.wav
+
+SpecialSample0 = sound/ships/shpalabc/WAVE_B01_WAV.wav
+SpecialSample1 = sound/ships/shpalabc/WAVE_B02_WAV.wav
+
+ExtraSample0 = sound/ships/shpalabc/WAVE_C01_WAV.wav
+ExtraSample1 = sound/ships/shpalabc/WAVE_C02_WAV.wav
+
+
+[Objects]
+ShipSprites = 1r128
+WeaponSprites = 1r +alpha
+WeaponSamples = 3
+WeaponExplosion = 10 +alpha
+SpecialSprites = 1r +alpha
+SpecialSamples = 2
+SpecialExplosion = 10 +alpha
+ExtraSprites = 1r +alpha
+ExtraSamples = 2
+ExtraExplosion = 10 +alpha
+ExtraExtraSprites0_ = 1r128 +alpha
+ExtraExtraSprites1_ = 1r128 +alpha
+ExtraExtraSprites2_ = 4 +alpha
+ExtraExtraSprites3_ = 2 +alpha
+ExtraExtraSprites4_ = 2 +alpha
+ExtraExtraSprites5_ = 2 +alpha
+ExtraExtraSprites6_ = 2 +alpha
+ExtraExtraSprites7_ = 12 +alpha
+ExtraExtraSprites8_ = 12 +alpha
+PanelBitmaps = 15
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpalabc/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpalabc/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpalabc/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpalabc/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpalabc/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpalabc/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpalabc/SHIP_P06_PCX.bmp
+PanelBitmaps7 = images/ships/shpalabc/ship_p10.bmp
+PanelBitmaps8 = images/ships/shpalabc/ship_p11.bmp
+PanelBitmaps9 = images/ships/shpalabc/ship_p12.bmp
+PanelBitmaps10 = images/ships/shpalabc/ship_p13.bmp
+PanelBitmaps11 = images/ships/shpalabc/ship_p20.bmp
+PanelBitmaps12 = images/ships/shpalabc/ship_p21.bmp
+PanelBitmaps13 = images/ships/shpalabc/ship_p22.bmp
+PanelBitmaps14 = images/ships/shpalabc/ship_p23.bmp
+
+
+ShipSprites0 = images/ships/shpalabc/SHIP_S_000_TGA.bmp
+
+WeaponSprites0 = images/ships/shpalabc/SHOT_A_00_TGA.bmp
+
+WeaponExplosion0 = images/ships/shpalabc/SHOT_B_00.bmp
+WeaponExplosion1 = images/ships/shpalabc/SHOT_B_01.bmp
+WeaponExplosion2 = images/ships/shpalabc/SHOT_B_02.bmp
+WeaponExplosion3 = images/ships/shpalabc/SHOT_B_03.bmp
+WeaponExplosion4 = images/ships/shpalabc/SHOT_B_04.bmp
+WeaponExplosion5 = images/ships/shpalabc/SHOT_B_05.bmp
+WeaponExplosion6 = images/ships/shpalabc/SHOT_B_06.bmp
+WeaponExplosion7 = images/ships/shpalabc/SHOT_B_07.bmp
+WeaponExplosion8 = images/ships/shpalabc/SHOT_B_08.bmp
+WeaponExplosion9 = images/ships/shpalabc/SHOT_B_09.bmp
+
+
+SpecialSprites0 = images/ships/shpalabc/SHOT_C_00_TGA.bmp
+
+SpecialExplosion0 = images/ships/shpalabc/SHOT_D_00_TGA.bmp
+SpecialExplosion1 = images/ships/shpalabc/SHOT_D_01_TGA.bmp
+SpecialExplosion2 = images/ships/shpalabc/SHOT_D_02_TGA.bmp
+SpecialExplosion3 = images/ships/shpalabc/SHOT_D_03_TGA.bmp
+SpecialExplosion4 = images/ships/shpalabc/SHOT_D_04_TGA.bmp
+SpecialExplosion5 = images/ships/shpalabc/SHOT_D_05_TGA.bmp
+SpecialExplosion6 = images/ships/shpalabc/SHOT_D_06_TGA.bmp
+SpecialExplosion7 = images/ships/shpalabc/SHOT_D_07_TGA.bmp
+SpecialExplosion8 = images/ships/shpalabc/SHOT_D_08_TGA.bmp
+SpecialExplosion9 = images/ships/shpalabc/SHOT_D_09_TGA.bmp
+
+ExtraSprites0 = images/ships/shpalabc/SHOT_E_00_TGA.bmp
+
+ExtraExplosion0 = images/ships/shpalabc/SHOT_F_00.bmp
+ExtraExplosion1 = images/ships/shpalabc/SHOT_F_01.bmp
+ExtraExplosion2 = images/ships/shpalabc/SHOT_F_02.bmp
+ExtraExplosion3 = images/ships/shpalabc/SHOT_F_03.bmp
+ExtraExplosion4 = images/ships/shpalabc/SHOT_F_04.bmp
+ExtraExplosion5 = images/ships/shpalabc/SHOT_F_05.bmp
+ExtraExplosion6 = images/ships/shpalabc/SHOT_F_06.bmp
+ExtraExplosion7 = images/ships/shpalabc/SHOT_F_07.bmp
+ExtraExplosion8 = images/ships/shpalabc/SHOT_F_08.bmp
+ExtraExplosion9 = images/ships/shpalabc/SHOT_F_09.bmp
+
+
+ExtraExtraSprites0_0 = images/ships/shpalabc/SHOT_T0_000_TGA.bmp
+
+ExtraExtraSprites1_0 = images/ships/shpalabc/SHOT_T1_000_TGA.bmp
+
+ExtraExtraSprites2_0 = images/ships/shpalabc/SHOT_X2_0.bmp
+ExtraExtraSprites2_1 = images/ships/shpalabc/SHOT_X2_1.bmp
+ExtraExtraSprites2_2 = images/ships/shpalabc/SHOT_X2_2.bmp
+ExtraExtraSprites2_3 = images/ships/shpalabc/SHOT_X2_3.bmp
+
+ExtraExtraSprites3_0 = images/ships/shpalabc/SHOT_X3_E1.bmp
+ExtraExtraSprites3_1 = images/ships/shpalabc/SHOT_X3_E2.bmp
+
+ExtraExtraSprites4_0 = images/ships/shpalabc/SHOT_X4_E1.bmp
+ExtraExtraSprites4_1 = images/ships/shpalabc/SHOT_X4_E2.bmp
+
+ExtraExtraSprites5_0 = images/ships/shpalabc/SHOT_X5_E1.bmp
+ExtraExtraSprites5_1 = images/ships/shpalabc/SHOT_X5_E2.bmp
+
+ExtraExtraSprites6_0 = images/ships/shpalabc/SHOT_X6_E1.bmp
+ExtraExtraSprites6_1 = images/ships/shpalabc/SHOT_X6_E2.bmp
+
+ExtraExtraSprites7_0 = images/ships/shpalabc/SHOT_X7_00.bmp
+ExtraExtraSprites7_1 = images/ships/shpalabc/SHOT_X7_01.bmp
+ExtraExtraSprites7_2 = images/ships/shpalabc/SHOT_X7_02.bmp
+ExtraExtraSprites7_3 = images/ships/shpalabc/SHOT_X7_03.bmp
+ExtraExtraSprites7_4 = images/ships/shpalabc/SHOT_X7_04.bmp
+ExtraExtraSprites7_5 = images/ships/shpalabc/SHOT_X7_05.bmp
+ExtraExtraSprites7_6 = images/ships/shpalabc/SHOT_X7_06.bmp
+ExtraExtraSprites7_7 = images/ships/shpalabc/SHOT_X7_07.bmp
+ExtraExtraSprites7_8 = images/ships/shpalabc/SHOT_X7_08.bmp
+ExtraExtraSprites7_9 = images/ships/shpalabc/SHOT_X7_09.bmp
+ExtraExtraSprites7_10 = images/ships/shpalabc/SHOT_X7_10.bmp
+ExtraExtraSprites7_11 = images/ships/shpalabc/SHOT_X7_11.bmp
+
+ExtraExtraSprites8_0 = images/ships/shpalabc/SHOT_X8_00.bmp
+ExtraExtraSprites8_1 = images/ships/shpalabc/SHOT_X8_01.bmp
+ExtraExtraSprites8_2 = images/ships/shpalabc/SHOT_X8_02.bmp
+ExtraExtraSprites8_3 = images/ships/shpalabc/SHOT_X8_03.bmp
+ExtraExtraSprites8_4 = images/ships/shpalabc/SHOT_X8_04.bmp
+ExtraExtraSprites8_5 = images/ships/shpalabc/SHOT_X8_05.bmp
+ExtraExtraSprites8_6 = images/ships/shpalabc/SHOT_X8_06.bmp
+ExtraExtraSprites8_7 = images/ships/shpalabc/SHOT_X8_07.bmp
+ExtraExtraSprites8_8 = images/ships/shpalabc/SHOT_X8_08.bmp
+ExtraExtraSprites8_9 = images/ships/shpalabc/SHOT_X8_09.bmp
+ExtraExtraSprites8_10 = images/ships/shpalabc/SHOT_X8_10.bmp
+ExtraExtraSprites8_11 = images/ships/shpalabc/SHOT_X8_11.bmp
+

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpandgu.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpandgu.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpandgu.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -7,6 +7,7 @@
 Origin = UQM
 Code = AndrosynthGuardian
 Coders = The Fly
+Version = 65M
 
 [Ship]
 Crew = 20
@@ -77,3 +78,50 @@
 CaptName14 = NECRO-99
 CaptName15 = HAL-2001
 CaptName16 = SR-71
+
+[Music]
+Victory = music/ditty/andditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpandgu/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpandgu/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 1r11 +alpha
+WeaponSamples = 1
+WeaponExplosion = 6 +alpha
+SpecialSprites = 1r +alpha
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 1
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpandgu/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpandgu/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpandgu/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpandgu/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpandgu/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpandgu/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpandgu/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpandgu/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpandgu/SHOT_A01_PCX.bmp
+
+WeaponExplosion0 = images/ships/shpandgu/SHOT_B01_PCX.bmp
+WeaponExplosion1 = images/ships/shpandgu/SHOT_B02_PCX.bmp
+WeaponExplosion2 = images/ships/shpandgu/SHOT_B03_PCX.bmp
+WeaponExplosion3 = images/ships/shpandgu/SHOT_B04_PCX.bmp
+WeaponExplosion4 = images/ships/shpandgu/SHOT_B05_PCX.bmp
+WeaponExplosion5 = images/ships/shpandgu/SHOT_B06_PCX.bmp
+
+
+SpecialSprites0 = images/ships/shpandgu/SHOT_C01_PCX.bmp
+
+ExtraSprites0 = images/ships/shpandgu/SHOT_EXX_BMP.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shparisk.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shparisk.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shparisk.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -8,6 +8,7 @@
 Origin = UQM
 Coders = The Fly
 Code = ArilouSkiff
+Version = 65M
 
 [Ship]
 Crew = 6
@@ -60,3 +61,78 @@
 CaptName14 = Yipyapi
 CaptName15 = Ropilup
 CaptName16 = Wolwali
+
+[Music]
+Victory = music/ditty/ariditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shparisk/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shparisk/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 0
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 40 +alpha
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shparisk/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shparisk/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shparisk/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shparisk/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shparisk/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shparisk/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shparisk/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shparisk/SHIP_S01_PCX.bmp
+
+SpecialSprites0 = images/ships/shparisk/SHOT_A01_PCX.bmp
+SpecialSprites1 = images/ships/shparisk/SHOT_A02_PCX.bmp
+SpecialSprites2 = images/ships/shparisk/SHOT_A03_PCX.bmp
+SpecialSprites3 = images/ships/shparisk/SHOT_A04_PCX.bmp
+SpecialSprites4 = images/ships/shparisk/SHOT_A05_PCX.bmp
+SpecialSprites5 = images/ships/shparisk/SHOT_A06_PCX.bmp
+SpecialSprites6 = images/ships/shparisk/SHOT_A07_PCX.bmp
+SpecialSprites7 = images/ships/shparisk/SHOT_A08_PCX.bmp
+SpecialSprites8 = images/ships/shparisk/SHOT_A09_PCX.bmp
+SpecialSprites9 = images/ships/shparisk/SHOT_A10_PCX.bmp
+SpecialSprites10 = images/ships/shparisk/SHOT_A11_PCX.bmp
+SpecialSprites11 = images/ships/shparisk/SHOT_A12_PCX.bmp
+SpecialSprites12 = images/ships/shparisk/SHOT_A13_PCX.bmp
+SpecialSprites13 = images/ships/shparisk/SHOT_A14_PCX.bmp
+SpecialSprites14 = images/ships/shparisk/SHOT_A15_PCX.bmp
+SpecialSprites15 = images/ships/shparisk/SHOT_A16_PCX.bmp
+SpecialSprites16 = images/ships/shparisk/SHOT_A17_PCX.bmp
+SpecialSprites17 = images/ships/shparisk/SHOT_A18_PCX.bmp
+SpecialSprites18 = images/ships/shparisk/SHOT_A19_PCX.bmp
+SpecialSprites19 = images/ships/shparisk/SHOT_A20_PCX.bmp
+SpecialSprites20 = images/ships/shparisk/SHOT_A21_PCX.bmp
+SpecialSprites21 = images/ships/shparisk/SHOT_A22_PCX.bmp
+SpecialSprites22 = images/ships/shparisk/SHOT_A23_PCX.bmp
+SpecialSprites23 = images/ships/shparisk/SHOT_A24_PCX.bmp
+SpecialSprites24 = images/ships/shparisk/SHOT_A25_PCX.bmp
+SpecialSprites25 = images/ships/shparisk/SHOT_A26_PCX.bmp
+SpecialSprites26 = images/ships/shparisk/SHOT_A27_PCX.bmp
+SpecialSprites27 = images/ships/shparisk/SHOT_A28_PCX.bmp
+SpecialSprites28 = images/ships/shparisk/SHOT_A29_PCX.bmp
+SpecialSprites29 = images/ships/shparisk/SHOT_A30_PCX.bmp
+SpecialSprites30 = images/ships/shparisk/SHOT_A31_PCX.bmp
+SpecialSprites31 = images/ships/shparisk/SHOT_A32_PCX.bmp
+SpecialSprites32 = images/ships/shparisk/SHOT_A33_PCX.bmp
+SpecialSprites33 = images/ships/shparisk/SHOT_A34_PCX.bmp
+SpecialSprites34 = images/ships/shparisk/SHOT_A35_PCX.bmp
+SpecialSprites35 = images/ships/shparisk/SHOT_A36_PCX.bmp
+SpecialSprites36 = images/ships/shparisk/SHOT_A37_PCX.bmp
+SpecialSprites37 = images/ships/shparisk/SHOT_A38_PCX.bmp
+SpecialSprites38 = images/ships/shparisk/SHOT_A39_PCX.bmp
+SpecialSprites39 = images/ships/shparisk/SHOT_A40_PCX.bmp
+

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpbahbu.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpbahbu.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpbahbu.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,44 +1,45 @@
 [Info]
 Origin = TW
-TWCost  = 20
+TWCost = 20
 Name = Bahoid Buzzsaw
 Name1 = Bahoid
 Name2 = Buzzsaw
 Coders = Reddish
 Code = BahaoidBuzzsaw
+Version = 65M
 
 [Ship]
-Crew           = 24
-CrewMax        = 24
-Batt           = 20
-BattMax        = 20
-SpeedMax       = 25
-AccelRate      = 6
-TurnRate       = 4
+Crew = 24
+CrewMax = 24
+Batt = 20
+BattMax = 20
+SpeedMax = 25
+AccelRate = 6
+TurnRate = 4
 RechargeAmount = 1
-RechargeRate   = 4
-WeaponDrain    = 0
-WeaponRate     = 0
-SpecialDrain   = 4
-SpecialRate    = 10
-HotspotRate    = 2
-Mass           = 12
+RechargeRate = 4
+WeaponDrain = 0
+WeaponRate = 0
+SpecialDrain = 4
+SpecialRate = 10
+HotspotRate = 2
+Mass = 12
 
 [Weapon]
-Range    = 2
-Damage   = 1
-Speed    = .8
-Color    = 10
+Range = 2
+Damage = 1
+Speed = .8
+Color = 10
 
 [Special]
-Range    = 20
+Range = 20
 Velocity = 10
-Damage   = 6
-Armour   = 10
-Timer    = 13000
-Radius   = 8
-Seek     = 5.5
-VelSeek  = 120
+Damage = 6
+Armour = 10
+Timer = 13000
+Radius = 8
+Seek = 5.5
+VelSeek = 120
 Number = 2
 
 [AI3_Default]
@@ -50,3 +51,38 @@
 Special3 = Back
 Special4 = Homing
 
+[Music]
+Victory = music/ditty/ariditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpbahbu/WAVE_A01_WAV.wav
+WeaponSample1 = sound/ships/shpbahbu/WAVE_A02_WAV.wav
+
+SpecialSample0 = sound/ships/shpbahbu/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 0
+WeaponSamples = 2
+WeaponExplosion = 0
+SpecialSprites = 1r
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpbahbu/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpbahbu/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpbahbu/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpbahbu/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpbahbu/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpbahbu/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpbahbu/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpbahbu/SHIP_S01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpbahbu/SHOT_B01_PCX.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpbipka.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpbipka.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpbipka.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -8,6 +8,7 @@
 Sfx = Forevian
 Ditty = Forevian
 Code = BipoleKatamaran
+Version = 65M
 
 [Ship]
 Crew = 12
@@ -48,3 +49,53 @@
 Special = Proximity
 Special_Range = 8
 Plus_Fire = Special
+
+[Music]
+Victory = music/ditty/ariditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpbipka/WAVE_A01_WAV.wav
+WeaponSample1 = sound/ships/shpbipka/WAVE_A02_WAV.wav
+WeaponSample2 = sound/ships/shpbipka/WAVE_A03_WAV.wav
+WeaponSample3 = sound/ships/shpbipka/WAVE_A04_WAV.wav
+WeaponSample4 = sound/ships/shpbipka/WAVE_A05_WAV.wav
+WeaponSample5 = sound/ships/shpbipka/WAVE_A06_WAV.wav
+WeaponSample6 = sound/ships/shpbipka/WAVE_A07_WAV.wav
+WeaponSample7 = sound/ships/shpbipka/WAVE_A08_WAV.wav
+WeaponSample8 = sound/ships/shpbipka/WAVE_A09_WAV.wav
+WeaponSample9 = sound/ships/shpbipka/WAVE_A10_WAV.wav
+WeaponSample10 = sound/ships/shpbipka/WAVE_A11_WAV.wav
+
+SpecialSample0 = sound/ships/shpbipka/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 11
+WeaponExplosion = 0
+SpecialSprites = 1r
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 9
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpbipka/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpbipka/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpbipka/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpbipka/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpbipka/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpbipka/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpbipka/SHIP_P06_PCX.bmp
+PanelBitmaps7 = images/ships/shpbipka/SHIP_P07_PCX.bmp
+PanelBitmaps8 = images/ships/shpbipka/SHIP_P08_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpbipka/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpbipka/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpbipka/SHOT_B01_PCX.bmp
+

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpchebr.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpchebr.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpchebr.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = ChenjesuBroodhome
+Version = 65M
 
 [Ship]
 Crew = 36
@@ -67,3 +68,89 @@
 CaptName14 = Vrroww
 CaptName15 = Zznaz
 CaptName16 = Zzzhmm
+
+[Music]
+Victory = music/ditty/cheditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpchebr/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpchebr/WAVE_B01_WAV.wav
+
+ExtraSample0 = sound/ships/shpchebr/WAVE_C01_WAV.wav
+ExtraSample1 = sound/ships/shpchebr/WAVE_C02_WAV.wav
+ExtraSample2 = sound/ships/shpchebr/WAVE_C03_WAV.wav
+
+[Objects]
+
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 20 +alpha
+SpecialSprites = 1r
+SpecialSamples = 1
+SpecialExplosion = 20 +alpha
+ExtraSprites = 1r
+ExtraSamples = 3
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpchebr/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpchebr/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpchebr/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpchebr/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpchebr/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpchebr/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpchebr/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpchebr/SHIP_S_00_TGA.bmp
+
+WeaponSprites0 = images/ships/shpchebr/SHOT_A_00_TGA.bmp
+
+WeaponExplosion0 = images/ships/shpchebr/SHOT_B_00_TGA.bmp
+WeaponExplosion1 = images/ships/shpchebr/SHOT_B_01_TGA.bmp
+WeaponExplosion2 = images/ships/shpchebr/SHOT_B_02_TGA.bmp
+WeaponExplosion3 = images/ships/shpchebr/SHOT_B_03_TGA.bmp
+WeaponExplosion4 = images/ships/shpchebr/SHOT_B_04_TGA.bmp
+WeaponExplosion5 = images/ships/shpchebr/SHOT_B_05_TGA.bmp
+WeaponExplosion6 = images/ships/shpchebr/SHOT_B_06_TGA.bmp
+WeaponExplosion7 = images/ships/shpchebr/SHOT_B_07_TGA.bmp
+WeaponExplosion8 = images/ships/shpchebr/SHOT_B_08_TGA.bmp
+WeaponExplosion9 = images/ships/shpchebr/SHOT_B_09_TGA.bmp
+WeaponExplosion10 = images/ships/shpchebr/SHOT_B_10_TGA.bmp
+WeaponExplosion11 = images/ships/shpchebr/SHOT_B_11_TGA.bmp
+WeaponExplosion12 = images/ships/shpchebr/SHOT_B_12_TGA.bmp
+WeaponExplosion13 = images/ships/shpchebr/SHOT_B_13_TGA.bmp
+WeaponExplosion14 = images/ships/shpchebr/SHOT_B_14_TGA.bmp
+WeaponExplosion15 = images/ships/shpchebr/SHOT_B_15_TGA.bmp
+WeaponExplosion16 = images/ships/shpchebr/SHOT_B_16_TGA.bmp
+WeaponExplosion17 = images/ships/shpchebr/SHOT_B_17_TGA.bmp
+WeaponExplosion18 = images/ships/shpchebr/SHOT_B_18_TGA.bmp
+WeaponExplosion19 = images/ships/shpchebr/SHOT_B_19_TGA.bmp
+
+SpecialSprites0 = images/ships/shpchebr/SHOT_C_00_TGA.bmp
+
+SpecialExplosion0 = images/ships/shpchebr/SHOT_D_00_TGA.bmp
+SpecialExplosion1 = images/ships/shpchebr/SHOT_D_01_TGA.bmp
+SpecialExplosion2 = images/ships/shpchebr/SHOT_D_02_TGA.bmp
+SpecialExplosion3 = images/ships/shpchebr/SHOT_D_03_TGA.bmp
+SpecialExplosion4 = images/ships/shpchebr/SHOT_D_04_TGA.bmp
+SpecialExplosion5 = images/ships/shpchebr/SHOT_D_05_TGA.bmp
+SpecialExplosion6 = images/ships/shpchebr/SHOT_D_06_TGA.bmp
+SpecialExplosion7 = images/ships/shpchebr/SHOT_D_07_TGA.bmp
+SpecialExplosion8 = images/ships/shpchebr/SHOT_D_08_TGA.bmp
+SpecialExplosion9 = images/ships/shpchebr/SHOT_D_09_TGA.bmp
+SpecialExplosion10 = images/ships/shpchebr/SHOT_D_10_TGA.bmp
+SpecialExplosion11 = images/ships/shpchebr/SHOT_D_11_TGA.bmp
+SpecialExplosion12 = images/ships/shpchebr/SHOT_D_12_TGA.bmp
+SpecialExplosion13 = images/ships/shpchebr/SHOT_D_13_TGA.bmp
+SpecialExplosion14 = images/ships/shpchebr/SHOT_D_14_TGA.bmp
+SpecialExplosion15 = images/ships/shpchebr/SHOT_D_15_TGA.bmp
+SpecialExplosion16 = images/ships/shpchebr/SHOT_D_16_TGA.bmp
+SpecialExplosion17 = images/ships/shpchebr/SHOT_D_17_TGA.bmp
+SpecialExplosion18 = images/ships/shpchebr/SHOT_D_18_TGA.bmp
+SpecialExplosion19 = images/ships/shpchebr/SHOT_D_19_TGA.bmp
+
+ExtraSprites0 = images/ships/shpchebr/SHOT_E_00_TGA.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpchmav.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpchmav.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpchmav.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = ChmmrAvatar
+Version = 65M
 
 [Ship]
 Crew = 42
@@ -62,3 +63,145 @@
 CaptName14 = Tzrtzn
 CaptName15 = Kztztz
 CaptName16 = Mrnkzt
+
+[Music]
+Victory = music/ditty/chmditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpchmav/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpchmav/WAVE_B01_WAV.wav
+
+ExtraSample0 = sound/ships/shpchmav/WAVE_C01_WAV.wav
+
+[Objects]
+
+ShipSprites = 1r
+WeaponSprites = 0
+WeaponSamples = 1
+WeaponExplosion = 40 +alpha
+SpecialSprites = 0
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 64
+ExtraSamples = 1
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpchmav/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpchmav/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpchmav/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpchmav/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpchmav/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpchmav/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpchmav/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpchmav/SHIP_S01_PCX.bmp
+
+WeaponExplosion0 = images/ships/shpchmav/SHOT_A0_00_BMP.bmp
+WeaponExplosion1 = images/ships/shpchmav/SHOT_A0_01_BMP.bmp
+WeaponExplosion2 = images/ships/shpchmav/SHOT_A0_02_BMP.bmp
+WeaponExplosion3 = images/ships/shpchmav/SHOT_A0_03_BMP.bmp
+WeaponExplosion4 = images/ships/shpchmav/SHOT_A0_04_BMP.bmp
+WeaponExplosion5 = images/ships/shpchmav/SHOT_A0_05_BMP.bmp
+WeaponExplosion6 = images/ships/shpchmav/SHOT_A0_06_BMP.bmp
+WeaponExplosion7 = images/ships/shpchmav/SHOT_A0_07_BMP.bmp
+WeaponExplosion8 = images/ships/shpchmav/SHOT_A0_08_BMP.bmp
+WeaponExplosion9 = images/ships/shpchmav/SHOT_A0_09_BMP.bmp
+WeaponExplosion10 = images/ships/shpchmav/SHOT_A1_00_BMP.bmp
+WeaponExplosion11 = images/ships/shpchmav/SHOT_A1_01_BMP.bmp
+WeaponExplosion12 = images/ships/shpchmav/SHOT_A1_02_BMP.bmp
+WeaponExplosion13 = images/ships/shpchmav/SHOT_A1_03_BMP.bmp
+WeaponExplosion14 = images/ships/shpchmav/SHOT_A1_04_BMP.bmp
+WeaponExplosion15 = images/ships/shpchmav/SHOT_A1_05_BMP.bmp
+WeaponExplosion16 = images/ships/shpchmav/SHOT_A1_06_BMP.bmp
+WeaponExplosion17 = images/ships/shpchmav/SHOT_A1_07_BMP.bmp
+WeaponExplosion18 = images/ships/shpchmav/SHOT_A1_08_BMP.bmp
+WeaponExplosion19 = images/ships/shpchmav/SHOT_A1_09_BMP.bmp
+WeaponExplosion20 = images/ships/shpchmav/SHOT_A2_00_BMP.bmp
+WeaponExplosion21 = images/ships/shpchmav/SHOT_A2_01_BMP.bmp
+WeaponExplosion22 = images/ships/shpchmav/SHOT_A2_02_BMP.bmp
+WeaponExplosion23 = images/ships/shpchmav/SHOT_A2_03_BMP.bmp
+WeaponExplosion24 = images/ships/shpchmav/SHOT_A2_04_BMP.bmp
+WeaponExplosion25 = images/ships/shpchmav/SHOT_A2_05_BMP.bmp
+WeaponExplosion26 = images/ships/shpchmav/SHOT_A2_06_BMP.bmp
+WeaponExplosion27 = images/ships/shpchmav/SHOT_A2_07_BMP.bmp
+WeaponExplosion28 = images/ships/shpchmav/SHOT_A2_08_BMP.bmp
+WeaponExplosion29 = images/ships/shpchmav/SHOT_A2_09_BMP.bmp
+WeaponExplosion30 = images/ships/shpchmav/SHOT_A3_00_BMP.bmp
+WeaponExplosion31 = images/ships/shpchmav/SHOT_A3_01_BMP.bmp
+WeaponExplosion32 = images/ships/shpchmav/SHOT_A3_02_BMP.bmp
+WeaponExplosion33 = images/ships/shpchmav/SHOT_A3_03_BMP.bmp
+WeaponExplosion34 = images/ships/shpchmav/SHOT_A3_04_BMP.bmp
+WeaponExplosion35 = images/ships/shpchmav/SHOT_A3_05_BMP.bmp
+WeaponExplosion36 = images/ships/shpchmav/SHOT_A3_06_BMP.bmp
+WeaponExplosion37 = images/ships/shpchmav/SHOT_A3_07_BMP.bmp
+WeaponExplosion38 = images/ships/shpchmav/SHOT_A3_08_BMP.bmp
+WeaponExplosion39 = images/ships/shpchmav/SHOT_A3_09_BMP.bmp
+
+ExtraSprites0 = images/ships/shpchmav/SHOT_B01_PCX.bmp
+ExtraSprites1 = images/ships/shpchmav/SHOT_B02_PCX.bmp
+ExtraSprites2 = images/ships/shpchmav/SHOT_B03_PCX.bmp
+ExtraSprites3 = images/ships/shpchmav/SHOT_B04_PCX.bmp
+ExtraSprites4 = images/ships/shpchmav/SHOT_B05_PCX.bmp
+ExtraSprites5 = images/ships/shpchmav/SHOT_B06_PCX.bmp
+ExtraSprites6 = images/ships/shpchmav/SHOT_B07_PCX.bmp
+ExtraSprites7 = images/ships/shpchmav/SHOT_B08_PCX.bmp
+ExtraSprites8 = images/ships/shpchmav/SHOT_B09_PCX.bmp
+ExtraSprites9 = images/ships/shpchmav/SHOT_B10_PCX.bmp
+ExtraSprites10 = images/ships/shpchmav/SHOT_B11_PCX.bmp
+ExtraSprites11 = images/ships/shpchmav/SHOT_B12_PCX.bmp
+ExtraSprites12 = images/ships/shpchmav/SHOT_B13_PCX.bmp
+ExtraSprites13 = images/ships/shpchmav/SHOT_B14_PCX.bmp
+ExtraSprites14 = images/ships/shpchmav/SHOT_B15_PCX.bmp
+ExtraSprites15 = images/ships/shpchmav/SHOT_B16_PCX.bmp
+ExtraSprites16 = images/ships/shpchmav/SHOT_B17_PCX.bmp
+ExtraSprites17 = images/ships/shpchmav/SHOT_B18_PCX.bmp
+ExtraSprites18 = images/ships/shpchmav/SHOT_B19_PCX.bmp
+ExtraSprites19 = images/ships/shpchmav/SHOT_B20_PCX.bmp
+ExtraSprites20 = images/ships/shpchmav/SHOT_B21_PCX.bmp
+ExtraSprites21 = images/ships/shpchmav/SHOT_B22_PCX.bmp
+ExtraSprites22 = images/ships/shpchmav/SHOT_B23_PCX.bmp
+ExtraSprites23 = images/ships/shpchmav/SHOT_B24_PCX.bmp
+ExtraSprites24 = images/ships/shpchmav/SHOT_B25_PCX.bmp
+ExtraSprites25 = images/ships/shpchmav/SHOT_B26_PCX.bmp
+ExtraSprites26 = images/ships/shpchmav/SHOT_B27_PCX.bmp
+ExtraSprites27 = images/ships/shpchmav/SHOT_B28_PCX.bmp
+ExtraSprites28 = images/ships/shpchmav/SHOT_B29_PCX.bmp
+ExtraSprites29 = images/ships/shpchmav/SHOT_B30_PCX.bmp
+ExtraSprites30 = images/ships/shpchmav/SHOT_B31_PCX.bmp
+ExtraSprites31 = images/ships/shpchmav/SHOT_B32_PCX.bmp
+ExtraSprites32 = images/ships/shpchmav/SHOT_B33_PCX.bmp
+ExtraSprites33 = images/ships/shpchmav/SHOT_B34_PCX.bmp
+ExtraSprites34 = images/ships/shpchmav/SHOT_B35_PCX.bmp
+ExtraSprites35 = images/ships/shpchmav/SHOT_B36_PCX.bmp
+ExtraSprites36 = images/ships/shpchmav/SHOT_B37_PCX.bmp
+ExtraSprites37 = images/ships/shpchmav/SHOT_B38_PCX.bmp
+ExtraSprites38 = images/ships/shpchmav/SHOT_B39_PCX.bmp
+ExtraSprites39 = images/ships/shpchmav/SHOT_B40_PCX.bmp
+ExtraSprites40 = images/ships/shpchmav/SHOT_B41_PCX.bmp
+ExtraSprites41 = images/ships/shpchmav/SHOT_B42_PCX.bmp
+ExtraSprites42 = images/ships/shpchmav/SHOT_B43_PCX.bmp
+ExtraSprites43 = images/ships/shpchmav/SHOT_B44_PCX.bmp
+ExtraSprites44 = images/ships/shpchmav/SHOT_B45_PCX.bmp
+ExtraSprites45 = images/ships/shpchmav/SHOT_B46_PCX.bmp
+ExtraSprites46 = images/ships/shpchmav/SHOT_B47_PCX.bmp
+ExtraSprites47 = images/ships/shpchmav/SHOT_B48_PCX.bmp
+ExtraSprites48 = images/ships/shpchmav/SHOT_B49_PCX.bmp
+ExtraSprites49 = images/ships/shpchmav/SHOT_B50_PCX.bmp
+ExtraSprites50 = images/ships/shpchmav/SHOT_B51_PCX.bmp
+ExtraSprites51 = images/ships/shpchmav/SHOT_B52_PCX.bmp
+ExtraSprites52 = images/ships/shpchmav/SHOT_B53_PCX.bmp
+ExtraSprites53 = images/ships/shpchmav/SHOT_B54_PCX.bmp
+ExtraSprites54 = images/ships/shpchmav/SHOT_B55_PCX.bmp
+ExtraSprites55 = images/ships/shpchmav/SHOT_B56_PCX.bmp
+ExtraSprites56 = images/ships/shpchmav/SHOT_B57_PCX.bmp
+ExtraSprites57 = images/ships/shpchmav/SHOT_B58_PCX.bmp
+ExtraSprites58 = images/ships/shpchmav/SHOT_B59_PCX.bmp
+ExtraSprites59 = images/ships/shpchmav/SHOT_B60_PCX.bmp
+ExtraSprites60 = images/ships/shpchmav/SHOT_B61_PCX.bmp
+ExtraSprites61 = images/ships/shpchmav/SHOT_B62_PCX.bmp
+ExtraSprites62 = images/ships/shpchmav/SHOT_B63_PCX.bmp
+ExtraSprites63 = images/ships/shpchmav/SHOT_B64_PCX.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpchoex.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpchoex.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpchoex.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,56 +1,57 @@
 [Info]
-TWCost  = 14
+TWCost = 14
 Name1 = Chorali
 Name2 = Extractor
 Origin = TW
 Coder = Culture20
 Code = ChoraliExtractor
+Version = 65M
 
 [Ship]
-Crew           = 18
-CrewMax        = 18
-Batt           = 20
-BattMax        = 20
-SpeedMax       = 46	; 40
-AccelRate      = 10
-TurnRate       = 2
+Crew = 18
+CrewMax = 18
+Batt = 20
+BattMax = 20
+SpeedMax = 46	; 40
+AccelRate = 10
+TurnRate = 2
 RechargeAmount = 1
-RechargeRate   = 3
-WeaponDrain    = 8
-WeaponRate     = 4
-SpecialDrain   = 1
-SpecialRate    = 0
-HotspotRate    = 4
-Mass           = 14
+RechargeRate = 3
+WeaponDrain = 8
+WeaponRate = 4
+SpecialDrain = 1
+SpecialRate = 0
+HotspotRate = 4
+Mass = 14
 
 [Weapon]
-Frames   = 6000
-Damage   = 1
+Frames = 6000
+Damage = 1
 
 [AsteroidMissile]
-Range    = 40	; 60
+Range = 40	; 60
 Velocity = 55	; 80
-Damage   = 2
-Armour   = 1
+Damage = 2
+Armour = 1
 TurnRate = 2
 
 [Special]
-Force    = 255
+Force = 255
 
 [Tractor]
-Range    = 6
-PushForce= 14
-PullForce= 1.5	; 1.0
-MaxColorR   = 0
-MaxColorG   = 160
-MaxColorB   = 255
-MinColorR   = 0
-MinColorG   = 0
-MinColorB   = 160
-Rate     = 1
-Damage   = 0
+Range = 6
+PushForce = 14
+PullForce = 1.5	; 1.0
+MaxColorR = 0
+MaxColorG = 160
+MaxColorB = 255
+MinColorR = 0
+MinColorG = 0
+MinColorB = 160
+Rate = 1
+Damage = 0
 MaxBeams = 3
-Spread   = 60
+Spread = 60
 
 [AI3_Default]
 Weapon_Range = 9
@@ -66,3 +67,54 @@
 CaptName5 = Keyrt
 CaptName6 = Ulurt
 CaptName7 = Treakzk
+
+[Music]
+Victory = music/ditty/cheditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpchoex/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpchoex/WAVE_B01_WAV.wav
+
+ExtraSample0 = sound/ships/shpchoex/WAVE_C01_WAV.wav
+ExtraSample1 = sound/ships/shpchoex/WAVE_C01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 10
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 1r
+ExtraSamples = 2
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpchoex/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpchoex/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpchoex/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpchoex/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpchoex/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpchoex/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpchoex/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpchoex/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpchoex/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpchoex/SHOT_B01_PCX.bmp
+SpecialSprites1 = images/ships/shpchoex/SHOT_B02_PCX.bmp
+SpecialSprites2 = images/ships/shpchoex/SHOT_B03_PCX.bmp
+SpecialSprites3 = images/ships/shpchoex/SHOT_B04_PCX.bmp
+SpecialSprites4 = images/ships/shpchoex/SHOT_B05_PCX.bmp
+SpecialSprites5 = images/ships/shpchoex/SHOT_B06_PCX.bmp
+SpecialSprites6 = images/ships/shpchoex/SHOT_B07_PCX.bmp
+SpecialSprites7 = images/ships/shpchoex/SHOT_B08_PCX.bmp
+SpecialSprites8 = images/ships/shpchoex/SHOT_B09_PCX.bmp
+SpecialSprites9 = images/ships/shpchoex/SHOT_B10_PCX.bmp
+
+ExtraSprites0 = images/ships/shpchoex/SHOT_C01_PCX.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpconca.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpconca.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpconca.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -5,6 +5,7 @@
 Origin = TW
 Coders = Corona688
 Code = ConfedCargotran
+Version = 65M
 
 [Ship]
 Crew = 6
@@ -38,3 +39,48 @@
 Weapon_Range = 20
 Special = Mine
 Special2 = Proximity
+
+[Music]
+Victory = music/ditty/cheditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpconca/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpconca/WAVE_B01_WAV.wav
+SpecialSample1 = sound/ships/shpconca/WAVE_B02_WAV.wav
+
+[Objects]
+
+ShipSprites = 1r
+WeaponSprites = 3r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 1r
+SpecialSamples = 2
+SpecialExplosion = 0
+ExtraSprites = 3r
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpconca/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpconca/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpconca/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpconca/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpconca/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpconca/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpconca/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpconca/SHIP_X00_BMP.bmp
+
+WeaponSprites0 = images/ships/shpconca/SHOT_000_PCX.bmp
+WeaponSprites1 = images/ships/shpconca/SHOT_001_PCX.bmp
+WeaponSprites2 = images/ships/shpconca/SHOT_002_PCX.bmp
+
+SpecialSprites0 = images/ships/shpconca/SHOT_A01_PCX.bmp
+
+ExtraSprites0 = images/ships/shpconca/SHOT_E00_PCX.bmp
+ExtraSprites1 = images/ships/shpconca/SHOT_E01_PCX.bmp
+ExtraSprites2 = images/ships/shpconca/SHOT_E02_PCS.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpconho.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpconho.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpconho.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -6,6 +6,7 @@
 Origin = TW
 Coders = Slag-786B
 Code = ConfederationHornet
+Version = 65M
 
 [Ship]
 Crew = 1
@@ -56,3 +57,50 @@
 Special = Front
 Special2 = Proximity
 Special_Range = 18
+
+[Music]
+Victory = music/ditty/cheditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpconho/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpconho/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 1r
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 17
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpconho/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpconho/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpconho/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpconho/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpconho/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpconho/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpconho/SHIP_P06_PCX.bmp
+PanelBitmaps7 = images/ships/shpconho/SHIP_P07_PCX.bmp
+PanelBitmaps8 = images/ships/shpconho/SHIP_P08_PCX.bmp
+PanelBitmaps9 = images/ships/shpconho/SHIP_P09_PCX.bmp
+PanelBitmaps10 = images/ships/shpconho/SHIP_P10_PCX.bmp
+PanelBitmaps11 = images/ships/shpconho/SHIP_P11_PCX.bmp
+PanelBitmaps12 = images/ships/shpconho/SHIP_P12_PCX.bmp
+PanelBitmaps13 = images/ships/shpconho/SHIP_P13_PCX.bmp
+PanelBitmaps14 = images/ships/shpconho/SHIP_P14_PCX.bmp
+PanelBitmaps15 = images/ships/shpconho/SHIP_P15_PCX.bmp
+PanelBitmaps16 = images/ships/shpconho/SHIP_P16_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpconho/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpconho/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpconho/SHOT_B01_PCX.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpdragr.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpdragr.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpdragr.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -5,6 +5,7 @@
 Origin = TW
 Coders = Launchpad
 Code = DraxGryphon
+Version = 65M
 
 [Ship]
 Crew = 24
@@ -52,3 +53,42 @@
 NumNames = 2
 CaptName1 = Resquel
 CaptName2 = Quiszin
+
+[Music]
+Victory = music/ditty/cheditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpdragr/WAVE_A01_WAV.wav
+WeaponSample1 = sound/ships/shpdragr/WAVE_A02_WAV.wav
+
+SpecialSample0 = sound/ships/shpdragr/WAVE_B01_WAV.wav
+
+[Objects]
+
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 2
+WeaponExplosion = 0
+SpecialSprites = 1r
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpdragr/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpdragr/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpdragr/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpdragr/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpdragr/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpdragr/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpdragr/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpdragr/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpdragr/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpdragr/SHOT_B01_PCX.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpdruma.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpdruma.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpdruma.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -6,6 +6,7 @@
 Origin = UQM
 Coders = The Fly
 Code = DruugeMauler
+Version = 65M
 
 [Ship]
 Crew = 14
@@ -54,3 +55,43 @@
 CaptName14 = Piini
 CaptName15 = Soopi
 CaptName16 = Peeru
+
+[Music]
+Victory = music/ditty/druditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpdruma/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpdruma/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 5
+SpecialSprites = 0
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpdruma/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpdruma/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpdruma/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpdruma/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpdruma/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpdruma/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpdruma/SHIP_P06_PCX.bmp
+
+ShipSprites0 = images/ships/shpdruma/SHIP_S00_PCX.bmp
+
+WeaponSprites0 = images/ships/shpdruma/SHOT_A01_PCX.bmp
+
+WeaponExplosion0 = images/ships/shpdruma/SHOT_B01_PCX.bmp
+WeaponExplosion1 = images/ships/shpdruma/SHOT_B02_PCX.bmp
+WeaponExplosion2 = images/ships/shpdruma/SHOT_B03_PCX.bmp
+WeaponExplosion3 = images/ships/shpdruma/SHOT_B04_PCX.bmp
+WeaponExplosion4 = images/ships/shpdruma/SHOT_B05_PCX.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpearc3.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpearc3.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpearc3.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -5,6 +5,7 @@
 Origin = TW
 Coders = Tau
 Code = EarthlingCruiserMk3
+Version = 65M
 
 [Ship]
 Crew = 24
@@ -61,3 +62,98 @@
 CaptName14 = Buck
 CaptName15 = Solo
 CaptName16 = Belt
+
+[Music]
+Victory = music/ditty/humditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpearc3/WAVE_A00_WAV.wav
+WeaponSample1 = sound/ships/shpearc3/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpearc3/WAVE_B00_WAV.wav
+
+ExtraSample0 = sound/ships/shpearc3/WAVE_C00_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 33 +alpha
+WeaponSamples = 2
+WeaponExplosion = 20 +alpha
+SpecialSprites = 1 +alpha
+SpecialSamples = 1
+SpecialExplosion = 1 +alpha
+ExtraSprites = 0
+ExtraSamples = 1
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpearc3/ship_p00.bmp
+PanelBitmaps1 = images/ships/shpearc3/ship_p01.bmp
+PanelBitmaps2 = images/ships/shpearc3/ship_p02.bmp
+PanelBitmaps3 = images/ships/shpearc3/ship_p03.bmp
+PanelBitmaps4 = images/ships/shpearc3/ship_p04.bmp
+PanelBitmaps5 = images/ships/shpearc3/ship_p05.bmp
+PanelBitmaps6 = images/ships/shpearc3/ship_p06.bmp
+
+ShipSprites0 = images/ships/shpearc3/SHIP_S0_00_BMP.bmp
+
+WeaponSprites0 = images/ships/shpearc3/SHOT_A0_00_TGA.bmp
+WeaponSprites1 = images/ships/shpearc3/SHOT_A0_01_TGA.bmp
+WeaponSprites2 = images/ships/shpearc3/SHOT_A0_02_TGA.bmp
+WeaponSprites3 = images/ships/shpearc3/SHOT_A0_03_TGA.bmp
+WeaponSprites4 = images/ships/shpearc3/SHOT_A0_04_TGA.bmp
+WeaponSprites5 = images/ships/shpearc3/SHOT_A0_05_TGA.bmp
+WeaponSprites6 = images/ships/shpearc3/SHOT_A0_06_TGA.bmp
+WeaponSprites7 = images/ships/shpearc3/SHOT_A0_07_TGA.bmp
+WeaponSprites8 = images/ships/shpearc3/SHOT_A0_08_TGA.bmp
+WeaponSprites9 = images/ships/shpearc3/SHOT_A0_09_TGA.bmp
+WeaponSprites10 = images/ships/shpearc3/SHOT_A0_10_TGA.bmp
+WeaponSprites11 = images/ships/shpearc3/SHOT_A0_11_TGA.bmp
+WeaponSprites12 = images/ships/shpearc3/SHOT_A0_12_TGA.bmp
+WeaponSprites13 = images/ships/shpearc3/SHOT_A0_13_TGA.bmp
+WeaponSprites14 = images/ships/shpearc3/SHOT_A0_14_TGA.bmp
+WeaponSprites15 = images/ships/shpearc3/SHOT_A0_15_TGA.bmp
+WeaponSprites16 = images/ships/shpearc3/SHOT_A0_16_TGA.bmp
+WeaponSprites17 = images/ships/shpearc3/SHOT_A0_17_TGA.bmp
+WeaponSprites18 = images/ships/shpearc3/SHOT_A0_18_TGA.bmp
+WeaponSprites19 = images/ships/shpearc3/SHOT_A0_19_TGA.bmp
+WeaponSprites20 = images/ships/shpearc3/SHOT_A0_20_TGA.bmp
+WeaponSprites21 = images/ships/shpearc3/SHOT_A0_21_TGA.bmp
+WeaponSprites22 = images/ships/shpearc3/SHOT_A0_22_TGA.bmp
+WeaponSprites23 = images/ships/shpearc3/SHOT_A0_23_TGA.bmp
+WeaponSprites24 = images/ships/shpearc3/SHOT_A0_24_TGA.bmp
+WeaponSprites25 = images/ships/shpearc3/SHOT_A0_25_TGA.bmp
+WeaponSprites26 = images/ships/shpearc3/SHOT_A0_26_TGA.bmp
+WeaponSprites27 = images/ships/shpearc3/SHOT_A0_27_TGA.bmp
+WeaponSprites28 = images/ships/shpearc3/SHOT_A0_28_TGA.bmp
+WeaponSprites29 = images/ships/shpearc3/SHOT_A0_29_TGA.bmp
+WeaponSprites30 = images/ships/shpearc3/SHOT_A0_30_TGA.bmp
+WeaponSprites31 = images/ships/shpearc3/SHOT_A0_31_TGA.bmp
+WeaponSprites32 = images/ships/shpearc3/SHOT_A0_XX_TGA.bmp
+
+WeaponExplosion0 = images/ships/shpearc3/SHOT_B0_00_TGA.bmp
+WeaponExplosion1 = images/ships/shpearc3/SHOT_B0_01_TGA.bmp
+WeaponExplosion2 = images/ships/shpearc3/SHOT_B0_02_TGA.bmp
+WeaponExplosion3 = images/ships/shpearc3/SHOT_B0_03_TGA.bmp
+WeaponExplosion4 = images/ships/shpearc3/SHOT_B0_04_TGA.bmp
+WeaponExplosion5 = images/ships/shpearc3/SHOT_B0_05_TGA.bmp
+WeaponExplosion6 = images/ships/shpearc3/SHOT_B0_06_TGA.bmp
+WeaponExplosion7 = images/ships/shpearc3/SHOT_B0_07_TGA.bmp
+WeaponExplosion8 = images/ships/shpearc3/SHOT_B0_08_TGA.bmp
+WeaponExplosion9 = images/ships/shpearc3/SHOT_B0_09_TGA.bmp
+WeaponExplosion10 = images/ships/shpearc3/SHOT_B0_10_TGA.bmp
+WeaponExplosion11 = images/ships/shpearc3/SHOT_B0_11_TGA.bmp
+WeaponExplosion12 = images/ships/shpearc3/SHOT_B0_12_TGA.bmp
+WeaponExplosion13 = images/ships/shpearc3/SHOT_B0_13_TGA.bmp
+WeaponExplosion14 = images/ships/shpearc3/SHOT_B0_14_TGA.bmp
+WeaponExplosion15 = images/ships/shpearc3/SHOT_B0_15_TGA.bmp
+WeaponExplosion16 = images/ships/shpearc3/SHOT_B0_16_TGA.bmp
+WeaponExplosion17 = images/ships/shpearc3/SHOT_B0_17_TGA.bmp
+WeaponExplosion18 = images/ships/shpearc3/SHOT_B0_18_TGA.bmp
+WeaponExplosion19 = images/ships/shpearc3/SHOT_B0_19_TGA.bmp
+
+SpecialSprites0 = images/ships/shpearc3/SHOT_C0_00_TGA.bmp
+
+SpecialExplosion0 = images/ships/shpearc3/SHOT_D0_00_TGA.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpearcr.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpearcr.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpearcr.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = EarthlingCruiser
+Version = 65M
 
 [Ship]
 Crew = 18
@@ -61,3 +62,49 @@
 CaptName14 = Buck
 CaptName15 = Solo
 CaptName16 = Belt
+
+[Music]
+Victory = music/ditty/humditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpearcr/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpearcr/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 10 +alpha
+SpecialSprites = 0
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpearcr/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpearcr/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpearcr/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpearcr/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpearcr/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpearcr/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpearcr/SHIP_P06_PCX.bmp
+
+ShipSprites0 = images/ships/shpearcr/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpearcr/SHOT_A01_PCX.bmp
+
+WeaponExplosion0 = images/ships/shpearcr/SHOT_B01_BMP.bmp
+WeaponExplosion1 = images/ships/shpearcr/SHOT_B02_BMP.bmp
+WeaponExplosion2 = images/ships/shpearcr/SHOT_B03_BMP.bmp
+WeaponExplosion3 = images/ships/shpearcr/SHOT_B04_BMP.bmp
+WeaponExplosion4 = images/ships/shpearcr/SHOT_B05_BMP.bmp
+WeaponExplosion5 = images/ships/shpearcr/SHOT_B06_BMP.bmp
+WeaponExplosion6 = images/ships/shpearcr/SHOT_B07_BMP.bmp
+WeaponExplosion7 = images/ships/shpearcr/SHOT_B08_BMP.bmp
+WeaponExplosion8 = images/ships/shpearcr/SHOT_B09_BMP.bmp
+WeaponExplosion9 = images/ships/shpearcr/SHOT_B10_BMP.bmp
+

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpforsh.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpforsh.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpforsh.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -4,6 +4,7 @@
 Name2 = Shocker
 Origin = TW
 Code = ForevianShocker
+Version = 65M
 
 [Ship]
 Crew = 42
@@ -46,3 +47,148 @@
 CaptName3 = Desussel
 CaptName4 = Fssres
 
+[Music]
+Victory = music/ditty/forditty.s3m
+
+[Sound]
+WeaponSample0 = sound/ships/shpforsh/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpforsh/WAVE_B01_WAV.wav
+SpecialSample1 = sound/ships/shpforsh/WAVE_B02_WAV.wav
+SpecialSample2 = sound/ships/shpforsh/WAVE_B03_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 32
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 10
+SpecialSamples = 3
+SpecialExplosion = 0
+ExtraSprites = 32
+ExtraSamples = 0
+ExtraExplosion = 32
+PanelBitmaps = 7
+
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpforsh/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpforsh/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpforsh/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpforsh/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpforsh/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpforsh/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpforsh/SHIP_P06_PCX.bmp
+
+ShipSprites0 = images/ships/shpforsh/SHIP_SS_000_BMP.bmp
+
+WeaponSprites0 = images/ships/shpforsh/SHOT_AR_PRIMARY_0001_BMP.bmp
+WeaponSprites1 = images/ships/shpforsh/SHOT_AR_PRIMARY_0002_BMP.bmp
+WeaponSprites2 = images/ships/shpforsh/SHOT_AR_PRIMARY_0003_BMP.bmp
+WeaponSprites3 = images/ships/shpforsh/SHOT_AR_PRIMARY_0004_BMP.bmp
+WeaponSprites4 = images/ships/shpforsh/SHOT_AR_PRIMARY_0005_BMP.bmp
+WeaponSprites5 = images/ships/shpforsh/SHOT_AR_PRIMARY_0006_BMP.bmp
+WeaponSprites6 = images/ships/shpforsh/SHOT_AR_PRIMARY_0007_BMP.bmp
+WeaponSprites7 = images/ships/shpforsh/SHOT_AR_PRIMARY_0008_BMP.bmp
+WeaponSprites8 = images/ships/shpforsh/SHOT_AR_PRIMARY_0009_BMP.bmp
+WeaponSprites9 = images/ships/shpforsh/SHOT_AR_PRIMARY_0010_BMP.bmp
+WeaponSprites10 = images/ships/shpforsh/SHOT_AR_PRIMARY_0011_BMP.bmp
+WeaponSprites11 = images/ships/shpforsh/SHOT_AR_PRIMARY_0012_BMP.bmp
+WeaponSprites12 = images/ships/shpforsh/SHOT_AR_PRIMARY_0013_BMP.bmp
+WeaponSprites13 = images/ships/shpforsh/SHOT_AR_PRIMARY_0014_BMP.bmp
+WeaponSprites14 = images/ships/shpforsh/SHOT_AR_PRIMARY_0015_BMP.bmp
+WeaponSprites15 = images/ships/shpforsh/SHOT_AR_PRIMARY_0016_BMP.bmp
+WeaponSprites16 = images/ships/shpforsh/SHOT_AR_PRIMARY_0017_BMP.bmp
+WeaponSprites17 = images/ships/shpforsh/SHOT_AR_PRIMARY_0018_BMP.bmp
+WeaponSprites18 = images/ships/shpforsh/SHOT_AR_PRIMARY_0019_BMP.bmp
+WeaponSprites19 = images/ships/shpforsh/SHOT_AR_PRIMARY_0020_BMP.bmp
+WeaponSprites20 = images/ships/shpforsh/SHOT_AR_PRIMARY_0021_BMP.bmp
+WeaponSprites21 = images/ships/shpforsh/SHOT_AR_PRIMARY_0022_BMP.bmp
+WeaponSprites22 = images/ships/shpforsh/SHOT_AR_PRIMARY_0023_BMP.bmp
+WeaponSprites23 = images/ships/shpforsh/SHOT_AR_PRIMARY_0024_BMP.bmp
+WeaponSprites24 = images/ships/shpforsh/SHOT_AR_PRIMARY_0025_BMP.bmp
+WeaponSprites25 = images/ships/shpforsh/SHOT_AR_PRIMARY_0026_BMP.bmp
+WeaponSprites26 = images/ships/shpforsh/SHOT_AR_PRIMARY_0027_BMP.bmp
+WeaponSprites27 = images/ships/shpforsh/SHOT_AR_PRIMARY_0028_BMP.bmp
+WeaponSprites28 = images/ships/shpforsh/SHOT_AR_PRIMARY_0029_BMP.bmp
+WeaponSprites29 = images/ships/shpforsh/SHOT_AR_PRIMARY_0030_BMP.bmp
+WeaponSprites30 = images/ships/shpforsh/SHOT_AR_PRIMARY_0031_BMP.bmp
+WeaponSprites31 = images/ships/shpforsh/SHOT_AR_PRIMARY_0032_BMP.bmp
+
+SpecialSprites0 = images/ships/shpforsh/SHOT_B01_PCX.bmp
+SpecialSprites1 = images/ships/shpforsh/SHOT_B02_PCX.bmp
+SpecialSprites2 = images/ships/shpforsh/SHOT_B03_PCX.bmp
+SpecialSprites3 = images/ships/shpforsh/SHOT_B04_PCX.bmp
+SpecialSprites4 = images/ships/shpforsh/SHOT_B05_PCX.bmp
+SpecialSprites5 = images/ships/shpforsh/SHOT_B06_PCX.bmp
+SpecialSprites6 = images/ships/shpforsh/SHOT_B07_PCX.bmp
+SpecialSprites7 = images/ships/shpforsh/SHOT_B08_PCX.bmp
+SpecialSprites8 = images/ships/shpforsh/SHOT_B09_PCX.bmp
+SpecialSprites9 = images/ships/shpforsh/SHOT_B10_PCX.bmp
+
+ExtraSprites0 = images/ships/shpforsh/SHOT_ER_PRIMARY0001_BMP.bmp
+ExtraSprites1 = images/ships/shpforsh/SHOT_ER_PRIMARY0002_BMP.bmp
+ExtraSprites2 = images/ships/shpforsh/SHOT_ER_PRIMARY0003_BMP.bmp
+ExtraSprites3 = images/ships/shpforsh/SHOT_ER_PRIMARY0004_BMP.bmp
+ExtraSprites4 = images/ships/shpforsh/SHOT_ER_PRIMARY0005_BMP.bmp
+ExtraSprites5 = images/ships/shpforsh/SHOT_ER_PRIMARY0006_BMP.bmp
+ExtraSprites6 = images/ships/shpforsh/SHOT_ER_PRIMARY0007_BMP.bmp
+ExtraSprites7 = images/ships/shpforsh/SHOT_ER_PRIMARY0008_BMP.bmp
+ExtraSprites8 = images/ships/shpforsh/SHOT_ER_PRIMARY0009_BMP.bmp
+ExtraSprites9 = images/ships/shpforsh/SHOT_ER_PRIMARY0010_BMP.bmp
+ExtraSprites10 = images/ships/shpforsh/SHOT_ER_PRIMARY0011_BMP.bmp
+ExtraSprites11 = images/ships/shpforsh/SHOT_ER_PRIMARY0012_BMP.bmp
+ExtraSprites12 = images/ships/shpforsh/SHOT_ER_PRIMARY0013_BMP.bmp
+ExtraSprites13 = images/ships/shpforsh/SHOT_ER_PRIMARY0014_BMP.bmp
+ExtraSprites14 = images/ships/shpforsh/SHOT_ER_PRIMARY0015_BMP.bmp
+ExtraSprites15 = images/ships/shpforsh/SHOT_ER_PRIMARY0016_BMP.bmp
+ExtraSprites16 = images/ships/shpforsh/SHOT_ER_PRIMARY0017_BMP.bmp
+ExtraSprites17 = images/ships/shpforsh/SHOT_ER_PRIMARY0018_BMP.bmp
+ExtraSprites18 = images/ships/shpforsh/SHOT_ER_PRIMARY0019_BMP.bmp
+ExtraSprites19 = images/ships/shpforsh/SHOT_ER_PRIMARY0020_BMP.bmp
+ExtraSprites20 = images/ships/shpforsh/SHOT_ER_PRIMARY0021_BMP.bmp
+ExtraSprites21 = images/ships/shpforsh/SHOT_ER_PRIMARY0022_BMP.bmp
+ExtraSprites22 = images/ships/shpforsh/SHOT_ER_PRIMARY0023_BMP.bmp
+ExtraSprites23 = images/ships/shpforsh/SHOT_ER_PRIMARY0024_BMP.bmp
+ExtraSprites24 = images/ships/shpforsh/SHOT_ER_PRIMARY0025_BMP.bmp
+ExtraSprites25 = images/ships/shpforsh/SHOT_ER_PRIMARY0026_BMP.bmp
+ExtraSprites26 = images/ships/shpforsh/SHOT_ER_PRIMARY0027_BMP.bmp
+ExtraSprites27 = images/ships/shpforsh/SHOT_ER_PRIMARY0028_BMP.bmp
+ExtraSprites28 = images/ships/shpforsh/SHOT_ER_PRIMARY0029_BMP.bmp
+ExtraSprites29 = images/ships/shpforsh/SHOT_ER_PRIMARY0030_BMP.bmp
+ExtraSprites30 = images/ships/shpforsh/SHOT_ER_PRIMARY0031_BMP.bmp
+ExtraSprites31 = images/ships/shpforsh/SHOT_ER_PRIMARY0032_BMP.bmp
+
+ExtraExplosion0 = images/ships/shpforsh/SHOT_FR_LIGHTNING0000_BMP.bmp
+ExtraExplosion1 = images/ships/shpforsh/SHOT_FR_LIGHTNING0001_BMP.bmp
+ExtraExplosion2 = images/ships/shpforsh/SHOT_FR_LIGHTNING0002_BMP.bmp
+ExtraExplosion3 = images/ships/shpforsh/SHOT_FR_LIGHTNING0003_BMP.bmp
+ExtraExplosion4 = images/ships/shpforsh/SHOT_FR_LIGHTNING0004_BMP.bmp
+ExtraExplosion5 = images/ships/shpforsh/SHOT_FR_LIGHTNING0005_BMP.bmp
+ExtraExplosion6 = images/ships/shpforsh/SHOT_FR_LIGHTNING0006_BMP.bmp
+ExtraExplosion7 = images/ships/shpforsh/SHOT_FR_LIGHTNING0007_BMP.bmp
+ExtraExplosion8 = images/ships/shpforsh/SHOT_FR_LIGHTNING0008_BMP.bmp
+ExtraExplosion9 = images/ships/shpforsh/SHOT_FR_LIGHTNING0009_BMP.bmp
+ExtraExplosion10 = images/ships/shpforsh/SHOT_FR_LIGHTNING0010_BMP.bmp
+ExtraExplosion11 = images/ships/shpforsh/SHOT_FR_LIGHTNING0011_BMP.bmp
+ExtraExplosion12 = images/ships/shpforsh/SHOT_FR_LIGHTNING0012_BMP.bmp
+ExtraExplosion13 = images/ships/shpforsh/SHOT_FR_LIGHTNING0013_BMP.bmp
+ExtraExplosion14 = images/ships/shpforsh/SHOT_FR_LIGHTNING0014_BMP.bmp
+ExtraExplosion15 = images/ships/shpforsh/SHOT_FR_LIGHTNING0015_BMP.bmp
+ExtraExplosion16 = images/ships/shpforsh/SHOT_FR_LIGHTNING0016_BMP.bmp
+ExtraExplosion17 = images/ships/shpforsh/SHOT_FR_LIGHTNING0017_BMP.bmp
+ExtraExplosion18 = images/ships/shpforsh/SHOT_FR_LIGHTNING0018_BMP.bmp
+ExtraExplosion19 = images/ships/shpforsh/SHOT_FR_LIGHTNING0019_BMP.bmp
+ExtraExplosion20 = images/ships/shpforsh/SHOT_FR_LIGHTNING0020_BMP.bmp
+ExtraExplosion21 = images/ships/shpforsh/SHOT_FR_LIGHTNING0021_BMP.bmp
+ExtraExplosion22 = images/ships/shpforsh/SHOT_FR_LIGHTNING0022_BMP.bmp
+ExtraExplosion23 = images/ships/shpforsh/SHOT_FR_LIGHTNING0023_BMP.bmp
+ExtraExplosion24 = images/ships/shpforsh/SHOT_FR_LIGHTNING0024_BMP.bmp
+ExtraExplosion25 = images/ships/shpforsh/SHOT_FR_LIGHTNING0025_BMP.bmp
+ExtraExplosion26 = images/ships/shpforsh/SHOT_FR_LIGHTNING0026_BMP.bmp
+ExtraExplosion27 = images/ships/shpforsh/SHOT_FR_LIGHTNING0027_BMP.bmp
+ExtraExplosion28 = images/ships/shpforsh/SHOT_FR_LIGHTNING0028_BMP.bmp
+ExtraExplosion29 = images/ships/shpforsh/SHOT_FR_LIGHTNING0029_BMP.bmp
+ExtraExplosion30 = images/ships/shpforsh/SHOT_FR_LIGHTNING0030_BMP.bmp
+ExtraExplosion31 = images/ships/shpforsh/SHOT_FR_LIGHTNING0031_BMP.bmp
+              

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpgarty.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpgarty.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpgarty.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -6,6 +6,7 @@
 Original = Idea = Kwon
 Coders = Tamaraw
 Code = GarashTyrant
+Version = 65M
 
 [Ship]
 Crew = 42
@@ -62,3 +63,61 @@
 CaptName4 = Hordrosk
 CaptName5 = Ghelgor
 CaptName6 = R'dalkrorth
+
+[Music]
+Victory = music/ditty/cheditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpgarty/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpgarty/WAVE_B01_WAV.wav
+
+ExtraSample0 = sound/ships/shpgarty/WAVE_C01_WAV.wav
+ExtraSample0 = sound/ships/shpgarty/WAVE_C02_WAV.wav
+ExtraSample0 = sound/ships/shpgarty/WAVE_C03_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 3r
+WeaponSamples = 1
+WeaponExplosion = 7
+SpecialSprites = 7
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 1r
+ExtraSamples = 3
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpgarty/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpgarty/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpgarty/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpgarty/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpgarty/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpgarty/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpgarty/SHIP_P06_PCX.bmp
+
+ShipSprites0 = images/ships/shpgarty/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpgarty/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shpgarty/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shpgarty/SHOT_A03_PCX.bmp
+
+WeaponExplosion0 = images/ships/shpgarty/SHOT_B01_PCX.bmp
+WeaponExplosion1 = images/ships/shpgarty/SHOT_B02_PCX.bmp
+WeaponExplosion2 = images/ships/shpgarty/SHOT_B03_PCX.bmp
+WeaponExplosion3 = images/ships/shpgarty/SHOT_B04_PCX.bmp
+WeaponExplosion4 = images/ships/shpgarty/SHOT_B05_PCX.bmp
+WeaponExplosion5 = images/ships/shpgarty/SHOT_B06_PCX.bmp
+WeaponExplosion6 = images/ships/shpgarty/SHOT_B07_PCX.bmp
+
+SpecialSprites0 = images/ships/shpgarty/SHOT_C01_PCX.bmp
+SpecialSprites1 = images/ships/shpgarty/SHOT_C02_PCX.bmp
+SpecialSprites2 = images/ships/shpgarty/SHOT_C03_PCX.bmp
+SpecialSprites3 = images/ships/shpgarty/SHOT_C04_PCX.bmp
+SpecialSprites4 = images/ships/shpgarty/SHOT_C05_PCX.bmp
+SpecialSprites5 = images/ships/shpgarty/SHOT_C06_PCX.bmp
+SpecialSprites6 = images/ships/shpgarty/SHOT_C07_PCX.bmp
+
+ExtraSprites0 = images/ships/shpgarty/SHOT_D01_PCX.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpilwav.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpilwav.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpilwav.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = IlwrathAvenger
+Version = 65M
 
 [Ship]
 Crew = 22
@@ -54,3 +55,89 @@
 CaptName14 = Lurgo
 CaptName15 = Regorjo
 CaptName16 = Manglor
+
+[Music]
+Victory = music/ditty/ilwditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpilwav/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpilwav/WAVE_B01_WAV.wav
+SpecialSample1 = sound/ships/shpilwav/WAVE_B02_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 50
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 0
+SpecialSamples = 2
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpilwav/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpilwav/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpilwav/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpilwav/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpilwav/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpilwav/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpilwav/SHIP_P06_PCX.bmp
+
+ShipSprites0 = images/ships/shpilwav/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpilwav/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shpilwav/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shpilwav/SHOT_A03_PCX.bmp
+WeaponSprites3 = images/ships/shpilwav/SHOT_A04_PCX.bmp
+WeaponSprites4 = images/ships/shpilwav/SHOT_A05_PCX.bmp
+WeaponSprites5 = images/ships/shpilwav/SHOT_A06_PCX.bmp
+WeaponSprites6 = images/ships/shpilwav/SHOT_A07_PCX.bmp
+WeaponSprites7 = images/ships/shpilwav/SHOT_A08_PCX.bmp
+WeaponSprites8 = images/ships/shpilwav/SHOT_A09_PCX.bmp
+WeaponSprites9 = images/ships/shpilwav/SHOT_A10_PCX.bmp
+WeaponSprites10 = images/ships/shpilwav/SHOT_A11_PCX.bmp
+WeaponSprites11 = images/ships/shpilwav/SHOT_A12_PCX.bmp
+WeaponSprites12 = images/ships/shpilwav/SHOT_A13_PCX.bmp
+WeaponSprites13 = images/ships/shpilwav/SHOT_A14_PCX.bmp
+WeaponSprites14 = images/ships/shpilwav/SHOT_A15_PCX.bmp
+WeaponSprites15 = images/ships/shpilwav/SHOT_A16_PCX.bmp
+WeaponSprites16 = images/ships/shpilwav/SHOT_A17_PCX.bmp
+WeaponSprites17 = images/ships/shpilwav/SHOT_A18_PCX.bmp
+WeaponSprites18 = images/ships/shpilwav/SHOT_A19_PCX.bmp
+WeaponSprites19 = images/ships/shpilwav/SHOT_A20_PCX.bmp
+WeaponSprites20 = images/ships/shpilwav/SHOT_A21_PCX.bmp
+WeaponSprites21 = images/ships/shpilwav/SHOT_A22_PCX.bmp
+WeaponSprites22 = images/ships/shpilwav/SHOT_A23_PCX.bmp
+WeaponSprites23 = images/ships/shpilwav/SHOT_A24_PCX.bmp
+WeaponSprites24 = images/ships/shpilwav/SHOT_A25_PCX.bmp
+WeaponSprites25 = images/ships/shpilwav/SHOT_A26_PCX.bmp
+WeaponSprites26 = images/ships/shpilwav/SHOT_A27_PCX.bmp
+WeaponSprites27 = images/ships/shpilwav/SHOT_A28_PCX.bmp
+WeaponSprites28 = images/ships/shpilwav/SHOT_A29_PCX.bmp
+WeaponSprites29 = images/ships/shpilwav/SHOT_A30_PCX.bmp
+WeaponSprites30 = images/ships/shpilwav/SHOT_A31_PCX.bmp
+WeaponSprites31 = images/ships/shpilwav/SHOT_A32_PCX.bmp
+WeaponSprites32 = images/ships/shpilwav/SHOT_A33_PCX.bmp
+WeaponSprites33 = images/ships/shpilwav/SHOT_A34_PCX.bmp
+WeaponSprites34 = images/ships/shpilwav/SHOT_A35_PCX.bmp
+WeaponSprites35 = images/ships/shpilwav/SHOT_A36_PCX.bmp
+WeaponSprites36 = images/ships/shpilwav/SHOT_A37_PCX.bmp
+WeaponSprites37 = images/ships/shpilwav/SHOT_A38_PCX.bmp
+WeaponSprites38 = images/ships/shpilwav/SHOT_A39_PCX.bmp
+WeaponSprites39 = images/ships/shpilwav/SHOT_A40_PCX.bmp
+WeaponSprites40 = images/ships/shpilwav/SHOT_A41_PCX.bmp
+WeaponSprites41 = images/ships/shpilwav/SHOT_A42_PCX.bmp
+WeaponSprites42 = images/ships/shpilwav/SHOT_A43_PCX.bmp
+WeaponSprites43 = images/ships/shpilwav/SHOT_A44_PCX.bmp
+WeaponSprites44 = images/ships/shpilwav/SHOT_A45_PCX.bmp
+WeaponSprites45 = images/ships/shpilwav/SHOT_A46_PCX.bmp
+WeaponSprites46 = images/ships/shpilwav/SHOT_A47_PCX.bmp
+WeaponSprites47 = images/ships/shpilwav/SHOT_A48_PCX.bmp
+WeaponSprites48 = images/ships/shpilwav/SHOT_A49_PCX.bmp
+WeaponSprites49 = images/ships/shpilwav/SHOT_A50_PCX.bmp
+                                              
+

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpilwsp.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpilwsp.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpilwsp.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -8,6 +8,7 @@
 Gfx = Forevian
 Ditty = Forevian
 Code = IlwrathSpider
+Version = 65M
 
 [Ship]
 Crew = 22
@@ -45,3 +46,103 @@
 Weapon = Precedence
 Weapon_Range = 5
 Special = Mine
+
+[Music]
+Victory = music/ditty/ilwditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpilwsp/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpilwsp/WAVE_B01_WAV.wav
+
+ExtraSample0 = sound/ships/shpilwsp/WAVE_C01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 10
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 32
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 20
+ExtraSamples = 1
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpilwsp/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpilwsp/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpilwsp/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpilwsp/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpilwsp/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpilwsp/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpilwsp/SHIP_P06_PCX.bmp
+
+ShipSprites0 = images/ships/shpilwsp/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpilwsp/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shpilwsp/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shpilwsp/SHOT_A03_PCX.bmp
+WeaponSprites3 = images/ships/shpilwsp/SHOT_A04_PCX.bmp
+WeaponSprites4 = images/ships/shpilwsp/SHOT_A05_PCX.bmp
+WeaponSprites5 = images/ships/shpilwsp/SHOT_A06_PCX.bmp
+WeaponSprites6 = images/ships/shpilwsp/SHOT_A07_PCX.bmp
+WeaponSprites7 = images/ships/shpilwsp/SHOT_A08_PCX.bmp
+WeaponSprites8 = images/ships/shpilwsp/SHOT_A09_PCX.bmp
+WeaponSprites9 = images/ships/shpilwsp/SHOT_A10_PCX.bmp
+                                              
+SpecialSprites0 = images/ships/shpilwsp/SHOT_B01_PCX.bmp
+SpecialSprites1 = images/ships/shpilwsp/SHOT_B02_PCX.bmp
+SpecialSprites2 = images/ships/shpilwsp/SHOT_B03_PCX.bmp
+SpecialSprites3 = images/ships/shpilwsp/SHOT_B04_PCX.bmp
+SpecialSprites4 = images/ships/shpilwsp/SHOT_B05_PCX.bmp
+SpecialSprites5 = images/ships/shpilwsp/SHOT_B06_PCX.bmp
+SpecialSprites6 = images/ships/shpilwsp/SHOT_B07_PCX.bmp
+SpecialSprites7 = images/ships/shpilwsp/SHOT_B08_PCX.bmp
+SpecialSprites8 = images/ships/shpilwsp/SHOT_B09_PCX.bmp
+SpecialSprites9 = images/ships/shpilwsp/SHOT_B10_PCX.bmp
+SpecialSprites10 = images/ships/shpilwsp/SHOT_B11_PCX.bmp
+SpecialSprites11 = images/ships/shpilwsp/SHOT_B12_PCX.bmp
+SpecialSprites12 = images/ships/shpilwsp/SHOT_B13_PCX.bmp
+SpecialSprites13 = images/ships/shpilwsp/SHOT_B14_PCX.bmp
+SpecialSprites14 = images/ships/shpilwsp/SHOT_B15_PCX.bmp
+SpecialSprites15 = images/ships/shpilwsp/SHOT_B16_PCX.bmp
+SpecialSprites16 = images/ships/shpilwsp/SHOT_B17_PCX.bmp
+SpecialSprites17 = images/ships/shpilwsp/SHOT_B18_PCX.bmp
+SpecialSprites18 = images/ships/shpilwsp/SHOT_B19_PCX.bmp
+SpecialSprites19 = images/ships/shpilwsp/SHOT_B20_PCX.bmp
+SpecialSprites20 = images/ships/shpilwsp/SHOT_B21_PCX.bmp
+SpecialSprites21 = images/ships/shpilwsp/SHOT_B22_PCX.bmp
+SpecialSprites22 = images/ships/shpilwsp/SHOT_B23_PCX.bmp
+SpecialSprites23 = images/ships/shpilwsp/SHOT_B24_PCX.bmp
+SpecialSprites24 = images/ships/shpilwsp/SHOT_B25_PCX.bmp
+SpecialSprites25 = images/ships/shpilwsp/SHOT_B26_PCX.bmp
+SpecialSprites26 = images/ships/shpilwsp/SHOT_B27_PCX.bmp
+SpecialSprites27 = images/ships/shpilwsp/SHOT_B28_PCX.bmp
+SpecialSprites28 = images/ships/shpilwsp/SHOT_B29_PCX.bmp
+SpecialSprites29 = images/ships/shpilwsp/SHOT_B30_PCX.bmp
+SpecialSprites30 = images/ships/shpilwsp/SHOT_B31_PCX.bmp
+SpecialSprites31 = images/ships/shpilwsp/SHOT_B32_PCX.bmp
+
+ExtraSprites0 = images/ships/shpilwsp/SHOT_C01_PCX.bmp
+ExtraSprites1 = images/ships/shpilwsp/SHOT_C02_PCX.bmp
+ExtraSprites2 = images/ships/shpilwsp/SHOT_C03_PCX.bmp
+ExtraSprites3 = images/ships/shpilwsp/SHOT_C04_PCX.bmp
+ExtraSprites4 = images/ships/shpilwsp/SHOT_C05_PCX.bmp
+ExtraSprites5 = images/ships/shpilwsp/SHOT_C06_PCX.bmp
+ExtraSprites6 = images/ships/shpilwsp/SHOT_C07_PCX.bmp
+ExtraSprites7 = images/ships/shpilwsp/SHOT_C08_PCX.bmp
+ExtraSprites8 = images/ships/shpilwsp/SHOT_C09_PCX.bmp
+ExtraSprites9 = images/ships/shpilwsp/SHOT_C10_PCX.bmp
+ExtraSprites10 = images/ships/shpilwsp/SHOT_C11_PCX.bmp
+ExtraSprites11 = images/ships/shpilwsp/SHOT_C12_PCX.bmp
+ExtraSprites12 = images/ships/shpilwsp/SHOT_C13_PCX.bmp
+ExtraSprites13 = images/ships/shpilwsp/SHOT_C14_PCX.bmp
+ExtraSprites14 = images/ships/shpilwsp/SHOT_C15_PCX.bmp
+ExtraSprites15 = images/ships/shpilwsp/SHOT_C16_PCX.bmp
+ExtraSprites16 = images/ships/shpilwsp/SHOT_C17_PCX.bmp
+ExtraSprites17 = images/ships/shpilwsp/SHOT_C18_PCX.bmp
+ExtraSprites18 = images/ships/shpilwsp/SHOT_C19_PCX.bmp
+ExtraSprites19 = images/ships/shpilwsp/SHOT_C20_PCX.bmp
+

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpkahbo.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpkahbo.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpkahbo.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -5,6 +5,7 @@
 Origin = TW
 Coders = Launchpad
 Code = KahrBoomerang
+Version = 65M
 
 [Ship]
 Crew = 18
@@ -82,3 +83,44 @@
 BattRecharge = 2
 
 
+[Music]
+Victory = music/ditty/ilwditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpkahbo/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpkahbo/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 1r
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 1r
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 10
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpkahbo/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpkahbo/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpkahbo/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpkahbo/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpkahbo/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpkahbo/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpkahbo/SHIP_P06_PCX.bmp
+PanelBitmaps7 = images/ships/shpkahbo/SHIP_P07_PCX.bmp
+PanelBitmaps8 = images/ships/shpkahbo/SHIP_P08_PCX.bmp
+PanelBitmaps9 = images/ships/shpkahbo/SHIP_P09_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpkahbo/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpkahbo/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpkahbo/SHOT_B01_PCX.bmp
+
+ExtraSprites0 = images/ships/shpkahbo/SHOT_C01_PCX.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpkohma.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpkohma.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpkohma.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = KohrAhMarauder
+Version = 65M
 
 [Ship]
 Crew = 42
@@ -65,3 +66,90 @@
 CaptName14 = Death 47
 CaptName15 = Death 53
 CaptName16 = Death 83
+
+[Music]
+Victory = music/ditty/bladitty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpkohma/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpkohma/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 10
+WeaponSamples = 1
+WeaponExplosion = 20
+SpecialSprites = 20 +alpha
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpkohma/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpkohma/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpkohma/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpkohma/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpkohma/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpkohma/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpkohma/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpkohma/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpkohma/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shpkohma/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shpkohma/SHOT_A03_PCX.bmp
+WeaponSprites3 = images/ships/shpkohma/SHOT_A04_PCX.bmp
+WeaponSprites4 = images/ships/shpkohma/SHOT_A05_PCX.bmp
+WeaponSprites5 = images/ships/shpkohma/SHOT_A06_PCX.bmp
+WeaponSprites6 = images/ships/shpkohma/SHOT_A07_PCX.bmp
+WeaponSprites7 = images/ships/shpkohma/SHOT_A08_PCX.bmp
+WeaponSprites8 = images/ships/shpkohma/SHOT_A09_PCX.bmp
+WeaponSprites9 = images/ships/shpkohma/SHOT_A10_PCX.bmp
+
+                   
+WeaponExplosion0 = images/ships/shpkohma/SHOT_B01_PCX.bmp
+WeaponExplosion1 = images/ships/shpkohma/SHOT_B02_PCX.bmp
+WeaponExplosion2 = images/ships/shpkohma/SHOT_B03_PCX.bmp
+WeaponExplosion3 = images/ships/shpkohma/SHOT_B04_PCX.bmp
+WeaponExplosion4 = images/ships/shpkohma/SHOT_B05_PCX.bmp
+WeaponExplosion5 = images/ships/shpkohma/SHOT_B06_PCX.bmp
+WeaponExplosion6 = images/ships/shpkohma/SHOT_B07_PCX.bmp
+WeaponExplosion7 = images/ships/shpkohma/SHOT_B08_PCX.bmp
+WeaponExplosion8 = images/ships/shpkohma/SHOT_B09_PCX.bmp
+WeaponExplosion9 = images/ships/shpkohma/SHOT_B10_PCX.bmp
+WeaponExplosion10 = images/ships/shpkohma/SHOT_B11_PCX.bmp
+WeaponExplosion11 = images/ships/shpkohma/SHOT_B12_PCX.bmp
+WeaponExplosion12 = images/ships/shpkohma/SHOT_B13_PCX.bmp
+WeaponExplosion13 = images/ships/shpkohma/SHOT_B14_PCX.bmp
+WeaponExplosion14 = images/ships/shpkohma/SHOT_B15_PCX.bmp
+WeaponExplosion15 = images/ships/shpkohma/SHOT_B16_PCX.bmp
+WeaponExplosion16 = images/ships/shpkohma/SHOT_B17_PCX.bmp
+WeaponExplosion17 = images/ships/shpkohma/SHOT_B18_PCX.bmp
+WeaponExplosion18 = images/ships/shpkohma/SHOT_B19_PCX.bmp
+WeaponExplosion19 = images/ships/shpkohma/SHOT_B20_PCX.bmp
+
+SpecialSprites0 = images/ships/shpkohma/SHOT_C01_PCX.bmp
+SpecialSprites1 = images/ships/shpkohma/SHOT_C02_PCX.bmp
+SpecialSprites2 = images/ships/shpkohma/SHOT_C03_PCX.bmp
+SpecialSprites3 = images/ships/shpkohma/SHOT_C04_PCX.bmp
+SpecialSprites4 = images/ships/shpkohma/SHOT_C05_PCX.bmp
+SpecialSprites5 = images/ships/shpkohma/SHOT_C06_PCX.bmp
+SpecialSprites6 = images/ships/shpkohma/SHOT_C07_PCX.bmp
+SpecialSprites7 = images/ships/shpkohma/SHOT_C08_PCX.bmp
+SpecialSprites8 = images/ships/shpkohma/SHOT_C09_PCX.bmp
+SpecialSprites9 = images/ships/shpkohma/SHOT_C10_PCX.bmp
+SpecialSprites10 = images/ships/shpkohma/SHOT_C11_PCX.bmp
+SpecialSprites11 = images/ships/shpkohma/SHOT_C12_PCX.bmp
+SpecialSprites12 = images/ships/shpkohma/SHOT_C13_PCX.bmp
+SpecialSprites13 = images/ships/shpkohma/SHOT_C14_PCX.bmp
+SpecialSprites14 = images/ships/shpkohma/SHOT_C15_PCX.bmp
+SpecialSprites15 = images/ships/shpkohma/SHOT_C16_PCX.bmp
+SpecialSprites16 = images/ships/shpkohma/SHOT_C17_PCX.bmp
+SpecialSprites17 = images/ships/shpkohma/SHOT_C18_PCX.bmp
+SpecialSprites18 = images/ships/shpkohma/SHOT_C19_PCX.bmp
+SpecialSprites19 = images/ships/shpkohma/SHOT_C20_PCX.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpkzedr.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpkzedr.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpkzedr.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -8,6 +8,7 @@
 Origin = UQM
 Coders = The Fly
 Code = KzerZaDreadnought
+Version = 65M
 
 [Ship]
 Crew = 42
@@ -61,3 +62,65 @@
 CaptName14 = Lord 783
 CaptName15 = Lord 52
 CaptName16 = Lord 21
+
+[Music]
+Victory = music/ditty/urqditty.mod
+
+
+[Sound]
+WeaponSample0 = sound/ships/shpkzedr/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpkzedr/WAVE_B01_WAV.wav
+
+ExtraSample0 = sound/ships/shpkzedr/WAVE_C01_WAV.wav
+ExtraSample1 = sound/ships/shpkzedr/WAVE_C02_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 20 +alpha
+SpecialSprites = 1r
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 2
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpkzedr/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpkzedr/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpkzedr/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpkzedr/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpkzedr/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpkzedr/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpkzedr/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpkzedr/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpkzedr/SHOT_A01_PCX.bmp
+
+WeaponExplosion0 = images/ships/shpkzedr/SHOT_B01_PCX.bmp
+WeaponExplosion1 = images/ships/shpkzedr/SHOT_B02_PCX.bmp
+WeaponExplosion2 = images/ships/shpkzedr/SHOT_B03_PCX.bmp
+WeaponExplosion3 = images/ships/shpkzedr/SHOT_B04_PCX.bmp
+WeaponExplosion4 = images/ships/shpkzedr/SHOT_B05_PCX.bmp
+WeaponExplosion5 = images/ships/shpkzedr/SHOT_B06_PCX.bmp
+WeaponExplosion6 = images/ships/shpkzedr/SHOT_B07_PCX.bmp
+WeaponExplosion7 = images/ships/shpkzedr/SHOT_B08_PCX.bmp
+WeaponExplosion8 = images/ships/shpkzedr/SHOT_B09_PCX.bmp
+WeaponExplosion9 = images/ships/shpkzedr/SHOT_B10_PCX.bmp
+WeaponExplosion10 = images/ships/shpkzedr/SHOT_B11_PCX.bmp
+WeaponExplosion11 = images/ships/shpkzedr/SHOT_B12_PCX.bmp
+WeaponExplosion12 = images/ships/shpkzedr/SHOT_B13_PCX.bmp
+WeaponExplosion13 = images/ships/shpkzedr/SHOT_B14_PCX.bmp
+WeaponExplosion14 = images/ships/shpkzedr/SHOT_B15_PCX.bmp
+WeaponExplosion15 = images/ships/shpkzedr/SHOT_B16_PCX.bmp
+WeaponExplosion16 = images/ships/shpkzedr/SHOT_B17_PCX.bmp
+WeaponExplosion17 = images/ships/shpkzedr/SHOT_B18_PCX.bmp
+WeaponExplosion18 = images/ships/shpkzedr/SHOT_B19_PCX.bmp
+WeaponExplosion19 = images/ships/shpkzedr/SHOT_B20_PCX.bmp
+
+SpecialSprites0 = images/ships/shpkzedr/SHOT_C01_PCX.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpmeltr.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpmeltr.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpmeltr.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -6,6 +6,7 @@
 Origin = UQM
 Coders = The Fly
 Code = MelnormeTrader
+Version = 65M
 
 [Ship]
 Crew = 20
@@ -65,3 +66,202 @@
 CaptName14 = Black
 CaptName15 = Bluish
 CaptName16 = Purple
+
+[Music]
+Victory = music/ditty/melditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpmeltr/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpmeltr/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 40 +alpha
+WeaponSamples = 1
+WeaponExplosion = 80 +alpha
+SpecialSprites = 20 +alpha
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 20
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpmeltr/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpmeltr/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpmeltr/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpmeltr/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpmeltr/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpmeltr/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpmeltr/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpmeltr/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpmeltr/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shpmeltr/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shpmeltr/SHOT_A03_PCX.bmp
+WeaponSprites3 = images/ships/shpmeltr/SHOT_A04_PCX.bmp
+WeaponSprites4 = images/ships/shpmeltr/SHOT_A05_PCX.bmp
+WeaponSprites5 = images/ships/shpmeltr/SHOT_A06_PCX.bmp
+WeaponSprites6 = images/ships/shpmeltr/SHOT_A07_PCX.bmp
+WeaponSprites7 = images/ships/shpmeltr/SHOT_A08_PCX.bmp
+WeaponSprites8 = images/ships/shpmeltr/SHOT_A09_PCX.bmp
+WeaponSprites9 = images/ships/shpmeltr/SHOT_A10_PCX.bmp
+WeaponSprites10 = images/ships/shpmeltr/SHOT_B01_PCX.bmp
+WeaponSprites11 = images/ships/shpmeltr/SHOT_B02_PCX.bmp
+WeaponSprites12 = images/ships/shpmeltr/SHOT_B03_PCX.bmp
+WeaponSprites13 = images/ships/shpmeltr/SHOT_B04_PCX.bmp
+WeaponSprites14 = images/ships/shpmeltr/SHOT_B05_PCX.bmp
+WeaponSprites15 = images/ships/shpmeltr/SHOT_B06_PCX.bmp
+WeaponSprites16 = images/ships/shpmeltr/SHOT_B07_PCX.bmp
+WeaponSprites17 = images/ships/shpmeltr/SHOT_B08_PCX.bmp
+WeaponSprites18 = images/ships/shpmeltr/SHOT_B09_PCX.bmp
+WeaponSprites19 = images/ships/shpmeltr/SHOT_B10_PCX.bmp
+WeaponSprites20 = images/ships/shpmeltr/SHOT_C01_PCX.bmp
+WeaponSprites21 = images/ships/shpmeltr/SHOT_C02_PCX.bmp
+WeaponSprites22 = images/ships/shpmeltr/SHOT_C03_PCX.bmp
+WeaponSprites23 = images/ships/shpmeltr/SHOT_C04_PCX.bmp
+WeaponSprites24 = images/ships/shpmeltr/SHOT_C05_PCX.bmp
+WeaponSprites25 = images/ships/shpmeltr/SHOT_C06_PCX.bmp
+WeaponSprites26 = images/ships/shpmeltr/SHOT_C07_PCX.bmp
+WeaponSprites27 = images/ships/shpmeltr/SHOT_C08_PCX.bmp
+WeaponSprites28 = images/ships/shpmeltr/SHOT_C09_PCX.bmp
+WeaponSprites29 = images/ships/shpmeltr/SHOT_C10_PCX.bmp
+WeaponSprites30 = images/ships/shpmeltr/SHOT_D01_PCX.bmp
+WeaponSprites31 = images/ships/shpmeltr/SHOT_D02_PCX.bmp
+WeaponSprites32 = images/ships/shpmeltr/SHOT_D03_PCX.bmp
+WeaponSprites33 = images/ships/shpmeltr/SHOT_D04_PCX.bmp
+WeaponSprites34 = images/ships/shpmeltr/SHOT_D05_PCX.bmp
+WeaponSprites35 = images/ships/shpmeltr/SHOT_D06_PCX.bmp
+WeaponSprites36 = images/ships/shpmeltr/SHOT_D07_PCX.bmp
+WeaponSprites37 = images/ships/shpmeltr/SHOT_D08_PCX.bmp
+WeaponSprites38 = images/ships/shpmeltr/SHOT_D09_PCX.bmp
+WeaponSprites39 = images/ships/shpmeltr/SHOT_D10_PCX.bmp
+
+
+
+WeaponExplosion0 = images/ships/shpmeltr/SHOT_E01_PCX.bmp
+WeaponExplosion1 = images/ships/shpmeltr/SHOT_E02_PCX.bmp
+WeaponExplosion2 = images/ships/shpmeltr/SHOT_E03_PCX.bmp
+WeaponExplosion3 = images/ships/shpmeltr/SHOT_E04_PCX.bmp
+WeaponExplosion4 = images/ships/shpmeltr/SHOT_E05_PCX.bmp
+WeaponExplosion5 = images/ships/shpmeltr/SHOT_E06_PCX.bmp
+WeaponExplosion6 = images/ships/shpmeltr/SHOT_E07_PCX.bmp
+WeaponExplosion7 = images/ships/shpmeltr/SHOT_E08_PCX.bmp
+WeaponExplosion8 = images/ships/shpmeltr/SHOT_E09_PCX.bmp
+WeaponExplosion9 = images/ships/shpmeltr/SHOT_E10_PCX.bmp
+WeaponExplosion10 = images/ships/shpmeltr/SHOT_E11_PCX.bmp
+WeaponExplosion11 = images/ships/shpmeltr/SHOT_E12_PCX.bmp
+WeaponExplosion12 = images/ships/shpmeltr/SHOT_E13_PCX.bmp
+WeaponExplosion13 = images/ships/shpmeltr/SHOT_E14_PCX.bmp
+WeaponExplosion14 = images/ships/shpmeltr/SHOT_E15_PCX.bmp
+WeaponExplosion15 = images/ships/shpmeltr/SHOT_E16_PCX.bmp
+WeaponExplosion16 = images/ships/shpmeltr/SHOT_E17_PCX.bmp
+WeaponExplosion17 = images/ships/shpmeltr/SHOT_E18_PCX.bmp
+WeaponExplosion18 = images/ships/shpmeltr/SHOT_E19_PCX.bmp
+WeaponExplosion19 = images/ships/shpmeltr/SHOT_E20_PCX.bmp
+WeaponExplosion20 = images/ships/shpmeltr/SHOT_F01_PCX.bmp
+WeaponExplosion21 = images/ships/shpmeltr/SHOT_F02_PCX.bmp
+WeaponExplosion22 = images/ships/shpmeltr/SHOT_F03_PCX.bmp
+WeaponExplosion23 = images/ships/shpmeltr/SHOT_F04_PCX.bmp
+WeaponExplosion24 = images/ships/shpmeltr/SHOT_F05_PCX.bmp
+WeaponExplosion25 = images/ships/shpmeltr/SHOT_F06_PCX.bmp
+WeaponExplosion26 = images/ships/shpmeltr/SHOT_F07_PCX.bmp
+WeaponExplosion27 = images/ships/shpmeltr/SHOT_F08_PCX.bmp
+WeaponExplosion28 = images/ships/shpmeltr/SHOT_F09_PCX.bmp
+WeaponExplosion29 = images/ships/shpmeltr/SHOT_F10_PCX.bmp
+WeaponExplosion30 = images/ships/shpmeltr/SHOT_F11_PCX.bmp
+WeaponExplosion31 = images/ships/shpmeltr/SHOT_F12_PCX.bmp
+WeaponExplosion32 = images/ships/shpmeltr/SHOT_F13_PCX.bmp
+WeaponExplosion33 = images/ships/shpmeltr/SHOT_F14_PCX.bmp
+WeaponExplosion34 = images/ships/shpmeltr/SHOT_F15_PCX.bmp
+WeaponExplosion35 = images/ships/shpmeltr/SHOT_F16_PCX.bmp
+WeaponExplosion36 = images/ships/shpmeltr/SHOT_F17_PCX.bmp
+WeaponExplosion37 = images/ships/shpmeltr/SHOT_F18_PCX.bmp
+WeaponExplosion38 = images/ships/shpmeltr/SHOT_F19_PCX.bmp
+WeaponExplosion39 = images/ships/shpmeltr/SHOT_F20_PCX.bmp
+WeaponExplosion40 = images/ships/shpmeltr/SHOT_G01_PCX.bmp
+WeaponExplosion41 = images/ships/shpmeltr/SHOT_G02_PCX.bmp
+WeaponExplosion42 = images/ships/shpmeltr/SHOT_G03_PCX.bmp
+WeaponExplosion43 = images/ships/shpmeltr/SHOT_G04_PCX.bmp
+WeaponExplosion44 = images/ships/shpmeltr/SHOT_G05_PCX.bmp
+WeaponExplosion45 = images/ships/shpmeltr/SHOT_G06_PCX.bmp
+WeaponExplosion46 = images/ships/shpmeltr/SHOT_G07_PCX.bmp
+WeaponExplosion47 = images/ships/shpmeltr/SHOT_G08_PCX.bmp
+WeaponExplosion48 = images/ships/shpmeltr/SHOT_G09_PCX.bmp
+WeaponExplosion49 = images/ships/shpmeltr/SHOT_G10_PCX.bmp
+WeaponExplosion50 = images/ships/shpmeltr/SHOT_G11_PCX.bmp
+WeaponExplosion51 = images/ships/shpmeltr/SHOT_G12_PCX.bmp
+WeaponExplosion52 = images/ships/shpmeltr/SHOT_G13_PCX.bmp
+WeaponExplosion53 = images/ships/shpmeltr/SHOT_G14_PCX.bmp
+WeaponExplosion54 = images/ships/shpmeltr/SHOT_G15_PCX.bmp
+WeaponExplosion55 = images/ships/shpmeltr/SHOT_G16_PCX.bmp
+WeaponExplosion56 = images/ships/shpmeltr/SHOT_G17_PCX.bmp
+WeaponExplosion57 = images/ships/shpmeltr/SHOT_G18_PCX.bmp
+WeaponExplosion58 = images/ships/shpmeltr/SHOT_G19_PCX.bmp
+WeaponExplosion59 = images/ships/shpmeltr/SHOT_G20_PCX.bmp
+WeaponExplosion60 = images/ships/shpmeltr/SHOT_H01_PCX.bmp
+WeaponExplosion61 = images/ships/shpmeltr/SHOT_H02_PCX.bmp
+WeaponExplosion62 = images/ships/shpmeltr/SHOT_H03_PCX.bmp
+WeaponExplosion63 = images/ships/shpmeltr/SHOT_H04_PCX.bmp
+WeaponExplosion64 = images/ships/shpmeltr/SHOT_H05_PCX.bmp
+WeaponExplosion65 = images/ships/shpmeltr/SHOT_H06_PCX.bmp
+WeaponExplosion66 = images/ships/shpmeltr/SHOT_H07_PCX.bmp
+WeaponExplosion67 = images/ships/shpmeltr/SHOT_H08_PCX.bmp
+WeaponExplosion68 = images/ships/shpmeltr/SHOT_H09_PCX.bmp
+WeaponExplosion69 = images/ships/shpmeltr/SHOT_H10_PCX.bmp
+WeaponExplosion70 = images/ships/shpmeltr/SHOT_H11_PCX.bmp
+WeaponExplosion71 = images/ships/shpmeltr/SHOT_H12_PCX.bmp
+WeaponExplosion72 = images/ships/shpmeltr/SHOT_H13_PCX.bmp
+WeaponExplosion73 = images/ships/shpmeltr/SHOT_H14_PCX.bmp
+WeaponExplosion74 = images/ships/shpmeltr/SHOT_H15_PCX.bmp
+WeaponExplosion75 = images/ships/shpmeltr/SHOT_H16_PCX.bmp
+WeaponExplosion76 = images/ships/shpmeltr/SHOT_H17_PCX.bmp
+WeaponExplosion77 = images/ships/shpmeltr/SHOT_H18_PCX.bmp
+WeaponExplosion78 = images/ships/shpmeltr/SHOT_H19_PCX.bmp
+WeaponExplosion79 = images/ships/shpmeltr/SHOT_H20_PCX.bmp
+
+SpecialSprites0 = images/ships/shpmeltr/SHOT_I01_PCX.bmp
+SpecialSprites1 = images/ships/shpmeltr/SHOT_I02_PCX.bmp
+SpecialSprites2 = images/ships/shpmeltr/SHOT_I03_PCX.bmp
+SpecialSprites3 = images/ships/shpmeltr/SHOT_I04_PCX.bmp
+SpecialSprites4 = images/ships/shpmeltr/SHOT_I05_PCX.bmp
+SpecialSprites5 = images/ships/shpmeltr/SHOT_I06_PCX.bmp
+SpecialSprites6 = images/ships/shpmeltr/SHOT_I07_PCX.bmp
+SpecialSprites7 = images/ships/shpmeltr/SHOT_I08_PCX.bmp
+SpecialSprites8 = images/ships/shpmeltr/SHOT_I09_PCX.bmp
+SpecialSprites9 = images/ships/shpmeltr/SHOT_I10_PCX.bmp
+SpecialSprites10 = images/ships/shpmeltr/SHOT_I11_PCX.bmp
+SpecialSprites11 = images/ships/shpmeltr/SHOT_I12_PCX.bmp
+SpecialSprites12 = images/ships/shpmeltr/SHOT_I13_PCX.bmp
+SpecialSprites13 = images/ships/shpmeltr/SHOT_I14_PCX.bmp
+SpecialSprites14 = images/ships/shpmeltr/SHOT_I15_PCX.bmp
+SpecialSprites15 = images/ships/shpmeltr/SHOT_I16_PCX.bmp
+SpecialSprites16 = images/ships/shpmeltr/SHOT_I17_PCX.bmp
+SpecialSprites17 = images/ships/shpmeltr/SHOT_I18_PCX.bmp
+SpecialSprites18 = images/ships/shpmeltr/SHOT_I19_PCX.bmp
+SpecialSprites19 = images/ships/shpmeltr/SHOT_I20_PCX.bmp
+
+ExtraSprites0 = images/ships/shpmeltr/SHOT_J01_PCX.bmp
+ExtraSprites1 = images/ships/shpmeltr/SHOT_J02_PCX.bmp
+ExtraSprites2 = images/ships/shpmeltr/SHOT_J03_PCX.bmp
+ExtraSprites3 = images/ships/shpmeltr/SHOT_J04_PCX.bmp
+ExtraSprites4 = images/ships/shpmeltr/SHOT_J05_PCX.bmp
+ExtraSprites5 = images/ships/shpmeltr/SHOT_J06_PCX.bmp
+ExtraSprites6 = images/ships/shpmeltr/SHOT_J07_PCX.bmp
+ExtraSprites7 = images/ships/shpmeltr/SHOT_J08_PCX.bmp
+ExtraSprites8 = images/ships/shpmeltr/SHOT_J09_PCX.bmp
+ExtraSprites9 = images/ships/shpmeltr/SHOT_J10_PCX.bmp
+ExtraSprites10 = images/ships/shpmeltr/SHOT_J11_PCX.bmp
+ExtraSprites11 = images/ships/shpmeltr/SHOT_J12_PCX.bmp
+ExtraSprites12 = images/ships/shpmeltr/SHOT_J13_PCX.bmp
+ExtraSprites13 = images/ships/shpmeltr/SHOT_J14_PCX.bmp
+ExtraSprites14 = images/ships/shpmeltr/SHOT_J15_PCX.bmp
+ExtraSprites15 = images/ships/shpmeltr/SHOT_J16_PCX.bmp
+ExtraSprites16 = images/ships/shpmeltr/SHOT_J17_PCX.bmp
+ExtraSprites17 = images/ships/shpmeltr/SHOT_J18_PCX.bmp
+ExtraSprites18 = images/ships/shpmeltr/SHOT_J19_PCX.bmp
+ExtraSprites19 = images/ships/shpmeltr/SHOT_J20_PCX.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpmmrxf.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpmmrxf.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpmmrxf.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = MmrnmhrmXForm
+Version = 65M
 
 [Ship]
 Crew = 20
@@ -85,3 +86,41 @@
 CaptName15 = Nhuh-na
 CaptName16 = Hrnm-hm
 CaptName17 = Mnm-hmm
+
+[Music]
+Victory = music/ditty/mmrditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpmmrxf/WAVE_A01_WAV.wav
+WeaponSample1 = sound/ships/shpmmrxf/WAVE_A02_WAV.wav
+
+SpecialSample0 = sound/ships/shpmmrxf/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 2
+WeaponExplosion = 0
+SpecialSprites = 1r
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpmmrxf/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpmmrxf/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpmmrxf/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpmmrxf/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpmmrxf/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpmmrxf/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpmmrxf/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpmmrxf/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpmmrxf/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpmmrxf/SHOT_B01_PCX.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpmycpo.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpmycpo.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpmycpo.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = MyconPodship
+Version = 65M
 
 [Ship]
 Crew = 20
@@ -55,3 +56,124 @@
 CaptName14 = Yush
 CaptName15 = Zaloop
 CaptName16 = Znuff
+
+[Music]
+Victory = music/ditty/mycditty.mod
+
+
+[Sound]
+WeaponSample0 = sound/ships/shpmycpo/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpmycpo/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 64 +alpha
+WeaponSamples = 1
+WeaponExplosion = 20 +alpha
+SpecialSprites = 0
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpmycpo/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpmycpo/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpmycpo/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpmycpo/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpmycpo/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpmycpo/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpmycpo/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpmycpo/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpmycpo/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shpmycpo/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shpmycpo/SHOT_A03_PCX.bmp
+WeaponSprites3 = images/ships/shpmycpo/SHOT_A04_PCX.bmp
+WeaponSprites4 = images/ships/shpmycpo/SHOT_A05_PCX.bmp
+WeaponSprites5 = images/ships/shpmycpo/SHOT_A06_PCX.bmp
+WeaponSprites6 = images/ships/shpmycpo/SHOT_A07_PCX.bmp
+WeaponSprites7 = images/ships/shpmycpo/SHOT_A08_PCX.bmp
+WeaponSprites8 = images/ships/shpmycpo/SHOT_A09_PCX.bmp
+WeaponSprites9 = images/ships/shpmycpo/SHOT_A10_PCX.bmp
+WeaponSprites10 = images/ships/shpmycpo/SHOT_A11_PCX.bmp
+WeaponSprites11 = images/ships/shpmycpo/SHOT_A12_PCX.bmp
+WeaponSprites12 = images/ships/shpmycpo/SHOT_A13_PCX.bmp
+WeaponSprites13 = images/ships/shpmycpo/SHOT_A14_PCX.bmp
+WeaponSprites14 = images/ships/shpmycpo/SHOT_A15_PCX.bmp
+WeaponSprites15 = images/ships/shpmycpo/SHOT_A16_PCX.bmp
+WeaponSprites16 = images/ships/shpmycpo/SHOT_A17_PCX.bmp
+WeaponSprites17 = images/ships/shpmycpo/SHOT_A18_PCX.bmp
+WeaponSprites18 = images/ships/shpmycpo/SHOT_A19_PCX.bmp
+WeaponSprites19 = images/ships/shpmycpo/SHOT_A20_PCX.bmp
+WeaponSprites20 = images/ships/shpmycpo/SHOT_A21_PCX.bmp
+WeaponSprites21 = images/ships/shpmycpo/SHOT_A22_PCX.bmp
+WeaponSprites22 = images/ships/shpmycpo/SHOT_A23_PCX.bmp
+WeaponSprites23 = images/ships/shpmycpo/SHOT_A24_PCX.bmp
+WeaponSprites24 = images/ships/shpmycpo/SHOT_A25_PCX.bmp
+WeaponSprites25 = images/ships/shpmycpo/SHOT_A26_PCX.bmp
+WeaponSprites26 = images/ships/shpmycpo/SHOT_A27_PCX.bmp
+WeaponSprites27 = images/ships/shpmycpo/SHOT_A28_PCX.bmp
+WeaponSprites28 = images/ships/shpmycpo/SHOT_A29_PCX.bmp
+WeaponSprites29 = images/ships/shpmycpo/SHOT_A30_PCX.bmp
+WeaponSprites30 = images/ships/shpmycpo/SHOT_A31_PCX.bmp
+WeaponSprites31 = images/ships/shpmycpo/SHOT_A32_PCX.bmp
+WeaponSprites32 = images/ships/shpmycpo/SHOT_A33_PCX.bmp
+WeaponSprites33 = images/ships/shpmycpo/SHOT_A34_PCX.bmp
+WeaponSprites34 = images/ships/shpmycpo/SHOT_A35_PCX.bmp
+WeaponSprites35 = images/ships/shpmycpo/SHOT_A36_PCX.bmp
+WeaponSprites36 = images/ships/shpmycpo/SHOT_A37_PCX.bmp
+WeaponSprites37 = images/ships/shpmycpo/SHOT_A38_PCX.bmp
+WeaponSprites38 = images/ships/shpmycpo/SHOT_A39_PCX.bmp
+WeaponSprites39 = images/ships/shpmycpo/SHOT_A40_PCX.bmp
+WeaponSprites40 = images/ships/shpmycpo/SHOT_A41_PCX.bmp
+WeaponSprites41 = images/ships/shpmycpo/SHOT_A42_PCX.bmp
+WeaponSprites42 = images/ships/shpmycpo/SHOT_A43_PCX.bmp
+WeaponSprites43 = images/ships/shpmycpo/SHOT_A44_PCX.bmp
+WeaponSprites44 = images/ships/shpmycpo/SHOT_A45_PCX.bmp
+WeaponSprites45 = images/ships/shpmycpo/SHOT_A46_PCX.bmp
+WeaponSprites46 = images/ships/shpmycpo/SHOT_A47_PCX.bmp
+WeaponSprites47 = images/ships/shpmycpo/SHOT_A48_PCX.bmp
+WeaponSprites48 = images/ships/shpmycpo/SHOT_A49_PCX.bmp
+WeaponSprites49 = images/ships/shpmycpo/SHOT_A50_PCX.bmp
+WeaponSprites50 = images/ships/shpmycpo/SHOT_A51_PCX.bmp
+WeaponSprites51 = images/ships/shpmycpo/SHOT_A52_PCX.bmp
+WeaponSprites52 = images/ships/shpmycpo/SHOT_A53_PCX.bmp
+WeaponSprites53 = images/ships/shpmycpo/SHOT_A54_PCX.bmp
+WeaponSprites54 = images/ships/shpmycpo/SHOT_A55_PCX.bmp
+WeaponSprites55 = images/ships/shpmycpo/SHOT_A56_PCX.bmp
+WeaponSprites56 = images/ships/shpmycpo/SHOT_A57_PCX.bmp
+WeaponSprites57 = images/ships/shpmycpo/SHOT_A58_PCX.bmp
+WeaponSprites58 = images/ships/shpmycpo/SHOT_A59_PCX.bmp
+WeaponSprites59 = images/ships/shpmycpo/SHOT_A60_PCX.bmp
+WeaponSprites60 = images/ships/shpmycpo/SHOT_A61_PCX.bmp
+WeaponSprites61 = images/ships/shpmycpo/SHOT_A62_PCX.bmp
+WeaponSprites62 = images/ships/shpmycpo/SHOT_A63_PCX.bmp
+WeaponSprites63 = images/ships/shpmycpo/SHOT_A64_PCX.bmp
+
+WeaponExplosion0 = images/ships/shpmycpo/SHOT_B01_PCX.bmp
+WeaponExplosion1 = images/ships/shpmycpo/SHOT_B02_PCX.bmp
+WeaponExplosion2 = images/ships/shpmycpo/SHOT_B03_PCX.bmp
+WeaponExplosion3 = images/ships/shpmycpo/SHOT_B04_PCX.bmp
+WeaponExplosion4 = images/ships/shpmycpo/SHOT_B05_PCX.bmp
+WeaponExplosion5 = images/ships/shpmycpo/SHOT_B06_PCX.bmp
+WeaponExplosion6 = images/ships/shpmycpo/SHOT_B07_PCX.bmp
+WeaponExplosion7 = images/ships/shpmycpo/SHOT_B08_PCX.bmp
+WeaponExplosion8 = images/ships/shpmycpo/SHOT_B09_PCX.bmp
+WeaponExplosion9 = images/ships/shpmycpo/SHOT_B10_PCX.bmp
+WeaponExplosion10 = images/ships/shpmycpo/SHOT_B11_PCX.bmp
+WeaponExplosion11 = images/ships/shpmycpo/SHOT_B12_PCX.bmp
+WeaponExplosion12 = images/ships/shpmycpo/SHOT_B13_PCX.bmp
+WeaponExplosion13 = images/ships/shpmycpo/SHOT_B14_PCX.bmp
+WeaponExplosion14 = images/ships/shpmycpo/SHOT_B15_PCX.bmp
+WeaponExplosion15 = images/ships/shpmycpo/SHOT_B16_PCX.bmp
+WeaponExplosion16 = images/ships/shpmycpo/SHOT_B17_PCX.bmp
+WeaponExplosion17 = images/ships/shpmycpo/SHOT_B18_PCX.bmp
+WeaponExplosion18 = images/ships/shpmycpo/SHOT_B19_PCX.bmp
+WeaponExplosion19 = images/ships/shpmycpo/SHOT_B20_PCX.bmp
+

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shporzne.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shporzne.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shporzne.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -6,6 +6,7 @@
 Origin = UQM
 Coders = The Fly
 Code = OrzNemesis
+Version = 65M
 
 [Ship]
 Crew = 16
@@ -67,3 +68,70 @@
 CaptName14 = *Smell*
 CaptName15 = *Juice*
 CaptName16 = *Squirt*
+
+[Music]
+Victory = music/ditty/orzditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shporzne/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shporzne/WAVE_B01_WAV.wav
+SpecialSample1 = sound/ships/shporzne/WAVE_B02_WAV.wav
+
+ExtraSample0 = sound/ships/shporzne/WAVE_C01_WAV.wav
+ExtraSample1 = sound/ships/shporzne/WAVE_C02_WAV.wav
+ExtraSample2 = sound/ships/shporzne/WAVE_C03_WAV.wav
+
+[Objects]
+ShipSprites = 1r +alpha
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 10 +alpha
+SpecialSprites = 2
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 1r +alpha
+ExtraSamples = 3
+ExtraExplosion = 10 +alpha
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shporzne/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shporzne/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shporzne/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shporzne/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shporzne/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shporzne/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shporzne/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shporzne/SHIP_S_00_TGA.bmp
+
+WeaponSprites0 = images/ships/shporzne/SHOT_A01_PCX.bmp
+
+WeaponExplosion0 = images/ships/shporzne/SHOT_B_00_BMP.bmp
+WeaponExplosion1 = images/ships/shporzne/SHOT_B_01_BMP.bmp
+WeaponExplosion2 = images/ships/shporzne/SHOT_B_02_BMP.bmp
+WeaponExplosion3 = images/ships/shporzne/SHOT_B_03_BMP.bmp
+WeaponExplosion4 = images/ships/shporzne/SHOT_B_04_BMP.bmp
+WeaponExplosion5 = images/ships/shporzne/SHOT_B_05_BMP.bmp
+WeaponExplosion6 = images/ships/shporzne/SHOT_B_06_BMP.bmp
+WeaponExplosion7 = images/ships/shporzne/SHOT_B_07_BMP.bmp
+WeaponExplosion8 = images/ships/shporzne/SHOT_B_08_BMP.bmp
+WeaponExplosion9 = images/ships/shporzne/SHOT_B_09_BMP.bmp
+
+SpecialSprites0 = images/ships/shporzne/SHOT_C01_PCX.bmp
+SpecialSprites1 = images/ships/shporzne/SHOT_C02_PCX.bmp
+
+ExtraSprites0 = images/ships/shporzne/SHOT_D_00_TGA.bmp
+
+ExtraExplosion0 = images/ships/shporzne/SHOT_E_00_BMP.bmp
+ExtraExplosion1 = images/ships/shporzne/SHOT_E_01_BMP.bmp
+ExtraExplosion2 = images/ships/shporzne/SHOT_E_02_BMP.bmp
+ExtraExplosion3 = images/ships/shporzne/SHOT_E_03_BMP.bmp
+ExtraExplosion4 = images/ships/shporzne/SHOT_E_04_BMP.bmp
+ExtraExplosion5 = images/ships/shporzne/SHOT_E_05_BMP.bmp
+ExtraExplosion6 = images/ships/shporzne/SHOT_E_06_BMP.bmp
+ExtraExplosion7 = images/ships/shporzne/SHOT_E_07_BMP.bmp
+ExtraExplosion8 = images/ships/shporzne/SHOT_E_08_BMP.bmp
+ExtraExplosion9 = images/ships/shporzne/SHOT_E_09_BMP.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shppkufu.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shppkufu.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shppkufu.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -6,6 +6,7 @@
 Origin = UQM
 Coders = The Fly
 Code = PkunkFury
+Version = 65M
 
 [Ship]
 Crew = 8
@@ -53,3 +54,61 @@
 CaptName14 = Jay
 CaptName15 = Screech
 CaptName16 = Twitter
+
+[Music]
+Victory = music/ditty/pkuditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shppkufu/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shppkufu/WAVE_B01_WAV.wav
+SpecialSample1 = sound/ships/shppkufu/WAVE_B02_WAV.wav
+SpecialSample2 = sound/ships/shppkufu/WAVE_B03_WAV.wav
+SpecialSample3 = sound/ships/shppkufu/WAVE_B04_WAV.wav
+SpecialSample4 = sound/ships/shppkufu/WAVE_B05_WAV.wav
+SpecialSample5 = sound/ships/shppkufu/WAVE_B06_WAV.wav
+SpecialSample6 = sound/ships/shppkufu/WAVE_B07_WAV.wav
+SpecialSample7 = sound/ships/shppkufu/WAVE_B08_WAV.wav
+SpecialSample8 = sound/ships/shppkufu/WAVE_B09_WAV.wav
+SpecialSample9 = sound/ships/shppkufu/WAVE_B10_WAV.wav
+SpecialSample10 = sound/ships/shppkufu/WAVE_B11_WAV.wav
+SpecialSample11 = sound/ships/shppkufu/WAVE_B12_WAV.wav
+SpecialSample12 = sound/ships/shppkufu/WAVE_B13_WAV.wav
+SpecialSample13 = sound/ships/shppkufu/WAVE_B14_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 10 +alpha
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 0
+SpecialSamples = 14
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 1
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shppkufu/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shppkufu/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shppkufu/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shppkufu/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shppkufu/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shppkufu/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shppkufu/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shppkufu/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shppkufu/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shppkufu/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shppkufu/SHOT_A03_PCX.bmp
+WeaponSprites3 = images/ships/shppkufu/SHOT_A04_PCX.bmp
+WeaponSprites4 = images/ships/shppkufu/SHOT_A05_PCX.bmp
+WeaponSprites5 = images/ships/shppkufu/SHOT_A06_PCX.bmp
+WeaponSprites6 = images/ships/shppkufu/SHOT_A07_PCX.bmp
+WeaponSprites7 = images/ships/shppkufu/SHOT_A08_PCX.bmp
+WeaponSprites8 = images/ships/shppkufu/SHOT_A09_PCX.bmp
+WeaponSprites9 = images/ships/shppkufu/SHOT_A10_PCX.bmp
+

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shprogsq.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shprogsq.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shprogsq.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -4,8 +4,9 @@
 Name1 = Rogue
 Name2 = Squadron
 Coders = GeomanNL
-; idea: this version, GeomanNL, but similar ideas were given by many people as well.
+; = idea: this version, GeomanNL, but similar ideas were given by many people as well.
 Code = RogueSquadron
+Version = 65M
 
 [Ship]
 Crew = 11
@@ -25,11 +26,11 @@
 Mass = 10
 
 [Weapon]
-Range    = 40
-Damage   = 1
+Range = 40
+Damage = 1
 Velocity = 100
-Color    = 0x0FFFF00	; yellow
-Length   = 20.0
+Color = 0x0FFFF00	; yellow
+Length = 20.0
 
 [Fighter]
 Crew = 2
@@ -41,7 +42,7 @@
 EvadeRotationPerSec = 720	; can do 2 turn / second to evade some object
 SuicideDamage = 1
 
-; rest is equal to mothership
+; = rest is equal to mothership
 
 [AI3_Default]
 Weapon = Missile
@@ -49,36 +50,36 @@
 SpecialFreq = 10
 
 [Formations]
-; assume the leader heads upward
-; each formation needs CrewMax entries
-; if you've casualties only the first Crew entries are used, so the order in which
-;     you define the positions is important.
-; position (0,0) is for the leader; should always be there.
+; = assume the leader heads upward
+; = each formation needs CrewMax entries
+; = if you've casualties only the first Crew entries are used, so the order in which
+; = you define the positions is important.
+; = position (0,0) is for the leader; should always be there.
 
 Nformations = 5
 
-; formation 1:
-;   ( x y ) sets
+; = formation 1:
+; = ( x y ) sets
 
-; column
+; = column
 Formation01 = 0 0  0 -100  0 -200  0 -300  0 -400  0 -500  0 -600  0 -700  0 -800  0 -900  0 -1000
 
-; row
-Formation02 =  0 0  -100 0  100 0  -200 0  200 0  -300 0  300 0  -400 0  400 0  -500 0  500 0
+; = row
+Formation02 = 0 0  -100 0  100 0  -200 0  200 0  -300 0  300 0  -400 0  400 0  -500 0  500 0
 
-; V
+; = V
 Formation03 = 0 0  -50 -50  50 -50  -100 -100  100 -100  -150 -150  150 -150  -200 -200  200 -200  -250 -250  250 -250
 
-; Circle (disabled)
+; = Circle (disabled)
 ;Formation04 = 0 0  -182 -117  198 -229  -57 -392  -151 -331  108 -32  -108 -32  57 -392  -198 -229  182 -117  151 -331
 
-; Box
+; = Box
 Formation04 = 0 0  -100 -100  0 -100  100 -100  -100 -200  0 -200  100 -200  -100 -300  0 -300  100 -300  0 -400
 
-; Tightly packed Box
+; = Tightly packed Box
 Formation05 = 0 0  -50 -50  0 -50  50 -50  -50 -100  0 -100  50 -100  -50 -150  0 -150  50 -150  0 -200
 
-; Two Rows (disabled)
+; = Two Rows (disabled)
 ;Formation06 = -150 0  -150 100  150 100  -150 200  150 200  -150 300  150 300  -150 400  150 400  -150 500  150 500
 
 [Names]
@@ -89,3 +90,38 @@
 CaptName4 = Delta
 CaptName5 = Red L.
 CaptName6 = Blue L.
+
+[Music]
+Victory = music/ditty/pkuditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shprogsq/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shprogsq/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 0
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shprogsq/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shprogsq/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shprogsq/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shprogsq/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shprogsq/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shprogsq/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shprogsq/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shprogsq/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shprogsq/SHOT_A01_PCX.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpshosc.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpshosc.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpshosc.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = ShofixtiScout
+Version = 65M
 
 [Ship]
 Crew = 6
@@ -60,3 +61,70 @@
 CaptName14 = Tora-3
 CaptName15 = Tofu
 CaptName16 = Kimba
+
+[Music]
+Victory = music/ditty/shoditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpshosc/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpshosc/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 30 +alpha
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 8
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpshosc/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpshosc/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpshosc/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpshosc/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpshosc/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpshosc/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpshosc/SHIP_P06_PCX.bmp
+PanelBitmaps7 = images/ships/shpshosc/SHIP_P07_PCX.bmp
+
+ShipSprites0 = images/ships/shpshosc/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpshosc/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpshosc/SHOT_B01_PCX.bmp
+SpecialSprites1 = images/ships/shpshosc/SHOT_B02_PCX.bmp
+SpecialSprites2 = images/ships/shpshosc/SHOT_B03_PCX.bmp
+SpecialSprites3 = images/ships/shpshosc/SHOT_B04_PCX.bmp
+SpecialSprites4 = images/ships/shpshosc/SHOT_B05_PCX.bmp
+SpecialSprites5 = images/ships/shpshosc/SHOT_B06_PCX.bmp
+SpecialSprites6 = images/ships/shpshosc/SHOT_B07_PCX.bmp
+SpecialSprites7 = images/ships/shpshosc/SHOT_B08_PCX.bmp
+SpecialSprites8 = images/ships/shpshosc/SHOT_B09_PCX.bmp
+SpecialSprites9 = images/ships/shpshosc/SHOT_B10_PCX.bmp
+SpecialSprites10 = images/ships/shpshosc/SHOT_B11_PCX.bmp
+SpecialSprites11 = images/ships/shpshosc/SHOT_B12_PCX.bmp
+SpecialSprites12 = images/ships/shpshosc/SHOT_B13_PCX.bmp
+SpecialSprites13 = images/ships/shpshosc/SHOT_B14_PCX.bmp
+SpecialSprites14 = images/ships/shpshosc/SHOT_B15_PCX.bmp
+SpecialSprites15 = images/ships/shpshosc/SHOT_B16_PCX.bmp
+SpecialSprites16 = images/ships/shpshosc/SHOT_B17_PCX.bmp
+SpecialSprites17 = images/ships/shpshosc/SHOT_B18_PCX.bmp
+SpecialSprites18 = images/ships/shpshosc/SHOT_B19_PCX.bmp
+SpecialSprites19 = images/ships/shpshosc/SHOT_B20_PCX.bmp
+SpecialSprites20 = images/ships/shpshosc/SHOT_B21_PCX.bmp
+SpecialSprites21 = images/ships/shpshosc/SHOT_B22_PCX.bmp
+SpecialSprites22 = images/ships/shpshosc/SHOT_B23_PCX.bmp
+SpecialSprites23 = images/ships/shpshosc/SHOT_B24_PCX.bmp
+SpecialSprites24 = images/ships/shpshosc/SHOT_B25_PCX.bmp
+SpecialSprites25 = images/ships/shpshosc/SHOT_B26_PCX.bmp
+SpecialSprites26 = images/ships/shpshosc/SHOT_B27_PCX.bmp
+SpecialSprites27 = images/ships/shpshosc/SHOT_B28_PCX.bmp
+SpecialSprites28 = images/ships/shpshosc/SHOT_B29_PCX.bmp
+SpecialSprites29 = images/ships/shpshosc/SHOT_B30_PCX.bmp
+

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpslypr.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpslypr.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpslypr.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -6,6 +6,7 @@
 Origin = UQM
 Coders = The Fly (weapon update: GeomanNL)
 Code = SlylandroProbe
+Version = 65M
 
 [Ship]
 Crew = 12
@@ -41,3 +42,100 @@
 [Names]
 NumNames = 1
 CaptName1 = 2418-B
+
+[Music]
+Victory = music/ditty/slyditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpslypr/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpslypr/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 64
+WeaponSprites = 0
+WeaponSamples = 1
+WeaponExplosion = 1
+SpecialSprites = 0
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpslypr/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpslypr/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpslypr/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpslypr/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpslypr/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpslypr/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpslypr/SHIP_P06_PCX.bmp
+
+ShipSprites0 = images/ships/shpslypr/SHIP_S01_PCX.bmp
+ShipSprites1 = images/ships/shpslypr/SHIP_S02_PCX.bmp
+ShipSprites2 = images/ships/shpslypr/SHIP_S03_PCX.bmp
+ShipSprites3 = images/ships/shpslypr/SHIP_S04_PCX.bmp
+ShipSprites4 = images/ships/shpslypr/SHIP_S05_PCX.bmp
+ShipSprites5 = images/ships/shpslypr/SHIP_S06_PCX.bmp
+ShipSprites6 = images/ships/shpslypr/SHIP_S07_PCX.bmp
+ShipSprites7 = images/ships/shpslypr/SHIP_S08_PCX.bmp
+ShipSprites8 = images/ships/shpslypr/SHIP_S09_PCX.bmp
+ShipSprites9 = images/ships/shpslypr/SHIP_S10_PCX.bmp
+ShipSprites10 = images/ships/shpslypr/SHIP_S11_PCX.bmp
+ShipSprites11 = images/ships/shpslypr/SHIP_S12_PCX.bmp
+ShipSprites12 = images/ships/shpslypr/SHIP_S13_PCX.bmp
+ShipSprites13 = images/ships/shpslypr/SHIP_S14_PCX.bmp
+ShipSprites14 = images/ships/shpslypr/SHIP_S15_PCX.bmp
+ShipSprites15 = images/ships/shpslypr/SHIP_S16_PCX.bmp
+ShipSprites16 = images/ships/shpslypr/SHIP_S17_PCX.bmp
+ShipSprites17 = images/ships/shpslypr/SHIP_S18_PCX.bmp
+ShipSprites18 = images/ships/shpslypr/SHIP_S19_PCX.bmp
+ShipSprites19 = images/ships/shpslypr/SHIP_S20_PCX.bmp
+ShipSprites20 = images/ships/shpslypr/SHIP_S21_PCX.bmp
+ShipSprites21 = images/ships/shpslypr/SHIP_S22_PCX.bmp
+ShipSprites22 = images/ships/shpslypr/SHIP_S23_PCX.bmp
+ShipSprites23 = images/ships/shpslypr/SHIP_S24_PCX.bmp
+ShipSprites24 = images/ships/shpslypr/SHIP_S25_PCX.bmp
+ShipSprites25 = images/ships/shpslypr/SHIP_S26_PCX.bmp
+ShipSprites26 = images/ships/shpslypr/SHIP_S27_PCX.bmp
+ShipSprites27 = images/ships/shpslypr/SHIP_S28_PCX.bmp
+ShipSprites28 = images/ships/shpslypr/SHIP_S29_PCX.bmp
+ShipSprites29 = images/ships/shpslypr/SHIP_S30_PCX.bmp
+ShipSprites30 = images/ships/shpslypr/SHIP_S31_PCX.bmp
+ShipSprites31 = images/ships/shpslypr/SHIP_S32_PCX.bmp
+ShipSprites32 = images/ships/shpslypr/SHIP_S33_PCX.bmp
+ShipSprites33 = images/ships/shpslypr/SHIP_S34_PCX.bmp
+ShipSprites34 = images/ships/shpslypr/SHIP_S35_PCX.bmp
+ShipSprites35 = images/ships/shpslypr/SHIP_S36_PCX.bmp
+ShipSprites36 = images/ships/shpslypr/SHIP_S37_PCX.bmp
+ShipSprites37 = images/ships/shpslypr/SHIP_S38_PCX.bmp
+ShipSprites38 = images/ships/shpslypr/SHIP_S39_PCX.bmp
+ShipSprites39 = images/ships/shpslypr/SHIP_S40_PCX.bmp
+ShipSprites40 = images/ships/shpslypr/SHIP_S41_PCX.bmp
+ShipSprites41 = images/ships/shpslypr/SHIP_S42_PCX.bmp
+ShipSprites42 = images/ships/shpslypr/SHIP_S43_PCX.bmp
+ShipSprites43 = images/ships/shpslypr/SHIP_S44_PCX.bmp
+ShipSprites44 = images/ships/shpslypr/SHIP_S45_PCX.bmp
+ShipSprites45 = images/ships/shpslypr/SHIP_S46_PCX.bmp
+ShipSprites46 = images/ships/shpslypr/SHIP_S47_PCX.bmp
+ShipSprites47 = images/ships/shpslypr/SHIP_S48_PCX.bmp
+ShipSprites48 = images/ships/shpslypr/SHIP_S49_PCX.bmp
+ShipSprites49 = images/ships/shpslypr/SHIP_S50_PCX.bmp
+ShipSprites50 = images/ships/shpslypr/SHIP_S51_PCX.bmp
+ShipSprites51 = images/ships/shpslypr/SHIP_S52_PCX.bmp
+ShipSprites52 = images/ships/shpslypr/SHIP_S53_PCX.bmp
+ShipSprites53 = images/ships/shpslypr/SHIP_S54_PCX.bmp
+ShipSprites54 = images/ships/shpslypr/SHIP_S55_PCX.bmp
+ShipSprites55 = images/ships/shpslypr/SHIP_S56_PCX.bmp
+ShipSprites56 = images/ships/shpslypr/SHIP_S57_PCX.bmp
+ShipSprites57 = images/ships/shpslypr/SHIP_S58_PCX.bmp
+ShipSprites58 = images/ships/shpslypr/SHIP_S59_PCX.bmp
+ShipSprites59 = images/ships/shpslypr/SHIP_S60_PCX.bmp
+ShipSprites60 = images/ships/shpslypr/SHIP_S61_PCX.bmp
+ShipSprites61 = images/ships/shpslypr/SHIP_S62_PCX.bmp
+ShipSprites62 = images/ships/shpslypr/SHIP_S63_PCX.bmp
+ShipSprites63 = images/ships/shpslypr/SHIP_S64_PCX.bmp
+
+WeaponExplosion0 = images/ships/shpslypr/SHIP_W01_PCX.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpspael.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpspael.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpspael.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = SpathiEluder
+Version = 65M
 
 [Ship]
 Crew = 30
@@ -61,3 +62,40 @@
 CaptName14 = Snelopy
 CaptName15 = Bwinkin
 CaptName16 = Whuff
+
+[Music]
+Victory = music/ditty/spaditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpspael/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpspael/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 1r
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpspael/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpspael/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpspael/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpspael/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpspael/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpspael/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpspael/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpspael/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpspael/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpspael/SHOT_B01_PCX.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpstaba.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpstaba.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpstaba.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -6,6 +6,7 @@
 Coders = UAF :) sort off, thanks to the creators of the other ships I
 ; = used their code for this ship :)
 Code = StarBase
+Version = 65M
 
 [Ship]
 Crew = 42
@@ -43,8 +44,44 @@
 HealColor = 1
 Range = 7
 
-[AI3_Default] 
-Special = Defense 
-SpecialFreq = 3 
+[AI3_Default]
+Special = Defense
+SpecialFreq = 3
 Reserve_Battery = 10
-Weapon = Sides
\ No newline at end of file
+Weapon = Sides
+
+[Music]
+Victory = music/ditty/spaditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpstaba/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpstaba/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 0
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpstaba/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpstaba/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpstaba/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpstaba/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpstaba/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpstaba/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpstaba/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpstaba/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpstaba/SHOT_A01_PCX.bmp
+

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpsupbl.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpsupbl.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpsupbl.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -6,6 +6,7 @@
 Origin = UQM
 Coders = The Fly
 Code = SupoxBlade
+Version = 65M
 
 [Ship]
 Crew = 12
@@ -51,3 +52,49 @@
 CaptName14 = Stem
 CaptName15 = Bramble
 CaptName16 = Thicket
+
+[Music]
+Victory = music/ditty/supditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpsupbl/WAVE_A01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 10
+SpecialSprites = 0
+SpecialSamples = 0
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpsupbl/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpsupbl/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpsupbl/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpsupbl/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpsupbl/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpsupbl/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpsupbl/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpsupbl/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpsupbl/SHOT_A01_PCX.bmp
+
+WeaponExplosion0 = images/ships/shpsupbl/SHOT_B01_PCX.bmp
+WeaponExplosion1 = images/ships/shpsupbl/SHOT_B02_PCX.bmp
+WeaponExplosion2 = images/ships/shpsupbl/SHOT_B03_PCX.bmp
+WeaponExplosion3 = images/ships/shpsupbl/SHOT_B04_PCX.bmp
+WeaponExplosion4 = images/ships/shpsupbl/SHOT_B05_PCX.bmp
+WeaponExplosion5 = images/ships/shpsupbl/SHOT_B06_PCX.bmp
+WeaponExplosion6 = images/ships/shpsupbl/SHOT_B07_PCX.bmp
+WeaponExplosion7 = images/ships/shpsupbl/SHOT_B08_PCX.bmp
+WeaponExplosion8 = images/ships/shpsupbl/SHOT_B09_PCX.bmp
+WeaponExplosion9 = images/ships/shpsupbl/SHOT_B10_PCX.bmp
+
+

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpsyrpe.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpsyrpe.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpsyrpe.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = SyreenPenetrator
+Version = 65M
 
 [Ship]
 Crew = 12
@@ -59,3 +60,42 @@
 CaptName14 = Aelita
 CaptName15 = Alura
 CaptName16 = Dale
+
+[Music]
+Victory = music/ditty/syrditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpsyrpe/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpsyrpe/WAVE_B01_WAV.wav
+
+ExtraSample0 = sound/ships/shpsyrpe/WAVE_C01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 1r32 +alpha
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 1
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpsyrpe/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpsyrpe/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpsyrpe/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpsyrpe/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpsyrpe/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpsyrpe/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpsyrpe/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpsyrpe/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpsyrpe/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpsyrpe/SHOT_B01_PCX.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shptauar.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shptauar.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shptauar.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,27 +1,28 @@
 [Info]
-TWCost  = 30
+TWCost = 30
 Name1 = Tau
 Name2 = Archon
 Origin = TW
 Coders = Tau (and Jad)
 Code = TauArchon
+Version = 65M
 
 [Ship]
-Crew           = 42
-CrewMax        = 42
-Batt           = 42
-BattMax        = 42
-SpeedMax       = 30
-AccelRate      = 5.7
-TurnRate       = 4.2
+Crew = 42
+CrewMax = 42
+Batt = 42
+BattMax = 42
+SpeedMax = 30
+AccelRate = 5.7
+TurnRate = 4.2
 RechargeAmount = 1
-RechargeRate   = 2.5
-WeaponDrain    = 3
-WeaponRate     = -0.5
-SpecialDrain   = 5
-SpecialRate    = 0
-HotspotRate    = 5
-Mass           = 23
+RechargeRate = 2.5
+WeaponDrain = 3
+WeaponRate = -0.5
+SpecialDrain = 5
+SpecialRate = 0
+HotspotRate = 5
+Mass = 23
 
 CoolDownThenCharge = 1
 
@@ -37,11 +38,11 @@
 SoundTimer = 250
 DoReactiveDamage = 1
 
-; The steps the ship takes to damage a ship
-; set DamageSteps to 0 to return to original (all batt first) style
+; = The steps the ship takes to damage a ship
+; = set DamageSteps to 0 to return to original (all batt first) style
 DamageSteps = 2
 
-; Batt = 1, Crew = 0.
+; = Batt = 1, Crew = 0.
 Step1 = 1
 Step2 = 0
 
@@ -54,3 +55,200 @@
 [AI3_Default]
 Special = Defense
 SpecialFreq = 1
+
+[Music]
+Victory = music/ditty/tauditty.xm
+
+[Sound]
+WeaponSample0 = sound/ships/shptauar/WAVE_A01_WAV.wav
+WeaponSample1 = sound/ships/shptauar/WAVE_A02_WAV.wav
+WeaponSample2 = sound/ships/shptauar/WAVE_A03_WAV.wav
+WeaponSample3 = sound/ships/shptauar/WAVE_A04_WAV.wav
+WeaponSample4 = sound/ships/shptauar/WAVE_A05_WAV.wav
+WeaponSample5 = sound/ships/shptauar/WAVE_A06_WAV.wav
+
+SpecialSample0 = sound/ships/shptauar/WAVE_B01_WAV.wav
+
+ExtraSample0 = sound/ships/shptauar/WAVE_C01_WAV.wav
+ExtraSample1 = sound/ships/shptauar/WAVE_C02_WAV.wav
+ExtraSample2 = sound/ships/shptauar/WAVE_C03_WAV.wav
+ExtraSample3 = sound/ships/shptauar/WAVE_C04_WAV.wav
+
+[Objects]
+ShipSprites = 1r +alpha
+WeaponSprites = 81 +alpha
+WeaponSamples = 6
+WeaponExplosion = 10 +alpha
+SpecialSprites = 0
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 12
+ExtraSamples = 4
+ExtraExplosion = 20 +alpha
+ExtraExtraSprites0_ = 1r +alpha
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shptauar/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shptauar/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shptauar/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shptauar/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shptauar/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shptauar/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shptauar/SHIP_P06_PCX.bmp
+
+ShipSprites0 = images/ships/shptauar/SHIP_S0_00_TGA.bmp
+
+WeaponSprites0 = images/ships/shptauar/SHOT_A0_00_TGA.bmp
+WeaponSprites1 = images/ships/shptauar/SHOT_A0_01_TGA.bmp
+WeaponSprites2 = images/ships/shptauar/SHOT_A0_02_TGA.bmp
+WeaponSprites3 = images/ships/shptauar/SHOT_A0_03_TGA.bmp
+WeaponSprites4 = images/ships/shptauar/SHOT_A0_04_TGA.bmp
+WeaponSprites5 = images/ships/shptauar/SHOT_A0_05_TGA.bmp
+WeaponSprites6 = images/ships/shptauar/SHOT_A0_06_TGA.bmp
+WeaponSprites7 = images/ships/shptauar/SHOT_A0_07_TGA.bmp
+WeaponSprites8 = images/ships/shptauar/SHOT_A0_08_TGA.bmp
+WeaponSprites9 = images/ships/shptauar/SHOT_A0_09_TGA.bmp
+WeaponSprites10 = images/ships/shptauar/SHOT_A0_10_TGA.bmp
+WeaponSprites11 = images/ships/shptauar/SHOT_A0_11_TGA.bmp
+WeaponSprites12 = images/ships/shptauar/SHOT_A0_12_TGA.bmp
+WeaponSprites13 = images/ships/shptauar/SHOT_A0_13_TGA.bmp
+WeaponSprites14 = images/ships/shptauar/SHOT_A0_14_TGA.bmp
+WeaponSprites15 = images/ships/shptauar/SHOT_A0_15_TGA.bmp
+WeaponSprites16 = images/ships/shptauar/SHOT_A0_16_TGA.bmp
+WeaponSprites17 = images/ships/shptauar/SHOT_A0_17_TGA.bmp
+WeaponSprites18 = images/ships/shptauar/SHOT_A0_18_TGA.bmp
+WeaponSprites19 = images/ships/shptauar/SHOT_A0_19_TGA.bmp
+WeaponSprites20 = images/ships/shptauar/SHOT_A1_00_TGA.bmp
+WeaponSprites21 = images/ships/shptauar/SHOT_A1_01_TGA.bmp
+WeaponSprites22 = images/ships/shptauar/SHOT_A1_02_TGA.bmp
+WeaponSprites23 = images/ships/shptauar/SHOT_A1_03_TGA.bmp
+WeaponSprites24 = images/ships/shptauar/SHOT_A1_04_TGA.bmp
+WeaponSprites25 = images/ships/shptauar/SHOT_A1_05_TGA.bmp
+WeaponSprites26 = images/ships/shptauar/SHOT_A1_06_TGA.bmp
+WeaponSprites27 = images/ships/shptauar/SHOT_A1_07_TGA.bmp
+WeaponSprites28 = images/ships/shptauar/SHOT_A1_08_TGA.bmp
+WeaponSprites29 = images/ships/shptauar/SHOT_A1_09_TGA.bmp
+WeaponSprites30 = images/ships/shptauar/SHOT_A1_10_TGA.bmp
+WeaponSprites31 = images/ships/shptauar/SHOT_A1_11_TGA.bmp
+WeaponSprites32 = images/ships/shptauar/SHOT_A1_12_TGA.bmp
+WeaponSprites33 = images/ships/shptauar/SHOT_A1_13_TGA.bmp
+WeaponSprites34 = images/ships/shptauar/SHOT_A1_14_TGA.bmp
+WeaponSprites35 = images/ships/shptauar/SHOT_A1_15_TGA.bmp
+WeaponSprites36 = images/ships/shptauar/SHOT_A1_16_TGA.bmp
+WeaponSprites37 = images/ships/shptauar/SHOT_A1_17_TGA.bmp
+WeaponSprites38 = images/ships/shptauar/SHOT_A1_18_TGA.bmp
+WeaponSprites39 = images/ships/shptauar/SHOT_A1_19_TGA.bmp
+WeaponSprites40 = images/ships/shptauar/SHOT_A2_00_TGA.bmp
+WeaponSprites41 = images/ships/shptauar/SHOT_A2_01_TGA.bmp
+WeaponSprites42 = images/ships/shptauar/SHOT_A2_02_TGA.bmp
+WeaponSprites43 = images/ships/shptauar/SHOT_A2_03_TGA.bmp
+WeaponSprites44 = images/ships/shptauar/SHOT_A2_04_TGA.bmp
+WeaponSprites45 = images/ships/shptauar/SHOT_A2_05_TGA.bmp
+WeaponSprites46 = images/ships/shptauar/SHOT_A2_06_TGA.bmp
+WeaponSprites47 = images/ships/shptauar/SHOT_A2_07_TGA.bmp
+WeaponSprites48 = images/ships/shptauar/SHOT_A2_08_TGA.bmp
+WeaponSprites49 = images/ships/shptauar/SHOT_A2_09_TGA.bmp
+WeaponSprites50 = images/ships/shptauar/SHOT_A2_10_TGA.bmp
+WeaponSprites51 = images/ships/shptauar/SHOT_A2_11_TGA.bmp
+WeaponSprites52 = images/ships/shptauar/SHOT_A2_12_TGA.bmp
+WeaponSprites53 = images/ships/shptauar/SHOT_A2_13_TGA.bmp
+WeaponSprites54 = images/ships/shptauar/SHOT_A2_14_TGA.bmp
+WeaponSprites55 = images/ships/shptauar/SHOT_A2_15_TGA.bmp
+WeaponSprites56 = images/ships/shptauar/SHOT_A2_16_TGA.bmp
+WeaponSprites57 = images/ships/shptauar/SHOT_A2_17_TGA.bmp
+WeaponSprites58 = images/ships/shptauar/SHOT_A2_18_TGA.bmp
+WeaponSprites59 = images/ships/shptauar/SHOT_A2_19_TGA.bmp
+WeaponSprites60 = images/ships/shptauar/SHOT_A3_00_TGA.bmp
+WeaponSprites61 = images/ships/shptauar/SHOT_A3_01_TGA.bmp
+WeaponSprites62 = images/ships/shptauar/SHOT_A3_02_TGA.bmp
+WeaponSprites63 = images/ships/shptauar/SHOT_A3_03_TGA.bmp
+WeaponSprites64 = images/ships/shptauar/SHOT_A3_04_TGA.bmp
+WeaponSprites65 = images/ships/shptauar/SHOT_A3_05_TGA.bmp
+WeaponSprites66 = images/ships/shptauar/SHOT_A3_06_TGA.bmp
+WeaponSprites67 = images/ships/shptauar/SHOT_A3_07_TGA.bmp
+WeaponSprites68 = images/ships/shptauar/SHOT_A3_08_TGA.bmp
+WeaponSprites69 = images/ships/shptauar/SHOT_A3_09_TGA.bmp
+WeaponSprites70 = images/ships/shptauar/SHOT_A3_10_TGA.bmp
+WeaponSprites71 = images/ships/shptauar/SHOT_A3_11_TGA.bmp
+WeaponSprites72 = images/ships/shptauar/SHOT_A3_12_TGA.bmp
+WeaponSprites73 = images/ships/shptauar/SHOT_A3_13_TGA.bmp
+WeaponSprites74 = images/ships/shptauar/SHOT_A3_14_TGA.bmp
+WeaponSprites75 = images/ships/shptauar/SHOT_A3_15_TGA.bmp
+WeaponSprites76 = images/ships/shptauar/SHOT_A3_16_TGA.bmp
+WeaponSprites77 = images/ships/shptauar/SHOT_A3_17_TGA.bmp
+WeaponSprites78 = images/ships/shptauar/SHOT_A3_18_TGA.bmp
+WeaponSprites79 = images/ships/shptauar/SHOT_A3_19_TGA.bmp
+WeaponSprites80 = images/ships/shptauar/SHOT_AX_00_TGA.bmp
+
+
+WeaponExplosion0 = images/ships/shptauar/SHOT_B_00_TGA.bmp
+WeaponExplosion1 = images/ships/shptauar/SHOT_B_01_TGA.bmp
+WeaponExplosion2 = images/ships/shptauar/SHOT_B_02_TGA.bmp
+WeaponExplosion3 = images/ships/shptauar/SHOT_B_03_TGA.bmp
+WeaponExplosion4 = images/ships/shptauar/SHOT_B_04_TGA.bmp
+WeaponExplosion5 = images/ships/shptauar/SHOT_B_05_TGA.bmp
+WeaponExplosion6 = images/ships/shptauar/SHOT_B_06_TGA.bmp
+WeaponExplosion7 = images/ships/shptauar/SHOT_B_07_TGA.bmp
+WeaponExplosion8 = images/ships/shptauar/SHOT_B_08_TGA.bmp
+WeaponExplosion9 = images/ships/shptauar/SHOT_B_09_TGA.bmp
+
+SpecialSprites0 = images/ships/shptauar/SHOT_C0_00_TGA.bmp
+SpecialSprites1 = images/ships/shptauar/SHOT_C1_00_TGA.bmp
+
+SpecialExplosion0 = images/ships/shptauar/SHOT_D_00_TGA.bmp
+SpecialExplosion1 = images/ships/shptauar/SHOT_D_01_TGA.bmp
+SpecialExplosion2 = images/ships/shptauar/SHOT_D_02_TGA.bmp
+SpecialExplosion3 = images/ships/shptauar/SHOT_D_03_TGA.bmp
+SpecialExplosion4 = images/ships/shptauar/SHOT_D_04_TGA.bmp
+SpecialExplosion5 = images/ships/shptauar/SHOT_D_05_TGA.bmp
+SpecialExplosion6 = images/ships/shptauar/SHOT_D_06_TGA.bmp
+SpecialExplosion7 = images/ships/shptauar/SHOT_D_07_TGA.bmp
+SpecialExplosion8 = images/ships/shptauar/SHOT_D_08_TGA.bmp
+SpecialExplosion9 = images/ships/shptauar/SHOT_D_09_TGA.bmp
+SpecialExplosion10 = images/ships/shptauar/SHOT_D_10_TGA.bmp
+SpecialExplosion11 = images/ships/shptauar/SHOT_D_11_TGA.bmp
+SpecialExplosion12 = images/ships/shptauar/SHOT_D_12_TGA.bmp
+SpecialExplosion13 = images/ships/shptauar/SHOT_D_13_TGA.bmp
+SpecialExplosion14 = images/ships/shptauar/SHOT_D_14_TGA.bmp
+SpecialExplosion15 = images/ships/shptauar/SHOT_D_15_TGA.bmp
+SpecialExplosion16 = images/ships/shptauar/SHOT_D_16_TGA.bmp
+SpecialExplosion17 = images/ships/shptauar/SHOT_D_17_TGA.bmp
+SpecialExplosion18 = images/ships/shptauar/SHOT_D_18_TGA.bmp
+SpecialExplosion19 = images/ships/shptauar/SHOT_D_19_TGA.bmp
+
+ExtraSprites0 = images/ships/shptauar/SHOT_C01_PCX.bmp
+ExtraSprites1 = images/ships/shptauar/SHOT_C02_PCX.bmp
+ExtraSprites2 = images/ships/shptauar/SHOT_C03_PCX.bmp
+ExtraSprites3 = images/ships/shptauar/SHOT_C04_PCX.bmp
+ExtraSprites4 = images/ships/shptauar/SHOT_C05_PCX.bmp
+ExtraSprites5 = images/ships/shptauar/SHOT_C06_PCX.bmp
+ExtraSprites6 = images/ships/shptauar/SHOT_C07_PCX.bmp
+ExtraSprites7 = images/ships/shptauar/SHOT_C08_PCX.bmp
+ExtraSprites8 = images/ships/shptauar/SHOT_C09_PCX.bmp
+ExtraSprites9 = images/ships/shptauar/SHOT_C10_PCX.bmp
+ExtraSprites10 = images/ships/shptauar/SHOT_C11_PCX.bmp
+ExtraSprites11 = images/ships/shptauar/SHOT_C12_PCX.bmp
+
+ExtraExplosion0 = images/ships/shptauar/SHOT_F_00_TGA.bmp
+ExtraExplosion1 = images/ships/shptauar/SHOT_F_01_TGA.bmp
+ExtraExplosion2 = images/ships/shptauar/SHOT_F_02_TGA.bmp
+ExtraExplosion3 = images/ships/shptauar/SHOT_F_03_TGA.bmp
+ExtraExplosion4 = images/ships/shptauar/SHOT_F_04_TGA.bmp
+ExtraExplosion5 = images/ships/shptauar/SHOT_F_05_TGA.bmp
+ExtraExplosion6 = images/ships/shptauar/SHOT_F_06_TGA.bmp
+ExtraExplosion7 = images/ships/shptauar/SHOT_F_07_TGA.bmp
+ExtraExplosion8 = images/ships/shptauar/SHOT_F_08_TGA.bmp
+ExtraExplosion9 = images/ships/shptauar/SHOT_F_09_TGA.bmp
+ExtraExplosion10 = images/ships/shptauar/SHOT_F_10_TGA.bmp
+ExtraExplosion11 = images/ships/shptauar/SHOT_F_11_TGA.bmp
+ExtraExplosion12 = images/ships/shptauar/SHOT_F_12_TGA.bmp
+ExtraExplosion13 = images/ships/shptauar/SHOT_F_13_TGA.bmp
+ExtraExplosion14 = images/ships/shptauar/SHOT_F_14_TGA.bmp
+ExtraExplosion15 = images/ships/shptauar/SHOT_F_15_TGA.bmp
+ExtraExplosion16 = images/ships/shptauar/SHOT_F_16_TGA.bmp
+ExtraExplosion17 = images/ships/shptauar/SHOT_F_17_TGA.bmp
+ExtraExplosion18 = images/ships/shptauar/SHOT_F_18_TGA.bmp
+ExtraExplosion19 = images/ships/shptauar/SHOT_F_19_TGA.bmp
+
+ExtraExtraSprites0_0 = images/ships/shptauar/SHOT_X0_00_BMP.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shptauda.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shptauda.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shptauda.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,27 +1,28 @@
 [Info]
-TWCost  = 12
+TWCost = 12
 Name1 = Tau
 Name2 = Dagger
 Origin = TW
 Coders = Tau
 Code = TauDagger
+Version = 65M
 
 [Ship]
-Crew           = 8
-CrewMax        = 8
-Batt           = 12
-BattMax        = 12
-SpeedMax       = 47
-AccelRate      = 13
-TurnRate       = 1
+Crew = 8
+CrewMax = 8
+Batt = 12
+BattMax = 12
+SpeedMax = 47
+AccelRate = 13
+TurnRate = 1
 RechargeAmount = 1
-RechargeRate   = 3
-WeaponDrain    = 6
-WeaponRate     = 11
-SpecialDrain   = 12
-SpecialRate    = 0
-HotspotRate    = 1
-Mass           = 6
+RechargeRate = 3
+WeaponDrain = 6
+WeaponRate = 11
+SpecialDrain = 12
+SpecialRate = 0
+HotspotRate = 1
+Mass = 6
 
 [Weapon]
 Range = 4.5
@@ -35,3 +36,73 @@
 Armour = 3
 Recoil = 60
 
+[Music]
+Victory = music/ditty/tauditty.xm
+
+[Sound]
+WeaponSample0 = sound/ships/shptauda/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shptauda/WAVE_B01_WAV.wav
+SpecialSample1 = sound/ships/shptauda/WAVE_B02_WAV.wav
+
+[Objects]
+ShipSprites = 1r +alpha
+WeaponSprites = 0
+WeaponSamples = 1
+WeaponExplosion = 1 +alpha
+SpecialSprites = 2r +alpha
+SpecialSamples = 2
+SpecialExplosion = 20 +alpha
+ExtraSprites = 10 +alpha
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shptauda/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shptauda/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shptauda/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shptauda/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shptauda/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shptauda/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shptauda/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shptauda/SHIP_S_00_TGA.bmp
+
+WeaponExplosion0 = images/ships/shptauda/SHOT_B_00_TGA.bmp
+
+SpecialSprites0 = images/ships/shptauda/SHOT_C0_00_TGA.bmp
+SpecialSprites1 = images/ships/shptauda/SHOT_C1_00_TGA.bmp
+
+SpecialExplosion0 = images/ships/shptauda/SHOT_D_00_TGA.bmp
+SpecialExplosion1 = images/ships/shptauda/SHOT_D_01_TGA.bmp
+SpecialExplosion2 = images/ships/shptauda/SHOT_D_02_TGA.bmp
+SpecialExplosion3 = images/ships/shptauda/SHOT_D_03_TGA.bmp
+SpecialExplosion4 = images/ships/shptauda/SHOT_D_04_TGA.bmp
+SpecialExplosion5 = images/ships/shptauda/SHOT_D_05_TGA.bmp
+SpecialExplosion6 = images/ships/shptauda/SHOT_D_06_TGA.bmp
+SpecialExplosion7 = images/ships/shptauda/SHOT_D_07_TGA.bmp
+SpecialExplosion8 = images/ships/shptauda/SHOT_D_08_TGA.bmp
+SpecialExplosion9 = images/ships/shptauda/SHOT_D_09_TGA.bmp
+SpecialExplosion10 = images/ships/shptauda/SHOT_D_10_TGA.bmp
+SpecialExplosion11 = images/ships/shptauda/SHOT_D_11_TGA.bmp
+SpecialExplosion12 = images/ships/shptauda/SHOT_D_12_TGA.bmp
+SpecialExplosion13 = images/ships/shptauda/SHOT_D_13_TGA.bmp
+SpecialExplosion14 = images/ships/shptauda/SHOT_D_14_TGA.bmp
+SpecialExplosion15 = images/ships/shptauda/SHOT_D_15_TGA.bmp
+SpecialExplosion16 = images/ships/shptauda/SHOT_D_16_TGA.bmp
+SpecialExplosion17 = images/ships/shptauda/SHOT_D_17_TGA.bmp
+SpecialExplosion18 = images/ships/shptauda/SHOT_D_18_TGA.bmp
+SpecialExplosion19 = images/ships/shptauda/SHOT_D_19_TGA.bmp
+
+ExtraSprites0 = images/ships/shptauda/SHOT_E_00_TGA.bmp
+ExtraSprites1 = images/ships/shptauda/SHOT_E_01_TGA.bmp
+ExtraSprites2 = images/ships/shptauda/SHOT_E_02_TGA.bmp
+ExtraSprites3 = images/ships/shptauda/SHOT_E_03_TGA.bmp
+ExtraSprites4 = images/ships/shptauda/SHOT_E_04_TGA.bmp
+ExtraSprites5 = images/ships/shptauda/SHOT_E_05_TGA.bmp
+ExtraSprites6 = images/ships/shptauda/SHOT_E_06_TGA.bmp
+ExtraSprites7 = images/ships/shptauda/SHOT_E_07_TGA.bmp
+ExtraSprites8 = images/ships/shptauda/SHOT_E_08_TGA.bmp
+ExtraSprites9 = images/ships/shptauda/SHOT_E_09_TGA.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shptausl.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shptausl.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shptausl.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,32 +1,33 @@
 [Info]
 Origin = TW
-TWCost  = 20
+TWCost = 20
 Name1 = Tau
 Name2 = Slider
 Coders = Tau
 Code = TauSlider
+Version = 65M
 
 [Ship]
-Crew           = 22
-CrewMax        = 22
-Batt           = 22
-BattMax        = 22
-SpeedMax       = 42
-AccelRate      = 9
-TurnRate       = 1
+Crew = 22
+CrewMax = 22
+Batt = 22
+BattMax = 22
+SpeedMax = 42
+AccelRate = 9
+TurnRate = 1
 RechargeAmount = 1
-RechargeRate   = 2
-WeaponDrain    = 3
-WeaponRate     = 1
-SpecialDrain   = 3
-SpecialRate    = 4
-HotspotRate    = 3
-Mass           = 16
+RechargeRate = 2
+WeaponDrain = 3
+WeaponRate = 1
+SpecialDrain = 3
+SpecialRate = 4
+HotspotRate = 3
+Mass = 16
 
 [Weapon]
-Range    = 15
+Range = 15
 Velocity = 110
-Length  = 10
+Length = 10
 
 [Special]
 Range0 = 0
@@ -41,3 +42,37 @@
 SubVelocity = 2
 
 
+[Music]
+Victory = music/ditty/tauditty.xm
+
+[Sound]
+WeaponSample0 = sound/ships/shptausl/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shptausl/WAVE_B01_WAV.wav
+SpecialSample1 = sound/ships/shptausl/WAVE_B02_WAV.wav
+SpecialSample1 = sound/ships/shptausl/WAVE_B03_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 0
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 0
+SpecialSamples = 3
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shptausl/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shptausl/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shptausl/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shptausl/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shptausl/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shptausl/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shptausl/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shptausl/SHIP_S00_BMP.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shptauto.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shptauto.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shptauto.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,40 +1,41 @@
 [Info]
 Origin = TW
-TWCost  = 22
+TWCost = 22
 Name1 = Tau
 Name2 = Torrent
 Coders = Tau
-Ditty  = Lestat
+Ditty = Lestat
 Code = TauTor
+Version = 65M
 
 [Ship]
-Crew           = 20
-CrewMax        = 20
-Batt           = 20
-BattMax        = 20
-SpeedMax       = 50
-AccelRate      = 5
-TurnRate       = 3
+Crew = 20
+CrewMax = 20
+Batt = 20
+BattMax = 20
+SpeedMax = 50
+AccelRate = 5
+TurnRate = 3
 RechargeAmount = 1
-RechargeRate   = 3
-WeaponDrain    = 10
-WeaponRate     = 20
-SpecialDrain   = 1
-SpecialRate    = 1
-HotspotRate    = 1
-Mass           = 21
+RechargeRate = 3
+WeaponDrain = 10
+WeaponRate = 20
+SpecialDrain = 1
+SpecialRate = 1
+HotspotRate = 1
+Mass = 21
 
 [Weapon]
-Range    = 50
+Range = 50
 Velocity = 130
-Damage   = 6
-Armour   = 999
+Damage = 6
+Armour = 999
 
 [Special]
-Range    = 14
+Range = 14
 Velocity = 80
-Damage   = 2
-Armour   = 1
+Damage = 2
+Armour = 1
 
 [Extra]
 StartDrain = 6
@@ -49,3 +50,93 @@
 BattRecharge = 1
 Special = Proximity
 Special_Range = 10
+
+[Music]
+Victory = music/ditty/tauditty.xm
+
+[Sound]
+WeaponSample0 = sound/ships/shptauto/WAVE_A01_WAV.wav
+WeaponSample1 = sound/ships/shptauto/WAVE_A02_WAV.wav
+
+ExtraSample0 = sound/ships/shptauto/WAVE_C01_WAV.wav
+ExtraSample1 = sound/ships/shptauto/WAVE_C02_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 6
+WeaponSamples = 2
+WeaponExplosion = 12
+SpecialSprites = 6
+SpecialSamples = 0
+SpecialExplosion = 12
+ExtraSprites = 12
+ExtraSamples = 2
+ExtraExplosion = 1r
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shptauto/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shptauto/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shptauto/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shptauto/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shptauto/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shptauto/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shptauto/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shptauto/SHIP_S00_BMP.bmp
+
+WeaponSprites0 = images/ships/shptauto/SHOT_A00_BMP.bmp
+WeaponSprites1 = images/ships/shptauto/SHOT_A01_BMP.bmp
+WeaponSprites2 = images/ships/shptauto/SHOT_A02_BMP.bmp
+WeaponSprites3 = images/ships/shptauto/SHOT_A03_BMP.bmp
+WeaponSprites4 = images/ships/shptauto/SHOT_A04_BMP.bmp
+WeaponSprites5 = images/ships/shptauto/SHOT_A05_BMP.bmp
+
+WeaponExplosion0 = images/ships/shptauto/SHOT_B00_BMP.bmp
+WeaponExplosion1 = images/ships/shptauto/SHOT_B01_BMP.bmp
+WeaponExplosion2 = images/ships/shptauto/SHOT_B02_BMP.bmp
+WeaponExplosion3 = images/ships/shptauto/SHOT_B03_BMP.bmp
+WeaponExplosion4 = images/ships/shptauto/SHOT_B04_BMP.bmp
+WeaponExplosion5 = images/ships/shptauto/SHOT_B05_BMP.bmp
+WeaponExplosion6 = images/ships/shptauto/SHOT_B06_BMP.bmp
+WeaponExplosion7 = images/ships/shptauto/SHOT_B07_BMP.bmp
+WeaponExplosion8 = images/ships/shptauto/SHOT_B08_BMP.bmp
+WeaponExplosion9 = images/ships/shptauto/SHOT_B09_BMP.bmp
+WeaponExplosion10 = images/ships/shptauto/SHOT_B10_BMP.bmp
+WeaponExplosion11 = images/ships/shptauto/SHOT_B11_BMP.bmp
+
+SpecialSprites0 = images/ships/shptauto/SHOT_C00_BMP.bmp
+SpecialSprites1 = images/ships/shptauto/SHOT_C01_BMP.bmp
+SpecialSprites2 = images/ships/shptauto/SHOT_C02_BMP.bmp
+SpecialSprites3 = images/ships/shptauto/SHOT_C03_BMP.bmp
+SpecialSprites4 = images/ships/shptauto/SHOT_C04_BMP.bmp
+SpecialSprites5 = images/ships/shptauto/SHOT_C05_BMP.bmp
+
+SpecialExplosion0 = images/ships/shptauto/SHOT_D00_BMP.bmp
+SpecialExplosion1 = images/ships/shptauto/SHOT_D01_BMP.bmp
+SpecialExplosion2 = images/ships/shptauto/SHOT_D02_BMP.bmp
+SpecialExplosion3 = images/ships/shptauto/SHOT_D03_BMP.bmp
+SpecialExplosion4 = images/ships/shptauto/SHOT_D04_BMP.bmp
+SpecialExplosion5 = images/ships/shptauto/SHOT_D05_BMP.bmp
+SpecialExplosion6 = images/ships/shptauto/SHOT_D06_BMP.bmp
+SpecialExplosion7 = images/ships/shptauto/SHOT_D07_BMP.bmp
+SpecialExplosion8 = images/ships/shptauto/SHOT_D08_BMP.bmp
+SpecialExplosion9 = images/ships/shptauto/SHOT_D09_BMP.bmp
+SpecialExplosion10 = images/ships/shptauto/SHOT_D10_BMP.bmp
+SpecialExplosion11 = images/ships/shptauto/SHOT_D11_BMP.bmp
+
+ExtraSprites0 = images/ships/shptauto/SHOT_E0000_BMP.bmp
+ExtraSprites1 = images/ships/shptauto/SHOT_E0001_BMP.bmp
+ExtraSprites2 = images/ships/shptauto/SHOT_E0002_BMP.bmp
+ExtraSprites3 = images/ships/shptauto/SHOT_E0003_BMP.bmp
+ExtraSprites4 = images/ships/shptauto/SHOT_E0004_BMP.bmp
+ExtraSprites5 = images/ships/shptauto/SHOT_E0005_BMP.bmp
+ExtraSprites6 = images/ships/shptauto/SHOT_E0006_BMP.bmp
+ExtraSprites7 = images/ships/shptauto/SHOT_E0007_BMP.bmp
+ExtraSprites8 = images/ships/shptauto/SHOT_E0008_BMP.bmp
+ExtraSprites9 = images/ships/shptauto/SHOT_E0009_BMP.bmp
+ExtraSprites10 = images/ships/shptauto/SHOT_E0010_BMP.bmp
+ExtraSprites11 = images/ships/shptauto/SHOT_E0011_BMP.bmp
+
+ExtraExplosion0 = images/ships/shptauto/SHOT_F00_BMP.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpthrto.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpthrto.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpthrto.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -6,6 +6,7 @@
 Origin = UQM
 Coders = The Fly
 Code = ThraddashTorch
+Version = 65M
 
 [Ship]
 Crew = 8
@@ -58,3 +59,81 @@
 CaptName14 = Fkank
 CaptName15 = Pdump
 CaptName16 = Whumps
+
+[Music]
+Victory = music/ditty/thrditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpthrto/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpthrto/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 39 +alpha
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpthrto/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpthrto/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpthrto/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpthrto/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpthrto/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpthrto/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpthrto/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpthrto/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpthrto/SHOT_A01_PCX.bmp
+
+SpecialSprites0 = images/ships/shpthrto/SHOT_B02_PCX.bmp
+SpecialSprites1 = images/ships/shpthrto/SHOT_B03_PCX.bmp
+SpecialSprites2 = images/ships/shpthrto/SHOT_B04_PCX.bmp
+SpecialSprites3 = images/ships/shpthrto/SHOT_B05_PCX.bmp
+SpecialSprites4 = images/ships/shpthrto/SHOT_B06_PCX.bmp
+SpecialSprites5 = images/ships/shpthrto/SHOT_B07_PCX.bmp
+SpecialSprites6 = images/ships/shpthrto/SHOT_B08_PCX.bmp
+SpecialSprites7 = images/ships/shpthrto/SHOT_B09_PCX.bmp
+SpecialSprites8 = images/ships/shpthrto/SHOT_B10_PCX.bmp
+SpecialSprites9 = images/ships/shpthrto/SHOT_B11_PCX.bmp
+SpecialSprites10 = images/ships/shpthrto/SHOT_B12_PCX.bmp
+SpecialSprites11 = images/ships/shpthrto/SHOT_B13_PCX.bmp
+SpecialSprites12 = images/ships/shpthrto/SHOT_B14_PCX.bmp
+SpecialSprites13 = images/ships/shpthrto/SHOT_B15_PCX.bmp
+SpecialSprites14 = images/ships/shpthrto/SHOT_B16_PCX.bmp
+SpecialSprites15 = images/ships/shpthrto/SHOT_B17_PCX.bmp
+SpecialSprites16 = images/ships/shpthrto/SHOT_B18_PCX.bmp
+SpecialSprites17 = images/ships/shpthrto/SHOT_B19_PCX.bmp
+SpecialSprites18 = images/ships/shpthrto/SHOT_B20_PCX.bmp
+SpecialSprites19 = images/ships/shpthrto/SHOT_B21_PCX.bmp
+SpecialSprites20 = images/ships/shpthrto/SHOT_B22_PCX.bmp
+SpecialSprites21 = images/ships/shpthrto/SHOT_B23_PCX.bmp
+SpecialSprites22 = images/ships/shpthrto/SHOT_B24_PCX.bmp
+SpecialSprites23 = images/ships/shpthrto/SHOT_B25_PCX.bmp
+SpecialSprites24 = images/ships/shpthrto/SHOT_B26_PCX.bmp
+SpecialSprites25 = images/ships/shpthrto/SHOT_B27_PCX.bmp
+SpecialSprites26 = images/ships/shpthrto/SHOT_B28_PCX.bmp
+SpecialSprites27 = images/ships/shpthrto/SHOT_B29_PCX.bmp
+SpecialSprites28 = images/ships/shpthrto/SHOT_B30_PCX.bmp
+SpecialSprites29 = images/ships/shpthrto/SHOT_B31_PCX.bmp
+SpecialSprites30 = images/ships/shpthrto/SHOT_B32_PCX.bmp
+SpecialSprites31 = images/ships/shpthrto/SHOT_B33_PCX.bmp
+SpecialSprites32 = images/ships/shpthrto/SHOT_B34_PCX.bmp
+SpecialSprites33 = images/ships/shpthrto/SHOT_B35_PCX.bmp
+SpecialSprites34 = images/ships/shpthrto/SHOT_B36_PCX.bmp
+SpecialSprites35 = images/ships/shpthrto/SHOT_B37_PCX.bmp
+SpecialSprites36 = images/ships/shpthrto/SHOT_B38_PCX.bmp
+SpecialSprites37 = images/ships/shpthrto/SHOT_B39_PCX.bmp
+SpecialSprites38 = images/ships/shpthrto/SHOT_B40_PCX.bmp
+
+
+

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpumgdr.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpumgdr.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpumgdr.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = UmgahDrone
+Version = 65M
 
 [Ship]
 Crew = 10
@@ -55,3 +56,44 @@
 CaptName14 = Kterbi'a
 CaptName15 = Chup'he
 CaptName16 = I'buba
+
+[Music]
+Victory = music/ditty/umgditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpumgdr/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpumgdr/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 6r +noaa
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 0
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpumgdr/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpumgdr/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpumgdr/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpumgdr/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpumgdr/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpumgdr/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpumgdr/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpumgdr/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpumgdr/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shpumgdr/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shpumgdr/SHOT_A03_PCX.bmp
+WeaponSprites3 = images/ships/shpumgdr/SHOT_A04_PCX.bmp
+WeaponSprites4 = images/ships/shpumgdr/SHOT_A05_PCX.bmp
+WeaponSprites5 = images/ships/shpumgdr/SHOT_A06_PCX.bmp
+

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shputwju.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shputwju.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shputwju.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -6,6 +6,7 @@
 Origin = UQM
 Coders = The Fly
 Code = UtwigJugger
+Version = 65M
 
 [Ship]
 Crew = 20
@@ -52,3 +53,39 @@
 CaptName14 = Thory
 CaptName15 = Jujuby
 CaptName16 = Erog
+
+[Music]
+Victory = music/ditty/utwditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shputwju/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shputwju/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 0
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shputwju/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shputwju/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shputwju/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shputwju/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shputwju/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shputwju/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shputwju/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shputwju/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shputwju/SHOT_A01_PCX.bmp
+

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpvuxin.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpvuxin.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpvuxin.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = VuxIntruder
+Version = 65M
 
 [Ship]
 Crew = 20
@@ -60,3 +61,58 @@
 CaptName14 = ZOG
 CaptName15 = ORZ
 CaptName16 = ZEK
+
+[Music]
+Victory = music/ditty/vuxditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpvuxin/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpvuxin/WAVE_B01_WAV.wav
+SpecialSample1 = sound/ships/shpvuxin/WAVE_B02_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 3r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 11
+SpecialSamples = 2
+SpecialExplosion = 0
+ExtraSprites = 3r
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpvuxin/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpvuxin/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpvuxin/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpvuxin/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpvuxin/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpvuxin/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpvuxin/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpvuxin/SHIP_S00_PCX.bmp
+
+WeaponSprites0 = images/ships/shpvuxin/SHOT_000_PCX.bmp
+WeaponSprites1 = images/ships/shpvuxin/SHOT_001_PCX.bmp
+WeaponSprites2 = images/ships/shpvuxin/SHOT_002_PCX.bmp
+
+SpecialSprites0 = images/ships/shpvuxin/SHOT_A01_PCX.bmp
+SpecialSprites1 = images/ships/shpvuxin/SHOT_A02_PCX.bmp
+SpecialSprites2 = images/ships/shpvuxin/SHOT_A03_PCX.bmp
+SpecialSprites3 = images/ships/shpvuxin/SHOT_A04_PCX.bmp
+SpecialSprites4 = images/ships/shpvuxin/SHOT_A05_PCX.bmp
+SpecialSprites5 = images/ships/shpvuxin/SHOT_A06_PCX.bmp
+SpecialSprites6 = images/ships/shpvuxin/SHOT_A07_PCX.bmp
+SpecialSprites7 = images/ships/shpvuxin/SHOT_A08_PCX.bmp
+SpecialSprites8 = images/ships/shpvuxin/SHOT_A09_PCX.bmp
+SpecialSprites9 = images/ships/shpvuxin/SHOT_A10_PCX.bmp
+SpecialSprites10 = images/ships/shpvuxin/SHOT_A11_PCX.bmp
+              
+ExtraSprites0 = images/ships/shpvuxin/SHOT_E00_PCX.bmp
+ExtraSprites1 = images/ships/shpvuxin/SHOT_E01_PCX.bmp
+ExtraSprites2 = images/ships/shpvuxin/SHOT_E02_PCS.bmp
+

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpyehte.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpyehte.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpyehte.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -7,6 +7,7 @@
 Origin = UQM
 Coders = The Fly
 Code = YehatTerminator
+Version = 65M
 
 [Ship]
 Crew = 20
@@ -56,3 +57,40 @@
 CaptName14 = Geep-eep
 CaptName15 = Zeep-eep
 CaptName16 = Neep-eep
+
+[Music]
+Victory = music/ditty/yehditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpyehte/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpyehte/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 1r
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 1r
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpyehte/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpyehte/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpyehte/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpyehte/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpyehte/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpyehte/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpyehte/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpyehte/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpyehte/SHOT_A00_BMP.bmp
+
+SpecialSprites0 = images/ships/shpyehte/SHOT_B01_PCX.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpzeksh.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpzeksh.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpzeksh.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -5,6 +5,7 @@
 Origin = TW
 Coders = Richardyzo
 Code = ZekfahanShocker
+Version = 65M
 
 [Ship]
 Crew = 42
@@ -35,3 +36,52 @@
 Damage = 4
 Armour = 99
 Frames = 2550
+
+[Music]
+Victory = music/ditty/vuxditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpzeksh/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpzeksh/WAVE_B01_WAV.wav
+SpecialSample1 = sound/ships/shpzeksh/WAVE_B02_WAV.wav
+SpecialSample2 = sound/ships/shpzeksh/WAVE_B03_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 5
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 6
+SpecialSamples = 3
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpzeksh/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpzeksh/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpzeksh/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpzeksh/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpzeksh/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpzeksh/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpzeksh/SHIP_P06_PCX.bmp
+
+
+ShipSprites0 = images/ships/shpzeksh/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpzeksh/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shpzeksh/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shpzeksh/SHOT_A03_PCX.bmp
+WeaponSprites3 = images/ships/shpzeksh/SHOT_A04_PCX.bmp
+WeaponSprites4 = images/ships/shpzeksh/SHOT_A05_PCX.bmp
+
+
+SpecialSprites0 = images/ships/shpzeksh/SHOT_B01_PCX.bmp
+SpecialSprites1 = images/ships/shpzeksh/SHOT_B02_PCX.bmp
+SpecialSprites2 = images/ships/shpzeksh/SHOT_B03_PCX.bmp
+SpecialSprites3 = images/ships/shpzeksh/SHOT_B04_PCX.bmp
+SpecialSprites4 = images/ships/shpzeksh/SHOT_B05_PCX.bmp
+SpecialSprites5 = images/ships/shpzeksh/SHOT_B06_PCX.bmp

Modified: branches/multiplayer-branch/gamedata/default_ini/ships/shpzfpst.ini
===================================================================
--- branches/multiplayer-branch/gamedata/default_ini/ships/shpzfpst.ini	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/default_ini/ships/shpzfpst.ini	2004-09-28 19:53:03 UTC (rev 71)
@@ -6,6 +6,7 @@
 Origin = UQM
 Coders = The Fly
 Code = ZoqFotPikStinger
+Version = 65M
 
 [Ship]
 Crew = 10
@@ -33,7 +34,7 @@
 [Special]
 Damage = 12		;4
 Licking = 0		;1
-; 0 makes it use "flat" damage
+; = 0 makes it use "flat" damage
 
 [AI3_Default]
 Tactic = Direct
@@ -60,3 +61,50 @@
 CaptName14 = TikTok
 CaptName15 = MikMok
 CaptName16 = SikSok
+
+[Music]
+Victory = music/ditty/zoqditty.mod
+
+[Sound]
+WeaponSample0 = sound/ships/shpzfpst/WAVE_A01_WAV.wav
+
+SpecialSample0 = sound/ships/shpzfpst/WAVE_B01_WAV.wav
+
+[Objects]
+ShipSprites = 1r
+WeaponSprites = 6
+WeaponSamples = 1
+WeaponExplosion = 0
+SpecialSprites = 6r
+SpecialSamples = 1
+SpecialExplosion = 0
+ExtraSprites = 0
+ExtraSamples = 0
+ExtraExplosion = 0
+PanelBitmaps = 7
+
+[Graphic]
+PanelBitmaps0 = images/ships/shpzfpst/SHIP_P00_PCX.bmp
+PanelBitmaps1 = images/ships/shpzfpst/SHIP_P01_PCX.bmp
+PanelBitmaps2 = images/ships/shpzfpst/SHIP_P02_PCX.bmp
+PanelBitmaps3 = images/ships/shpzfpst/SHIP_P03_PCX.bmp
+PanelBitmaps4 = images/ships/shpzfpst/SHIP_P04_PCX.bmp
+PanelBitmaps5 = images/ships/shpzfpst/SHIP_P05_PCX.bmp
+PanelBitmaps6 = images/ships/shpzfpst/SHIP_P06_PCX.bmp
+
+ShipSprites0 = images/ships/shpzfpst/SHIP_S01_PCX.bmp
+
+WeaponSprites0 = images/ships/shpzfpst/SHOT_A01_PCX.bmp
+WeaponSprites1 = images/ships/shpzfpst/SHOT_A02_PCX.bmp
+WeaponSprites2 = images/ships/shpzfpst/SHOT_A03_PCX.bmp
+WeaponSprites3 = images/ships/shpzfpst/SHOT_A04_PCX.bmp
+WeaponSprites4 = images/ships/shpzfpst/SHOT_A05_PCX.bmp
+WeaponSprites5 = images/ships/shpzfpst/SHOT_A06_PCX.bmp
+
+SpecialSprites0 = images/ships/shpzfpst/SHOT_B01_PCX.bmp
+SpecialSprites1 = images/ships/shpzfpst/SHOT_B02_PCX.bmp
+SpecialSprites2 = images/ships/shpzfpst/SHOT_B03_PCX.bmp
+SpecialSprites3 = images/ships/shpzfpst/SHOT_B04_PCX.bmp
+SpecialSprites4 = images/ships/shpzfpst/SHOT_B05_PCX.bmp
+SpecialSprites5 = images/ships/shpzfpst/SHOT_B06_PCX.bmp
+

Copied: branches/multiplayer-branch/gamedata/gob.dat (from rev 69, trunk/gamedata/gob.dat)


Property changes on: branches/multiplayer-branch/gamedata/gob.dat
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Copied: branches/multiplayer-branch/gamedata/images/bspab.jpg (from rev 69, trunk/gamedata/images/bspab.jpg)


Property changes on: branches/multiplayer-branch/gamedata/images/bspab.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Deleted: branches/multiplayer-branch/gamedata/images/logo.bmp
===================================================================
(Binary files differ)

Copied: branches/multiplayer-branch/gamedata/images/ships (from rev 69, trunk/gamedata/images/ships)

Copied: branches/multiplayer-branch/gamedata/images/stangrop.jpg (from rev 69, trunk/gamedata/images/stangrop.jpg)


Property changes on: branches/multiplayer-branch/gamedata/images/stangrop.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: branches/multiplayer-branch/gamedata/ingame.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ingame.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ingame.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,98 +1,113 @@
 Global keys:
-        F1 brings up the help screen
-        F2 brings up the options menu
-        F3 switches camera focus
-        F4 is fast-forward (speeds up in-game time greatly)
-        F5 displays fleet status
-        F7 changes game tic rate (physics quality)
-        F8 changes camera mode
-        F10 quits (so does ESCAPE)
-        F11 saves screenshots
-        F12 displays framerates / performance data
-        - zooms out on some viewing modes.
-        + (or =) zooms in on some viewing modes.
-        0 and 9 also effect the camera in some viewing modes.
-        ctrl+T = toggle team indicators on/off
-        ctrl+H = toggle healthbar indicators on/off
+  F1 brings up the help screen
+  F2 brings up the options menu
+  F3 switches camera focus
+  F4 is fast-forward (speeds up in-game time greatly)
+  F5 displays fleet status
+  F7 changes game tic rate (physics quality)
+  F8 changes camera mode
+  F10 quits (so does ESCAPE)
+  F11 saves screenshots
+  F12 displays framerates / performance data
+  - zooms out on some viewing modes.
+  + (or =) zooms in on some viewing modes.
+  0 and 9 also effect the camera in some viewing modes.
+  ctrl+T = toggle team indicators on/off
+  ctrl+H = toggle healthbar indicators on/off
 
 Melee:  
+  Starts a battle with the current team settings.
 
-	Starts a battle with the current team settings.
-
 Extras Menu:
 
-	Play Game:
-               Select different gametypes.  For this version, only Melee is available.
-	Key Tester:
-               Use this utility to check keys combination for conflicts.
-	Show License:
-		Shows the license of this program.
-	Ship Info:
-		Here you can get detail information about every 
-             ship in the game.  Disabled in this release, sorry!
-	Diagnostic:
-                Show comlile options and version information. 
-	Main Menu:
-                This returns to the main menu.
-		
+  Play Game:
+    Select different gametypes.  Currently:
+    1) Melee - simple starfleet combat
+    2) GOB - Game goals:
+              Avoid dieing.  
+              Try to get as bad-ass a ship as you can.  
+              Kill lots of enemies.
 
+       If you survive for long enough and accumulate 
+       enough wealth, you will eventually be able to 
+       purchase the "Hyper Dynamo" upgrade.  Once you
+       get that, you can basically consider yourself 
+       to have won the game. Try to win Gob with as 
+       many different ships as you can.  
+
+    3) Defender - protect starbase as long as you can
+
+  Key Tester:
+    Use this utility to check keys combination for conflicts.
+  Show License:
+    Shows the license of this program.
+  Ship Info:
+    Here you can get detail information about every 
+    ship in the game.  
+  Diagnostic:
+    Show comlile options and version information. 
+  Main Menu:
+    This returns to the main menu.	
+
 Teams:
 
-        Select Controller:
-                Select the player (i.e. "Player 1" or "Player 2")
-              you wish to alter from the list on the left, and
-              the controller (i.e. "Keyboard", "MoronBot") you
-              want to control that player from the list on the
-              left.  Then either click on the "Select
-              Controller" button or double click on the
-              controller name.
-	Change Team #: 
-	        This switches the player allys. 
-	      Note that team 0 mean no allys.
-        Change Config #:
-                 This switches the configuration used by the
-               currently highlighted controller.  
-        Edit Configuration:
-                 This is used to setup up keys when the currently
-               highlighted player is using the keyboard.  It
-               may eventually allow the configuration of AIs
-               and calibration of joysticks.
-        Edit Fleet:
-                 This button brings up the fleet selection menu for
-               the currently highlighted player.  
-        Main Menu:
-                 This returns to the main menu.
+  Select Controller:
+    Select the player (i.e. "Player 1" or "Player 2")
+    you wish to alter from the list on the left, and
+    the controller (i.e. "Keyboard", "MoronBot") you
+    want to control that player from the list on the
+    left.  Then either click on the "Select
+    Controller" button or double click on the
+    controller name.
+  Change Team #: 
+    This switches the player allys. 
+    Note that team 0 mean no allys.
+  Change Config #:
+    This switches the configuration used by the
+    currently highlighted controller.  
+  Edit Configuration:
+    This is used to setup up keys when the currently
+    highlighted player is using the keyboard.  It
+    may eventually allow the configuration of AIs
+    and calibration of joysticks.
+  Edit Fleet:
+    This button brings up the fleet selection menu for
+    the currently highlighted player.  
+  Main Menu:
+    This returns to the main menu.
 
 Options:
 
-        Most things on this menu are self-explanatory, but a few
-          need special mention.
+  Most things on this menu are self-explanatory, but a few
+  need special mention.
 
-        Gamma correction:
-                This makes things brighter during combat.  This
-                  should not be changed from the middle of combat,
-                  or colors could get weird.  
-        Antialiasing:
-                If this box is checked then TimeWarp will use
-                  higher quality graphics, but run slower.  
-        Color Depth:
-                You cannot change this from the middle of combat.  
-        Camera Mode:
-                This allows you to control what is shown on your
-                  screen in combat.  
+  Gamma correction:
+    This makes things brighter during combat.  This
+    should not be changed from the middle of combat,
+    or colors could get weird.  
+  Antialiasing:
+    If this box is checked then TimeWarp will use
+    higher quality graphics, but run slower.  
+  Color Depth:
+    You cannot change this from the middle of combat.  
+  Camera Mode:
+    This allows you to control what is shown on your
+    screen in combat.  
 
-                "Enemy_Discrete"
-                  is just like Star Control on the PC, where
-                  the camera moved to keep both you and your
-                  enemy onscreen, and zoomed in by factors of
-                  2.
-                "Enemy"
-                  is like Star Control on the Genesis or 3DO,
-                  where the camera zoomed in smoothly.
-                "Hero"
-                  makes the camera stay focused on Player 1,
-                  and zoom in/out when + and - are pressed.
-                "Everything"
-                  makes the camera stay on the planet and zoom
-                  way out so that everything is visible.  This
-                  mode is slightly buggy (visual artifacts).  
+    "Enemy_Discrete"
+       is just like Star Control on the PC, where
+       the camera moved to keep both you and your
+       enemy onscreen, and zoomed in by factors of 2.
+
+     "Enemy"
+       is like Star Control on the Genesis or 3DO,
+       where the camera zoomed in smoothly.
+
+     "Hero"
+       makes the camera stay focused on Player 1,
+       and zoom in/out when + and - are pressed.
+
+     "Everything"
+       makes the camera stay on the planet and zoom
+       way out so that everything is visible.  This
+       mode is slightly buggy (visual artifacts).  

Copied: branches/multiplayer-branch/gamedata/music/ditty (from rev 69, trunk/gamedata/music/ditty)

Modified: branches/multiplayer-branch/gamedata/readme.html
===================================================================
--- branches/multiplayer-branch/gamedata/readme.html	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/readme.html	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,218 +1,54 @@
-<html>
-<head>
-    <title>TW-Light Readme</title>
-</head>
-<body>
-
-<h1>TW-Light Readme</h1>
-
-<h2>Overview: What is TW-Light?</h2>
-
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
+<title>TW-Light: TW-Light</title>
+<link href="doxygen.css" rel="stylesheet" type="text/css">
+</head><body>
+<!-- Generated by Doxygen 1.3.8 -->
+<h1>TW-Light </h1>
 <p>
-TW-Light is lightweighted version of Star Control: TimeWarp.
-Currently it includes only a combat portion with the best TW ships but 
-without network support. There are some plans to expand it to include an 
-epic adventure.
-</p>
-
-<h2>Getting Started</h2>
-
-<p>
-<pre>
-Melee:  Starts a battle.  In battle the following keys do stuff:
-        F1 brings up the help screen (this file, at the moment)
-        F2 brings up the options menu
-        F3 switches camera focus
-        F4 is fast-forward (speeds up in-game time greatly)
-        F5 displays fleet status
-        F7 changes game tic rate (physics quality)
-        F8 changes camera mode
-        F9 creates planets (silly "feature")
-        F10 quits (so does ESCAPE)
-        F11 saves screenshots
-        F12 displays framerates / performance data
-        - zooms out on some viewing modes.
-        + (or =) zooms in on some viewing modes.
-        0 and 9 also effect the camera in some viewing modes.
-        ctrl+T = toggle team indicators on/off
-        ctrl+H = toggle healthbar indicators on/off
-        Also, if some controllers are set to keyboard, customizable
-        buttons may cause ship actions.  Be default these are:
-        Config 0:
-                left:   Keypad 4
-                thrust: Keypad 8
-                right:  Keypad 6
-                fire:   Quote (")
-                special:Semicolon (;)
-                next:   Closebrace (])
-                prev:   Openbrace ([)
-                near:   P
-        Config 1:
-                left:   A
-                thrust: S
-                right:  D
-                fire:   B
-                special:V
-                next:   F
-                prev:   G
-                near:   H
-Extended Menu:
-	Play Game:
-               Same as "Melee" now
-	Key Tester:
-               Use this utility to check keys combination for conflicts.
-	Ship Info:
-		Here you can get detail information about every 
-             ship in the game.
-	Diagnostic:
-                Show comlile options and version information. 
-	Main Menu:
-                This returns to the main menu.
-		
-Teams:
-        Select Controller:
-                Select the player (i.e. "Player 1" or "Player 2")
-              you wish to alter from the list on the left, and
-              the controller (i.e. "Keyboard", "MoronBot") you
-              want to control that player from the list on the
-              left.  Then either click on the "Select
-              Controller" button or double click on the
-              controller name.
-	Change Team #: 
-	        This switches the player allys. 
-	      Note that team 0 mean no allys.
-        Change Config #:
-                 This switches the configuration used by the
-               currently highlighted controller.  
-        Edit Configuration:
-                 This is used to setup up keys when the currently
-               highlighted player is using the keyboard.  It
-               may eventually allow the configuration of AIs
-               and calibration of joysticks.
-        Edit Fleet:
-                 This button brings up the fleet selection menu for
-               the currently highlighted player.  
-        Main Menu:
-                 This returns to the main menu.
-Options:
-        Most things on this menu are self-explanatory, but a few
-          need special mention.
-
-        Gamma correction:
-                This makes things brighter during combat.  This
-                  should not be changed from the middle of combat,
-                  or colors could get weird.  
-        Antialiasing:
-                If this box is checked then TimeWarp will use
-                  higher quality graphics, but run slower.  
-        Color Depth:
-                You cannot change this from the middle of combat.  
-        Camera Mode:
-                This allows you to control what is shown on your
-                  screen in combat.  
-
-                "Enemy_Discrete"
-                  is just like Star Control on the PC, where
-                  the camera moved to keep both you and your
-                  enemy onscreen, and zoomed in by factors of
-                  2.
-                "Enemy"
-                  is like Star Control on the Genesis or 3DO,
-                  where the camera zoomed in smoothly.
-                "Hero"
-                  makes the camera stay focused on Player 1,
-                  and zoom in/out when + and - are pressed.
-                "Everything"
-                  makes the camera stay on the planet and zoom
-                  way out so that everything is visible.  This
-                  mode is slightly buggy (visual artifacts).  
-</pre>
-</p>
-
-<h2>Development</h2>
-<p>
-  <ul>
-	<li>Introduce the most interesting and cool TimeWarp ships</li>
-	<li>Simplify and fix melee engine</li>
-	<li>Add TimeWarp Markup Language (TML) support</li>
-	<li>Write plot</li>
-	<li>Implement plot with TML</li>
-  </ul>
-</p>
-
-<h4>Introduce the most interesting and cool TimeWarp ships</h4>
-<p>
-Currently TW-Light includes the following ships:<br>
+<h3 align="center">0.3b69 </h3><h2><a class="anchor" name="overview_sec">
+Overview: What is TW-Light?</a></h2>
+TW-Light is an open source clone/sequel to the epic cross-genre game Star Control II. Currently it includes only a combat portion, although epic adventure part that is called TW:Legacies is actively developed now.<h2><a class="anchor" name="getting_started_sec">
+Getting Started</a></h2>
 <ul>
-	<li>Alary Battlecruiser</li>
-	<li>Bipole Katamaran</li>
-	<li>The Chorali Extractor</li>
-	<li>Confed Cargotran</li>
-	<li>Confederation Hornet</li>
-	<li>Djinni Lancer</li>
-	<li>Drax Griffon</li>
-	<li>Earthling Crusader MK2</li>
-	<li>Earthling Crusader MK3</li>
-	<li>Zekfahan Shocker</li>
-	<li>Garash Tyrant</li>
-	<li>Hydrovar</li>
-	<li>Ilwrath Spider</li>
-	<li>Kahr Boomerang</li>
-	<li>Re-Koj Assassin</li>
-	<li>Rogue Squadron</li>
-	<li>Tau Archon</li>
-	<li>Tau Dagger</li>
-	<li>Tau Slider</li>
-	<li>Tau Torrent</li>
-	<li>Zekfahan Shocker</li>
-</ul>
-</p>
-
-<h4>Simplify and fix melee engine</h4>
+<li>Melee: Starts a battle. In battle the following keys do stuff:<ul>
+<li>F1 brings up the help screen (this file, at the moment)</li><li>F2 brings up the options menu</li><li>F3 switches camera focus</li><li>F4 is fast-forward (speeds up in-game time greatly)</li><li>F5 displays fleet status</li><li>F7 changes game tic rate (physics quality)</li><li>F8 changes camera mode</li><li>F9 creates planets (silly "feature")</li><li>F10 quits (so does ESCAPE)</li><li>F11 saves screenshots</li><li>F12 displays framerates / performance data</li><li>- zooms out on some viewing modes.</li><li>+ (or =) zooms in on some viewing modes.</li><li>0 also effect the camera in some viewing modes.</li><li>ctrl+T = toggle team indicators on/off</li><li>ctrl+H = toggle healthbar indicators on/off</li><li>Also, if some controllers are set to keyboard, customizable</li><li>buttons may cause ship actions. Be default these are:</li><li>Config 0:<ul>
+<li>left: Keypad 4</li><li>thrust: Keypad 8</li><li>right: Keypad 6</li><li>fire: Enter</li><li>special:Ctrl</li><li>next: Closebrace (])</li><li>prev: Openbrace ([)</li><li>near: P</li></ul>
+</li></ul>
+</li></ul>
 <p>
-  We are working on it.
-</p>
-
-<h4>Add TimeWarp Markup Language (TML) support</h4>
+See ingame help for controls description.<h2><a class="anchor" name="development">
+Development</a></h2>
+Full developer documentation can be produced using doxygen tool.<p>
+Following documents describes some of the issues concerning contributing to TW-Light<ul>
+<li><a class="el" href="coding_page.html">A guide to a few of the wierder issues with programming for TW-Light.</a></li><li><a class="el" href="howto_document.html">Document your code</a></li></ul>
 <p>
-  No progress.
-</p>
-
-<h4>Write plot</h4>
-<p>
-  No progress.
-</p>
-
-<h4>Implement plot with TML</h4>
-<p>
-  No progress.
-</p>
-
-<h2>License</h2>
-
-<p>
-  Copyright (C) 2004 <a href=mailto:yurand at land.ru>Yura Semashko aka Yurand</a><br>
-  Copyright (C) 2001-2004  TimeWarp development team<br>
-<br>
-  This program is free software; you can redistribute it and/or modify <br>
-  it under the terms of the GNU General Public License as published by <br>
-  the Free Software Foundation; either version 2 of the License, or    <br>
-  (at your option) any later version. <br>
-                                          <br>
-  This program is distributed in the hope that it will be useful,<br>
-  but WITHOUT ANY WARRANTY; without even the implied warranty of<br>
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br>
-  GNU General Public License for more details.
-</p>
-
-<h2>Credits</h2>
-<pre>
-
-  TW-Light is derivative work from <a href="http://timewarp.sf.net/">Star Control: TimeWarp</a>
-
-</pre>
-
-
-</div>
+Currently we are working on the following tasks:<p>
+<ul>
+<li>Introduce the most interesting and cool TimeWarp ships</li><li>Simplify and fix melee engine</li><li>Add TimeWarp Markup Language (TML) support</li><li>Write plot</li><li>Implement plot with TML</li></ul>
+<h3><a class="anchor" name="intoro">
+Introduce the most interesting and cool TimeWarp ships</a></h3>
+Currently TW-Light includes the following ships:<p>
+<ul>
+<li>Alary Battlecruiser</li><li>Bipole Katamaran</li><li>The Chorali Extractor</li><li>Confed Cargotran</li><li>Confederation Hornet</li><li>Drax Griffon</li><li>Earthling Crusader MK3</li><li>Zekfahan Shocker</li><li>Garash Tyrant</li><li>Ilwrath Spider</li><li>Kahr Boomerang</li><li>Re-Koj Assassin</li><li>Rogue Squadron</li><li>Tau Archon</li><li>Tau Dagger</li><li>Tau Slider</li><li>Tau Torrent</li><li>Zekfahan Shocker</li></ul>
+<h3><a class="anchor" name="simplyfy_subsec">
+Simplify and fix melee engine</a></h3>
+Almost done.<h3><a class="anchor" name="TML_subsec">
+Add TimeWarp Markup Language (TML) support</a></h3>
+No progress.<h3><a class="anchor" name="plot_subsec">
+Write plot</a></h3>
+The Plot is fully writen.<h3><a class="anchor" name="plot_impl_subsec">
+Implement plot with TML</a></h3>
+No progress.<h2><a class="anchor" name="licene_sec">
+License</a></h2>
+Copyright (C) 2004 <a href="mailto:yurand at land.ru">Yura Semashko aka Yurand</a> Copyright (C) 2001-2004 TimeWarp development team<p>
+This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.<p>
+This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.<h2><a class="anchor" name="credits_sec">
+Credits</a></h2>
+<ul>
+<li>TW-Light is derivative work from <a href="timewarp.sourceforge.net">Star Control: TimeWarp</a></li><li>Some code and documents were taken from <a href="www.wesnoth.org">Battle for Wesnoth</a></li><li>UQM Ships description were taken from Ultronomicon (<a href="http://uqm.stack.nl/wiki/">http://uqm.stack.nl/wiki/</a>)</li><li>Some battle music were written by Robeter Productions Inc. </li></ul>
+<hr size="1"><address style="align: right;"><small>Generated on Mon Sep 27 22:11:45 2004 for TW-Light by
+<a href="http://www.doxygen.org/index.html">
+<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
 </body>
-</head>
+</html>

Modified: branches/multiplayer-branch/gamedata/ships/COPYING.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/COPYING.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/COPYING.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,369 +1,370 @@
-
-    Some contents data files may contain content from The Ur-Quan Masters project.
-    Used by permission from Toys For Bob.  The UQM license appears below.
-
-----------------------------------------------------------------------------
-    The Ur-Quan Masters
-    Copyright (C) 1992, 2002 Toys for Bob, Inc.
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be entertaining,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.  A copy of the
-    General Public License is included at the end of this document.
-
-    The content -- voiceovers, dialogue, graphics, and music -- are
-    copyright (C) 1992, 1993, 2002 Toys for Bob, Inc. or their
-    respective creators.  The content may be copied freely as part of
-    a distribution of The Ur-Quan Masters.  All other rights are reserved.
-
-    (Side Note: The content will become more freely redistributable
-     and reusable in later releases.)
-
-----------------------------------------------------------------------------
-
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year  name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.
+    Some contents text files may contain content from Ultronomicon (http://uqm.stack.nl/wiki/)
+    
+    Some contents data files may contain content from The Ur-Quan Masters project.
+    Used by permission from Toys For Bob.  The UQM license appears below.
+
+----------------------------------------------------------------------------
+    The Ur-Quan Masters
+    Copyright (C) 1992, 2002 Toys for Bob, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be entertaining,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.  A copy of the
+    General Public License is included at the end of this document.
+
+    The content -- voiceovers, dialogue, graphics, and music -- are
+    copyright (C) 1992, 1993, 2002 Toys for Bob, Inc. or their
+    respective creators.  The content may be copied freely as part of
+    a distribution of The Ur-Quan Masters.  All other rights are reserved.
+
+    (Side Note: The content will become more freely redistributable
+     and reusable in later releases.)
+
+----------------------------------------------------------------------------
+
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.

Deleted: branches/multiplayer-branch/gamedata/ships/shpalabc.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpalabc.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpalabc.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpalabc.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,50 +1,39 @@
-Alary Battlecruiser (v.2.3)
-===========================
-
-Weapon:
--------
-Heavy "fire and forget" MIRV torpedo. The torpedo is extremely slow though
-(even warheads have lower-than-average velocity).
-
-Note: Torpedo itself will not do damage on collisions (only launched warheads will). 
-
-Turrets:
---------
-Press "special" to turn them on or off (look in the upper-right corner
-of the "captain screen" to see current state). When on, turrets will
-automatically shoot on possible targets in range. Priority list is
-(descending): your target, any enemy ship, non-damaging things,
-heavy shots.
-
-Note: Turrets can be damaged (disabled).
-
-Engines:
---------
-
-Note: Engines can be damaged, crippling an already slow ship.
-
-Shield:
--------
-Automatic absorbance shield can block most of the incoming damage.
-Does not work when/if overloaded by continuous heavy fire.
-The shield status indicator is located in the upper-left corner
-of the "captain screen"
-
-Note: Shield does cover turrets and engines.
-
-
-Quirk #1:
----------
-Damage (even direct) cut in half (to make this ship really tough
-without going over 42 crew (for aesthetic reasons)).
-
-Quirk #2:
----------
-"Slow death" (beware of turret fire).
-
-
------------------------------------
-*Tau* <twships at tau137.com>
-
-
-Last updated on 31 Jan 2003.
+Alary Battlecruiser (v.2.3)
+===========================
+
+Weapon:
+-------
+Heavy "fire and forget" MIRV torpedo. The torpedo is extremely slow though (even warheads have lower-than-average velocity).
+
+Note: Torpedo itself will not do damage on collisions (only launched warheads will). 
+
+Turrets:
+--------
+Press "special" to turn them on or off (look in the upper-right corner of the "captain screen" to see current state). When on, turrets will automatically shoot on possible targets in range. Priority list is (descending): your target, any enemy ship, non-damaging things, heavy shots.
+
+Note: Turrets can be damaged (disabled).
+
+Engines:
+--------
+
+Note: Engines can be damaged, crippling an already slow ship.
+
+Shield:
+-------
+Automatic absorbance shield can block most of the incoming damage. Does not work when/if overloaded by continuous heavy fire. The shield status indicator is located in the upper-left corner of the "captain screen"
+
+Note: Shield does cover turrets and engines.
+
+
+Quirk #1:
+---------
+Damage (even direct) cut in half (to make this ship really tough without going over 42 crew (for aesthetic reasons)). 
+
+Quirk #2:
+---------
+"Slow death" (beware of turret fire).
+
+
+-----------------------------------
+*Tau* <twships at tau137.com>
+

Deleted: branches/multiplayer-branch/gamedata/ships/shpandgu.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpandgu.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpandgu.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpandgu.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,27 +1,3 @@
-The Androsynth Guardian is one of the original ships
-from Star Control 1.  They were on the Hierarchy side.  
+The Androsynth Guardians main weapon fires acid bubbles that slowly home in on enemies using the Chaos(tm) tracking system.  
 
-The Androsynth Guardians main weapon fires acid
-bubbles that slowly home in on enemies using the
-Chaos(tm) tracking system.  
-
-It's special weapon transforms it into a flaming comet,
-which is extremely fast and maneuverable, and inflicts
-damage upon impact.  
-
-
-Androsynth are modified humans.  They have numbers in
-their names, and are frequently clones, and are
-heavily genetically modified.  They have a history of
-being oppressed by the rest of humankind, and hate
-humans as a result.  Androsynth seem to be much more
-technologically advanced than normal humans.  
-
-In Star Control 2, the Androsynth were apparently dead
-before the game started ; their homeworld showed signs
-of some horrific struggle, strongly reminiscent of the
-writtings of science fiction / horror author Howard
-Philips Lovecraft III.
-The implication is that all Androsynch were killed (or
-worse) by the Orz or some race related to the Orz.  
-
+It's special weapon transforms it into a flaming comet, which is extremely fast and maneuverable, and inflicts damage upon impact.  
\ No newline at end of file

Deleted: branches/multiplayer-branch/gamedata/ships/shparisk.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shparisk.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shparisk.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shparisk.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,28 +1,50 @@
-The Arilou Skiff is one of the original ships from
-Star Control 1.  They were on the Alliance side.  
+Overview
 
-The Arilou Skiffs main weapon is a short range
-auto-aiming laser.  
+After the discovery of relativity by German-American physicist Albert Einstein in the early 20th century, Terran scientists were disappointed to discover that conventional physics cannot allow normal objects to travel faster than light in TrueSpace. Even after the discoveries of FTL (faster-than-light) technology and HyperSpace travel (thanks to the aid of the Chenjesu), they again encountered a second stumbling block on the limit of power produced by an engine. "If only we could control inertia...," the scientists complained again and again. Enter the Arilou Lalee'lay Skiff.
 
-It's special weapon is a short range hyperspace shunt
-(random teleport).
+Utilized mainly as a means of conveyance in TrueSpace and piloted by the pacifistic Arilou, the blue saucer-shaped Skiff is designed mainly for exploratory missions and boasts minimal defensive weaponry, but it has one envious quality: an inertialess drive.
 
-Arilou ships are extremely maneuverable, and contain
-advanced inertialess drives that stop the ship instantly
-when it stops thrusting.  
 
-Discrepancy: In SC1 & SC2, Arilou Skiffs always auto-aimed
-straight towards their enemy if they had one, otherwise
-straight.  In TimeWarp, where there can be multiple
-enemies, it auto-aims at the closest enemy if one is close,
-or fires straight forward otherwise.  
+Speed and control
 
-Arilou look like little classic aliens: little green men.  
+When not travelling at FTL speeds, the Skiff flies, or rather glides, through TrueSpace at extremely fast speeds (though not as quickly as the nimble Spathi Eluder, nee Discriminator, or Pkunk Fury). Its inertialess drive gives it the smallest turning radius in the galaxy -- 0 m! -- and of course the turning rate itself can't be beat. No inertia also means instant acceleration (and deceleration), as well as no gravitational effects from planetary objects or anything else for that matter! Surprisingly enough, the helm contains no physical controls at all; the captain telepathically controls the ship, thus requiring only a skeleton crew to operate it!
 
-In Star Control 2, the Arilou were mysterious and aloof
-creatures that has been stalking humanity for centuries, 
-and maybe have been involved in the origin of the human
-race.  They expressed special dislike for the Orz.  They
-and the Orz were the two races in SC2 that came from other
-dimensions.  
 
+Armament
+
+Primary
+
+The Skiff's main and only true weapon is a ventral 360-degree short range auto-aiming laser. Meant to simply deter prowlers and pirates from seiging the ship and to surgically cease the roamings of stray space debris, it can be used as an offensive weapon with limited results. Damage is minimal and technique and timing are crucial. Two of the major drawbacks of the targeting system are that:
+
+1. it only tracks the ion trails from warp-drive capable exhaust systems thereby neglecting smaller craft such as Ur-Quan slave ships or Orz marines.
+2. it has a discrete firing pattern, limiting the direction in which it can fire. 
+
+Particular skillful captains are able to minimize the shortcomings of the limited weaponry with carefully-timed firing and cunning tactics.
+
+Secondary
+
+Utilizing the power of the inertialess drive, the secondary armament is a short-range HyperSpace shunt transportation device allowing instantaneous teleportation. While extremely useful in making a quick exit from a heated sortie, the range is limited once again to a single yet significant factor. Range is determined using fourth-dimensional QuasiSpatial movement, which is heavily distorted by FTL sub-spatial harmonics, particularly near starship warp drives. Thus Skiffs hardly have the ability to attempt a long-range teleportation when even a FTL-capable ship as small as a Umgah Drone is nearby. Additionally, the shunt is nearly impossible to guide due to the relatively minute range (on a galactic scale) that the Skiff is able to teleport when such an object is close by. Because of this, undesirable results often occur and, in the small chance of materializing inside of a planetary object or even another ship, can prove to be fatal. However, such catastrophic occurences ar!
 e still extremely rare.
+
+
+Layout and design
+
+Due to the telepathic nature of the Arilou, few conventional devices other than a hull that can withstand TrueSpace and a weak laser are needed to produce the shell of the Skiff. However, the building and implementation of the inertialess drive and the HyperSpace shunt teleporter are beyond current human techonology, not to mention finding a superlative telepathic crew of midgets who can bond to the ship's internal systems. Still, the hull of the Skiff is as simple as it gets: tall enough for a 1.5-meter tall person; and perfectly round for uniform psionic harmonics; and blue -- very, very blue... oh, and headlights. The guts... well, that's a little bit tougher to explain.
+
+Miscellaneous
+
+Tactics
+
+Due to the difficulty in winning a dogfight through brute-force, Arilou captains have been forced to take more clever methods of vanquishing foes. The following are three of the most commonly used methods.
+
+* Gun and run 
+
+Agility and speed are the two strongest attributes of the Skiff. Why not exploit them? Heading directly into enemy fire can be advatangeous given the opponent's barrage is slow enough and the Skiff's captain is nimble enough. Once close enough to the enemy ship, even the directionally-challenged auto-aiming laser can do its job without missing. Leave enough fuel for a quick jump, and >poof< the Skiff is out of harm's way! 
+
+* Planetary ambush 
+
+With no inertia, the Skiff is the only vehicle entirely immune to gravitational effects from nearby planets even when it's sitting right next to it! Letting the bloodlust overcome an adversary's judgment, the perceptive Arilou captain can capitalize on such egregious foolhardiness. Sitting on the far side of the planet as the enemy ship approaces, the opponent cannot both aim accurately and guide his ship to safe course (with some exceptions, eg. the Supox). Seizing such opportunities nets maximal damage to the opponent as he slingshots past the ambushing Skiff without ever having the ability to fire a single shot at the clever Arilou! 
+
+* Cyborg shimmy 
+
+With the reactions of a well-timed computer, an expert Skiff captain can sometimes approach an enemy vessel in a direction that it can't even fire! This feint requires split-second timing at the helm that no human could possibly match! It's even more devastating for the ship captain who can't quite catch his Arilou Lalee'lay opponent off-guard! 
+

Deleted: branches/multiplayer-branch/gamedata/ships/shpbahbu.dat
===================================================================
(Binary files differ)

Deleted: branches/multiplayer-branch/gamedata/ships/shpbipka.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpbipka.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpbipka.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpbipka.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,17 +1,14 @@
-Bipole Katamaran
-
-For a stone-like race. Maybe Taalo...
-
-Primary Weapon:
-  Both sideships have a simple projectile cannon.
-  
-Special:
-  Increases the distance between the sideships (if both exist) or accelerates
-  backwards (if only one of them exists).
-
-Notes:
-  This ship is made up of two 'sideships' each of which can survive the
-  destruction of the other. Their crew and battery is kept track of independently
-  but is shown on the panel summed.
-
- * created by: cyhawk at sch.bme.hu and forevian at freemail.hu
+Bipole Katamaran
+
+For a stone-like race. Maybe Taalo...
+
+Primary Weapon:
+  Both sideships have a simple projectile cannon.
+  
+Special:
+  Increases the distance between the sideships (if both exist) or accelerates backwards (if only one of them exists).
+
+Notes:
+  This ship is made up of two 'sideships' each of which can survive the destruction of the other. Their crew and battery is kept track of independently but is shown on the panel summed.
+
+ * created by: cyhawk at sch.bme.hu and forevian at freemail.hu

Deleted: branches/multiplayer-branch/gamedata/ships/shpchebr.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpchebr.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpchebr.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpchebr.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,18 +1,8 @@
-The Chenjesu Broodhome is one of the original ships
-from Star Control 1.  They were on the Alliance side.
-They were the most powerfull and wise member of the
-Alliance.  
+The Chenjesu Broodhome main weapon fires crystals that keep traveling until you lift the fire button, when they explode into many small fragments.  
 
-The Chenjesu Broodhome main weapon fires crystals
-that keep traveling until you lift the fire button,
-when they explode into many small fragments.  
+It's special weapon launches DOGIs that seek the Chenjesu's target and drain their battery.  
 
-It's special weapon launches DOGIs that seek the
-Chenjesu's target and drain their battery.  
-
 Chenjesu are a crystaline life form.  
 
-In Star Control 2, the Chenjesu were imprisoned on
-their homeworld with the Mmrnmhrmm before the game
-started, slowly transforming into Chmmr.  
+In Star Control 2, the Chenjesu were imprisoned on their homeworld with the Mmrnmhrmm before the game started, slowly transforming into Chmmr.  
 

Deleted: branches/multiplayer-branch/gamedata/ships/shpchmav.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpchmav.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpchmav.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpchmav.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,18 +1,9 @@
-The Chmmr Avatar is one of the original ships
-from Star Control 2.
-
 The ship's main weapon consists of an uberlaser.
 
-Three defense satellites circle the ship. Each is
-equipped with a short-range auto-targeting laser.
+Three defense satellites circle the ship. Each is equipped with a short-range auto-targeting laser.
 
 The special is a tractor beam with unlimited range.
 
-The Chmmr are a race born of two races, the Chenjesu 
-and the Mrmnmhrm, in an attempt to save the latter from 
-extinction.  The Chmmr are immensely powerful, hyper-
-intelligent, and possibly somewhat schizophenic.  
+The Chmmr are a race born of two races, the Chenjesu and the Mrmnmhrm, in an attempt to save the latter from extinction.  The Chmmr are immensely powerful, hyper-intelligent, and possibly somewhat schizophenic.  
 
-The Chmmr were slave-shielded by the Ur-Quan, but 
-when set free provided a valuable contribution to
-the fight for freedom.
\ No newline at end of file
+The Chmmr were slave-shielded by the Ur-Quan, but when set free provided a valuable contribution to the fight for freedom.
\ No newline at end of file

Deleted: branches/multiplayer-branch/gamedata/ships/shpchoex.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpchoex.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpchoex.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpchoex.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,30 +1,30 @@
-The Chorali Extractor
-CrewMax        = 10
-BattMax        = 20
-SpeedMax       = 40
-AccelRate      = 10
-TurnRate       = 2
-I've got the speed/turning set medium/high to compensate for my lack of skill.
-
-Appearance: Currently, it's a shiny gold colored ship.  It's physically large, but that's only because I wanted to have a spinning asteroid as part of the ship.  The front of the ship is flanged outward; this is where the ship's tractor beam comes from.
-
-Weapon: Multi-Use Tractor Beam.  
-Cost: 8 to activate or deactivate prematurely
-Range:6 (from center of ship)
-Time: The Beam lasts for 6000 frames (not sure what that is in seconds, 6?)
-Description:  The Chorali use their tractor beams for just about everything.  They didn't invent the beams, they found the technology on a dead world and replicated it, but they can at least come up with new uses.  First, the beams will draw any matter they come in contact with (currently just ships and asteroids, I tried to get the cargo chain from the confed cargotran to work, but I'm not sure what way would be proper).  The beams also turn any ships they draw, so that they will not continue to fire at the Extractor (watch out for B.U.T.T. missles). If the object is drawn completely to the Extractor, it will be held stationary (no thrust or turning, fire & special still work) until the beam's duration is done.  If the fire button is pressed while an asteroid is held, the asteroid is lobbed at high velocity towards the current target.  Weak long range tractor beams will occasionally correct the trajectory of the missile. 
-[AsteroidMissile]
-Range    = 60
-Velocity = 80
-Damage   = 2
-Armour   = 1
-TurnRate = 2
-The beams will also push away any objects that the onboard computer thinks are dangerous.  Currently, the only homing missiles it can keep at bay are Mycon plasmoids and Khor-Ah blades.
-
-
-Special:  Planet-Fall.
-Cost: 1
-Rate: 0
-The Chorali have discovered that their tractor beams can also be used on nearby planets with surpising success.  If the beams are not focused, they will draw the ship towards the planet.  Used in combination with the main weapon, the Extractor can force enemy ships to crash into the planet.
-
-Quirk: If the highly focused beams of the main weapon are used on the planet, chunks of matter are lifted from the planet, making asteroids (of a non-regenerating type, to keep the amount of permanent asteroids to a minimum).
+The Chorali Extractor
+CrewMax        = 10
+BattMax        = 20
+SpeedMax       = 40
+AccelRate      = 10
+TurnRate       = 2
+I've got the speed/turning set medium/high to compensate for my lack of skill.
+
+Appearance: Currently, it's a shiny gold colored ship.  It's physically large, but that's only because I wanted to have a spinning asteroid as part of the ship.  The front of the ship is flanged outward; this is where the ship's tractor beam comes from.
+
+Weapon: Multi-Use Tractor Beam.  
+Cost: 8 to activate or deactivate prematurely
+Range:6 (from center of ship)
+Time: The Beam lasts for 6000 frames (not sure what that is in seconds, 6?)
+Description:  The Chorali use their tractor beams for just about everything.  They didn't invent the beams, they found the technology on a dead world and replicated it, but they can at least come up with new uses.  First, the beams will draw any matter they come in contact with (currently just ships and asteroids, I tried to get the cargo chain from the confed cargotran to work, but I'm not sure what way would be proper).  The beams also turn any ships they draw, so that they will not continue to fire at the Extractor (watch out for B.U.T.T. missles). If the object is drawn completely to the Extractor, it will be held stationary (no thrust or turning, fire & special still work) until the beam's duration is done.  If the fire button is pressed while an asteroid is held, the asteroid is lobbed at high velocity towards the current target.  Weak long range tractor beams will occasionally correct the trajectory of the missile. 
+[AsteroidMissile]
+Range    = 60
+Velocity = 80
+Damage   = 2
+Armour   = 1
+TurnRate = 2
+The beams will also push away any objects that the onboard computer thinks are dangerous.  Currently, the only homing missiles it can keep at bay are Mycon plasmoids and Khor-Ah blades.
+
+
+Special:  Planet-Fall.
+Cost: 1
+Rate: 0
+The Chorali have discovered that their tractor beams can also be used on nearby planets with surpising success.  If the beams are not focused, they will draw the ship towards the planet.  Used in combination with the main weapon, the Extractor can force enemy ships to crash into the planet.
+
+Quirk: If the highly focused beams of the main weapon are used on the planet, chunks of matter are lifted from the planet, making asteroids (of a non-regenerating type, to keep the amount of permanent asteroids to a minimum).

Deleted: branches/multiplayer-branch/gamedata/ships/shpconca.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpconca.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpconca.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpconca.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,28 +1,28 @@
-Ship		- Confed Cargotran
-Class		- Commercial cargo tug
-Crew		- 6
-Battery		- 4
-Acceleration	- Awe-inspiring
-Turning		- Average
-Top speed	- Slower than an Earthling Cruiser
-Creator		- Corona688, tsm at accesscomm.ca
-
-Weapons:
- Primary 	- Weak short-range laser
- Secondary	- Decelerate, straightens out the chain
- Teritary	- fire + special, ditch the cargo
-
-Weaknesses:	This is NOT a military vessel, and is not meant to
- enter combat.  It's single weapon is only really meant to crack
- asteroids.  Even worse, the structural integrity field used to
- chain the cargo containers behind it means that any damage on them is 
- transferred to the tug.  If forced to enter combat, the captain's
- only recourse is to ditch the cargo entirely and take refuge in the
- slowly growing cloud of containers.
-
-Strengths:	No military strengths.
-
-Quirks:		Although the tug itself has terrific acceleration, this
- is more than offset by the kilotons of cargo it tows.  If caught in a
- gravity well, the cargo can easily haul the whole mess into the planet
+Ship		- Confed Cargotran
+Class		- Commercial cargo tug
+Crew		- 6
+Battery		- 4
+Acceleration	- Awe-inspiring
+Turning		- Average
+Top speed	- Slower than an Earthling Cruiser
+Creator		- Corona688, tsm at accesscomm.ca
+
+Weapons:
+ Primary 	- Weak short-range laser
+ Secondary	- Decelerate, straightens out the chain
+ Teritary	- fire + special, ditch the cargo
+
+Weaknesses:	This is NOT a military vessel, and is not meant to
+ enter combat.  It's single weapon is only really meant to crack
+ asteroids.  Even worse, the structural integrity field used to
+ chain the cargo containers behind it means that any damage on them is 
+ transferred to the tug.  If forced to enter combat, the captain's
+ only recourse is to ditch the cargo entirely and take refuge in the
+ slowly growing cloud of containers.
+
+Strengths:	No military strengths.
+
+Quirks:		Although the tug itself has terrific acceleration, this
+ is more than offset by the kilotons of cargo it tows.  If caught in a
+ gravity well, the cargo can easily haul the whole mess into the planet
  unless the captain jettisons it immediately.
\ No newline at end of file

Deleted: branches/multiplayer-branch/gamedata/ships/shpconho.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpconho.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpconho.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpconho.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,56 +1,56 @@
-Ship          - Confederation Hornet
-Class         - Medium Range Light Fighter
-crew          - 1
-battery       - 10
-accelleration - Good
-Turning       - Very Good
-Top Speed     - Very Good
-
-Weapons
- Primary   - Dual Ball Laser Cannons
- Secondary - Torpedoes (Direct Damage Missles, Slightly Homing)
-
-Extra - Recharging Shield
- Can absorb 8 points of damage, readout in crew-bar
-
-Limitations
- - killed instantly by any direct damage
-   - current known direct damages include :
-     - running into a planet
-     - Orz Marines
-     - Narool Acid
-     - *NEW* Torpedoes
-
-Strong-Points
- - Extremely Manouverable, an excellent pilot can challenge any ship in space
- - Strong destructive capability for a light fighter (lasers do 1 damage each, Torpedoes do 4)
- - Recharging Shield + High Manouverability = longer life, there is no suffering from length in battle
- - Perfect for circling enemies.
-
-/**************************************************************************************/
-03/02/2001
-  - corrected minor bug (i was 1 pixle off when blitting shield pictures)
-  - changed colors around ship in panel to all blue shades
-
-/**********/
-
-03/01/2001
-Torpedoes Implimented
-  - still 4 damage, but now split across normal and direct, (3 and 1 respectively)
-
-Shield Indicator Overlay Implimented
-  - Displays a color around the ship in the panel indicating how your shield is faring.
-
-mshppan.cpp updated to solve a problem with graphic artifacts being left when a hornet's dying, fixed now - if there are any side affects let me know.
-
-/**********/
-
-02/27/2001
-  - Shield indicator bar all blue now.
-  - added homing to missles.
-  - Minor initialization changes to strenthen ship. (not truly necessary in my opinion)
-
-/**********/
-
-02/26/2001
+Ship          - Confederation Hornet
+Class         - Medium Range Light Fighter
+crew          - 1
+battery       - 10
+accelleration - Good
+Turning       - Very Good
+Top Speed     - Very Good
+
+Weapons
+ Primary   - Dual Ball Laser Cannons
+ Secondary - Torpedoes (Direct Damage Missles, Slightly Homing)
+
+Extra - Recharging Shield
+ Can absorb 8 points of damage, readout in crew-bar
+
+Limitations
+ - killed instantly by any direct damage
+   - current known direct damages include :
+     - running into a planet
+     - Orz Marines
+     - Narool Acid
+     - *NEW* Torpedoes
+
+Strong-Points
+ - Extremely Manouverable, an excellent pilot can challenge any ship in space
+ - Strong destructive capability for a light fighter (lasers do 1 damage each, Torpedoes do 4)
+ - Recharging Shield + High Manouverability = longer life, there is no suffering from length in battle
+ - Perfect for circling enemies.
+
+/**************************************************************************************/
+03/02/2001
+  - corrected minor bug (i was 1 pixle off when blitting shield pictures)
+  - changed colors around ship in panel to all blue shades
+
+/**********/
+
+03/01/2001
+Torpedoes Implimented
+  - still 4 damage, but now split across normal and direct, (3 and 1 respectively)
+
+Shield Indicator Overlay Implimented
+  - Displays a color around the ship in the panel indicating how your shield is faring.
+
+mshppan.cpp updated to solve a problem with graphic artifacts being left when a hornet's dying, fixed now - if there are any side affects let me know.
+
+/**********/
+
+02/27/2001
+  - Shield indicator bar all blue now.
+  - added homing to missles.
+  - Minor initialization changes to strenthen ship. (not truly necessary in my opinion)
+
+/**********/
+
+02/26/2001
 First release, most features implimented
\ No newline at end of file

Deleted: branches/multiplayer-branch/gamedata/ships/shpdragr.dat
===================================================================
(Binary files differ)

Deleted: branches/multiplayer-branch/gamedata/ships/shpdruma.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpdruma.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpdruma.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpdruma.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,21 +1,19 @@
+ General Overview
 
-The Druuge Mauler is one of the original ships
-from Star Control 2.
+One of the single most troublesome ships in the game. The Mauler is slow, ungainly reactions make it a difficult ship to play with. Mastering the correct usage of the high-recoil cannon is not easy and the slow battery regeneration turns the Mauler into a vulnerable ship. To compensate for the Mauler's weak battery recharging, Druuge captains have been known to order lower-ranking crew members to be thrown into the furnace. Yet, when correctly used against certain ships, the Mauler can prove a deadly adversary. Correct usage of recoil effects would allow for great targeting and quick evasion.
 
-The Druuge Mauler is essentially a flying long range
-cannon. The projectiles it fires have some mass,
-which provide backwards momentum for the Druuge and
-the enemy ships.
+Main Weapon: High-Recoil Cannon
 
-The special is somewhat gruesome - the Druuge throw
-their crew into their nuclear furnaces to create
-instantaneous battery reserve.
+Takes four points of battery and does six points of damage. The high-recoil cannon's fast shots can pummel an unwary enemy from long distance. The recoil itself can propel the Mauler into ?hyperspacing speed? which can be a double-edged sword. The recoil-effect, combined with the Furnace, nominate the Mauler as one of the few ships that are actually DANGEROUS to a Chmmr Avatar. Aiming takes a while to master but the shots are hard to evade.
 
-The Druuge are a race living in a dystopian 
-corporate society, with an emphasis on trade, 
-profit, and cruelty.  
+Special System: The Furnace
 
-The Druuge trade slaves, fuel and artifacts. They
-were responsible for the death of the Gg in order
-to save their own skin when the Kohr-Ah approached.
+At first, this appears to be the single most useless special system available. Throwing a crewman into the furnace to fill half-way of the battery. But when thinking of the possible action ? The Mauler actually never runs out of battery power. This is especially useful against the Avatar where you can use the high-recoil cannon and the supply of battery power to keep out of the Avatar's Tractor-and-Laser tactic, pummeling it to dust. Other than that, it is recommended that you be as cheap as possible on throwing people into the furnace.
 
+Tactical Overview
+
+The Mauler is a very specific ship. It has its advantages only versus specific ships. It is very vulnerable.
+
+Strong against: Chmmr Avatar. Shofixti Scout - The high-recoil would allow the Mauler to stay out of the Glory Device?s range and it only needs one hit to send the Scout to hell. The Ilwrath Avenger will have a hard time against it too. When flown really masterfully it can also tear ships such as the Earthling (Humans) Cruiser apart.
+
+Weak Against: Whoa. What not? The Marauder's spinning blades, the Arilou Skiff can easily lay an ambush, the VUX Limpets, The Slylandro Probe and Pkunk Fury speed. The X-form?s long-range missiles, the Kzer-za Dreadnought]?s fighters, Chenjesu Broodhome DOGIs, the Orz Nemesis marines and the Mycon Podship Can easily wear-down the crew complement. The Utwig Jugger loves meeting the Mauler in battle. 
\ No newline at end of file

Deleted: branches/multiplayer-branch/gamedata/ships/shpearc3.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpearc3.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpearc3.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpearc3.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,24 +1,24 @@
-EARTHLING CRUISER MK3
-
-This ship represents yet another attempt to make a worthy "new generation" Earthling ship.
-Started a along time ago, it would never be competed if it was not for Starwreck, which
-inspired that last effort needed to bring this ship to life.  And, sure enough, this attempt
-brings the Earthling Cruiser a step or two closer to its 'Treck predecessors (which is not
-necessarily a bad thing).
-
-Primary weapon on this ship is the proton torpedo launcher, capable of firing highly destructive
-projectiles at long range.  Advanced targeting system automatically tracks all major targets in range
-and calculates optimum firing angle.  However, the launcher itself is limited to a relatively small
-firing arc, and can take some time to aim in on target.  The limited accuracy is an inherited problem
-of all existing proton torpedo launchers.
-
-Secondary weapon system is the short-range point defense laser (PDL).  The beam can be fired
-in short bursts, with some time required to cool down the emitter.   Each burst is automatically
-aimed at the nearest non-friendly object.  If the object is destroyed or is out of range, PDL can
-quickly acquire a new target.  This weapon is especially effective against projectile weapons.
-----------------------------
-
-
-*Tau* <twships at tau137.com>
-
-30 Jan 2003
+EARTHLING CRUISER MK3
+
+This ship represents yet another attempt to make a worthy "new generation" Earthling ship.
+Started a along time ago, it would never be competed if it was not for Starwreck, which
+inspired that last effort needed to bring this ship to life.  And, sure enough, this attempt
+brings the Earthling Cruiser a step or two closer to its 'Treck predecessors (which is not
+necessarily a bad thing).
+
+Primary weapon on this ship is the proton torpedo launcher, capable of firing highly destructive
+projectiles at long range.  Advanced targeting system automatically tracks all major targets in range
+and calculates optimum firing angle.  However, the launcher itself is limited to a relatively small
+firing arc, and can take some time to aim in on target.  The limited accuracy is an inherited problem
+of all existing proton torpedo launchers.
+
+Secondary weapon system is the short-range point defense laser (PDL).  The beam can be fired
+in short bursts, with some time required to cool down the emitter.   Each burst is automatically
+aimed at the nearest non-friendly object.  If the object is destroyed or is out of range, PDL can
+quickly acquire a new target.  This weapon is especially effective against projectile weapons.
+----------------------------
+
+
+*Tau* <twships at tau137.com>
+
+30 Jan 2003

Deleted: branches/multiplayer-branch/gamedata/ships/shpearcr.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpearcr.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpearcr.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpearcr.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,15 +1,6 @@
-The Earthling Cruiser is one of the original ships
-from Star Control 1.  They were on the Alliance side.
-Earthlings, needless to say, are humans.  
+The Earthling Cruiser is a slow vessel with a devastating arsenal of weapons. A Cruiser can hold its own against other ships as long as it maintains a safe distance from its opponent.
 
-The main weapon is very long range nuclear missiles
-that home in on enemies.  (surplus MX missiles)
+The Cruiser's primary weapon is a guided nuclear missile. The missile's tracking is not perfect, but it's fairly accurate and will do a good amount of damage unless the enemy can shield itself upon impact or shoot down the missile.
 
-It's special weapon fires point defense lasers at
-nearby objects.  (surplus SDI systems)
+The Cruiser's alternate weapon is a point-defense laser system, based on mid-1980s "Star Wars" missile defense technology, that fires lasers at enemy ships, projectiles, asteroids, or anything else that is close to the Earthling ship. 
 
-
-In Star Control 2, most earthlings were imprisoned on
-Earth, but you, the player, were a rogue Earthling in
-a spaceship that was an ancient alien artifact 100,000
-years old.  

Deleted: branches/multiplayer-branch/gamedata/ships/shpforsh.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpforsh.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpforsh.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpforsh.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,22 +1,22 @@
-----------------
-Zekfahan Shocker
-----------------
-
-The primary is the same but the graphics made it necessary
-to put the guns closer. If you think this a major drawback,
-I might redesign it to feature the original barrel distances.
-
-The secondary now is a chain lightning weapon. It will bounce
-towards every non-planet object after a hit, including the
-shocker itself. It does a reducing amount of damage with
-each bouncing, and the shocker is immune to its shot.
-
-Thanks for Richardyzo for allowing me to rework his ship idea.
-(I've done it because the original one had some copyright
-issues with StarCraft.)
-
-I'd like to thank "the coder" also for doing me this job.
-
-Have fun with the new Shocker! Richardyzo, I hope you enjoy it!
-
-	Forevian
+----------------
+Zekfahan Shocker
+----------------
+
+The primary is the same but the graphics made it necessary
+to put the guns closer. If you think this a major drawback,
+I might redesign it to feature the original barrel distances.
+
+The secondary now is a chain lightning weapon. It will bounce
+towards every non-planet object after a hit, including the
+shocker itself. It does a reducing amount of damage with
+each bouncing, and the shocker is immune to its shot.
+
+Thanks for Richardyzo for allowing me to rework his ship idea.
+(I've done it because the original one had some copyright
+issues with StarCraft.)
+
+I'd like to thank "the coder" also for doing me this job.
+
+Have fun with the new Shocker! Richardyzo, I hope you enjoy it!
+
+	Forevian

Deleted: branches/multiplayer-branch/gamedata/ships/shpgarty.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpgarty.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpgarty.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpgarty.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,32 +1,32 @@
-Ship          - Garash Tyrant
-Class         - Behemoth
-crew          - 42
-battery       - 42
-acceleration  - Poor
-Turning       - Very Good
-Top Speed     - Average
-
-Weapons
- Primary   - Charging weapon (damage depending on charge)
-  Stage 1: acts as shield and good at ramming
-  Stage 2: can be released.
-  Stage 3: same as stage two but a little bit powerful.
- Secondary - Repulsar wave  
-  Knockbacks opponent.
-  Knockouts control over ship at a very limited time.
-  Inflicts a modest damage.
-
-Weaknesses
- Slow rate of fire
- Cannot shoot at whim (there's a minimum charge required to shoot)
- Cannot hold on to the shot indefinitely (auto released at some max time   limit)
- Very big ship (easy to hit with high armored shots)
- 
- 
-Strenghts
- Good at long range.
- Good defense vs low armoured shots.
- Good at pillboxing tactics.
- Very good versus low range ships.
- Very powerful shot (absorbs everything or any other form of shots!)
-
+Ship          - Garash Tyrant
+Class         - Behemoth
+crew          - 42
+battery       - 42
+acceleration  - Poor
+Turning       - Very Good
+Top Speed     - Average
+
+Weapons
+ Primary   - Charging weapon (damage depending on charge)
+  Stage 1: acts as shield and good at ramming
+  Stage 2: can be released.
+  Stage 3: same as stage two but a little bit powerful.
+ Secondary - Repulsar wave  
+  Knockbacks opponent.
+  Knockouts control over ship at a very limited time.
+  Inflicts a modest damage.
+
+Weaknesses
+ Slow rate of fire
+ Cannot shoot at whim (there's a minimum charge required to shoot)
+ Cannot hold on to the shot indefinitely (auto released at some max time   limit)
+ Very big ship (easy to hit with high armored shots)
+ 
+ 
+Strenghts
+ Good at long range.
+ Good defense vs low armoured shots.
+ Good at pillboxing tactics.
+ Very good versus low range ships.
+ Very powerful shot (absorbs everything or any other form of shots!)
+

Deleted: branches/multiplayer-branch/gamedata/ships/shpilwav.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpilwav.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpilwav.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpilwav.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,6 +1,3 @@
-The Ilwrath Avenger is one of the original ships
-from Star Control 1.  They were on the Hierarchy side.
-
 The Avengers main weapon spouts short range hellfire
 in front of the ship.
 
@@ -11,10 +8,3 @@
 Discrepancy: cloaking in TimeWarp is much more powerfull
 than in SC1/2 because the camera position does not
 reveal their position.  
-
-Ilwrath look like spiders.  In SC1 they have 5 legs, in
-SC2 8 legs.  
-
-In Star Control 2, Ilwrath are depicted as the ultimate
-in villany and cruelty, but not very powerfull.  
-

Deleted: branches/multiplayer-branch/gamedata/ships/shpilwsp.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpilwsp.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpilwsp.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpilwsp.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,16 +1,16 @@
-Ilwrath Spider
-
-During the war against the Traddash the Ilwrath could salvage some Traddash
-technology and came out with this new prototype. (non-official concept)
-
-Primary Weapon:
-  Improved dual version of the original flamethrowers partially based on the Torch's
-  after burners.
-  
-Special:
-  Strange smoke that stops everything for a small amount of time. Even projectiles.
-  The smoke completly adsorbs laser.
-
- * created by: DOS and cyhawk at sch.bme.hu and forevian at freemail.hu
- * thank for the folks at Shipboard for suggesting some elements -- I don't
+Ilwrath Spider
+
+During the war against the Traddash the Ilwrath could salvage some Traddash
+technology and came out with this new prototype. (non-official concept)
+
+Primary Weapon:
+  Improved dual version of the original flamethrowers partially based on the Torch's
+  after burners.
+  
+Special:
+  Strange smoke that stops everything for a small amount of time. Even projectiles.
+  The smoke completly adsorbs laser.
+
+ * created by: DOS and cyhawk at sch.bme.hu and forevian at freemail.hu
+ * thank for the folks at Shipboard for suggesting some elements -- I don't
    remember their name and right now I'm lazy to check the topic
\ No newline at end of file

Deleted: branches/multiplayer-branch/gamedata/ships/shpkahbo.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpkahbo.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpkahbo.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpkahbo.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,12 +1,12 @@
-Kahr Boomerang
-
-This ship has characteristics close to the Yehat Terminator.
-
-Weapon (3)
-Press Special to select (can be done at any time)
-
-Small boomerang : 1 damage that bounces of ships, short range. No limit.
-Medium boomerang : 3 damage, long range (otherwise same as small). limit 4.
-Large boomerang : 5 damage, controlable range, when you release fire will return.  If turning ship when released it will turn in rotation direction of ship.  Also industuctable like Kohr-ah FIRED system. Limit 1
-
+Kahr Boomerang
+
+This ship has characteristics close to the Yehat Terminator.
+
+Weapon (3)
+Press Special to select (can be done at any time)
+
+Small boomerang : 1 damage that bounces of ships, short range. No limit.
+Medium boomerang : 3 damage, long range (otherwise same as small). limit 4.
+Large boomerang : 5 damage, controlable range, when you release fire will return.  If turning ship when released it will turn in rotation direction of ship.  Also industuctable like Kohr-ah FIRED system. Limit 1
+
 Enjoy
\ No newline at end of file

Deleted: branches/multiplayer-branch/gamedata/ships/shpkohma.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpkohma.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpkohma.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpkohma.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,31 +1,8 @@
+A very powerful vessel rivaling the Kzer-Za Dreadnought. Armed with spinning sawblades and a destructive F.R.I.E.D. system.
 
-The Kohr-Ah Marauder is one of the original
-ships from Star Control 2. They are hostiles.
+The sawblades will travel until the fire button is released, effectively giving them unlimited range. Ideal for placing one in the line of travel of the enemy. The blades come with a short-range homing capability.
 
-The main consists of blades which can travel
-a long way until fire is released. Ideal for
-placing one in the line of travel of the enemy.
-The blades come with a short-range homing
-capability.
+The FRIED aka Fiery Ring of Inevitable, Eternal Destruction is a ring of superheated plasma that expands from the Marauder and F.R.I.E.S. anything in its path. If a FRIED shot and an enemy projectile collide, the FRIED will always win. This property makes them good for defense. Using FRIED consumes half of the maximum battery.
 
-The special is named FRIED (fiery ring of 
-inevitable and eternal destruction).  It spawns 
-a ring of fiery spheres.  If your velocity 
-relative to a target is very high you can 
-sometimes hit the target with many (3 to 5) 
-FRIED shots from a single ring, inflicting 
-substancial damage.  If a FRIED shot and an 
-enemy projectile collide, the FRIED will always 
-win.  This property makes them good for defense.  
-Using FRIED consumes half of the maximum battery.  
+Overall, the Ur-Quan Kohr-Ah Marauder is one of the most powerful ships in the Quadrant.  
 
-They resemble black caterpillars.  
-
-The Kohr-Ah are the black offshoot of the 
-Ur-Quan race. They were bread by the Dnyarri 
-as warriors. The Kohr-Ah philosophy is to 
-"cleanse" the universe of anything that shows 
-signs of intelligence, on the theory that the 
-only viable defense is a preemptive strike.  
-
-

Deleted: branches/multiplayer-branch/gamedata/ships/shpkzedr.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpkzedr.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpkzedr.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpkzedr.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,33 +1,6 @@
-The Ur-Quan Dreadnought is one of the original ships
-from Star Control 1.  They were on the Hierarchy side.
-In fact, they were the founders and masters of the
-Urquan Hierarchy (i.e. the main badguy).  In Star
-Control 2, their name was changed to the Ur-Quan
-Kzer-Za, sometimes called green Urquan, to distinguish
-them from the black urquan, the Ur-Quan Kohr-Ah.  
+The Ur-Quan Kzer-Za Dreadnought is the mainstay of the Hierarchy fleets. A fully-crewed Dreadnought can crush most opponents with ease.
 
-The Dreadnoughts main weapon fires fusion blasts.  It
-fires fairly quickly, does a lot of damage, and has a
-decent range.  
+The Dreadnought's fusion cannon can destroy small ships in one or two hits. Additionally, the Ur-Quan captain can send out small, one-man fighter ships armed with lasers to harass the enemy. Each fighter has only a limited supply of air and fuel and must return to the Dreadnought after several seconds. 
 
-The Dreadnoughts special weapon launches 2 fighter ships
-which seek out enemies and kill them.  These fighters can
-do enourmous damage, but launching them costs crew, which
-is regained when the fighter returns.  
 
-Urquan are green catepillar-like creatures.
 
-In Star Control 2, the Urquan are the guys who imprisoned
-everyone under force shields, so they seem like the badguy.
-But they are much more complex than that.  Urquan are
-mighty, proud, arrogant, kind, masochistic, and ultimately
-tragic.  The Urquan overcame their predatory nature long ago
-to be a part of a mutually beneficial galactic society, but
-a horrific struggle 20,000 years ago destroyed galactic
-civilization and permanently warped the urquans view of the
-universe.  Now they go around enslaving and imprisoning other
-races, with the best of intentions.  Parts of their history are
-reminiscient of the writtings of science fiction author Larry
-Niven.  
-
-

Deleted: branches/multiplayer-branch/gamedata/ships/shpmeltr.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpmeltr.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpmeltr.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpmeltr.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,21 +1 @@
-
-The Melnorme Trader is one of the original ships
-from Star Control 2; neutrals.
-
-The main consists of a light sphere. This can be
-charged to do more damage upon release. When fully
-charged, the weapon sphere can absorb enemy fire
-and act as a small shield.
-
-Special fires some field with long range, which on
-impact puts the enemy into an uncontrollable spin,
-disabling the rotation controls.  This field 
-can pass right through most defenses.  
-
-The Melnorme are cyclopses.  
-
-The Melnorme are neutral traders, apparently without
-a homeworld. They provide a wealth of information
-and technology in exchange for data on lifeforms.
-Their origins are a mystery, they could be
-descendants of the Mael-Num, a Milieu race.
+A large, moderate speed ship with moderate to slow turning. Primary fire is an energy bolt that can be charged up. Low charge doe minimal damage, however a fully charged shot can cause grevious damage. A charging shot can also act as a shield vrs incoming fire. The secondary weapon is a stun shot that causes an effected enemy to spin helplessly. The cannot activate their secondary weapons or their turning jets. They can still activate their primary weapon and thrusters.

Deleted: branches/multiplayer-branch/gamedata/ships/shpmmrxf.dat
===================================================================
(Binary files differ)

Copied: branches/multiplayer-branch/gamedata/ships/shpmmrxf.txt (from rev 69, trunk/gamedata/ships/shpmmrxf.txt)

Deleted: branches/multiplayer-branch/gamedata/ships/shpmycpo.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpmycpo.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpmycpo.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpmycpo.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,26 +1,7 @@
+The Mycon podship is a large medium speed, slow turning ship. It's primary weapon is a slow moving long-range homing plasma burst. It's damage decreases the longer the plasma has been in flight (as the plasma disperses). At short range, damage is very high. At long range, damage is very low. Enemy fire that strikes the plasma disperses it and reduces it's damage potential.
 
-The Mycon Podship is one of the original ships
-from Star Control 1.  They were on the Hierarchy side.
+The secondary ability of the podship is to regrow it's own crew. It is piloted by talking fungi after all!
 
-They formed an important addition to the UQ fleets,
-whom they joined of their free will - accepting that
-the UQ were "inevitable". Their help guaranteed UQ
-victory over Earth defence forces.
+One other notable feature of the podship is it's ability to commit suicide by ramming it's own plasma bursts. Due to the plasma'a low speed, plasma launched in the direction of travel while the ship is at speed stand a good chance of being "over-run" by the ship itself. Due to the high damage of the fresh plasma, this is often fatal. Take extra care when using a gravity whip manuver.
 
-The main consists of a very long range, semi-sentient
-homing plasmoid. This weapon loses power slowly with
-distance. A full battery is just enough for 2 plasmoids.
-
-The special creates new crew, but this drains the whole
-battery.
-
-The Mycon are a fungi like race, living in and on
-steaming hot lava worlds. Their "ships" are probably
-of organic origin. They can quickly produce new
-individuals from spores in a hot radiative environment.
-They have a shared memory, which is somewhat incoherent ;)
-
-The Mycon were mostly important for their hostile
-relation with the Syreen in star control 2.
-
-
+Certain other highly manuverable ships can also cause the plasma to strike the podship that launched it. 
\ No newline at end of file

Deleted: branches/multiplayer-branch/gamedata/ships/shporzne.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shporzne.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shporzne.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shporzne.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,37 +1,21 @@
-The Orz Nemesis is one of the original ships
-from Star Control 2.
+ General Overview
 
-The main weapon consists of a gun turret with 
-mediumrange.
+Always a worthy adversary. Underestimating the Nemesis would likely be the last mistake anyone can ever make. Like its name suggests, the Orz ship is a goddess of revenge, coming to inflict pain and vengeance on the galaxy. The Nemesis is fairly quick and has a fair turn-rate. Never, under any circumstances, chase after the nemesis!
 
-Special allows you to rotate the turret, which is
-not that useful a feature, but looks nice.  You 
-do this by holding down special and pressing the 
-turn buttons.  
+Main Weapon/Special system: Rotating Howitzer
 
-The second special launches Orz space marines,
-which can use a planet's gravity field to achieve
-high velocities and board the enemy; once on board,
-they can kill a random amount of crew. They can
-stay in space indefinitely, but return when the
-target is destroyed.  To launch marines, press 
-both the special key and the fire key at the same 
-time.  
+The Howitzer inflicts deadly damage and its shots are fast and medium-ranged. The rotational turret allows usage as a strafing weapon or as a backwards utilized attacker-repellent.
 
-The Orz are a fish-like creatures, who need the
-safe environment of a space suit to walk around
-in space.
 
-The Orz come from an alien dimension they call
-*below*. They've a suspicious connection to the
-disappearance of the Androsynths. Though the
-story implies that they could pose a big threat,
-they're friendly and of minor importance in the game.
+Special Action: Marines (GoGos)
 
-The Orz are an strange race, with childish sillyness 
-and simplicity, an undercurrent of a Lovecraftian 
-horror theme, and an overall very friendly attitude.  
-It's implied in SC2 that you should be afraid of them, 
-but for practical purposes allying with them is easy, 
-useful, and harmless.  The Arilou seem to particularly 
-dislike the Orz.  
+Using their armored exo-skeleton, Orzine marines exit the ship from the aft portholes and enter an enemy ship by burning a hole in the hull. They then start roaming the enemy ship?s corridors, killing every crewman in sight. Especially useful in large groups, the marines can blast a ship entirely by themselves. Warlike creatures such as Ur-Quan, Chmmr, Yehat and Shofixti usually put up a better resistance than peaceful or cowardly creatures like the Spathi, Chenjesu and Mycon. The marine tactic of using a planet wrap-around slingshot maneuver to gain speed aids them against some ships.
+
+Tactical Overview
+
+A very effective ship that rarely fails.
+
+Strong against: Kzer-Za Dreadnought and to some degree Kohr-Ah Marauder are both in danger. The Chenjesu Broodhome is virtually helpless against the marines as is the VUX Intruder and the Mycon Podship. The marines cling on to the Yehat Terminator until the shield goes down and while they are repelled by the Utwig Jugger Shield, no fuel is gained and so they can be used to take down the Jugger?s shield. Showing the Chmmr Avatar your aft and blasting her with the howitzer is a tricky thing but the Nemesis can break through the tractor beam and as soon as the Zap-sats are down, the Avatar is marine-meat
+
+Weak against: The Pkunk Fury, Slylandro Probe and Arilou Skiff can effortlessly pull out of marine?s grasp and use hit-n-run attacks to whack the unready Nemesis. The Androsynth Guardian is a bit tricky ? if she get stuck without battery she?s Marine-meat but the Comet form destroys marines on impact and the Nemesis?s aft section appears to have been designed exactly to be wedged by a wicked blazer. So long as they manage to evade the marines, The X-form and the Spathi Eluder can pose a pain in the butt to any Nemesis captain. A very hot Shofixti Scout pilot can evade the marines long enough to use a wrap-around slingshot maneuver to catch the Nemesis unaware.
+

Deleted: branches/multiplayer-branch/gamedata/ships/shppkufu.dat
===================================================================
(Binary files differ)

Deleted: branches/multiplayer-branch/gamedata/ships/shprogsq.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shprogsq.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shprogsq.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shprogsq.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,16 +1,16 @@
-
-Rogue Squadron
-
-background:
-
-A rogue squadron of former UQ crew, now lawless scavengers of the universe, a curious mixture of different races in a simple general ship design which is harmless on its own, but can be dangerous in large numbers.
-
-How to use this ship:
-
-main = pulse laser
-
-special = choose formations.
-
-In the ini file, you can edit formations. A formation is a list of x y points relative to the leader ship which you have to give a position (0,0), entered on a single line. The must be exactly as many x y pairs as there are crew members. I use an odd number of crew (11) to make the ships start in a symmetrical pattern around the leader.
-
-In melee, the player controls position (0,0) of the grid, which is indicated by a small arrow. Ships are distributed relative to the player position and angle.
+
+Rogue Squadron
+
+background:
+
+A rogue squadron of former UQ crew, now lawless scavengers of the universe, a curious mixture of different races in a simple general ship design which is harmless on its own, but can be dangerous in large numbers.
+
+How to use this ship:
+
+main = pulse laser
+
+special = choose formations.
+
+In the ini file, you can edit formations. A formation is a list of x y points relative to the leader ship which you have to give a position (0,0), entered on a single line. The must be exactly as many x y pairs as there are crew members. I use an odd number of crew (11) to make the ships start in a symmetrical pattern around the leader.
+
+In melee, the player controls position (0,0) of the grid, which is indicated by a small arrow. Ships are distributed relative to the player position and angle.

Deleted: branches/multiplayer-branch/gamedata/ships/shpshosc.dat
===================================================================
(Binary files differ)

Deleted: branches/multiplayer-branch/gamedata/ships/shpslypr.dat
===================================================================
(Binary files differ)

Deleted: branches/multiplayer-branch/gamedata/ships/shpspael.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpspael.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpspael.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpspael.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,22 +1,28 @@
+Overview
 
-The Spathi Eluder is one of the original ships
-from Star Control 1.  They were on the Alliance side.
+The multi-colored Spathi Eluder, formerly known as the Discriminator, remains bulk of the Spathi fleet even 20 years after the War. Its construction, though seemingly chaotic, is carefully designed to mimic its crew's natural attributes: paranoia, elusiveness, and cowardice.
 
-Their role in sc1:
+Speed and Control
 
-The main weapon is a short range, fast firing,
-cannon. Only to be used in unfortunate close
-encounters!
+The Eluder is one of the fastest ships in the galaxy, both in top speed and acceleration, and has a turning radius an Arilou Lalee'lay would be jealous of. Though agility would be a mighty boon for most brute-force fighter ships, the Eluder is anything but brute... or a force... or even a fighter, for that matter. The fact is the thrusters primary use isn't for speeding into battle, but rather for speeding away from it! From this perspective, the Eluder performs admirably! The helm of the Eluder is quite large and is typically manned by two Spathi at once, but in times of emergency (mainly when he's the only crew member left) the captain usually whips into a adrenaline-filled panicked frenzy and finds the ability to man both halves of the helm nearly simultaneously by himself!
 
-The special consists of BUTT missiles, backward
-utilizing tracking torpedoes. Those are ideal for
-those who are afraid to turn and face their enemies.
-Very effective in combination with the high speed
-of the Eluder.
+Armament
 
-The Spathi are insectoids.
+Primary
 
-In star control 2, the Spathi formed a cowardly
-race, who were very funny ;)
+The Eluder's main weaponary consists of a quick-firing, short-range, low-impact plasma pellet. Great for sneak attacks and guerilla tactics or just to finish off a severely-handicapped adversary (which are the only direct attacks a Spathi would consider), the plasma pellet is otherwise limited in its usefulness.
 
+Secondary
 
+The secondary weaponry epitomizes the essence of true Spathi-ness due to its ability to do the most damage while the Eluder is in full retreat! The Backwards Utility Tracking Torpedo (B.U.T.T.) is a medium-range, low-impact conventional space torpedo with a good automated guidance system and moderate speed and manuevering. Fired from the rear of the craft, B.U.T.T. missiles do most of the dirty work in the dogfights as Eluders make their way away from the fray. Enemy captains foolish enough to think it can run down an Eluder usually end up learning a fatal lesson in space warfare.
+
+Ship Layout and Design
+
+From the outside, the Eluder consists of many bubble-shaped, solid-colored cabins joined together by smaller white corridors. The intention of having so many large seemingly crew-filled projections is in part to obfuscate enemy into targeting the decoy cabins and to direct enemy fire away from the main bridge. However, in practice, enemy weapons seem to incapacitate the same amount of crew no matter where the Eluder is damaged. This is most likely due to the fact that even in the safety of a large starship, the crew is bound to hide in every nook, cranny, and hole the ship has to offer in the case of direct combat. And, unfortunate for the Spathi, there are many of these crannies throughout the ship as it was Spathi engineers who designed it to begin with, making the seemingly crew-filled decoy cabins actually full of petrified crew members. To make matters worse, even the crew itself can be confused by the ship layout. In fact, the random cabin configuration has fooled man!
 y a green-eared Spathi captain who haven't grown used to the ship's odd design, especially as they're slinking away from the bridge during particularly nasty dogfights.
+
+Miscellaneous
+
+A small note should be added that it may be possible that perhaps a few jet-black Eluders exist. The legends of the Black Spathi Squandron, lead by a small band of courageous, brave Spathi rebels, who attempt to lead its brethren to freedom, have been passed down for several generations. However, the credibility of this legend is dubious at best seeing as how even the most courageous Spathi in the known universe are little short of "completely terrified." 
+
+
+

Deleted: branches/multiplayer-branch/gamedata/ships/shpstaba.dat
===================================================================
(Binary files differ)

Deleted: branches/multiplayer-branch/gamedata/ships/shpsupbl.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpsupbl.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpsupbl.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpsupbl.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,14 +1,19 @@
+ General review
 
-The Supox Blade is one of the original ships
-from Star Control 2.
+The Blade is a largely underrated ship. It's rapid fire capability can pound an unwary enemy and the lateral thrusting, when properly used, is nearly as good as the Arilou Hyperspace shunts in evading shots. The Blade is quick and agile with a fair turn-rate, allowing it to considerably hamper enemy targeting efforts. Its slender form makes it harder to hit her.
 
-The main weapon consists of a rapid-fire forward
-cannon.
+Main Weapon: Sprout Gun
 
-The special allows the ship to move almost instantly
-left, right, back, like a leaf in the wind.
+The rapid-fire Sprout Gun may cause small damage but it sure fires fast. Even when out of battery, the gun?s firing rate remains high and it's range, equaling the Ur-Quan Kzer-Za Dreadnought and the Syreen Penetrator can prove deadly.
 
-The Supox are the only sentient plant species known.
+Special System: Lateral Thrusting System
 
-The Supox formed peaceful allies of the Utwig, whom
-they helped in their time of distress.
+It takes a hell lot of practice to master the tricky Lateral Thrusting System but when correctly used, the Lateral Thrusting can be used to sidestep shots or strafe into a firing position. Especially effective against slow-firing ships such as the Dreadnought or Kohr-Ah Marauder.
+
+Tactical Overview
+
+The Blade is a fair adversary that shouldn't be taken lightly.
+
+Strong against: Syreen Penetrator, Kzer-Za Dreadnought, VUX Intruder, Ilwrath Avenger, Utwig Jugger.
+
+Weak against: Chenjesu Broodhome The crystalline shards put the Lateral-Sidestepping into a real problem. Arilou Skiff, Slylandro Probe and Pkunk Fury can convey quick hit-n-run attacks on the Blade. Chmmr Avatar. 

Deleted: branches/multiplayer-branch/gamedata/ships/shpsyrpe.dat
===================================================================
(Binary files differ)

Deleted: branches/multiplayer-branch/gamedata/ships/shptauar.dat
===================================================================
(Binary files differ)

Deleted: branches/multiplayer-branch/gamedata/ships/shptauda.dat
===================================================================
(Binary files differ)

Deleted: branches/multiplayer-branch/gamedata/ships/shptausl.dat
===================================================================
(Binary files differ)

Deleted: branches/multiplayer-branch/gamedata/ships/shptauto.dat
===================================================================
(Binary files differ)

Deleted: branches/multiplayer-branch/gamedata/ships/shpthrto.dat
===================================================================
(Binary files differ)

Copied: branches/multiplayer-branch/gamedata/ships/shpthrto.txt (from rev 69, trunk/gamedata/ships/shpthrto.txt)

Deleted: branches/multiplayer-branch/gamedata/ships/shpumgdr.dat
===================================================================
(Binary files differ)

Deleted: branches/multiplayer-branch/gamedata/ships/shputwju.dat
===================================================================
(Binary files differ)

Copied: branches/multiplayer-branch/gamedata/ships/shputwju.txt (from rev 69, trunk/gamedata/ships/shputwju.txt)

Deleted: branches/multiplayer-branch/gamedata/ships/shpvuxin.dat
===================================================================
(Binary files differ)

Copied: branches/multiplayer-branch/gamedata/ships/shpvuxin.txt (from rev 69, trunk/gamedata/ships/shpvuxin.txt)

Deleted: branches/multiplayer-branch/gamedata/ships/shpyehte.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpyehte.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpyehte.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpyehte.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,21 +1,3 @@
+The Yehat Terminator is a moderately slow but agile and strong ship that can deal serious damage at close range.
 
-The Yehat Terminator is one of the original ships
-from Star Control 1.  They were on the Alliance side.
-
-Main is a dual, fast firing gun of intermediate range.
-
-Special spawns a shield, needed because their home
-system was located in a nebula and the shield was
-used to reduce friction.
-
-The Yehat are pterodactyl-like creatures.
-
-In Star Control 2, the Yehat are proud warriors, but who
-are under the ruling of a Queen whom they always respected,
-but who chose the side of the dishonorable Ur-Quan. On top
-of this, they suffer from great guilt about the great
-sacrifice of the Shofixti, a race which they uplifted and
-admired. They loathe the Pkunk, who are a peace-loving
-offshoot of the Yehat race. In short, the Yehat are a very
-unhappy race.
-
+Terminators are armed with twin short-range rapid-fire ion cannons. In addition, Terminators are equipped with an energy shield that will block almost all attacks. An Orz Nemesis's space marines, a VUX Intruder's limpets, and a Shofixti Scout's Glory Device detonation are some of the few (but not all) attacks that can penetrate the Terminators shield. Energy generation, though fast, is not sufficient for constant firing and shielding. Proper timing, sensible weapon useage and conservation of energy for shields are of paramount importance. 
\ No newline at end of file

Deleted: branches/multiplayer-branch/gamedata/ships/shpzeksh.dat
===================================================================
(Binary files differ)

Deleted: branches/multiplayer-branch/gamedata/ships/shpzfpst.dat
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/gamedata/ships/shpzfpst.txt
===================================================================
--- branches/multiplayer-branch/gamedata/ships/shpzfpst.txt	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/gamedata/ships/shpzfpst.txt	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,22 +1,3 @@
+The Zoq-Fot-Pik Stinger is a light vessel which can outrun and outmaneuver most other ships but cannot sustain much damage.
 
-The Zoqfotpik Stinger is one of the original ships
-from Star Control 2.
-
-Its normal weapon is a short range pellet gun, 
-which throws around small projectiles in a wide 
-arc.
-
-Its special weapon is a "tongue", able to 
-inflict some major damage at VERY short range.  
-
-The Zoq, Fot and Pik are three species who evolved
-together with the Zebranky on a single world. They
-worked together to destroy the predatory Zebranky,
-and form a cooperative society.
-
-They were close to Ur-Quan territory and, though
-unnoticed by them, were close to extinction due to
-fights between the Kzer-Za and Kohr-Ah taking place
-in their systems. They were very eager to get help
-against this threat.
-
+The Stinger's main weapon is a short-range cannon that can be used to deflect incoming attacks from some other ships. Its alternate weapon is a "tongue" that shoots superheated plasma into the enemy's ship, inflicting incredible damage. However, the Stinger must be right next to its target to hit it with the tongue attack. 

Copied: branches/multiplayer-branch/gamedata/sound/ships (from rev 69, trunk/gamedata/sound/ships)

Modified: branches/multiplayer-branch/makefile
===================================================================
--- branches/multiplayer-branch/makefile	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/makefile	2004-09-28 19:53:03 UTC (rev 71)
@@ -7,7 +7,7 @@
 #                          {TEST=1}                                            #
 #                                                                              #
 # Define win32=1    when compiling with Mingw32 gcc compiler for windows       #
-# Define debug=1    when you want to build debug version of TimeWarp           #         
+# Define debug=1    when you want to build debug version of TimeWarp           #
 # Define xmingw=1   when compiling  win32 binary with Mingw gcc crosscompiler  #
 # Define DATAPATH   to specify where datafile stored (*nix version only)       #
 # Define EXECPATH   to specify where executable should be placed               #
@@ -16,12 +16,12 @@
 # Running just make builds the release version of TimeWarp for *nix            #
 # (Linux, FreeBSD, ...)                                                        #
 #                                                                              #
-# The game depends on Allegro (4.0.x) library, so you need to install it       #
-# before running                                                               #
+# The game depends on Allegro (4.0.x), SDL, SDL_mixer with ogg support         # 
+# libraries, so you need to install them before running.                       #
 #                                                                              #
 ################################################################################
 
-PRODUCTVERSION = 0.2
+PRODUCTVERSION = 0.3
 
 SVNVERSION = ${shell svnversion .}
 
@@ -74,7 +74,7 @@
         source/other source/ships source/sc1ships source/sc2ships \
         source/twgui source/util source/libraries/alogg \
         source/libraries/jpgalleg source/libraries/jgmod source/libraries/cppunit \
-        source/libraries/raknet
+        source/libraries/raknet source/libraries/lua source/libraries/lua/lib
 
 #FILELIST= ${shell find source -type f "(" -name "*.c" -o -name "*.cpp" ")"}
 FILELIST= ${shell cat sources.lst}
@@ -121,7 +121,8 @@
 	LIBS += ${shell allegro-config --libs} -pthread ${shell sdl-config --libs}
 endif
 
-CFLAGS += -I./source -I./source/libraries
+CFLAGS += -I./source -I./source/libraries -I./source/libraries/lua
+
 ifdef TEST
 CFLAGS += -DTEST ${shell cppunit-config --cflags }
 LIBS += ${shell cppunit-config --libs }
@@ -186,6 +187,8 @@
 	svn export . $(EXPDIR)
 	$(RM) $(EXPDIR)/web/*
 	rmdir $(EXPDIR)/web
+	$(RM) $(EXPDIR)/rawgraphic/*
+	rmdir $(EXPDIR)/rawgraphic
 	echo "TW-Light $(PRODUCTVERSION)r$(SVNVERSION) - $(TIMESTAMP)" >$(EXPDIR)/gamedata/version.txt
 	echo "!define VER_VERSION $(PRODUCTVERSION)" >$(EXPDIR)/Util/ver
 	echo "!define VER_SVNVERSION $(SVNVERSION)"  >$(EXPDIR)/Util/svnver
@@ -195,24 +198,17 @@
 
 update_source_list:
 	find source -type f "(" -name "*.c" -o -name "*.cpp" ")" >sources.lst
+
+add_stacktrace:
+	find source -name '*.cpp'|grep -v 'libraries'|grep -v 'errors.cpp'|grep -v 'utils.cpp'|xargs ./Util/addStackTrace.pl 
+
 install:
 	./install-sh $(NAME) $(EXECPATH)/$(NAME)
 	./install-sh gamedata $(DATAPATH)
 
 uninstall:
 	$(RM) $(EXECPATH)/$(NAME)
-	$(RM) $(DATAPATH)/ships/shp*.dat
-	$(RM) $(DATAPATH)/*.dat
-	$(RM) $(DATAPATH)/*.html
-	$(RM) $(DATAPATH)/*.txt
-	$(RM) $(DATAPATH)/palette
-	$(RM) $(DATAPATH)/ships/shp*.txt
-	rmdir $(DATAPATH)/ships
-	$(RM) $(DATAPATH)/default_ini/*.ini
-	$(RM) $(DATAPATH)/default_ini/ships/shp*.ini
-	rmdir $(DATAPATH)/default_ini/ships
-	rmdir $(DATAPATH)/default_ini
-	rmdir $(DATAPATH)
+	$(RM) -r $(DATAPATH)
 
 
 -include $(DEPS)

Copied: branches/multiplayer-branch/rawgraphic (from rev 69, trunk/rawgraphic)

Modified: branches/multiplayer-branch/source/ais/c_input.cpp
===================================================================
--- branches/multiplayer-branch/source/ais/c_input.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ais/c_input.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,7 +1,6 @@
-/* $Id: c_input.cpp,v 1.2 2004/08/03 11:37:21 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -23,7 +22,6 @@
 #include <stdio.h>
 #include <string.h>
 #include "melee.h"
-REGISTER_FILE
 #include "ais.h"
 #include "melee/mship.h"
 #include "gui.h"
@@ -39,54 +37,65 @@
 
 
 
-int my_bitmap_proc( int msg, DIALOG* d, int c ){
-	if( msg == MSG_END && d->dp ){
-		destroy_bitmap( (BITMAP*)d->dp );
-		d->dp = NULL;
-	}
+int my_bitmap_proc( int msg, DIALOG* d, int c )
+{
+  if( msg == MSG_END && d->dp )
+    {
+      destroy_bitmap( (BITMAP*)d->dp );
+      d->dp = NULL;
+    }
 
-	if( msg != MSG_DRAW || d->dp ) return d_bitmap_proc( msg, d, c );
-	return D_O_K;
+  if( msg != MSG_DRAW || d->dp ) 
+    return d_bitmap_proc( msg, d, c );
+  return D_O_K;
 }
 
-int my_list_proc( int msg, DIALOG* d, int c ){
-	int old_d1 = d->d1;
-	Fleet *fleet = (Fleet*)d->dp3;
-	int ret = d_list_proc2( msg, d, c );
-	if( d->d1 != old_d1 || msg == MSG_START ){
-		ShipType* type = fleet->getShipType(d->d1);
+int my_list_proc( int msg, DIALOG* d, int c )
+{
+  int old_d1 = d->d1;
+  Fleet *fleet = (Fleet*)d->dp3;
+  int ret = d_list_proc2( msg, d, c );
+  if( d->d1 != old_d1 || msg == MSG_START )
+    {
+      ShipType* type = fleet->getShipType(d->d1);
+      
+      ASSERT(type != NULL);
 
-        ASSERT(type != NULL);
+      selectDialog[SELECT_DIALOG_TITLE].flags |= D_DIRTY;
+      sprintf(selectTitleString, "%s\n%s\n%d of %d points", 
+	      selectShipPrompt,
+	      (type != NULL) ? type->name : 0,
+	      (type != NULL) ? type->cost : 0,
+	      fleet->getCost());
+      
+      tw_set_config_file(type->data->ini);
 
-        selectDialog[SELECT_DIALOG_TITLE].flags |= D_DIRTY;
-        sprintf(selectTitleString, "%s\n%s\n%d of %d points", 
-            selectShipPrompt,
-            (type != NULL) ? type->name : 0,
-            (type != NULL) ? type->cost : 0,
-            fleet->getCost());
-
-		BITMAP* panel = NULL;
-		DATAFILE* data = load_datafile_object( type->data->file, "SHIP_P00_PCX" );
-
-		if( data ){
-			BITMAP* bmp = (BITMAP*)data->dat;
-			panel = create_bitmap_ex( bitmap_color_depth(screen), bmp->w, bmp->h );
-			blit( bmp, panel, 0, 0, 0, 0, bmp->w, bmp->h );
-			unload_datafile_object( data );
-			data = load_datafile_object( type->data->file, "SHIP_P01_PCX" );
-			bmp = (BITMAP*)data->dat;
-			blit( bmp, panel, 0, 0, 4, 65, bmp->w, bmp->h );
-			unload_datafile_object( data );
-			color_correct_bitmap( panel, 0 );
-		}
-
-		if( selectDialog[SELECT_DIALOG_PIC].dp ) destroy_bitmap( (BITMAP*)selectDialog[SELECT_DIALOG_PIC].dp );
-		selectDialog[SELECT_DIALOG_PIC].dp = panel;
-		scare_mouse();
-		SEND_MESSAGE( &selectDialog[SELECT_DIALOG_PIC], MSG_DRAW, 0 );
-		unscare_mouse();
+      BITMAP* panel = load_bitmap(data_full_path(get_config_string("Graphic", 
+								   "PanelBitmaps0", 
+								   "")).c_str(), NULL);
+      if(panel)
+	{
+	  BITMAP* bmp = load_bitmap(data_full_path(get_config_string("Graphic", 
+								     "PanelBitmaps1", 
+								     "")).c_str(), NULL);
+	  blit( bmp, panel, 0, 0, 4, 65, bmp->w, bmp->h );
+	  destroy_bitmap(bmp);
+	  color_correct_bitmap( panel, 0 );
 	}
-	return ret;
+      else
+	{
+	  tw_error("Unable to load ship pannel!!\n%s", 
+		   data_full_path(get_config_string("Graphic", "PanelBitmaps0", "")).c_str());
+	}
+      
+      if( selectDialog[SELECT_DIALOG_PIC].dp ) 
+	destroy_bitmap( (BITMAP*)selectDialog[SELECT_DIALOG_PIC].dp );
+      selectDialog[SELECT_DIALOG_PIC].dp = panel;
+      scare_mouse();
+      SEND_MESSAGE( &selectDialog[SELECT_DIALOG_PIC], MSG_DRAW, 0 );
+      unscare_mouse();
+    }
+  return ret;
 }
 
 void calibrate_joysticks() 
@@ -217,12 +226,14 @@
 /*! \brief Get control name */
 const char *ControlHuman::getTypeName() 
 {
+  STACKTRACE;
   return "Keyboard/Joystick";
 }
 
 /*! \brief Process get input from player */
 int ControlHuman::think() 
 {
+  STACKTRACE;
   int r = 0;
   if (key_pressed(thrust))  r |= keyflag::thrust;
   if (key_pressed(back))    r |= keyflag::back;
@@ -245,10 +256,11 @@
 
 ControlHuman::ControlHuman(const char *name, int channel) : Control(name, channel, ai_index_human) 
 {
+  STACKTRACE;
 };
 
 int ControlHuman::choose_ship(VideoWindow *window, char * prompt, Fleet *fleet) {
-	STACKTRACE;
+  STACKTRACE;
 	int ret = -1, slot = 0;
 	if (fleet->getSize() == 0) {tw_error ("Empty fleet! (prompt:%s)", prompt);}
 	selectDialog[SELECT_DIALOG_LIST].dp3 = fleet;
@@ -279,6 +291,7 @@
 
 /*! returns help text for this controller ie keys to use this controller*/
 void ControlHuman::getHelpText(char * text) {
+  STACKTRACE;
 	char line[80] = "";
 	char desc[80] = "";
 
@@ -299,6 +312,7 @@
 /*! \brief setap players keys */
 void ControlHuman::setup() 
 {
+  STACKTRACE;
   int i, t = 0;
   int last = 0;
   while (true) 

Modified: branches/multiplayer-branch/source/ais/c_other.cpp
===================================================================
--- branches/multiplayer-branch/source/ais/c_other.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ais/c_other.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,7 +1,6 @@
-/* $Id: c_other.cpp,v 1.1.1.1 2004/08/01 10:21:19 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -21,16 +20,17 @@
 #endif
 
 #include "ais.h"
-REGISTER_FILE
 
 /*! \brief Get control name */
 const char *ControlVegetable::getTypeName() 
 {
+  STACKTRACE;
   return "VegetableBot";
 }
 /*! \brief This AI do nothing */
 int ControlVegetable::think() 
 {
+  STACKTRACE;
   return 0;
 }
 /*! \brief This function do nothing
@@ -38,6 +38,7 @@
 */
 int ControlVegetable::choose_ship(VideoWindow *window, char * prompt, class Fleet *fleet ) 
 {
+  STACKTRACE;
   return -1;
 }
 
@@ -47,6 +48,7 @@
 
 const char *ControlMoron::getTypeName() 
 {
+  STACKTRACE;
   return "MoronBot";
 }
 
@@ -92,6 +94,7 @@
 /*! \brief Summon stupid_bot() */
 int ControlMoron::think()
 {
+  STACKTRACE;
   if (ship)
     return stupid_bot(ship);
   else
@@ -100,6 +103,7 @@
 
 ControlMoron::ControlMoron(const char *name, int channel) : Control(name, channel, ai_index_moron) 
 {
+  STACKTRACE;
 }
 
 

Modified: branches/multiplayer-branch/source/ais/c_wussie.cpp
===================================================================
--- branches/multiplayer-branch/source/ais/c_wussie.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ais/c_wussie.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,4 +1,3 @@
-/* $Id: c_wussie.cpp,v 1.2 2004/08/01 21:26:15 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
                     http://timewarp.sourceforge.net/

Modified: branches/multiplayer-branch/source/doxygen.cpp
===================================================================
--- branches/multiplayer-branch/source/doxygen.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/doxygen.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,7 +1,6 @@
-/* $Id: doxygen.cpp,v 1.3 2004/08/07 13:10:51 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -19,9 +18,9 @@
  * 
  *  \section overview_sec Overview: What is TW-Light?
  *  
- *  TW-Light is lightweighted version of Star Control: TimeWarp. Currently it includes only a combat 
- *  portion with the best TW ships but without network support. There are some plans to expand it to 
- *  include an epic adventure. 
+ *  TW-Light is an open source clone/sequel to the epic cross-genre game Star Control II. 
+ *  Currently it includes only a combat portion, although epic adventure part that is 
+ *  called TW:Legacies is actively developed now. 
  *
  *  \section getting_started_sec Getting Started
  * 
@@ -39,7 +38,7 @@
  *       - F12 displays framerates / performance data
  *       - - zooms out on some viewing modes.
  *       - + (or =) zooms in on some viewing modes.
- *       - 0 and 9 also effect the camera in some viewing modes.
+ *       - 0 also effect the camera in some viewing modes.
  *       - ctrl+T = toggle team indicators on/off
  *       - ctrl+H = toggle healthbar indicators on/off
  *       - Also, if some controllers are set to keyboard, customizable
@@ -48,94 +47,20 @@
  *               - left:   Keypad 4
  *               - thrust: Keypad 8
  *               - right:  Keypad 6
- *               - fire:   Quote (")
- *               -  special:Semicolon (;)
+ *               - fire:   Enter 
+ *               -  special:Ctrl 
  *               - next:   Closebrace (])
  *               - prev:   Openbrace ([)
  *               - near:   P
- *       - Config 1:
- *               - left:   A
- *               - thrust: S
- *               - right:  D
- *               - fire:   B
- *               - special:V
- *               - next:   F
- *               - prev:   G
- *               - near:   H
- * - Extended Menu:
- *	- Play Game:
- *              - Same as "Melee" now
- *      - Key Tester:
- *              - Use this utility to check keys combination for conflicts.
- *	- Ship Info:
- *		- Here you can get detail information about every ship in the game.
- * 	- Diagnostic:
- *              - Show comlile options and version information. 
- *	- Main Menu:
- *              - This returns to the main menu.
- *		
- * - Teams:
- *      - Select Controller:
- *             - Select the player (i.e. "Player 1" or "Player 2")
- *              you wish to alter from the list on the left, and
- *              the controller (i.e. "Keyboard", "MoronBot") you
- *              want to control that player from the list on the
- *             left.  Then either click on the "Select
- *             Controller" button or double click on the
- *             controller name.
- *	- Change Team #: 
- *	       - This switches the player allys. 
- *	      Note that team 0 mean no allys.
- *      - Change Config #:
- *             -   This switches the configuration used by the
- *              currently highlighted controller.  
- *      - Edit Configuration:
- *             -   This is used to setup up keys when the currently
- *              highlighted player is using the keyboard.  It
- *              may eventually allow the configuration of AIs
- *              and calibration of joysticks.
- *      - Edit Fleet:
- *             -   This button brings up the fleet selection menu for
- *              the currently highlighted player.  
- *      - Main Menu:
- *             -   This returns to the main menu.
- * - Options:
- *      -  Most things on this menu are self-explanatory, but a few
- *         need special mention.
- *
- *      - Gamma correction:
- *             -  This makes things brighter during combat.  This
- *                 should not be changed from the middle of combat,
- *                 or colors could get weird.  
- *      - Antialiasing:
- *             -  If this box is checked then TimeWarp will use
- *                higher quality graphics, but run slower.  
- *      - Color Depth:
- *             -  You cannot change this from the middle of combat.  
- *      -  Camera Mode:
- *             -  This allows you to control what is shown on your
- *                 screen in combat.  
- *
- *             - "Enemy_Discrete"
- *                 is just like Star Control on the PC, where
- *                 the camera moved to keep both you and your
- *                 enemy onscreen, and zoomed in by factors of
- *                 2.
- *             -  "Enemy"
- *                 is like Star Control on the Genesis or 3DO,
- *                 where the camera zoomed in smoothly.
- *             -  "Hero"
- *                 makes the camera stay focused on Player 1,
- *                 and zoom in/out when + and - are pressed.
- *             -  "Everything"
- *                 makes the camera stay on the planet and zoom
- *                 way out so that everything is visible.  This
- *                 mode is slightly buggy (visual artifacts).  
- *
+ * 
+ *   See ingame help for controls description.
+ *  
  * \section development Development
  * 
+ * Full developer documentation can be produced using doxygen tool.
+ * 
  * Following documents describes some of the issues concerning contributing 
- * to Timewarp
+ * to TW-Light
  * 		- \ref coding_page
  * 		- \ref howto_document
  *  
@@ -156,13 +81,10 @@
  *   - The Chorali Extractor
  *   - Confed Cargotran
  *   - Confederation Hornet
- *   - Djinni Lancer
  *   - Drax Griffon
- *   - Earthling Crusader MK2
  *   - Earthling Crusader MK3
  *   - Zekfahan Shocker
  *   - Garash Tyrant
- *   - Hydrovar
  *   - Ilwrath Spider
  *   - Kahr Boomerang
  *   - Re-Koj Assassin
@@ -175,7 +97,7 @@
  *
  * \subsection simplyfy_subsec Simplify and fix melee engine
  * 
- *  We are working on it.
+ *  Almost done.
  * 
  * \subsection TML_subsec Add TimeWarp Markup Language (TML) support
  * 
@@ -183,7 +105,7 @@
  * 
  * \subsection plot_subsec Write plot
  * 
- *  No progress.
+ *  The Plot is fully writen.
  *
  * \subsection plot_impl_subsec  Implement plot with TML
  * 
@@ -206,8 +128,10 @@
  *
  * \section credits_sec Credits
  *
- * TW-Light is derivative work from <a href="timewarp.sourceforge.net">Star Control: TimeWarp</a>
-
+ * - TW-Light is derivative work from <a href="timewarp.sourceforge.net">Star Control: TimeWarp</a>
+ * - Some code and documents were taken from <a href="www.wesnoth.org">Battle for Wesnoth</a>
+ * - UQM Ships description were taken from Ultronomicon (http://uqm.stack.nl/wiki/)
+ * - Some battle music were written by Robeter Productions Inc. 
  */
 
  /*! \page coding_page A guide to a few of the wierder issues with programming for TW-Light.  
@@ -252,23 +176,15 @@
  * \section trivial_conventions_sec Trivial Conventions
  * 
  * It would be nice if the following conventions were followed in TW-Light code:
- * -#  The proper indentation amount is 1 tab.  If you don't like that (or if
- * your editor produces spaces when you hit tab), then try 2 spaces instead.
- * If you don't like that either, AT LEAST BE INTERNALLY CONSISTENT IN YOUR
- * INDENTATION POLICY!  YES, THIS MEANS YOU!!!
- * -#  In the same vein, do not use an editor that transparently replaces N
- * spaces with the "equivalent" tabs.  Or, if you must do so, make sure that
- * your indentation amount exactly matches the tab size.  Otherwise your
- * indentation will apear totally fucked up on other editors with different tab
- * sizes.  And don't use an editor that replaces tabs with spaces either.  
- * Don't use strange characters in file names.  To be specific, the 26 
+ * -#  The proper indentation amount is 2 spaces. If you don't like it, AT LEAST 
+ * BE INTERNALLY CONSISTENT IN YOUR INDENTATION POLICY!  YES, THIS MEANS YOU!!!
+ * -#  Don't use strange characters in file names.  To be specific, the 26 
  * english characters and underscores and up to one period per file name 
  * are okay.  I guess numbers would be ok too.  Use lower case letters, 
  * never upper case.  
  * -# Don't name two source files exactly the same thing, even if they're in 
  * different directories. The same rule applies to headers.  
- * -# All source files should have extensions of either .cpp or .h .  No .c 
- * or .cc files.  Exception: .c files are permitted in the util directory.  
+ * -# All source files should have extensions of either .c .cpp or .h .  No .cc files.    
  * 
  * \section collisions_sec Collisions
  * 
@@ -300,10 +216,11 @@
  * \section report_error_sec Reporting Errors
  * 
  * If you wish to report an error condition, you can say something like:
+ * //simple error message<br>
  * tw_error("Oh no! an error occured!");
- * //simple error message
+ * //error message using more complex printf-style stuff<br>
  * tw_error("This error was brought to you by the letter %c and the number %d", 'g', 3);
- * //error message using more complex printf-style stuff
+ * 
  * When you report an error in this manner, a box will pop up and tell
  * the user your message, and the source file and line number from which
  * tw_error() was called.  The user will be presented with a number of buttons,

Modified: branches/multiplayer-branch/source/frame.cpp
===================================================================
--- branches/multiplayer-branch/source/frame.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/frame.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -24,7 +24,6 @@
 #include <stdio.h>
 #include <memory.h>
 #include "melee.h"
-REGISTER_FILE
 #include "frame.h"
 
 extern FILE* debug_file;
@@ -126,6 +125,7 @@
 
 Frame::Frame(int max_items) 
 {
+  STACKTRACE;
   window = new VideoWindow();
   window->preinit();
   surface = NULL;
@@ -166,6 +166,7 @@
 /*! \brief weild code to enlarge amount of items */
 void Frame::enlarge_list(int increment) 
 {
+  STACKTRACE;
   DirtyItem *temp;
   
   temp = item;
@@ -223,42 +224,49 @@
 /*! \brief Add pixel item to item list */
 void Frame::add_pixel(int x, int y)
 {
+  STACKTRACE;
   add_to_list(x, y, 0, 0, erase_pixel, draw_pixel);
 }
 
 /*! \brief Add box item to item list */
 void Frame::add_box(double x, double y, double w, double h)
 {
+  STACKTRACE;
   add_to_list((int)x, (int)y, (int)w, (int)h, erase_box, draw_box);
 }
 
 /*! \brief Add circle item to item list */
 void Frame::add_circle(int x, int y, int a, int b)
 {
+  STACKTRACE;
   add_to_list(x, y, a, b, erase_circle, draw_circle);
 }
 
 /*! \brief to be deleted? */
 void Frame::add_old_circle(int x, int y, int a, int b)
 {
+  STACKTRACE;
   add_to_old_list(x, y, a, b, erase_circle, draw_circle);
 }
 
 /*! \brief to be deleted? */
 void Frame::add_line(int x, int y, int a, int b)
 {
+  STACKTRACE;
   add_to_list(x, y, a, b, erase_line, draw_line);
 }
 
 /*! \brief to be deleted? */
 void Frame::add_old_pixel(int x, int y)
 {
+  STACKTRACE;
   add_to_old_list(x, y, 0, 0, erase_pixel, draw_pixel);
 }
 
 /*! \brief to be deleted? */
 void Frame::add_old_box(int x, int y, int a, int b)
 {
+  STACKTRACE;
   add_to_old_list(
 		  x, 
 		  y, 
@@ -271,6 +279,7 @@
 /*! \brief to be deleted? */
 void Frame::add_old_line(int x, int y, int a, int b)
 {
+  STACKTRACE;
   add_to_old_list(x, y, a, b, erase_line, draw_line);
 }
 

Copied: branches/multiplayer-branch/source/games/gdefender.cpp (from rev 69, trunk/source/games/gdefender.cpp)

Modified: branches/multiplayer-branch/source/games/gflmelee.cpp
===================================================================
--- branches/multiplayer-branch/source/games/gflmelee.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/games/gflmelee.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,7 +1,7 @@
 /* $Id: gflmelee.cpp,v 1.1.1.1 2004/08/01 10:21:21 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -27,7 +27,6 @@
 #include "other/radar.h"
 #include "melee/mshppan.h"
 
-REGISTER_FILE
 #include "melee/mframe.h"
 #include "melee/mgame.h"
 #include "melee/mmain.h"
@@ -181,6 +180,7 @@
 
 StatsManager::StatsManager()
 {
+  STACKTRACE;
   Nships = 0;
   // no stats yet :)
 
@@ -466,6 +466,7 @@
 
 YRadar::YRadar(Control *ocontroller, double Size, TeamCode hteam, char *datafilename, bool rel, int shape)
 {
+  STACKTRACE;
   relative_angle = rel;
   display_shape = shape;
   
@@ -533,11 +534,13 @@
 
 void YRadar::toggleActive()
 {
+  STACKTRACE;
   active^=1;
 }
 
 void YRadar::setSize(double Size)
 {
+  STACKTRACE;
   size=Size;
 }
 
@@ -685,6 +688,7 @@
 
 ImIndicator::ImIndicator(SpaceLocation *o)
 {
+  STACKTRACE;
   showme = o;
   
   bmp = create_bitmap_ex( bitmap_color_depth(screen), ImIndicatorSize, ImIndicatorSize);

Copied: branches/multiplayer-branch/source/games/ggob.cpp (from rev 69, trunk/source/games/ggob.cpp)

Copied: branches/multiplayer-branch/source/games/ggob.h (from rev 69, trunk/source/games/ggob.h)

Modified: branches/multiplayer-branch/source/gui.cpp
===================================================================
--- branches/multiplayer-branch/source/gui.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/gui.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -26,7 +26,6 @@
 #endif
 #include <allegro/internal/aintern.h>
 #include "melee.h"
-REGISTER_FILE
 
 #include "scp.h"
 #include "gui.h"
@@ -66,31 +65,32 @@
 {
   int f, g, h;
   if (0) ;
-  else if (videosystem.width <= 250) g = 0;
-  else if (videosystem.width <= 320) g = 1;
-  else if (videosystem.width <= 400) g = 2;
-  else if (videosystem.width <= 640) g = 3;
-  else if (videosystem.width <= 800) g = 4;
-  else if (videosystem.width <= 1024) g = 5;
-  else if (videosystem.width <= 1280) g = 6;
-  else if (videosystem.width <= 1600) g = 7;
+  else if (videosystem->width <= 250) g = 0;
+  else if (videosystem->width <= 320) g = 1;
+  else if (videosystem->width <= 400) g = 2;
+  else if (videosystem->width <= 640) g = 3;
+  else if (videosystem->width <= 800) g = 4;
+  else if (videosystem->width <= 1024) g = 5;
+  else if (videosystem->width <= 1280) g = 6;
+  else if (videosystem->width <= 1600) g = 7;
   else g = 8;
   if (0) ;
-  else if (videosystem.height <= 180) h = 0;
-  else if (videosystem.height <= 240) h = 1;
-  else if (videosystem.height <= 300) h = 2;
-  else if (videosystem.height <= 480) h = 3;
-  else if (videosystem.height <= 600) h = 4;
-  else if (videosystem.height <= 768) h = 5;
-  else if (videosystem.height <= 1024) h = 6;
-  else if (videosystem.height <= 1280) h = 7;
+  else if (videosystem->height <= 180) h = 0;
+  else if (videosystem->height <= 240) h = 1;
+  else if (videosystem->height <= 300) h = 2;
+  else if (videosystem->height <= 480) h = 3;
+  else if (videosystem->height <= 600) h = 4;
+  else if (videosystem->height <= 768) h = 5;
+  else if (videosystem->height <= 1024) h = 6;
+  else if (videosystem->height <= 1280) h = 7;
   else h = 8;
   f = (c + g + h + 1) / 2;
-  return videosystem.get_font(f);
+  return videosystem->get_font(f);
 }
 
 void TW_Dialog_Player::redraw() 
 {
+  STACKTRACE;
   int i;
   if (!player) return;
   for (i = 0; player->dialog[i].proc; i++) player->dialog[i].flags |= D_DIRTY;
@@ -100,6 +100,7 @@
 
 void TW_Dialog_Player::_event( Event * e) 
 {
+  STACKTRACE;
   switch (e->type) 
     {
     case Event::VIDEO: {
@@ -111,11 +112,13 @@
 
 void TW_Dialog_Player::init(VideoWindow *w, DIALOG *d, int focus) 
 {
+  STACKTRACE;
   dialog = d;
   window = w;
   ifocus = focus;
   player = NULL;
-  if (!window) window = &videosystem.window;
+  if (!window) 
+    window = &videosystem->window;
   window->add_callback(this);
   int i;
   for (i = 0; d[i].proc; i += 1) ;
@@ -163,6 +166,7 @@
 }
 void TW_Dialog_Player::deinit() 
 {
+  STACKTRACE;
   int i;
   window->remove_callback(this);
   dialog[length].d2 -= 1;
@@ -189,7 +193,8 @@
 }
 int TW_Dialog_Player::update() 
 {
-  videosystem.poll_redraw();
+  STACKTRACE;
+  videosystem->poll_redraw();
   BITMAP *old = screen;
   screen = subscreen;
   if (!player) player = init_dialog(dialog, ifocus);
@@ -210,7 +215,8 @@
 {
   int return_value;
   TW_Dialog_Player bob;
-  if (!window) window = &videosystem.window;
+  if (!window) 
+    window = &videosystem->window;
   bob.init(window, d, index);
   
   while (keypressed()) readkey();
@@ -226,11 +232,13 @@
 {
   BITMAP *tmp;
   int n, i, return_value;
-  if (!window) window = &videosystem.window;
+  if (!window) 
+    window = &videosystem->window;
   for (n = 0; d[n].proc; n += 1) ;
-  if (!window->surface) error ("tw_dialog_pre - no drawing surface");
+  if (!window->surface) 
+    tw_error ("tw_dialog_pre - no drawing surface");
   if ((index >= n) || (index < 0)) 
-    error("tw_dialog - index invalid");
+    tw_error("tw_dialog - index invalid");
   
   TW_Dialog_Player bob;
   bob.init( window, d, index);
@@ -722,17 +730,17 @@
     case MSG_END:
       if (d->flags & D_DISABLED) 
 	{
-	  tw_sound.play_sound(menuDisabled);
+	  tw_sound->play_sound(menuDisabled, 0.5);
         }
       else 
 	{
-	  tw_sound.play_sound(menuAccept);
+	  tw_sound->play_sound(menuAccept, 0.25);
         }
       break;
 
     case MSG_GOTFOCUS:
       {
-	tw_sound.play_sound(menuFocus);
+	tw_sound->play_sound(menuFocus, 0.5);
 	break;
       }
     };

Modified: branches/multiplayer-branch/source/input.cpp
===================================================================
--- branches/multiplayer-branch/source/input.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/input.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -25,7 +25,6 @@
 #endif
 
 #include "melee.h"
-REGISTER_FILE
 
 #define JOY_NUM_BITS       3
 #define JOY_NUM_SHIFT     12
@@ -420,7 +419,7 @@
 {
   if (which_key & 0x8000) 
     {
-      error ("key_pressed - bad key");
+      tw_error ("key_pressed - bad key");
       return 0;
     }
 
@@ -451,7 +450,7 @@
 	case 3: return joy[joy_num].stick[joy_stick].axis[joy_axi].pos;
 	default: return 0;
 	}
-      error ("key_pressed - bad key???");
+      tw_error ("key_pressed - bad key???");
       return 0;
     }
   

Copied: branches/multiplayer-branch/source/libraries/lua (from rev 69, trunk/source/libraries/lua)

Modified: branches/multiplayer-branch/source/melee/manim.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/manim.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/manim.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "melee.h"
-REGISTER_FILE
 
 
 #include "ship.h"
@@ -35,27 +34,27 @@
   frame_step(frame_length),
   scale(_scale),
   transparency(0)
-{STACKTRACE
-   if (frame_size <= 0) 
-     {
-       tw_error("Animation::Animation - frame_size == %d", frame_size);
-       frame_size = 1;
-     }
- sprite_index = first_frame;
- layer = LAYER_HOTSPOTS;
- set_depth(depth);
- collide_flag_anyone = collide_flag_sameteam = collide_flag_sameship = 0;
- mass = 0;
- 
- // it's got no physical interaction with the rest of the world, so, remove it
- // from the query list:
- attributes |= ATTRIB_UNDETECTABLE;
+{
+  STACKTRACE;
+  if (frame_size <= 0) 
+    {
+      tw_error("Animation::Animation - frame_size == %d", frame_size);
+      frame_size = 1;
+    }
+  sprite_index = first_frame;
+  layer = LAYER_HOTSPOTS;
+  set_depth(depth);
+  collide_flag_anyone = collide_flag_sameteam = collide_flag_sameship = 0;
+  mass = 0;
+  
+  // it's got no physical interaction with the rest of the world, so, remove it
+  // from the query list:
+  attributes |= ATTRIB_UNDETECTABLE;
 }
 
 void Animation::calculate() 
 {
   STACKTRACE;
-  
   frame_step -= frame_time;
   while (frame_step < 0) 
     {

Modified: branches/multiplayer-branch/source/melee/mcbodies.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mcbodies.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mcbodies.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -15,11 +15,11 @@
 GNU General Public License for more details.
 */
 
+#include "util/sound.h"
 #include <allegro.h>
 #include <string.h>
 #include <stdio.h>
 #include "melee.h"
-REGISTER_FILE
 #include "id.h"
 #include "scp.h"
 #include "frame.h"
@@ -33,7 +33,7 @@
 #include "other/twconfig.h"
 
 Asteroid::Asteroid() 
-:	SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite), explosion(meleedata.asteroidExplosionSprite)
+:	SpaceObject(NULL, random(map_size), random(PI2), game->meleedata.asteroidSprite), explosion(game->meleedata.asteroidExplosionSprite)
 {
   STACKTRACE;
   collide_flag_sameteam = ALL_LAYERS;
@@ -64,7 +64,8 @@
   SpaceObject::calculate();
 }
 
-int Asteroid::handle_damage(SpaceLocation *source, double normal, double direct) {
+int Asteroid::handle_damage(SpaceLocation *source, double normal, double direct) 
+{
   STACKTRACE;
   if (!exists()) 
     return 0;
@@ -78,9 +79,9 @@
   return 1;
 }
 
-void Asteroid::death() {
-  STACKTRACE;
-			  
+void Asteroid::death() 
+{
+  STACKTRACE;		  
   Animation *a = new Animation(this, pos,
 			       explosion, 0, explosion->frames(), time_ratio, get_depth());
   a->match_velocity(this);
@@ -116,15 +117,37 @@
 {
   STACKTRACE;
   int i = 1;
-  if (other->isShip()) {
-    i = (int) ceil(((Ship*)other)->crew / 3.0);
-  }
-  if (other->mass == 0) other->state = 0;
+  if (other->isShip()) 
+    {
+      i = (int) ceil(((Ship*)other)->crew / 3.0);
+    }
+  if (other->mass == 0) 
+    other->state = 0;
   damage(other, 0, i);
   i /= 2;
   if (i >= BOOM_SAMPLES) i = BOOM_SAMPLES - 1;
   if (!other->isShot()) 
-    play_sound((SAMPLE *)(melee[MELEE_BOOM + i].dat));
+    {
+      switch(i)
+	{
+	case 0:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+	  break;
+	case 1:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+	  break;
+	case 2:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+	  break;
+	case 3:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+	  break;
+	default:
+	  {
+	    tw_error("Unknown BOOM sound");
+	  }
+	}
+    }
   return;
 }
 
@@ -190,7 +213,6 @@
 			  int aa_mode
 			  ) 
 {
-  STACKTRACE;
   int i;
   double wx, wy;
   RNG_FS rng;
@@ -247,7 +269,6 @@
  int aa_mode
  ) 
 {
-  STACKTRACE;
   int i;
   double wx, wy;
   RNG_FS rng;
@@ -346,93 +367,103 @@
 
 Stars::Stars()
 {
-	STACKTRACE;
-
-	int i;
-	v = NULL;
-	set_depth(DEPTH_STARS);
-	DATAFILE *stardat = load_datafile(data_full_path("stars.dat").c_str());
-	if (!stardat) {
-		tw_error("stars.dat not found!");
-		num_pics = 0;
-		pic = NULL;
-		num_stars = 0;
-		num_layers = 0;
-		return;
-	}
-	for (i = 0; (stardat[i].type == DAT_RLE_SPRITE) || (stardat[i].type == DAT_BITMAP); i += 1) ;
-	num_pics = i;
-	pic = new SpaceSprite*[num_pics];
-	seed = rng.raw64();
-	for(i = 0; i < num_pics; i++) {
-		pic[i] = new SpaceSprite(&stardat[i], 1, 
-			SpaceSprite::ALPHA | 
-			SpaceSprite::MASKED | 
-			SpaceSprite::IRREGULAR | 
-			SpaceSprite::MIPMAPED
-		);
-	}
-	game->log_file("server.ini");
-	width = get_config_int("Stars", "Width", 4000);
-	height = get_config_int("Stars", "Height", 4000);
-	num_stars = get_config_int("Stars", "Number", 150);
-	num_layers = get_config_int("Stars", "Layers", 5);
-	field_depth = get_config_int("Stars", "Depth", 192);
-	tw_set_config_file("client.ini");
-	aa_mode = get_config_int("Stars", "Quality", 5);
-	unload_datafile(stardat);
+  STACKTRACE;
+  int i;
+  v = NULL;
+  set_depth(DEPTH_STARS);
+  DATAFILE *stardat = load_datafile(data_full_path("stars.dat").c_str());
+  if (!stardat) 
+    {
+      tw_error("stars.dat not found!");
+      num_pics = 0;
+      pic = NULL;
+      num_stars = 0;
+      num_layers = 0;
+      return;
+    }
+  for (i = 0; (stardat[i].type == DAT_RLE_SPRITE) || (stardat[i].type == DAT_BITMAP); i += 1) ;
+  num_pics = i;
+  pic = new SpaceSprite*[num_pics];
+  seed = rng.raw64();
+  for(i = 0; i < num_pics; i++) 
+    {
+      pic[i] = new SpaceSprite(&stardat[i], 1, 
+			       SpaceSprite::ALPHA | 
+			       SpaceSprite::MASKED | 
+			       SpaceSprite::IRREGULAR | 
+			       SpaceSprite::MIPMAPED
+			       );
+    }
+  game->log_file("server.ini");
+  width = get_config_int("Stars", "Width", 4000);
+  height = get_config_int("Stars", "Height", 4000);
+  num_stars = get_config_int("Stars", "Number", 150);
+  num_layers = get_config_int("Stars", "Layers", 5);
+  field_depth = get_config_int("Stars", "Depth", 192);
+  tw_set_config_file("client.ini");
+  aa_mode = get_config_int("Stars", "Quality", 5);
+  unload_datafile(stardat);
 }
-Stars::~Stars() {STACKTRACE
-	int i;
-	for(i = 0; i < num_pics; i++) delete pic[i];
-	delete[] pic;
-	}
+Stars::~Stars() 
+{
+  int i;
+  for(i = 0; i < num_pics; i++) delete pic[i];
+  delete[] pic;
+}
 
 
-void Stars::animate(Frame *space) {STACKTRACE
-	if (v && (space_view != *v)) return;
+void Stars::animate(Frame *space) 
+{
+  STACKTRACE;
+  if (v && (space_view != *v)) return;
 
-	double d = space_zoom;
-	double w = width * d;
-	double h = height * d;
-	int x, y, layer;
-	for (layer = 0; layer < num_layers; layer += 1) {
-		d = space_zoom * pow(1.0 - field_depth / 260.0, (num_layers-layer)/(double)num_layers);
-		for (y = 0; y * h < space->surface->h; y+=1) {
-			for (x = 0; x * w < space->surface->w; x+=1) {
-				if (aa_mode & 0x80000000) {
-					_draw_starfield_cached ( 
-						space, 
-						pic[layer%num_pics], 
-						0,
-						num_stars / num_layers,
-						(x+0.5)*w, (y+0.5)*h, 
-						-space_center_nowrap.x * d + space_view_size.x / 2, 
-						-space_center_nowrap.y * d + space_view_size.y / 2, 
-						w, h, 
-						w, h, 
-						d + d*fabs(50.0-(((game->game_time / 10 + layer * 70)) % 100)) / 100.0,
-						seed + layer,
-						aa_mode
-					);
-				}
-				else {
-					_draw_starfield_raw ( 
-						space, 
-						pic[layer%num_pics], 0, 1,
-						num_stars / num_layers,
-						(x+0.5)*w, (y+0.5)*h, 
-						-space_center_nowrap.x * d + space_view_size.x / 2, 
-						-space_center_nowrap.y * d + space_view_size.y / 2, 
-						w, h, 
-						w, h, 
-						d + d*fabs(50.0-(((game->game_time / 10 + layer * 70)) % 100)) / 100.0,
-						seed + layer,
-						aa_mode & 0x7fffFFFF
-					);
-				}
-			}
+  double d = space_zoom;
+  double w = width * d;
+  double h = height * d;
+  int x, y, layer;
+  for (layer = 0; layer < num_layers; layer += 1) 
+    {
+      d = space_zoom * pow(1.0 - field_depth / 260.0, (num_layers-layer)/(double)num_layers);
+      for (y = 0; y * h < space->surface->h; y+=1) 
+	{
+	  for (x = 0; x * w < space->surface->w; x+=1) 
+	    {
+	      if (aa_mode & 0x80000000) 
+		{
+		  _draw_starfield_cached 
+		    ( 
+		     space, 
+		     pic[layer%num_pics], 
+		     0,
+		     num_stars / num_layers,
+		     (x+0.5)*w, (y+0.5)*h, 
+		     -space_center_nowrap.x * d + space_view_size.x / 2, 
+		     -space_center_nowrap.y * d + space_view_size.y / 2, 
+		     w, h, 
+		     w, h, 
+		     d + d*fabs(50.0-(((game->game_time / 10 + layer * 70)) % 100)) / 100.0,
+		     seed + layer,
+		     aa_mode
+		     );
 		}
+	      else 
+		{
+		  _draw_starfield_raw ( 
+				       space, 
+				       pic[layer%num_pics], 0, 1,
+				       num_stars / num_layers,
+				       (x+0.5)*w, (y+0.5)*h, 
+				       -space_center_nowrap.x * d + space_view_size.x / 2, 
+				       -space_center_nowrap.y * d + space_view_size.y / 2, 
+				       w, h, 
+				       w, h, 
+				       d + d*fabs(50.0-(((game->game_time / 10 + layer * 70)) % 100)) / 100.0,
+				       seed + layer,
+				       aa_mode & 0x7fffFFFF
+				       );
+		}
+	    }
 	}
-	return;
+    }
+  return;
 }

Modified: branches/multiplayer-branch/source/melee/mcontrol.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mcontrol.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mcontrol.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -20,7 +20,6 @@
 #include <allegro.h>
 
 #include "melee.h"
-REGISTER_FILE
 #include "ais.h"
 #include "id.h"
 
@@ -33,10 +32,6 @@
 #include "scp.h"
 #include "other/dialogs.h"
 
-
-
-
-
 const char num_controls = 4;
 static char *gcc_sucks_dick[num_controls + 2] = 
 		{
@@ -52,7 +47,6 @@
 
 void animate_target(Frame *frame, SpaceLocation *t, int dx, int dy, int r, int c) 
 {
-  STACKTRACE;
   return;
 }
 
@@ -60,8 +54,8 @@
 
 
 
-int control2number(const char *name) {
-  STACKTRACE;
+int control2number(const char *name) 
+{
   if (!name) 
     return 0;
   for (int i = 0; i < num_controls+1; i += 1) 
@@ -74,10 +68,9 @@
 
 Control *getController(const char *type, const char *name, int channel) 
 {
-  STACKTRACE;
   if ((channel != -1) && (channel & Game::_channel_buffered)) 
     {
-      error("getController - invalid channel # %d", channel);
+      tw_error("getController - invalid channe");
     }
   switch (control2number(type)) 
     {
@@ -92,12 +85,14 @@
 
 int Control::rand() 
 {
+  STACKTRACE;
   if (channel == Game::channel_none) 
     return random();
   return (::rand() ^ ((::rand() << 12) + (::rand() <<24))) & 0x7fffffff;
 }
 
-void Control::setup() {}
+void Control::setup() {
+  STACKTRACE;}
 void Control::select_ship(Ship* ship_pointer, const char* ship_name) 
 {
   STACKTRACE;
@@ -116,10 +111,12 @@
 
 void Control::load(const char* inifile, const char* inisection) 
 {
+  STACKTRACE;
   return;
 }
 void Control::save(const char* inifile, const char* inisection) 
 {
+  STACKTRACE;
   return;
 }
 SpaceLocation *Control::get_focus() 
@@ -131,9 +128,9 @@
 }
 
 
-int Control::choose_ship(VideoWindow *window, char * prompt, Fleet *fleet) {
-	STACKTRACE;
-
+int Control::choose_ship(VideoWindow *window, char * prompt, Fleet *fleet) 
+{
+  STACKTRACE;
 	//automatically select a random ship, without interrupting the user.
 	// HumanControl is where a user can select a ship herself.
 		
@@ -143,80 +140,91 @@
 	slot = rand() % fleet->getSize();
 	return slot ;
 }
-void Control::set_target(int i) {
-	STACKTRACE;
-	if (i >= targets->N) {tw_error("oscar hamburger!!!!!!!!!");}
-	if (i == -1) {
-		index = i;
-		target = NULL;
-		return;
-		}
-	if (!valid_target(targets->item[i])) {tw_error("oscer hambuger");}
-	index = i;
-	target = targets->item[index];
-	return;
+void Control::set_target(int i) 
+{
+  STACKTRACE;
+  if (i >= targets->N) {tw_error("oscar hamburger!!!!!!!!!");}
+  if (i == -1) 
+    {
+      index = i;
+      target = NULL;
+      return;
+    }
+  if (!valid_target(targets->item[i])) {tw_error("oscer hambuger");}
+  index = i;
+  target = targets->item[index];
+  return;
+}
+
+void Control::target_stuff() 
+{
+  STACKTRACE;
+  if (index == -1) 
+    {
+      if (targets->N) 
+	{
+	  index = random() % targets->N;
+	  target = targets->item[index];
+	  goto validate;
 	}
-void Control::target_stuff() {STACKTRACE;
-	if (index == -1) {
-		if (targets->N) {
-			index = random() % targets->N;
-			target = targets->item[index];
-			goto validate;
-			}
-		else {
-			goto done;
-			}
-		}
-blah:
-	if (index >= targets->N) {
-		if (targets->N) {
-			index -= 1;
-			if (index < 0) index = 0;
-			goto blah;
-			}
-		else {
-			index = -1;
-			target = NULL;
-			goto change;
-			}
-		}
-	if (target == targets->item[index]) {
-		goto done;
-		}
-	else goto search;
-search:
-	int o;
-	o = index;
-	for (index = 0; index < targets->N; index += 1) {
+      else 
+	{
+	  goto done;
+	}
+    }
+ blah:
+  if (index >= targets->N) 
+    {
+      if (targets->N) 
+	{
+	  index -= 1;
+	  if (index < 0) index = 0;
+	  goto blah;
+	}
+      else 
+	{
+	  index = -1;
+	  target = NULL;
+	  goto change;
+	}
+    }
+  if (target == targets->item[index]) 
+    {
+      goto done;
+    }
+  else goto search;
+ search:
+  int o;
+  o = index;
+  for (index = 0; index < targets->N; index += 1) {
 		if (targets->item[index] == target) {
-			goto done;
-			}
+		  goto done;
 		}
+  }
 	index = o;
-validate:
+ validate:
 	if (!ship) {
-		goto done;
-		}
+	  goto done;
+	}
 	int start;
 	start = index;
 	while (!valid_target(targets->item[index])) {
-		index = (index + 1) % targets->N;
-		if (index == start) {
-			index = -1;
-			target = NULL;
+	  index = (index + 1) % targets->N;
+	  if (index == start) {
+	    index = -1;
+	    target = NULL;
 			goto change;
-			}
-		}
+	  }
+	}
 	target = targets->item[index];
-change:
-done:
+ change:
+ done:
 	return;
-	}
+}
 
 void Control::calculate() 
 {
-  STACKTRACE;
-  
+  STACKTRACE; 
   if (!exists()) 
     return;
 
@@ -284,12 +292,12 @@
 char *Control::getDescription() 
 {
   STACKTRACE;
-  return iname;
+   return iname;
 }
 void Control::_event(Event *e) 
 {
   STACKTRACE;
-  //add code for lag increase / decrease here
+   //add code for lag increase / decrease here
   return;
 }
 Control::Control(const char *name, int _channel, ControlType controlType) : temporary(false), target_sign_color(255), 
@@ -307,22 +315,22 @@
       _prediction_keys_index = 0;
       if (channel & Game::_channel_buffered) 
 	{
-	  error("Control::Control - invalid channel!");
+	  tw_error("invalid channel!");
 	}
     }
   iname = strdup(name);
 }
 Control::~Control() 
 {
-  STACKTRACE;
-  if (_prediction_keys) delete[] _prediction_keys;
+   if (_prediction_keys) delete[] _prediction_keys;
 }
 bool Control::die() 
 {
+  STACKTRACE;
   if (channel == Game::channel_none) 
     return Presence::die();
   // controls CANNOT arbitrarily be killed off, because the deal with networking directly
-  error("controls cannot be killed");
+  tw_error("controls cannot be killed");
   //the error can be removed eventually... 
   //I just want to find out if anything is actually calling this
   //because before this function was added, that would have resulted in a desynch
@@ -331,6 +339,7 @@
 
 bool Control::valid_target(SpaceObject *t) 
 {
+  STACKTRACE;
   // GEO: this error sometimes occur, unknown why.
   // speculation: it happened with a wasx clone; perhaps its mother died before
   // and since it shared control, and didn't check for a dead mother before the

Modified: branches/multiplayer-branch/source/melee/mfleet.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mfleet.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mfleet.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -23,7 +23,6 @@
 #include <allegro.h>
 
 #include "melee.h"
-REGISTER_FILE
 #include "mfleet.h"
 
 #include "other/twconfig.h"
@@ -77,14 +76,15 @@
 	reference_fleet->Sort();
 }
 
-    Fleet::Fleet() {STACKTRACE
+    Fleet::Fleet() {
+  STACKTRACE;
         cost = 0;
         maxFleetCost = (FleetCost)FLEET_COST_DEFAULT;
         memset(title, '\0', MAX_TITLE_LENGTH);
     };
 
     void Fleet::reset() {
-		STACKTRACE;
+  STACKTRACE;
         ships.clear();
         this->cost = 0;
         memset(title, '\0', MAX_TITLE_LENGTH);
@@ -121,7 +121,8 @@
 #define READ(a) if (int(s+sizeof(a))>psize) {delete k;tw_error ("deserialize_fleet - bad!");}memcpy(&a, &buffy[s], sizeof(a)); s += sizeof(a);
 #define READ2(a,b) if (b+s>psize) {delete k;tw_error ("deserialize_fleet - bad!");}memcpy(&a, &buffy[s], b); s += b;
 
-void Fleet::deserialize(void *data, int psize) {        
+void Fleet::deserialize(void *data, int psize) {
+  STACKTRACE;        
   unsigned char *buffy = (unsigned char *) data;
   int s = 0;
   int j;
@@ -177,6 +178,7 @@
        
 
     int Fleet::addShipType(ShipType * type) {
+  STACKTRACE;
         if ( (getSize() >= MAX_FLEET_SIZE) || (type == NULL))
             return -1;
 
@@ -187,6 +189,7 @@
     }
 
     void Fleet::addFleet(Fleet * fleetToAdd) {
+  STACKTRACE;
         for (int i=0; i<fleetToAdd->getSize(); i++)
             addShipType(fleetToAdd->getShipType(i));
     }
@@ -199,14 +202,16 @@
     
     }
 
-    ShipType * Fleet::getShipType(int slot) {STACKTRACE
+    ShipType * Fleet::getShipType(int slot) {
+  STACKTRACE;
         if ( (slot<0) || (slot>=(int)ships.size()))
             return NULL;
 
         return ships[slot];
     }
 
-    void Fleet::save(const char *filename, const char *section) {STACKTRACE
+    void Fleet::save(const char *filename, const char *section) {
+  STACKTRACE;
         int count = 0;
         char slot_str[8];
     
@@ -228,7 +233,8 @@
         set_config_int(section, "MaxFleetCost", getMaxCost());
     }
 
-    void Fleet::load(const char *filename, const char *section) {STACKTRACE
+    void Fleet::load(const char *filename, const char *section) {
+  STACKTRACE;
         int i, count;
         ShipType *type;
         char slot_str[8];
@@ -386,6 +392,7 @@
 };
 
 void Fleet::Sort(SortingMethod sortMethod, bool ascending, int startIndex, int endIndex) {
+  STACKTRACE;
   MyFleetListType::iterator _begin, _end;
   int _size = ships.size();
   
@@ -465,6 +472,7 @@
 }
 
 int Fleet::getNextFleetEntryByCharacter(unsigned int currentShip, char c) {
+  STACKTRACE;
         
         ASSERT(ships.at(currentShip) != NULL);
         ASSERT(currentShip < ships.size());

Modified: branches/multiplayer-branch/source/melee/mframe.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mframe.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mframe.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -15,6 +15,7 @@
 GNU General Public License for more details.
 */
 
+#include "util/sound.h"
 #include <allegro.h>
 #ifdef WIN32
 #include <winalleg.h>
@@ -25,7 +26,6 @@
 #include <functional>
 
 #include "melee.h"
-REGISTER_FILE
 #include "id.h"
 #include "frame.h"
 #include "util/aastr.h"
@@ -38,6 +38,7 @@
 #include "mcbodies.h"
 #include "util/pmask.h"
 #include "other/twconfig.h"
+#include "scp.h"
 
 int total_presences;
 
@@ -67,7 +68,7 @@
 int physics_time = 0;
 int render_time = 0;
 int frame_time = 1;
-DATAFILE *melee = NULL;
+//DATAFILE *melee = NULL;
 Vector2 map_size;
 double MAX_SPEED = 0;
 
@@ -173,7 +174,8 @@
 	return;
 	}
 
-void Query::end() {STACKTRACE
+void Query::end() {
+  STACKTRACE;
 	}
 
 
@@ -293,11 +295,13 @@
 	return;
 	}
 
-void Query2::end() {STACKTRACE
+void Query2::end() {
+  STACKTRACE;
 	}
 
 
-Presence::Presence() {STACKTRACE
+Presence::Presence() {
+  STACKTRACE;
 	total_presences += 1;
 	attributes = 0;
 	state = 1;
@@ -364,10 +368,12 @@
 	return ((attributes & ATTRIB_SYNCHED) != 0);
 	}
 
-SpaceLocation *Presence::get_focus() {STACKTRACE
+SpaceLocation *Presence::get_focus() {
+  STACKTRACE;
 	return NULL;
 	}
-SpaceLocation *SpaceLocation::get_focus() {STACKTRACE
+SpaceLocation *SpaceLocation::get_focus() {
+  STACKTRACE;
 	return this;
 	}
 
@@ -382,7 +388,8 @@
 	collide_flag_sameteam(0),
 	collide_flag_sameship(0)
 
-{STACKTRACE
+{
+  STACKTRACE;
 	id |= SPACE_LOCATION;
 	attributes |= ATTRIB_SYNCHED;
 	attributes |= ATTRIB_LOCATION;
@@ -407,7 +414,8 @@
 
 	}
 
-bool SpaceLocation::change_owner(SpaceLocation *new_owner) {STACKTRACE
+bool SpaceLocation::change_owner(SpaceLocation *new_owner) {
+  STACKTRACE;
 	if (new_owner) {
 		ally_flag = new_owner->ally_flag;
 		ship = new_owner->ship;
@@ -421,7 +429,8 @@
 	return true;
 	}
 
-void SpaceLocation::death() {STACKTRACE
+void SpaceLocation::death() {
+  STACKTRACE;
 }
 
 double SpaceLocation::get_angle_ex() const
@@ -455,7 +464,8 @@
 }
 
 double SpaceLocation::distance(SpaceLocation *l)
-{STACKTRACE
+{
+  STACKTRACE;
   return(distance_from(normal_pos(), l->normal_pos()));
 }
 
@@ -473,6 +483,7 @@
 
 void SpaceLocation::change_vel(Vector2 dvel)
 {
+  STACKTRACE;
 	vel += dvel;
 }
 
@@ -480,6 +491,7 @@
 */
 void SpaceLocation::change_pos(Vector2 dpos)
 {
+  STACKTRACE;
 	pos = normalize(pos + dpos);
 }
 
@@ -487,23 +499,28 @@
 */
 void SpaceLocation::change_pos(double scale)
 {
+  STACKTRACE;
 	pos *= scale;
 }
 
-void SpaceLocation::ship_died() {STACKTRACE
+void SpaceLocation::ship_died() {
+  STACKTRACE;
 	ship = NULL;
 }
 void SpaceLocation::target_died() {
+  STACKTRACE;
 	target = NULL;
 }
 
-double SpaceLocation::trajectory_angle(SpaceLocation *l) {STACKTRACE
+double SpaceLocation::trajectory_angle(SpaceLocation *l) {
+  STACKTRACE;
 	return ::trajectory_angle(pos, l->normal_pos());
 }
 
 
 bool inline SpaceLocation::detectable()
 {
+  STACKTRACE;
 	int i;
 	i = attributes & ATTRIB_UNDETECTABLE;
 
@@ -514,6 +531,7 @@
 
 
 int SpaceLocation::canCollide(SpaceLocation *other) {
+  STACKTRACE;
 	if (!detectable()) return 0;
 	if (sameShip(other)) return ((1 << other->layer) & collide_flag_sameship);
 	else if (sameTeam(other)) return ((1 << other->layer) & collide_flag_sameteam);
@@ -527,6 +545,7 @@
 
 void SpaceLocation::set_team(TeamCode k)
 {
+  STACKTRACE;
 	ally_flag &= ~team_mask;
 	ally_flag |= k << team_shift;
 }
@@ -544,14 +563,17 @@
 }
 
 void Presence::set_depth(double d) {
+  STACKTRACE;
 	_depth = int(floor(ldexp(d, 8)));
 }
 
 double Presence::get_depth() {
+  STACKTRACE;
 	return ldexp((double)_depth, -8);
 }
 
-Planet *SpaceLocation::nearest_planet() {STACKTRACE
+Planet *SpaceLocation::nearest_planet() {
+  STACKTRACE;
 	Planet *p = NULL;
 	double r = 99999999;
 	Query q;
@@ -568,120 +590,147 @@
 	}
 	return p;
 }
-void SpaceLocation::play_sound (SAMPLE *sample, int vol, int freq) {STACKTRACE
-	physics->play_sound(sample, this, vol, freq);
-	return;
+
+int SpaceLocation::translate( Vector2 delta) 
+{
+  STACKTRACE;
+  pos = normalize ( pos + delta, map_size );
+  return true;
 }
-void SpaceLocation::play_sound2 (SAMPLE *sample, int vol, int freq) {STACKTRACE
-	physics->play_sound2(sample, this, vol, freq);
-	return;
-}
-int SpaceLocation::translate( Vector2 delta) {STACKTRACE
-	pos = normalize ( pos + delta, map_size );
-	return true;
-}
 
-int SpaceLocation::accelerate(SpaceLocation *source, double angle, double velocity, double max_speed) {STACKTRACE
-	_accelerate(angle, velocity, max_speed);
-	return true;
+int SpaceLocation::accelerate(SpaceLocation *source, double angle, double velocity, double max_speed) 
+{
+  STACKTRACE;
+  _accelerate(angle, velocity, max_speed);
+  return true;
 }
-int SpaceLocation::accelerate(SpaceLocation *source, Vector2 delta_v, double max_speed) {STACKTRACE
-	_accelerate(delta_v, max_speed);
-	return true;
+int SpaceLocation::accelerate(SpaceLocation *source, Vector2 delta_v, double max_speed) 
+{
+  STACKTRACE;
+  _accelerate(delta_v, max_speed);
+  return true;
 }
-void SpaceLocation::_accelerate(double angle, double velocity, double max_speed) {STACKTRACE
-	double ovm, nvm;
-	Vector2 nv;
+void SpaceLocation::_accelerate(double angle, double velocity, double max_speed) 
+{
+  STACKTRACE;
+  double ovm, nvm;
+  Vector2 nv;
 
-	ovm = magnitude_sqr(vel);
-	nv = vel + unit_vector(angle) * velocity;
-	nvm = magnitude_sqr(nv);
-	if ((nvm <= max_speed * max_speed) || (nvm <= ovm)) {
-		vel = nv;
-	}
-	else {
-		if (ovm <= max_speed * max_speed) ovm = max_speed;
-		else ovm = sqrt(ovm);
-		vel = nv * ovm / (ovm + velocity);
-	}
-	return;
+  ovm = magnitude_sqr(vel);
+  nv = vel + unit_vector(angle) * velocity;
+  nvm = magnitude_sqr(nv);
+  if ((nvm <= max_speed * max_speed) || (nvm <= ovm)) 
+    {
+      vel = nv;
+    }
+  else 
+    {
+      if (ovm <= max_speed * max_speed) ovm = max_speed;
+      else ovm = sqrt(ovm);
+      vel = nv * ovm / (ovm + velocity);
+    }
+  return;
 }
-void SpaceLocation::_accelerate(Vector2 delta_v, double max_speed) {STACKTRACE
-	double ovm, nvm;
-	Vector2 nv;
 
-	ovm = magnitude_sqr(vel);
-	nv = vel + delta_v;
-	nvm = magnitude_sqr(nv);
-	if ((nvm <= max_speed * max_speed) || (nvm <= ovm)) {
-		//if new velocity is slow, handle normally
-		//if new velocity is fast, but we're decelerating, still handle normally
-		vel = nv;
-	}
-	else {
-		if (ovm <= max_speed * max_speed) ovm = max_speed;
-		else ovm = sqrt(ovm);
-		//otherwise, slow down closer to the maximum speed
-		//but only when turning, particularly turning fast
-		vel = nv * ovm / (ovm + magnitude(delta_v));
-	}
-	return;
+void SpaceLocation::_accelerate(Vector2 delta_v, double max_speed) 
+{
+  STACKTRACE;
+  double ovm, nvm;
+  Vector2 nv;
+
+  ovm = magnitude_sqr(vel);
+  nv = vel + delta_v;
+  nvm = magnitude_sqr(nv);
+  if ((nvm <= max_speed * max_speed) || (nvm <= ovm)) 
+    {
+      //if new velocity is slow, handle normally
+      //if new velocity is fast, but we're decelerating, still handle normally
+      vel = nv;
+    }
+  else 
+    {
+      if (ovm <= max_speed * max_speed) ovm = max_speed;
+      else ovm = sqrt(ovm);
+      //otherwise, slow down closer to the maximum speed
+      //but only when turning, particularly turning fast
+      vel = nv * ovm / (ovm + magnitude(delta_v));
+    }
+  return;
 }
 
-int SpaceLocation::accelerate_gravwhip(SpaceLocation *source, double angle, double velocity, double max_speed) {STACKTRACE
+int SpaceLocation::accelerate_gravwhip(SpaceLocation *source, 
+				       double angle, 
+				       double velocity, 
+				       double max_speed) 
+{
+  STACKTRACE;
 	Planet *p = nearest_planet();
 	if (!p) return SpaceLocation::accelerate(source, angle, velocity, max_speed);
 	double tmp;
 	tmp = distance(p) / p->gravity_range;
 	if (tmp > 1) return SpaceLocation::accelerate(source, angle, velocity, max_speed);
-	return SpaceLocation::accelerate(source, angle, velocity, max_speed * (p->gravity_whip * tmp + 1) + tmp * p->gravity_whip2);
+	return SpaceLocation::accelerate(source, angle, 
+					 velocity, 
+					 max_speed * (p->gravity_whip * tmp + 1) + 
+					 tmp * p->gravity_whip2);
 }
 
-void SpaceLocation::animate(Frame* f) {
+void SpaceLocation::animate(Frame* f) 
+{
   STACKTRACE;
 }
 
-void SpaceLocation::calculate() {STACKTRACE
-	if (target && !target->exists()) {
-		target_died();
-	}
-	if (ship && !ship->exists()) {
-		ship_died();
-	}
-	return;
+void SpaceLocation::calculate() 
+{
+  STACKTRACE;
+  if (target && !target->exists()) 
+    {
+      target_died();
+    }
+  if (ship && !ship->exists()) 
+    {
+      ship_died();
+    }
+  return;
 }
 
-void SpaceObject::set_sprite(SpaceSprite *new_sprite) {STACKTRACE
-	sprite = new_sprite;
-	size = new_sprite->size();
+void SpaceObject::set_sprite(SpaceSprite *new_sprite) 
+{
+  STACKTRACE;
+  sprite = new_sprite;
+  size = new_sprite->size();
 }
 
-void SpaceObject::calculate() {STACKTRACE
-	SpaceLocation::calculate();
-	if ((attributes & ATTRIB_STANDARD_INDEX) && sprite) {
-		sprite_index = get_index(angle, PI/2, sprite->frames());
-	}
-	return;
+void SpaceObject::calculate() 
+{
+  STACKTRACE;
+  SpaceLocation::calculate();
+  if ((attributes & ATTRIB_STANDARD_INDEX) && sprite) 
+    {
+      sprite_index = get_index(angle, PI/2, sprite->frames());
+    }
+  return;
 }
 
 SpaceObject::SpaceObject(SpaceLocation *creator, Vector2 opos, 
-	double oangle, SpaceSprite *osprite) 
-	:
-	SpaceLocation(creator, opos, oangle),
-	size(osprite->width(), osprite->height()),
-	mass(0),
-	sprite(osprite),
-	sprite_index(0)
-	{STACKTRACE
-	attributes |= ATTRIB_OBJECT;
-	if (game && game->friendly_fire) collide_flag_sameteam = ALL_LAYERS;
-	collide_flag_sameship = 0;
-	collide_flag_anyone = ALL_LAYERS;
-	id = SPACE_OBJECT;
+			 double oangle, SpaceSprite *osprite) 
+  :
+  SpaceLocation(creator, opos, oangle),
+  size(osprite->width(), osprite->height()),
+  mass(0),
+  sprite(osprite),
+  sprite_index(0)
+{
+  STACKTRACE;
+  attributes |= ATTRIB_OBJECT;
+  if (game && game->friendly_fire) collide_flag_sameteam = ALL_LAYERS;
+  collide_flag_sameship = 0;
+  collide_flag_anyone = ALL_LAYERS;
+  id = SPACE_OBJECT;
+  
+  isblockingweapons = true;
+}
 
-	isblockingweapons = true;
-	}
-
 void SpaceObject::animate(Frame *space) 
 {
   STACKTRACE;
@@ -707,18 +756,10 @@
   dp.y = min_delta(p1.y, p2.y, map_size.y);
   p2 = p1 - dp - other->size / 2;
   p1 = p1 - size / 2;
-  
-  /*	x1 = (int)(normal_x() - (w / 2.0));
-	y1 = (int)(normal_y() - (h / 2.0));
-	dx = min_delta(normal_x(), other->normal_x(), map_size.x);
-	dy = min_delta(normal_y(), other->normal_y(), Y_MAX);
-	x2 = (int)(normal_x() - dx - ((other->w) / 2.0));
-	y2 = (int)(normal_y() - dy - ((other->h) / 2.0));*/
-  
+    
   if (!sprite->collide((int)p1.x, (int)p1.y, sprite_index, (int)p2.x, (int)p2.y, 
 		       other->sprite_index, other->sprite)) 
     return;
-  //sprite->collide(x1, y1, sprite_index, x2, y2, other->sprite_index, other->sprite);
 
   inflict_damage(other);
   other->inflict_damage(this);
@@ -744,20 +785,17 @@
   tmp = dot_product(dv, _dp);
   tmp = ( -2 * tmp );
   tmp = tmp * (mass * other->mass) / (mass + other->mass);
-  if (tmp >= 0) {
-    //vel += _dp * tmp / mass;
-    //other->vel -= _dp * tmp / other->mass;
-    change_vel(_dp * tmp / mass);
-    other->change_vel( -_dp * tmp / other->mass);
-  }
+  if (tmp >= 0) 
+    {
+      change_vel(_dp * tmp / mass);
+      other->change_vel( -_dp * tmp / other->mass);
+    }
   
   Vector2 nd;
 	nd = unit_vector(dp);
 	nd /= (mass + other->mass);
 	while (sprite->collide((int)p1.x, (int)p1.y, sprite_index, (int)p2.x, (int)p2.y, 
 			       other->sprite_index, other->sprite)) {
-	  //pos = normalize(pos + nd * other->mass);
-	  //other->pos = normalize(other->pos - nd * mass);
 	  change_pos(nd * other->mass);
 	  other->change_pos(-nd * mass);
 	  
@@ -773,7 +811,8 @@
 }
 
 double SpaceObject::collide_ray(Vector2 lp1, Vector2 lp2, double llength)
-{STACKTRACE
+{
+  STACKTRACE;
 	int collide_x = (int)(lp2.x);
 	int collide_y = (int)(lp2.y);
 	Vector2 d;
@@ -790,19 +829,45 @@
 	return(llength);
 }
 
-void SpaceObject::inflict_damage(SpaceObject *other) {STACKTRACE
-	int i;
-	if (damage_factor > 0) {
-		i = iround_down(damage_factor / 2);
-		if(i >= BOOM_SAMPLES) i = BOOM_SAMPLES - 1;
-		play_sound((SAMPLE *)(melee[MELEE_BOOM + i].dat));
-		damage(other, damage_factor);
-		}
-	else damage(other, 0);
-	return;
+void SpaceObject::inflict_damage(SpaceObject *other) 
+{
+  STACKTRACE;
+  int i;
+  if (damage_factor > 0) 
+    {
+      i = iround_down(damage_factor / 2);
+      if(i >= BOOM_SAMPLES) 
+	i = BOOM_SAMPLES - 1;
+      
+      // temporary code
+      switch(i)
+	{
+	  case 0:
+	    tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+	    break;
+	  case 1:
+	    tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+	    break;
+	  case 2:
+	    tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+	    break;
+	  case 3:
+	    tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+	    break;
+	default:
+	  {
+	    tw_error("Unknown BOOM sound %d", i);
+	  }
 	}
+      damage(other, damage_factor);
+    }
+  else 
+    damage(other, 0);
+  return;
+}
 
-void SpaceObject::death() {STACKTRACE
+void SpaceObject::death() {
+  STACKTRACE;
 	if (attributes & ATTRIB_NOTIFY_ON_DEATH) {
 		physics->object_died(this, NULL);
 		attributes &= ~ ATTRIB_NOTIFY_ON_DEATH;
@@ -815,7 +880,8 @@
 	SpaceLocation(creator, lpos, langle),
 	length(llength),
 	color(lcolor)
-	{STACKTRACE
+	{
+  STACKTRACE;
 	id = SPACE_LINE;
 	attributes |= ATTRIB_LINE;// | ATTRIB_COLLIDE_STATIC;
 	layer = LAYER_LINES;
@@ -845,21 +911,41 @@
   return(length);
 }
 
-void SpaceLine::inflict_damage(SpaceObject *other) {STACKTRACE
-	int i;
-	i = iround_down(damage_factor / 2);
-	if(i >= BOOM_SAMPLES)
-		i = BOOM_SAMPLES - 1;
-	play_sound((SAMPLE *)(melee[MELEE_BOOM + i].dat));
-	damage(other, damage_factor);
-	collide_flag_anyone = collide_flag_sameship = collide_flag_sameteam = 0;
-	physics->add(new Animation( this, 
-			pos + edge(), meleedata.sparkSprite, 0, 
-			SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
-	return;
-	}
+void SpaceLine::inflict_damage(SpaceObject *other) 
+{
+  STACKTRACE;
+  int i;
+  i = iround_down(damage_factor / 2);
+  if(i >= BOOM_SAMPLES)
+    i = BOOM_SAMPLES - 1;
 
-void SpaceLine::animate(Frame *space) {
+  // temporary code
+  switch(i)
+    {
+    case 0:
+      tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+      break;
+    case 1:
+      tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+      break;
+    case 2:
+      tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+      break;
+    case 3:
+      tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+      break;
+    }
+
+  damage(other, damage_factor);
+  collide_flag_anyone = collide_flag_sameship = collide_flag_sameteam = 0;
+  physics->add(new Animation( this, 
+			      pos + edge(), game->meleedata.sparkSprite, 0, 
+			      SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
+  return;
+}
+
+void SpaceLine::animate(Frame *space) 
+{
   STACKTRACE;
   
   Vector2 p1 = corner( pos );
@@ -915,10 +1001,12 @@
 }
 
 unsigned int Physics::new_ship() {
+  STACKTRACE;
 	last_ship += 1;
 	return last_ship;
 	}
 TeamCode Physics::new_team() {
+  STACKTRACE;
 	last_team += 1;
 	return last_team;
 	}
@@ -965,7 +1053,7 @@
 
 
 void Physics::add(SpaceLocation *o) {
-	STACKTRACE;
+  STACKTRACE;
 	if (o->attributes & ATTRIB_INGAME) {tw_error("addItem - already added");}
 	if (!o->isLocation()) {tw_error("addItem - catastrophic");}
 	//if (!o->_serial) _list(o);
@@ -1055,8 +1143,9 @@
     return false;
 }
 
-void Physics::calculate() {
-  _STACKTRACE("Physics::calculate()");
+void Physics::calculate() 
+{
+  STACKTRACE;
   int i;
   
   //adjust time
@@ -1195,8 +1284,9 @@
 }
 
 
-void Physics::collide() {
-  _STACKTRACE("Physics::collide()");
+void Physics::collide() 
+{
+  STACKTRACE;
   PMASKDATA_FLOAT *tmp;
   int l = 0;
   tmp = new PMASKDATA_FLOAT[item.size()];
@@ -1250,7 +1340,8 @@
   return;
 }
 
-void Physics::prepare() {STACKTRACE
+void Physics::prepare() {
+  STACKTRACE;
 	::physics_time = this->game_time;
 	::render_time = this->game_time;
 	::frame_time = this->frame_time;
@@ -1259,7 +1350,7 @@
 	return;
 }
 int Physics::checksum() {
-  _STACKTRACE("Physics::checksum");
+  STACKTRACE;
   Uint32 g = 0;
   for(std::list<SpaceLocation*>::iterator i=item.begin();i!=item.end();i++)
     {
@@ -1273,23 +1364,10 @@
     }
   return g;// + (tw_random_state_checksum()) & 255));
 }
-void Physics::dump_state ( const char *file_name ) {
-  STACKTRACE;
-  //unimplemented
+void Physics::dump_state ( const char *file_name ) 
+{
 }
-void Physics::play_sound (SAMPLE *sample, SpaceLocation *source, int vol, int freq) {
-  STACKTRACE;
-  sound.play(sample, vol, 128, iround(freq * turbo));
-  return;
-}
-void Physics::play_sound2 (SAMPLE *sample, SpaceLocation *source, int vol, int freq) {
-  STACKTRACE;
-  sound.stop(sample);
-  play_sound(sample, source, vol, freq);
-  return;
-}
 
-
 void Physics::log_file (const char *fname)
 {
   tw_set_config_file(fname);
@@ -1298,12 +1376,14 @@
 
 void Physics::ship_died(Ship *who, SpaceLocation *source)
 {
+  STACKTRACE;
 	// nothing ...
 }
 
 
 void Physics::object_died(SpaceObject *who, SpaceLocation *source)
 {
+  STACKTRACE;
   if (who && who->isShip())
     {
       ship_died((Ship*)who, source);

Modified: branches/multiplayer-branch/source/melee/mframe.h
===================================================================
--- branches/multiplayer-branch/source/melee/mframe.h	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mframe.h	2004-09-28 19:53:03 UTC (rev 71)
@@ -29,7 +29,7 @@
 extern Vector2 map_size;
 extern double MAX_SPEED;
 
-extern DATAFILE *melee;
+//extern DATAFILE *melee;
 
 typedef unsigned int TeamCode;
 
@@ -37,368 +37,380 @@
 class Planet;
 class Presence;
 
-
 enum {
-	ATTRIB_SYNCHED         =    (1<<0), 
-	ATTRIB_LOGGED =             (1<<1), 
-	ATTRIB_INGAME =             (1<<2), 
+  ATTRIB_SYNCHED         =    (1<<0), 
+  ATTRIB_LOGGED          =    (1<<1), 
+  ATTRIB_INGAME          =    (1<<2), 
+  
+  ATTRIB_TARGET          =    (1<<3),
+  ATTRIB_FOCUS           =    (1<<4),
+  ATTRIB_ACTIVE_FOCUS    =    (1<<5),
+  
+  ATTRIB_NOTIFY_ON_DEATH =    (1<<6),
+  
+  ATTRIB_STANDARD_INDEX  =    (1<<7),
+  ATTRIB_STRICT_RECT     =    (1<<8),
+  
+  ATTRIB_COLLIDE_STATIC  =    (1<<9),
+  
+  ATTRIB_LOCATION        =    (1<<10), 
+  ATTRIB_OBJECT          =    (1<<11), 
+  ATTRIB_LINE            =    (1<<12),
+  ATTRIB_SHOT            =    (1<<13), 
+  ATTRIB_SHIP            =    (1<<14),
 
-	ATTRIB_TARGET =             (1<<3),
-	ATTRIB_FOCUS  =             (1<<4),
-	ATTRIB_ACTIVE_FOCUS =       (1<<5),
-
-	ATTRIB_NOTIFY_ON_DEATH =    (1<<6),
-
-	ATTRIB_STANDARD_INDEX =     (1<<7),
-	ATTRIB_STRICT_RECT =        (1<<8),
-
-	ATTRIB_COLLIDE_STATIC =     (1<<9),
-
-	//ATTRIB_BOUNCY         //currently, anything that has mass
-	//ATTRIB_MASSFULL       //anything that has mass
-	//ATTRIB_CREWED         //currently, only ships with green crew
-	//ATTRIB_ORGANIC        //currently, only ships with green crew
-	//ATTRIB_SENTIENT       //currently, only ships
-	//ATTRIB_NEUTRAL        //asteroids & planets
-	//ATTRIB_CONTACT_DANGER //things to avoid
-
-	ATTRIB_LOCATION =           (1<<10), 
-	ATTRIB_OBJECT =             (1<<11), 
-	ATTRIB_LINE =               (1<<12),
-	ATTRIB_SHOT =               (1<<13), 
-	ATTRIB_SHIP =               (1<<14),
-
-	// this hides objects from queries = important in case there are many objects (hide hotspots!!)!
-	ATTRIB_UNDETECTABLE =       (1<<15)
+  // this hides objects from queries = important in case there are many objects (hide hotspots!!)!
+  ATTRIB_UNDETECTABLE    =    (1<<15)
 };
 
+/// \brief melee universe
+class Physics : public BaseClass 
+{
+ public:
+  
+  std::vector<SpaceLocation*> quadrant;
+  friend struct Query;
+  
+  std::list<SpaceLocation*> item;
+  
+  std::list<Presence*> presence;
+  
+  /// add space location to universe
+  void add(SpaceLocation *p);
+  /// add presence from universe
+  void add(Presence *p);
+  /// remove space location to universe
+  bool remove(SpaceLocation *o);
+  /// remove presence from universe
+  bool remove(Presence *p) ;
+  
+  TeamCode last_team;
+  unsigned int last_ship;
 
-class Physics : public BaseClass {
-	public:
-
-	std::vector<SpaceLocation*> quadrant;
-	friend struct Query;
-
-	//int num_items, max_items;
-	std::list<SpaceLocation*> item;
-
-	//int num_presences, max_presences;
-	std::list<Presence*> presence;
-
-	void add(SpaceLocation *p);
-	void add(Presence *p);
-	bool remove(SpaceLocation *o);
-	bool remove(Presence *p) ;
-
-	TeamCode last_team;
-	unsigned int last_ship;
-
-	protected:
-	virtual void collide();
-
-	public:
-	virtual unsigned int new_ship();
-	virtual TeamCode new_team();
-	unsigned int get_code(unsigned int ship, TeamCode team) ;
-	virtual void merge_teams ( TeamCode team1, TeamCode team2) ; //causes team1 and team2 to be the same team (changes members of team2 to being members of team1 instead)
-	virtual void switch_team ( unsigned int ship,  TeamCode team ) ; //causes ship to join team.  if ship was already on an old team, ship betrays that team.  
-
-	int frame_number; //the total number of frames that have passed so far
-	int frame_time;
-	int game_time;
-	double max_speed;
-	Vector2 size;
-	double turbo;
-
-	virtual void prepare();
-
-	virtual void calculate();
-	virtual void animate(Frame *frame);
-
-	/*Presence *find_serial(int serial);
-	int _find_serial(int serial);*/
-
-	virtual void play_sound (SAMPLE *sample, SpaceLocation *source, int vol = 255, int freq = 1000);
-	virtual void play_sound2 (SAMPLE *sample, SpaceLocation *source, int vol = 255, int freq = 1000);
-
-	virtual void preinit();
-	virtual void init();
-	virtual ~Physics();
-	virtual void destroy_all();
-
-	virtual int checksum();
-	virtual void dump_state ( const char *file_name );
-
-	// moved ROB - from mgame to here.
-	bool friendly_fire;
-	double shot_relativity;
-
-	// to init parameters of space-objects...
-	virtual void log_file (const char *fname);
-
-	// to handle the death of objects in the game ...
-	virtual void object_died(SpaceObject *who, SpaceLocation *source);
-	virtual void ship_died(Ship *who, SpaceLocation *source);
+ protected:
+  /// \brief calculate which object collide
+  virtual void collide();
+  
+ public:
+  virtual unsigned int new_ship();
+  virtual TeamCode new_team();
+  unsigned int get_code(unsigned int ship, TeamCode team) ;
+  /// \brief causes team1 and team2 to be the same team (changes members of team2 to 
+  /// being members of team1 instead)
+  virtual void merge_teams ( TeamCode team1, TeamCode team2) ; 
+  /// causes ship to join team.  if ship was already on an old team, ship betrays that team.  
+  virtual void switch_team ( unsigned int ship,  TeamCode team ) ; 
+  
+  /// the total number of frames that have passed so far
+  int frame_number; 
+  int frame_time;
+  int game_time;
+  double max_speed;
+  Vector2 size;
+  double turbo;
+  
+  virtual void prepare();
+  
+  virtual void calculate();
+  virtual void animate(Frame *frame);
+    
+  virtual void preinit();
+  virtual void init();
+  virtual ~Physics();
+  virtual void destroy_all();
+  
+  virtual int checksum();
+  virtual void dump_state ( const char *file_name );
+  
+  bool friendly_fire;  ///< is friendly fire damage
+  double shot_relativity;
+  
+  /// to init parameters of space-objects...
+  virtual void log_file (const char *fname);
+  
+  /// to handle the death of objects in the game ...
+  virtual void object_died(SpaceObject *who, SpaceLocation *source);
+  virtual void ship_died(Ship *who, SpaceLocation *source);
 };
 
 /// \brief Any item in the game
-class Presence : public BaseClass { 
-	friend class Physics;
-	public:
+class Presence : public BaseClass 
+{ 
+  friend class Physics;
+ public:
+  int    id;           ///< id code, indicates what type it is
+  int attributes;      ///< describes it
+  signed char state;   ///< may be set to any positive value if alive, or 0 to kill it
 
-	int    id;            // id code, indicates what type it is
-	int attributes;       // describes it
-	signed char state;    // may be set to any positive value if alive, or 0 to kill it
-	//private: int _serial; // unique reference number
-	public:
-	int _depth;  // determines rendering order ; read/write with set_depth, get_depth
-	void set_depth(double d);
-	double get_depth();
-	friend int compare_depth (const void *_a, const void *_b) ;
-
-	inline void add(SpaceLocation *o) {physics->add(o);}
-	inline void add(Presence *p) {physics->add(p);}
-
-	virtual void animate(Frame *space); //displays ? on screen (NOT permitted to affect game physics in any way)
-
-	virtual void calculate(); //advance the item frame_time milliseconds in time
-	inline bool exists() {return state > 0;};  //returns 0 if dead, non-zero if alive
-	Presence();
-	virtual ~Presence();  // called when a presence is deallocated
-	virtual SpaceLocation *get_focus();
-
-	virtual bool die(); // calling this kills a presence (returns true on success)
-	virtual void death();
-
-	bool isLocation() const ;  //returns true if it is the specified engine-defined type
-	bool isLine() const ;
-	bool isObject() const ;
-	bool isAsteroid() const ;
-	bool isPlanet() const ;
-	bool isShip() const ;
-	bool isShot() const;
-	bool isSynched() const;
-
+ public:
+  int _depth;    ///< determines rendering order ; read/write with set_depth, get_depth
+  void set_depth(double d);
+  double get_depth();
+  friend int compare_depth (const void *_a, const void *_b) ;
+  
+  inline void add(SpaceLocation *o) {physics->add(o);}
+  inline void add(Presence *p) {physics->add(p);}
+  
+  /// displays ? on screen (NOT permitted to affect game physics in any way)
+  virtual void animate(Frame *space); 
+  
+  virtual void calculate(); ///< advance the item frame_time milliseconds in time
+  inline bool exists() {return state > 0;};  ///< returns 0 if dead, non-zero if alive
+  Presence();
+  virtual ~Presence();      ///< called when a presence is deallocated
+  virtual SpaceLocation *get_focus();
+  
+  virtual bool die();       ///< calling this kills a presence (returns true on success)
+  virtual void death();
+  
+  bool isLocation() const ;  ///< returns true if it is the specified engine-defined type
+  bool isLine() const ;      ///< returns true if it is the specified engine-defined type
+  bool isObject() const ;    ///< returns true if it is the specified engine-defined type
+  bool isAsteroid() const ;  ///< returns true if it is the specified engine-defined type
+  bool isPlanet() const ;    ///< returns true if it is the specified engine-defined type
+  bool isShip() const ;      ///< returns true if it is the specified engine-defined type
+  bool isShot() const;       ///< returns true if it is the specified engine-defined type
+  bool isSynched() const;    ///< returns true if it is the specified engine-defined type
+  
 };
 
-/// \brief any item in the game that has a location
-class SpaceLocation : public Presence { // base class for all items in game
-	friend class Physics;
-	friend struct Query;
+/// \brief any item in the game that has a location, base class for all items in game
+class SpaceLocation : public Presence 
+{ 
+  friend class Physics;
+  friend struct Query;
 
-protected: public: //aught to be protected, but we're lazy
-	Vector2 pos;
-	union {
-		SpaceObject   *qnexto;
-		SpaceLine     *qnextl;
-		SpaceLocation *qnext;
-	};
-	public:
-	int    layer;       // effects collisions & queries... (will be phased out eventually)
-protected: public://aught to be protected, but we're lazy
-	Vector2 vel;
-	double angle;        // the angle it's facing (sometimes not very meaningfull)
+ protected: public: 
+  //aught to be protected, but we're lazy
+  Vector2 pos;
+  union 
+  {
+    SpaceObject   *qnexto;
+    SpaceLine     *qnextl;
+    SpaceLocation *qnext;
+  };
+ public:
+  int    layer;       ///< effects collisions & queries... (will be phased out eventually)
+ protected: public://aught to be protected, but we're lazy
+  Vector2 vel;
+  double angle;       ///< the angle it's facing (sometimes not very meaningfull)
+  
+  enum { 
+    team_bits = 14, ship_bits =  18, 
+    team_shift = 0, ship_shift = 14, 
+    team_mask = ((1<<team_bits)-1) << team_shift,
+    ship_mask = ((1<<ship_bits)-1) << ship_shift
+  };
+  unsigned int ally_flag;
 
+ public:
 
-	enum { 
-			team_bits = 14, ship_bits =  18, 
-			team_shift = 0, ship_shift = 14, 
-			team_mask = ((1<<team_bits)-1) << team_shift,
-			ship_mask = ((1<<ship_bits)-1) << ship_shift
-		};
-	unsigned int ally_flag;
+  Ship *ship;          ///< the ship it's associated with
+  ShipData *data;      ///< the data module it depends upon
+  SpaceObject *target; ///< it's target, if it has one
 
-	public:
+  inline  bool sameShip (const SpaceLocation *other) {return ally_flag == other->ally_flag;}
+  virtual bool sameTeam (const SpaceLocation *other) const;
+  TeamCode get_team() const;
+  void set_team(TeamCode k);
+  
+  virtual void ship_died();
+  virtual void target_died();
+  virtual bool change_owner(SpaceLocation *new_owner);
+  
+  
+  double damage_factor;         ///< the damage this item inflicts
+  
+  int collide_flag_anyone;   ///< mask for which layers it can collide with for non-allies
+  int collide_flag_sameteam; ///< mask for which layers it can collide with for allies
+  int collide_flag_sameship; ///< mask for which layers it can collide with objects associated with the same ship
 
-	Ship *ship;          // the ship it's associated with
-	ShipData *data;      // the data module it depends upon
-	SpaceObject *target; // it's target, if it has one
+  int damage(SpaceLocation *who, double normal, double direct = 0) 
+    { 
+      return who->handle_damage(this, normal, direct); 
+    }
 
-	inline  bool sameShip (const SpaceLocation *other) {return ally_flag == other->ally_flag;}
-	virtual bool sameTeam (const SpaceLocation *other) const;
-	TeamCode get_team() const;
-	void set_team(TeamCode k);
+  /// \return (this is a lie)
+  /// -1 = benefitted from damage
+  ///  0 = ignored damage
+  ///  1 = took damage normally
+  ///  2 = reduced damage
+  virtual int handle_damage(SpaceLocation *source, double normal, double direct = 0);
+  virtual int handle_fuel_sap(SpaceLocation *source, double normal);
+  virtual double handle_speed_loss(SpaceLocation *source, double normal);
+  
+  virtual void change_vel(Vector2 dvel);
+  virtual void change_pos(Vector2 dpos);
+  virtual void change_pos(double scale);
 
-	virtual void ship_died();
-	virtual void target_died();
-	virtual bool change_owner(SpaceLocation *new_owner);
+  SpaceLocation(SpaceLocation *creator, Vector2 lpos, double langle);
+  virtual void death();      ///< called after an item is killed
+  virtual ~SpaceLocation();  ///< called when an item is deallocated
 
+  double get_angle() const;  
+  Vector2 get_vel() const {return vel;}
 
-	double damage_factor;         // the damage this item inflicts
+  virtual double get_angle_ex() const; ///< stupid helper for camera
 
-	int    collide_flag_anyone;   // mask for which layers it can collide with for non-allies
-	int    collide_flag_sameteam; // mask for which layers it can collide with for allies
-	int    collide_flag_sameship; // mask for which layers it can collide with objects associated with the same ship
+  int getID() const;
 
+  virtual SpaceLocation *get_focus();
 
+  /// returns the x,y coordinates, and normalizes it (0 <= pos.x < map_size.x), (0 <= pos.y < map_size.y)
+  Vector2 normal_pos() const;          
+  Vector2 nearest_pos(SpaceLocation *l) const;
+  double distance(SpaceLocation *l);
+  double trajectory_angle(SpaceLocation *l);
 
-	int damage(SpaceLocation *who, double normal, double direct = 0) { return who->handle_damage(this, normal, direct); }
-	/*handle_damage returns: (this is a lie)
-		-1 = benefitted from damage
-		 0 = ignored damage
-		 1 = took damage normally
-		 2 = reduced damage
-	*/
-	virtual int handle_damage(SpaceLocation *source, double normal, double direct = 0);
-	virtual int handle_fuel_sap(SpaceLocation *source, double normal);
-	virtual double handle_speed_loss(SpaceLocation *source, double normal);
-
-	virtual void change_vel(Vector2 dvel);
-	virtual void change_pos(Vector2 dpos);
-	virtual void change_pos(double scale);
-
-	SpaceLocation(SpaceLocation *creator, Vector2 lpos, double langle);
-	virtual void death();      // called after an item is killed
-	virtual ~SpaceLocation();  // called when an item is deallocated
-
-	double get_angle() const;        // various public functions for reading otherwise protected data
-	Vector2 get_vel() const {return vel;}
-
-	virtual double get_angle_ex() const; // stupid helper for camera
-
-	int getID() const;
-
-	virtual SpaceLocation *get_focus();
-
-	Vector2 normal_pos() const;          // returns the x,y coordinates, and normalizes it (0 <= pos.x < map_size.x), (0 <= pos.y < map_size.y)
-	Vector2 nearest_pos(SpaceLocation *l) const;
-	double distance(SpaceLocation *l);
-	double trajectory_angle(SpaceLocation *l);
-
-	virtual double isProtected() const;  // returns 0 normally, or a positive number if shielded
-	virtual double isInvisible() const;  // returns 0 normally, or a positive number if cloaked
+  virtual double isProtected() const;  ///< returns 0 normally, or a positive number if shielded
+  virtual double isInvisible() const;  ///< returns 0 normally, or a positive number if cloaked
 	
-	// this is used in queries, to see if it's detectable and should be examined.
-	virtual bool detectable();
+  /// this is used in queries, to see if it's detectable and should be examined.
+  virtual bool detectable();
 
-	Planet *nearest_planet(); //returns the nearest planet, or NULL if no planets are nearby
+  Planet *nearest_planet(); ///< returns the nearest planet, or NULL if no planets are nearby
 
-	virtual int canCollide(SpaceLocation *other); // returns 0 if collision impossible
+  virtual int canCollide(SpaceLocation *other); ///< returns 0 if collision impossible
 
-	virtual int translate(Vector2 rel_pos); //moves an object (returns non-zero on success)
-	int translate(double rel_x, double rel_y) {return translate(Vector2(rel_x,rel_y));}
-	void _accelerate(double angle, double vel, double max_speed=MAX_SPEED); //accelerates an object by vel at angle, to a maximum of max_speed
-	void _accelerate(Vector2 delta_v, double max_speed=MAX_SPEED); //changes an objects velocity by delta_v, to a maximum of max_speed
-	virtual int accelerate(SpaceLocation *source, double angle, double vel, double max_speed=MAX_SPEED); //accelerates an object by vel at angle, to a maximum of max_speed
-	virtual int accelerate(SpaceLocation *source, Vector2 delta_v, double max_speed=MAX_SPEED); //changes an objects velocity by delta_v, to a maximum of max_speed
-	virtual int accelerate_gravwhip(SpaceLocation *source, double angle, double velocity, double max_speed) ; //accelerates an object, with gravity whip
-	void match_velocity(SpaceLocation *other) {vel = other->vel;}
+  virtual int translate(Vector2 rel_pos); ///< moves an object (returns non-zero on success)
+  int translate(double rel_x, double rel_y) {return translate(Vector2(rel_x,rel_y));}
+  /// accelerates an object by vel at angle, to a maximum of max_speed
+  void _accelerate(double angle, double vel, double max_speed=MAX_SPEED); 
+  /// changes an objects velocity by delta_v, to a maximum of max_speed
+  void _accelerate(Vector2 delta_v, double max_speed=MAX_SPEED); 
+  /// accelerates an object by vel at angle, to a maximum of max_speed
+  virtual int accelerate(SpaceLocation *source, double angle, double vel, double max_speed=MAX_SPEED); 
+  /// changes an objects velocity by delta_v, to a maximum of max_speed
+  virtual int accelerate(SpaceLocation *source, Vector2 delta_v, double max_speed=MAX_SPEED); 
+  /// accelerates an object, with gravity whip
+  virtual int accelerate_gravwhip(SpaceLocation *source, double angle, double velocity, 
+				  double max_speed); 
+  void match_velocity(SpaceLocation *other) {vel = other->vel;}
 
-	virtual void animate(Frame *space); //displays an object on screen (NOT permitted to affect game physics in any way)
-	virtual void calculate(); //advance the item frame_time milliseconds in time
-
-	void play_sound (SAMPLE *sample, int vol = 256, int freq = 1000); //plays a sound
-	void play_sound2 (SAMPLE *sample, int vol = 256, int freq = 1000);//like play_sound, only stops the previous sound
+  /// displays an object on screen (NOT permitted to affect game physics in any way)
+  virtual void animate(Frame *space); 
+  /// advance the item frame_time milliseconds in time
+  virtual void calculate(); 
 };
 
 /// \brief any item with a sprite (only SpaceObjects can bounce)
-class SpaceObject : public SpaceLocation {
-	public:
-	Vector2 size;      //size of sprite
-	double  mass; //mass of object
-	bool isblockingweapons;	// this object blocks weaponry (shots)
-	protected:
-	SpaceSprite *sprite; //the pictures that this object looks like
-	int          sprite_index; //which one of those pictures is active at the moment
+class SpaceObject : public SpaceLocation 
+{
+ public:
+  Vector2 size; ///< size of sprite
+  double  mass; ///< mass of object
+  bool isblockingweapons; ///< this object blocks weaponry (shots)
+ protected:
+  SpaceSprite *sprite; ///< the pictures that this object looks like
+  int sprite_index;    ///< which one of those pictures is active at the moment
 
-	public:
-	SpaceObject(SpaceLocation *creator, Vector2 opos, double oangle, 
-			SpaceSprite *osprite);
-	virtual void death();      // called after an item is killed
+ public:
+  SpaceObject(SpaceLocation *creator, Vector2 opos, double oangle, 
+	      SpaceSprite *osprite);
+  virtual void death();      ///< called after an item is killed
 
-	SpaceSprite *get_sprite() const {return sprite;}
-	int get_sprite_index() const {return sprite_index;}
+  SpaceSprite *get_sprite() const {return sprite;}
+  int get_sprite_index() const {return sprite_index;}
+  
+  Vector2 get_size() const {return size;}
+  
+  virtual void animate(Frame *space);
+  virtual void calculate();
+  virtual void collide(SpaceObject *other);
+  virtual double collide_ray(Vector2 lpos1, Vector2 lpos2, double llength);
 
-	Vector2 get_size() const {return size;}
-
-	virtual void animate(Frame *space);
-	virtual void calculate();
-	virtual void collide(SpaceObject *other);
-	virtual double collide_ray(Vector2 lpos1, Vector2 lpos2, double llength);
-
-	virtual void inflict_damage(SpaceObject *other);
-
-	virtual void set_sprite ( SpaceSprite *sprite );
+  virtual void inflict_damage(SpaceObject *other);
+  
+  virtual void set_sprite ( SpaceSprite *sprite );
 };
 
-/// \brief an item that appears as a line.  these can only collide with SpaceObjects, but not other lines.  
-class SpaceLine : public SpaceLocation {
-	protected:
-	double length;
-	int    color;
+/// an item that appears as a line.  these can only collide with SpaceObjects, but not other lines.  
+class SpaceLine : public SpaceLocation 
+{
+ protected:
+  double length;
+  int    color;
 
-	public:
-	SpaceLine(SpaceLocation *creator, Vector2 lpos, double langle, 
-		double llength, int lcolor);
-
-	Vector2 edge() const;
-	double edge_x() const;
-	double edge_y() const;
-	double get_length() const;
-
-	virtual void animate(Frame *space);
-	virtual void collide(SpaceObject *o);
-	virtual void inflict_damage(SpaceObject *other);
+ public:
+  SpaceLine(SpaceLocation *creator, Vector2 lpos, double langle, 
+	    double llength, int lcolor);
+  
+  Vector2 edge() const;
+  double edge_x() const;
+  double edge_y() const;
+  double get_length() const;
+  
+  virtual void animate(Frame *space);
+  virtual void collide(SpaceObject *o);
+  virtual void inflict_damage(SpaceObject *other);
 };
 
-struct Query {
-	private:
-	int layers;
-	SpaceLocation *target;
-	int qx_min, qx_max;
-	int qy_min, qy_max;
-	int qx, qy;
-	Vector2 target_pos;
-	double range_sqr;
-	void next_quadrant ();
-	public:
-	union {
-		SpaceObject   *currento;
-		SpaceLine     *currentl;
-		SpaceLocation *current;
-	};
-	void begin (SpaceLocation *target, int layers, double range);
-	void begin (SpaceLocation *target, Vector2 center, int layers, double range);
-	void next ();
-	void end();
-	private:
-	bool current_invalid() {
-		if (!(bit(current->layer) & layers) || (current == target) || !current->exists()) return true;
-		if (magnitude_sqr(min_delta(target_pos, current->normal_pos())) > range_sqr) return true;
-		return false;
-	}
+struct Query 
+{
+  private:
+int layers;
+  SpaceLocation *target;
+  int qx_min, qx_max;
+  int qy_min, qy_max;
+  int qx, qy;
+  Vector2 target_pos;
+  double range_sqr;
+  void next_quadrant ();
+  public:
+  union 
+  {
+    SpaceObject   *currento;
+    SpaceLine     *currentl;
+    SpaceLocation *current;
+  };
+  void begin (SpaceLocation *target, int layers, double range);
+  void begin (SpaceLocation *target, Vector2 center, int layers, double range);
+  void next ();
+  void end();
+  private:
+  bool current_invalid() 
+  {
+    if (!(bit(current->layer) & layers) || (current == target) || !current->exists()) return true;
+    if (magnitude_sqr(min_delta(target_pos, current->normal_pos())) > range_sqr) return true;
+    return false;
+  }
 };
 
 inline Uint64 REQUIRE_ATTRIBUTES(Uint32 a) {return a | (Uint64(a) << 32);}
 inline Uint64 PROHIBIT_ATTRIBUTES(Uint32 a) {return Uint64(a) << 32;}
 
-struct Query2 {
-	private:
-	int attributes_desired;
-	int attributes_mask;
-	SpaceLocation *target;
-	int qx_min, qx_max;
-	int qy_min, qy_max;
-	int qx, qy;
-	Vector2 target_pos;
-	double range_sqr;
-	void next_quadrant ();
-	public:
-	union {
-		SpaceObject   *currento;
-		SpaceLine     *currentl;
-		SpaceLocation *current;
-	};
-	void begin (SpaceLocation *target, Uint64 attribute_filter, double range);
-	void begin (SpaceLocation *target, Vector2 center, Uint64 attribute_filter, double range);
-	void next ();
-	void end();
-	private:
-	bool current_invalid() {
-		if (((current->attributes & attributes_mask) != attributes_desired) || (current == target) || !current->exists()) return true;
-		if (magnitude_sqr(min_delta(target_pos, current->normal_pos())) > range_sqr) return true;
-		return false;
-	}
+struct Query2 
+{
+  private:
+int attributes_desired;
+  int attributes_mask;
+  SpaceLocation *target;
+  int qx_min, qx_max;
+  int qy_min, qy_max;
+  int qx, qy;
+  Vector2 target_pos;
+  double range_sqr;
+  void next_quadrant ();
+  public:
+  union {
+    SpaceObject   *currento;
+    SpaceLine     *currentl;
+    SpaceLocation *current;
+  };
+  void begin (SpaceLocation *target, Uint64 attribute_filter, double range);
+  void begin (SpaceLocation *target, Vector2 center, Uint64 attribute_filter, double range);
+  void next ();
+  void end();
+  private:
+  bool current_invalid() 
+  {
+    if (((current->attributes & attributes_mask) != attributes_desired) || 
+	(current == target) || !current->exists()) 
+      return true;
+    if (magnitude_sqr(min_delta(target_pos, current->normal_pos())) > range_sqr) 
+      return true;
+    return false;
+  }
 };
 
 #endif // __MFRAME_H__

Modified: branches/multiplayer-branch/source/melee/mgame.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mgame.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mgame.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,7 +1,7 @@
 /* $Id: mgame.cpp,v 1.5 2004/08/08 17:36:06 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -15,21 +15,16 @@
 GNU General Public License for more details.
 */
 
-//#define REVERSE_CONNECT
-//for debuging
-
 #include <exception>
 using std::exception;
-#include <typeinfo>//
+#include <typeinfo>
 
 #include <stdio.h>
 #include <string.h>
-//#include <stdlib.h>//
-#include <string.h>
+
 #include <allegro.h>
 
 #include "melee.h"
-REGISTER_FILE
 #include "scp.h"
 #include "util/history.h"
 #include "util/get_time.h"
@@ -57,78 +52,78 @@
 
 int random_seed[2];
 
-MeleeData meleedata;
 
 MeleeData::MeleeData()
 {
-	panelSprite             = NULL;
-	kaboomSprite            = NULL;
-	hotspotSprite           = NULL;
-	sparkSprite             = NULL;
-	asteroidExplosionSprite = NULL;
-	asteroidSprite          = NULL;
-	planetSprite            = NULL;
-	xpl1Sprite              = NULL;
+  STACKTRACE;
+  
+  DATAFILE*  melee = load_datafile(data_full_path("melee.dat").c_str());
+  
+  if (!melee) 
+    tw_error("Error loading melee data\n");
 
-	planet_victory		= "";	
-
-	melee = NULL;
+  panelSprite = new SpaceSprite(&melee[MELEE_PANEL], 
+				PANEL_FRAMES, SpaceSprite::IRREGULAR);
+  kaboomSprite = new SpaceSprite(&melee[MELEE_KABOOM], KABOOM_FRAMES,
+				 SpaceSprite::ALPHA | SpaceSprite::MASKED | 
+				 SpaceSprite::MIPMAPED);
+  hotspotSprite = new SpaceSprite(&melee[MELEE_HOTSPOT], HOTSPOT_FRAMES,
+				  SpaceSprite::ALPHA | SpaceSprite::MASKED | 
+				  SpaceSprite::MIPMAPED);
+  sparkSprite = new SpaceSprite(&melee[MELEE_SPARK], SPARK_FRAMES,
+				SpaceSprite::ALPHA | SpaceSprite::MASKED | 
+				SpaceSprite::MIPMAPED | 
+				SpaceSprite::MATCH_SCREEN_FORMAT);
+  asteroidExplosionSprite = new SpaceSprite(&melee[MELEE_ASTEROIDEXPLOSION], 
+					    ASTEROIDEXPLOSION_FRAMES);
+  asteroidSprite = new SpaceSprite(&melee[MELEE_ASTEROID], ASTEROID_FRAMES);
+  planetSprite = new SpaceSprite(&melee[MELEE_PLANET], PLANET_FRAMES);
+  xpl1Sprite = new SpaceSprite(&melee[MELEE_XPL1], XPL1_FRAMES,
+			       SpaceSprite::ALPHA | SpaceSprite::MASKED | 
+			       SpaceSprite::MIPMAPED);
+  unload_datafile(melee);
 }
 
-
-
-void MeleeData::init()
+MeleeData::~MeleeData()
 {
-  melee = load_datafile(data_full_path("melee.dat").c_str());
-  if (!melee) tw_error("Error loading melee data\n");
-
-  meleedata.panelSprite             = new SpaceSprite(&melee[MELEE_PANEL], 
-						      PANEL_FRAMES, SpaceSprite::IRREGULAR);
-  meleedata.kaboomSprite            = new SpaceSprite(&melee[MELEE_KABOOM], KABOOM_FRAMES,
-						      SpaceSprite::ALPHA | SpaceSprite::MASKED | 
-						      SpaceSprite::MIPMAPED);
-  meleedata.hotspotSprite           = new SpaceSprite(&melee[MELEE_HOTSPOT], HOTSPOT_FRAMES,
-						      SpaceSprite::ALPHA | SpaceSprite::MASKED | 
-						      SpaceSprite::MIPMAPED);
-  meleedata.sparkSprite             = new SpaceSprite(&melee[MELEE_SPARK], SPARK_FRAMES,
-						      SpaceSprite::ALPHA | SpaceSprite::MASKED | 
-						      SpaceSprite::MIPMAPED | 
-						      SpaceSprite::MATCH_SCREEN_FORMAT);
-  meleedata.asteroidExplosionSprite = new SpaceSprite(&melee[MELEE_ASTEROIDEXPLOSION], 
-						      ASTEROIDEXPLOSION_FRAMES);
-  meleedata.asteroidSprite          = new SpaceSprite(&melee[MELEE_ASTEROID], ASTEROID_FRAMES);
-  meleedata.planetSprite            = new SpaceSprite(&melee[MELEE_PLANET], PLANET_FRAMES);
-  meleedata.xpl1Sprite              = new SpaceSprite(&melee[MELEE_XPL1], XPL1_FRAMES,
-						      SpaceSprite::ALPHA | SpaceSprite::MASKED | 
-						      SpaceSprite::MIPMAPED);
-  
-  //planet_victory = (Music*) (melee[MELEE_PLANET+PLANET_FRAMES].dat);
-  char tmp[20] = {0};
-  sprintf(tmp, "%d", MELEE_PLANET+PLANET_FRAMES);
-  planet_victory = std::string("melee.dat#") + tmp;
+  STACKTRACE;
+  if(panelSprite)
+    {
+      delete panelSprite;
+    }
+  if(kaboomSprite)
+    {
+      delete kaboomSprite;
+    }
+  if(hotspotSprite)
+    {
+      delete hotspotSprite;
+    }
+  if(sparkSprite)
+    {
+      delete sparkSprite;
+    }
+  if(asteroidExplosionSprite)
+    {
+      delete asteroidExplosionSprite;
+    }
+  if(asteroidSprite)
+    {
+      delete asteroidSprite;
+    }
+  if(planetSprite)
+    {
+      delete planetSprite;
+    }
+  if(xpl1Sprite)
+    {
+      delete xpl1Sprite;
+    }
 }
 
-void MeleeData::deinit()
-{
-	panelSprite             = NULL;
-	kaboomSprite            = NULL;
-	hotspotSprite           = NULL;
-	sparkSprite             = NULL;
-	asteroidExplosionSprite = NULL;
-	asteroidSprite          = NULL;
-	planetSprite            = NULL;
-	xpl1Sprite              = NULL;
 
-	planet_victory		= "";		
 
-	unload_datafile(melee);
-	
-	melee = NULL;
-}
 
-
-
-
 int interpolate_frames = false;
 
 
@@ -159,177 +154,208 @@
 	game_names[num_games] = NULL;
 }
 
-Game *GameType::new_game() {STACKTRACE
-	Game *tmp = _new_game();
-	tmp->preinit();
-	tmp->type = this;
-	return tmp;
+Game *GameType::new_game() 
+{
+  STACKTRACE;
+  Game *tmp = _new_game();
+  tmp->preinit();
+  tmp->type = this;
+  return tmp;
 }
 
-GameType *gametype (const char *name) {STACKTRACE
-	GameType ** g;
-	for (g = games; *g; g ++)
-		if (!strcmp((*g)->name, name))
-			return *g;
+GameType *gametype (const char *name) 
+{
+  GameType ** g;
+  for (g = games; *g; g ++)
+    if (!strcmp((*g)->name, name))
+      return *g;
 	return NULL;
 }
 
-void __checksync( const char *fname, int line) {
-	if (!game) {
-		error("request to compare checksums without a valid game\nfrom file %f, line %d", fname, line);
-		return;
-	}
+void __checksync( const char *fname, int line) 
+{
+  if (!game) 
+    {
+      tw_error("request to compare checksums without a valid game");
+      return;
+    }
 #	ifdef LOTS_OF_CHECKSUMS
-	game->compare_checksums();
+  game->compare_checksums();
 #	endif
 }
 
 
 
-void Game::_event(Event *e) {
-	switch (e->type) {
-		case Event::VIDEO: {
-			if (game_done)
-				return;
-			if (e->subtype == VideoEvent::REDRAW)
-				this->redraw();
-		} break;
-		case Event::TW_CONFIG: {
-			ConfigEvent *c = (ConfigEvent*)e;
-			switch (c->subtype) {
-			case ConfigEvent::SET: {
-					if (0) ;
-					else if (!strcmp(c->name, "server.ini/game/shotrelativity")) {
-						double v = atof(c->value);
-						this->shot_relativity = v;
-					}
-					else if (!strcmp(c->name, "server.ini/game/friendlyfire")) {
-						int v = atoi(c->value);
-						this->friendly_fire = (bool) v;
-					}
-				} break;
-			}
-			std::list<BaseClass*>b_presence;
-			std::copy(presence.begin(),presence.end(),back_inserter(b_presence));
-			issue_event(b_presence, e);
-			std::list<BaseClass*> b_item;
-			std::copy(item.begin(),item.end(),std::back_inserter(b_item));
-			issue_event(b_item, e);
-		} break;
-	}
+void Game::_event(Event *e) 
+{
+  STACKTRACE;
+  switch (e->type) 
+    {
+    case Event::VIDEO: 
+      {
+	if (game_done)
+	  return;
+	if (e->subtype == VideoEvent::REDRAW)
+	  this->redraw();
+      } break;
+    case Event::TW_CONFIG: 
+      {
+	ConfigEvent *c = (ConfigEvent*)e;
+	switch (c->subtype) 
+	  {
+	  case ConfigEvent::SET: 
+	    {
+	      if (0) ;
+	      else if (!strcmp(c->name, "server.ini/game/shotrelativity")) 
+		{
+		  double v = atof(c->value);
+		  this->shot_relativity = v;
+		}
+	      else if (!strcmp(c->name, "server.ini/game/friendlyfire")) {
+		int v = atoi(c->value);
+		this->friendly_fire = (bool) v;
+	      }
+	    } break;
+	  }
+	std::list<BaseClass*>b_presence;
+	std::copy(presence.begin(),presence.end(),back_inserter(b_presence));
+	issue_event(b_presence, e);
+	std::list<BaseClass*> b_item;
+	std::copy(item.begin(),item.end(),std::back_inserter(b_item));
+	issue_event(b_item, e);
+      } break;
+    }
 }
 
-void Game::add_focus(Presence *new_focus, int channel) {
-	if ((channel != -1) && !log->playback && !(log->get_direction(channel) & Log::direction_write))
-		return;
-	num_focuses += 1;
-	focus = (Presence **) realloc(focus, sizeof(Presence *) * num_focuses);
-	focus[num_focuses - 1] = new_focus;
-	new_focus->attributes |= ATTRIB_FOCUS;
-	if (num_focuses == 1) new_focus->attributes |= ATTRIB_ACTIVE_FOCUS;
-	if (focus_index == -1) focus_index = 0;
+void Game::add_focus(Presence *new_focus, int channel) 
+{
+  STACKTRACE;
+  if ((channel != -1) && !log->playback && !(log->get_direction(channel) & Log::direction_write))
+    return;
+  num_focuses += 1;
+  focus = (Presence **) realloc(focus, sizeof(Presence *) * num_focuses);
+  focus[num_focuses - 1] = new_focus;
+  new_focus->attributes |= ATTRIB_FOCUS;
+  if (num_focuses == 1) new_focus->attributes |= ATTRIB_ACTIVE_FOCUS;
+  if (focus_index == -1) focus_index = 0;
 }
 
 
 void Game::prepare() {
+  STACKTRACE;
 #ifdef _MSC_VER
-	_asm { finit }
+  _asm { finit }
 #elif defined(__GCC__) && defined(__i386__)
-	asm("finit");
+  asm("finit");
 #endif
-	Physics::prepare();
-	::game = this;
-	::targets = &gametargets;
-	return;
+  Physics::prepare();
+  ::game = this;
+  ::targets = &gametargets;
+  return;
 }
 
-void Game::set_resolution(int screen_x, int screen_y) {
-	int view_x, view_y;
-	view_x = screen_x;
-	view_y = screen_y;
-	redraw();
-	return;
+void Game::set_resolution(int screen_x, int screen_y) 
+{
+  STACKTRACE;
+  int view_x, view_y;
+  view_x = screen_x;
+  view_y = screen_y;
+  redraw();
+  return;
 }
 
-void Game::redraw() {STACKTRACE
-	if (!window->surface) return;
-	scare_mouse();
-	window->lock();
-	rectfill(window->surface, window->x, window->y, window->x+window->w-1, window->y+window->h-1, pallete_color[8]);
-	FULL_REDRAW += 1;
-	view->refresh();
-	view->animate(this);
-	FULL_REDRAW -= 1;
-	window->unlock();
-	unscare_mouse();
-	return;
+void Game::redraw() 
+{
+  STACKTRACE;
+  if (!window->surface) return;
+  scare_mouse();
+  window->lock();
+  rectfill(window->surface, window->x, window->y, window->x+window->w-1, window->y+window->h-1, pallete_color[8]);
+  FULL_REDRAW += 1;
+  view->refresh();
+  view->animate(this);
+  FULL_REDRAW -= 1;
+  window->unlock();
+  unscare_mouse();
+  return;
 }
 
-Ship *Game::create_ship(const char *id, Control *c, Vector2 pos, double angle, int team) {STACKTRACE
-	ShipType *type = shiptype(id);
-	if (!type)
-	{tw_error("Game::create_ship - bad ship id (%s)", id);}
-	log_file(type->file);
-	if (team == 0) team = new_team();
-	Ship *s = type->get_ship(pos, angle, get_code(new_ship(), team));
-	if (c)
-		c->select_ship(s, id);
-	gametargets.add(s);
-	s->attributes |= ATTRIB_NOTIFY_ON_DEATH;
-	return s;
+Ship *Game::create_ship(const char *id, Control *c, Vector2 pos, double angle, int team) 
+{
+  STACKTRACE;
+  ShipType *type = shiptype(id);
+  if (!type)
+    {tw_error("Game::create_ship - bad ship id (%s)", id);}
+  log_file(type->file);
+  if (team == 0) team = new_team();
+  Ship *s = type->get_ship(pos, angle, get_code(new_ship(), team));
+  if (c)
+    c->select_ship(s, id);
+  gametargets.add(s);
+  s->attributes |= ATTRIB_NOTIFY_ON_DEATH;
+  return s;
 }
 
-Ship *Game::create_ship(int channel, const char *id, const char *control, Vector2 pos, double angle, int team) {STACKTRACE
-	Control *c = create_control(channel, control);
-	if (!c)
-	{tw_error("bad Control type!");}
-	c->temporary = true;
-	Ship *s = create_ship(id, c, pos, angle, team);
-	return s;
+Ship *Game::create_ship(int channel, const char *id, const char *control, Vector2 pos, double angle, int team) 
+{
+  STACKTRACE;
+  Control *c = create_control(channel, control);
+  if (!c)
+    {tw_error("bad Control type!");}
+  c->temporary = true;
+  Ship *s = create_ship(id, c, pos, angle, team);
+  return s;
 }
 
-void Game::increase_latency() {STACKTRACE
-	if (CHECKSUM_CHANNEL) {
-		log->buffer(channel_server + Game::_channel_buffered, NULL, 2);
-		log->buffer(channel_client + Game::_channel_buffered, NULL, 2);
-		if (log->playback) 
-			log->buffer(channel_playback + Game::_channel_buffered, NULL, 1);
-		log->flush();
-	}
-	lag_frames += 1;
+void Game::increase_latency() 
+{
+  STACKTRACE;
+  if (CHECKSUM_CHANNEL) {
+    log->buffer(channel_server + Game::_channel_buffered, NULL, 2);
+    log->buffer(channel_client + Game::_channel_buffered, NULL, 2);
+    if (log->playback) 
+      log->buffer(channel_playback + Game::_channel_buffered, NULL, 1);
+    log->flush();
+  }
+  lag_frames += 1;
 }
 
-void Game::decrease_latency() {
-	STACKTRACE;
-	if (lag_frames <= 1) {tw_error("latency decreased too far");}
-	if (CHECKSUM_CHANNEL) {
-		log->unbuffer(channel_server + Game::_channel_buffered, NULL, 2);
-		log->unbuffer(channel_client + Game::_channel_buffered, NULL, 2);
-		if (log->playback) 
-			log->unbuffer(channel_playback + Game::_channel_buffered, NULL, 1);
-	}
-	lag_frames -= 1;
+void Game::decrease_latency() 
+{
+  STACKTRACE;
+  if (lag_frames <= 1) {tw_error("latency decreased too far");}
+  if (CHECKSUM_CHANNEL) {
+    log->unbuffer(channel_server + Game::_channel_buffered, NULL, 2);
+    log->unbuffer(channel_client + Game::_channel_buffered, NULL, 2);
+    if (log->playback) 
+      log->unbuffer(channel_playback + Game::_channel_buffered, NULL, 1);
+  }
+  lag_frames -= 1;
 }
 
-int Game::is_local (int channel) {
-	return (log->get_direction (channel) & Log::direction_write);
+int Game::is_local (int channel) 
+{
+  return (log->get_direction (channel) & Log::direction_write);
 }
-void Game::log_file (const char *fname) {STACKTRACE
-	log->log_file(fname);
+void Game::log_file (const char *fname) 
+{
+  log->log_file(fname);
 }
 
-void Game::log_fleet(int channel, Fleet *fleet) {STACKTRACE
-	int fl;
-	void *tmpdata = fleet->serialize(&fl);
-	char buffer[16384];
+void Game::log_fleet(int channel, Fleet *fleet) 
+{
+  STACKTRACE;
+  int fl;
+  void *tmpdata = fleet->serialize(&fl);
+  char buffer[16384];
 
-	if (fl > 16000)	{tw_error("blah");}
-	memcpy(buffer, tmpdata, fl);
-	free(tmpdata);
-	log_int(channel, fl);
-	if (fl > 16000)	{tw_error("blah");}
-	log_data(channel, buffer, fl);
-	fleet->deserialize(buffer, fl);
+  if (fl > 16000)	{tw_error("blah");}
+  memcpy(buffer, tmpdata, fl);
+  free(tmpdata);
+  log_int(channel, fl);
+  if (fl > 16000)	{tw_error("blah");}
+  log_data(channel, buffer, fl);
+  fleet->deserialize(buffer, fl);
 }
 
 Control *Game::create_control (int channel, const char *type, char *config, char *file) {STACKTRACE
@@ -350,12 +376,14 @@
 }
 
 void Game::log_char(int channel, char &data) {
+  STACKTRACE;
 	if (!log) return;
 	log->log  (channel, &data, 1);
 	return;
 }
 
 void Game::log_short(int channel, short &data) {
+  STACKTRACE;
 	if (!log) return;
 	data = intel_ordering_short(data);	
 	log->log  (channel, &data, sizeof(short));
@@ -364,6 +392,7 @@
 }
 
 void Game::log_int(int channel, int &data) {
+  STACKTRACE;
 	if (!log) return;
 	data = intel_ordering(data);
 	log->log  (channel, &data, sizeof(int));
@@ -371,13 +400,15 @@
 	return;
 }
 
-void Game::log_data(int channel, void *data, int size) {STACKTRACE
+void Game::log_data(int channel, void *data, int size) {
+  STACKTRACE;
 	if (!log) return;
 	log->log  (channel, data, size);
 	return;
 }
 
-void Game::idle(int time) {STACKTRACE
+void Game::idle(int time) {
+  STACKTRACE;
 	if (log->listen()) return;
 	::idle(time);
 	return;
@@ -385,15 +416,13 @@
 
 void Game::animate(Frame *frame) 
 {
-  _STACKTRACE("Game::animate(Frame*)");
+  STACKTRACE;
   Physics::animate(frame);
 }
 
 void Game::animate() 
 {
-  
-  _STACKTRACE("Game::animate(void)");
-
+  STACKTRACE;
   double t = get_time();
   paused_time = 0;
   view->animate(this);
@@ -402,7 +431,8 @@
   return;
 }
 
-bool Game::game_ready() {STACKTRACE
+bool Game::game_ready() {
+  STACKTRACE;
 	if (CHECKSUM_CHANNEL == 0) return 1;
 	if (log->playback) {
 		return (log->ready(channel_server + Game::_channel_buffered) != 0);
@@ -422,8 +452,11 @@
 	return true;
 }
 
-void Game::handle_desynch(int local_checksum, int server_checksum, int client_checksum) {STACKTRACE
-	error("Game Desynchronized\nTime=%d Frame=%d\nClient=%d Server=%d Local=%d", game_time, frame_number, (int)client_checksum, (int)server_checksum, (int)local_checksum);
+void Game::handle_desynch(int local_checksum, int server_checksum, int client_checksum) 
+{
+  STACKTRACE;
+  //  tw_error("Game Desynchronized\nTime=%d Frame=%d\nClient=%d Server=%d Local=%d", game_time, frame_number, (int)client_checksum, (int)server_checksum, (int)local_checksum);
+  tw_error("Game Desynchronized");
 }
 
 //static int old_num_items;
@@ -435,239 +468,165 @@
 //if a game is killed due to an error, this may be executed
 void handle_game_error ( Game *game )
 {
-	log_debug("handle_game_error() executed\n");
-	if (game->log) {
-		game->log->save("error.dmo");
-		log_debug("Demo recording saved to error.dmo\n");
-	}
-/*
-	FILE *f;
-
-	f = fopen("error.log", "a");
-	if (!f) return;
-
-	if (exitmessage)
-		fprintf(f, "\n\n-------- error report, with message [%s]\n", exitmessage);
-	else
-		fprintf(f, "\n\n-------- error report, unknown error\n");
-	//fprintf(f, "-------- showing in-game objects --------\n");
-	fprintf(f, "timewarp version = %s\n", tw_version());
-
-	if (game)
-		fprintf(f, "lag_frames = %i", game->lag_frames);
-	else
-		fprintf(f, "no game defined");
-
-	time_t t;
-	tm *td;
-	t = ::time(0);
-	td = ::localtime(&t);
-	// month: 0=januari
-	fprintf(f, "local time = %i-%02i-%02i %02i:%02i\n\n", td->tm_mday, td->tm_mon+1, 1900+td->tm_year,
-		td->tm_hour, td->tm_min);
-
-	if (physics)
-	{
-		fprintf(f, "name, pos(x,y), vel(x,y), state, obj-pointer(this), ship-pointer(ship), target pointer(target)\n\n");
-		
-		int i;
-		for (i = 0; i < physics->num_items; i += 1)
-		{
-			SpaceLocation *s;
-			s = physics->item[i];
-			
-			if (!(s && s->exists() && s->detectable()))
-				continue;
-			
-			int is = s->state;
-			Vector2 p = s->pos;
-			Vector2 v = s->vel;
-			
-			// set "enable run-type information" for this feature
-			// (rebuild all after changing that option)
-			fprintf(f, "%30s %11.3e %011.3e %11.3e %11.3e %3i 0x%08X 0x%08X 0x%08X\n",
-				typeid(*s).name(), p.x, p.y, v.x, v.y, is, (unsigned int)s, (unsigned int)s->ship, (unsigned int)s->target );
-		}
-	} else {
-		fprintf(f, "No physics defined\n");
-	}
-
-	#ifdef DO_STACKTRACE
-	//char *s = tw_error_str;
-//	fprintf(f, "%s\n", tw_error_str);
-	//free(s);	// cause s was allocated with malloc().
-
-	fprintf(f, "\nPROCLIST: level of call, line number in file, file name (top=most recent call)\n\n");
-
-	const char *fname = 0;
-	int *linenum = 0, *level = 0;
-
-	int i;
-	i = 0;	// start with the most recent one.
-	while (	get_stacklist_info(i, &fname, &linenum, &level) )
-	{
-		++i;	// go on until it's a full circle
-		if (fname && linenum && level)
-			fprintf(f, "%2i   %4i  %s\n", *level, *linenum, fname);
-	}
-
-	fprintf(f, "\nPROCSTACK: level of call, line number in file, file name (top=most recent call)\n\n");
-
-	// also, read the "other" stack info ...
-	i = 0;
-	while ( get_stacktrace_info( i, &fname, &linenum, &level) )
-	{
-		++i;
-		if (fname && linenum && level)
-			fprintf(f, "%2i   %4i  %s\n", *level, *linenum, fname);
-	}
-
-	#endif
-
-	fprintf(f, "----------------- end error log ---------------------\n");
-
-	fclose(f);
-	*/
+  log_debug("handle_game_error() executed\n");
+  if (game->log) 
+    {
+      game->log->save("error.dmo");
+      log_debug("Demo recording saved to error.dmo\n");
+    }
 }
 
 
-void Game::compare_checksums() {STACKTRACE
-	unsigned char local_checksum = checksum() & 255;
-	unsigned char client_checksum = local_checksum;
-	unsigned char server_checksum = local_checksum;
-	bool desync = false;
+void Game::compare_checksums() 
+{
+  STACKTRACE;
+  unsigned char local_checksum = checksum() & 255;
+  unsigned char client_checksum = local_checksum;
+  unsigned char server_checksum = local_checksum;
+  bool desync = false;
+  
+  log_char(channel_server + CHECKSUM_CHANNEL, server_checksum);
+  if (lag_frames)
+    log_char(channel_client + CHECKSUM_CHANNEL, client_checksum);
+  
+  if (server_checksum != client_checksum)
+    desync = true;
+  if (log->playback) {
+    if (lag_frames) 
+      log_char (channel_playback + CHECKSUM_CHANNEL, local_checksum);
+    if (local_checksum != server_checksum) desync = true;
+  }
 
-	log_char(channel_server + CHECKSUM_CHANNEL, server_checksum);
-	if (lag_frames)
-		log_char(channel_client + CHECKSUM_CHANNEL, client_checksum);
-
-	if (server_checksum != client_checksum)
-		desync = true;
-	if (log->playback) {
-		if (lag_frames) 
-			log_char (channel_playback + CHECKSUM_CHANNEL, local_checksum);
-		if (local_checksum != server_checksum) desync = true;
-	}
-
-	this->local_checksum = local_checksum;
-	this->client_checksum = client_checksum;
-	this->server_checksum = server_checksum;
-
-	if (desync)
-	{
-		handle_desynch(local_checksum, server_checksum, client_checksum);
-	}
+  this->local_checksum = local_checksum;
+  this->client_checksum = client_checksum;
+  this->server_checksum = server_checksum;
+  
+  if (desync)
+    {
+      handle_desynch(local_checksum, server_checksum, client_checksum);
+    }
 }
 
-void Game::do_game_events() {_STACKTRACE("Game::do_game_events()")
-	int i;
+void Game::do_game_events() 
+{
+  STACKTRACE;
+  int i;
 
-	//transmit from server
-	if (log->get_direction(channel_server) & Log::direction_write) {
-		COMPILE_TIME_ASSERT(sizeof(events_waiting) == sizeof(char));
-		log->buffer( channel_server + _channel_buffered, &events_waiting, sizeof(events_waiting) );
-		for (i = 0; i < events_waiting; i += 1) {
-			log->buffer ( channel_server + _channel_buffered, waiting_events[i], waiting_events[i]->size );
-		}
-		//deallocate transmitted events
-		for (i = 0; i < events_waiting; i += 1) free(waiting_events[i]);
-		events_waiting = 0;
-	}
-
-	//transmit from client
-	if (log->get_direction(channel_client) & Log::direction_write) {
-		COMPILE_TIME_ASSERT(sizeof(events_waiting) == sizeof(char));
-		log->buffer( channel_client + _channel_buffered, &events_waiting, sizeof(events_waiting) );
-		for (i = 0; i < events_waiting; i += 1) {
-			log->buffer ( channel_client + _channel_buffered, waiting_events[i], waiting_events[i]->size );
-		}
-		//deallocate transmitted events
-		for (i = 0; i < events_waiting; i += 1) free(waiting_events[i]);
-		events_waiting = 0;
-	}
-
-	//double-check transmission
-	if (events_waiting) {
-		tw_error("Game::do_game_events - events weren't sent properly");
-		for (i = 0; i < events_waiting; i += 1) free(waiting_events[i]);
-		events_waiting = 0;
-	}
-
-	//recieve
-	char ne;
-	COMPILE_TIME_ASSERT(sizeof(events_waiting) == sizeof(ne));
-	char buffy[1024];
-
-	//recieve from server
-	log->unbuffer(channel_server + _channel_buffered, &ne, sizeof(ne));
-	for (i = 0; i < ne; i += 1) {
-		char *tmp = buffy;
-		log->unbuffer(channel_server + _channel_buffered, &buffy, sizeof(GameEvent));
-		int s = ((GameEvent*)tmp)->size;
-		if (s > 1024) {
-			tmp = (char *)malloc(s);
-			memcpy(tmp, buffy, sizeof(GameEvent));
-		}
+  //transmit from server
+  if (log->get_direction(channel_server) & Log::direction_write) {
+    COMPILE_TIME_ASSERT(sizeof(events_waiting) == sizeof(char));
+    log->buffer( channel_server + _channel_buffered, &events_waiting, sizeof(events_waiting) );
+    for (i = 0; i < events_waiting; i += 1) {
+      log->buffer ( channel_server + _channel_buffered, waiting_events[i], waiting_events[i]->size );
+    }
+    //deallocate transmitted events
+    for (i = 0; i < events_waiting; i += 1) free(waiting_events[i]);
+    events_waiting = 0;
+  }
+  
+  //transmit from client
+  if (log->get_direction(channel_client) & Log::direction_write) {
+    COMPILE_TIME_ASSERT(sizeof(events_waiting) == sizeof(char));
+    log->buffer( channel_client + _channel_buffered, &events_waiting, sizeof(events_waiting) );
+    for (i = 0; i < events_waiting; i += 1) {
+      log->buffer ( channel_client + _channel_buffered, waiting_events[i], waiting_events[i]->size );
+    }
+    //deallocate transmitted events
+    for (i = 0; i < events_waiting; i += 1) free(waiting_events[i]);
+    events_waiting = 0;
+  }
+  
+  //double-check transmission
+  if (events_waiting) {
+    tw_error("Game::do_game_events - events weren't sent properly");
+    for (i = 0; i < events_waiting; i += 1) free(waiting_events[i]);
+    events_waiting = 0;
+  }
+  
+  //recieve
+  char ne;
+  COMPILE_TIME_ASSERT(sizeof(events_waiting) == sizeof(ne));
+  char buffy[1024];
+  
+  //recieve from server
+  log->unbuffer(channel_server + _channel_buffered, &ne, sizeof(ne));
+  for (i = 0; i < ne; i += 1) {
+    char *tmp = buffy;
+    log->unbuffer(channel_server + _channel_buffered, &buffy, sizeof(GameEvent));
+    int s = ((GameEvent*)tmp)->size;
+    if (s > 1024) {
+      tmp = (char *)malloc(s);
+      memcpy(tmp, buffy, sizeof(GameEvent));
+    }
 		log->unbuffer(channel_server + _channel_buffered, tmp + sizeof(GameEvent), s - sizeof(GameEvent));
 		handle_game_event ( channel_server, ((GameEvent*)tmp));
 		if (tmp != buffy) free(tmp);
-	}
-
-
-	//recieve from client
-	log->unbuffer(channel_client + _channel_buffered, &ne, sizeof(ne));
-	for (i = 0; i < ne; i += 1) {
-		char *tmp = buffy;
-		log->unbuffer(channel_client + _channel_buffered, &buffy, sizeof(GameEvent));
-		int s = ((GameEvent*)tmp)->size;
-		if (s > 1024) {
-			tmp = (char *)malloc(s);
-			memcpy(tmp, buffy, sizeof(GameEvent));
+  }
+  
+  
+  //recieve from client
+  log->unbuffer(channel_client + _channel_buffered, &ne, sizeof(ne));
+  for (i = 0; i < ne; i += 1) {
+    char *tmp = buffy;
+    log->unbuffer(channel_client + _channel_buffered, &buffy, sizeof(GameEvent));
+    int s = ((GameEvent*)tmp)->size;
+    if (s > 1024) {
+      tmp = (char *)malloc(s);
+      memcpy(tmp, buffy, sizeof(GameEvent));
 		}
-		log->unbuffer(channel_client + _channel_buffered, tmp + sizeof(GameEvent), s - sizeof(GameEvent));
-		handle_game_event ( channel_client, ((GameEvent*)tmp));
-		if (tmp != buffy) free(tmp);
-	}
+    log->unbuffer(channel_client + _channel_buffered, tmp + sizeof(GameEvent), s - sizeof(GameEvent));
+    handle_game_event ( channel_client, ((GameEvent*)tmp));
+    if (tmp != buffy) free(tmp);
+  }
 }
 
-void Game::handle_game_event ( int source, class GameEvent *event ) {STACKTRACE
-	if ((event->type <= event_invalid) || (event->type >= event_last)) {
-		tw_error("Game::handle_game_event - Bad event type: %d", event->type);
-	}
-	switch (event->type) {
-		case event_change_lag: ((GameEventChangeLag*)event)->execute(source);
-		break;
-		case event_message: ((GameEventMessage*)event)->execute(source);
-		break;
-	}
+void Game::handle_game_event ( int source, class GameEvent *event ) 
+{
+  STACKTRACE;
+  if ((event->type <= event_invalid) || (event->type >= event_last)) 
+    {
+      tw_error("Game::handle_game_event - Bad event type: %d", event->type);
+    }
+  switch (event->type) 
+    {
+    case event_change_lag: ((GameEventChangeLag*)event)->execute(source);
+      break;
+    case event_message: ((GameEventMessage*)event)->execute(source);
+      break;
+    }
 }
 
-void Game::send_game_event ( class GameEvent *event ) {STACKTRACE
-	if (events_waiting == maximum_events_waiting) {
-		tw_error("too many GameEvents");
-		return;
-	}
-	if (!waiting_events) waiting_events = new GameEvent*[maximum_events_waiting];
-	waiting_events[events_waiting] = event;
-	events_waiting += 1;
+void Game::send_game_event ( class GameEvent *event ) 
+{
+  STACKTRACE;
+  if (events_waiting == maximum_events_waiting) 
+    {
+      tw_error("too many GameEvents");
+      return;
+    }
+  if (!waiting_events) waiting_events = new GameEvent*[maximum_events_waiting];
+  waiting_events[events_waiting] = event;
+  events_waiting += 1;
 }
 
 
-void Game::calculate() {_STACKTRACE("Game::calculate")
-	int i;
-	double t = get_time();
-	int active_focus_destroyed = false;
-
-
-	paused_time = 0;
-	compare_checksums();
-	do_game_events();
-
-	for (i = 0; i < num_focuses; i += 1) {
-		if (!focus[i]->exists()) {
-			num_focuses -= 1;
-			if (focus_index == i) {
-				focus[i]->attributes &= ~ATTRIB_ACTIVE_FOCUS;
+void Game::calculate() 
+{
+  STACKTRACE;
+  int i;
+  double t = get_time();
+  int active_focus_destroyed = false;
+  
+  
+  paused_time = 0;
+  compare_checksums();
+  do_game_events();
+  
+  for (i = 0; i < num_focuses; i += 1) {
+    if (!focus[i]->exists()) {
+      num_focuses -= 1;
+      if (focus_index == i) {
+	focus[i]->attributes &= ~ATTRIB_ACTIVE_FOCUS;
 				active_focus_destroyed = 1;
 				focus_index -= 1;
 				if (num_focuses && (focus_index < 0))
@@ -698,6 +657,7 @@
 
 void Game::play() 
 {
+  STACKTRACE;
   set_resolution(window->w, window->h);
   prepare();
   if (is_paused()) 
@@ -707,14 +667,16 @@
       play_music();
       while(!game_done) 
 	{
+	  if(!tw_sound->playing_music())
+	    play_music();
+	  
 	  unsigned int time = get_time();
 	  poll_input();
-	  videosystem.poll_redraw();
+	  videosystem->poll_redraw();
 	  if ((next_tic_time <= time) && (next_render_time > game_time) && game_ready()) 
 	    {
 	      _STACKTRACE("Game::play - Game physics")
 		calculate();
-	      if (auto_unload) unload_unused_ship_data();
 	      log->flush();
 	      log->listen();
 	      if (key[KEY_F4])
@@ -774,33 +736,36 @@
 
 void Game::ship_died(Ship *who, SpaceLocation *source)
 {
+  STACKTRACE;
   if (source && source->data) 
     {
       std::string tmp = "";
       //if (source && source->ship && source->ship->data) tmp = source->ship->data->moduleVictory;
       // note: it's not guaranteed that a ship exists longer than its weapon, while data keep existing, right ?
       
-      /* temporary commented: Yurand
       if (source && source->exists()) 
 	tmp = source->data->moduleVictory;
       if (!tmp.empty()) 
-	tw_sound.play_sound(tmp);
-      */
+	{
+	  tw_sound->play_music(data_full_path(tmp), 1);
+	}
       
     }
-	return;
+  return;
 }
 
 
 void Game::object_died(SpaceObject *who, SpaceLocation *source)
 {
+  STACKTRACE;
 	if (who && who->isShip())
 	{
 		ship_died((Ship*)who, source);
 	}
 }
 
-void Game::fps() {STACKTRACE
+void Game::fps() {
+  STACKTRACE;
 	if ((!log->playback) && ((log->type == Log::log_net1server) || (log->type == Log::log_net1client))) {
 		int ping = ((NetLog*)log)->ping;
 		char *tt = "good";
@@ -855,6 +820,7 @@
 
 void Game::preinit() 
 {
+  STACKTRACE;
   Physics::preinit();
   //	meleedata.planetSprite = meleedata.asteroidSprite = meleedata.asteroidExplosionSprite = meleedata.hotspotSprite = meleedata.kaboomSprite = meleedata.panelSprite = meleedata.sparkSprite = meleedata.xpl1Sprite = NULL;
   // you should reset it here (again), cause there can be subgames of this type.
@@ -877,75 +843,77 @@
   music = "";
 }
 
-void Game::init(Log *_log) {_STACKTRACE("Game::init")
-	int i;
+void Game::init(Log *_log) 
+{
+  STACKTRACE;
+  int i;
 
-	game_done = false;
-	log = _log;
-	if (!log) {
-		log = new Log();
-		log->init();
-	}
-
-	lag_frames = 0;
-	show_fps = 0;
-	game_time = 0;
-	frame_time = 1;
-	frame_number = 0;
-	hiccup_margin = 100;
-	next_tic_time = get_time();
-	next_render_time = game_time;
-	next_fps_time = game_time;
-	view_locked = false;
-	physics_locked = false;
-	if (log->type != Log::log_normal || log->playback) physics_locked = true;
-	local_checksum = client_checksum = server_checksum = 0;
-
-	Physics::init();
-	prepare();
-
-	if (!window) {
-		window = new VideoWindow();
-		window->preinit();
-	}
-
-	tw_set_config_file("client.ini");
-	change_view(get_config_string("View", "View", "Hero")); 
-
-	window->add_callback(this);
-
-	if (!log->playback) {
-		switch (log->type) {
-			case Log::log_normal: {
-			}
+  game_done = false;
+  log = _log;
+  if (!log) {
+    log = new Log();
+    log->init();
+  }
+  
+  lag_frames = 0;
+  show_fps = 0;
+  game_time = 0;
+  frame_time = 1;
+  frame_number = 0;
+  hiccup_margin = 100;
+  next_tic_time = get_time();
+  next_render_time = game_time;
+  next_fps_time = game_time;
+  view_locked = false;
+  physics_locked = false;
+  if (log->type != Log::log_normal || log->playback) physics_locked = true;
+  local_checksum = client_checksum = server_checksum = 0;
+  
+  Physics::init();
+  prepare();
+  
+  if (!window) {
+    window = new VideoWindow();
+    window->preinit();
+  }
+  
+  tw_set_config_file("client.ini");
+  change_view(get_config_string("View", "View", "Hero")); 
+  
+  window->add_callback(this);
+  
+  if (!log->playback) {
+    switch (log->type) {
+    case Log::log_normal: {
+    }
+      break;
+    case Log::log_net1server: {
+    }
+      break;
+    case Log::log_net1client: {
+    }
 			break;
-			case Log::log_net1server: {
-			}
-			break;
-			case Log::log_net1client: {
-			}
-			break;
-			default: {
-				tw_error("Knee!");
-			}
-			break;
-		}
-	}
-
-/* CONTENTS OF CHANNEL channel_init :
-
-offset	size	format		data
-0		4		int			log type number
+    default: {
+      tw_error("Knee!");
+    }
+      break;
+    }
+  }
+  
+  /* CONTENTS OF CHANNEL channel_init :
+     
+  offset	size	format		data
+  0		4		int			log type number
 4		4		int			size of game type name
 8		?		char[]		game type name
 ?		4		int			lag frames
 
-*/
-	int tmp = log->type;
-	log_int(channel_init, tmp);
-	if (log->playback) log->type = tmp;
+  */
+  int tmp = log->type;
+  log_int(channel_init, tmp);
+  if (log->playback) log->type = tmp;
 
-	char buffy[128];
+  char buffy[128];
 	i = strlen(type->name);
 	memcpy(buffy, type->name, i);
 	if (i > 127) {tw_error("long gamename1");}
@@ -1001,7 +969,8 @@
 	return;
 }
 
-void Game::init_lag() {STACKTRACE
+void Game::init_lag() {
+  STACKTRACE;
 	if ((log->type == Log::log_net1server) || (log->type == Log::log_net1client)) {
 		int lag_time = 0;//get_config_int("Network", "Lag", 200);
 		char blah = 0;
@@ -1033,7 +1002,8 @@
 	}
 }
 
-void Game::change_view(View *new_view) {STACKTRACE//this function looks wrong to me
+void Game::change_view(View *new_view) {
+  STACKTRACE;//this function looks wrong to me
 	View *v = new_view;
 	v->preinit();
 	v->init(view);
@@ -1052,7 +1022,8 @@
 	return;
 }
 
-void Game::change_view(const char * name) {STACKTRACE
+void Game::change_view(const char * name) {
+  STACKTRACE;
 	View *v = get_view(name, view);
 	if (!v)	{tw_error("Game::change_view - invalid view name");}
 	if (view)
@@ -1081,7 +1052,7 @@
 	delete tic_history; tic_history = NULL;
 	delete render_history; render_history = NULL;
 
-	tw_sound.play_music(std::string(""));
+	tw_sound->play_music(std::string(""));
 
 	message.out("deleteing game objects");
 	destroy_all();
@@ -1096,6 +1067,7 @@
 
 bool Game::is_paused() 
 {
+  STACKTRACE;
   if (time_paused != -1) 
     return true;
   return false;
@@ -1103,6 +1075,7 @@
 
 void Game::pause() 
 {
+  STACKTRACE;
   if (time_paused != -1) 
     tw_error ("can't pause -- already paused");
   time_paused = get_time();
@@ -1110,6 +1083,7 @@
 
 void Game::unpause() 
 {
+  STACKTRACE;
   if (time_paused == -1) 
     tw_error ("can't unpause -- not paused");
   redraw();
@@ -1120,6 +1094,7 @@
 
 void Game::save_screenshot() 
 {
+  STACKTRACE;
   static int shot_index = 0;
   char path[80];
 
@@ -1149,6 +1124,7 @@
 
 bool Game::handle_key(int k) 
 {
+  STACKTRACE;
   switch (k >> 8) 
     {
 #if !defined _DEBUG
@@ -1177,7 +1153,7 @@
     case KEY_F1: 
       {// help
 	pause();
-	show_file(data_full_path("ingame.txt").c_str());
+	show_file(data_full_path("ingame.txt"));
 	unpause();
 	return true;
       }
@@ -1279,29 +1255,37 @@
   return false;
 }
 
-int Game::set_frame_time(int t) {STACKTRACE
+int Game::set_frame_time(int t) {
+  STACKTRACE;
 	this->frame_time = t;
 	prepare();
 	return 1;
 }
 
-int Game::set_turbo(double t) {STACKTRACE
-	this->normal_turbo = t;
-	prepare();
-	return 1;
+int Game::set_turbo(double t) 
+{
+  STACKTRACE;
+  this->normal_turbo = t;
+  prepare();
+  return 1;
 }
 
-double Game::get_turbo() {
-	return this->normal_turbo;
+double Game::get_turbo() 
+{
+  STACKTRACE;
+  return this->normal_turbo;
 }
 
 void Game::play_music() 
 {
-  tw_sound.play_music(data_full_path("music/Robeter-battle-music-remix.ogg"));
+  STACKTRACE;
+  tw_sound->play_music(data_full_path("music/Robeter-battle-music-remix.ogg"));
   return;
 }
 
-void Game::quit(const char *message) { 
-	game_done = true;
+void Game::quit(const char *message) 
+{
+  STACKTRACE; 
+  game_done = true;
 }
 

Modified: branches/multiplayer-branch/source/melee/mgame.h
===================================================================
--- branches/multiplayer-branch/source/melee/mgame.h	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mgame.h	2004-09-28 19:53:03 UTC (rev 71)
@@ -27,15 +27,17 @@
 extern int random_seed[2];
 extern int interpolate_frames;
 
-class GameType {
-	private:
-	Game *(*_new_game)();
-	public:
-	double order;
-	char *name;
-	Game *new_game();
-	GameType ( const char *name, Game *(*new_game)(), double order = 0);
-	};
+class GameType 
+{
+ private:
+  Game *(*_new_game)();
+ public:
+  double order;
+  char *name;
+  Game *new_game();
+  GameType ( const char *name, Game *(*new_game)(), double order = 0);
+};
+
 extern int num_games;
 extern char **game_names;
 extern GameType **games;
@@ -43,26 +45,23 @@
 GameType *gametype(const char *name);
 
 
-// these are default data used in ships and game objects, which in principle, should be
-// independent of the (normal) game type.
+/// \brief these are default data used in ships and game objects, which in principle, should be
+/// independent of the (normal) game type.
 class MeleeData
 {
-public:
-	MeleeData();
-
-	void init();
-	void deinit();
+ public:
+  MeleeData();
+  ~MeleeData();
 	
-	SpaceSprite *planetSprite;
-	SpaceSprite *asteroidSprite;
-	SpaceSprite *asteroidExplosionSprite;
-	SpaceSprite *sparkSprite;
-	SpaceSprite *hotspotSprite;
-	SpaceSprite *kaboomSprite;
-	SpaceSprite *panelSprite;
-	SpaceSprite *xpl1Sprite;
-
-	std::string planet_victory;
+  SpaceSprite *planetSprite;
+  SpaceSprite *asteroidSprite;
+  SpaceSprite *asteroidExplosionSprite;
+  SpaceSprite *sparkSprite;
+  SpaceSprite *hotspotSprite;
+  SpaceSprite *kaboomSprite;
+  SpaceSprite *panelSprite;
+  SpaceSprite *xpl1Sprite;
+  
 };
 
 
@@ -71,6 +70,8 @@
  public:
   GameType *type;
   
+  MeleeData meleedata;
+  
   enum 
     {
       channel_none = -1,    /**< not a valid channel */

Modified: branches/multiplayer-branch/source/melee/mhelpers.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mhelpers.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mhelpers.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -25,7 +25,6 @@
 #include <stdio.h>
 #include <string.h>
 #include <assert.h>
-#include "util/sounds.h"
 #include "other/dialogs.h"
 
 #include "melee/mmain.h"
@@ -42,37 +41,25 @@
 Byte Ordering (endianness)
 	offers invert_ordering, intel_ordering, motorola_ordering, 
 	normal versions are 32 bit; and short versions of each are 16 bit
-File Registration System
-	keeps a list of linked files & compile times
-VideoSystem
-	sets screen resolutions, color formats, color transforms, fonts
-	gets screen surface
-	records redraw event times
-SoundSystem
-	inits sound hardware
-	plays sounds
-	loads sounds
 
-SC2 Unit Conversion
-Help Dialog
 
+
 */
 
 #define PLATFORM_IS_ALLEGRO
 
 #if defined PLATFORM_IS_ALLEGRO
-	#include <allegro.h>
-	#if defined ALLEGRO_MSVC
-		#include <winalleg.h>
-		#include <windows.h>
-	#endif
+#include <allegro.h>
+#if defined ALLEGRO_MSVC
+#include <winalleg.h>
+#include <windows.h>
+#endif
 #else
-	#error unknown platform (allegro?)
+#error unknown platform (allegro?)
 #endif
 
 
 #include "melee.h"
-REGISTER_FILE
 
 #include "scp.h"
 
@@ -83,536 +70,539 @@
 volatile int debug_value = 0;
 
 
-
-
-
-
-
-
 /*------------------------------
-		File Registration System
-------------------------------*/
-registered_file_type *registered_files = NULL;
-int num_registered_files = 0;
-void _register_file (char *fname, char *fdate, char *ftime) {
-	registered_files = (registered_file_type*) realloc(registered_files, sizeof(registered_file_type) * (num_registered_files+1));
-	registered_files[num_registered_files].fname = fname;
-	registered_files[num_registered_files].fdate = fdate;
-	registered_files[num_registered_files].ftime = ftime;
-	num_registered_files += 1;
-	return;
-	}
-
-
-/*------------------------------
 		Video mode
 ------------------------------*/
-int  GFX_TIMEWARP_WINDOW =  
-#if defined DJGPP
-	GFX_AUTODETECT
-#else
-//	GFX_OPENGL_WINDOWED
-	GFX_AUTODETECT_WINDOWED
-	//GFX_GDI
-#endif
-;
-int GFX_TIMEWARP_FULLSCREEN = 
-GFX_AUTODETECT_FULLSCREEN
-//GFX_AUTODETECT
-;
+int  GFX_TIMEWARP_WINDOW =  GFX_AUTODETECT_WINDOWED;
+int GFX_TIMEWARP_FULLSCREEN = GFX_AUTODETECT_FULLSCREEN;
 
+VideoSystem* videosystem = NULL;
 
-VideoSystem videosystem;
-
-static void tw_display_switch_out() {
+static void tw_display_switch_out() 
+{
 }
 
-static void tw_display_switch_in() {
-	if (get_time() > videosystem.last_poll + 1000) {
-		videosystem.redraw();
-	}
-	else videosystem.screen_corrupted = true;
+static void tw_display_switch_in() 
+{
+  if (get_time() > videosystem->last_poll + 1000) 
+    {
+      videosystem->redraw();
+    }
+  else 
+    videosystem->screen_corrupted = true;
 }
 
 static int _gamma = -1;
 static unsigned char _gamma_map[256];
-int get_gamma() {
-	return _gamma;
+int get_gamma() 
+{
+  return _gamma;
 }
-void set_gamma(int gamma) {
-	if (gamma < 0) gamma = 0;
-	if (gamma > 255) gamma = 255;
-	_gamma = gamma;
-	int i;
-	for (i = 0; i < 256; i += 1) {
-		_gamma_map[i] = iround_down(256 * pow(i / 255.5, 1-gamma/258.));
-	}
-	return;
+
+void set_gamma(int gamma) 
+{
+  if (gamma < 0) 
+    gamma = 0;
+  if (gamma > 255) 
+    gamma = 255;
+  _gamma = gamma;
+  int i;
+  for (i = 0; i < 256; i += 1) 
+    {
+      _gamma_map[i] = iround_down(256 * pow(i / 255.5, 1-gamma/258.));
+    }
+  return;
 }
-void gamma_color_effects (RGB *c) {
-	if (!c->filler) {
-		c->r = _gamma_map[c->r];
-		c->g = _gamma_map[c->g];
-		c->b = _gamma_map[c->b];
+
+void gamma_color_effects (RGB *c) 
+{
+  if (!c->filler) 
+    {
+      c->r = _gamma_map[c->r];
+      c->g = _gamma_map[c->g];
+      c->b = _gamma_map[c->b];
+    }
+  else 
+    {
+      int alpha = (c->filler ^ 255) + 1;
+      int r, g, b;
+      r = (c->r << 8) / alpha;
+      g = (c->g << 8) / alpha;
+      b = (c->b << 8) / alpha;
+      if ((r | g | b) > 255) 
+	{
+	  tw_error("gamma_color_effects : premultiplied alpha color invalid");
 	}
-	else {
-		int alpha = (c->filler ^ 255) + 1;
-		int r, g, b;
-		r = (c->r << 8) / alpha;
-		g = (c->g << 8) / alpha;
-		b = (c->b << 8) / alpha;
-		if ((r | g | b) > 255) {
-			tw_error("gamma_color_effects : premultiplied alpha color invalid");
-		}
-		r = _gamma_map[r];
-		g = _gamma_map[g];
-		b = _gamma_map[b];
-		r = (r * alpha) >> 8;
-		g = (g * alpha) >> 8;
-		b = (b * alpha) >> 8;
-		c->r = r;
-		c->g = g;
-		c->b = b;
-	}
-	return;
-	}
-int tw_color (RGB c) {
-	videosystem.color_effects(&c);
-	return makecol(c.r, c.g, c.b);
+      r = _gamma_map[r];
+      g = _gamma_map[g];
+      b = _gamma_map[b];
+      r = (r * alpha) >> 8;
+      g = (g * alpha) >> 8;
+      b = (b * alpha) >> 8;
+      c->r = r;
+      c->g = g;
+      c->b = b;
+    }
+  return;
 }
-int tw_color (int r, int g, int b) {
-	RGB c = {r,g,b};
-	return makecol(c.r, c.g, c.b);
+
+int tw_color (RGB c) 
+{
+  videosystem->color_effects(&c);
+  return makecol(c.r, c.g, c.b);
 }
-int VideoSystem::poll_redraw() {
-	last_poll = get_time();
-	if (screen_corrupted) {
-		screen_corrupted = false;
-		videosystem.redraw();
-		return 1;
-	}
-	return 0;
+
+int tw_color (int r, int g, int b) 
+{
+  RGB c = {r,g,b};
+  return makecol(c.r, c.g, c.b);
 }
-void VideoSystem::preinit() {STACKTRACE
-	int i;
-	surface = NULL;
-	width = -1;
-	height = -1;
-	bpp = -1;
-	fullscreen = false;
-	font_data = NULL;
-	basic_font = NULL;
-	palette = (RGB*)malloc(sizeof(RGB) * 256);
-	if (1) {
-		FILE *f = fopen(data_full_path("palette").c_str(), "rb");
-		if (f) {
-			for (i = 0; i < 256; i += 1) {
-				palette[i].r = fgetc(f);
-				palette[i].g = fgetc(f);
-				palette[i].b = fgetc(f);
-				palette[i].filler = 0;
-			}
-			fclose(f);
-		}
-	}
-	else {
-		enum {
-			r_levels = 6,
-			g_levels = 6,
-			b_levels = 6,
-			total_levels = r_levels * g_levels * b_levels
-		};
-		COMPILE_TIME_ASSERT(total_levels < 256);
-		for (i = 0; i < 256; i += 1) {
-			if (i < total_levels) {
-				int j = 1;
-				palette[i].r = ((i/j)%r_levels) * 255 / r_levels;
-				j *= r_levels;
-				palette[i].g = ((i/j)%g_levels) * 255 / g_levels;
-				j *= g_levels;
-				palette[i].b = ((i/j)%b_levels) * 255 / b_levels;
-				j *= b_levels;
-			}
-			else {
-				palette[i].r = 0;
-				palette[i].g = 0;
-				palette[i].b = 0;
-				palette[i].filler = 0;
-			}
-			/*palette[i].r = (((i >> 0) & (bit(red_bits)-1)) * 255) / (bit(red_bits)-1);
-			palette[i].g = (((i >> red_bits) & (bit(green_bits)-1)) * 255) / (bit(green_bits)-1);
-			palette[i].b = (((i >> (red_bits+green_bits)) & (bit(blue_bits)-1)) * 255) / (bit(blue_bits)-1);*/
-		}
-	}
-	color_effects = gamma_color_effects;
 
-	screen_corrupted = false;
-	last_poll = -1;
-	window.preinit();
-	window.init( &window );
-	window.locate(0,0,0,0,  0,1,0,1);
+int VideoSystem::poll_redraw() 
+{
+  STACKTRACE;
+  last_poll = get_time();
+  if (screen_corrupted) 
+    {
+      screen_corrupted = false;
+      videosystem->redraw();
+      return 1;
+    }
+  return 0;
 }
-FONT *VideoSystem::get_font(int s) {STACKTRACE
-	if (!font_data) {
-		if (basic_font) return basic_font;
-		if (!font) {
-			tw_error_exit("VideoSystem::get_font - something horribly wrong!");
-			return font;
-		}
+
+void VideoSystem::preinit() 
+{
+  STACKTRACE;
+  int i;
+  surface = NULL;
+  width = -1;
+  height = -1;
+  bpp = -1;
+  fullscreen = false;
+  font_data = NULL;
+  basic_font = NULL;
+  palette = (RGB*)malloc(sizeof(RGB) * 256);
+
+  FILE *f = fopen(data_full_path("palette").c_str(), "rb");
+  if (f) 
+    {
+      for (i = 0; i < 256; i += 1) 
+	{
+	  palette[i].r = fgetc(f);
+	  palette[i].g = fgetc(f);
+	  palette[i].b = fgetc(f);
+	  palette[i].filler = 0;
 	}
-	if (s < 0) s = 0;
-	if (s > 7) s = 7;
-	return (FONT*) font_data[s].dat;
+      fclose(f);
+    } 
+  
+  color_effects = gamma_color_effects;
+  
+  screen_corrupted = false;
+  last_poll = -1;
+  window.preinit();
+  window.init( &window );
+  window.locate(0,0,0,0,  0,1,0,1);
 }
-void VideoSystem::set_palette(RGB *new_palette) {STACKTRACE
-	memcpy(palette, new_palette, sizeof(RGB) * 256);
-	update_colors();
-	return;
-}
-void VideoSystem::update_colors() {STACKTRACE
-	RGB tmp[256];
-	if (!palette) return;
-	memcpy(tmp, palette, sizeof(RGB) * 256);
-	int i;	
-	for (i = 1; i < 256; i += 1) {
-		color_effects(&tmp[i]);
-		tmp[i].r = ((unsigned int)(tmp[i].r) * 63) / 255;
-		tmp[i].g = ((unsigned int)(tmp[i].g) * 63) / 255;
-		tmp[i].b = ((unsigned int)(tmp[i].b) * 63) / 255;
+
+FONT *VideoSystem::get_font(int s) 
+{
+  STACKTRACE;
+  if (!font_data) 
+    {
+      if (basic_font) 
+	return basic_font;
+      if (!font) 
+	{
+	  tw_error_exit("VideoSystem::get_font - something horribly wrong!");
+	  return font;
 	}
-	if (rgb_map) create_rgb_table ( rgb_map, tmp, NULL);
-	::set_palette(tmp);
-	return;
+    }
+  if (s < 0) s = 0;
+  if (s > 7) s = 7;
+  return (FONT*) font_data[s].dat;
 }
-void VideoSystem::redraw() {
-	VideoEvent ve;
-	ve.type = Event::VIDEO;
-	ve.subtype = VideoEvent::REDRAW;
-	ve.window = &window;
-	window._event(&ve);
-	//clear_to_color(surface, palette_color[4]);
+
+void VideoSystem::set_palette(RGB *new_palette) 
+{
+  STACKTRACE;
+  memcpy(palette, new_palette, sizeof(RGB) * 256);
+  update_colors();
+  return;
 }
-int VideoSystem::set_resolution (int width, int height, int bpp, int fullscreen) {STACKTRACE
-	VideoEvent ve;
-	ve.type = Event::VIDEO;
-	ve.window = &window;
-	if (width == 0) width = this->width;
-	if (height == 0) height = this->height;
-	if (bpp == 0) bpp = this->bpp;
-	if (!basic_font) basic_font = font;
-	if (!font_data) font_data = load_datafile("fonts.dat");
-	if ((bpp == this->bpp) && (width == this->width) && (height == this->height) && (fullscreen == this->fullscreen)) return true;
-	if ((width < 300) || (height < 200)) {
-		char buffy[512];
-		sprintf(buffy, "Error switching to graphics mode\n(%dx%d @ %d bit)\nresolution too low", width, height, bpp);
-		if (this->bpp == -1) {
-			tw_error_exit(buffy);
-		}
-		tw_alert (buffy, "Continue");
-		return false;
-	}
-	ve.subtype = VideoEvent::INVALID;
-	window._event(&ve);
-	surface = NULL;
-	set_color_depth(bpp);
-	if ( set_gfx_mode((fullscreen ? GFX_TIMEWARP_FULLSCREEN : GFX_TIMEWARP_WINDOW), width, height, 0, 0)) {
-		const char *part1 = "Error switching to graphics mode";
-		char part2[256];
-		sprintf (part2, "(%dx%d @ %d bit)", width, height, bpp);
-		const char *part3 = allegro_error;
-		if (this->bpp == -1) {
-			char buffy[1024];
-			sprintf(buffy, "%s\n%s\n%s", part1, part2, part3);
-			tw_error_exit(buffy);
-		}
-		set_color_depth(this->bpp);
-		set_gfx_mode((this->fullscreen ? GFX_TIMEWARP_FULLSCREEN : GFX_TIMEWARP_WINDOW), this->width, this->height, 0, 0);
-		alert (part1, part2, part3, "Continue", NULL, ' ', '\n');
-		surface = screen;
-		ve.subtype = VideoEvent::VALID;
-		window._event(&ve);
-		surface = NULL;
-		redraw();
-		return false;
-	}
-	surface = screen;
-	if (set_display_switch_mode(SWITCH_BACKAMNESIA) == -1)
-		set_display_switch_mode(SWITCH_BACKGROUND);
-	set_display_switch_callback(SWITCH_IN, tw_display_switch_in);
-	set_display_switch_callback(SWITCH_OUT, tw_display_switch_out);
 
-	int owidth, oheight, obpp, ogamma, ofullscreen;
-	owidth = this->width; oheight = this->height; obpp = this->bpp; 
-	ogamma = this->gamma; ofullscreen = this->fullscreen;
+void VideoSystem::update_colors() 
+{
+  STACKTRACE;
+  RGB tmp[256];
+  if (!palette) return;
+  memcpy(tmp, palette, sizeof(RGB) * 256);
+  int i;	
+  for (i = 1; i < 256; i += 1) 
+    {
+      color_effects(&tmp[i]);
+      tmp[i].r = ((unsigned int)(tmp[i].r) * 63) / 255;
+      tmp[i].g = ((unsigned int)(tmp[i].g) * 63) / 255;
+      tmp[i].b = ((unsigned int)(tmp[i].b) * 63) / 255;
+    }
+  if (rgb_map) 
+    create_rgb_table ( rgb_map, tmp, NULL);
+  ::set_palette(tmp);
+  return;
+}
 
-	this->width = width;
-	this->height = height;
-	this->bpp = bpp;
-	//this->gamma = gamma;
-	this->fullscreen = fullscreen;
-	update_colors();
-	if (font_data) font = (FONT *)(font_data[15].dat);
-	else font = basic_font;
-	if (bpp == 8) {
-		if (!rgb_map) rgb_map = (RGB_MAP*)malloc(1<<15);
-		RGB tmp[256];
-		memcpy(tmp, palette, sizeof(RGB) * 256);
-		int i;	
-		for (i = 0; i < 256; i += 1) {
-			tmp[i].r = ((unsigned int)(tmp[i].r) * 63) / 255;
-			tmp[i].g = ((unsigned int)(tmp[i].g) * 63) / 255;
-			tmp[i].b = ((unsigned int)(tmp[i].b) * 63) / 255;
-		}
-		create_rgb_table ( rgb_map, tmp, NULL);
+void VideoSystem::redraw() 
+{
+  STACKTRACE;
+  VideoEvent ve;
+  ve.type = Event::VIDEO;
+  ve.subtype = VideoEvent::REDRAW;
+  ve.window = &window;
+  window._event(&ve);
+}
+
+int VideoSystem::set_resolution (int width, int height, int bpp, int fullscreen) 
+{
+  VideoEvent ve;
+  ve.type = Event::VIDEO;
+  ve.window = &window;
+  if (width == 0) 
+    width = this->width;
+  if (height == 0) 
+    height = this->height;
+  if (bpp == 0) 
+    bpp = this->bpp;
+  if (!basic_font) 
+    basic_font = font;
+  if (!font_data) 
+    font_data = load_datafile("fonts.dat");
+  if ((bpp == this->bpp) && 
+      (width == this->width) && 
+      (height == this->height) && 
+      (fullscreen == this->fullscreen)) 
+    return true;
+
+  if ((width < 300) || (height < 200)) 
+    {
+      char buffy[512];
+      sprintf(buffy, "Error switching to graphics mode\n(%dx%d @ %d bit)\nresolution too low", width, height, bpp);
+      if (this->bpp == -1) 
+	{
+	  tw_error_exit(buffy);
 	}
-	if (obpp != bpp) {
-		ve.subtype = VideoEvent::CHANGE_BPP;
-		window._event(&ve);
+      tw_alert (buffy, "Continue");
+      return false;
+    }
+  ve.subtype = VideoEvent::INVALID;
+  window._event(&ve);
+  surface = NULL;
+  set_color_depth(bpp);
+  if ( set_gfx_mode((fullscreen ? GFX_TIMEWARP_FULLSCREEN : GFX_TIMEWARP_WINDOW), width, height, 0, 0)) 
+    {
+      const char *part1 = "Error switching to graphics mode";
+      char part2[256];
+      sprintf (part2, "(%dx%d @ %d bit)", width, height, bpp);
+      const char *part3 = allegro_error;
+      if (this->bpp == -1) 
+	{
+	  char buffy[1024];
+	  sprintf(buffy, "%s\n%s\n%s", part1, part2, part3);
+	  tw_error_exit(buffy);
 	}
-	if ((owidth != width) || (oheight != height)) {
-		ve.subtype = VideoEvent::RESIZE;
-		window._event(&ve);
+      set_color_depth(this->bpp);
+      set_gfx_mode((this->fullscreen ? GFX_TIMEWARP_FULLSCREEN : GFX_TIMEWARP_WINDOW), 
+		   this->width, this->height, 0, 0);
+      alert (part1, part2, part3, "Continue", NULL, ' ', '\n');
+      surface = screen;
+      ve.subtype = VideoEvent::VALID;
+      window._event(&ve);
+      surface = NULL;
+      redraw();
+      return false;
+    }
+  surface = screen;
+  if (set_display_switch_mode(SWITCH_BACKAMNESIA) == -1)
+    set_display_switch_mode(SWITCH_BACKGROUND);
+  set_display_switch_callback(SWITCH_IN, tw_display_switch_in);
+  set_display_switch_callback(SWITCH_OUT, tw_display_switch_out);
+  
+  int owidth, oheight, obpp, ogamma, ofullscreen;
+  owidth = this->width; oheight = this->height; obpp = this->bpp; 
+  ogamma = this->gamma; ofullscreen = this->fullscreen;
+
+  this->width = width;
+  this->height = height;
+  this->bpp = bpp;
+  this->fullscreen = fullscreen;
+  update_colors();
+  if (font_data) 
+    font = (FONT *)(font_data[15].dat);
+  else 
+    font = basic_font;
+  if (bpp == 8) 
+    {
+      if (!rgb_map) rgb_map = (RGB_MAP*)malloc(1<<15);
+      RGB tmp[256];
+      memcpy(tmp, palette, sizeof(RGB) * 256);
+      int i;	
+      for (i = 0; i < 256; i += 1) 
+	{
+	  tmp[i].r = ((unsigned int)(tmp[i].r) * 63) / 255;
+	  tmp[i].g = ((unsigned int)(tmp[i].g) * 63) / 255;
+	  tmp[i].b = ((unsigned int)(tmp[i].b) * 63) / 255;
 	}
-
-	ve.subtype = VideoEvent::VALID;
-	window._event(&ve);
-
-	redraw();
-	return true;
+      create_rgb_table ( rgb_map, tmp, NULL);
+  }
+  if (obpp != bpp) 
+    {
+      ve.subtype = VideoEvent::CHANGE_BPP;
+      window._event(&ve);
+    }
+  if ((owidth != width) || (oheight != height)) 
+    {
+      ve.subtype = VideoEvent::RESIZE;
+      window._event(&ve);
+    }
+  
+  ve.subtype = VideoEvent::VALID;
+  window._event(&ve);
+  
+  redraw();
+  return true;
 }
 
-
-
-struct VW_lock_data {
-	short int x, y, w, h;
+struct VW_lock_data 
+{
+  short int x, y, w, h;
 };
 
-void VideoWindow::lock ( ) {
-	//int i = lock_level;
-	lock_level += 1;
-	//if (!surface) return;
-	if (lock_level == 1) {
-/*		if (!lock_data) lock_data = (VW_lock_data*)malloc(sizeof(VW_lock_data));
-		if (w && h) {
-			lock_data[i].x = surface->cl;
-			lock_data[i].y = surface->ct;
-			lock_data[i].w = surface->cr - surface->cl;
-			lock_data[i].h = surface->cb - surface->ct;
-			set_clip(surface, x, y, x+w-1, y+h-1);
-		}
-		else {
-			lock_data[i].x = 0;
-			lock_data[i].y = 0;
-			lock_data[i].w = 0;
-			lock_data[i].h = 0;
-		}*/
-		set_clip(surface, x, y, x+w-1, y+h-1);
-		acquire_bitmap(surface);
-	}
+void VideoWindow::lock ( ) 
+{
+  lock_level += 1;
+  if (lock_level == 1) 
+    {
+      set_clip(surface, x, y, x+w-1, y+h-1);
+      acquire_bitmap(surface);
+    }
 }
-void VideoWindow::unlock ( ) {
-	//int i = lock_level - 1;
-	if (lock_level == 0) {
-		tw_error("VideoWindow unlocked too many times");
-		return;
-	}
-	lock_level -= 1;
-	//if (!surface) return;
-/*	if (w && h) {
-		set_clip(surface, lock_data[i].x, lock_data[i].y,
-			lock_data[i].x + lock_data[i].w - 1,
-			lock_data[i].y + lock_data[i].h - 1
-			);
-	}*/
-	if (lock_level == 0) {
-		release_bitmap(surface);
-		set_clip(surface, 0, 0, surface->w-1, surface->h-1);
-	}
+
+void VideoWindow::unlock ( ) 
+{
+  if (lock_level == 0) {
+    tw_error("VideoWindow unlocked too many times");
+    return;
+  }
+  lock_level -= 1;
+  if (lock_level == 0) 
+    {
+      release_bitmap(surface);
+      set_clip(surface, 0, 0, surface->w-1, surface->h-1);
+    }
 }
+
 #define VideoWindow_callbacklist_units 4
-void VideoWindow::match ( VideoWindow *old ) {
-	if (lock_level) {tw_error("VideoWindow - illegal while locked");}
-	if (!parent && old->parent) init( old->parent );
-	locate ( 
-		old->const_x, old->propr_x, 
-		old->const_y, old->propr_y, 
-		old->const_w, old->propr_w,
-		old->const_h, old->propr_h
-		);
-	return;
+void VideoWindow::match ( VideoWindow *old ) 
+{
+  if (lock_level) 
+    {
+      tw_error("VideoWindow - illegal while locked");
+    }
+  if (!parent && old->parent) 
+    init( old->parent );
+  locate 
+    ( 
+     old->const_x, old->propr_x, 
+     old->const_y, old->propr_y, 
+     old->const_w, old->propr_w,
+     old->const_h, old->propr_h
+     );
+  return;
 }
-void VideoWindow::hide() {
-	locate(0,0,0,0,0,0,0,0);
-	return;
+
+void VideoWindow::hide() 
+{
+  STACKTRACE;
+  locate(0,0,0,0,0,0,0,0);
+  return;
 }
-void VideoWindow::add_callback( BaseClass *callee ) {
-  //int i;
-  //	for (i = 0; i < num_callbacks; i += 1) {
-  //	if (callback_list[i] == callee) {tw_error("adding VideoWindow callback twice");}
-  //}
+
+void VideoWindow::add_callback( BaseClass *callee ) 
+{
+  STACKTRACE;
   std::list<BaseClass*>::iterator cb = std::find(callback_list.begin(),callback_list.end(), callee);
   if(cb != callback_list.end())
     {
       tw_error("adding VideoWindow callback twice");
     }
   callback_list.push_back(callee);
-  //	if (!(num_callbacks & (VideoWindow_callbacklist_units-1))) {
-  //	callback_list = (BaseClass**) realloc(callback_list, sizeof(BaseClass*) * 
-  //		(num_callbacks + VideoWindow_callbacklist_units) );
-  //}
-  //callback_list[num_callbacks] = callee;
-  //num_callbacks += 1;
   return;
 }
 
-void VideoWindow::remove_callback( BaseClass *callee ) {
-  //int i;
-  //	for (i = 0; i < num_callbacks; i += 1) {
-  //	if (callback_list[i] == callee) {
-  //		callback_list[i] = callback_list[num_callbacks-1];
-  //		num_callbacks -= 1;
-  //		if (!(num_callbacks & (VideoWindow_callbacklist_units-1))) callback_list = (BaseClass**)
-  //			realloc(callback_list, sizeof(BaseClass*) * (num_callbacks) );
-  //		return;
-  //	}
-  //}
+void VideoWindow::remove_callback( BaseClass *callee ) 
+{
+  STACKTRACE;
   callback_list.remove(callee);
   return;
 }
-void VideoWindow::event(int subtype) {
-	if (lock_level) {tw_error("VideoWindow - illegal while locked");}
-	VideoEvent ve;
-	ve.type = Event::VIDEO;
-	ve.subtype = subtype;
-	ve.window = this;
-	issue_event( callback_list, &ve);
-	return;
+
+void VideoWindow::event(int subtype) 
+{
+  STACKTRACE;
+  if (lock_level) 
+    {tw_error("VideoWindow - illegal while locked");}
+  VideoEvent ve;
+  ve.type = Event::VIDEO;
+  ve.subtype = subtype;
+  ve.window = this;
+  issue_event( callback_list, &ve);
+  return;
 }
-void VideoWindow::update_pos() {
-	if (lock_level) {tw_error("VideoWindow - illegal while locked");}
-	int nx = 0, ny = 0, nw = 0, nh = 0;
-	if (parent == this) {
-		surface = videosystem.surface;
-		if (surface) {
-			nx = 0;
-			ny = 0;
-			nw = videosystem.width;
-			nh = videosystem.height;
-		}
+
+void VideoWindow::update_pos() 
+{
+  STACKTRACE;
+  if (lock_level) 
+    {tw_error("VideoWindow - illegal while locked");}
+  int nx = 0, ny = 0, nw = 0, nh = 0;
+  if (parent == this) 
+    {
+      surface = videosystem->surface;
+      if (surface) 
+	{
+	  nx = 0;
+	  ny = 0;
+	  nw = videosystem->width;
+	  nh = videosystem->height;
 	}
-	else {
-		if (parent) surface = parent->surface;
-		else surface = NULL;
-		if (surface) {
-			nx = parent->x;
-			ny = parent->y;
-			nw = parent->w;
-			nh = parent->h;
-		}
-	}
-
-	x = nx + iround_up(const_x + propr_x * nw - 0.05);
-	y = ny + iround_up(const_y + propr_y * nh - 0.05);
-	w = iround_down(const_w + propr_w * nw + 0.05);
-	h = iround_down(const_h + propr_h * nh + 0.05);
-
-	if ((w <= 0) || (h <= 0)) surface = NULL;
-	return;
+    }
+  else 
+    {
+      if (parent) surface = parent->surface;
+      else surface = NULL;
+      if (surface) {
+	nx = parent->x;
+	ny = parent->y;
+	nw = parent->w;
+	nh = parent->h;
+      }
+    }
+  
+  x = nx + iround_up(const_x + propr_x * nw - 0.05);
+  y = ny + iround_up(const_y + propr_y * nh - 0.05);
+  w = iround_down(const_w + propr_w * nw + 0.05);
+  h = iround_down(const_h + propr_h * nh + 0.05);
+  
+  if ((w <= 0) || (h <= 0)) surface = NULL;
+  return;
 }
 
-void VideoWindow::_event( Event *e ) {
-	if (e->type == Event::VIDEO) {
-		const VideoEvent *ve = (const VideoEvent *) e;
-		if (ve->window != parent) {tw_error ("VideoWindow event not from parent?");}
-		VideoEvent nve;
-		nve.type = Event::VIDEO;
-		nve.window = this;
-		nve.subtype = ve->subtype;
-		switch (ve->subtype) {
-			case VideoEvent::RESIZE : {
-				update_pos();
-			} break;
-			case VideoEvent::INVALID: {
-				x = y = w = h = 0;
-				surface = NULL;
-			} break;
-			case VideoEvent::VALID: {
-				update_pos();
-			} break;
-			case VideoEvent::REDRAW: {
-				//update_pos();
-			} break;
-		}
-		issue_event( callback_list, &nve);
+void VideoWindow::_event( Event *e ) 
+{
+  STACKTRACE;
+  if (e->type == Event::VIDEO) 
+    {
+      const VideoEvent *ve = (const VideoEvent *) e;
+      if (ve->window != parent) {tw_error ("VideoWindow event not from parent?");}
+      VideoEvent nve;
+      nve.type = Event::VIDEO;
+      nve.window = this;
+      nve.subtype = ve->subtype;
+      switch (ve->subtype) 
+	{
+	case VideoEvent::RESIZE : 
+	  {
+	    update_pos();
+	  } 
+	break;
+	case VideoEvent::INVALID: 
+	  {
+	    x = y = w = h = 0;
+	    surface = NULL;
+	  } 
+	  break;
+	case VideoEvent::VALID: 
+	  {
+	    update_pos();
+	  } 
+	  break;
+	case VideoEvent::REDRAW: 
+	  {	    
+	  } break;
 	}
-	else {tw_error ( "VideoWindow got non-video event" );}
-	return;
+      issue_event( callback_list, &nve);
+    }
+  else {tw_error ( "VideoWindow got non-video event" );}
+  return;
 }
 
-void VideoWindow::preinit () {
-	parent = NULL;
-	surface = NULL;
-	callback_list.clear();
+void VideoWindow::preinit () 
+{
+  parent = NULL;
+  surface = NULL;
+  callback_list.clear();
+  
+  lock_level = 0;
+  
+  const_x = const_y = const_w = const_h = 0;
+  propr_x = propr_y = 0;
+  propr_w = propr_h = 1;
+  x = y = w = h = 0;
+  return;
+}
 
-	lock_level = 0;
+void VideoWindow::init ( VideoWindow *parent_window) 
+{
+  if (lock_level) 
+    {tw_error("VideoWindow - illegal while locked");}
+  if (parent) 
+    parent->remove_callback( this );
+  parent = parent_window;
 
-	const_x = const_y = const_w = const_h = 0;
-	propr_x = propr_y = 0;
-	propr_w = propr_h = 1;
-	x = y = w = h = 0;
-	return;
+  if (parent && (parent != this)) 
+    parent->add_callback ( this );
+  update_pos();
+  event(VideoEvent::RESIZE);
+  event(VideoEvent::REDRAW);
+  return;
 }
-void VideoWindow::init ( VideoWindow *parent_window) {
-	if (lock_level) {tw_error("VideoWindow - illegal while locked");}
-	if (parent) parent->remove_callback( this );
-	parent = parent_window;
-	//if (parent == this) {tw_error("VideoWindow - incest");}
-	if (parent && (parent != this)) parent->add_callback ( this );
-	update_pos();
-	event(VideoEvent::RESIZE);
-	event(VideoEvent::REDRAW);
-	return;
+
+void VideoWindow::locate ( double x1, double x2, 
+			   double y1, double y2, 
+			   double w1, double w2, 
+			   double h1, double h2) 
+{
+  if (lock_level) {tw_error("VideoWindow - illegal while locked");}
+  const_x = x1;
+  propr_x = x2;
+  const_y = y1;
+  propr_y = y2;
+  const_w = w1;
+  propr_w = w2;
+  const_h = h1;
+  propr_h = h2;
+  update_pos();
+  event(VideoEvent::RESIZE);
+  event(VideoEvent::REDRAW);
+  return;
 }
-void VideoWindow::locate ( double x1, double x2, double y1, double y2, double w1, double w2, double h1, double h2) {
-	if (lock_level) {tw_error("VideoWindow - illegal while locked");}
-	const_x = x1;
-	propr_x = x2;
-	const_y = y1;
-	propr_y = y2;
-	const_w = w1;
-	propr_w = w2;
-	const_h = h1;
-	propr_h = h2;
-	update_pos();
-	event(VideoEvent::RESIZE);
-	event(VideoEvent::REDRAW);
-	return;
+
+void VideoWindow::deinit() 
+{
+  STACKTRACE;
+  if (lock_level) {tw_error("VideoWindow - illegal while locked");}
+  if (parent) {
+    parent->remove_callback( this );
+    parent = NULL;
+  }
+  if (callback_list.size()) 
+    {tw_error("VideowWindow - deinit illegal while child windows remain");}
 }
-void VideoWindow::deinit() {
-	if (lock_level) {tw_error("VideoWindow - illegal while locked");}
-	if (parent) {
-		parent->remove_callback( this );
-		parent = NULL;
-	}
-	if (callback_list.size()) 
-		{tw_error("VideowWindow - deinit illegal while child windows remain");}
-	/*for (int i = 0; i < num_callbacks; i += 1) {
-		Event e;
-		e.type = 
-		callback_list[i]->_event(e);
-	}*/
 
-	//free(callback_list);
-	//callback_list = NULL;
-	//num_callbacks = 0;
-	callback_list.clear();
-	
-//	free(lock_data);
-//	lock_data = NULL;
+VideoWindow::~VideoWindow() 
+{
+  deinit();
 }
-VideoWindow::~VideoWindow() {
-	deinit();
-}
 
 
 /*------------------------------
@@ -620,60 +610,71 @@
 ------------------------------*/
 int time_ratio; //1000 milliseconds / SC2 framerate
 double distance_ratio;
-void init_sc2_unit_conversion() {
-	}
-int scale_frames(double value) {
-	return (int)((value + 1) * time_ratio);
-	}
-double scale_turning (double turn_rate) {
-//  turn_rate = 20.0 / ((turn_rate + 1.0) * 5.0);	
-	return (PI2 / 16) / (turn_rate + 1.0) / time_ratio;
-	}
-double scale_velocity (double velocity) {
-//  velocity = velocity / 7.5;
-//velocity = x sc2pixels / sc2frame
-//velocity = y twpixels / twframe
-//velocity = x (1. / 1600) / (50ms)
-//velocity = y (1. / 3840) / (1ms)
-// y = x * (3840 / 1600) / 50
-// WTF????
-	return velocity * distance_ratio / time_ratio;
-	}
-double scale_acceleration (double acceleration, double raw_hotspot_rate) {
-//  accel_rate = accel_rate / 100.0;
-	return acceleration * distance_ratio / (1 + raw_hotspot_rate) / time_ratio / time_ratio; 
-	}
-double scale_range (double range) {
-	return range * 40;
-	}
 
+/// \brief SC2 Unit Conversion
+void init_sc2_unit_conversion() 
+{
+}
+/// \brief SC2 Unit Conversion
+int scale_frames(double value) 
+{
+  return (int)((value + 1) * time_ratio);
+}
+/// \brief SC2 Unit Conversion
+double scale_turning (double turn_rate) 
+{
+  return (PI2 / 16) / (turn_rate + 1.0) / time_ratio;
+}
+/// \brief SC2 Unit Conversion
+double scale_velocity (double velocity) 
+{
+  return velocity * distance_ratio / time_ratio;
+}
 
-void show_file(const char *file) {
-	int i;
-	char *willy;
-	PACKFILE *f;
-	f = pack_fopen (file, F_READ);
-	if (!f) {
-		willy = (char*) malloc(strlen(file)+1);
-		sprintf(willy, "Failed to load file \"%s\"", file);
-	}
-	else {
-		i = file_size(file);
-		willy = (char*)malloc(i+1);
-		i = pack_fread (willy, i, f);
-		pack_fclose(f);
-		willy[i] = 0;
-	}
-	show_text(willy);
-	free(willy);
-	return;
+/// \brief SC2 Unit Conversion
+double scale_acceleration (double acceleration, double raw_hotspot_rate) 
+{
+  return acceleration * distance_ratio / (1 + raw_hotspot_rate) / time_ratio / time_ratio; 
 }
-void show_text(const char *text) {
-	help_dialog[2].dp = (void *) text;
-	help_dialog[2].d1 = 0;
-	help_dialog[2].d2 = 0;
-	tw_popup_dialog(&videosystem.window, help_dialog, 1);
-	return;
+/// \brief SC2 Unit Conversion
+double scale_range (double range) 
+{
+  return range * 40;
 }
 
-	
+/// \brief show file in pupup dialog
+void show_file(std::string file) 
+{
+  int i;
+  char *willy;
+  PACKFILE *f;
+  f = pack_fopen (file.c_str(), F_READ);
+  if (!f) 
+    {
+      willy = (char*) malloc(file.size()+1);
+      sprintf(willy, "Failed to load file \"%s\"", file.c_str());
+    }
+  else 
+    {
+      i = file_size(file.c_str());
+      willy = (char*)malloc(i+1);
+      i = pack_fread (willy, i, f);
+      pack_fclose(f);
+      willy[i] = 0;
+    }
+  show_text(willy);
+  free(willy);
+  return;
+}
+
+/// \brief show text in popup dialog
+void show_text(std::string text) 
+{
+  help_dialog[2].dp = (void *) text.c_str();
+  help_dialog[2].d1 = 0;
+  help_dialog[2].d2 = 0;
+  tw_popup_dialog(&videosystem->window, help_dialog, 1);
+  return;
+}
+
+

Modified: branches/multiplayer-branch/source/melee/mitems.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mitems.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mitems.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -17,7 +17,6 @@
 
 #include <allegro.h>
 #include "melee.h"
-REGISTER_FILE
 
 
 #include "frame.h"
@@ -31,6 +30,7 @@
 
 HealthBar::HealthBar(Ship *creator, int *toggle)
 {
+  STACKTRACE;
 	scale = 2.0;
 	bartoggle = toggle;
 	mother = creator;
@@ -38,7 +38,7 @@
 
 void HealthBar::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if ( !(mother && mother->exists()) )
 	{
@@ -51,7 +51,7 @@
 
 void HealthBar::draw_bar(Ship *s, double yoffs, int len, double H, double fraction, int col1, int col2, Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	Vector2 center;
 	int d;
@@ -87,7 +87,7 @@
 
 void HealthBar::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if (!*bartoggle)
 		return;
@@ -112,10 +112,12 @@
 
 
 
-Indicator::Indicator() : Presence() {STACKTRACE
+Indicator::Indicator() : Presence() {
+  STACKTRACE;
 	}
 
-bool Indicator::coords(Frame *space, SpaceLocation *l, Vector2 *pos, Vector2 *a_pos) {STACKTRACE
+bool Indicator::coords(Frame *space, SpaceLocation *l, Vector2 *pos, Vector2 *a_pos) {
+  STACKTRACE;
 	Vector2 p = corner(l->normal_pos());
 	Vector2 op = p;
 
@@ -146,12 +148,14 @@
 	return true;
 	}
 
-BlinkyIndicator::BlinkyIndicator(SpaceObject *target, int color) : Indicator() {STACKTRACE
+BlinkyIndicator::BlinkyIndicator(SpaceObject *target, int color) : Indicator() {
+  STACKTRACE;
 	this->target = target;
 	this->color = color;
 	}
 
 void BlinkyIndicator::animate(Frame *space) {
+  STACKTRACE;
 	if ((game->game_time >> 8) & 1) return;
 	Vector2 p;
 	int a = coords(space, target, &p);
@@ -176,17 +180,20 @@
 	}
 	return;
 	}
-void BlinkyIndicator::calculate() {STACKTRACE
+void BlinkyIndicator::calculate() {
+  STACKTRACE;
 	if (!target->exists()) die();
 	}
 
-WedgeIndicator::WedgeIndicator(SpaceLocation *target, int length, int color) : Indicator() {STACKTRACE
+WedgeIndicator::WedgeIndicator(SpaceLocation *target, int length, int color) : Indicator() {
+  STACKTRACE;
 	this->target = target;
 	this->length = length;
 	this->color = color;
 	}
 
 void WedgeIndicator::animate(Frame *space) {
+  STACKTRACE;
 	double a, a2;
 	Vector2 p, p2, tmp;
 	if (target->isInvisible() > 0.5) return;
@@ -208,6 +215,7 @@
 	return;
 	}
 void WedgeIndicator::calculate() {
+  STACKTRACE;
 	if (!target->exists()) die();
 	}
 
@@ -224,7 +232,8 @@
 	accelerate(this, angle + PI/2 + PI*(random()&1), 0.15, MAX_SPEED);
 	}
 
-void Orbiter::calculate() {STACKTRACE
+void Orbiter::calculate() {
+  STACKTRACE;
 	angle = trajectory_angle(center) + PI;
 	sprite_index = get_index(angle);
 	double r = distance(center) / radius;

Modified: branches/multiplayer-branch/source/melee/mlog.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mlog.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mlog.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -30,7 +30,8 @@
 //				Logging stuff
 ////////////////////////////////////////////////////////////////////////
 
-void Log::init() {STACKTRACE
+void Log::init() {
+  STACKTRACE;
 	log_len  = NULL;
 	log_size = NULL;
 	log_pos  = NULL;
@@ -93,7 +94,8 @@
 	if (log_dir[channel] & direction_read) _unlog ( channel, data, size);
 	return;
 }
-void Log::_log(int channel, const void *data, int size) {STACKTRACE
+void Log::_log(int channel, const void *data, int size) {
+  STACKTRACE;
 	log_len[channel] += size;
 	while (log_len[channel] > log_size[channel]) {
 		if (log_size[channel]) log_size[channel] = log_size[channel] * 2;
@@ -104,7 +106,7 @@
 	return;
 }
 void Log::_unlog(int channel, void *data, int size) {
-	STACKTRACE;
+  STACKTRACE;
 	if (log_len[channel] < log_pos[channel] + size) {tw_error ("Game::_unlog - went past end (%d+%d/%d on %d)", log_pos[channel], size, log_len[channel], channel);}
 	memcpy(data, log_data[channel]+log_pos[channel], size);
 	log_pos[channel] += size;
@@ -158,7 +160,7 @@
 	return;
 }
 void Log::expand_logs(int num_channels) {
-	STACKTRACE;
+  STACKTRACE;
 	int old_log_num = log_num;
 	if (num_channels <= log_num) { tw_error ("Log::expand_logs - shrinking logs?"); }
 	log_num = num_channels;
@@ -177,12 +179,13 @@
 	return;
 }
 int Log::ready(int channel) {
+  STACKTRACE;
 	if (channel < 0) { tw_error ("log_ready - negative channel!"); }
 	if (channel >= log_num) return 0;
 	return log_len[channel] - log_pos[channel];
 }
 int Log::file_ready(const char *fname, void **location) {
-	STACKTRACE;
+  STACKTRACE;
 	if (log_num <= channel_file_data) return -1;
 	int i = 0, j = 0;
 	while (i < log_len[channel_file_names]) {
@@ -208,6 +211,7 @@
 	return -1;
 }
 void Log::log_file(const char *fname) {
+  STACKTRACE;
 	void *loc;
 	if (!(log_dir[channel_file_data] & direction_read)) {
 		set_config_file(home_ini_full_path(fname).c_str());
@@ -250,7 +254,8 @@
 	return;
 }
 
-void Log::deinit() {STACKTRACE
+void Log::deinit() {
+  STACKTRACE;
 	return;
 }
 
@@ -296,14 +301,17 @@
 }
 
 void Log::flush() {
+  STACKTRACE;
 	return;
 }
 
 bool Log::listen() {
+  STACKTRACE;
 	return false;
 }
 
 void Log::reset() {
+  STACKTRACE;
 	int i;
 	for (i = 0 ; i < this->log_num; i += 1) {
 		log_pos[i] = 0;
@@ -313,7 +321,8 @@
 
 
 
-void PlaybackLog::init() {STACKTRACE
+void PlaybackLog::init() {
+  STACKTRACE;
 	Log::init();
 	playback = true;
 	default_direction = Log::direction_read;
@@ -329,7 +338,7 @@
 }
 
 void PlaybackLog::set_all_directions( char direction ) {
-	STACKTRACE;
+  STACKTRACE;
 	tw_error("set_all_directions - your not supposed to do that in a demo playback!");
 	return;
 }

Modified: branches/multiplayer-branch/source/melee/mmain.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mmain.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mmain.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -22,7 +22,6 @@
 #include <allegro.h>
 
 #include "melee.h"
-REGISTER_FILE
 #include "scp.h"
 #include "frame.h"
 
@@ -96,7 +95,8 @@
 	return i;
 	}
 
-void NormalGame::init_objects() {STACKTRACE
+void NormalGame::init_objects() {
+  STACKTRACE;
 	int i;
 	add(new Stars());
 	Planet *planet = create_planet();
@@ -107,7 +107,8 @@
 	for (i = 0; i < num_asteroids; i += 1) add(new Asteroid());
 	}
 
-void NormalGame::init_players() {STACKTRACE
+void NormalGame::init_players() {
+  STACKTRACE;
 	switch (log->type) {
 		case Log::log_normal: {
 			for (int i = 0; true; i += 1) {
@@ -196,6 +197,7 @@
 }
 
 void NormalGame::set_resolution(int screen_x, int screen_y) {
+  STACKTRACE;
 	int view_x, view_y;
 	view_x = screen_x;
 	view_y = screen_y;
@@ -209,6 +211,7 @@
 	}
 
 void NormalGame::preinit() {
+  STACKTRACE;
 	Game::preinit();
 	player_control = NULL;
 	player_name = NULL;
@@ -224,7 +227,8 @@
 	gameEnding = false;
 	gameEndingTime = DefaultEndingTime;
 	}
-void NormalGame::init(Log *_log) {STACKTRACE
+void NormalGame::init(Log *_log) {
+  STACKTRACE;
 	Game::init(_log);
 
 	team_table_size = 0;
@@ -282,7 +286,8 @@
 	}
 
 static int kill_all_delay_counter = 0;
-void NormalGame::calculate() {STACKTRACE
+void NormalGame::calculate() {
+  STACKTRACE;
 	Game::calculate();
 	if (next_choose_new_ships_time <= game_time) {
 		choose_new_ships();
@@ -318,7 +323,8 @@
 	return;
 	}
 
-void NormalGame::ship_died(Ship *who, SpaceLocation *source) {STACKTRACE
+void NormalGame::ship_died(Ship *who, SpaceLocation *source) {
+  STACKTRACE;
 	char victimName[80] = "";
 	char killerName[80] = "";
 	int victimID = -1;
@@ -380,7 +386,8 @@
 	return;
 	}
 
-void NormalGame::display_stats() {STACKTRACE
+void NormalGame::display_stats() {
+  STACKTRACE;
 	pause();
 	int i;
 	for (i = 0; i < num_players; i += 1) {
@@ -405,7 +412,7 @@
 }
 bool NormalGame::handle_key(int k)
 {
-	STACKTRACE;
+  STACKTRACE;
 	switch (k >> 8) {
 		default: {
 			return Game::handle_key(k);
@@ -455,180 +462,190 @@
 
 
 
-void NormalGame::choose_new_ships() {STACKTRACE
-	char tmp[40];
-	int i;
-	pause();
-	//message.out("Selecting ships...", 1000);
-	int *slot = new int[num_players];
-	//choose ships and send them across network
-	for (i = 0; i < num_players; i += 1) {
-		slot[i] = -2;
-		if (player_control[i]->ship) {
-			}
-		else {
-//			if (player_panel[i]) player_panel[i]->window->hide();
-//			player_panel[i] = NULL;
-			sprintf (tmp, "Player%d", i+1);
-			Fleet *fleet = player_fleet[i];
-			if (fleet->getSize() == 0) continue;
-			char buffy[512];
+void NormalGame::choose_new_ships() 
+{
+  STACKTRACE;
+  char tmp[40];
+  int i;
+  pause();
 
-            if (strlen(fleet->getTitle()) != 0) 
-                sprintf(buffy, "%s\n%s\n", player_name[i], fleet->getTitle());
-            else
-                sprintf(buffy, "%s\n", player_name[i]);
+  int *slot = new int[num_players];
+  //choose ships and send them across network
+  for (i = 0; i < num_players; i += 1) 
+    {
+      slot[i] = -2;
+      if (player_control[i]->ship) 
+	{
+	}
+      else 
+	{
+	  sprintf (tmp, "Player%d", i+1);
+	  Fleet *fleet = player_fleet[i];
+	  if (fleet->getSize() == 0) continue;
+	  char buffy[512];
+	  
+	  if (strlen(fleet->getTitle()) != 0) 
+	    sprintf(buffy, "%s\n%s\n", player_name[i], fleet->getTitle());
+	  else
+	    sprintf(buffy, "%s\n", player_name[i]);
+	  
+	  slot[i] = player_control[i]->choose_ship(window, buffy, fleet);
+	  if (player_control[i]->channel != channel_none) {
+	    slot[i] = intel_ordering(slot[i]);
+	    log->buffer(player_control[i]->channel, &slot[i], sizeof(int));
+	    log->flush();
+	  }
+	}
+    }
+  //recieve the ships that were chosen
+  log->listen();
+  for (i = 0; i < num_players; i += 1) 
+    {
+      if (slot[i] == -2) continue;
+      if (player_control[i]->channel != channel_none) 
+	{
+	  log->unbuffer(player_control[i]->channel, &slot[i], sizeof(int));
+	  slot[i] = intel_ordering(slot[i]);
+	}
+    }
+  //create the ships that were chosen
+  for (i = 0; i < num_players; i += 1) 
+    {
+      if (slot[i] == -2) continue;
+      sprintf (tmp, "Player%d", i+1);
 
-			slot[i] = player_control[i]->choose_ship(window, buffy, fleet);
-			if (player_control[i]->channel != channel_none) {
-				slot[i] = intel_ordering(slot[i]);
-				log->buffer(player_control[i]->channel, &slot[i], sizeof(int));
-				log->flush();
-				//slot[i] = intel_ordering(slot[i]);
-				}
-			}
-		}
-	//recieve the ships that were chosen
-	log->listen();
-	for (i = 0; i < num_players; i += 1) {
-		if (slot[i] == -2) continue;
-		if (player_control[i]->channel != channel_none) {
-			log->unbuffer(player_control[i]->channel, &slot[i], sizeof(int));
-			slot[i] = intel_ordering(slot[i]);
-			}
-		}
-	//create the ships that were chosen
-	for (i = 0; i < num_players; i += 1) {
-		if (slot[i] == -2) continue;
-		sprintf (tmp, "Player%d", i+1);
-		//fleet->load("./fleets.tmp", tmp);
-		Fleet *fleet = player_fleet[i];
-		if (slot[i] == -1) slot[i] = random() % fleet->getSize();
-		if (slot[i] < 0 || slot[i] >= fleet->getSize()) {tw_error("trying to load invalid ship");}
-		Ship *s = create_ship(fleet->getShipType(slot[i])->id, player_control[i], random(size), random(PI2), player_team[i]);
-		if (!s) {tw_error("unable to create ship");}
-		fleet->clear_slot(slot[i]);
-		fleet->Sort();
-		//fleet->save("./fleets.tmp", tmp);
-		s->locate();
-		add ( new WedgeIndicator ( s, 30, i+1 ) );
-		ShipPanel *panel = new ShipPanel(s);
-		panel->window->init(window);
-		panel->window->locate(
-			0, 0.9,
-			0, i * (100.0/480), 
-			0, 0.1,
-			0, (100.0/480)
-			);
-		add(panel);
-		add(s->get_ship_phaser());
-
-		// add a healthbar for the ship, and also a team indicator.
-		add(new HealthBar(s, &indhealthtoggle));
-		add(new TeamIndicator(s, &indteamtoggle));
-
+      Fleet *fleet = player_fleet[i];
+      if (slot[i] == -1) slot[i] = random() % fleet->getSize();
+      if (slot[i] < 0 || slot[i] >= fleet->getSize()) {tw_error("trying to load invalid ship");}
+      Ship *s = create_ship(fleet->getShipType(slot[i])->id, player_control[i], random(size), random(PI2), player_team[i]);
+      if (!s) {tw_error("unable to create ship");}
+      fleet->clear_slot(slot[i]);
+      fleet->Sort();
+      
+      s->locate();
+      add ( new WedgeIndicator ( s, 30, i+1 ) );
+      ShipPanel *panel = new ShipPanel(s);
+      panel->window->init(window);
+      panel->window->locate(
+			    0, 0.9,
+			    0, i * (100.0/480), 
+			    0, 0.1,
+			    0, (100.0/480)
+			    );
+      add(panel);
+      add(s->get_ship_phaser());
+      
+      // add a healthbar for the ship, and also a team indicator.
+      add(new HealthBar(s, &indhealthtoggle));
+      add(new TeamIndicator(s, &indteamtoggle));
+      
+      
+      // CHECK FILE SIZES !! to intercept desynch before they happen.
+      int myfsize, otherfsize;
+      
+      myfsize = 0;
+      otherfsize = myfsize;
+      if (player_control[i]->channel != channel_none) 
+	{
+	  log_int(player_control[i]->channel, otherfsize);
+	}
+      
+      if (otherfsize != myfsize)
+	{
+	  // the player who loads the ship doesn't get this message, cause his own file is identical by default
+	  tw_error("DAT files have different size! This may cause a desynch. Press Retry to continue");
+	}
 		
-		// CHECK FILE SIZES !! to intercept desynch before they happen.
-		int myfsize, otherfsize;
-
-		myfsize = file_size(s->type->data->file);
-		otherfsize = myfsize;
-		if (player_control[i]->channel != channel_none) {
-			log_int(player_control[i]->channel, otherfsize);
-		}
-
-		if (otherfsize != myfsize)
-		{
-			// the player who loads the ship doesn't get this message, cause his own file is identical by default
-			tw_error("DAT files have different size! This may cause a desynch. Press Retry to continue");
-		}
 		
+    }
+  delete[] slot;
+  //message.out("Finished selecting ships...", 1500);
+  unpause();
+  return;
+}
 
-		}
-	delete[] slot;
-	//message.out("Finished selecting ships...", 1500);
-	unpause();
-	return;
+bool NormalGame::isGameDone() 
+{
+  STACKTRACE;
+  /*! we'll only check this every now and again, to avoid bogging down the engine.  */  
+  enum { IterationsToSkip = 30 };
+  static long iterationsToSkip = IterationsToSkip;
+  
+  /*! */
+  if (gameEnding) {
+    /*! how long do we wait after a victory before exiting the game? */
+    if (--gameEndingTime > 0)
+      return Game::isGameDone();
+    else {
+      game_done = true;
+    }
+  }
+  
+  if (iterationsToSkip-- <=0 ) {
+    iterationsToSkip = IterationsToSkip;
+    
+    //determine how many teams are still alive
+    unsigned numAliveTeams = 0;
+    TeamCode * teams = (TeamCode*)calloc(MAX_TEAMS, sizeof(TeamCode));
+    
+    for (int i=0; i<num_players; i++) {
+      
+      //check for: 
+      //* does the player have any ships left in her fleet?
+      //* is the player controlling a ship right now?
+      if ( ( player_fleet[i] && 
+	     player_fleet[i]->getSize() > 0)
+	   ||
+	   (player_control[i] &&
+	    player_control[i]->ship)
+	   )
+	{
+	  if (teams[ player_team[i] ] == 0)
+	    numAliveTeams++;
+	  teams[ player_team[i] ]++;
 	}
-
-bool NormalGame::isGameDone() {
-	/*! we'll only check this every now and again, to avoid bogging down the engine.  */  
-	enum { IterationsToSkip = 30 };
-	static long iterationsToSkip = IterationsToSkip;
-	
-	/*! */
-	if (gameEnding) {
-		/*! how long do we wait after a victory before exiting the game? */
-		if (--gameEndingTime > 0)
-			return Game::isGameDone();
-		else {
-			game_done = true;
-		}
-	}
-	
-	if (iterationsToSkip-- <=0 ) {
-		iterationsToSkip = IterationsToSkip;
-		
-	    //determine how many teams are still alive
-	    unsigned numAliveTeams = 0;
-	    TeamCode * teams = (TeamCode*)calloc(MAX_TEAMS, sizeof(TeamCode));
-
-	    for (int i=0; i<num_players; i++) {
-	  	    
-	  	    //check for: 
-	  	    //* does the player have any ships left in her fleet?
-	  	    //* is the player controlling a ship right now?
-	  	    if ( ( player_fleet[i] && 
-	  	    	   player_fleet[i]->getSize() > 0)
-	  	    	||
-	  	    	 (player_control[i] &&
-	  	    	  player_control[i]->ship)
-	  	    	)
-	  	    {
-	  	    	if (teams[ player_team[i] ] == 0)
-	  	    		numAliveTeams++;
-	  	    	teams[ player_team[i] ]++;
-	  	    }
-	    }
-	    
-	    //either there's one team left standing, or none. :)
-	    // either way, the game is over.
-	    //we delay ending the game a few seconds for dramatic effect
-	    if (numAliveTeams <= 1) {
-	    	gameEnding = true;
-	    	if (numAliveTeams==1) {
-	    		for (int i=0; i<num_players; i++) {
-	    			if ( ( player_fleet[i] && 
-	  	    	   		   player_fleet[i]->getSize() > 0)
-	  	    			||
-	  	    	 		  (player_control[i] &&
-	  	    	           player_control[i]->ship) )
-	  	    	    {
-	  	    	    	if (player_control[i]->isHuman())
-	    					message.print(8000,15,"%s won the match!", player_name[i]);
-	    				else
-	    					message.print(8000,15,"%s won the match!", control_name[ player_control[i]->getControlType() ]);
+    }
+    
+    //either there's one team left standing, or none. :)
+    // either way, the game is over.
+    //we delay ending the game a few seconds for dramatic effect
+    if (numAliveTeams <= 1) {
+      gameEnding = true;
+      if (numAliveTeams==1) {
+	for (int i=0; i<num_players; i++) {
+	  if ( ( player_fleet[i] && 
+		 player_fleet[i]->getSize() > 0)
+	       ||
+	       (player_control[i] &&
+		player_control[i]->ship) )
+	    {
+	      if (player_control[i]->isHuman())
+		message.print(8000,15,"%s won the match!", player_name[i]);
+	      else
+		message.print(8000,15,"%s won the match!", control_name[ player_control[i]->getControlType() ]);
 	    				break;
-	    			}
-	    		}
-	    	} else {
-	    		message.print(8000,15,"Match ends in a draw!");
-	    	}
 	    }
-	    free(teams);
 	}
-    return Game::isGameDone();
+      } else {
+	message.print(8000,15,"Match ends in a draw!");
+      }
+    }
+    free(teams);
+  }
+  return Game::isGameDone();
 }
 
 // this should be places elsewhere I think ...
 TeamIndicator::TeamIndicator(Ship *s, int *atoggle)
 {
+  STACKTRACE;
 	indtoggle = atoggle;
 	mother = s;
 }
 
 void TeamIndicator::calculate()
 {
+  STACKTRACE;
 	if ( !(mother && mother->exists()) )
 	{
 		mother = 0;
@@ -638,6 +655,7 @@
 }
 
 void TeamIndicator::animate(Frame *space) {
+  STACKTRACE;
   if (!*indtoggle)
     return;
   
@@ -662,6 +680,7 @@
   
 }
 void NormalGame::showHelpText() {
+  STACKTRACE;
 	const char * file = data_full_path("ingame.txt").c_str();
 	char text[10000] = "";
 	char controlHelp[3000] = "";

Modified: branches/multiplayer-branch/source/melee/mmath.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mmath.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mmath.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -17,7 +17,6 @@
 
 
 #include "melee.h"
-REGISTER_FILE
 #include "mview.h"
 
 #include "util/vector2.h"

Modified: branches/multiplayer-branch/source/melee/mnet1.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mnet1.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mnet1.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -20,11 +20,9 @@
 #include <string.h>
 #include <allegro.h>
 #include "melee.h"
-REGISTER_FILE
 #include "mnet1.h"
 #include "mview.h"
 #include "mcontrol.h"
-//#include "mcbodies.h"
 #include "scp.h"
 
 GameEventMessage::GameEventMessage (const char *text)
@@ -35,7 +33,8 @@
 	size = sizeof(GameEvent) + l;
 	type = Game::event_message;
 }
-void GameEventMessage::execute( int source ) {STACKTRACE
+void GameEventMessage::execute( int source ) {
+  STACKTRACE;
 	char buffy[64+max_message_length];
 	char *tmp = buffy;
 	int c = 15;
@@ -49,7 +48,8 @@
 	::message.out(buffy, 6000, c);
 }
 
-void GameEventChangeLag::execute( int source ) {STACKTRACE
+void GameEventChangeLag::execute( int source ) {
+  STACKTRACE;
 	if (source != Game::channel_server) return;
 	if (old_lag != game->lag_frames) return;
 	int i;
@@ -113,39 +113,50 @@
 		}
 	}
 
-void NetLog::init() {STACKTRACE
+void NetLog::init() {
+  STACKTRACE;
 	}
-void NetLog::deinit() {STACKTRACE
+void NetLog::deinit() {
+  STACKTRACE;
 	}
 
 NetLog::~NetLog() {STACKTRACE
 	}
 
 void NetLog::send_packet() {
+  STACKTRACE;
 	}
 void NetLog::recv_packet() {
+  STACKTRACE;
 	}
 
 void NetLog::expand_logs(int num_channels) {
+  STACKTRACE;
 	return;
 	}
 
 void NetLog::_log(int channel, const void *data, int size) {
+  STACKTRACE;
 }
 void NetLog::_unlog(int channel, void *data, int size) {
+  STACKTRACE;
 	return;
 	}
 
 void NetLog::log_file(const char *fname) {
+  STACKTRACE;
 }
 
 void NetLog::flush() {
+  STACKTRACE;
 }
 
 bool NetLog::listen() {
+  STACKTRACE;
 return false;
 }
 
 int NetLog::ready(int channel) {
+  STACKTRACE;
 return 0;
 }

Modified: branches/multiplayer-branch/source/melee/moptions.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/moptions.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/moptions.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -25,7 +25,6 @@
 #include <string.h>
 
 #include "melee.h"
-REGISTER_FILE
 
 #include "moptions.h"
 #include "scp.h"
@@ -37,9 +36,9 @@
 #include "util/sound.h"
 
 /*
-
+  
 -	master menu
-		client.ini
+                 client.ini
 -			video mode
 				exit (exit menu)
 				apply (use settings)
@@ -79,356 +78,390 @@
 */
 
 
-void options_menu (Game *game) {STACKTRACE
-	int a;
-	while (true) {
-		a = tw_popup_dialog(NULL, options_dialog, 0);
-		switch (a) {
-			default: 
-			case DIALOG_OPTIONS_DONE: {
-				return;
-				}
-			break;
-			case DIALOG_OPTIONS_VIDEO: {
-				video_menu(game);
-				}
-			break;
-			case DIALOG_OPTIONS_AUDIO: {
-				audio_menu(game);
-				}
-			break;
-			case DIALOG_OPTIONS_CONFIG: {
-				config_menu(game);
-				}
-			break;
-			case DIALOG_OPTIONS_PHYSICS: {
-				physics_menu(game);
-				}
-			break;
-			case DIALOG_OPTIONS_DEFAULT: {
-				}
-			break;
-			}
-		}
-	return;
+/// \brief Show option dialog 
+void options_menu (Game *game) 
+{
+  int a;
+  while (true) 
+    {
+      a = tw_popup_dialog(NULL, options_dialog, 0);
+      switch (a) 
+	{
+	default: 
+	case DIALOG_OPTIONS_DONE: 
+	  {
+	    return;
+	  }
+	  break;
+	case DIALOG_OPTIONS_VIDEO: 
+	  {
+	    video_menu(game);
+	  }
+	  break;
+	case DIALOG_OPTIONS_AUDIO: 
+	  {
+	    audio_menu(game);
+	  }
+	  break;
+	case DIALOG_OPTIONS_CONFIG: 
+	  {
+	    config_menu(game);
+	  }
+	  break;
+	case DIALOG_OPTIONS_PHYSICS: 
+	  {
+	    physics_menu(game);
+	  }
+	  break;
+	case DIALOG_OPTIONS_DEFAULT: 
+	  {
+	  }
+	  break;
 	}
+    }
+  return;
+}
 
-
-bool confirmVideoChanges() {    
-    int choice = -1;
-    while (-1 != (choice = tw_popup_dialog(NULL, confirmVideoDialog, 0))) {        
-        switch (choice) {
-        case DIALOG_CONFIRM_VIDEO_YES:
-            return true;
+/// \brief Show Confirm video changes dialog
+bool confirmVideoChanges() 
+{    
+  int choice = -1;
+  while (-1 != (choice = tw_popup_dialog(NULL, confirmVideoDialog, 0))) 
+    {        
+      switch (choice) 
+	{
+	case DIALOG_CONFIRM_VIDEO_YES:
+	  return true;
         case DIALOG_CONFIRM_VIDEO_NO:
-            return false;
+	  return false;
         }
     }
-    return false;
+  return false;
 }
 
-char *resolution[] = { 
-	"640x480", "800x600", "1024x768", "1280x1024", "Custom", NULL
-	};
-char *color_depth[] = { 
-	"8", "15", "16", "24", "32", NULL
-	};
+char *resolution[] = 
+  { 
+    "640x480", "800x600", "1024x768", "1280x1024", "Custom", NULL
+  };
+char *color_depth[] = 
+  { 
+    "8", "15", "16", "24", "32", NULL
+  };
 
-int handleGammaSliderChange(void *dp3, int d2) {
-    set_gamma(d2);
-    return d2;
+/// \brief Set gamma function
+int handleGammaSliderChange(void *dp3, int d2) 
+{
+  set_gamma(d2);
+  return d2;
 }
 
-
-void video_menu (Game *game) {STACKTRACE
-	int choice = -1;
-    bool done = false;
-    
-	while ( (choice != DIALOG_VIDEO_EXIT) && (!done) ) {
-		sprintf(dialog_string[3], "%dx%d", videosystem.width, videosystem.height);
-
-
-        //set index for resolution
-        int x=-1, y=-1, x2, y2, i, bpp, bpp2, fs;
-        x2 = videosystem.width;
-        y2 = videosystem.height;
-        for (i = 0; resolution[i+1]; i += 1) {
-            x = strtol(resolution[i], NULL, 10);
-            y = strtol(strchr(resolution[i], 'x') + 1, NULL, 10);
-            if ((x == x2) && (y == y2)) break;
+/// brief Show video menu dialog
+void video_menu (Game *game) 
+{
+  int choice = -1;
+  bool done = false;
+  
+  while ( (choice != DIALOG_VIDEO_EXIT) && (!done) ) 
+    {
+      sprintf(dialog_string[3], "%dx%d", videosystem->width, videosystem->height);
+      
+      
+      //set index for resolution
+      int x=-1, y=-1, x2, y2, i, bpp, bpp2, fs;
+      x2 = videosystem->width;
+      y2 = videosystem->height;
+      for (i = 0; resolution[i+1]; i += 1) 
+	{
+	  x = strtol(resolution[i], NULL, 10);
+	  y = strtol(strchr(resolution[i], 'x') + 1, NULL, 10);
+	  if ((x == x2) && (y == y2)) 
+	    break;
         }
-        if(!resolution[0]) { tw_error("Resolution error"); }
-        	
-        video_dialog[DIALOG_VIDEO_RESLIST].d1 = i;
-        //set index for bpp
-        bpp = videosystem.bpp;
-        for (i = 0; true; i += 1) {
-            if (!color_depth[i]) { tw_error("video_menu - current bpp invalid?"); }
-            if (strtol(color_depth[i], NULL, 10) == bpp) break;
-        }
-        video_dialog[DIALOG_VIDEO_BPPLIST].d1 = i;
+      if(!resolution[0]) 
+	{ 
+	  tw_error("Resolution error"); 
+	}
+      
+      video_dialog[DIALOG_VIDEO_RESLIST].d1 = i;
+      //set index for bpp
+      bpp = videosystem->bpp;
+      for (i = 0; true; i += 1) 
+	{
+	  if (!color_depth[i]) 
+	    { 
+	      tw_error("video_menu - current bpp invalid?"); 
+	    }
+	  if (strtol(color_depth[i], NULL, 10) == bpp) 
+	    break;
+	}
+      video_dialog[DIALOG_VIDEO_BPPLIST].d1 = i;
         
-        //set button for fullscreen
-        video_dialog[DIALOG_VIDEO_FULLSCREEN].flags = videosystem.fullscreen ? D_SELECTED : 0;
+      //set button for fullscreen
+      video_dialog[DIALOG_VIDEO_FULLSCREEN].flags = videosystem->fullscreen ? D_SELECTED : 0;
 
-        int startfs = video_dialog[DIALOG_VIDEO_FULLSCREEN].flags;
+      int startfs = video_dialog[DIALOG_VIDEO_FULLSCREEN].flags;
+      
+      
+      //set gamma correction
+      video_dialog[DIALOG_VIDEO_GAMMA_SLIDER].d2 = get_gamma();
 
-        
-        //set gamma correction
-        video_dialog[DIALOG_VIDEO_GAMMA_SLIDER].d2 = get_gamma();
+      //do the dialog
+      choice = tw_popup_dialog(NULL, video_dialog, 0);
+      if (choice == -1) 
+	choice = DIALOG_VIDEO_EXIT;
 
-		//do the dialog
-		choice = tw_popup_dialog(NULL, video_dialog, 0);
-		if (choice == -1) choice = DIALOG_VIDEO_EXIT;
+      //set resolution
+      i = video_dialog[DIALOG_VIDEO_RESLIST].d1;
+      char *tmp = resolution[i];
+      if (!resolution[i+1]) 
+	tmp = dialog_string[3];
+      x2 = strtol(tmp, NULL, 10);
+      y2 = strtol(strchr(tmp, 'x') + 1, NULL, 10);
+      
+      //set bpp from menu
+      i = video_dialog[DIALOG_VIDEO_BPPLIST].d1;
+      bpp2 = strtol(color_depth[i], NULL, 10);
+      
+      //set fullscreen from menu
+      fs = video_dialog[DIALOG_VIDEO_FULLSCREEN].flags & D_SELECTED;
+      
+      switch (choice) 
+	{
+	case DIALOG_VIDEO_GET_DEFAULT:
+	  tw_set_config_file("client.ini");
+	  bpp2   = get_config_int("Video", "BitsPerPixel", 16);
+	  x2     = get_config_int("Video", "ScreenWidth", 640);
+	  y2     = get_config_int("Video", "ScreenHeight", 480);
+	  fs     = get_config_int("Video", "FullScreen", false);
+	  set_gamma(get_config_int("Video", "Gamma", 128));
+	  
+	  videosystem->set_resolution(x2, y2, bpp2, fs);
+	  break;
+	  
+	  
+	case DIALOG_VIDEO_SET_DEFAULT:
+	  if ((bpp2 != bpp) && game) 
+	    {
+	      tw_alert ("Color depths cannot be changed in\nthe middle of a game\nin this version", "Okay");
+	    }
+	  else 
+	    {
+	      done = true;
+	    }
+	  break;
 
-		//set resolution
-		i = video_dialog[DIALOG_VIDEO_RESLIST].d1;
-		char *tmp = resolution[i];
-		if (!resolution[i+1]) tmp = dialog_string[3];
-		x2 = strtol(tmp, NULL, 10);
-		y2 = strtol(strchr(tmp, 'x') + 1, NULL, 10);
-
-		//set bpp from menu
-		i = video_dialog[DIALOG_VIDEO_BPPLIST].d1;
-        bpp2 = strtol(color_depth[i], NULL, 10);
-        
-        //set fullscreen from menu
-        fs = video_dialog[DIALOG_VIDEO_FULLSCREEN].flags & D_SELECTED;
-        
-        switch (choice) {
-            case DIALOG_VIDEO_GET_DEFAULT:
-                tw_set_config_file("client.ini");
-                bpp2   = get_config_int("Video", "BitsPerPixel", 16);
-                x2     = get_config_int("Video", "ScreenWidth", 640);
-                y2     = get_config_int("Video", "ScreenHeight", 480);
-                fs     = get_config_int("Video", "FullScreen", false);
-                set_gamma(get_config_int("Video", "Gamma", 128));
-
-                videosystem.set_resolution(x2, y2, bpp2, fs);
-                break;
-            
-           
-             case DIALOG_VIDEO_SET_DEFAULT:
-                 if ((bpp2 != bpp) && game) {
-                     tw_alert ("Color depths cannot be changed in\nthe middle of a game\nin this version", "Okay");
-                 }
-                 else {
-                     done = true;
-                 }
-                 break;
-
-             case DIALOG_VIDEO_BPPLIST:
-             case DIALOG_VIDEO_RESLIST:
-                 break;
-
-             case DIALOG_VIDEO_GAMMA_SLIDER:
-                 set_gamma(video_dialog[DIALOG_VIDEO_GAMMA_SLIDER].d2);
-                 break;
-
-             case DIALOG_VIDEO_EXIT:
-             case -1:
-                 return;
-                 break;
+	case DIALOG_VIDEO_BPPLIST:
+	case DIALOG_VIDEO_RESLIST:
+	  break;
+	  
+	case DIALOG_VIDEO_GAMMA_SLIDER:
+	  set_gamma(video_dialog[DIALOG_VIDEO_GAMMA_SLIDER].d2);
+	  break;
+	  
+	case DIALOG_VIDEO_EXIT:
+	case -1:
+	  return;
+	  break;
         }
-        
-        if ( (x2 != x) ||
-             (y2 != y) ||
-             (bpp != bpp2) ||
-             (startfs != fs) )
+      
+      if ( (x2 != x) ||
+	   (y2 != y) ||
+	   (bpp != bpp2) ||
+	   (startfs != fs) )
         {
-            set_gamma(video_dialog[DIALOG_VIDEO_GAMMA_SLIDER].d2);
-
-            //try to set video mode.  If it does not work, back out, and do not confirm
-            //the changes.
-            if ( ! videosystem.set_resolution(x2, y2, bpp2, fs))  {
-                done = false;
+	  set_gamma(video_dialog[DIALOG_VIDEO_GAMMA_SLIDER].d2);
+	  
+	  //try to set video mode.  If it does not work, back out, and do not confirm
+	  //the changes.
+	  if ( ! videosystem->set_resolution(x2, y2, bpp2, fs))  
+	    {
+	      done = false;
+	    }
+	  else 
+	    {
+	    //if the video mode was actually set, confirm the changes
+	    if (confirmVideoChanges()) 
+	      {
+		tw_set_config_file("client.ini");
+		set_config_int("Video", "BitsPerPixel", bpp2);
+		set_config_int("Video", "ScreenWidth", x2);
+		set_config_int("Video", "ScreenHeight", y2);
+		set_config_int("Video", "FullScreen", fs);
+		set_config_int("Video", "Gamma", get_gamma());
+		return;
+	      }
+	    else 
+	      {
+		tw_set_config_file("client.ini");
+		bpp2   = get_config_int("Video", "BitsPerPixel", 16);
+		x2     = get_config_int("Video", "ScreenWidth", 640);
+		y2     = get_config_int("Video", "ScreenHeight", 480);
+		fs     = get_config_int("Video", "FullScreen", false);
+		set_gamma(get_config_int("Video", "Gamma", 128));
+		
+		i = videosystem->set_resolution(x2, y2, bpp2, fs);
+		done = false;
+	      }
             }
-            else {
-                //if the video mode was actually set, confirm the changes
-                if (confirmVideoChanges()) {
-                    tw_set_config_file("client.ini");
-                    set_config_int("Video", "BitsPerPixel", bpp2);
-                    set_config_int("Video", "ScreenWidth", x2);
-                    set_config_int("Video", "ScreenHeight", y2);
-                    set_config_int("Video", "FullScreen", fs);
-                    set_config_int("Video", "Gamma", get_gamma());
-                    return;
-                }
-                else {
-                    tw_set_config_file("client.ini");
-                    bpp2   = get_config_int("Video", "BitsPerPixel", 16);
-                    x2     = get_config_int("Video", "ScreenWidth", 640);
-                    y2     = get_config_int("Video", "ScreenHeight", 480);
-                    fs     = get_config_int("Video", "FullScreen", false);
-                    set_gamma(get_config_int("Video", "Gamma", 128));
-                    
-                    i = videosystem.set_resolution(x2, y2, bpp2, fs);
-                    done = false;
-                }
-            }
         }
-        
-	}
-	return;
+      
+    }
+  return;
 }
 
+/// \brief Show audio dialog
 void audio_menu (Game *game) 
 {
   int i;
 
   //set dialog values
-  audio_dialog[DIALOG_AUDIO_SOUND_VOL].d2 = iround(100 * tw_sound.load_sound_volume());
-  audio_dialog[DIALOG_AUDIO_MUSIC_VOL].d2 = iround(100 * tw_sound.load_music_volume());
+  audio_dialog[DIALOG_AUDIO_SOUND_VOL].d2 = iround(100 * tw_sound->load_sound_volume());
+  audio_dialog[DIALOG_AUDIO_MUSIC_VOL].d2 = iround(100 * tw_sound->load_music_volume());
 	
   //do the dialog
   i = tw_popup_dialog(NULL, audio_dialog, 0);
   if (i != DIALOG_AUDIO_OK) return;
   
   //set actual values
-  tw_sound.set_sound_volume( audio_dialog[DIALOG_AUDIO_SOUND_VOL].d2/100.0);
-  tw_sound.set_music_volume( audio_dialog[DIALOG_AUDIO_MUSIC_VOL].d2/100.0);
+  tw_sound->set_sound_volume( audio_dialog[DIALOG_AUDIO_SOUND_VOL].d2/100.0);
+  tw_sound->set_music_volume( audio_dialog[DIALOG_AUDIO_MUSIC_VOL].d2/100.0);
 };
 
 int handleSoundSliderChange(void *dp3, int d2) 
 {
-  tw_sound.set_sound_volume( audio_dialog[DIALOG_AUDIO_SOUND_VOL].d2/100.0);
+  tw_sound->set_sound_volume( audio_dialog[DIALOG_AUDIO_SOUND_VOL].d2/100.0);
   return 0;
 }
 
-int handleMusicSliderChange(void *dp3, int d2) {
-  tw_sound.set_music_volume( audio_dialog[DIALOG_AUDIO_MUSIC_VOL].d2/100.0);
+int handleMusicSliderChange(void *dp3, int d2) 
+{
+  tw_sound->set_music_volume( audio_dialog[DIALOG_AUDIO_MUSIC_VOL].d2/100.0);
   return 0;
 }
 
 
-
-
-
 #include "mview.h"
 #include "mgame.h"
 
 char *viewListboxGetter(int index, int *list_size) 
 {
-	static char tmp[40];
-	tmp[0] = 0;
-	if(index < 0) {
-		*list_size = num_views;
-		return NULL;
-	} else {
-		return(view_name[index]);
-	}
+  static char tmp[40];
+  tmp[0] = 0;
+  if(index < 0) 
+    {
+      *list_size = num_views;
+      return NULL;
+    } 
+  else 
+    {
+      return(view_name[index]);
+    }
 }
 
 
-void change_options() {STACKTRACE
-	int optionsRet, i;
+void change_options() 
+{
+  int optionsRet, i;
 
-	tw_set_config_file("client.ini");
-//	old_optionsDialog[OPTIONS_DIALOG_AA].d1 = get_aa_mode();
+  tw_set_config_file("client.ini");
 
-	old_optionsDialog[OPTIONS_DIALOG_INTERPOLATION_ON].flags = 
-		interpolate_frames ? D_SELECTED : 0;
-	int aa = get_config_int("Rendering", "AA_Mode", AA_NO_AA);
-	old_optionsDialog[OPTIONS_DIALOG_AA_ON].flags = 
-		(aa&AA_NO_AA) ? 0 : D_SELECTED;
-	old_optionsDialog[OPTIONS_DIALOG_NOALIGN_ON].flags = 
-		(aa&AA_NO_ALIGN) ? D_SELECTED : 0;
-	old_optionsDialog[OPTIONS_DIALOG_BLEND_ON].flags = 
-		(aa&AA_BLEND) ? D_SELECTED : 0;
-	old_optionsDialog[OPTIONS_DIALOG_ALPHA_ON].flags = 
-		(aa&AA_ALPHA) ? D_SELECTED : 0;
+  old_optionsDialog[OPTIONS_DIALOG_INTERPOLATION_ON].flags = 
+    interpolate_frames ? D_SELECTED : 0;
+  int aa = get_config_int("Rendering", "AA_Mode", AA_NO_AA);
+  old_optionsDialog[OPTIONS_DIALOG_AA_ON].flags = 
+    (aa&AA_NO_AA) ? 0 : D_SELECTED;
+  old_optionsDialog[OPTIONS_DIALOG_NOALIGN_ON].flags = 
+    (aa&AA_NO_ALIGN) ? D_SELECTED : 0;
+  old_optionsDialog[OPTIONS_DIALOG_BLEND_ON].flags = 
+    (aa&AA_BLEND) ? D_SELECTED : 0;
+  old_optionsDialog[OPTIONS_DIALOG_ALPHA_ON].flags = 
+    (aa&AA_ALPHA) ? D_SELECTED : 0;
+  
+  
+  tw_set_config_file("server.ini");
+  old_optionsDialog[OPTIONS_DIALOG_STARS_SLIDER].d2 = 
+    get_config_int("Stars", "Depth", 192);
+  old_optionsDialog[OPTIONS_DIALOG_RELATIVITY_SLIDER].d2 = 
+    iround(get_config_float("Game", "ShotRelativity", 0.5) * 1000);
+  if (get_config_int("Game", "FriendlyFire", 1)) 
+    old_optionsDialog[OPTIONS_DIALOG_FRIENDLY_FIRE].flags = D_SELECTED;
+  else
+    old_optionsDialog[OPTIONS_DIALOG_FRIENDLY_FIRE].flags = 0;
+  
+  if (get_config_int("View", "CameraHidesCloakers", 1)) 
+    old_optionsDialog[OPTIONS_DIALOG_HIDE_CLOAKERS].flags = D_SELECTED;
+  else
+    old_optionsDialog[OPTIONS_DIALOG_HIDE_CLOAKERS].flags = 0;
+  
+  tw_set_config_file("client.ini");
+  
+  if (get_config_int("Planet", "PlanetDimension", 2) == 3) 
+    old_optionsDialog[OPTIONS_DIALOG_3DPLANET].flags = D_SELECTED;
+  else
+    old_optionsDialog[OPTIONS_DIALOG_3DPLANET].flags = 0;
+  
+  i = get_view_num ( get_config_string ( "View", "View", NULL ) );
+  if (i == -1) i = 0;
+  old_optionsDialog[OPTIONS_DIALOG_VIEW].d1 = i;
+  
+  
+  optionsRet = tw_popup_dialog(NULL, old_optionsDialog, OPTIONS_DIALOG_OK);
+  
+  if (optionsRet == OPTIONS_DIALOG_CANCEL) return;
+  
+  tw_set_config_file("client.ini");
+  interpolate_frames = 
+    (old_optionsDialog[OPTIONS_DIALOG_INTERPOLATION_ON].flags & D_SELECTED) ? 1 : 0;
+  set_config_int("View", "InterpolateFrames", interpolate_frames);
+  aa&=~AA_NO_AA;aa|= (old_optionsDialog[OPTIONS_DIALOG_AA_ON].flags) ? 
+		  0 : AA_NO_AA;
+  aa&=~AA_NO_ALIGN;aa|= (old_optionsDialog[OPTIONS_DIALOG_NOALIGN_ON].flags) ? 
+		     AA_NO_ALIGN : 0;
+  aa&=~AA_BLEND;aa|= (old_optionsDialog[OPTIONS_DIALOG_BLEND_ON].flags) ? 
+		  AA_BLEND : 0;
+  aa&=~AA_ALPHA;aa|= (old_optionsDialog[OPTIONS_DIALOG_ALPHA_ON].flags) ? 
+		  AA_ALPHA : 0;
+  set_config_int("Rendering", "AA_Mode", aa);
+  set_tw_aa_mode(aa);
+    
+  View *v = get_view(
+		     view_name[old_optionsDialog[OPTIONS_DIALOG_VIEW].d1],
+		     NULL
+		     );
+  set_view(v);
+  twconfig_set_string("/cfg/client.ini/view/view", 
+		      view_name[old_optionsDialog[OPTIONS_DIALOG_VIEW].d1]);
+  if (game && !game->view_locked) game->change_view(
+						    view_name[old_optionsDialog[OPTIONS_DIALOG_VIEW].d1]);
+  
+  
+  twconfig_set_int("/cfg/server.ini/stars/depth", 
+		   old_optionsDialog[OPTIONS_DIALOG_STARS_SLIDER].d2);
+  
+  twconfig_set_float("/cfg/server.ini/game/shotrelativity", 
+		     old_optionsDialog[OPTIONS_DIALOG_RELATIVITY_SLIDER].d2 / 1000.0);
+  
+  
+  if (old_optionsDialog[OPTIONS_DIALOG_FRIENDLY_FIRE].flags & D_SELECTED) 
+    i = 1;
+  else i = 0;
+  twconfig_set_int("/cfg/server.ini/game/friendlyfire", i);
+  
+  if (old_optionsDialog[OPTIONS_DIALOG_HIDE_CLOAKERS].flags & D_SELECTED) 
+    i = 1;
+  else i = 0;
+  twconfig_set_int("/cfg/server.ini/view/camerahidescloakers", i);
+  
+  return;
+}
 
+void config_menu (Game *game) 
+{
+  change_options();
+};
 
-	tw_set_config_file("server.ini");
-	old_optionsDialog[OPTIONS_DIALOG_STARS_SLIDER].d2 = 
-		get_config_int("Stars", "Depth", 192);
-	old_optionsDialog[OPTIONS_DIALOG_RELATIVITY_SLIDER].d2 = 
-		iround(get_config_float("Game", "ShotRelativity", 0.5) * 1000);
-	if (get_config_int("Game", "FriendlyFire", 1)) 
-		old_optionsDialog[OPTIONS_DIALOG_FRIENDLY_FIRE].flags = D_SELECTED;
-	else
-		old_optionsDialog[OPTIONS_DIALOG_FRIENDLY_FIRE].flags = 0;
+void physics_menu (Game *game) 
+{
+};
 
-	if (get_config_int("View", "CameraHidesCloakers", 1)) 
-		old_optionsDialog[OPTIONS_DIALOG_HIDE_CLOAKERS].flags = D_SELECTED;
-	else
-		old_optionsDialog[OPTIONS_DIALOG_HIDE_CLOAKERS].flags = 0;
 
-	tw_set_config_file("client.ini");
-
-	if (get_config_int("Planet", "PlanetDimension", 2) == 3) 
-		old_optionsDialog[OPTIONS_DIALOG_3DPLANET].flags = D_SELECTED;
-	else
-		old_optionsDialog[OPTIONS_DIALOG_3DPLANET].flags = 0;
-
-	i = get_view_num ( get_config_string ( "View", "View", NULL ) );
-	if (i == -1) i = 0;
-	old_optionsDialog[OPTIONS_DIALOG_VIEW].d1 = i;
-
- 
-	optionsRet = tw_popup_dialog(NULL, old_optionsDialog, OPTIONS_DIALOG_OK);
-
-	if (optionsRet == OPTIONS_DIALOG_CANCEL) return;
-
-//	set_aa_mode(old_optionsDialog[OPTIONS_DIALOG_AA].d1);
-
-	tw_set_config_file("client.ini");
-//	set_config_int("View", "Anti-Aliasing", get_aa_mode());
-	interpolate_frames = 
-		(old_optionsDialog[OPTIONS_DIALOG_INTERPOLATION_ON].flags & D_SELECTED) ? 1 : 0;
-	set_config_int("View", "InterpolateFrames", interpolate_frames);
-	aa&=~AA_NO_AA;aa|= (old_optionsDialog[OPTIONS_DIALOG_AA_ON].flags) ? 
-		0 : AA_NO_AA;
-	aa&=~AA_NO_ALIGN;aa|= (old_optionsDialog[OPTIONS_DIALOG_NOALIGN_ON].flags) ? 
-		AA_NO_ALIGN : 0;
-	aa&=~AA_BLEND;aa|= (old_optionsDialog[OPTIONS_DIALOG_BLEND_ON].flags) ? 
-		AA_BLEND : 0;
-	aa&=~AA_ALPHA;aa|= (old_optionsDialog[OPTIONS_DIALOG_ALPHA_ON].flags) ? 
-		AA_ALPHA : 0;
-	set_config_int("Rendering", "AA_Mode", aa);
-	set_tw_aa_mode(aa);
-
-	if (old_optionsDialog[OPTIONS_DIALOG_3DPLANET].flags == D_SELECTED)
-		i = 3;
-	else
-		i = 2;
-	set_config_int("Planet", "PlanetDimension", i);
-
-	View *v = get_view(
-		view_name[old_optionsDialog[OPTIONS_DIALOG_VIEW].d1],
-		NULL
-		);
-	set_view(v);
-	twconfig_set_string("/cfg/client.ini/view/view", 
-		view_name[old_optionsDialog[OPTIONS_DIALOG_VIEW].d1]);
-	if (game && !game->view_locked) game->change_view(
-		view_name[old_optionsDialog[OPTIONS_DIALOG_VIEW].d1]);
-
-
-	twconfig_set_int("/cfg/server.ini/stars/depth", 
-		old_optionsDialog[OPTIONS_DIALOG_STARS_SLIDER].d2);
-
-	twconfig_set_float("/cfg/server.ini/game/shotrelativity", 
-		old_optionsDialog[OPTIONS_DIALOG_RELATIVITY_SLIDER].d2 / 1000.0);
-
-
-	if (old_optionsDialog[OPTIONS_DIALOG_FRIENDLY_FIRE].flags & D_SELECTED) 
-		i = 1;
-	else i = 0;
-	twconfig_set_int("/cfg/server.ini/game/friendlyfire", i);
-
-	if (old_optionsDialog[OPTIONS_DIALOG_HIDE_CLOAKERS].flags & D_SELECTED) 
-		i = 1;
-	else i = 0;
-	twconfig_set_int("/cfg/server.ini/view/camerahidescloakers", i);
-
-	return;
-	}
-
-void config_menu (Game *game) {STACKTRACE
-	change_options();
-	};
-void physics_menu (Game *game) {STACKTRACE
-	};
-
-

Modified: branches/multiplayer-branch/source/melee/mship.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mship.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mship.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,7 +1,7 @@
 /* $Id: mship.cpp,v 1.2 2004/08/08 17:36:06 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -15,13 +15,13 @@
 GNU General Public License for more details.
 */
 
+#include "util/sound.h"
 
 #include <allegro.h>
 #include <string.h>
 #include <stdio.h>
 
 #include "melee.h"
-REGISTER_FILE
 #include "id.h"
 #include "frame.h"
 
@@ -43,36 +43,41 @@
 ShipClass *shipclasses = NULL;
 
 void register_shipclass (
-	const char *name, 
-	const char *source_name, 
-	Ship *(*func)(Vector2 pos, double a, ShipData *data, unsigned int code)
-) 
+			 const char *name, 
+			 const char *source_name, 
+			 Ship *(*func)(Vector2 pos, double a, ShipData *data, unsigned int code)
+			 ) 
 {
-	num_shipclasses += 1;
-	shipclasses = (ShipClass*)realloc(shipclasses, num_shipclasses * sizeof(ShipClass));
-	int i = num_shipclasses-1;
-	shipclasses[i].link_order = i;
-	shipclasses[i].name = name;
-	shipclasses[i].source = source_name;
-	shipclasses[i]._get_ship = func;
-	return;
+  num_shipclasses += 1;
+  shipclasses = (ShipClass*)realloc(shipclasses, num_shipclasses * sizeof(ShipClass));
+  int i = num_shipclasses-1;
+  shipclasses[i].link_order = i;
+  shipclasses[i].name = name;
+  shipclasses[i].source = source_name;
+  shipclasses[i]._get_ship = func;
+  return;
 }
 
 Ship *ShipClass::get_ship(Vector2 pos, double angle, ShipData *dat, unsigned int team) {
-	dat->lock();
-	Ship *s = _get_ship(pos, angle, dat, team);
-	dat->unlock();
-	s->code = this;
-	return s;
+  STACKTRACE;
+  dat->lock();
+  Ship *s = _get_ship(pos, angle, dat, team);
+  dat->unlock();
+  s->code = this;
+  return s;
 }
 
-ShipClass *shipclass ( const char *name ) {
-	int i;
-	if (!name) return NULL;
-	for (i = 0; i < num_shipclasses; i += 1) {
-		if (!strcmp(shipclasses[i].name, name)) return &shipclasses[i];
-	}
-	return NULL;
+ShipClass *shipclass ( const char *name ) 
+{
+  int i;
+  if (!name) 
+    return NULL;
+  for (i = 0; i < num_shipclasses; i += 1) 
+    {
+      if (!strcmp(shipclasses[i].name, name)) 
+	return &shipclasses[i];
+    }
+  return NULL;
 }
 
 
@@ -85,33 +90,41 @@
 ShipType *shiptypes = NULL;
 
 
-Ship *ShipType::get_ship(Vector2 pos, double angle, unsigned int team) {
-	game->log_file(file);
-	Ship *s = code->get_ship(pos, angle, data, team);
-	s->type = this;
-	return s;
+Ship *ShipType::get_ship(Vector2 pos, double angle, unsigned int team) 
+{
+  STACKTRACE;
+  game->log_file(file);
+  Ship *s = code->get_ship(pos, angle, data, team);
+  s->type = this;
+  return s;
 }
 
-ShipType *shiptype(const char *shiptype_id) {
-	int i;
-	for (i = 0; i < num_shiptypes; i += 1) {
-		if (!strcmp(shiptype_id, shiptypes[i].id)) {
-			return &shiptypes[i];
-		}
+ShipType *shiptype(const char *shiptype_id) 
+{
+  int i;
+  for (i = 0; i < num_shiptypes; i += 1) 
+    {
+      if (!strcmp(shiptype_id, shiptypes[i].id)) 
+	{
+	  return &shiptypes[i];
 	}
-	return NULL;
+    }
+  return NULL;
 }
 
-const char *old_code_name( const char *file ) {
-	char buffy[2048];
-	if (strlen(file) != 18) return NULL;
-	strncpy(buffy, file+9, 5);
-	buffy[5] = 0;
-	int i;
-	for (i = 0; i < num_shipclasses; i += 1) {
-		if (strstr(shipclasses[i].source, buffy)) return shipclasses[i].name;
-	}
-	return NULL;
+const char *old_code_name( const char *file ) 
+{
+  char buffy[2048];
+  if (strlen(file) != 18) 
+    return NULL;
+  strncpy(buffy, file+9, 5);
+  buffy[5] = 0;
+  int i;
+  for (i = 0; i < num_shipclasses; i += 1) 
+    {
+      if (strstr(shipclasses[i].source, buffy)) return shipclasses[i].name;
+    }
+  return NULL;
 }
 
 static void register_shiptype ( const char *file ) 
@@ -127,7 +140,8 @@
   char buffy[1024];
   strncpy(buffy, file, 1000);
   char *tmp = strrchr(buffy, '.');
-  if (!tmp || (tmp - buffy < 5)) tw_error("bad ship file name (%s)", file);
+  if (!tmp || (tmp - buffy < 5)) 
+    tw_error("bad ship file name (%s)", file);
   *tmp = 0;
   shiptypes[i].id = strdup(tmp - 5);
   
@@ -145,37 +159,36 @@
   
 
   const char *name = get_config_string("Info", "Name", NULL);
-  if (!name) {
-    const char *tmp;
-    int l = 0;
-    tmp = get_config_string("Info", "Name0", NULL);
-    if (tmp) {
-      l += sprintf(buffy + l, "%s ", tmp);
+  if (!name) 
+    {
+      const char *tmp;
+      int l = 0;
+      tmp = get_config_string("Info", "Name0", NULL);
+      if (tmp) 
+	{
+	  l += sprintf(buffy + l, "%s ", tmp);
+	}
+      tmp = get_config_string("Info", "Name1", NULL);
+      if (!tmp)
+	tw_error("init_ships - error initializing name (%s)", file);
+      l += sprintf(buffy + l, "%s", tmp);
+      int n = 1;
+      while (true) 
+	{
+	  char buf[25];
+	  n += 1;
+	  sprintf(buf, "Name%d", n);
+	  tmp = get_config_string("Info", buf, NULL);
+	  if (!tmp) 
+	    break;
+	  l += sprintf(buffy + l, " %s", tmp);
+	}
+      name = buffy;
     }
-    tmp = get_config_string("Info", "Name1", NULL);
-    if (!tmp)
-      tw_error("init_ships - error initializing name (%s)", file);
-    l += sprintf(buffy + l, "%s", tmp);
-    int n = 1;
-    while (true) {
-      char buf[25];
-      n += 1;
-      sprintf(buf, "Name%d", n);
-      tmp = get_config_string("Info", buf, NULL);
-      if (!tmp) break;
-      l += sprintf(buffy + l, " %s", tmp);
-    }
-    name = buffy;
-  }
   shiptypes[i].name = strdup(name);
   shiptypes[i].cost = get_config_int("Info", "TWCost", 0);
-  const char *data = get_config_string("Info", "Data", NULL);
-  if (!data) {
-    replace_extension(buffy, ini_path.c_str(), "dat", 2040);
-    shiptypes[i].data = shipdata(data_full_path(buffy).c_str());
-  }
-  else 
-    shiptypes[i].data = shipdata(data);
+  shiptypes[i].data = shipdata( ini_path );
+  
   const char *text = get_config_string("Info", "Description", NULL);
   if (!text) 
     {
@@ -189,19 +202,20 @@
   shiptypes[i].code = shipclass(code);
   if (!shiptypes[i].data || !shiptypes[i].code) 
     {
-      if (!data) data = "none";
-      if (!code) code = "none";
+      if (!code) 
+	code = "none";
       char buffy[2048];
       char *tmp = buffy;
       tmp += sprintf(tmp, "Ship registration failed\n%s (%s)\n",
 		     shiptypes[i].name, shiptypes[i].file);
-      if (!shiptypes[i].data) tmp += sprintf(tmp, "Data not found (%s)\n", data);
-      if (!shiptypes[i].code) tmp += sprintf(tmp, "Code not found (%s)\n", code);
-      error("%s", buffy);
+      if (!shiptypes[i].code) 
+	tmp += sprintf(tmp, "Code not found (%s)\n", code);
+      tw_error(buffy);
       num_shiptypes -= 1;
       return;
     }
-  if (old) set_config_string("Info", "Code", code);
+  if (old) 
+    set_config_string("Info", "Code", code);
   
   return;
   
@@ -243,499 +257,556 @@
 	update_panel(false),
 	target_pressed(false),
 	control(NULL)
-{STACKTRACE
-	attributes |= ATTRIB_SHIP;
-	layer = LAYER_SHIPS;
-	set_depth(DEPTH_SHIPS);
-	collide_flag_sameteam = ALL_LAYERS;
-	collide_flag_sameship = ALL_LAYERS;
-	nextkeys = 0;
-	id = SPACE_SHIP;
+{
+  STACKTRACE;
+  attributes |= ATTRIB_SHIP;
+  layer = LAYER_SHIPS;
+  set_depth(DEPTH_SHIPS);
+  collide_flag_sameteam = ALL_LAYERS;
+  collide_flag_sameship = ALL_LAYERS;
+  nextkeys = 0;
+  id = SPACE_SHIP;
+	
+  type = NULL;
+  code = NULL;
 
-	type = NULL;
-	code = NULL;
-
-	// modified otherwise the kat poly crashes
-	if (creator->isShip())
-		type = ((Ship*) creator)->type;
-
-	captain_name[0] = '\0';
-	thrust           = FALSE;
-	turn_left        = FALSE;
-	turn_right       = FALSE;
-	thrust_backwards = FALSE;
-	fire_weapon      = FALSE;
-	fire_special     = FALSE;
-	fire_altweapon   = FALSE;
-
-	spritePanel = NULL;
-
-	turn_step = 0;
-	angle = floor(oangle / (PI2/64)) * (PI2/64);
-	sprite_index = get_index(angle);
-
-	hashotspots = true;
+  // modified otherwise the kat poly crashes
+  if (creator->isShip())
+    type = ((Ship*) creator)->type;
+  
+  captain_name[0] = '\0';
+  thrust           = FALSE;
+  turn_left        = FALSE;
+  turn_right       = FALSE;
+  thrust_backwards = FALSE;
+  fire_weapon      = FALSE;
+  fire_special     = FALSE;
+  fire_altweapon   = FALSE;
+  
+  spritePanel = NULL;
+  
+  turn_step = 0;
+  angle = floor(oangle / (PI2/64)) * (PI2/64);
+  sprite_index = get_index(angle);
+  
+  hashotspots = true;
 }
 
 Ship::Ship(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int ally_flag) :
-	SpaceObject(NULL, opos, shipAngle, shipData->spriteShip),
-	death_counter(-1),
-	update_panel(false),
-	target_pressed(false),
-	control(NULL)
-{STACKTRACE
-	shipData->lock();
-	attributes |= ATTRIB_SHIP;
-	layer = LAYER_SHIPS;
-	set_depth(DEPTH_SHIPS);
+  SpaceObject(NULL, opos, shipAngle, shipData->spriteShip),
+  death_counter(-1),
+  update_panel(false),
+  target_pressed(false),
+  control(NULL)
+{
+  STACKTRACE;
+  shipData->lock();
+  attributes |= ATTRIB_SHIP;
+  layer = LAYER_SHIPS;
+  set_depth(DEPTH_SHIPS);
 
-	type = NULL;
-	code = NULL;
+  type = NULL;
+  code = NULL;
+	
+  captain_name[0] = '\0';
+  ship = this;
+  data = shipData;
+  this->ally_flag = ally_flag;
 
-	captain_name[0] = '\0';
-	ship = this;
-	data = shipData;
-	this->ally_flag = ally_flag;
+  collide_flag_sameteam = ALL_LAYERS;
+  collide_flag_sameship = ALL_LAYERS;
+  nextkeys = 0;
 
-	collide_flag_sameteam = ALL_LAYERS;
-	collide_flag_sameship = ALL_LAYERS;
-	nextkeys = 0;
+  id = SPACE_SHIP;
+  
+  int i;
+  i = get_config_int("Names", "NumNames", 0);
+  int L = sizeof(captain_name);
+  if (i) {
+    char buffy[16];
+    sprintf(buffy, "CaptName%d", 1+(rand() % i));
+    const char *tmp = get_config_string("Names", buffy, "");
+    i = strlen(tmp);
+    strncpy(captain_name, tmp, L);
+    if (i >= L) i = L-1;
+    captain_name[i] = '\0';
+  }
+  else captain_name[0] = '\0';
+  
+  crew     = get_config_int("Ship", "Crew", 0);
+  crew_max = get_config_int("Ship", "CrewMax", 0);
+  batt     = get_config_int("Ship", "Batt", 0);
+  batt_max = get_config_int("Ship", "BattMax", 0);
+  
+  recharge_amount  = get_config_int("Ship", "RechargeAmount", 0);
+  recharge_rate    = scale_frames(get_config_float("Ship", "RechargeRate", 0));
+  recharge_step    = recharge_rate;
+  weapon_drain     = get_config_int("Ship", "WeaponDrain", 0);
+  weapon_rate      = scale_frames(get_config_float("Ship", "WeaponRate", 0));
+  weapon_sample    = 0;
+  weapon_recharge  = 0;
+  weapon_low       = FALSE;
+  special_drain    = get_config_int("Ship", "SpecialDrain", 0);
+  special_rate     = scale_frames(get_config_float("Ship", "SpecialRate", 0));
+  special_sample   = 0;
+  special_recharge = 0;
+  special_low      = FALSE;
 
-	id = SPACE_SHIP;
-
-	int i;
-	i = get_config_int("Names", "NumNames", 0);
-	int L = sizeof(captain_name);
-	if (i) {
-		char buffy[16];
-		sprintf(buffy, "CaptName%d", 1+(rand() % i));
-		const char *tmp = get_config_string("Names", buffy, "");
-		i = strlen(tmp);
-		strncpy(captain_name, tmp, L);
-		if (i >= L) i = L-1;
-		captain_name[i] = '\0';
-	}
-	else captain_name[0] = '\0';
-
-	crew     = get_config_int("Ship", "Crew", 0);
-	crew_max = get_config_int("Ship", "CrewMax", 0);
-	batt     = get_config_int("Ship", "Batt", 0);
-	batt_max = get_config_int("Ship", "BattMax", 0);
-
-	recharge_amount  = get_config_int("Ship", "RechargeAmount", 0);
-	recharge_rate    = scale_frames(get_config_float("Ship", "RechargeRate", 0));
-	recharge_step    = recharge_rate;
-	weapon_drain     = get_config_int("Ship", "WeaponDrain", 0);
-	weapon_rate      = scale_frames(get_config_float("Ship", "WeaponRate", 0));
-	weapon_sample    = 0;
-	weapon_recharge  = 0;
-	weapon_low       = FALSE;
-	special_drain    = get_config_int("Ship", "SpecialDrain", 0);
-	special_rate     = scale_frames(get_config_float("Ship", "SpecialRate", 0));
-	special_sample   = 0;
-	special_recharge = 0;
-	special_low      = FALSE;
-
-	double raw_hotspot_rate = get_config_float("Ship", "HotspotRate", 0);
-	hotspot_rate  = scale_frames(raw_hotspot_rate);
-	hotspot_frame = 0;
-	turn_rate     = scale_turning(get_config_float("Ship", "TurnRate", 0));
-	turn_step     = 0.0;
-	speed_max     = scale_velocity(get_config_float("Ship", "SpeedMax", 0));
-	accel_rate    = scale_acceleration(get_config_float("Ship", "AccelRate", 0), raw_hotspot_rate);
-	mass          = (get_config_float("Ship", "Mass", 0));
-
-	thrust           = FALSE;
-	turn_left        = FALSE;
-	turn_right       = FALSE;
-	thrust_backwards = FALSE;
-	fire_weapon      = FALSE;
-	fire_special     = FALSE;
-	fire_altweapon   = FALSE;
-
-	spritePanel  = new SpaceSprite(*(data->spritePanel));
-	if (captain_name[0]) {
-		spritePanel->lock();
-		text_mode(-1);
-		textprintf_centre(
+  double raw_hotspot_rate = get_config_float("Ship", "HotspotRate", 0);
+  hotspot_rate  = scale_frames(raw_hotspot_rate);
+  hotspot_frame = 0;
+  turn_rate     = scale_turning(get_config_float("Ship", "TurnRate", 0));
+  turn_step     = 0.0;
+  speed_max     = scale_velocity(get_config_float("Ship", "SpeedMax", 0));
+  accel_rate    = scale_acceleration(get_config_float("Ship", "AccelRate", 0), raw_hotspot_rate);
+  mass          = (get_config_float("Ship", "Mass", 0));
+  
+  thrust           = FALSE;
+  turn_left        = FALSE;
+  turn_right       = FALSE;
+  thrust_backwards = FALSE;
+  fire_weapon      = FALSE;
+  fire_special     = FALSE;
+  fire_altweapon   = FALSE;
+  
+  spritePanel  = new SpaceSprite(*(data->spritePanel));
+  if (captain_name[0]) 
+    {
+      spritePanel->lock();
+      text_mode(-1);
+      textprintf_centre(
 			spritePanel->get_bitmap(0), 
-			videosystem.get_font(1), 
+			videosystem->get_font(1), 
 			30, 51, 
 			pallete_color[0], 
 			captain_name
 		);
-		spritePanel->unlock();
-	}
+      spritePanel->unlock();
+    }
+  
+  angle = floor(shipAngle / (PI2/64)) * (PI2/64);
+  sprite_index = get_index(angle);
 
-	angle = floor(shipAngle / (PI2/64)) * (PI2/64);
-	sprite_index = get_index(angle);
-
-	hashotspots = true;
+  hashotspots = true;
 }
 
-void Ship::death() {STACKTRACE
-	if (attributes & ATTRIB_NOTIFY_ON_DEATH) {
-		game->ship_died(this, NULL);
-		attributes &= ~ATTRIB_NOTIFY_ON_DEATH;
-	}
-	return;
+void Ship::death() 
+{
+  STACKTRACE;
+  if (attributes & ATTRIB_NOTIFY_ON_DEATH) 
+    {
+      game->ship_died(this, NULL);
+      attributes &= ~ATTRIB_NOTIFY_ON_DEATH;
+    }
+  return;
 }
 
-Ship::~Ship() {STACKTRACE
-	delete spritePanel;
+Ship::~Ship() 
+{
+  delete spritePanel;
 }
 
 double Ship::getCrew()
 {
+  STACKTRACE;
   return(crew);
 }
 
 double Ship::getBatt()
 {
+  STACKTRACE;
   return(batt);
 }
 
 RGB Ship::crewPanelColor(int k)
 {
+  STACKTRACE;
 	RGB c = {0,225,0};
 	return c;
 }
 
 RGB Ship::battPanelColor(int k)
 {
-	RGB c = {225,0,0};
-	return c;
+  STACKTRACE;
+  RGB c = {225,0,0};
+  return c;
 }
 
-void Ship::locate() {STACKTRACE
-	int tries = 0;
-	double mindist = 1000;
-	while (tries < 15) {
-		pos = random(map_size);
-		SpaceLocation *spacePlanet = nearest_planet();
-		if (!spacePlanet || (distance(spacePlanet) > mindist))
-			break;
-		if (tries < 10)
-			mindist *= 0.9;
-		else
-			mindist *= 0.5;
-	}
-	return;
+void Ship::locate() 
+{
+  STACKTRACE;
+  int tries = 0;
+  double mindist = 1000;
+  while (tries < 15) {
+    pos = random(map_size);
+    SpaceLocation *spacePlanet = nearest_planet();
+    if (!spacePlanet || (distance(spacePlanet) > mindist))
+      break;
+    if (tries < 10)
+      mindist *= 0.9;
+    else
+      mindist *= 0.5;
+  }
+  return;
 }
 
 void Ship::calculate()
-{STACKTRACE
+{
+  STACKTRACE;
+  
+  //added by Tau - start
+  if (exists() && death_counter >= 0) 
+    {
+      while(fabs(turn_step) > (PI2/64) / 2) 
+	{
+	  if(turn_step < 0.0) 
+	    {
+	      angle -= (PI2/64);
+	      turn_step += (PI2/64); 
+	    }
+	  else if(turn_step > 0.0) 
+	    {
+	      angle += (PI2/64);
+	      turn_step -= (PI2/64); 
+	    }
+	  if(angle < 0.0)
+	    angle += PI2;
+	  if(angle >= PI2)
+	    angle -= PI2;
+	}
+      
+      if (sprite->frames() > 64)
+	sprite_index = get_index(angle);
+      else
+	sprite_index = get_index(angle, PI/2, sprite->frames());
+      
+      
+      SpaceObject::calculate();
 
-//added by Tau - start
-	if (exists() && death_counter >= 0) {
-		while(fabs(turn_step) > (PI2/64) / 2) {
-			if(turn_step < 0.0) {
-				angle -= (PI2/64);
-				turn_step += (PI2/64); }
-			else
-				if(turn_step > 0.0) {
-					angle += (PI2/64);
-					turn_step -= (PI2/64); }
-			if(angle < 0.0)
-				angle += PI2;
-			if(angle >= PI2)
-				angle -= PI2;
-		}
-
-		// changed GEO - just to be sure you don't exceed #frames if #frames<64 (the assumed value here...).
-		// sprite_index = get_index(angle);
-		//sprite_index = get_index(angle, PI/2, sprite->frames());
-		// (geo) actually, this introduces a big bug if the ship has >64 frames in
-		// the ship sprite -- eg the tau mercury.
-		if (sprite->frames() > 64)
-			sprite_index = get_index(angle);
-		else
-			sprite_index = get_index(angle, PI/2, sprite->frames());
-
-
-		SpaceObject::calculate();
-
-		Animation *a;
-		int i, ff;
-		double vv = magnitude(vel);
-
-		death_explosion_counter -= frame_time;
-		while (death_explosion_counter <= 0) {
-			death_explosion_counter += 25;
-			for (i=0; i<2; i++) {
-				ff = random(25);
-				a = new Animation(this, pos, meleedata.xpl1Sprite,
-					ff, 40-ff, 25, DEPTH_EXPLOSIONS);
-				a->transparency = 1.0 / 4;
-				game->add(a);
-				a->accelerate(this, vel.angle(), vv, MAX_SPEED);
-				a->accelerate(this, random(PI2),
-					random(1.0)*scale_velocity(25)*sqrt((15+mass)/35),
-					MAX_SPEED);
-				a->collide_flag_anyone = a->collide_flag_sameship = a->collide_flag_sameteam = 0;
-			}
-		}
-
-		death_counter += frame_time;
-		if (death_counter > 700 * (15+mass)/35 || death_counter > 3000) //smaller ships will make smaller explosions ; GEO: but a real upper limit is also good to have
-			state = 0; //die already
-
-		return;
+      Animation *a;
+      int i, ff;
+      double vv = magnitude(vel);
+      
+      death_explosion_counter -= frame_time;
+      while (death_explosion_counter <= 0) 
+	{
+	  death_explosion_counter += 25;
+	  for (i=0; i<2; i++) 
+	    {
+	      ff = random(25);
+	      a = new Animation(this, pos, game->meleedata.xpl1Sprite,
+				ff, 40-ff, 25, DEPTH_EXPLOSIONS);
+	      a->transparency = 1.0 / 4;
+	      game->add(a);
+	      a->accelerate(this, vel.angle(), vv, MAX_SPEED);
+	      a->accelerate(this, random(PI2),
+			    random(1.0)*scale_velocity(25)*sqrt((15+mass)/35),
+			    MAX_SPEED);
+	      a->collide_flag_anyone = a->collide_flag_sameship = a->collide_flag_sameteam = 0;
+	    }
 	}
-//added by Tau - end
-
-	if (control) {
-		this->thrust           = 1&&(nextkeys & keyflag::thrust);
-		this->thrust_backwards = 1&&(nextkeys & keyflag::back);
-		this->turn_left        = 1&&(nextkeys & keyflag::left);
-		this->turn_right       = 1&&(nextkeys & keyflag::right);
-		this->fire_weapon      = 1&&(nextkeys & keyflag::fire);
-		this->fire_special     = 1&&(nextkeys & keyflag::special);
-		this->fire_altweapon   = 1&&(nextkeys & keyflag::altfire);
-		this->target_next      = 1&&(nextkeys & keyflag::next);
-		this->target_prev      = 1&&(nextkeys & keyflag::prev);
-		this->target_closest   = 1&&(nextkeys & keyflag::closest);
-        if (nextkeys & keyflag::suicide) {
-            crew  = 0;
-            play_sound((SAMPLE *)(melee[MELEE_BOOMSHIP].dat));
-
-            if (meleedata.xpl1Sprite) {
-                death_counter = 0;
-                death_explosion_counter = 0;
-                collide_flag_anyone = collide_flag_sameship = collide_flag_sameteam = 0;
+      
+      death_counter += frame_time;
+      //smaller ships will make smaller explosions ; GEO: but a real upper limit is also good to have
+      if (death_counter > 700 * (15+mass)/35 || death_counter > 3000) 
+	state = 0; //die already
+      
+      return;
+    }
+  //added by Tau - end
+  
+  if (control) 
+    {
+      this->thrust           = 1&&(nextkeys & keyflag::thrust);
+      this->thrust_backwards = 1&&(nextkeys & keyflag::back);
+      this->turn_left        = 1&&(nextkeys & keyflag::left);
+      this->turn_right       = 1&&(nextkeys & keyflag::right);
+      this->fire_weapon      = 1&&(nextkeys & keyflag::fire);
+      this->fire_special     = 1&&(nextkeys & keyflag::special);
+      this->fire_altweapon   = 1&&(nextkeys & keyflag::altfire);
+      this->target_next      = 1&&(nextkeys & keyflag::next);
+      this->target_prev      = 1&&(nextkeys & keyflag::prev);
+      this->target_closest   = 1&&(nextkeys & keyflag::closest);
+      if (nextkeys & keyflag::suicide) 
+	{
+	  crew  = 0;
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMSHIP_WAV.wav"));
+	  
+	  if (game->meleedata.xpl1Sprite) 
+	    {
+	      death_counter = 0;
+	      death_explosion_counter = 0;
+	      collide_flag_anyone = collide_flag_sameship = collide_flag_sameteam = 0;
+	    }
+	  else 
+	    {
+	      state = 0;
+	      game->add(new Animation(this, pos, game->meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS));
+	    }
+	  if (attributes & ATTRIB_NOTIFY_ON_DEATH) 
+	    {
+	      game->ship_died(this, NULL);
+	      attributes &= ~ATTRIB_NOTIFY_ON_DEATH;
             }
-            else {
-                state = 0;
-                game->add(new Animation(this, pos, meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS));
-            }
-            if (attributes & ATTRIB_NOTIFY_ON_DEATH) {
-                game->ship_died(this, NULL);
-                attributes &= ~ATTRIB_NOTIFY_ON_DEATH;
-            }
         }
-		this->nextkeys = control->keys;
+      this->nextkeys = control->keys;
+      
+      if (!control->exists()) 
+	control = NULL;
+    }
 
-
-        
-
-		if (!control->exists()) control = NULL;
+  if(batt < batt_max) 
+    {
+      recharge_step -= frame_time;
+      while(recharge_step < 0 && recharge_rate > 0)	// this loop never ends if there's no recharge
+	{
+	  batt += recharge_amount;
+	  if (batt > batt_max) batt = batt_max;
+	  recharge_step += recharge_rate;
 	}
-
-	if(batt < batt_max) {
-		recharge_step -= frame_time;
-		while(recharge_step < 0 && recharge_rate > 0)	// this loop never ends if there's no recharge
+    }
+  
+  if(weapon_recharge > 0)
+    weapon_recharge -= frame_time;
+  if(special_recharge > 0)
+    special_recharge -=  frame_time;
+  
+  int target_pressed_prev = target_pressed;
+  target_pressed = target_next || target_prev || target_closest;
+  
+  int i;
+  if (target_pressed && (!target_pressed_prev) && control) 
+    {
+      if (target_next) 
+	{
+	  if (control && targets->N) 
+	    {
+	      i = control->index;
+	      if (i < 0) i = 0;
+	      while (1) 
 		{
-			batt += recharge_amount;
-			if (batt > batt_max) batt = batt_max;
-			recharge_step += recharge_rate;
+		  i = (i + 1) % targets->N;
+		  if (control->valid_target(targets->item[i])) 
+		    {
+		      control->set_target(i);
+		      break;
+		    }
+		  if (control->index != -1) 
+		    {
+		      if (i == control->index) 
+			break;
+		    }
+		  else 
+		    {
+		      if (i == 0) 
+			break;
+		    }
 		}
+	    }				
 	}
-
-	if(weapon_recharge > 0)
-		weapon_recharge -= frame_time;
-	if(special_recharge > 0)
-		special_recharge -=  frame_time;
-
-	int target_pressed_prev = target_pressed;
-	target_pressed = target_next || target_prev || target_closest;
-
-	int i;
-	if (target_pressed && (!target_pressed_prev) && control) {
-		if (target_next) {
-			if (control && targets->N) {
-				i = control->index;
-				if (i < 0) i = 0;
-				while (1) {
-					i = (i + 1) % targets->N;
-					if (control->valid_target(targets->item[i])) {
-						control->set_target(i);
-						break;
-					}
-					if (control->index != -1) {
-						if (i == control->index) break;
-					}
-					else {
-						if (i == 0) break;
-					}
-				}
-			}				
+      else if (target_prev) 
+	{
+	  if (control && targets->N) 
+	    {
+	      i = control->index;
+	      if (i < 0) i = 0;
+	      while (1) 
+		{
+		  i = (i + targets->N - 1) % targets->N;
+		  if (control->valid_target(targets->item[i])) 
+		    {
+		      control->set_target(i);
+		      break;
+		    }
+		  if (control->index != -1) 
+		    {
+		      if (i == control->index)
+			break;
+		    }
+		  else 
+		    {
+		      if (i == 0) break;
+		    }
 		}
-		else if (target_prev) {
-			if (control && targets->N) {
-				i = control->index;
-				if (i < 0) i = 0;
-				while (1) {
-					i = (i + targets->N - 1) % targets->N;
-					if (control->valid_target(targets->item[i])) {
-						control->set_target(i);
-						break;
-					}
-					if (control->index != -1) {
-						if (i == control->index)
-							break;
-					}
-					else {
-						if (i == 0) break;
-					}
-				}
-			}				
+	    }				
+	}
+      else if (target_closest) 
+	{
+	  if (control && targets->N) 
+	    {
+	      int i, j = -1;
+	      double r = 99999;
+	      double d;
+	      for (i = 0; i < targets->N; i += 1) 
+		{
+		  if (control->valid_target(targets->item[i])) {
+		    d = distance(targets->item[i]);
+		    if (d < r) {
+		      r = d;
+		      j = i;
+		    }
+		  }
 		}
-		else if (target_closest) {
-			if (control && targets->N) {
-				int i, j = -1;
-				double r = 99999;
-				double d;
-				for (i = 0; i < targets->N; i += 1) {
-					if (control->valid_target(targets->item[i])) {
-						d = distance(targets->item[i]);
-						if (d < r) {
-							r = d;
-							j = i;
-						}
-					}
-				}
-				control->set_target(j);
-			}
-		}
+	      control->set_target(j);
+	    }
 	}
-
-	target_pressed = target_next | target_prev | target_closest;
-	if (control)
-		target = control->target;
-
-	calculate_turn_left();
-	calculate_turn_right();
-	calculate_thrust();
-	calculate_fire_weapon();
-	calculate_fire_special();
-
-
-	while(fabs(turn_step) > (PI2/64) / 2) {
-		if(turn_step < 0.0) {
-			angle -= (PI2/64);
-			turn_step += (PI2/64);
-		} else
-			if(turn_step > 0.0) {
-				angle += (PI2/64);
-				turn_step -= (PI2/64);
-			}
-
-		if(angle < 0.0) angle += PI2;
-		if(angle >= PI2) angle -= PI2;
+    }
+  
+  target_pressed = target_next | target_prev | target_closest;
+  if (control)
+    target = control->target;
+  
+  calculate_turn_left();
+  calculate_turn_right();
+  calculate_thrust();
+  calculate_fire_weapon();
+  calculate_fire_special();
+  
+  
+  while(fabs(turn_step) > (PI2/64) / 2) 
+    {
+      if(turn_step < 0.0) 
+	{
+	  angle -= (PI2/64);
+	  turn_step += (PI2/64);
+	} 
+      else if(turn_step > 0.0) 
+	{
+	  angle += (PI2/64);
+	  turn_step -= (PI2/64);
 	}
 
-	sprite_index = get_index(angle);
+      if(angle < 0.0) angle += PI2;
+      if(angle >= PI2) angle -= PI2;
+    }
 
-	// hotspots are too much a luxury to include in massive games (lots of objects)
-	if (hashotspots)
-		calculate_hotspots();
-
-	SpaceObject::calculate();
+  sprite_index = get_index(angle);
+  
+  // hotspots are too much a luxury to include in massive games (lots of objects)
+  if (hashotspots)
+    calculate_hotspots();
+  
+  SpaceObject::calculate();
 }
 
-int Ship::handle_fuel_sap(SpaceLocation *source, double normal) {STACKTRACE
+int Ship::handle_fuel_sap(SpaceLocation *source, double normal) 
+{
+  STACKTRACE;
+  if (death_counter >= 0) 
+    return 0; //added by Tau
 
-	if (death_counter >= 0) return 0; //added by Tau
+  batt -= normal;
+  
+  if(batt < 0) 
+    {
+      normal += batt;
+      batt = 0;
+    }
 
-	batt -= normal;
-
-	if(batt < 0) {
-		normal += batt;
-		batt = 0;
-	}
-
-	if(batt > batt_max) {
-		normal += batt_max - batt;
-		batt = batt_max;
-	}
-
-	return 1;
+  if(batt > batt_max) 
+    {
+      normal += batt_max - batt;
+      batt = batt_max;
+    }
+  
+  return 1;
 }
 
-double Ship::handle_speed_loss(SpaceLocation *source, double normal) {STACKTRACE
-	double speed_loss = normal;
-	if(speed_loss > 0.0) {
-
-
-		double sl = (30/(mass+30)) * speed_loss;
-		if (sl > 1)
-			tw_error("Speed loss too large\n(%f)", sl);
-
-		accel_rate *= 1 - sl * accel_rate / (accel_rate + scale_acceleration(2,4));
-		hotspot_rate = (int)(hotspot_rate / (1 - sl * accel_rate / (accel_rate + scale_acceleration(2,4)) ) );
-		speed_max *= 1 - sl * speed_max / (speed_max + scale_velocity(10));
-		turn_rate *=  1 - sl * turn_rate / (turn_rate + scale_turning(4));
-		speed_loss = 0;
-	}
-	return 1;
+double Ship::handle_speed_loss(SpaceLocation *source, double normal) 
+{
+  STACKTRACE;
+  double speed_loss = normal;
+  if(speed_loss > 0.0) 
+    {
+      double sl = (30/(mass+30)) * speed_loss;
+      if (sl > 1)
+	tw_error("Speed loss too large\n(%f)", sl);
+      
+      accel_rate *= 1 - sl * accel_rate / (accel_rate + scale_acceleration(2,4));
+      hotspot_rate = (int)(hotspot_rate / (1 - sl * accel_rate / (accel_rate + scale_acceleration(2,4)) ) );
+      speed_max *= 1 - sl * speed_max / (speed_max + scale_velocity(10));
+      turn_rate *=  1 - sl * turn_rate / (turn_rate + scale_turning(4));
+      speed_loss = 0;
+    }
+  return 1;
 }
 
-int Ship::handle_damage(SpaceLocation *source, double normal, double direct) {STACKTRACE
+int Ship::handle_damage(SpaceLocation *source, double normal, double direct) 
+{
+  STACKTRACE;
+  if (death_counter >= 0) 
+    return 0; //added by Tau
 
-	if (death_counter >= 0) return 0; //added by Tau
+  double total = normal + direct;
+  
+  crew -= total;
+  if(crew > crew_max) 
+    {
+      total += crew_max - crew;
+      crew = crew_max;
+    }
 
-	double total = normal + direct;
-
-	crew -= total;
-	if(crew > crew_max) {
-		total += crew_max - crew;
-		crew = crew_max;
+  if(crew <= 0) 
+    {
+      total += crew;
+      crew  = 0;
+      tw_sound->play_sound(data_full_path("sound/boom/BOOMSHIP_WAV.wav"));
+      if (game->meleedata.xpl1Sprite) 
+	{
+	  death_counter = 0;
+	  death_explosion_counter = 0;
+	  collide_flag_anyone = collide_flag_sameship = collide_flag_sameteam = 0;
 	}
-
-	if(crew <= 0) {
-		total += crew;
-		crew  = 0;
-		play_sound((SAMPLE *)(melee[MELEE_BOOMSHIP].dat));
-		//state = 0;
-//modified by Tau - start
-		if (meleedata.xpl1Sprite) {
-			death_counter = 0;
-			death_explosion_counter = 0;
-			collide_flag_anyone = collide_flag_sameship = collide_flag_sameteam = 0;
-		}
-		else {
-			state = 0;
-			game->add(new Animation(this, pos, meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS));
-		}
-		if (attributes & ATTRIB_NOTIFY_ON_DEATH) {
-			game->ship_died(this, source);
-			attributes &= ~ATTRIB_NOTIFY_ON_DEATH;
-		}
-
+      else 
+	{
+	  state = 0;
+	  game->add(new Animation(this, pos, game->meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS));
 	}
+      if (attributes & ATTRIB_NOTIFY_ON_DEATH) {
+	game->ship_died(this, source);
+	attributes &= ~ATTRIB_NOTIFY_ON_DEATH;
+      }
+      
+    }
 
-	return 1;
+  return 1;
 }
 
 void Ship::materialize() {
+  STACKTRACE;
 }
 
 
 void Ship::assigntarget(SpaceObject *otarget)
 {
+  STACKTRACE;
 	target = otarget;
 }
 
 
-void Ship::calculate_thrust() {STACKTRACE
+void Ship::calculate_thrust() {
+  STACKTRACE;
 	if (thrust)
 		accelerate_gravwhip(this, angle, accel_rate * frame_time, speed_max);
 	return;
 }
 
 void Ship::calculate_turn_left()
-{STACKTRACE
+{
+  STACKTRACE;
   if(turn_left)
 		turn_step -= turn_rate * frame_time;
 }
 
 void Ship::calculate_turn_right()
-{STACKTRACE
+{
+  STACKTRACE;
   if(turn_right)
 		turn_step += turn_rate * frame_time;
 }
 
-void Ship::calculate_fire_weapon() {STACKTRACE
+void Ship::calculate_fire_weapon() {
+  STACKTRACE;
 	weapon_low = FALSE;
 
 	if (fire_weapon) {
@@ -756,13 +827,17 @@
 		weapon_recharge += weapon_rate;
 
 		if (weapon_sample >= 0)
-			play_sound2(data->sampleWeapon[weapon_sample]);
+		  {
+		    tw_sound->stop_sound(data_full_path(data->sampleWeapon[weapon_sample]));
+		    tw_sound->play_sound(data_full_path(data->sampleWeapon[weapon_sample]));
+		  }
 	}
 	return;
 }
 
 void Ship::calculate_fire_special()
-{STACKTRACE
+{
+  STACKTRACE;
   special_low = FALSE;
 
   if(fire_special) {
@@ -781,33 +856,42 @@
     special_recharge += special_rate;
 
     if (special_sample >= 0)
-			play_sound2(data->sampleSpecial[special_sample]);
+      {
+	tw_sound->stop_sound(data_full_path(data->sampleSpecial[special_sample]));
+	tw_sound->play_sound(data_full_path(data->sampleSpecial[special_sample]));
+      }
   }
 }
 
-void Ship::calculate_hotspots() {STACKTRACE
-	if((thrust) && (hotspot_frame <= 0)) {
-		game->add(new Animation(this,
-			normal_pos() - unit_vector(angle) * size.x / 2.5,
-			meleedata.hotspotSprite, 0, HOTSPOT_FRAMES, time_ratio, DEPTH_HOTSPOTS));
-		hotspot_frame += hotspot_rate;
-	}
-	if (hotspot_frame > 0)
-		hotspot_frame -= frame_time;
-	return;
+void Ship::calculate_hotspots() 
+{
+  STACKTRACE;
+  if((thrust) && (hotspot_frame <= 0)) 
+    {
+      game->add(new Animation(this,
+			      normal_pos() - unit_vector(angle) * size.x / 2.5,
+			      game->meleedata.hotspotSprite, 0, HOTSPOT_FRAMES, time_ratio, DEPTH_HOTSPOTS));
+      hotspot_frame += hotspot_rate;
+    }
+  if (hotspot_frame > 0)
+    hotspot_frame -= frame_time;
+  return;
 }
 
 int Ship::activate_weapon()
 {
+  STACKTRACE;
   return(TRUE);
 }
 
 int Ship::activate_special()
 {
+  STACKTRACE;
   return(TRUE);
 }
 
 void Ship::animate(Frame *frame) {
+  STACKTRACE;
 	SpaceObject::animate(frame);
 }
 
@@ -818,6 +902,7 @@
 
 ShipType *Ship::get_shiptype()
 {
+  STACKTRACE;
 	return type;
 }
 
@@ -838,7 +923,8 @@
 	phaser_step_position(0),
 	phaser_steps(steps),
 	phaser_step_size(step_size)
-{STACKTRACE
+{
+  STACKTRACE;
 	layer = LAYER_HOTSPOTS;
 	set_depth(DEPTH_HOTSPOTS);
 	collide_flag_anyone = 0;
@@ -855,12 +941,14 @@
 }
 
 void Phaser::animate(Frame *space) {
+  STACKTRACE;
 	sprite->animate_character(pos, 
 		sprite_index, pallete_color[colors[color_index]], space);
 	return;
 }
 
-void Phaser::calculate() {STACKTRACE
+void Phaser::calculate() {
+  STACKTRACE;
 	if (!exists())
 		return;
 	frame_step -= frame_time;
@@ -891,7 +979,8 @@
 	SpaceObject::calculate();
 }
 
-SpaceLocation *Ship::get_ship_phaser() {STACKTRACE
+SpaceLocation *Ship::get_ship_phaser() {
+  STACKTRACE;
 	return new Phaser(this,
 		pos - unit_vector(angle ) * PHASE_MAX * size.x,
 		unit_vector(angle ) * PHASE_MAX * size.x,

Modified: branches/multiplayer-branch/source/melee/mship.h
===================================================================
--- branches/multiplayer-branch/source/melee/mship.h	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mship.h	2004-09-28 19:53:03 UTC (rev 71)
@@ -23,50 +23,52 @@
 
 typedef short KeyCode;
 
-struct keyflag {
-	enum { 
-		left       =	(1<<0),
-		right      =	(1<<1),
-		thrust     =	(1<<2),
-		back       =	(1<<3),
-		fire       =	(1<<4),
-		special    =	(1<<5),
-		altfire    =	(1<<6),
-		next       =	(1<<7),
-		prev       =	(1<<8),
-		closest    =	(1<<9),
-		extra1     =   (1<<10),
-		extra2     =   (1<<11),
-		extra3     =   (1<<12),
-		extra4     =   (1<<13),
-		extra5     =   (1<<14),
-		suicide    =   (1<<15),
-		};
-	};
+struct keyflag 
+{
+  enum { 
+    left       =	(1<<0),
+    right      =	(1<<1),
+    thrust     =	(1<<2),
+    back       =	(1<<3),
+    fire       =	(1<<4),
+    special    =	(1<<5),
+    altfire    =	(1<<6),
+    next       =	(1<<7),
+    prev       =	(1<<8),
+    closest    =	(1<<9),
+    extra1     =   (1<<10),
+    extra2     =   (1<<11),
+    extra3     =   (1<<12),
+    extra4     =   (1<<13),
+    extra5     =   (1<<14),
+    suicide    =   (1<<15),
+  };
+};
 
-class Phaser : public SpaceObject {
-	protected:
-	Vector2 rel_pos;
-	Ship *ship;
-	int sprite_index;
-	int *colors;
-	int num_colors;
-	int color_index;
-	int frame_size;
-	int frame_step;
-	int phaser_step_position;
-	int phaser_steps;
-	int phaser_step_size;
+class Phaser : public SpaceObject 
+{
+ protected:
+  Vector2 rel_pos;
+  Ship *ship;
+  int sprite_index;
+  int *colors;
+  int num_colors;
+  int color_index;
+  int frame_size;
+  int frame_step;
+  int phaser_step_position;
+  int phaser_steps;
+  int phaser_step_size;
+  
+ public:
+  Phaser::Phaser(SpaceLocation *creator, Vector2 pos, Vector2 rel_pos, 
+		 Ship *ship, SpaceSprite *sprite, int osprite_index, int *ocolors, 
+		 int onum_colors, int ofsize, int steps, int step_time) ;
+  
+  virtual void animate(Frame *space);
+  virtual void calculate();
+};
 
-	public:
-	Phaser::Phaser(SpaceLocation *creator, Vector2 pos, Vector2 rel_pos, 
-		Ship *ship, SpaceSprite *sprite, int osprite_index, int *ocolors, 
-		int onum_colors, int ofsize, int steps, int step_time) ;
-
-	virtual void animate(Frame *space);
-	virtual void calculate();
-	};
-
 /** the classification of where a given ship comes from */
 enum ShipOrigin { 
     SHIP_ORIGIN_NONE = 0, /**< None, no classification given*/
@@ -76,107 +78,108 @@
 };
 
 /// \brief Exactly what is sounds like
-class Ship : public SpaceObject {
-	protected:
+class Ship : public SpaceObject 
+{
+ protected:
+  
+  int hotspot_frame;
+  int recharge_step;
+  int weapon_recharge;
+  int weapon_low;
+  int special_recharge;
+  int special_low;
+  
+  virtual void calculate_thrust();
+  virtual void calculate_turn_left();
+  virtual void calculate_turn_right();
+  virtual void calculate_fire_weapon();
+  virtual void calculate_fire_special();
+  virtual void calculate_hotspots();
 
-	int hotspot_frame;
-	int recharge_step;
-	int weapon_recharge;
-	int weapon_low;
-	int special_recharge;
-	int special_low;
-
-	virtual void calculate_thrust();
-	virtual void calculate_turn_left();
-	virtual void calculate_turn_right();
-	virtual void calculate_fire_weapon();
-	virtual void calculate_fire_special();
-	virtual void calculate_hotspots();
-
-	virtual int activate_weapon();
-	virtual int activate_special();
-
-	virtual double get_angle_ex() const; // stupid helper for camera
-
-	public:
-	ShipType *type;
-	virtual ShipType *get_shiptype();
-
-	ShipClass *code;
-
-	int death_counter;
-	int death_explosion_counter;
-
-	bool hashotspots;
-	virtual void assigntarget(SpaceObject *otarget);
-
-	virtual void materialize();
-	double crew;
-	double crew_max;
-	double batt;
-	double batt_max;
-	double turn_rate;
-	double turn_step;
-	double speed_max;
-	double accel_rate;
-	int    recharge_amount;
-	int    recharge_rate;
-	int    weapon_drain;
-	int    weapon_rate;
-	int    weapon_sample;
-	int    special_drain;
-	int    special_rate;
-	int    special_sample;
-	int    hotspot_rate;
-	char   captain_name[16];
-
-	SpaceSprite *spritePanel;
-
-	int update_panel;
-
-	KeyCode nextkeys;
-
-	char thrust;
-	char thrust_backwards;
-	char turn_left;
-	char turn_right;
-	char fire_weapon;
-	char fire_special;
-	char fire_altweapon;
-	char target_next;
-	char target_prev;
-	char target_closest;
-
-	char target_pressed;
-	Control *control;
-
-	friend class ShipPanel;
-
-	Ship(SpaceLocation *creator, Vector2 opos, double shipAngle, 
-			SpaceSprite *osprite) ;
-	Ship(Vector2 opos, double shipAngle, ShipData *shipData, 
-			unsigned int code);
-	virtual SpaceLocation *get_ship_phaser() ;
-	virtual ~Ship();
-	virtual void death();
-
-
-	virtual double getCrew();
-	virtual double getBatt();
-
-	virtual RGB crewPanelColor(int k = 0);
-	virtual RGB battPanelColor(int k = 0);
-	virtual bool custom_panel_update(BITMAP *panel, int display_type) {return false;};
-
-
-	void locate();
-
-	void calculate();
-	virtual int handle_damage(SpaceLocation *source, double normal, double direct = 0);
-	virtual int handle_fuel_sap(SpaceLocation *source, double normal);
-	virtual double handle_speed_loss(SpaceLocation *source, double normal);
-
-	virtual void animate(Frame *frame);
+  virtual int activate_weapon();
+  virtual int activate_special();
+  
+  virtual double get_angle_ex() const; ///< stupid helper for camera
+  
+ public:
+  ShipType *type;
+  virtual ShipType *get_shiptype();
+  
+  ShipClass *code;
+  
+  int death_counter;
+  int death_explosion_counter;
+  
+  bool hashotspots;
+  virtual void assigntarget(SpaceObject *otarget);
+  
+  virtual void materialize();
+  double crew;
+  double crew_max;
+  double batt;
+  double batt_max;
+  double turn_rate;
+  double turn_step;
+  double speed_max;
+  double accel_rate;
+  int    recharge_amount;
+  int    recharge_rate;
+  int    weapon_drain;
+  int    weapon_rate;
+  int    weapon_sample;
+  int    special_drain;
+  int    special_rate;
+  int    special_sample;
+  int    hotspot_rate;
+  char   captain_name[16];
+  
+  SpaceSprite *spritePanel;
+  
+  int update_panel;
+  
+  KeyCode nextkeys;
+  
+  char thrust;
+  char thrust_backwards;
+  char turn_left;
+  char turn_right;
+  char fire_weapon;
+  char fire_special;
+  char fire_altweapon;
+  char target_next;
+  char target_prev;
+  char target_closest;
+  
+  char target_pressed;
+  Control *control;
+  
+  friend class ShipPanel;
+  
+  Ship(SpaceLocation *creator, Vector2 opos, double shipAngle, 
+       SpaceSprite *osprite) ;
+  Ship(Vector2 opos, double shipAngle, ShipData *shipData, 
+       unsigned int code);
+  virtual SpaceLocation *get_ship_phaser() ;
+  virtual ~Ship();
+  virtual void death();
+  
+  
+  virtual double getCrew();
+  virtual double getBatt();
+  
+  virtual RGB crewPanelColor(int k = 0);
+  virtual RGB battPanelColor(int k = 0);
+  virtual bool custom_panel_update(BITMAP *panel, int display_type) {return false;};
+  
+  
+  void locate();
+  
+  void calculate();
+  virtual int handle_damage(SpaceLocation *source, double normal, double direct = 0);
+  virtual int handle_fuel_sap(SpaceLocation *source, double normal);
+  virtual double handle_speed_loss(SpaceLocation *source, double normal);
+  
+  virtual void animate(Frame *frame);
 };
 
 

Modified: branches/multiplayer-branch/source/melee/mshot.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mshot.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mshot.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -15,15 +15,16 @@
 GNU General Public License for more details.
 */
 
+#include "util/sound.h"
 #include <allegro.h>
 
 #include "melee.h"
-REGISTER_FILE
 #include "id.h"
 #include "mgame.h"
 #include "mshot.h"
 #include "mship.h"
 #include "manim.h"
+#include "scp.h"
 
 // Define shot spark
 
@@ -32,16 +33,16 @@
 	SpaceSprite *osprite, double relativity) 
 	:
   SpaceObject(creator, opos->normal_pos(), 
-	  oangle, osprite),
+	      oangle, osprite),
   v(ov),
-  d(0.0),
+	d(0.0),
   range(orange),
   armour(oarmour),
-  explosionSprite(meleedata.sparkSprite),
-  explosionSample(NULL),
+  explosionSprite(game->meleedata.sparkSprite),
   explosionFrameCount(SPARK_FRAMES),
   explosionFrameSize(scale_frames(0))
 {
+  STACKTRACE;
 	layer = LAYER_SHOTS;
 	set_depth(DEPTH_SHOTS);
 	attributes |= ATTRIB_SHOT;
@@ -62,6 +63,7 @@
 }
 
 void Shot::calculate() {
+  STACKTRACE;
 	SpaceObject::calculate();
 
 	if (!(ship && ship->exists()))
@@ -76,11 +78,13 @@
 }
 
 void Shot::animate(Frame *space) {
+  STACKTRACE;
   SpaceObject::animate(space);
   return;
 }
 
 int Shot::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	if (!exists()) return 0;
 	if ((normal > 0) || (direct > 0)) {
 		armour -= normal;
@@ -97,6 +101,7 @@
 }
 
 void Shot::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if (!other->exists()) return;
 	damage(other, damage_factor);
 	//if (!other->isShot()) state = 0;
@@ -109,35 +114,62 @@
 }
 
 void Shot::death() {
-/*	animateExplosion();
-	soundExplosion(); */
+  STACKTRACE;
 }
 
 void Shot::animateExplosion() {
+  STACKTRACE;
 	game->add(new Animation(this, normal_pos(),
 			explosionSprite, 0, explosionFrameCount,
 			explosionFrameSize, DEPTH_EXPLOSIONS));
 	return;
 }
 
-void Shot::soundExplosion() {
-	if(explosionSample) {
-		play_sound2(explosionSample);
+void Shot::soundExplosion() 
+{
+  STACKTRACE;
+  if(!explosionSample.empty()) 
+    {
+      tw_sound->play_sound(data_full_path(explosionSample));
+    }
+  else if(damage_factor > 0) 
+    {
+      int i = iround_down(damage_factor / 2);
+      if(i >= BOOM_SAMPLES) 
+	i = BOOM_SAMPLES - 1;
+      
+      // temporary code
+      switch(i)
+	{
+	case 0:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+	  break;
+	case 1:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+	  break;
+	case 2:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+	  break;
+	case 3:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+	  break;
+	default:
+	  {
+	    tw_error("Unknown BOOM sound");
+	  }
 	}
-	else if(damage_factor > 0) {
-		int i = iround_down(damage_factor / 2);
-		if(i >= BOOM_SAMPLES) i = BOOM_SAMPLES - 1;
-		play_sound((SAMPLE *)(melee[MELEE_BOOM + i].dat));
-	}
-	return;
+    }
+  return;
 }
 
 void Shot::stop() {
+  STACKTRACE;
 	vel = Vector2(0,0);
 	return;
 }
 
 void Shot::destroy() {
+  STACKTRACE;
 	state = 0;
 	return;
 }
@@ -152,6 +184,7 @@
 }
 
 int Shot::isHomingMissile() {
+  STACKTRACE;
 	return ((id & BASE_MASK3) == SPACE_HOMING_MISSILE);
 }
 
@@ -164,9 +197,11 @@
 	frame_size(ofsize),
 	frame_step(ofsize)
 {
+  STACKTRACE;
 }
 
 void AnimatedShot::calculate() {
+  STACKTRACE;
 	Shot::calculate();
 	frame_step -= frame_time;
 	while (frame_step < 0) {
@@ -183,6 +218,7 @@
 :
 	Shot(creator, rpos, oangle, ov, odamage, orange, oarmour, opos, osprite, relativity)
 {
+  STACKTRACE;
 	sprite_index = get_index(angle);
 }
 
@@ -200,11 +236,13 @@
 	turn_rate(otrate),
 	turn_step(0.0)
 {
+  STACKTRACE;
 	target = otarget;
 	id = SPACE_HOMING_MISSILE;
 }
 
 void HomingMissile::calculate() {
+  STACKTRACE;
 	Missile::calculate();
 	if (target && !target->isInvisible()) {
 		double d_a = normalize(trajectory_angle(target) - (angle + turn_step), PI2);
@@ -234,6 +272,7 @@
 }
 
 void HomingMissile::animate(Frame *space) {
+  STACKTRACE;
 	int old_sprite_index = sprite_index;
 	Vector2 old_vel = vel;
 
@@ -270,6 +309,7 @@
   rel_pos(rpos),
   sinc_angle(osinc_angle)
 {
+  STACKTRACE;
 
 // angle conventions fucked up??
 	rel_pos.x *= -1;
@@ -297,6 +337,7 @@
 
 
 void Laser::calculate() {
+  STACKTRACE;
 	if((frame < frame_count) && (lpos->exists())) {
 		pos = lpos->normal_pos() + rotate(rel_pos, lpos->get_angle() - PI/2);
 		vel = lpos->get_vel();
@@ -313,6 +354,7 @@
   Laser(creator, lsource->trajectory_angle(ltarget), lcolor, lsource->distance(ltarget), ldamage, lfcount, lsource, rel_pos),
   target(ltarget)
 {
+  STACKTRACE;
 	collide_flag_anyone = bit(target->layer);
 	collide_flag_sameteam = bit(target->layer);
 	collide_flag_sameship = bit(target->layer);
@@ -324,11 +366,13 @@
 }
 
 int PointLaser::canCollide(SpaceObject *other) {
+  STACKTRACE;
 	if (other != target) return false;
 	return Laser::canCollide(other);
 }
 
 void PointLaser::calculate() {
+  STACKTRACE;
 	double alpha;
 	alpha = (lpos->get_angle());
 	Laser::calculate();

Modified: branches/multiplayer-branch/source/melee/mshot.h
===================================================================
--- branches/multiplayer-branch/source/melee/mshot.h	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mshot.h	2004-09-28 19:53:03 UTC (rev 71)
@@ -22,53 +22,55 @@
 #include "mgame.h"
 
 /// \brief A bullet with a range
-class Shot : public SpaceObject {
-	public:
-	double v;
-	double d;
-	double range;
-	double armour;
+class Shot : public SpaceObject 
+{
+ public:
+  double v;
+  double d;
+  double range;
+  double armour;
   
-	SpaceSprite *explosionSprite;
-	SAMPLE      *explosionSample;
-	int          explosionFrameCount;
-	int          explosionFrameSize;
+  SpaceSprite *explosionSprite;
+  std::string  explosionSample;
+  int          explosionFrameCount;
+  int          explosionFrameSize;
+  
+  Shot(SpaceLocation *creator, Vector2 rpos, double oangle, double ov, double odamage,
+       double orange, double oarmour, SpaceLocation *opos, SpaceSprite *osprite, double relativity = game->shot_relativity);
+  
+  virtual void animate(Frame *space);
+  
+  virtual void calculate();
+  virtual int handle_damage(SpaceLocation *source, double normal, double direct);
+  virtual void inflict_damage(SpaceObject *other);
+  virtual void death();
+  
+  virtual void animateExplosion();
+  virtual void soundExplosion();
+  
+  void stop();
+  void destroy();
+  
+  virtual void changeDirection(double oangle);
+  int isHomingMissile();
+};
 
-	Shot(SpaceLocation *creator, Vector2 rpos, double oangle, double ov, double odamage,
-			double orange, double oarmour, SpaceLocation *opos, SpaceSprite *osprite, double relativity = game->shot_relativity);
-
-	virtual void animate(Frame *space);
-
-	virtual void calculate();
-	virtual int handle_damage(SpaceLocation *source, double normal, double direct);
-	virtual void inflict_damage(SpaceObject *other);
-	virtual void death();
-
-	virtual void animateExplosion();
-	virtual void soundExplosion();
-
-	void stop();
-	void destroy();
-
-	virtual void changeDirection(double oangle);
-	int isHomingMissile();
-	};
-
 /// \brief A shot that uses a sequence of images over time
-class AnimatedShot : public Shot {
-	protected:
-	int frame_count;
-	int frame_size;
-	int frame_step;
+class AnimatedShot : public Shot 
+{
+ protected:
+  int frame_count;
+  int frame_size;
+  int frame_step;
+  
+ public:
+  AnimatedShot(SpaceLocation *creator, Vector2 rpos, double oangle, 
+	       double ov, double odamage, double orange, double oarmour, SpaceLocation *opos,
+	       SpaceSprite *osprite, int ofcount, int ofsize, double relativity = game->shot_relativity);
+  
+  virtual void calculate();
+};
 
-	public:
-	AnimatedShot(SpaceLocation *creator, Vector2 rpos, double oangle, 
-			double ov, double odamage, double orange, double oarmour, SpaceLocation *opos,
-			SpaceSprite *osprite, int ofcount, int ofsize, double relativity = game->shot_relativity);
-
-	virtual void calculate();
-	};
-
 /// \brief A shot that uses an image depending upon which angle it's pointing
 class Missile : public Shot {
 	public:

Modified: branches/multiplayer-branch/source/melee/mshpdata.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mshpdata.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mshpdata.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,8 +16,6 @@
 */
 
 
-#include <stdio.h>
-#include <string.h>
 #include <allegro.h>
 #ifdef WIN32
 #include <winalleg.h>
@@ -27,7 +25,6 @@
 #include <string>
 
 #include "melee.h"
-REGISTER_FILE
 #include "util/aastr.h"
 #include "other/twconfig.h"
 
@@ -45,307 +42,332 @@
 typedef std::map<std::string, ShipData*> ShipDataMap;
 ShipDataMap shipdatas;
 
-ShipData *shipdata ( const char *file ) {
-	if (!file) return NULL;
+/// Allocate ship data resources, or return already loaded ones
+ShipData *shipdata ( std::string inifile ) 
+{
+  if ( inifile.empty()) 
+    return NULL;
 	
-	ShipDataMap::iterator shp = shipdatas.find(file);
-	if(shp!=shipdatas.end())
-		return (*shp).second;
-
-	if (!exists(file)) return NULL;
-	ShipData *data = new ShipData(file);
-	shipdatas[file] = data;
-	return data;
+  ShipDataMap::iterator shp = shipdatas.find(inifile);
+  if(shp!=shipdatas.end())
+    return (*shp).second;
+  
+  ShipData *data = new ShipData( inifile);
+  shipdatas[inifile] = data;
+  return data;
 }
-void save_spacesprite2(SpaceSprite *ss, const char *spritename, const char *destination, const char *extension) {
-	int i;
-	char buf[512];
 
-	if (ss->frames() != 64)
-		tw_error("save_spacesprite2 - error");
-
-	BITMAP *tmp = create_bitmap(int(ss->width() * 8), int(ss->height() * 8));
-	for (i = 0; i < ss->frames(); i += 1) {
-		blit(ss->get_bitmap(i), tmp, 0, 0, (i&7) * (int)ss->width(), int((i/8) * ss->height()), (int)ss->width(), (int)ss->height());
-		sprintf(buf, "%s%i.%s", spritename, i, extension);
-		save_bitmap(buf, tmp, NULL);
-	}
-	return;
+void save_spacesprite2(SpaceSprite *ss, const char *spritename, 
+		       const char *destination, const char *extension) 
+{
+  int i;
+  char buf[512];
+  
+  if (ss->frames() != 64)
+    tw_error("save_spacesprite2 - error");
+  
+  BITMAP *tmp = create_bitmap(int(ss->width() * 8), int(ss->height() * 8));
+  for (i = 0; i < ss->frames(); i += 1) 
+    {
+      blit(ss->get_bitmap(i), tmp, 0, 0, (i&7) * (int)ss->width(), 
+	   int((i/8) * ss->height()), (int)ss->width(), (int)ss->height());
+      sprintf(buf, "%s%i.%s", spritename, i, extension);
+      save_bitmap(buf, tmp, NULL);
+    }
+  return;
 }
 
-void save_spacesprite(SpaceSprite *ss, const char *spritename, const char *destination, const char *extension) {
-	int i;
-	char buf[512];
-
-	if (!ss)
-		return;
-
-	if (ss->frames()) {
-		for (i = 0; i < ss->frames(); i += 1) {
-			if (strchr(extension, '.')) {
-				sprintf(buf, "tmp/%s%03d%s", spritename, i, extension);
-			}
-			else {
-				sprintf(buf, "tmp/%s%03d.bmp", spritename, i);
-			}
-
-			save_bitmap(buf, ss->get_bitmap(i), NULL);
-		}
-
+void save_spacesprite(SpaceSprite *ss, const char *spritename, 
+		      const char *destination, const char *extension) 
+{
+  int i;
+  char buf[512];
+  
+  if (!ss)
+    return;
+  
+  if (ss->frames()) 
+    {
+      for (i = 0; i < ss->frames(); i += 1) 
+	{
+	  if (strchr(extension, '.')) 
+	    {
+	      sprintf(buf, "tmp/%s%03d%s", spritename, i, extension);
+	    }
+	  else 
+	    {
+	      sprintf(buf, "tmp/%s%03d.bmp", spritename, i);
+	    }
+	  
+	  save_bitmap(buf, ss->get_bitmap(i), NULL);
 	}
-
-	sprintf(buf, "tmp/%s.ini", spritename);
-	tw_set_config_file(buf);
-	set_config_string("Main", "Type", "SpaceSprite");
-	set_config_int("SpaceSprite", "Number", (int)ss->frames());
-	set_config_int("SpaceSprite", "Width", (int)ss->width());
-	set_config_int("SpaceSprite", "Height", (int)ss->height());
-	set_config_string("SpaceSprite", "SubType", "Normal");
-	set_config_string("SpaceSprite", "Extension", extension);
-	chdir("tmp");
-	sprintf(buf, "dat ../ships/%s.dat -k -a *", destination);
-//	system(buf);
-	sprintf(buf, "move * ..\\ships\\%s", destination);
-	system(buf);
-	chdir("..");
-	return;
+      
+    }
+  
+  sprintf(buf, "tmp/%s.ini", spritename);
+  tw_set_config_file(buf);
+  set_config_string("Main", "Type", "SpaceSprite");
+  set_config_int("SpaceSprite", "Number", (int)ss->frames());
+  set_config_int("SpaceSprite", "Width", (int)ss->width());
+  set_config_int("SpaceSprite", "Height", (int)ss->height());
+  set_config_string("SpaceSprite", "SubType", "Normal");
+  set_config_string("SpaceSprite", "Extension", extension);
+  chdir("tmp");
+  sprintf(buf, "dat ../ships/%s.dat -k -a *", destination);
+  sprintf(buf, "move * ..\\ships\\%s", destination);
+  system(buf);
+  chdir("..");
+  return;
 }
 
-void save_samples(SpaceSprite *ss, const char *spritename, const char *destination, const char *extension) 
+void ShipData::lock() 
 {
+  STACKTRACE;
+  if (references == 0) 
+    {
+      push_config_state();//can screw up badly if an error occurs while loading...
+      load();
+      pop_config_state();
+    }
+  references += 1;
 }
 
-void ShipData::lock() {
-	if (references == 0) {
-		push_config_state();//can screw up badly if an error occurs while loading...
-		load();
-		pop_config_state();
-	}
-	references += 1;
+void ShipData::unlock() 
+{
+  STACKTRACE;
+  references -= 1;
+  if ((references == 0) && auto_unload) 
+    {
+      unload();
+    }
 }
 
-void ShipData::unlock() {
-	references -= 1;
-	if ((references == 0) && auto_unload) {
-		unload();
-	}
-}
+void ShipData::unload() 
+{
+  STACKTRACE;
+  if (status != LOADED_FULL) 
+    return;
 
-void unload_all_ship_data() {
+  if (spriteShip) 
+    {
+      delete spriteShip;
+      spriteShip = NULL;
+    }
+  if (spriteWeapon) 
+    {
+      delete spriteWeapon;
+      spriteWeapon = NULL;
+    }
+  if (spriteWeaponExplosion) 
+    {
+      delete spriteWeaponExplosion;
+      spriteWeaponExplosion = NULL;
+    }
+  if (spriteSpecial) 
+    {
+      delete spriteSpecial;
+      spriteSpecial = NULL;
+    }
+  if (spriteSpecialExplosion) 
+    {
+      delete spriteSpecialExplosion;
+      spriteSpecialExplosion = NULL;
+    }
+  if (spriteExtra) 
+    {
+      delete spriteExtra;
+      spriteExtra = NULL;
+    }
+  
+  if (spritePanel) 
+    {
+      delete spritePanel;
+      spritePanel = NULL;
+    }
+  
+  if (num_more_sprites) 
+    {
+      int i;
+      for (i = 0; i < num_more_sprites; i += 1) 
+	delete more_sprites[i];
+      delete[] more_sprites;
+      more_sprites = NULL;
+      num_more_sprites = 0;
+    }
+  
+  status = LOADED_NONE;
 }
-void unload_unused_ship_data() {
-}
 
-void ShipData::unload() {
-
-	if (status != LOADED_FULL) return;
-
-	if (spriteShip) {
-		delete spriteShip;
-		spriteShip = NULL;
-	}
-	if (spriteWeapon) {
-		delete spriteWeapon;
-		spriteWeapon = NULL;
-	}
-	if (spriteWeaponExplosion) {
-		delete spriteWeaponExplosion;
-		spriteWeaponExplosion = NULL;
-	}
-	if (spriteSpecial) {
-		delete spriteSpecial;
-		spriteSpecial = NULL;
-	}
-	if (spriteSpecialExplosion) {
-		delete spriteSpecialExplosion;
-		spriteSpecialExplosion = NULL;
-	}
-	if (spriteExtra) {
-		delete spriteExtra;
-		spriteExtra = NULL;
-	}
-
-	if (spritePanel) {
-		delete spritePanel;
-		spritePanel = NULL;
-	}
-
-	if (num_more_sprites) {
-		int i;
-		for (i = 0; i < num_more_sprites; i += 1) delete more_sprites[i];
-		delete[] more_sprites;
-		more_sprites = NULL;
-		num_more_sprites = 0;
-	}
-
-	unload_datafile(data);
-
-	status = LOADED_NONE;
-}
-
-ShipData::ShipData(const char *filename) :
-	data(NULL),
-	spriteShip(NULL),
-	spriteWeapon(NULL),
-	spriteWeaponExplosion(NULL),
-	spriteSpecial(NULL),
-	spriteSpecialExplosion(NULL),
-	spriteExtra(NULL),
-	spriteExtraExplosion(NULL),
-	num_weapon_samples(0),
-	sampleWeapon(NULL),
-	num_special_samples(0),
-	sampleSpecial(NULL),
-	num_extra_samples(0),
-	sampleExtra(NULL),
-	moduleVictory(NULL)
+ShipData::ShipData( std::string inifile) :
+  spriteShip(NULL),
+  spriteWeapon(NULL),
+  spriteWeaponExplosion(NULL),
+  spriteSpecial(NULL),
+  spriteSpecialExplosion(NULL),
+  spriteExtra(NULL),
+  spriteExtraExplosion(NULL)
 {
-	file = strdup(filename);
-	references = 0;
-	status = LOADED_NONE;
+  STACKTRACE;
+  ini  = inifile;
+  references = 0;
+  status = LOADED_NONE;
 }
 
 
-SpaceSprite *load_sprite(const char *string, DATAFILE *data, int *index) 
+SpaceSprite *load_sprite(const char *string ) 
 {
-	char buffy[512]; buffy[0] = 0;
-	char *cp = buffy;
-	char *tp;
-	int argc, i;
-	int rotations = 1;
-	char **argv = get_config_argv("Objects", string, &argc);
-	int count = 0;
-	if (!argc) return NULL;
-	count = atoi(argv[0]);
-	if (!count) return NULL;
-	tp = strchr(argv[0], 'r');
-	for (i = 1; i < argc; i += 1) {
-		if ((argv[i][0] == '-') || (argv[i][0] == '+')) {
-			cp += sprintf(cp, "%s ", argv[i]);
-		}
-		else if (argv[i][0] == 'r') tp = argv[i];
-		else {tw_error("load_sprite - unrecognized modifiers '%s'", argv[i]);}
-	}
-	if (tp) {
-		rotations = atoi(tp+1);
-		if (rotations == 0) rotations = 64;
-	}
-	SpaceSprite *sprite = NULL;
-	int attrib = string_to_sprite_attributes(buffy);
-	sprite = new SpaceSprite(&data[*index], count, attrib, rotations);
-	for (i = 0; i < count; i += 1) {
-		destroy_rle_sprite((RLE_SPRITE*)data[(*index)+i].dat);
-		data[(*index)+i].dat = NULL;
-		// brutal hack to free up the memory
-	}
-	*index += count;
-	return sprite;
+  char buffy[512]; buffy[0] = 0;
+  char *cp = buffy;
+  char *tp;
+  int argc, i;
+  int rotations = 1;
+  char **argv = get_config_argv("Objects", string, &argc);
+  int count = 0;
+  if (!argc) 
+    return NULL;
+  count = atoi(argv[0]);
+  if (!count) 
+    return NULL;
+  tp = strchr(argv[0], 'r');
+  for (i = 1; i < argc; i += 1) {
+    if ((argv[i][0] == '-') || (argv[i][0] == '+')) {
+      cp += sprintf(cp, "%s ", argv[i]);
+    }
+    else if (argv[i][0] == 'r') tp = argv[i];
+    else {tw_error("load_sprite - unrecognized modifiers '%s'", argv[i]);}
+  }
+  if (tp) 
+    {
+      rotations = atoi(tp+1);
+      if (rotations == 0) 
+	rotations = 64;
+    }
+  SpaceSprite *sprite = NULL;
+  int attrib = string_to_sprite_attributes(buffy);
+  
+  std::vector<std::string> tmpVec;
+
+  for(i = 0; i < count; i++) 
+    {
+      char tmp[200] = {0};
+      sprintf(tmp, "%d", i);
+      tmpVec.push_back( get_config_string("Graphic", 
+					  (std::string(string) + tmp).c_str(),
+					  ""));
+    }
+  
+  sprite = new SpaceSprite(tmpVec, count, attrib, rotations);
+  return sprite;
 }
 
-void ShipData::load() {
-	int i, index = 0, count;
+void ShipData::load() 
+{
+  STACKTRACE;
+  int i, index = 0, count;
+  
+  if (status != LOADED_NONE) 
+    return;
+  
+  tw_set_config_file(ini);
 
-	if (status != LOADED_NONE) return;
+  int num_panel_bitmaps = get_config_int("Objects", "PanelBitmaps", 0);
+  // load ship panel
+  if (num_panel_bitmaps < 2)
+    tw_error("Too few ship panel bitmaps");
 
-	data = load_datafile(file);
+  std::vector<std::string> tmpVec;
+  for(i = 0; i < num_panel_bitmaps; i++) 
+    {
+      char tmp[200] = {0};
+      sprintf(tmp, "%d", i);
+      tmpVec.push_back( get_config_string("Graphic", 
+					  (std::string("PanelBitmaps") + tmp).c_str(),
+					  ""));
+    }
+  spritePanel = new SpaceSprite(tmpVec, num_panel_bitmaps, SpaceSprite::IRREGULAR);
+  tmpVec.clear();
+  //  tw_error("!!");
+  // load ship sprites
+  spriteShip = load_sprite("ShipSprites"); 
 
-	if(!data)
-		tw_error("Error loading '%s'", file);
+  // load weapon sprites
+  spriteWeapon = load_sprite("WeaponSprites");
 
-	set_config_data((char *)(data[index].dat), data[index].size);
+  // load weapon explosion sprites
+  spriteWeaponExplosion = load_sprite("WeaponExplosion");
 
-	int num_panel_bitmaps = get_config_int("Objects", "PanelBitmaps", 0);
+  // load special ability sprites
+  spriteSpecial = load_sprite("SpecialSprites");
+  
+  // load special ability explosion sprites
+  spriteSpecialExplosion = load_sprite("SpecialExplosion");
+  
+  // load extra sprites
+  spriteExtra = load_sprite("ExtraSprites");
+  
+  // load extra explosion sprites
+  spriteExtraExplosion = load_sprite("ExtraExplosion");
+  
+  //load optional super-extra sprites
+  i = 0;
+  more_sprites = NULL;
+  while (true) 
+    {
+      char buffy[512];
+      sprintf(buffy, "ExtraExtraSprites%d_", i);
+      if (get_config_int("Objects", buffy, -1) == -1) 
+	break;
+      
+      //tw_error("SSS");
+      more_sprites = (SpaceSprite**) realloc(more_sprites, (i+1) * sizeof(SpaceSprite*));
+      more_sprites[i] = load_sprite(buffy);
+      i += 1;
+    }
+  num_more_sprites = i;
+  
+  // initialize ship victory ditty
+  moduleVictory = get_config_string("Music", "Victory", "");
+  index++;
+  
+  // load weapon samples
+  count = get_config_int("Objects", "WeaponSamples", 0);
+  for(i = 0; i < count; i++) 
+    {
+      char tmp[200] = {0};
+      sprintf(tmp, "%d", i);
+      sampleWeapon.push_back( get_config_string("Sound", 
+						(std::string("WeaponSample") + tmp).c_str(),
+						""));
+    }
+  
+  // load special ability samples
+  count = get_config_int("Objects", "SpecialSamples", 0);
+  for(i = 0; i < count; i++) 
+    {
+      char tmp[200] = {0};
+      sprintf(tmp, "%d", i);
+      sampleSpecial.push_back( get_config_string("Sound", 
+						 (std::string("SpecialSample") + tmp).c_str(),
+						 ""));
+    }
+  
+  // load extra samples
+  count = get_config_int("Objects", "ExtraSamples", 0);
+  for(i = 0; i < count; i++) 
+    {
+      char tmp[200] = {0};
+      sprintf(tmp, "%d", i);
+      sampleExtra.push_back( get_config_string("Sound", 
+					       (std::string("ExtraSample") + tmp).c_str(),
+					       ""));
+    }
+  
+  status = LOADED_FULL;
 
-	index++;
-
-	// load ship panel
-	if (num_panel_bitmaps < 2)
-		tw_error("Too few ship panel bitmaps");
-	spritePanel = new SpaceSprite(&data[index], num_panel_bitmaps, SpaceSprite::IRREGULAR);
-	index += num_panel_bitmaps;
-
-	// load ship sprites
-	spriteShip = load_sprite("ShipSprites", data, &index);
-
-	// load weapon sprites
-	spriteWeapon = load_sprite("WeaponSprites", data, &index);
-
-	// load weapon explosion sprites
-	spriteWeaponExplosion = load_sprite("WeaponExplosion", data, &index);
-
-	// load special ability sprites
-	spriteSpecial = load_sprite("SpecialSprites", data, &index);
-
-	// load special ability explosion sprites
-	spriteSpecialExplosion = load_sprite("SpecialExplosion", data, &index);
-
-	// load extra sprites
-	spriteExtra = load_sprite("ExtraSprites", data, &index);
-
-	// load extra explosion sprites
-	spriteExtraExplosion = load_sprite("ExtraExplosion", data, &index);
-
-	//load optional super-extra sprites
-	i = 0;
-	more_sprites = NULL;
-	while (true) {
-		char buffy[512];
-		sprintf(buffy, "ExtraExtraSprites%d", i);
-		if (get_config_int("Objects", buffy, -1) == -1) break;
-		more_sprites = (SpaceSprite**) realloc(more_sprites, (i+1) * sizeof(SpaceSprite*));
-		more_sprites[i] = load_sprite(buffy, data, &index);
-		i += 1;
-	}
-	num_more_sprites = i;
-
-	// initialize ship victory ditty
-	moduleVictory = (Music *)(data[index].dat);
-	index++;
-
-	// load weapon samples
-	count = get_config_int("Objects", "WeaponSamples", 0);
-	num_weapon_samples = count;
-	if(count > 0) {
-		sampleWeapon = new SAMPLE*[count];
-		for(i = 0; i < count; i++) {
-			sampleWeapon[i] = (SAMPLE *)(data[index].dat);
-			index++;
-		}
-	}
-	else sampleWeapon = NULL;
-
-	// load special ability samples
-	count = get_config_int("Objects", "SpecialSamples", 0);
-	num_special_samples = count;
-	if(count > 0) {
-		sampleSpecial = new SAMPLE*[count];
-		for(i = 0; i < count; i++) {
-			sampleSpecial[i] = (SAMPLE *)(data[index].dat);
-			index++;
-		}
-	}
-	else sampleSpecial = NULL;
-
-	// load extra samples
-	count = get_config_int("Objects", "ExtraSamples", 0);
-	num_extra_samples = count;
-	if(count > 0) {
-		sampleExtra = new SAMPLE*[count];
-		for(i = 0; i < count; i++) {
-			sampleExtra[i] = (SAMPLE *)(data[index].dat);
-			index++;
-		}
-	}
-	else sampleExtra = NULL;
-
-	status = LOADED_FULL;
-
-	return;
-
+  return;  
 }
 
 ShipData::~ShipData()
 {
-	unload();
-	free(file);
+  unload();
 }

Modified: branches/multiplayer-branch/source/melee/mshppan.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mshppan.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mshppan.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -18,7 +18,6 @@
 #include <allegro.h>
 
 #include "melee.h"
-REGISTER_FILE
 #include "mgame.h"
 #include "mshppan.h"
 #include "mship.h"
@@ -38,7 +37,8 @@
 int batt_y = 53;
 
 
-ShipPanel::ShipPanel(Ship *_ship) {STACKTRACE
+ShipPanel::ShipPanel(Ship *_ship) {
+  STACKTRACE;
 	id |= ID_SHIP_PANEL;
 
 	panel   = create_bitmap(64, 100);
@@ -81,13 +81,15 @@
   delete window;
 }
 
-void ShipPanel::refresh() {STACKTRACE
+void ShipPanel::refresh() {
+  STACKTRACE;
 	panel_needs_update = 1;
 	captain_needs_update = 1;
 	return;
 	}
 
-void ShipPanel::calculate() {STACKTRACE
+void ShipPanel::calculate() {
+  STACKTRACE;
 	if (!ship) {
 		deathframe -= frame_time;
 		if (deathframe <= 0) this->die();
@@ -116,7 +118,7 @@
 	}
 
 void ShipPanel::animate(Frame *space) {
-	STACKTRACE;
+  STACKTRACE;
 
 	BITMAP *screen = window->surface;
 	if (!screen) return;
@@ -204,12 +206,12 @@
 		}
 
 	if((!batt_light) && (ship->weapon_low || ship->special_low)) {
-		meleedata.panelSprite->draw(40, 58, 2, panel);
+		game->meleedata.panelSprite->draw(40, 58, 2, panel);
 		batt_light = TRUE;
 		panel_needs_update = true;
 		}
 	else if(batt_light && (!ship->weapon_low) && (!ship->special_low)) {
-		meleedata.panelSprite->draw(40, 58, 1, panel);
+		game->meleedata.panelSprite->draw(40, 58, 1, panel);
 		batt_light = FALSE;
 		panel_needs_update = true;
 		}

Modified: branches/multiplayer-branch/source/melee/msprite.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/msprite.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/msprite.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -23,7 +23,6 @@
 
 
 #include "melee.h"
-REGISTER_FILE
 #include "util/pmask.h"
 #include "util/aastr.h"
 #include "frame.h"
@@ -32,125 +31,167 @@
 #include "mview.h"
 
 int tw_aa_mode = 0;
-void set_tw_aa_mode ( int a) {
-	tw_aa_mode = a;
+void set_tw_aa_mode ( int a) 
+{
+  STACKTRACE;
+  tw_aa_mode = a;
 }
-int get_tw_aa_mode () {
-	return tw_aa_mode;
+
+int get_tw_aa_mode () 
+{
+  STACKTRACE;
+  return tw_aa_mode;
 }
 
-int string_to_sprite_attributes ( const char *s, int recommended ) {STACKTRACE
-	int a = recommended;
-	if (!s) return a;
+/// \brief convert attribute string to bit mask
+/// \param s attribute string
+/// \param recommended default mask
+/// \return bit mask
+int string_to_sprite_attributes ( const char *s, int recommended ) 
+{
+  STACKTRACE;
+  int a = recommended;
+  if (!s) return a;
+  
+  if (strstr(s, "+screen")) 
+    {
+      a |= SpaceSprite::MATCH_SCREEN_FORMAT;
+    }
+  if (strstr(s, "-screen")) 
+    {
+      a &=~SpaceSprite::MATCH_SCREEN_FORMAT;
+    }
 
-	if (strstr(s, "+screen")) {
-		a |= SpaceSprite::MATCH_SCREEN_FORMAT;
-	}
-	if (strstr(s, "-screen")) {
-		a &=~SpaceSprite::MATCH_SCREEN_FORMAT;
-	}
+  if (strstr(s, "+mipmap")) 
+    {
+      a |= SpaceSprite::MIPMAPED;
+    }
+  if (strstr(s, "-mipmap")) 
+    {
+      a &=~SpaceSprite::MIPMAPED;
+    }
+  
+  if (strstr(s, "+irregular")) 
+    {
+      a |= SpaceSprite::IRREGULAR;
+    }
+  if (strstr(s, "-irregular")) 
+    {
+      a &=~SpaceSprite::IRREGULAR;
+    }
+  
+  if (strstr(s, "+masked")) 
+    {
+      a |= SpaceSprite::MASKED;
+    }
+  if (strstr(s, "-masked")) 
+    {
+      a &=~SpaceSprite::MASKED;
+    }
+  
+  if (strstr(s, "+alpha")) 
+    {
+      a |= SpaceSprite::ALPHA;
+      a &=~SpaceSprite::MATCH_SCREEN_FORMAT;//remove me
+    }
+  if (strstr(s, "-alpha")) 
+    {
+      a &=~SpaceSprite::ALPHA;
+    }
+  
+  if (strstr(s, "+dither")) 
+    {
+      a |= SpaceSprite::DITHER;
+    }
+  if (strstr(s, "-dither")) 
+    {
+      a &=~SpaceSprite::DITHER;
+    }
+  
+  if (strstr(s, "+noaa")) 
+    {
+      a |= SpaceSprite::NO_AA;
+    }
+  if (strstr(s, "-noaa")) 
+    {
+      a &=~SpaceSprite::NO_AA;
+    }
+  return a;
+}
 
-	if (strstr(s, "+mipmap")) {
-		a |= SpaceSprite::MIPMAPED;
-	}
-	if (strstr(s, "-mipmap")) {
-		a &=~SpaceSprite::MIPMAPED;
-	}
-
-	if (strstr(s, "+irregular")) {
-		a |= SpaceSprite::IRREGULAR;
-	}
-	if (strstr(s, "-irregular")) {
-		a &=~SpaceSprite::IRREGULAR;
-	}
-
-	if (strstr(s, "+masked")) {
-		a |= SpaceSprite::MASKED;
-	}
-	if (strstr(s, "-masked")) {
-		a &=~SpaceSprite::MASKED;
-	}
-
-	if (strstr(s, "+alpha")) {
-		a |= SpaceSprite::ALPHA;
-		a &=~SpaceSprite::MATCH_SCREEN_FORMAT;//remove me
-	}
-	if (strstr(s, "-alpha")) {
-		a &=~SpaceSprite::ALPHA;
-	}
-
-	if (strstr(s, "+dither")) {
-		a |= SpaceSprite::DITHER;
-	}
-	if (strstr(s, "-dither")) {
-		a &=~SpaceSprite::DITHER;
-	}
-
-	if (strstr(s, "+noaa")) {
-		a |= SpaceSprite::NO_AA;
-	}
-	if (strstr(s, "-noaa")) {
-		a &=~SpaceSprite::NO_AA;
-	}
-	return a;
+void handle_alpha_load ( BITMAP *bmp ) 
+{
+  STACKTRACE;
+  switch (bitmap_color_depth(bmp)) 
+    {
+    case 16: 
+      {
+	rgba4444_as_rgb16 (bmp);
+      } break;
+    case 32: 
+      {
+	convert_alpha(bmp, 1);
+      } 
+      break;
+    default: 
+      {
+      } 
+      break;
+    }
+  return;
 }
 
-void handle_alpha_load ( BITMAP *bmp ) {
-	switch (bitmap_color_depth(bmp)) {
-		case 16: {
-			rgba4444_as_rgb16 (bmp);
-			//invert_alpha(bmp);
-		} break;
-		case 32: {
-			convert_alpha(bmp, 1);
-		} break;
-		default: {
-		} break;
-	}
-	return;
+/// \brief draw line
+void line ( BITMAP *dest, Vector2 p1, Vector2 p2, int color ) 
+{
+  STACKTRACE;
+  line (dest, iround(p1.x), iround(p1.y), iround(p2.x), iround(p2.y), color);
 }
 
-void line ( BITMAP *dest, Vector2 p1, Vector2 p2, int color ) {
-	line (dest, iround(p1.x), iround(p1.y), iround(p2.x), iround(p2.y), color);
+/// \brief draw line
+void line ( Frame *dest, Vector2 p1, Vector2 p2, int color ) 
+{
+  STACKTRACE;
+  int x1, y1, x2, y2;
+  x1 = iround(p1.x);	y1 = iround(p1.y);
+  x2 = iround(p2.x);	y2 = iround(p2.y);
+  line(dest->surface, x1, y1, x2, y2, color);
+  dest->add_line(x1, y1, x2, y2);
 }
-void line ( Frame *dest, Vector2 p1, Vector2 p2, int color ) {
-	int x1, y1, x2, y2;
-	x1 = iround(p1.x);	y1 = iround(p1.y);
-	x2 = iround(p2.x);	y2 = iround(p2.y);
-	line(dest->surface, x1, y1, x2, y2, color);
-	dest->add_line(x1, y1, x2, y2);
-}
 
 
 int SpaceSprite::mip_min = 0;
 int SpaceSprite::mip_max = 8;
 int SpaceSprite::mip_bias = 0;
-inline int find_mip_level(double r, int highest) {
-	int a;
-	frexp(r, &a);
-	a = SpaceSprite::mip_bias - a;
-	if (a < SpaceSprite::mip_min) a = SpaceSprite::mip_min;
-	if (a > SpaceSprite::mip_max) a = SpaceSprite::mip_max;
-	if (a > highest) a = highest;
-	return a;
+inline int find_mip_level(double r, int highest) 
+{
+  STACKTRACE;
+  int a;
+  frexp(r, &a);
+  a = SpaceSprite::mip_bias - a;
+  if (a < SpaceSprite::mip_min) a = SpaceSprite::mip_min;
+  if (a > SpaceSprite::mip_max) a = SpaceSprite::mip_max;
+  if (a > highest) a = highest;
+  return a;
 }
-//COMPILE_TIME_ASSERT(SpaceSprite::DITHER == AA_DITHER << 16);
-//COMPILE_TIME_ASSERT(SpaceSprite::MASKED == AA_MASKED << 16);
-//COMPILE_TIME_ASSERT(SpaceSprite::ALPHA  == AA_ALPHA << 16);
-inline int find_aa_mode(int general_options) {
-	int aa = tw_aa_mode;
-	if (general_options & SpaceSprite::MASKED) aa |= AA_MASKED;
-	if (~general_options & SpaceSprite::ALPHA) aa &=~AA_ALPHA;
-	if (general_options & SpaceSprite::NO_AA)  {
-		aa |= AA_NO_AA;
-	}
-	return aa;
+
+inline int find_aa_mode(int general_options) 
+{
+  STACKTRACE;
+  int aa = tw_aa_mode;
+  if (general_options & SpaceSprite::MASKED) aa |= AA_MASKED;
+  if (~general_options & SpaceSprite::ALPHA) aa &=~AA_ALPHA;
+  if (general_options & SpaceSprite::NO_AA)  {
+    aa |= AA_NO_AA;
+  }
+  return aa;
 }
 
 
-
+/// \brief do nothing
 void convert_bitmap(BITMAP *src, BITMAP *dest, int aa_mode) 
 {
+  STACKTRACE;
   if ((src->w != dest->w) || (src->h != dest->h)) 
     {
       tw_error("convert_bitmap - wrong size");
@@ -161,6 +202,7 @@
 
 void color_correct_bitmap(BITMAP *bmp, int masked) 
 {
+  STACKTRACE;
   //return;//remove me!!!
   int x, y, w, h;
   w = bmp->w;
@@ -214,7 +256,7 @@
 	      }
 	      break;
 	    }
-	  videosystem.color_effects(&a);
+	  videosystem->color_effects(&a);
 	  c = makeacol_depth(bitmap_color_depth(bmp), a.r, a.g, a.b, a.filler);
 	  if ((c == bmc) && masked) 
 	    {
@@ -231,6 +273,7 @@
 
 void SpaceSprite::generate_mipmaps() 
 {
+  STACKTRACE;
   int bpp, level, i;
   if (general_attributes & MIPMAPED) 
     {
@@ -264,6 +307,7 @@
 
 void SpaceSprite::change_color_depth(int newbpp) 
 {
+  STACKTRACE;
   int i, l;
   for (l = 0; l <= highest_mip; l += 1) 
     {
@@ -281,6 +325,7 @@
 
 void SpaceSprite::permanent_phase_shift ( int phase ) 
 {
+  STACKTRACE;
   int i, mip;
   Surface **tmp = new Surface*[count];
   while (phase < 0) phase += count;
@@ -325,6 +370,7 @@
 
 SpaceSprite::SpaceSprite(const DATAFILE *images, int sprite_count, int _attributes, int rotations) 
 {
+  STACKTRACE;
   int i, j, obpp=0;
   BITMAP *bmp = NULL, *tmp = NULL;
   
@@ -348,15 +394,14 @@
   general_attributes = _attributes;
   if (general_attributes &  MATCH_SCREEN_FORMAT) 
     {
-      bpp = videosystem.bpp;
+      bpp = videosystem->bpp;
       if (general_attributes & ALPHA) 
 	{
-	  if (bpp <= 16) bpp = 16;
-	  else bpp = 32;
 	  bpp = 32; //quick hack, because converting to 16bpp isn't quite working properly
 	}
     }
-  else bpp = 0;
+  else 
+    bpp = 0;
   
   originaltype = images[0].type;
   switch (originaltype) 
@@ -562,6 +607,7 @@
 
 SpaceSprite::SpaceSprite(SpaceSprite &old) 
 {
+  STACKTRACE;
   int i, l;
   BITMAP *bmp;
   count = old.count;
@@ -594,14 +640,181 @@
   else b[l] = NULL;
 }
 
+
+
+SpaceSprite::SpaceSprite(std::vector<std::string> bmplist, int sprite_count, int _attributes, int rotations)
+{
+  STACKTRACE;
+  int i, j, obpp=0;
+  BITMAP *bmp = NULL, *tmp = NULL, *tmp2 = NULL;
+  
+
+  if (_attributes == -1) 
+    _attributes = string_to_sprite_attributes(NULL);
+
+  count = sprite_count * rotations;
+  if ((rotations < 1) || (count < 1)) 
+    {
+      tw_error("SpaceSprite::SpaceSprite - bad parameters");
+    }
+  
+  references = 0;
+  highest_mip = 0;
+  for (i = 1; i < MAX_MIP_LEVELS; i += 1) 
+    {
+      b[i] = NULL;
+    }
+  
+  general_attributes = _attributes;
+  if (general_attributes &  MATCH_SCREEN_FORMAT) 
+    {
+      bpp = videosystem->bpp;
+      if (general_attributes & ALPHA) 
+	{
+	  bpp = 32; 
+	}
+    }
+  else 
+    bpp = 0;
+  
+  
+  tmp2 = load_bitmap(data_full_path(bmplist[0]).c_str(), NULL);
+  if(!tmp2)
+    tw_error("Unable to load bitmap: %s", data_full_path(bmplist[0]).c_str());
+
+  w = tmp2->w;
+  h = tmp2->h;
+  obpp = bitmap_color_depth(tmp2);
+  
+  if (bpp == 0) 
+    bpp = obpp;
+  
+  if (obpp != bpp) 
+    tmp = create_bitmap_ex(obpp, w, h);
+  
+  if (general_attributes & ALPHA) 
+    {
+      bpp = 32;
+    }
+  destroy_bitmap(tmp2);
+  
+  if (general_attributes & IRREGULAR) 
+    {
+      if (rotations != 1) 
+	{
+	  tw_error (" irregular SpaceSprites are not permitted to be autorotated");
+	}
+  
+      m = new PMASK*[count];
+      b[0] = new BITMAP*    [count];
+      attributes  = new char [count];
+  
+      for(i = 0; i < sprite_count; i += 1) 
+	{
+	  tmp2 = load_bitmap(data_full_path(bmplist[i]).c_str(), NULL);
+	  if(!tmp2)
+	    {
+	      tw_error("unable to load bitmap: %s", bmplist[i].c_str());
+	    }
+	  if (general_attributes & ALPHA) 
+	    handle_alpha_load(tmp2);
+	  w = tmp2->w;
+	  h = tmp2->h;
+	  bmp = create_bitmap_ex ( bpp, w, h);
+	  convert_bitmap(tmp2, bmp, general_attributes & MASKED);
+	  color_correct_bitmap(bmp, general_attributes & MASKED);
+	  m[(i * rotations)] = create_allegro_pmask(bmp);
+	  b[0][(i * rotations)] = bmp;
+	  attributes[(i * rotations)] = DEALLOCATE_IMAGE | DEALLOCATE_MASK;
+	  destroy_bitmap(tmp2);
+	}
+      return;//end of irregular/masked 
+    }
+  
+  /*
+  for(i = 1; i < sprite_count; i++) 
+    {
+      if ((w != ((BITMAP *)images[i].dat)->w) || 
+	  (h != ((BITMAP *)images[i].dat)->h) ) 
+	{
+	  tw_error("SpaceSprite - size changed");
+	}
+      if (bitmap_color_depth((BITMAP *)images[i].dat) != obpp) 
+	{
+	  tw_error("SpaceSprite - changing source color depth not yet allowed");
+	}
+    }
+  */
+
+  m = new PMASK*[count];
+  b[0] = new BITMAP*    [count];
+  attributes  = new char [count];
+  
+  for(i = 0; i < sprite_count; i += 1) 
+    {
+      tmp2 = load_bitmap(data_full_path(bmplist[i]).c_str(), NULL);
+      if(!tmp2)
+	{
+	  tw_error("unable to load bitmap: %s", bmplist[i].c_str());
+	}
+      bmp = create_bitmap_ex(bpp, w, h);
+      if (!tmp) 
+	tmp = bmp;
+      if (general_attributes & MASKED) 
+	clear_to_color(bmp, bitmap_mask_color(bmp));
+      if (tmp != bmp) 
+	clear_to_color(tmp, bitmap_mask_color(tmp));
+
+      if (general_attributes & ALPHA) 
+	handle_alpha_load(tmp2);
+      if (obpp != bpp) 
+	{
+	  convert_bitmap(tmp2, bmp, (general_attributes & MASKED) ? AA_MASKED : 0);
+	}
+      else 
+	{
+	  if (general_attributes & MASKED) 
+	    draw_sprite(bmp, tmp2, 0, 0);
+	  else 
+	    blit(tmp2, bmp, 0, 0, 0, 0, w, h);
+	}
+      color_correct_bitmap(bmp, general_attributes & MASKED);
+
+      if (tmp == bmp) 
+	tmp = NULL;
+      for (j = 1; j < rotations; j += 1) 
+	{
+	  BITMAP *tmp = create_bitmap_ex(bpp, w, h);
+	  clear_to_color(tmp, bitmap_mask_color(tmp));
+	  rotate_sprite(tmp, bmp, 0, 0, j * ((1<<24)/rotations));
+	  m[j + (i * rotations)] = create_allegro_pmask(tmp);
+	  b[0][j + (i * rotations)] = tmp;
+	  attributes[j + (i * rotations)] = DEALLOCATE_IMAGE | DEALLOCATE_MASK;
+	}
+      m[(i * rotations)] = create_allegro_pmask(bmp);
+      b[0][(i * rotations)] = bmp;
+      attributes[(i * rotations)] = DEALLOCATE_IMAGE | DEALLOCATE_MASK;
+      destroy_bitmap(tmp2);
+    }
+
+  if (general_attributes & MIPMAPED) 
+    {
+      generate_mipmaps();
+    }
+
+  return;//end of normal/masked/autorotated
+}
+
 void SpaceSprite::lock() 
 {
+  STACKTRACE;
   highest_mip = 0;
   return;
 }
 
 void SpaceSprite::unlock() 
 {
+  STACKTRACE;
   int i, j;
   for (i = 0; i < MAX_MIP_LEVELS; i += 1) 
     {
@@ -641,6 +854,7 @@
 
 BITMAP *SpaceSprite::get_bitmap(int index, int miplevel)
 {
+  STACKTRACE;
   if (general_attributes & MIPMAPED) 
     if (miplevel > highest_mip) 
       {tw_error ("get_bitmap on undefined mipmap level");}
@@ -651,6 +865,7 @@
 
 BITMAP *SpaceSprite::get_bitmap_readonly(int index)
 {
+  STACKTRACE;
   if (index >= count) 
     {
       tw_error("SpaceSprite::get_bitmap_readonly - index %d >= count %d", index, count); index = 0;
@@ -664,6 +879,7 @@
 
 void SpaceSprite::animate_character(Vector2 pos, int index, int color, Frame *space, double scale) 
 {
+  STACKTRACE;
   if (index >= count) 
     {
       tw_error("SpaceSprite::animate_character - index %d >= count %d", index, count);
@@ -751,6 +967,7 @@
 
 void SpaceSprite::draw(Vector2 pos, Vector2 size, int index, BITMAP *surface) 
 {
+  STACKTRACE;
   if (index >= count) 
     {
       tw_error("SpaceSprite::draw - index %d > count %d", index, count); index = 0;
@@ -781,6 +998,7 @@
 
 void SpaceSprite::draw(Vector2 pos, Vector2 size, int index, Frame *frame) 
 {
+  STACKTRACE;
   if (index >= count) 
     {
       tw_error("SpaceSprite::draw - index %d > count %d", index, count); index = 0;
@@ -826,12 +1044,14 @@
 
 void SpaceSprite::draw(int x, int y, int index, BITMAP *surface) 
 {
+  STACKTRACE;
   draw(Vector2(x,y), Vector2(b[0][index]->w, b[0][index]->h), index, surface);
   return;
 }
 
 void SpaceSprite::animate(Vector2 pos, int index, Frame *space, double scale) 
 {
+  STACKTRACE;
   if (index >= count) 
     {
       tw_error("SpaceSprite::animate - index %d >= count %d", index, count);
@@ -849,6 +1069,7 @@
 
 void SpaceSprite::draw_character(int x, int y, int index, int color, BITMAP *bmp) 
 {
+  STACKTRACE;
   if (index >= count) 
     {
       tw_error("SpaceSprite::draw_character - index %d >= count %d", index, count); index = 0;
@@ -863,18 +1084,21 @@
 
 void SpaceSprite::draw_character(int x, int y, int index, int color, Frame *space) 
 {
+  STACKTRACE;
   draw_character(x, y, index, color, space->surface);
   space->add_box(x, y, w, h);
 }
 
 void SpaceSprite::draw_character(int x, int y, int w, int h, int index, int color, Frame *space) 
 {
+  STACKTRACE;
   draw_character(x, y, w, h, index, color, space->surface);
   space->add_box(x, y, w, h);
 }
 
 void SpaceSprite::draw_character(int x, int y, int w, int h, int index, int color, BITMAP *bmp) 
 {
+  STACKTRACE;
   if (index >= count) 
     {
       tw_error("SpaceSprite::draw_character_stretch - index %d >= count %d", index, count); index = 0;
@@ -890,6 +1114,7 @@
 int SpaceSprite::collide(int x, int y, int i, int ox, int oy, int oi,
 			 SpaceSprite *other)
 {
+  STACKTRACE;
   if (i >= count) 
     { 
       tw_error("SpaceSprite::collide - index1 %d >= count1 %d", i, count); 
@@ -944,6 +1169,7 @@
 int SpaceSprite::collide_ray(int lx1, int ly1, int *lx2, int *ly2,
   int sx, int sy, int sindex)
 {
+  STACKTRACE;
   line_collide = FALSE;
   rect_x = sx - (w / 2);
   rect_y = sy - (h / 2);

Modified: branches/multiplayer-branch/source/melee/mtarget.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mtarget.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mtarget.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -24,6 +24,7 @@
 
 Targets::Targets()
 {
+  STACKTRACE;
 	N = 0;
 	item = 0;
 }
@@ -36,6 +37,7 @@
 
 void Targets::reset()
 {
+  STACKTRACE;
 	if (item)
 		free(item);
 	item = 0;
@@ -43,7 +45,8 @@
 }
 
 
-void Targets::add(SpaceObject *a) {STACKTRACE
+void Targets::add(SpaceObject *a) {
+  STACKTRACE;
 	N += 1;
 	item = (SpaceObject **) realloc(item, sizeof(SpaceObject *) * N);
 	item[N - 1] = a;
@@ -53,6 +56,7 @@
 
 void Targets::rem(int i)
 {
+  STACKTRACE;
 	-- N;
 	item[i]->attributes &= ~ATTRIB_TARGET;
 	item[i] = item[N];
@@ -61,6 +65,7 @@
 
 void Targets::rem(SpaceObject *r)
 {
+  STACKTRACE;
 	int i;
 	for ( i = 0; i < N; ++i )
 		if (item[i] == r)
@@ -76,6 +81,7 @@
 
 void Targets::calculate()
 {
+  STACKTRACE;
 	int i;
 	
 	for (i = 0; i < N; i += 1)
@@ -93,6 +99,7 @@
 
 int Targets::findindex(SpaceObject *o)
 {
+  STACKTRACE;
 	int i;
 
 	for (i = 0; i < N; i += 1)
@@ -109,5 +116,6 @@
 
 bool Targets::isintargetlist(SpaceObject *o)
 {
+  STACKTRACE;
 	return findindex(o) >= 0;
 }

Modified: branches/multiplayer-branch/source/melee/mview.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mview.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee/mview.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -23,7 +23,6 @@
 
 
 #include "melee.h"
-REGISTER_FILE
 #include "scp.h"
 #include "frame.h"
 
@@ -59,7 +58,8 @@
 
 
 
-View * ViewType::create( View * old ) {STACKTRACE
+View * ViewType::create( View * old ) {
+  STACKTRACE;
 	View * r = _create();
 	r->preinit();
 	r->type = this;
@@ -112,7 +112,8 @@
 
 
 
-void View::preinit() {STACKTRACE
+void View::preinit() {
+  STACKTRACE;
 	frame = NULL;
 	window = NULL;
 	type = NULL;
@@ -153,7 +154,8 @@
 }
 
 
-void View::animate(Game *game) {STACKTRACE
+void View::animate(Game *game) {
+  STACKTRACE;
 	if (FULL_REDRAW) frame->full_redraw = true;
 	frame->erase();
 	prepare(frame, 0);
@@ -169,11 +171,12 @@
 	return;
 	}
 
-void View::config() {STACKTRACE
+void View::config() {
+  STACKTRACE;
 	return;
 	}
 bool View::screen2game(Vector2 *_pos) {
-	STACKTRACE
+  STACKTRACE;
 	Vector2 pos = *_pos;
 	Vector2 opos = pos;
 
@@ -193,7 +196,7 @@
 	return true;
 	}
 double View::in_view(Vector2 pos, Vector2 size) {
-	STACKTRACE
+  STACKTRACE;
 	pos = corner(pos, size);
 	size = size * space_zoom;
 
@@ -212,7 +215,7 @@
 	return a * b / (size.x * size.y);
 }
 int View::focus(CameraPosition *pos, SpaceLocation *la, SpaceLocation *lb) {
-	STACKTRACE
+  STACKTRACE;
 	if (!la && !lb) return 0;
 	if (!la) la = lb;
 	if (!lb) lb = la;
@@ -242,6 +245,7 @@
 }
 
 /*void View::see_also(SpaceLocation *o) {
+  STACKTRACE;
 	if (!o) return;
 	double x2, y2;
 	x2 = b->normal_x();
@@ -317,7 +321,8 @@
 	return;
 }
 
-void View::init(View *old) {STACKTRACE
+void View::init(View *old) {
+  STACKTRACE;
 	if (window || frame) {
 		tw_error("View::init - hmm...");
 	}
@@ -373,9 +378,11 @@
 		delete frame;
 	}
 }
-void View::calculate(Game *game) {}
+void View::calculate(Game *game) {
+  STACKTRACE;}
 
-void message_type::out(char *string, int dur, int c) {STACKTRACE
+void message_type::out(char *string, int dur, int c) {
+  STACKTRACE;
 	ASSERT (c < 256);
 	if (num_messages == max_messages - 1) {
 		messages[0].end_time = -1;
@@ -391,7 +398,8 @@
 	clean();
 	return;
 	}
-void message_type::print(int dur, int c, const char *format, ...) {STACKTRACE
+void message_type::print(int dur, int c, const char *format, ...) {
+  STACKTRACE;
 	char buf[1024];
 	va_list those_dots;
 	va_start (those_dots, format);
@@ -408,7 +416,8 @@
 	out(buf, dur, c);
 	return;
 	}
-void message_type::clean() {STACKTRACE
+void message_type::clean() {
+  STACKTRACE;
 	int kill_time;
 	if (game) kill_time = game->game_time;
 	else kill_time = 0;
@@ -422,7 +431,8 @@
 		}
 	return;
 	}
-void message_type::flush() {STACKTRACE
+void message_type::flush() {
+  STACKTRACE;
 	for (int i = 0; i < num_messages; i += 1) {
 		if (messages[i].string)
 			free (messages[i].string);
@@ -431,7 +441,8 @@
 	return;
 	}
 
-void message_type::animate(Frame *frame) {STACKTRACE
+void message_type::animate(Frame *frame) {
+  STACKTRACE;
 
 	if (num_messages <= 0)
 		return;
@@ -444,8 +455,8 @@
 		}
 	else {
 		text_mode(0);
-		videosystem.window.lock();
-		bmp = videosystem.window.surface;
+		videosystem->window.lock();
+		bmp = videosystem->window.surface;
 		}
 	clean();
 	if (!frame) rectfill(bmp, 0, 0, ox, oy, 0);
@@ -456,14 +467,16 @@
 		y += text_height(font);
 		}
 	if (frame && !frame->full_redraw) frame->add_box(0, 0, x, y);	
-	if (!frame) videosystem.window.unlock();
+	if (!frame) 
+	  videosystem->window.unlock();
 	ox = x;
 	oy = y;
 	return;
 	}
 message_type message;
 
-void View::_event( Event *e ) {STACKTRACE
+void View::_event( Event *e ) {
+  STACKTRACE;
 	if ( e->type == Event::VIDEO ) {
 		const VideoEvent *ve = (const VideoEvent*) e;
 		const VideoWindow *w = ve->window;
@@ -503,7 +516,8 @@
 	virtual void init(View *old);
 	//virtual void set_window (BITMAP *dest, int x, int y, int w, int h);
 	};
-void View_Hero::init(View *old) {STACKTRACE
+void View_Hero::init(View *old) {
+  STACKTRACE;
 	View::init(old);
 	f = 0;
 	min = 30;//480;
@@ -610,7 +624,8 @@
 	virtual void animate(Game *game);
 	virtual ~View_Split2a();
 	};
-void View_Split2a::init(View *old) {STACKTRACE
+void View_Split2a::init(View *old) {
+  STACKTRACE;
 	View::init(old);
 
 	min = 480;
@@ -708,7 +723,8 @@
 	virtual void animate(Game *game);
 	virtual ~View_Split2b();
 	};
-void View_Split2b::init(View *old) {STACKTRACE
+void View_Split2b::init(View *old) {
+  STACKTRACE;
 	View::init(old);
 
 	min = 480;
@@ -808,7 +824,8 @@
 	virtual void animate(Game *game);
 	virtual ~View_Split3();
 	};
-void View_Split3::init(View *old) {STACKTRACE
+void View_Split3::init(View *old) {
+  STACKTRACE;
 	View::init(old);
 
 	min = 480;
@@ -829,7 +846,8 @@
 		delete frames[i];
 	}
 }
-void View_Split3::animate(Game *game) {STACKTRACE
+void View_Split3::animate(Game *game) {
+  STACKTRACE;
 	VideoWindow *tmpw;
 	Frame *tmpf;
 	CameraPosition tmpc;
@@ -907,7 +925,8 @@
 	virtual void animate(Game *game);
 	virtual ~View_Split4();
 	};
-void View_Split4::init(View *old) {STACKTRACE
+void View_Split4::init(View *old) {
+  STACKTRACE;
 	View::init(old);
 
 	min = 480;
@@ -929,7 +948,8 @@
 		delete frames[i];
 	}
 }
-void View_Split4::animate(Game *game) {STACKTRACE
+void View_Split4::animate(Game *game) {
+  STACKTRACE;
 	VideoWindow *tmpw;
 	Frame *tmpf;
 	CameraPosition tmpc;

Modified: branches/multiplayer-branch/source/melee.h
===================================================================
--- branches/multiplayer-branch/source/melee.h	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/melee.h	2004-09-28 19:53:03 UTC (rev 71)
@@ -14,7 +14,8 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 */
-//this is a test
+
+
 #ifndef __MELEE_H__
 #define __MELEE_H__
 
@@ -27,10 +28,11 @@
 #endif
 
 #include <list>
+#include <string>
+#include <vector>
 
 #ifndef PI
 #	define PI 3.14159265358979323846
-//#define PI AL_PI
 #endif
 #ifdef PI2
 #	undef PI2
@@ -50,16 +52,17 @@
 	struct BITMAP;
 	struct DATAFILE;
 #if !defined ALLEGRO_H
-		struct RGB {
-			unsigned char r, g, b, zero;
-		};
+struct RGB 
+{
+  unsigned char r, g, b, zero;
+};
 #endif
 
-	typedef RGB     Color;
-	typedef BITMAP  Surface;
+typedef RGB     Color;
+typedef BITMAP  Surface;
 
 #else
-	#error unknown platform (allegro?)
+#error unknown platform (allegro?)
 #endif
 
 #ifdef _MSC_VER
@@ -73,18 +76,14 @@
 #define random  tw_random
 #include "util/round.h"
 #include "util/vector2.h"
-#include "util/sounds.h"
-//#include "util/aastr.h"
 
 
-
-
 /*
-	error displays an error message, and prompts the user to
-	"Abort", "Retry", or "Debug"
-	on "Abort", it throws 0, which will be silently caught at the closest catch (int)
-	on "Retry" it returns
-	on "Debug" it throws -1, which will be rethrown all the way out. or something roughly equivalent
+  error displays an error message, and prompts the user to
+  "Abort", "Retry", or "Debug"  
+  on "Abort", it throws 0, which will be silently caught at the closest catch (int)
+  on "Retry" it returns on "Debug" it throws -1, which will be rethrown all the way out. 
+  or something roughly equivalent
 */
 #include "util/errors.h"
 
@@ -98,16 +97,12 @@
 //does nothing if LOTS_OF_CHECKSUMS isn't defined in libs.h)
 #ifdef _DEBUG
 #	define checksync() __checksync(__FILE__,__LINE__)
-	void __checksync( const char *fname, int line);//defined in mgame.cpp
+void __checksync( const char *fname, int line);//defined in mgame.cpp
 #else
 #	define checksync()
 #endif
 //*/
 
-class Logger;
-
-//extern DATAFILE *scppal;
-
 #define MELEE_ASTEROID          0
 #define MELEE_ASTEROIDEXPLOSION 64
 #define MELEE_BOOM              84
@@ -182,6 +177,12 @@
 extern int hot_color[HOT_COLORS];
 
 
+#define MELEE_BOOMSHIP_SOUND "sound/boom/BOOMSHIP_WAV.wav"
+#define MELEE_BOOM_SOUND1 "sound/boom/BOOMPL01_WAV.wav"
+#define MELEE_BOOM_SOUND2 "sound/boom/BOOMPL01_WAV.wav"
+#define MELEE_BOOM_SOUND3 "sound/boom/BOOMPL01_WAV.wav"
+#define MELEE_BOOM_SOUND4 "sound/boom/BOOMPL01_WAV.wav"
+
 //melee/mframe.h
 class Physics;
 class SpaceSprite;
@@ -251,50 +252,53 @@
 extern class GobGame *&gobgame;
 extern Vector2 map_size;
 
-extern class MeleeData meleedata;
-
 //melee/mhelpers.cpp
 
 /// \brief Config event
-class ConfigEvent : public Event {
-public:
-	const char *name;
-	union {
-		/// \brief value is read as a const char * on a SET event
-		/// value is modified by a GET event to a malloced string
-		/// BaseClass *source;
-		char *value;
-	};
-	enum {
-		GET, 
-		SET,
-		FIND
-	};
+class ConfigEvent : public Event 
+{
+ public:
+  const char *name;
+  union 
+  {
+    /// \brief value is read as a const char * on a SET event
+    /// value is modified by a GET event to a malloced string
+    /// BaseClass *source;
+    char *value;
+  };
+  enum 
+    {
+      GET, 
+      SET,
+      FIND
+    };
 };
 
-class VideoEvent : public Event {
-public:
-	class VideoWindow *window;
-	enum { 
-		/// \brief happens before surface is invalidated
-		/// before a resolution change, whatever
-		INVALID,    
-	        /// \brief the opposite of an invalid event
-		/// after an alt-tab back, after a resolution change, whatever
-		VALID,
-		/// \brief happens when size is changed
-		/// after a resolution change, or a window resize
-		/// ?? after alt-tabbing back in ??
-		RESIZE,     
-		/// \brief happens when the color format changes
-		CHANGE_BPP, 
-		/// \brief happens when contents are changed
-		/// ?? after alt-tabbing back in ??
-		/// ?? after window translated ??
-		/// ? after any resize event ?
-		REDRAW      
-	};
-	virtual int _get_size() const {return sizeof(*this);}
+/*! \brief video event */
+class VideoEvent : public Event 
+{
+ public:
+  class VideoWindow *window;
+  enum { 
+    /// \brief happens before surface is invalidated
+    /// before a resolution change, whatever
+    INVALID,    
+    /// \brief the opposite of an invalid event
+    /// after an alt-tab back, after a resolution change, whatever
+    VALID,
+    /// \brief happens when size is changed
+    /// after a resolution change, or a window resize
+    /// ?? after alt-tabbing back in ??
+    RESIZE,     
+    /// \brief happens when the color format changes
+    CHANGE_BPP, 
+    /// \brief happens when contents are changed
+    /// ?? after alt-tabbing back in ??
+    /// ?? after window translated ??
+    /// ? after any resize event ?
+    REDRAW      
+  };
+  virtual int _get_size() const {return sizeof(*this);}
 };
 extern volatile int debug_value;
 
@@ -310,86 +314,77 @@
 double scale_velocity (double velocity) ;
 double scale_acceleration (double acceleration, double hotspot_rate = 0) ;
 
-void show_file(const char *file) ;
-void show_text(const char *text) ;
-//void show_help();
+void show_file(std::string file) ;
+void show_text(std::string text) ;
 
+
+/// \brief init vidio hardware
+///
+/// sets screen resolutions, color formats, color transforms, fonts
+/// gets screen surface, records redraw event times
 class VideoWindow : public BaseClass {
-	float const_x, const_y, const_w, const_h;
-	float propr_x, propr_y, propr_w, propr_h;
+  float const_x, const_y, const_w, const_h;
+  float propr_x, propr_y, propr_w, propr_h;
+  
+  char lock_level;
+  //struct VW_lock_data *lock_data;
+  
+ public:void update_pos();
+  
+  VideoWindow *parent;
+  std::list<BaseClass*> callback_list;
+ public:
+  void add_callback ( BaseClass * );
+  void remove_callback ( BaseClass * );
+  virtual void _event ( Event *e );
+  
+  int x, y, w, h;
+  Surface *surface;
+  void event(int subtype);
+  void redraw() {event(VideoEvent::REDRAW);}
+  void preinit ();
+  void init ( VideoWindow *parent_window);
+  void locate ( double c_x, double p_x, double c_y, double p_y, double c_w, double p_w, double c_h, double p_h );
+  void lock();
+  void unlock();
+  void hide();
+  void match ( VideoWindow *old );
+  void deinit();
+  virtual ~VideoWindow();
+  virtual int _get_size() const {return sizeof(*this);}
+};
 
-	char lock_level;
-	//struct VW_lock_data *lock_data;
-
-public:void update_pos();
-
-	VideoWindow *parent;
-	std::list<BaseClass*> callback_list;
-public:
-	void add_callback ( BaseClass * );
-	void remove_callback ( BaseClass * );
-	virtual void _event ( Event *e );
-
-	int x, y, w, h;
-	Surface *surface;
-	void event(int subtype);
-	void redraw() {event(VideoEvent::REDRAW);}
-	void preinit ();
-	void init ( VideoWindow *parent_window);
-	void locate ( double c_x, double p_x, double c_y, double p_y, double c_w, double p_w, double c_h, double p_h );
-	void lock();
-	void unlock();
-	void hide();
-	void match ( VideoWindow *old );
-	void deinit();
-	virtual ~VideoWindow();
-	virtual int _get_size() const {return sizeof(*this);}
+/// Video System
+class VideoSystem : public BaseClass 
+{
+ public:
+  int width, height, bpp, gamma;
+  int fullscreen;
+  DATAFILE *font_data; //fonts
+  FONT *basic_font; //font to use if no other is available
+  Color *palette;
+  volatile bool screen_corrupted;
+  int last_poll;
+  Surface *surface;
+  VideoWindow window;
+  
+  FONT *get_font(int size);
+  
+  void preinit() ;
+  int poll_redraw();
+  int set_resolution (int width, int height, int bpp, int fullscreen) ; //returns 0 on failure
+  void set_palette(Color *pal);
+  void (*color_effects)(Color *color);
+  void update_colors();
+  void redraw();
 };
+extern VideoSystem* videosystem;
 
-class VideoSystem : public BaseClass {
-	public:
-	int width, height, bpp, gamma;
-	int fullscreen;
-	DATAFILE *font_data; //fonts
-	FONT *basic_font; //font to use if no other is available
-	Color *palette;
-	volatile bool screen_corrupted;
-	int last_poll;
-	Surface *surface;
-	VideoWindow window;
-
-	FONT *get_font(int size);
-
-	void preinit() ;
-	int poll_redraw();
-	int set_resolution (int width, int height, int bpp, int fullscreen) ; //returns 0 on failure
-	void set_palette(Color *pal);
-	void (*color_effects)(Color *color);
-	void update_colors();
-	void redraw();
-} extern videosystem;
-
 int get_gamma();
 void set_gamma(int gamma);
 void gamma_color_effects (Color *color) ;
 
 
-struct registered_file_type {
-	char *fname;
-	char *fdate;
-	char *ftime;
-	};
-extern registered_file_type *registered_files;
-extern int num_registered_files;
-void _register_file (char *fname, char *fdate, char *ftime);
-
-#ifdef _DEBUG
-#	define REGISTER_FILE static const char *__registered_filename = __FILE__; static void __ignore_me_rf() {_register_file(__FILE__, __DATE__, __TIME__);} CALL_BEFORE_MAIN(__ignore_me_rf);
-#else
-#	define REGISTER_FILE static void __ignore_me_rf() {_register_file(__FILE__, __DATE__, __TIME__);} CALL_BEFORE_MAIN(__ignore_me_rf);
-#endif
-
-
 void init_ships();
 
 //mmath.h
@@ -435,107 +430,98 @@
 void animate_bmp(BITMAP *bmp, Vector2 pos, Frame *space);
 
 
-class SpaceSprite {
-	public:
-	static int mip_min, mip_max, mip_bias;
-	protected:
-	enum { MAX_MIP_LEVELS = 8 };
-	int         count;
-	char bpp;
-	char highest_mip;
-	int originaltype;
-	int         w;
-	int         h;
-	struct PMASK **m;
-	Surface **b[MAX_MIP_LEVELS];
+class SpaceSprite 
+{
+ public:
+  static int mip_min, mip_max, mip_bias;
+ protected:
+  enum { MAX_MIP_LEVELS = 8 };
+  int  count;
+  char bpp;
+  char highest_mip;
+  int originaltype;
+  int w;
+  int h;
+  struct PMASK **m;
+  Surface **b[MAX_MIP_LEVELS];
 
-	//char *type;
-	int references;
-	char *attributes;
-	enum { DEALLOCATE_IMAGE = 0x01, DEALLOCATE_MASK = 0x02 };
-	unsigned int general_attributes;
-	public:
-	enum {
-		MATCH_SCREEN_FORMAT = 0x001, 
-		IRREGULAR           = 0x002, 
-		MIPMAPED            = 0x004, 
+  int references;
+  char *attributes;
+  enum 
+    { 
+      DEALLOCATE_IMAGE  = (1<<0), 
+      DEALLOCATE_MASK   = (1<<2) 
+    };
+  unsigned int general_attributes;
+ public:
+  enum {
+    MATCH_SCREEN_FORMAT = (1<<0), 
+    IRREGULAR           = (1<<1), 
+    MIPMAPED            = (1<<2), 
+    
+    MASKED              = (1<<3), 
+    ALPHA               = (1<<4), 
+    DITHER              = (1<<5),
+    NO_AA               = (1<<6),
+    
+    NONE = 0
+  };
+  //sprite_count * rotation new images based upon sprite_count RLE_SPRITES, with gamma correction
+  SpaceSprite(const DATAFILE *sprites, int sprite_count, int attributes = -1, int rotations = 1);
+  SpaceSprite(BITMAP *image, int _attributes = -1);
+  SpaceSprite(SpaceSprite &old);
+ 
+  SpaceSprite( std::vector<std::string> bmplist, int sprite_count,  
+	       int _attributes = -1, 
+	       int rotations =1);
+  virtual ~SpaceSprite();
+  
+  
+  /// method for direct access:
+  Surface     *get_bitmap(int index, int miplevel = 0);
+  /// method for direct access:
+  Surface     *get_bitmap_readonly(int index);
+  const struct PMASK *get_pmask(int index) {return m[index];}
+  void lock();	///< make surface writable
+  void unlock();
+  
+  void overlay ( int index1, int index2, Surface *dest);
 
-		MASKED              = 0x100, 
-		ALPHA               = 0x200, 
-		DITHER              = 0x400,
-		NO_AA               = 0x800,
+  void draw(Vector2 pos, Vector2 size, int index, Frame *frame) ;
+  void draw(Vector2 pos, Vector2 size, int index, Surface *bmp) ;
+  void draw(int x, int y, int index, Surface *bmp) ;
 
-		NONE = 0
-	};
-	//sprite_count * rotation new images based upon sprite_count RLE_SPRITES, with gamma correction
-	SpaceSprite(const DATAFILE *sprites, int sprite_count, int attributes = -1, int rotations = 1);
-	SpaceSprite(BITMAP *image, int _attributes = -1);
-	SpaceSprite(SpaceSprite &old);
-//	SpaceSprite(const char *sourcename, const char *spritename);
-	// added GEO    (should be deleted)
-//	SpaceSprite::SpaceSprite(char *bmpfilename, int _attributes);
-	// added GEO
-	SpaceSprite::SpaceSprite(BITMAP **bmplist, int sprite_count, int rotations, int _attributes);
+  // added GEO
+  virtual void animate(Vector2 pos, int index, Frame *space, double scale = 1);
+  void animate_character(Vector2 pos, int index, int color, Frame *space, double scale = 1);
 
-	virtual ~SpaceSprite();
 
+  void draw_character(int x, int y, int index, int color, Surface *bmp);
+  void draw_character(int x, int y, int index, int color, Frame *space);
+  void draw_character(int x, int y, int w, int h, int index, int color, Surface *bmp);
+  void draw_character(int x, int y, int w, int h, int index, int color, Frame *space);
+  
+  void generate_mipmaps();
+  void regenerate_mipmaps();
+  
+  void permanent_phase_shift ( int index );
+  
+  virtual void change_color_depth(int dest);
+  
+  int collide(int x, int y, int i, int ox, int oy, int oi,
+	      SpaceSprite *other);
+  int collide_ray(int lx1, int ly1, int *lx2, int *ly2, int sx, int sy,
+		  int sindex);
 
-//methods for direct access:
-	Surface     *get_bitmap(int index, int miplevel = 0);
-	Surface     *get_bitmap_readonly(int index);
-	const struct PMASK *get_pmask(int index) {return m[index];}
-	void lock();	//make surface writable
-	void unlock();
-
-	void overlay ( int index1, int index2, Surface *dest);
-
-	void draw(Vector2 pos, Vector2 size, int index, Frame *frame) ;
-	void draw(Vector2 pos, Vector2 size, int index, Surface *bmp) ;
-	//void draw(double x, double y, int index, Frame *frame) ;
-	//void draw(double x, double y, int index, Surface *bmp) ;
-	//void draw(int x, int y, int w, int h, int index, Frame *frame) ;
-	//void draw(int x, int y, int w, int h, int index, Surface *bmp) ;
-	//void draw(int x, int y, int index, Frame *frame) ;
-	void draw(int x, int y, int index, Surface *bmp) ;
-
-	// added GEO
-	virtual void animate(Vector2 pos, int index, Frame *space, double scale = 1);
-	void animate_character(Vector2 pos, int index, int color, Frame *space, double scale = 1);
-
-
-	void draw_character(int x, int y, int index, int color, Surface *bmp);
-	void draw_character(int x, int y, int index, int color, Frame *space);
-	void draw_character(int x, int y, int w, int h, int index, int color, Surface *bmp);
-	void draw_character(int x, int y, int w, int h, int index, int color, Frame *space);
-
-	void generate_mipmaps();
-	void regenerate_mipmaps();
-
-	void permanent_phase_shift ( int index );
-
-	virtual void change_color_depth(int dest);
-
-	int collide(int x, int y, int i, int ox, int oy, int oi,
-			SpaceSprite *other);
-	int collide_ray(int lx1, int ly1, int *lx2, int *ly2, int sx, int sy,
-			int sindex);
-
-	INLINE int frames() const {return count;}
-	// changed Rob.
-	Vector2  size(int i = 0) const;//   const {return Vector2(b[0][i]->w, b[0][i]->h);}
-	int      width()  const {return w;}
-	int      height() const {return h;}
+  INLINE int frames() const {return count;}
+  // changed Rob.
+  Vector2  size(int i = 0) const; 
+  int      width()  const {return w;}
+  int      height() const {return h;}
 };
 
-int string_to_sprite_attributes ( const char *s, int recommended = SpaceSprite::MASKED | SpaceSprite::MATCH_SCREEN_FORMAT | SpaceSprite::MIPMAPED) ;
+int string_to_sprite_attributes ( const char *s, int recommended = SpaceSprite::MASKED | SpaceSprite::MATCH_SCREEN_FORMAT | SpaceSprite::MIPMAPED);
 
-
-
-
-
-
-
-
 //melee/mship
 
 struct ShipClass {
@@ -554,21 +540,16 @@
 #define REGISTER_SHIP(ship) static Ship *get_shipclass_ ## ship (Vector2 pos, double a, ShipData *d, unsigned int c){return(new ship(pos,a,d,c));} static void __register_shipclass_ ## ship () {register_shipclass(#ship, __FILE__, &get_shipclass_ ## ship);} CALL_BEFORE_MAIN(__register_shipclass_ ## ship);
 
 
-//extern ShipData **shipdatas;
-//extern int num_shipdatas;
-//ShipData *shipdata( const char *file );
-
-
 struct ShipType {
-	const char *id;
-	const char *file;
-	const char *name;
-	const char *text;
-	int cost;
-	ShipData  *data;
-	ShipClass *code;
-	Ship *get_ship(Vector2 pos, double angle, unsigned int team);
-	int origin;
+  const char *id;
+  const char *file;
+  const char *name;
+  const char *text;
+  int cost;
+  ShipData  *data;
+  ShipClass *code;
+  Ship *get_ship(Vector2 pos, double angle, unsigned int team);
+  int origin;
 };
 extern ShipType *shiptypes;
 extern int num_shiptypes;
@@ -578,68 +559,69 @@
 //melee/mshpdata
 extern int auto_unload;
 
-ShipData *shipdata ( const char *file ) ;
+ShipData *shipdata ( std::string inifile ) ;
 void unload_all_ship_data() ;
-void unload_unused_ship_data() ;
 
-class ShipData {
-	enum { 
-		LOADED_NONE,
-		LOADED_FULL,
-		LOADED_PARTIAL,
-		LOADED_MINIMAL
-	};
-	int references;
-	public:
-	int status;
-	char *file;
-	void lock();
-	void unlock();
-	void load();
-	void unload();
-	DATAFILE    *data;
-//	int num_panel_bitmaps;
-//	Surface     **bitmapPanel;
-	SpaceSprite *spritePanel;
-	SpaceSprite *spriteShip;
-	SpaceSprite *spriteWeapon;
-	SpaceSprite *spriteWeaponExplosion;
-	SpaceSprite *spriteSpecial;
-	SpaceSprite *spriteSpecialExplosion;
-	SpaceSprite *spriteExtra;
-	SpaceSprite *spriteExtraExplosion;
+/*! \brief Sprites, samples - can be in loaded or unloaded state 
+  
+    Note: in future this class will contain only string to data files, all datas will
+    actully be in SoundSystem and VideoSystem classes
+*/ 
+class ShipData 
+{
+  enum { 
+    LOADED_NONE,
+    LOADED_FULL,
+    LOADED_PARTIAL,
+    LOADED_MINIMAL
+  };
+  int references;
+ public:
+  int status;
+  std::string ini;
 
-	int num_more_sprites;
-	SpaceSprite **more_sprites;
+  void lock();
+  void unlock();
+  void load();
+  void unload();
 
-	int num_weapon_samples;
-	Sound     **sampleWeapon;
-	int num_special_samples;
-	Sound     **sampleSpecial;
-	int num_extra_samples;
-	Sound     **sampleExtra;
+  SpaceSprite *spritePanel;
+  SpaceSprite *spriteShip;
+  SpaceSprite *spriteWeapon;
+  SpaceSprite *spriteWeaponExplosion;
+  SpaceSprite *spriteSpecial;
+  SpaceSprite *spriteSpecialExplosion;
+  SpaceSprite *spriteExtra;
+  SpaceSprite *spriteExtraExplosion;
+  
+  int num_more_sprites;
+  SpaceSprite **more_sprites;
+  
+  std::vector<std::string> sampleWeapon;
+  std::vector<std::string> sampleSpecial;
+  std::vector<std::string> sampleExtra;
+  
+  std::string moduleVictory;
+  
+  ShipData(std::string inifile);
+  ~ShipData();
+};
 
-	Music       *moduleVictory;
-
-	ShipData(const char *filename);
-	~ShipData();
-	};
-
 //gui.h
 class TW_Dialog_Player : public BaseClass {
 public:
-	struct DIALOG_PLAYER *player;
-	struct DIALOG *dialog;
-	struct BITMAP *subscreen;
-	int *old_sizes;
-	TW_Dialog_Player *prev_level;
-	int length, level, ifocus;
-	VideoWindow *window;
-	void init ( VideoWindow *window, DIALOG *dialog, int index = 0);
-	int update ();
-	void redraw ();
-	void deinit ();
-	virtual void _event( Event * e);
+  struct DIALOG_PLAYER *player;
+  struct DIALOG *dialog;
+  struct BITMAP *subscreen;
+  int *old_sizes;
+  TW_Dialog_Player *prev_level;
+  int length, level, ifocus;
+  VideoWindow *window;
+  void init ( VideoWindow *window, DIALOG *dialog, int index = 0);
+  int update ();
+  void redraw ();
+  void deinit ();
+  virtual void _event( Event * e);
 };
 struct DIALOG;
 int tw_do_dialog ( VideoWindow *window, DIALOG *d, int index );

Modified: branches/multiplayer-branch/source/other/dialogs.cpp
===================================================================
--- branches/multiplayer-branch/source/other/dialogs.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/other/dialogs.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -108,7 +108,20 @@
   { d_tw_yield_proc,   0,    0,    0,    0,    255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },
   { NULL,              0,    0,    0,    0,    255,  0,    0,    0,       0,    0,    NULL, NULL, NULL }
 };
+DIALOG tw_alert_dialog5[] = {
+  // (dialog proc)     (x)   (y)   (w)   (h)   (fg)  (bg)  (key) (flags)  (d1)  (d2)  (dp)
+  { d_agup_box_proc,        180,  170,  380,  140,  255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },
+  { d_agup_textbox_proc,    185,  175,  370,  95,   255,  0,    0,    0,       80,   0,    NULL, NULL, NULL },
+  { d_agup_button_proc,     190,  280,  55,   20,   255,  0,    0,    D_EXIT,  0,    0,    NULL, NULL, NULL },
+  { d_agup_button_proc,     255,  280,  55,   20,   255,  0,    0,    D_EXIT,  0,    0,    NULL, NULL, NULL },
+  { d_agup_button_proc,     320,  280,  55,   20,   255,  0,    0,    D_EXIT,  0,    0,    NULL, NULL, NULL },
+  { d_agup_button_proc,     385,  280,  55,   20,   255,  0,    0,    D_EXIT,  0,    0,    NULL, NULL, NULL },  
+  { d_agup_button_proc,     450,  280,  100,  20,   255,  0,    0,    D_EXIT,  0,    0,    NULL, NULL, NULL },
+  { d_tw_yield_proc,   0,    0,    0,    0,    255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },
+  { NULL,              0,    0,    0,    0,    255,  0,    0,    0,       0,    0,    NULL, NULL, NULL }
+};
 
+
 DIALOG selectDialog[] = {
 	// (dialog proc)     (x)   (y)   (w)   (h)   (fg)  (bg)  (key) (flags)  (d1)  (d2)  (dp)
 	{ my_list_proc,      5,     5,   280,  400,  255,  0,    0,    D_EXIT,  0,    0,    (void *)fleetListboxGetter, NULL, NULL },
@@ -264,13 +277,13 @@
 // MELEE_EX - dialog structure
 DIALOG melee_ex_dialog[] = {
   // (dialog proc)     (x)  (y)   (w)   (h)   (fg)  (bg)  (key) (flags)  (d1)  (d2)  (dp)
-  { d_shadow_box_proc, 40,  40,   240,  160,  255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },
+  { d_shadow_box_proc, 40,  40,   240,  185,  255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },
   { my_d_button_proc,  50,   50,  190,  20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Play Game" , NULL, NULL },
   { my_d_button_proc,  50,   75,  190,  20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Key Tester", NULL, NULL },
-//  { my_d_button_proc,  50,  100,  190,  20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Ship Info", NULL, NULL },
-  { my_d_button_proc,  50,  100,  190,  20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Show License", NULL, NULL },
-  { my_d_button_proc,  50,  125,  190,  20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Diagnostics", NULL, NULL },
-  { my_d_button_proc,  80,  150,  190,  30,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Main Menu", NULL, NULL },
+  { my_d_button_proc,  50,  100,  190,  20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Ship Info", NULL, NULL },
+  { my_d_button_proc,  50,  125,  190,  20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Show License", NULL, NULL },
+  { my_d_button_proc,  50,  150,  190,  20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Diagnostics", NULL, NULL },
+  { my_d_button_proc,  80,  175,  190,  30,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Main Menu", NULL, NULL },
   { d_tw_yield_proc,   0,   0,    0,    0,    255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },
   { NULL,              0,   0,    0,    0,    255,  0,    0,    0,       0,    0,    NULL, NULL, NULL }
 };

Modified: branches/multiplayer-branch/source/other/dialogs.h
===================================================================
--- branches/multiplayer-branch/source/other/dialogs.h	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/other/dialogs.h	2004-09-28 19:53:03 UTC (rev 71)
@@ -72,6 +72,7 @@
 extern DIALOG tw_alert_dialog2[];
 extern DIALOG tw_alert_dialog3[];
 extern DIALOG tw_alert_dialog4[];
+extern DIALOG tw_alert_dialog5[];
 
 enum {
 	SELECT_DIALOG_LIST = 0,

Copied: branches/multiplayer-branch/source/other/gup.cpp (from rev 69, trunk/source/other/gup.cpp)

Copied: branches/multiplayer-branch/source/other/gup.h (from rev 69, trunk/source/other/gup.h)

Modified: branches/multiplayer-branch/source/other/nullphas.cpp
===================================================================
--- branches/multiplayer-branch/source/other/nullphas.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/other/nullphas.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "melee.h"
-REGISTER_FILE
 #include "melee/mgame.h"
 #include "nullphas.h"
 
@@ -25,11 +24,13 @@
   oship->size, unit_vector( oship->get_angle()) * PHASE_MAX * oship->size,
   oship, oship->get_sprite(), oship->get_sprite_index(), hot_color, HOT_COLORS,
   PHASE_DELAY, PHASE_MAX, PHASE_DELAY ){
+  STACKTRACE;
 }
 
-void NullPhaser::animate( Frame* space ){}
+void NullPhaser::animate( Frame* space ){
+  STACKTRACE;}
 void NullPhaser::calculate(){
-	STACKTRACE
+  STACKTRACE;
 
   if( state > 0 ){
     game->add( ship );

Modified: branches/multiplayer-branch/source/other/objanim.cpp
===================================================================
--- branches/multiplayer-branch/source/other/objanim.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/other/objanim.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "melee.h"
-REGISTER_FILE
 
 #include "objanim.h"
 
@@ -26,6 +25,7 @@
 Animation( creator, opos, osprite, first_frame, num_frames, frame_size, depth ),
   angle(oangle)
 {
+  STACKTRACE;
   vel = ovel;
 
   sprite_index = get_index(angle);
@@ -33,7 +33,7 @@
 }
 
 void ObjectAnimation::calculate(){
-	STACKTRACE
+  STACKTRACE;
 
   sprite_index >>= 6;
   Animation::calculate();

Modified: branches/multiplayer-branch/source/other/orbit.cpp
===================================================================
--- branches/multiplayer-branch/source/other/orbit.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/other/orbit.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -18,7 +18,6 @@
 #include <stdio.h>
 #include <allegro.h>
 #include "melee.h"
-REGISTER_FILE
 #include "id.h"
 #include "scp.h"
 #include "frame.h"
@@ -46,7 +45,7 @@
 
 int SpaceStation::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	Crew-=(int)(normal+direct);
 	if(Crew<=0) state=0;
@@ -55,7 +54,7 @@
 
 void SpaceStation::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	//Healing beam code
 
@@ -75,6 +74,7 @@
 SpaceStation::SpaceStation(SpaceLocation *creator, Vector2 opos,
 	SpaceSprite *oSprite):SpaceObject(creator,opos,0.,oSprite)
 {
+  STACKTRACE;
 //	layer=LAYER_SPECIAL;
 	mass=10.;
 	Crew=2000;
@@ -87,6 +87,7 @@
 	double lrad, double lspeed, int iLock):SpaceLocation(creator,
 	lpos, 0.)
 {
+  STACKTRACE;
 	id=ORBIT_ID;
 	ipos=lpos;
 	Lock=iLock;
@@ -104,7 +105,7 @@
 
 void OrbitHandler::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if((sun==NULL)||(plan==NULL))
 		return;
@@ -143,6 +144,7 @@
 
 int OrbitHandler::canCollide(SpaceLocation *other)
 {
+  STACKTRACE;
 	return FALSE;
 }
 
@@ -150,6 +152,7 @@
 	:
 	SpaceObject(NULL, opos, 0.0, sprite)
 	{
+  STACKTRACE;
 
 	layer = LAYER_SHOTS;
 	set_depth(LAYER_EXPLOSIONS);
@@ -176,7 +179,7 @@
 
 int Sun::canCollide(SpaceLocation *other)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if(other->id==COMET_ID) return FALSE;
 	return(!other->isPlanet());
@@ -184,7 +187,7 @@
 
 void Sun::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	double d = distance(other);
 	if (d >= Range) return;
@@ -196,7 +199,7 @@
 }
 
 void Sun::calculate() {
-	STACKTRACE
+  STACKTRACE;
 
 	SpaceObject::calculate();
 	SpaceObject *o;

Modified: branches/multiplayer-branch/source/other/planet3d.cpp
===================================================================
--- branches/multiplayer-branch/source/other/planet3d.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/other/planet3d.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -17,7 +17,6 @@
 
 
 #include "ship.h"
-REGISTER_FILE
 #include "melee/mview.h"
 
 #include "util/pmask.h"
@@ -31,6 +30,7 @@
 
 SpaceSprite::SpaceSprite(BITMAP *image, int _attributes)
 {
+  STACKTRACE;
   if (_attributes == -1) 
     _attributes = string_to_sprite_attributes(NULL);
   general_attributes = _attributes;
@@ -71,8 +71,8 @@
     
   // create a 2D planet
   Planet *planet = new Planet (position, 
-			       meleedata.planetSprite, 
-			       random(meleedata.planetSprite->frames()));
+			       game->meleedata.planetSprite, 
+			       random(game->meleedata.planetSprite->frames()));
   game->add (planet);
   return planet;
 }

Modified: branches/multiplayer-branch/source/other/radar.cpp
===================================================================
--- branches/multiplayer-branch/source/other/radar.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/other/radar.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -17,7 +17,6 @@
 
 #include <allegro.h>
 #include "melee.h"
-REGISTER_FILE
 #include "id.h"
 #include "scp.h"
 #include "frame.h"
@@ -33,16 +32,19 @@
 
 void ZRadar::toggleActive()
 {
+  STACKTRACE;
 	active^=1;
 }
 
 void ZRadar::setSize(double Size)
 {
+  STACKTRACE;
 	size=Size;
 }
 
 void ZRadar::setTarget(SpaceLocation *target)
 {
+  STACKTRACE;
 	t=target;
 }
 
@@ -53,6 +55,7 @@
 
 ZRadar::ZRadar(BITMAP *BlankSlate, Presence *target, double Size)
 {
+  STACKTRACE;
 	Blank=BlankSlate;
 	Painted = create_bitmap_ex(bitmap_color_depth(screen),Blank->w,Blank->h);
 	t=target;
@@ -63,13 +66,14 @@
 
 double ZRadar::shiftscale(double r_center, double v_center, double scale, double n)
 {
+  STACKTRACE;
 	//Used to scale game coordinates onto RADAR screen coordinates
 	return(((n - r_center)*scale)+v_center);
 }
 
 void ZRadar::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	//If the radar is disabled, don't do anything.
 	if(active==FALSE) return;

Modified: branches/multiplayer-branch/source/other/shippart.cpp
===================================================================
--- branches/multiplayer-branch/source/other/shippart.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/other/shippart.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -18,7 +18,6 @@
 
 #include "ship.h"
 #include "melee/mview.h"
-REGISTER_FILE
 
 #include <stdio.h>
 
@@ -34,6 +33,7 @@
 :
 Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 	// remove this from the physics interaction
 	//mass = 0;
 	collide_flag_anyone = 0;
@@ -46,7 +46,7 @@
 
 void BigShip::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	// make sure the "ship" is not a real target
 	if (targets->isintargetlist(this))
@@ -71,7 +71,7 @@
 // change velocities of the ship and all its parts
 void BigShip::change_vel(Vector2 dvel)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	int i;
 
@@ -89,7 +89,7 @@
 // change positions of the ship and all its parts
 void BigShip::change_pos(Vector2 dpos)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	int i;
 
@@ -107,6 +107,7 @@
 
 void BigShip::animate(Frame *space)
 {
+  STACKTRACE;
 	return;
 }
 
@@ -121,6 +122,7 @@
 :
 Ship(aowner, 0, 0, spr)
 {
+  STACKTRACE;
 	owner = aowner;
 	relpos = orelpos;
 	relangle = orelangle;
@@ -165,7 +167,7 @@
 
 void BigShipPart::syncpos()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	// maintain (relative) position wrt the ship
 	angle = owner->angle + relangle;	// this is the discrete angle (64 values).
@@ -187,7 +189,7 @@
 
 void BigShipPart::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if ( !(owner && owner->exists()) )
 	{
@@ -233,7 +235,7 @@
 
 int BigShipPart::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	// by default, transmit damage to the ship owner ...
 	return owner->handle_damage(source, normal, direct);
@@ -243,7 +245,7 @@
 
 void BigShipPart::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	Ship::inflict_damage(other);
 
@@ -255,6 +257,7 @@
 
 bool BigShipPart::isdisabled()
 {
+  STACKTRACE;
 	return false;
 }
 
@@ -263,7 +266,7 @@
 // change velocities of the ship and all its parts
 void BigShipPart::change_vel(Vector2 dvel)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	owner->change_vel(dvel);
 }
@@ -271,7 +274,7 @@
 // change positions of the ship and all its parts
 void BigShipPart::change_pos(Vector2 dpos)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	owner->change_pos(dpos);
 }
@@ -283,6 +286,7 @@
 :
 SpaceObject(aownerpart, aownerpart->pos, aownerpart->angle, ospr)
 {
+  STACKTRACE;
 	ownerpart = aownerpart;
 
 	layer = LAYER_SHIPS;
@@ -301,7 +305,7 @@
 
 void BigShipPartDevice::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if ( !(ownerpart && ownerpart->exists()) )
 	{
@@ -323,7 +327,7 @@
 
 void BigShipPartDevice::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if (ownerpart->isdisabled())
 		return;
@@ -335,7 +339,7 @@
 
 int BigShipPart::handle_fuel_sap(SpaceLocation *source, double normal)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	return owner->handle_fuel_sap(source, normal);
 }
@@ -344,6 +348,7 @@
 
 ShipType *BigShipPart::get_shiptype()
 {
+  STACKTRACE;
 	// this is necessary, otherwise the Kat Poly ship crashes.
 	// also, "type" cannot be redirected inside the constructor, cause the
 	// parents' type is declared outside of its constructor (bad?).

Modified: branches/multiplayer-branch/source/other/twconfig.cpp
===================================================================
--- branches/multiplayer-branch/source/other/twconfig.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/other/twconfig.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -28,16 +28,13 @@
 #include "melee/mfleet.h"
 #include "util/aastr.h"
 
-void tw_set_config_file(const char *filename)
+void tw_set_config_file(std::string filename)
 {
   std::string file = home_ini_full_path(filename); 
-  //if(exists(file.c_str()))
-    set_config_file(file.c_str());
-  //  else
-  //  tw_error("File %s does not exist", file.c_str());
+  set_config_file(file.c_str());
 }
 
-int tw_delete_file(const char * filename)
+int tw_delete_file(std::string filename)
 {
   return delete_file(home_ini_full_path(filename).c_str());
 }
@@ -56,7 +53,8 @@
   char *item;
   char *section;
   char file[1024];
-  if (strlen(name) > 1000) error("_get_ini_string - name too long");
+  if (strlen(name) > 1000) 
+    tw_error("_get_ini_string - name too long");
   strncpy (file, name, 1000);
   char *_slash[2];
   _slash[0] = strchr(file, '/');
@@ -95,7 +93,8 @@
   char *item;
   char *section;
   char file[1024];
-  if (strlen(name) > 1000) error("_set_ini_string - name too long");
+  if (strlen(name) > 1000) 
+    tw_error("_set_ini_string - name too long");
   strncpy (file, name, 1000);
   char *_slash[2];
   _slash[0] = strchr(file, '/');
@@ -141,7 +140,8 @@
       //else if (!strncmp(item, "/dev/", 5)) type = DEV;
       else if (!strncmp(item, "/ini/", 5)) type = INI;
       else if (!strncmp(item, "/cfg/", 5)) type = CFG;
-      else error("twconfig_get_string - unknown prefix");
+      else 
+	tw_error("twconfig_get_string - unknown prefix");
     }
   else type = NORMAL;
   ConfigEvent ce;
@@ -186,10 +186,12 @@
   if (*item == '/') 
     {
       if (0) ;
-      //else if (!strncmp(item, "/dev/", 5)) type = DEV;
-      else if (!strncmp(item, "/ini/", 5)) type = INI;
-      else if (!strncmp(item, "/cfg/", 5)) type = CFG;
-      else error("twconfig_get_string - unknown prefix");
+      else if (!strncmp(item, "/ini/", 5)) 
+	type = INI;
+      else if (!strncmp(item, "/cfg/", 5)) 
+	type = CFG;
+      else 
+	tw_error("twconfig_get_string - unknown prefix");
     }
   else type = NORMAL;
   ConfigEvent ce;

Modified: branches/multiplayer-branch/source/other/twconfig.h
===================================================================
--- branches/multiplayer-branch/source/other/twconfig.h	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/other/twconfig.h	2004-09-28 19:53:03 UTC (rev 71)
@@ -17,9 +17,11 @@
 
 #ifndef TWCONFIG_H
 
-void tw_set_config_file(const char * filename);
-int tw_delete_file(const char * filename);
+#include <string>
 
+void tw_set_config_file(std::string filename);
+int tw_delete_file(std::string filename);
+
 const char *twconfig_get_string (const char *item);
 //string destroyed by next call to twconfig_get_*
 void   twconfig_set_string (const char *item, const char *value);
@@ -28,4 +30,6 @@
 void   twconfig_set_float ( const char *item, double value );
 double twconfig_get_float ( const char *item );
 
+std::string make_name_by_index (int index, std::string name, std::string ext );
+
 #endif // TWCONFIG_H

Modified: branches/multiplayer-branch/source/other/vbodies.cpp
===================================================================
--- branches/multiplayer-branch/source/other/vbodies.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/other/vbodies.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -15,13 +15,13 @@
 GNU General Public License for more details.
 */
 
+#include "util/sound.h"
 #include <allegro.h>
 #include <string.h>
 #include <stdio.h>
 
 
 #include "melee.h"
-REGISTER_FILE
 #include "id.h"
 #include "scp.h"
 #include "frame.h"
@@ -206,17 +206,21 @@
 
 //end sprite handling routines
 
-VSpaceInstallation::VSpaceInstallation():SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite)
+VSpaceInstallation::VSpaceInstallation():SpaceObject(NULL, random(map_size), 
+						     random(PI2), game->meleedata.asteroidSprite)
 {
+  STACKTRACE;
 	collide_flag_sameteam = ALL_LAYERS;
 	collide_flag_sameship = ALL_LAYERS;
 	layer = LAYER_CBODIES;
 	set_depth(DEPTH_ASTEROIDS);
 }
 
-void VSpaceInstallation::Initialize(void) {;}
+void VSpaceInstallation::Initialize(void) {
+  STACKTRACE;;}
 
 void VSpaceInstallation::Initialize(const char* nameInIni) {
+  STACKTRACE;
 	game->log_file ("vobject.ini");
   this->armour = get_config_float(nameInIni, "Armour", 0);
   this->mass = get_config_float(nameInIni, "Mass", 0);
@@ -224,6 +228,7 @@
 }
 
 bool VSpaceInstallation::AddInstallation(VGroundInstallation* oGI) {
+  STACKTRACE;
   int i;
   for(i=0;i<12;i++) {
     if(this->Installation[i]==NULL) {
@@ -237,10 +242,12 @@
 }
 
 void VSpaceInstallation::calculate(void) {
+  STACKTRACE;
 	this->vel *= (1 - this->friction * game->frame_time);
 }
 
 void VSpaceInstallation::death() {
+  STACKTRACE;
   int i;
   for(i=0;i<12;i++)
     if(this->Installation[i]!=NULL)
@@ -248,6 +255,7 @@
 }
 
 int VSpaceInstallation::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   message.print(500,5,"Installation armour=%d", (long int)armour);
   if(source->isAsteroid()) return(0);
   armour -= (normal + direct);
@@ -257,45 +265,54 @@
 
 
 VDefSat::VDefSat() {
+  STACKTRACE;
   this->set_sprite(VDefSat::mySprite);
   this->Initialize();
 }
 
 void VDefSat::Initialize(void) {
+  STACKTRACE;
   VSpaceInstallation::Initialize("DefSat");
 }
 
 VDeepSpaceOutpost::VDeepSpaceOutpost() {
+  STACKTRACE;
   this->set_sprite(VDeepSpaceOutpost::mySprite);
   this->Initialize();
 }
 
 void VDeepSpaceOutpost::Initialize() {
+  STACKTRACE;
   VSpaceInstallation::Initialize("DeepSpaceOutpost");
 
 }
 
 VDeepSpaceColony::VDeepSpaceColony() {
+  STACKTRACE;
   this->set_sprite(VDeepSpaceColony::mySprite);
   this->Initialize();
 }
 
 void VDeepSpaceColony::Initialize() {
+  STACKTRACE;
   VSpaceInstallation::Initialize("DeepSpaceColony");
 }
 
 VDeepSpaceStation::VDeepSpaceStation() {
+  STACKTRACE;
   this->set_sprite(VDeepSpaceStation::mySprite);
   this->Initialize();
 }
 
 void VDeepSpaceStation::Initialize() {
+  STACKTRACE;
   VSpaceInstallation::Initialize("DeepSpaceStation");
 }
 
 
 VGroundInstallation::VGroundInstallation(SpaceLocation* olocation):Presence()
 {
+  STACKTRACE;
   this->totalDamageTaken = 0;
   this->location = olocation;
   actionCounter = 0;
@@ -308,11 +325,13 @@
 
 void VGroundInstallation::Initialize(void)
 {
+  STACKTRACE;
   ;
 }
 
 void VGroundInstallation::Initialize(const char* nameInIni)
 {
+  STACKTRACE;
 	game->log_file ("vobject.ini");
   this->damageToDisable = get_config_float(nameInIni, "DamageToDisable", 0);
   this->damageToDestroy = get_config_float(nameInIni, "DamageToDestroy", 0);
@@ -322,6 +341,7 @@
 
 int VGroundInstallation::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   if(source->isPlanet()||source->isAsteroid()) return(0);
   this->totalDamageTaken += (normal + direct);
   message.print(350,5,"DamageTaken=%d", (long int)this->totalDamageTaken);
@@ -342,6 +362,7 @@
 
 void VGroundInstallation::calculate(void)
 {
+  STACKTRACE;
   if(!this->isFunctioning)return;
   Presence::calculate();
   actionCounter += ((double)frame_time / 1000.0) * this->actionsPerSecond;
@@ -355,47 +376,57 @@
 
 bool VGroundInstallation::BattleAction(void)
 {
+  STACKTRACE;
   return(false);
 }
 
 VWilderness::VWilderness(SpaceLocation* olocation):VGroundInstallation(olocation) {
+  STACKTRACE;
   this->Initialize();
 }
 
 void VWilderness::Initialize(void)
 {
+  STACKTRACE;
   VGroundInstallation::Initialize("Wilderness");
 }
 
 
 VColony::VColony(SpaceLocation* olocation):VGroundInstallation(olocation) {
+  STACKTRACE;
   this->Initialize();
 }
 
 void VColony::Initialize(void)
 {
+  STACKTRACE;
   VGroundInstallation::Initialize("Colony");
 }
 
 VMine::VMine(SpaceLocation* olocation):VGroundInstallation(olocation) {
+  STACKTRACE;
   this->Initialize();
 }
 
 void VMine::Initialize(void)
 {
+  STACKTRACE;
   VGroundInstallation::Initialize("Mine");
 }
 
 VFortification::VFortification(SpaceLocation* olocation):VGroundInstallation(olocation) {
+  STACKTRACE;
   this->Initialize();
 }
 
 void VFortification::Initialize(void)
 {
+  STACKTRACE;
   VGroundInstallation::Initialize("Fortification");
 }
 
 VPlanetaryShield::VPlanetaryShield(SpaceLocation* olocation):VGroundInstallation(olocation) {
+  STACKTRACE;
   this->Initialize();
   this->isFunctioning = true;
   this->isDestroyed = false;
@@ -405,6 +436,7 @@
 
 void VPlanetaryShield::Initialize(void)
 {
+  STACKTRACE;
   VGroundInstallation::Initialize("PlanetaryShield");
   this->maxShield = get_config_float("PlanetaryShield", "Shield", 0);
   this->currentShield = maxShield;
@@ -412,6 +444,7 @@
 }
 
 int VPlanetaryShield::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   if(this->currentShield>0) {
     this->currentShield -= (normal + direct);
     message.print(500,5,"Shield level=%d", (long int)this->currentShield);
@@ -422,6 +455,7 @@
 }
 
 void VPlanetaryShield::calculate(void) {
+  STACKTRACE;
   this->currentShield += ((double)frame_time / 1000) * this->shieldRegenerationPerSecond;
   if(this->currentShield>this->maxShield) this->currentShield=this->maxShield;
   if(this->currentShield<0) this->isShield = false;
@@ -430,6 +464,7 @@
 
 VGroundDefenseLaser::VGroundDefenseLaser(SpaceLocation* olocation):VGroundInstallation(olocation)
 {
+  STACKTRACE;
   this->Initialize();
   this->isFunctioning = true;
   this->isDestroyed = false;
@@ -438,6 +473,7 @@
 }
 
 void VGroundDefenseLaser::Initialize() {
+  STACKTRACE;
   VGroundInstallation::Initialize("PlanetaryDefenseLaser");
   weaponRange = scale_range(get_config_float("PlanetaryDefenseLaser", "LaserRange", 0));
   weaponColor = get_config_int("PlanetaryDefenseLaser", "LaserColor", 0);
@@ -446,6 +482,7 @@
 }
 
 bool VGroundDefenseLaser::BattleAction() {
+  STACKTRACE;
   Vector2 RelLoc;
   double ta;
 	SpaceObject *o = NULL;
@@ -483,6 +520,7 @@
 
 VGroundIonCannon::VGroundIonCannon(SpaceLocation* olocation):VGroundInstallation(olocation)
 {
+  STACKTRACE;
   this->Initialize();
   this->isFunctioning = true;
   this->isDestroyed = false;
@@ -492,6 +530,7 @@
 }
 
 void VGroundIonCannon::Initialize() {
+  STACKTRACE;
   VGroundInstallation::Initialize("PlanetaryIonCannon");
   weaponRange = scale_range(get_config_float("PlanetaryIonCannon", "CannonRange", 0));
   weaponVelocity = scale_velocity(get_config_float("PlanetaryIonCannon", "CannonSpeed", 0));
@@ -500,6 +539,7 @@
 }
 
 bool VGroundIonCannon::BattleAction(void) {
+  STACKTRACE;
   //double rAnticipated;
   Vector2 RelLoc;
 
@@ -529,6 +569,7 @@
 
 VGroundMissileLauncher::VGroundMissileLauncher(SpaceLocation* olocation):VGroundInstallation(olocation)
 {
+  STACKTRACE;
   this->Initialize();
   this->isFunctioning = true;
   this->isDestroyed = false;
@@ -538,6 +579,7 @@
 }
 
 void VGroundMissileLauncher::Initialize() {
+  STACKTRACE;
   VGroundInstallation::Initialize("PlanetaryMissileLauncher");
   weaponRange = scale_range(get_config_float("PlanetaryMissileLauncher", "MissileRange", 0));
   weaponVelocity = scale_velocity(get_config_float("PlanetaryMissileLauncher", "MissileSpeed", 0));
@@ -547,6 +589,7 @@
 }
 
 bool VGroundMissileLauncher::BattleAction(void) {
+  STACKTRACE;
   Vector2 RelLoc;
 
 	SpaceObject *o = NULL;
@@ -570,8 +613,9 @@
 }
 
 
-VSpaceMine::VSpaceMine():SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite)
+VSpaceMine::VSpaceMine():SpaceObject(NULL, random(map_size), random(PI2), game->meleedata.asteroidSprite)
 {
+  STACKTRACE;
   this->set_sprite(VSpaceMine::mySprite);
   this->explosionSprite = VSpaceMine::explosionSprite;
   Initialize();
@@ -585,12 +629,14 @@
 }
 
 void VSpaceMine::death(void) {
+  STACKTRACE;
   this->animateExplosion();
   SpaceObject::death();
   if(this->willRespawn) game->add(new VSpaceMine());
 }
 
 void VSpaceMine::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   Vector2 V;
   if(!other->isShip()) return; //only damages ships!!!
   this->damage_factor = this->damage;
@@ -602,6 +648,7 @@
 
 int VSpaceMine::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   if(source->isLine()||source->isShot()) {
     armour -= normal + direct;
     if(armour<0) state = 0;
@@ -612,6 +659,7 @@
 }
 
 void VSpaceMine::Initialize() {
+  STACKTRACE;
 	game->log_file ("vobject.ini");
   this->sprite_index = 0;
   this->armour = get_config_float("SpaceMine", "Armour", 0);
@@ -620,6 +668,7 @@
 }
 
 void VSpaceMine::animateExplosion(void) {
+  STACKTRACE;
 //	Animation(SpaceLocation *creator, Vector2 opos, SpaceSprite *osprite, 
 //			int first_frame, int num_frames, int frame_size, double depth, double scale = 1.0) ;
 	game->add(new Animation(this, normal_pos(),
@@ -628,45 +677,70 @@
 	return;
 }
 
-void VSpaceMine::soundExplosion(void) {
-  if(damage_factor > 0) {
-		int i = iround_down(damage_factor / 2);
-		if(i >= BOOM_SAMPLES) i = BOOM_SAMPLES - 1;
-		play_sound((SAMPLE *)(melee[MELEE_BOOM + i].dat));
+void VSpaceMine::soundExplosion(void) 
+{
+  STACKTRACE;
+  if(damage_factor > 0) 
+    {
+      int i = iround_down(damage_factor / 2);
+      if(i >= BOOM_SAMPLES) i = BOOM_SAMPLES - 1;
+      switch(i)
+	{
+	case 0:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+	  break;
+	case 1:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+	  break;
+	case 2:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+	  break;
+	case 3:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+	  break;
+	default:
+	  {
+	    tw_error("Unknown BOOM sound");
+	  }
 	}
-	return;
+    }
+  return;
 }
 
 
 
 VNebula::VNebula():Presence()
 {
+  STACKTRACE;
 //  game->all_damage_direct = true;
 //  game->is_nebula = true;
   friction = 0.0004;
-	videosystem.color_effects = VNebulaColorEffects;
-	videosystem.update_colors();
+	videosystem->color_effects = VNebulaColorEffects;
+	videosystem->update_colors();
 }
 
 VNebula::VNebula(double ofriction):Presence()
 {
+  STACKTRACE;
 //  game->all_damage_direct = true;
   friction = ofriction;
-	videosystem.color_effects = VNebulaColorEffects;
-	videosystem.update_colors();
+	videosystem->color_effects = VNebulaColorEffects;
+	videosystem->update_colors();
 
 }
 
 VNebula::VNebula(double ofriction, int oionStorms):Presence()
 {
+  STACKTRACE;
 //  game->all_damage_direct = true;
   friction = ofriction; 
   ionStorms = oionStorms;
-	videosystem.color_effects = VNebulaColorEffects;
-	videosystem.update_colors();
+  videosystem->color_effects = VNebulaColorEffects;
+  videosystem->update_colors();
 }
 
 void VNebula::calculate(void) {
+  STACKTRACE;
   Presence::calculate();
   
   for(std::list<SpaceLocation*>::iterator i=game->item.begin();i!=game->item.end();i++)
@@ -683,24 +757,21 @@
 }
 
 VNebula::~VNebula() {
-//  game->all_damage_direct = false;
-//  game->is_nebula = false;
-  videosystem.color_effects = gamma_color_effects;
-	videosystem.update_colors();
+  videosystem->color_effects = gamma_color_effects;
+  videosystem->update_colors();
 }
 
-VIonStorm::VIonStorm(void):SpaceObject(NULL, Vector2(0,0), 0, NULL) {
-//	SpaceObject(SpaceLocation *creator, Vector2 opos, double oangle, 
-//			SpaceSprite *osprite);
-
-  ;
+VIonStorm::VIonStorm(void):SpaceObject(NULL, Vector2(0,0), 0, NULL) 
+{
+  STACKTRACE;
 }
 
 
 VDustCloud::VDustCloud(void)
 :
-SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite)
+SpaceObject(NULL, random(map_size), random(PI2), game->meleedata.asteroidSprite)
 {
+  STACKTRACE;
   double speed, angle;
   this->velocityRestoreFactor = 0.00;
   this->mass = 0;
@@ -719,6 +790,7 @@
 }
 
 void VDustCloud::Initialize(const char* nameInIni) {
+  STACKTRACE;
 	game->log_file ("vobject.ini");
   this->sprite_index = 0;
 	mass = get_config_int(nameInIni, "Mass", 0);
@@ -732,10 +804,12 @@
 }
 
 void VDustCloud::Initialize(void) {
+  STACKTRACE;
   Initialize("DustCloud");
 }
 
 int VDustCloud::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   if(source->isAsteroid()) return(0);
   if(source->isLine()||source->isShot()) {
     armour -= (normal + direct);
@@ -746,6 +820,7 @@
 }
 
 void VDustCloud::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   Vector2 relV;
   double excessSpeed;
   double d;
@@ -769,11 +844,13 @@
 }
 
 void VDustCloud::death(void) {
+  STACKTRACE;
   SpaceObject::death();
   if(this->willRespawn) game->add(new VDustCloud());
 }
 
 void VDustCloud::calculate(void) {
+  STACKTRACE;
   double x;
   x = (double)frame_time * this->velocityRestoreFactor;
   if(x>1)x=1;
@@ -784,8 +861,9 @@
 
 VGasCloud::VGasCloud(void)
 :
-SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite)
+SpaceObject(NULL, random(map_size), random(PI2), game->meleedata.asteroidSprite)
 {
+  STACKTRACE;
   double speed, angle;
   this->velocityRestoreFactor = 0.00;
   this->mass = 0;
@@ -805,6 +883,7 @@
 }
 
 void VGasCloud::Initialize(const char* nameInIni) {
+  STACKTRACE;
 	game->log_file ("vobject.ini");
   this->sprite_index = 0;
 	mass = get_config_int(nameInIni, "Mass", 0);
@@ -823,10 +902,12 @@
 }
 
 void VGasCloud::Initialize(void) {
+  STACKTRACE;
   Initialize("GasCloud");
 }
 
 int VGasCloud::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   if(isEnergized = false) {
     this->damageFactor=0;
     this->damage_factor=0;
@@ -848,6 +929,7 @@
 }
 
 void VGasCloud::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   if(this->damageFactor>0.001) {
     //message.print(500,5,"energizing damage");
     damage(other, this->energizingDamageFactor * this->damageFactor / 2, this->energizingDamageFactor * this->damageFactor / 2);
@@ -864,6 +946,7 @@
 }
 
 void VGasCloud::calculate(void) {
+  STACKTRACE;
   double x;
   if(this->isEnergized) {
     this->isEnergized = false;
@@ -881,6 +964,7 @@
 }
 
 void VGasCloud::death(void) {
+  STACKTRACE;
   SpaceObject::death();
   if(this->willRespawn) game->add(new VGasCloud());
 }
@@ -890,6 +974,7 @@
 :
 Planet(Vector2(0,0), VMoon::mySprite, 0) // a sprite is needed to avoid a crash...WTF?
 {
+  STACKTRACE;
   int i;
   for(i=0; i<12; i++) this->Installation[i]=NULL;
   this->id = ID_PLANET;
@@ -897,16 +982,19 @@
 }
 
 double VPlanet::getRadius(void) {
+  STACKTRACE;
   return(((this->size.x + this->size.y) / 4) / 1000);
 }
 
 
 void VPlanet::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   Planet::inflict_damage(other);
 }
 
 int VPlanet::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   int i,j;
   for(i=0;i<12;i++) {
     if(this->Installation[i]!=NULL)
@@ -946,6 +1034,7 @@
 
 void VPlanet::Initialize(const char* nameInIni)
 {
+  STACKTRACE;
 	game->log_file ("vobject.ini");
   this->sprite_index = 0;
 	gravity_mindist = scale_range(get_config_float(nameInIni, "GravityMinDist", 0));
@@ -958,6 +1047,7 @@
 }
 
 bool VPlanet::AddInstallation(VGroundInstallation* oGI) {
+  STACKTRACE;
   int i;
   for(i=0;i<12;i++) {
     if(this->Installation[i]==NULL) {
@@ -970,6 +1060,7 @@
 }
 
 void VPlanet::death() {
+  STACKTRACE;
   int i;
   for(i=0;i<12;i++)
     if(this->Installation[i]!=NULL)
@@ -977,6 +1068,7 @@
 }
 
 void VStar::AttractShots(int warping_power, double intensity) {
+  STACKTRACE;
   //sort of like gravity, but no minimum distance
   //and only changes direction, not speed.
   //only affects massless objects.
@@ -1037,6 +1129,7 @@
 :
 Planet(Vector2(0,0), VBrownDwarf::mySprite, 0) //sprite problem?
 {
+  STACKTRACE;
   this->id = ID_PLANET; // done for grav-whip purposes!!!!
   this->starEnergy = 0.0;
   this->angle = 0;
@@ -1054,11 +1147,13 @@
 }
 
 double VStar::getRadius(void) {
+  STACKTRACE;
   return((this->size.x + this->size.y) / 4);
 }
 
 
 void VStar::calculate() {
+  STACKTRACE;
   double r;
   double maxFlares;
   double flareFactor;
@@ -1094,6 +1189,7 @@
 }
 
 void VStar::LaunchFlare(double oangle, double oinitialVelocity, double orange, double odamage, double ofinalVelocity) {
+  STACKTRACE;
   ;// this SHOULD be overridden as needed by individual stars...?
   VRedFlare* VRF;
   VRF = new VRedFlare(this, oangle, oinitialVelocity, orange, odamage, ofinalVelocity);
@@ -1104,12 +1200,14 @@
 
 int VStar::canCollide(SpaceLocation *other)
 {
+  STACKTRACE;
   return(TRUE);
 	if(other->id==COMET_ID) return FALSE;
 	return(!other->isPlanet());
 }
 
 void VStar::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   double percentCoreDamage;
 
   double totalDamage;
@@ -1125,6 +1223,7 @@
 }
 
 int VStar::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return(0);
   /*int x;
   x = VStar::handle_damage(source, normal, direct);
@@ -1137,6 +1236,7 @@
 
 void VStar::Initialize(const char* nameInIni)
 {
+  STACKTRACE;
   starEnergy = 0.0;
 	game->log_file ("vobject.ini");
   this->sprite_index = 0;
@@ -1167,6 +1267,7 @@
 }
 
 bool VStar::isPlanet(void) {
+  STACKTRACE;
   return(true); // a kludge, should help grav-whip???
 }
 
@@ -1175,11 +1276,12 @@
 :
 Asteroid()
 {
+  STACKTRACE;
   this->set_sprite(mySprite);
   armour = VMetalShard::myArmour;
   damage_factor = VMetalShard::myDamage;
   mass = VMetalShard::myMass;
-  explosionSprite = meleedata.sparkSprite;
+  explosionSprite = game->meleedata.sparkSprite;
   mass = 1;
   this->willRespawn = FALSE;
 }
@@ -1188,13 +1290,14 @@
 :
 Asteroid()
 {
+  STACKTRACE;
   if(VMetalShard::mySprite==NULL) {
     ;
   }
   this->set_sprite(mySprite);
   armour = VMetalShard::myArmour;
   damage_factor = VMetalShard::myArmour;
-  explosionSprite = meleedata.sparkSprite;
+  explosionSprite = game->meleedata.sparkSprite;
   mass = VMetalShard::myMass;
   //
   this->pos = pos;
@@ -1203,6 +1306,7 @@
 
 
 int VMetalShard::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	if (!exists()) return 0;
 	if ((normal > 0) || (direct > 0)) {
 		armour -= normal;
@@ -1219,6 +1323,7 @@
 }
 
 void VMetalShard::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if (!other->exists()) return;
 	damage(other, 0, damage_factor);
   if(other->isShip()) ((Ship*)other)->update_panel=1;
@@ -1229,6 +1334,7 @@
 }
 
 void VMetalShard::animateExplosion(void) {
+  STACKTRACE;
 	game->add(new Animation(this, normal_pos(),
     explosionSprite, 0, 10,
     scale_frames(0), DEPTH_EXPLOSIONS));
@@ -1236,20 +1342,43 @@
 }
 
 void VMetalShard::soundExplosion(void) {
-  if(damage_factor > 0) {
-		int i = iround_down(damage_factor / 2);
-		if(i >= BOOM_SAMPLES) i = BOOM_SAMPLES - 1;
-		play_sound((SAMPLE *)(melee[MELEE_BOOM + i].dat));
+  STACKTRACE;
+  if(damage_factor > 0) 
+    {
+      int i = iround_down(damage_factor / 2);
+      if(i >= BOOM_SAMPLES) i = BOOM_SAMPLES - 1;
+      
+      switch(i)
+	{
+	case 0:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+	  break;
+	case 1:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+	  break;
+	case 2:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+	  break;
+	case 3:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+	  break;
+	default:
+	  {
+	    tw_error("Unknown BOOM sound");
+	  }
 	}
-	return;
+    }
+  return;
 }
 
 void VMetalShard::death(void) {
+  STACKTRACE;
   SpaceObject::death();
   if(this->willRespawn) game->add(new VMetalShard());
 }
 
 void VMetalShard::compareSprites(void) {
+  STACKTRACE;
   if(this->sprite==this->mySprite) {
     tw_error("Identical sprites");
   }
@@ -1262,15 +1391,17 @@
 :
 Asteroid()
 {
+  STACKTRACE;
   this->set_sprite(mySprite);
   armour = VMetalAsteroid::myArmour;
   damage_factor = VMetalAsteroid::myDamage;
-  explosionSprite = meleedata.sparkSprite;
+  explosionSprite = game->meleedata.sparkSprite;
   mass = VMetalAsteroid::myMass;
   this->willRespawn = TRUE;
 }
 
-int VMetalAsteroid::handle_damage(SpaceLocation *source, double normal, double direct) {STACKTRACE
+int VMetalAsteroid::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
   Vector2 V;
   //tw_error("about to handle damage");
 	if (!exists()) return 0;
@@ -1295,7 +1426,8 @@
 	return 1;
 }
 
-void VMetalAsteroid::inflict_damage(SpaceObject *other) {STACKTRACE
+void VMetalAsteroid::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
   //tw_error("about to inflict damage");
 	if (!other->exists()) return;
 	damage(other, 0, damage_factor);
@@ -1307,6 +1439,7 @@
 }
 
 void VMetalAsteroid::animateExplosion(void) {
+  STACKTRACE;
 	game->add(new Animation(this, normal_pos(),
     explosionSprite, 0, 10,
     scale_frames(0), DEPTH_EXPLOSIONS));
@@ -1314,16 +1447,38 @@
 
 }
 
-void VMetalAsteroid::soundExplosion(void) {
-  if(damage_factor > 0) {
-		int i = iround_down(damage_factor / 2);
-		if(i >= BOOM_SAMPLES) i = BOOM_SAMPLES - 1;
-		play_sound((SAMPLE *)(melee[MELEE_BOOM + i].dat));
-	}
-	return;
+void VMetalAsteroid::soundExplosion(void) 
+{
+  STACKTRACE;
+  if(damage_factor > 0) 
+    {
+      int i = iround_down(damage_factor / 2);
+      if(i >= BOOM_SAMPLES) i = BOOM_SAMPLES - 1;
+      switch(i)
+	{
+	case 0:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+	  break;
+	case 1:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+	  break;
+	case 2:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+	  break;
+	case 3:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+	  break;
+	default:
+	  {
+	    tw_error("Unknown BOOM sound");
+	  }
+	}    
+    }
+  return;
 }
 
 void VMetalAsteroid::death(void) {
+  STACKTRACE;
   VMetalShard* VS;
   Vector2 Loc, UV;
   int i;
@@ -1353,10 +1508,11 @@
 :
 Asteroid()
 {
+  STACKTRACE;
   this->set_sprite(mySprite);
   armour = VSmallAsteroid::myArmour;
   damage_factor = VSmallAsteroid::damage_factor;
-  explosionSprite = meleedata.sparkSprite;
+  explosionSprite = game->meleedata.sparkSprite;
   mass = VSmallAsteroid::mass;
   willRespawn = TRUE;
 }
@@ -1365,10 +1521,11 @@
 :
 Asteroid()
 {
+  STACKTRACE;
   this->set_sprite(mySprite);
   armour = 10;
   damage_factor = 0;
-  explosionSprite = meleedata.sparkSprite;
+  explosionSprite = game->meleedata.sparkSprite;
   mass = 10;
   //
   this->pos = pos;
@@ -1377,6 +1534,7 @@
 
 
 int VSmallAsteroid::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	Vector2 V;
   if (!exists()) return 0;
 	if ((normal > 0) || (direct > 0)) {
@@ -1401,6 +1559,7 @@
 }
 
 void VSmallAsteroid::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if (!other->exists()) return;
 	damage(other, 0, damage_factor);
   if(other->isShip()) ((Ship*)other)->update_panel=1;
@@ -1411,6 +1570,7 @@
 }
 
 void VSmallAsteroid::animateExplosion(void) {
+  STACKTRACE;
 	game->add(new Animation(this, normal_pos(),
     explosionSprite, 0, 10,
     scale_frames(0), DEPTH_EXPLOSIONS));
@@ -1419,15 +1579,36 @@
 }
 
 void VSmallAsteroid::soundExplosion(void) {
-  if(damage_factor > 0) {
-		int i = iround_down(damage_factor / 2);
-		if(i >= BOOM_SAMPLES) i = BOOM_SAMPLES - 1;
-		play_sound((SAMPLE *)(melee[MELEE_BOOM + i].dat));
+  STACKTRACE;
+  if(damage_factor > 0) 
+    {
+      int i = iround_down(damage_factor / 2);
+      if(i >= BOOM_SAMPLES) i = BOOM_SAMPLES - 1;
+      switch(i)
+	{
+	case 0:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+	  break;
+	case 1:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+	  break;
+	case 2:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+	  break;
+	case 3:
+	  tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+	  break;
+	default:
+	  {
+	    tw_error("Unknown BOOM sound");
+	  }
 	}
-	return;
+    }
+  return;
 }
 
 void VSmallAsteroid::death(void) {
+  STACKTRACE;
   SpaceObject::death();
   if(this->willRespawn) game->add(new VSmallAsteroid());
 
@@ -1437,15 +1618,17 @@
 :
 Asteroid()
 {
+  STACKTRACE;
   this->set_sprite(mySprite);
   armour = VLargeAsteroid::myArmour;
   damage_factor = VLargeAsteroid::myDamage;
-  explosionSprite = meleedata.sparkSprite;
+  explosionSprite = game->meleedata.sparkSprite;
   mass = VLargeAsteroid::myMass;
   willRespawn = TRUE;
 }
 
 int VLargeAsteroid::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
   Vector2 V;
 	if (!exists()) return 0;
 	if ((normal > 0) || (direct > 0)) {
@@ -1472,6 +1655,7 @@
 }
 
 void VLargeAsteroid::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if (!other->exists()) return;
 	damage(other, 0, damage_factor);
   if(other->isShip()) ((Ship*)other)->update_panel=1;
@@ -1482,6 +1666,7 @@
 }
 
 void VLargeAsteroid::animateExplosion(void) {
+  STACKTRACE;
 	game->add(new Animation(this, normal_pos(),
     explosionSprite, 0, 10,
     scale_frames(0), DEPTH_EXPLOSIONS));
@@ -1489,16 +1674,37 @@
 
 }
 
-void VLargeAsteroid::soundExplosion(void) {
+void VLargeAsteroid::soundExplosion(void) 
+{
+  STACKTRACE;
   if(damage_factor > 0) {
-		int i = iround_down(damage_factor / 2);
-		if(i >= BOOM_SAMPLES) i = BOOM_SAMPLES - 1;
-		play_sound((SAMPLE *)(melee[MELEE_BOOM + i].dat));
+    int i = iround_down(damage_factor / 2);
+    if(i >= BOOM_SAMPLES) i = BOOM_SAMPLES - 1;
+    switch(i)
+      {
+      case 0:
+	tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+	break;
+      case 1:
+	tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+	break;
+      case 2:
+	tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+	break;
+      case 3:
+	tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+	break;
+      default:
+	{
+	  tw_error("Unknown BOOM sound");
 	}
-	return;
+      }
+  }
+  return;
 }
 
 void VLargeAsteroid::death(void) {
+  STACKTRACE;
   VSmallAsteroid* VS;
   Vector2 Loc, UV;
   int i;
@@ -1518,11 +1724,13 @@
 :
 VPlanet()
 {
+  STACKTRACE;
   this->set_sprite(VMoon::mySprite);
   this->Initialize("Moon");
 }
 
 void VMoon::calculate() {
+  STACKTRACE;
   VPlanet::calculate();
 }
 
@@ -1531,6 +1739,7 @@
 :
 VPlanet()
 {
+  STACKTRACE;
   this->set_sprite(VRockballPlanet::mySprite);
   this->Initialize("RockballPlanet");
 }
@@ -1541,6 +1750,7 @@
 :
 VPlanet()
 {
+  STACKTRACE;
   this->set_sprite(VInhospitablePlanet::mySprite);
   this->Initialize("InhospitablePlanet");
 }
@@ -1549,6 +1759,7 @@
 :
 VPlanet()
 {
+  STACKTRACE;
   this->set_sprite(VHabitablePlanet::mySprite);
   this->Initialize("HabitablePlanet");
 }
@@ -1557,6 +1768,7 @@
 :
 VPlanet()
 {
+  STACKTRACE;
   this->set_sprite(VGasGiant::mySprite);
   this->Initialize("GasGiant");
 
@@ -1566,15 +1778,18 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VBrownDwarf::mySprite);
   this->Initialize("BrownDwarf");
 }
 
 void VBrownDwarf::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VBrownDwarf::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
@@ -1583,15 +1798,18 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VRedDwarf::mySprite);
   this->Initialize("RedDwarf");
 }
 
 void VRedDwarf::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VRedDwarf::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
@@ -1599,15 +1817,18 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VWhiteDwarf::mySprite);
   this->Initialize("WhiteDwarf");
 }
 
 void VWhiteDwarf::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 void VWhiteDwarf::LaunchFlare(VStar* osource, double oangle, double oinitialVelocity, double orange, double odamage, double ofinalVelocity) {
+  STACKTRACE;
   VWhiteFlare* VRF;
   VRF = new VWhiteFlare(this, oangle, oinitialVelocity, orange, odamage, ofinalVelocity);
   game->add(VRF);
@@ -1616,6 +1837,7 @@
 
 
 int VWhiteDwarf::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
@@ -1624,15 +1846,18 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VRedStar::mySprite);
   this->Initialize("RedStar");
 }
 
 void VRedStar::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VRedStar::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
@@ -1640,20 +1865,24 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VOrangeStar::mySprite);
   this->Initialize("OrangeStar");
 
 }
 
 void VOrangeStar::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VOrangeStar::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
 void VOrangeStar::LaunchFlare(VStar* osource, double oangle, double oinitialVelocity, double orange, double odamage, double ofinalVelocity) {
+  STACKTRACE;
   VOrangeFlare* VRF;
   VRF = new VOrangeFlare(this, oangle, oinitialVelocity, orange, odamage, ofinalVelocity);
   game->add(VRF);
@@ -1665,20 +1894,24 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VYellowStar::mySprite);
   this->Initialize("YellowStar");
 }
 
 
 void VYellowStar::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VYellowStar::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
 void VYellowStar::LaunchFlare(double oangle, double oinitialVelocity, double orange, double odamage, double ofinalVelocity) {
+  STACKTRACE;
   VYellowFlare* VRF;
   VRF = new VYellowFlare(this, oangle, oinitialVelocity, orange, odamage, ofinalVelocity);
   game->add(VRF);
@@ -1690,19 +1923,23 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VWhiteStar::mySprite);
   this->Initialize("WhiteStar");
 }
 
 void VWhiteStar::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VWhiteStar::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
 void VWhiteStar::LaunchFlare(VStar* osource, double oangle, double oinitialVelocity, double orange, double odamage, double ofinalVelocity) {
+  STACKTRACE;
   VWhiteFlare* VRF;
   VRF = new VWhiteFlare(this, oangle, oinitialVelocity, orange, odamage, ofinalVelocity);
   game->add(VRF);
@@ -1713,15 +1950,18 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VRedGiant::mySprite);
   this->Initialize("RedGiant");
 }
 
 void VRedGiant::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VRedGiant::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
@@ -1730,19 +1970,23 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VBlueGiant::mySprite);
   this->Initialize("BlueGiant");
 }
 
 void VBlueGiant::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VBlueGiant::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
 void VBlueGiant::LaunchFlare(double oangle, double oinitialVelocity, double orange, double odamage, double ofinalVelocity) {
+  STACKTRACE;
   VWhiteFlare* VRF;
   VRF = new VWhiteFlare(this, oangle, oinitialVelocity, orange, odamage, ofinalVelocity);
   game->add(VRF);
@@ -1754,6 +1998,7 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VNeutronStar::mySprite);
   this->Initialize("NeutronStar");
 	/*game->log_file ("vobject.ini");
@@ -1766,13 +2011,16 @@
 }
 
 void VNeutronStar::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VNeutronStar::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return(0);
 }
 void VNeutronStar::calculate(void) {
+  STACKTRACE;
   this->sprite_index += 1;
   while(this->sprite_index>63) this->sprite_index -=64;
   while(this->sprite_index<0) this->sprite_index +=64;
@@ -1785,19 +2033,23 @@
 :
 VStar()
 {
+  STACKTRACE;
   this->set_sprite(VHypermass::mySprite);
   this->Initialize("Hypermass");
 }
 
 void VHypermass::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VHypermass::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return(0);
 }
 
 void VHypermass::calculate(void) {
+  STACKTRACE;
   this->sprite_index += 1;
   while(this->sprite_index>63) this->sprite_index -=64;
   while(this->sprite_index<0) this->sprite_index +=64;
@@ -1810,6 +2062,7 @@
 Missile(source, source->pos, angle, initialVelocity, 
         odamage, range, odamage, source, VRedFlare::mySprite, 0)
 {
+  STACKTRACE;
   creator = (SpaceLocation*)source;
   pos = source->pos;
   originalVelocity = initialVelocity;
@@ -1821,6 +2074,7 @@
 }
 
 void VFlare::calculate() {
+  STACKTRACE;
   double amountFlown, amountToFly, currentAngle, calcVelocity;
   amountToFly = ((double)this->range - (double)this->d) / (double)this->range;
   amountToFly = amountToFly * amountToFly * amountToFly;
@@ -1833,11 +2087,13 @@
 }
 
 void VFlare::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   if((SpaceLocation*)other == (SpaceLocation*)creator) return;
   Missile::inflict_damage(other);
 }
 
 int VFlare::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
   if((SpaceLocation*)source == (SpaceLocation*)creator) return(0);
   return(Missile::handle_damage(source, normal, direct));
 }
@@ -1846,6 +2102,7 @@
 :
 VFlare(source, angle, initialVelocity, range, odamage, ofinalVelocity)
 {
+  STACKTRACE;
   this->set_sprite(VRedFlare::mySprite);
 }
 
@@ -1853,6 +2110,7 @@
 :
 VFlare(source, angle, initialVelocity, range, odamage, ofinalVelocity)
 {
+  STACKTRACE;
   this->set_sprite(VOrangeFlare::mySprite);
 }
 
@@ -1860,6 +2118,7 @@
 :
 VFlare(source, angle, initialVelocity, range, odamage, ofinalVelocity)
 {
+  STACKTRACE;
   this->set_sprite(VYellowFlare::mySprite);
 }
 
@@ -1867,6 +2126,7 @@
 :
 VFlare(source, angle, initialVelocity, range, odamage, ofinalVelocity)
 {
+  STACKTRACE;
   this->set_sprite(VWhiteFlare::mySprite);
 }
 

Modified: branches/multiplayer-branch/source/other/vtarget.cpp
===================================================================
--- branches/multiplayer-branch/source/other/vtarget.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/other/vtarget.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -17,7 +17,6 @@
 
 #include <assert.h>
 #include "melee.h"
-REGISTER_FILE
 #include "id.h"
 
 #include "melee/mframe.h"
@@ -41,6 +40,7 @@
 			   double WeaponOffsetY, double WeaponAngle,
 			   double MaxRange,
 			   double DegTolerance, int LagSetting) {
+  STACKTRACE;
 	AimSys::SetupDefaults();
 	source = sourceP; target = targetP;
 	relativity = Relativity;
@@ -61,6 +61,7 @@
 
 
 AimSys::AimSys(SpaceLocation* sourceP, SpaceLocation* targetP, double WeaponSpeed, double Relativity) {
+  STACKTRACE;
 	//not anti-aliased here
 	AimSys::SetupDefaults();
 	source = sourceP; target = targetP;
@@ -76,6 +77,7 @@
 }
 
 AimSys::AimSys(SpaceLocation* sourceP, SpaceLocation* targetP, double WeaponSpeed) {
+  STACKTRACE;
 	//not anti-aliased here
 	AimSys::SetupDefaults();
     source = sourceP; target = targetP;
@@ -89,6 +91,7 @@
 }
 
 AimSys::AimSys(SpaceLocation* sourceP, SpaceLocation* targetP) {
+  STACKTRACE;
 	//not anti-aliased here
 	//use with caution -- weapon speed is taken to be the
 	//current ship speed.  Would work for the Tau Bomber.
@@ -103,7 +106,8 @@
   AimSys::CalcWeaponOffset();
 }
 
-void AimSys::SetupDefaults(void) { //sets up defaults
+void AimSys::SetupDefaults(void) {
+  STACKTRACE; //sets up defaults
 	relativity = 0.5;
 	source = NULL; target = NULL;
   nx1center = 0; ny1center = 0;
@@ -117,6 +121,7 @@
 }
 
 void AimSys::CalcWeaponOffset(void) {
+  STACKTRACE;
   
   double dx, dy;
 	gamma = CalcVectorAngle(0,0,-weaponOffsetY, weaponOffsetX);
@@ -131,12 +136,14 @@
 }
 
 void AimSys::CalcWeaponOffset(double xOff, double yOff) {
+  STACKTRACE;
   weaponOffsetX = xOff;
   weaponOffsetY = yOff;
   AimSys::CalcWeaponOffset();
 }
 
 void AimSys::SetSpaceLine(SpaceLine* SL) {
+  STACKTRACE;
   SL->pos.x = nx1;
   SL->pos.y = ny1;
   SL->angle = gamma+source->angle;
@@ -147,16 +154,19 @@
 
 
 double AimSys::RawDistance(double x1, double y1, double x2, double y2) {
+  STACKTRACE;
 	return sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2 - y1));
 	//not anti-aliased here
 }
 
 double AimSys:: CalcVectorAngle(void) {
+  STACKTRACE;
 	return AimSys::CalcVectorAngle(nx1, ny1, nx2, ny2);
 }
 
 
 double AimSys:: CalcVectorAngle(double x1, double y1, double x2, double y2) {
+  STACKTRACE;
 	//angle of the line from source to target, in normal cartesian coordinates
 	//zero degrees is going straight up.
 	//the computer uses X+ across, Y+ down.
@@ -183,6 +193,7 @@
 }
 
 int AimSys::CalcTrialValues(void) {
+  STACKTRACE;
 	//HERE is where the anti-ailasing happens!
 	//all 8 wrap-around positions are tested, along with the non
 	//wrapped one.
@@ -230,26 +241,32 @@
 }
 
 double AimSys::getPursuitAngle() {
+  STACKTRACE;
 	return pursuitAngle;
 }
 
 double AimSys::getBestTrialAlpha() {
+  STACKTRACE;
 	return bestTrialAlpha;
 }
 
 double AimSys::getBestTrialTheta() {
+  STACKTRACE;
 	return bestTrialTheta;
 }
 
 double AimSys::getAngleOfShortestDistance() {
+  STACKTRACE;
   return bestTrialEpsilon;
 }
 
 void AimSys::setNewTarget(SpaceObject* newTarget) {
+  STACKTRACE;
 	target = newTarget;
 }
 
 void AimSys::Update(void) {
+  STACKTRACE;
 	if(source==NULL||target==NULL) return;
 	nx1center = source->pos.x; ny1center = source->pos.y; 
 	nx2 = target->pos.x; ny2 = target->pos.y;
@@ -266,6 +283,7 @@
 }
 
 double AimSys::absAngleDifference(double A1, double A2) {
+  STACKTRACE;
 	double x;
 	x = fabs(A2 - A1);
 	if(x>180)
@@ -276,6 +294,7 @@
 
 
 int AimSys::shouldFireNow(void) {
+  STACKTRACE;
 	// at the moment, just checks for current angle
 	//within tolerance
 	//the quick and dirty answer
@@ -293,6 +312,7 @@
 }
 
 int AimSys::shouldTurnLeft(void) {
+  STACKTRACE;
 	int x1, x2;
 	x1 = iround(source->angle-weaponAngle);
 	x2 = iround(pursuitAngle);
@@ -305,6 +325,7 @@
 }
 
 int AimSys::shouldTurnRight(void) {
+  STACKTRACE;
 	int x1, x2;
 	x1 = iround(source->angle-weaponAngle);
 	x2 = iround(pursuitAngle);

Modified: branches/multiplayer-branch/source/sc1ships/shpandgu.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpandgu.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc1ships/shpandgu.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -15,10 +15,11 @@
 GNU General Public License for more details.
 */
 
+#include "util/sound.h"
 #include "ship.h"
-REGISTER_FILE
 
 #include "sc1ships.h"
+#include "scp.h"
 
 class AndrosynthBubble : public AnimatedShot {
   int courseFrames;
@@ -34,6 +35,7 @@
 AndrosynthGuardian::AndrosynthGuardian(Vector2 opos, double angle, ShipData *data, unsigned int code) :
   Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 	weaponDamage       = get_config_int("Weapon", "Damage", 1);
 	weaponArmour       = get_config_int("Weapon", "Armour", 1);
 	weaponRange        = scale_range(get_config_float("Weapon", "Range", 10));
@@ -58,6 +60,7 @@
 
 void AndrosynthGuardian::calculate()
 {
+  STACKTRACE;
 	Ship::calculate();
 	if(specialActive && (batt == -1)) {
 		set_sprite(shipSprite);
@@ -73,6 +76,7 @@
 	}
 
 void AndrosynthGuardian::calculate_thrust() {
+  STACKTRACE;
 	if(specialActive) {
 		double dv;
 		if (bounce_status > 0) {
@@ -93,30 +97,54 @@
 
 void AndrosynthGuardian::calculate_hotspots()
 {
+  STACKTRACE;
   if(specialActive)
     return;
   Ship::calculate_hotspots();
 }
 
-void AndrosynthGuardian::inflict_damage(SpaceObject *other) {
-	if (damage_factor > 0) {
-		if (other->mass) {
-			game->add(new Animation(this, 
-					pos + unit_vector(trajectory_angle(other)) * 20.0,
-					meleedata.sparkSprite, 0, SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
-			translate(-specialBounceDistance*unit_vector(angle));
-			bounce_status = specialBounceTime;
-			int i = iround_down(damage_factor / 2);
-			if (i >= BOOM_SAMPLES) i = BOOM_SAMPLES - 1;
-			play_sound((SAMPLE *)(melee[MELEE_BOOM + i].dat));
-			}
-		if (!other->isProtected()) damage(other, damage_factor);
-		}
-	else damage(other, 0);
-	return;
+void AndrosynthGuardian::inflict_damage(SpaceObject *other) 
+{
+  STACKTRACE;
+  if (damage_factor > 0) 
+    {
+      if (other->mass) 
+	{
+	  game->add(new Animation(this, 
+				  pos + unit_vector(trajectory_angle(other)) * 20.0,
+				  game->meleedata.sparkSprite, 0, SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
+	  translate(-specialBounceDistance*unit_vector(angle));
+	  bounce_status = specialBounceTime;
+	  int i = iround_down(damage_factor / 2);
+	  if (i >= BOOM_SAMPLES) i = BOOM_SAMPLES - 1;
+	  switch(i)
+	    {
+	    case 0:
+	      tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+	      break;
+	    case 1:
+	      tw_sound->play_sound(data_full_path("sound/boom/BOOMPL02_WAV.wav"));
+	      break;
+	    case 2:
+	      tw_sound->play_sound(data_full_path("sound/boom/BOOMPL03_WAV.wav"));
+	      break;
+	    case 3:
+	      tw_sound->play_sound(data_full_path("sound/boom/BOOMPL04_WAV.wav"));
+	      break;
+	    default:
+	      {
+		tw_error("Unknown BOOM sound");
+	      }
+	    }
 	}
+      if (!other->isProtected()) damage(other, damage_factor);
+    }
+  else damage(other, 0);
+  return;
+}
 
 int AndrosynthGuardian::activate_weapon() {
+  STACKTRACE;
   
   if(specialActive)
 	  return FALSE;
@@ -127,27 +155,30 @@
   return(TRUE);
 }
 
-int AndrosynthGuardian::activate_special() {
-	if(specialActive)
-		return(FALSE);
-
-	if (batt < 1) return(FALSE);
-
-	set_sprite(specialSprite);
-
-	normalMass = mass;
-	shipTurnRate    = turn_rate;
-	shipRechargeAmount = recharge_amount;
-
-	damage_factor = specialDamage;
-	specialActive = TRUE;
-	turn_rate     = specialTurnRate;
+int AndrosynthGuardian::activate_special() 
+{
+  STACKTRACE;
+  if(specialActive)
+    return(FALSE);
   
-	recharge_step = recharge_rate;
-	recharge_amount = -1;
-	mass = specialMass;
+  if (batt < 1) 
+    return(FALSE);
+  
+  set_sprite(specialSprite);
+  
+  normalMass = mass;
+  shipTurnRate    = turn_rate;
+  shipRechargeAmount = recharge_amount;
+  
+  damage_factor = specialDamage;
+  specialActive = TRUE;
+  turn_rate     = specialTurnRate;
+  
+  recharge_step = recharge_rate;
+  recharge_amount = -1;
+  mass = specialMass;
 
-	return(TRUE);
+  return(TRUE);
 }
 
 AndrosynthBubble::AndrosynthBubble(Vector2 opos, double oangle,
@@ -157,6 +188,7 @@
     osprite, ofcount, ofsize),
   courseFrames(0)
 {
+  STACKTRACE;
   explosionSprite     = data->spriteWeaponExplosion;
   explosionFrameCount = 6;
   explosionFrameSize  = 50;
@@ -164,6 +196,7 @@
 
 void AndrosynthBubble::calculate()
 {
+  STACKTRACE;
 	if (!(ship && ship->exists()))
 	{
 		state = 0;

Modified: branches/multiplayer-branch/source/sc1ships/shparisk.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shparisk.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc1ships/shparisk.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -17,14 +17,13 @@
 
 #include "ship.h"
 
-REGISTER_FILE
-
 #include "sc1ships.h"
 
 ArilouSkiff::ArilouSkiff(Vector2 opos, double angle, ShipData *data, unsigned int code) 
 	:
 	Ship(opos, angle, data, code)
 	{
+  STACKTRACE;
 	specialSprite = data->spriteSpecial;
 
 	weaponColor  = get_config_int("Weapon", "Color", 0);
@@ -38,6 +37,7 @@
 	}
 
 void ArilouSkiff::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if (just_teleported && other->mass) {
 		damage(this, 0, 999);
 		}
@@ -46,6 +46,7 @@
 	}
 
 int ArilouSkiff::activate_weapon() {
+  STACKTRACE;
 	SpaceObject *o = NULL;
 
 	double r = 99999;  
@@ -65,6 +66,7 @@
 	}
 
 int ArilouSkiff::activate_special() {
+  STACKTRACE;
 
 	game->add(new Animation(this, pos,
 			specialSprite, 0, 40, iround(specialFrames/40), DEPTH_HOTSPOTS-0.1));
@@ -82,6 +84,7 @@
 	}
 
 void ArilouSkiff::calculate() {
+  STACKTRACE;
 	just_teleported = 0;
 	Ship::calculate();
 
@@ -90,10 +93,12 @@
 		}
 	}
 
-void ArilouSkiff::calculate_gravity() {}
+void ArilouSkiff::calculate_gravity() {
+  STACKTRACE;}
 
 int ArilouSkiff::accelerate(SpaceLocation *source, double angle, double velocity, 
 		double max_speed) {
+  STACKTRACE;
 	if (source == this) 
 		return Ship::accelerate(source, angle, velocity, max_speed);
 	return false;
@@ -101,6 +106,7 @@
 
 int ArilouSkiff::accelerate_gravwhip(SpaceLocation *source, double angle, double velocity, 
 		double max_speed) {
+  STACKTRACE;
 	if (source == this) 
 		return Ship::accelerate(source, angle, velocity, max_speed);
 	return false;

Modified: branches/multiplayer-branch/source/sc1ships/shpchebr.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpchebr.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc1ships/shpchebr.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 #include "sc1ships.h"
 
@@ -54,6 +53,7 @@
 ChenjesuBroodhome::ChenjesuBroodhome(Vector2 opos, double angle, ShipData *data, unsigned int code) :
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 	weaponDamage		= get_config_int("Weapon", "Damage", 0);
 	shardRange			= scale_range(get_config_int("Weapon", "ShardRange", 0));
 	shardDamage			= get_config_int("Weapon", "ShardDamage", 0);
@@ -77,6 +77,7 @@
 
 int ChenjesuBroodhome::activate_weapon()
 {
+  STACKTRACE;
 	if(weaponFired)
 		return(FALSE);
 	weaponObject = new ChenjesuShot(Vector2(0.0, (size.y / 2.0)), angle,
@@ -88,6 +89,7 @@
 
 int ChenjesuBroodhome::activate_special()
 {
+  STACKTRACE;
 	if(specialNumDOGIs >= MAX_DOGIS)
 		return(FALSE);
 	ChenjesuDOGI* DOGI; //added by Varith
@@ -103,6 +105,7 @@
 
 void ChenjesuBroodhome::calculate()
 {
+  STACKTRACE;
 	int i;
 
 	Ship::calculate();
@@ -120,8 +123,7 @@
 			shot->collide_flag_sameship = bit(LAYER_SPECIAL);
 			game->add(shot);
 		}
-//		weaponObject->play_sound2(data->sampleExtra[0]);
-		weaponObject->play_sound(data->sampleExtra[0]);
+		tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
 		weaponObject->destroy();
 		weaponObject = NULL;
 	}
@@ -132,6 +134,7 @@
 	int odamage, int oarmour, SpaceLocation *creator, SpaceSprite *osprite) :
 	Missile(creator, opos, oangle, ov, odamage, -1.0, oarmour, creator, osprite)
 {
+  STACKTRACE;
 	collide_flag_sameship = bit(LAYER_SPECIAL);
 	explosionSprite     = data->spriteWeaponExplosion;
 	explosionFrameCount = 20;
@@ -140,6 +143,7 @@
 
 void ChenjesuShot::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
 	Shot::inflict_damage(other);
 	if ((other->mass > 0) && !exists())
 		if (other-exists())
@@ -154,6 +158,7 @@
 
 void ChenjesuShot::animateExplosion()
 {
+  STACKTRACE;
 	return;
 }
 
@@ -163,6 +168,7 @@
 	AnimatedShot(oship, opos, ov, oangle, 0, -1.0, oarmour, oship, osprite, 64, 50),
 	sap_factor(fuel_sap), accel_rate(accel), num_dogis(onum_dogis)
 {
+  STACKTRACE;
 	layer = LAYER_SPECIAL;
 	set_depth(DEPTH_SPECIAL);
 	mass = omass;
@@ -172,6 +178,7 @@
 
 void ChenjesuDOGI::calculate()
 {
+  STACKTRACE;
 	AnimatedShot::calculate();
 
 	if (ship && ship->exists()) {
@@ -197,25 +204,29 @@
 
 void ChenjesuDOGI::inflict_damage(SpaceObject *other)
 {
-	play_sound(data->sampleExtra[1]);
+  STACKTRACE;
+  tw_sound->play_sound(data_full_path(data->sampleExtra[1]));
 
-	if(sameTeam(other)) return;
+  if(sameTeam(other)) 
+    return;
 
-	other->handle_fuel_sap(this, sap_factor);
-	double a = trajectory_angle(other);
-	accelerate(this, a, -v, MAX_SPEED);
-	if (other->mass > mass/100.0)
-		other->accelerate(this, a, v*3*mass/other->mass, v);
-	return;
+  other->handle_fuel_sap(this, sap_factor);
+  double a = trajectory_angle(other);
+  accelerate(this, a, -v, MAX_SPEED);
+  if (other->mass > mass/100.0)
+    other->accelerate(this, a, v*3*mass/other->mass, v);
+  return;
 }
 
 void ChenjesuDOGI::death()
 {
+  STACKTRACE;
 	if (num_dogis) (*num_dogis)--;
 }
 
 void ChenjesuDOGI::ship_died()
 {
+  STACKTRACE;
 	num_dogis = NULL;
 	SpaceObject::ship_died();
 	state = 0;
@@ -224,14 +235,17 @@
 
 void ChenjesuDOGI::animateExplosion()
 {
+  STACKTRACE;
 	game->add(new Animation(this, pos,
 		data->spriteSpecialExplosion, 0, 20, 25, DEPTH_EXPLOSIONS));
 }
 
 void ChenjesuDOGI::soundExplosion()
 {
-	play_sound2(data->sampleExtra[2]);
-	return;
+  STACKTRACE;
+  tw_sound->stop_sound(data_full_path(data->sampleExtra[2]));
+  tw_sound->play_sound(data_full_path(data->sampleExtra[2]));
+  return;
 }
 
 

Modified: branches/multiplayer-branch/source/sc1ships/shpearcr.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpearcr.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc1ships/shpearcr.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -14,11 +14,12 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 */
- 
+
+#include "util/sound.h" 
 #include "ship.h"
-REGISTER_FILE
 
 #include "sc1ships.h"
+#include "scp.h"
 
 class EarthlingMissile : public HomingMissile {
   public:
@@ -31,6 +32,7 @@
 	:
 	Ship(opos, angle, data, code)
 	{
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -47,33 +49,43 @@
 }
 
 int EarthlingCruiser::activate_weapon() {
+  STACKTRACE;
 	game->add(new EarthlingMissile(
 		Vector2(0.0, (size.y * 1.0)), angle, weaponVelocity, weaponDamage, weaponRange,
 		weaponArmour, weaponTurnRate, this, data->spriteWeapon));
 	return(TRUE);
 }
 
-int EarthlingCruiser::activate_special() {
-	int fire = FALSE;
-	SpaceObject *o;
-
-	Query a;
-	for (a.begin(this, bit(LAYER_SHIPS) + bit(LAYER_SHOTS) + bit(LAYER_SPECIAL) + 
-			bit(LAYER_CBODIES), specialRange); a.current; a.next()) {
-		o = a.currento;
-		if( (!o->isInvisible()) && !o->sameTeam(this) && (o->collide_flag_anyone & bit(LAYER_LINES))) {
-			SpaceLocation *l = new PointLaser(this, pallete_color[specialColor], 1, 
-					specialFrames, this, o, Vector2(0.0, 10.0));
-			game->add(l);
-			if (l->exists()) {
-                                fire = TRUE;
-                                l->set_depth(LAYER_EXPLOSIONS); }
-			}
-		}
-	if (fire) play_sound((SAMPLE *)(melee[MELEE_BOOM + 0].dat));
-
-	return(fire);
+int EarthlingCruiser::activate_special() 
+{
+  STACKTRACE;
+  int fire = FALSE;
+  SpaceObject *o;
+  
+  Query a;
+  for (a.begin(this, bit(LAYER_SHIPS) + bit(LAYER_SHOTS) + bit(LAYER_SPECIAL) + 
+	       bit(LAYER_CBODIES), specialRange); a.current; a.next()) 
+    {
+      o = a.currento;
+      if( (!o->isInvisible()) && !o->sameTeam(this) && (o->collide_flag_anyone & bit(LAYER_LINES))) 
+	{
+	  SpaceLocation *l = new PointLaser(this, pallete_color[specialColor], 1, 
+					    specialFrames, this, o, Vector2(0.0, 10.0));
+	  game->add(l);
+	  if (l->exists()) 
+	    {
+	      fire = TRUE;
+	      l->set_depth(LAYER_EXPLOSIONS); 
+	    }
 	}
+    }
+  if (fire) 
+    {
+      tw_sound->play_sound(data_full_path("sound/boom/BOOMPL01_WAV.wav"));
+    }
+  
+  return(fire);
+}
 
 EarthlingMissile::EarthlingMissile(Vector2 opos, double oangle,
   double ov, int odamage, double orange, int oarmour, double otrate,
@@ -81,6 +93,7 @@
   HomingMissile(oship, opos, oangle, ov, odamage, orange, oarmour, otrate, 
 		oship, osprite, oship->target)
 {
+  STACKTRACE;
 	collide_flag_sameship = bit(LAYER_SHIPS) | bit(LAYER_SHOTS);
   explosionSprite     = data->spriteWeaponExplosion;
   explosionFrameCount = 10;

Modified: branches/multiplayer-branch/source/sc1ships/shpilwav.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpilwav.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc1ships/shpilwav.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 #include "sc1ships.h"
 
@@ -26,6 +25,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
   weaponDamage   = get_config_int("Weapon", "Damage", 0);
@@ -42,6 +42,7 @@
 	}
 
 int IlwrathAvenger::activate_weapon() {
+  STACKTRACE;
 	// note that target=0 is only set after this routine is called in ship::calculate
 	// so we need to check if it exists ...
 	if (cloak && target && target->exists()) {
@@ -61,6 +62,7 @@
 
 void IlwrathAvenger::calculate_fire_special()
 {
+  STACKTRACE;
   special_low = FALSE;
 
   if(fire_special) {
@@ -72,28 +74,32 @@
     if(special_recharge > 0)
       return;
 
-    if(cloak) {
-      cloak = FALSE;
+    if(cloak) 
+      {
+	cloak = FALSE;
+      } 
+    else 
+      {
+	cloak = TRUE;
+	tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+	tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
+	batt -= special_drain;
+      }
 
-      play_sound2(data->sampleSpecial[1]);
-    } else {
-      cloak = TRUE;
-      play_sound2(data->sampleSpecial[0]);
-      batt -= special_drain;
-    }
-
     special_recharge = special_rate;
   }
 }
 
 void IlwrathAvenger::calculate_hotspots()
 {
+  STACKTRACE;
   if(!cloak)
     Ship::calculate_hotspots();
 }
 
 void IlwrathAvenger::calculate()
 {
+  STACKTRACE;
   if((cloak) && (cloak_frame < 300))
     cloak_frame += frame_time;
   if((!cloak) && (cloak_frame > 0))
@@ -103,6 +109,7 @@
 }
 
 void IlwrathAvenger::animate(Frame *space) {
+  STACKTRACE;
 	if((cloak_frame > 0) && (cloak_frame < 300))
 		sprite->animate_character( pos, sprite_index, 
 				pallete_color[cloak_color[cloak_frame / 100]], space);

Modified: branches/multiplayer-branch/source/sc1ships/shpkzedr.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpkzedr.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc1ships/shpkzedr.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
  
 #include "ship.h"
-REGISTER_FILE
 #include "melee/mview.h"
 
 #include "sc1ships.h"
@@ -52,6 +51,7 @@
 	:
 	Ship(opos, angle, data, code) 
 	{
+  STACKTRACE;
 	weaponRange         = scale_range(get_config_float("Weapon", "Range", 0));
 	weaponVelocity      = scale_velocity(get_config_float("Weapon", "Velocity", 0));
 	weaponDamage        = get_config_int("Weapon", "Damage", 0);
@@ -69,6 +69,7 @@
 	}
 
 int KzerZaDreadnought::activate_weapon() {
+  STACKTRACE;
 	game->add( new KzerZaMissile(
 			Vector2(0.0, (size.y / 2.0)), angle, weaponVelocity, weaponDamage, weaponRange,
 			weaponArmour, this, data->spriteWeapon) );
@@ -76,6 +77,7 @@
 	}
 
 int KzerZaDreadnought::activate_special() {
+  STACKTRACE;
 	if(crew > 1) {
 		game->add( new KzerZaFighter(Vector2(-25.0, -50.0),
 				angle - PI*7.0/8 , specialVelocity, specialRange, specialArmour,
@@ -102,6 +104,7 @@
 	:
 	Missile(oship, opos, oangle, ov, odamage, orange, oarmour, oship,osprite) 
 	{
+  STACKTRACE;
 	explosionSprite     = data->spriteWeaponExplosion;
 	explosionFrameCount = 20;
 	explosionFrameSize  = 50;
@@ -126,85 +129,107 @@
 	set_depth(DEPTH_SPECIAL);
 	}
 
-void KzerZaFighter::calculate() {
-	Missile::calculate();
+void KzerZaFighter::calculate() 
+{
+  STACKTRACE;
+  Missile::calculate();
 
-	if (!(ship && ship->exists()))
+  if (!(ship && ship->exists()))
+    {
+      ship = 0;	// not really needed but well.
+      state = 0;
+      return;
+    }
+  air_frames -= frame_time;
+  if (air_frames <= 0) 
+    {
+      state = 0;
+      return;
+    }
+  if (air_frames > max_air_frames - 350) 
+    return;
+  
+  target = ship->target;
+  if((target == NULL) || (air_frames < (max_air_frames / 2)) || target->isInvisible()) 
+    {
+      collide_flag_sameship |= bit(LAYER_SHIPS);
+      changeDirection(trajectory_angle(ship));
+      return;
+    }
+  collide_flag_sameship &= ~bit(LAYER_SHIPS);
+  
+  if ((distance(target) < laser_range) && (batt <= 0)) 
+    {
+      collide_flag_sameship = 0;
+      vel = 0;
+      tw_sound->stop_sound(data_full_path(data->sampleExtra[0]));
+      tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
+      
+      add(new Laser(this, trajectory_angle(target),
+		    pallete_color[laser_color], laser_range, laser_damage,
+		    laser_frames, this, Vector2(0.0, -size.y / 2.0)));
+      batt = recharge_frames;
+    }
+  else 
+    {
+      Vector2 t = target->normal_pos();
+      double ta = target->get_angle();
+      double a = target->trajectory_angle(this) - target->get_angle();
+      a = normalize(a,PI2);
+      Vector2 l = t + unit_vector(ta+PI/2) * laser_range * 0.8;
+      Vector2 r = t + unit_vector(ta+PI*3/2) * laser_range * 0.8;
+      double d_l = distance_from(pos, l);
+      double d_r = distance_from(pos, r);
+      double d2t;
+      if (d_l < d_r) 
 	{
-		ship = 0;	// not really needed but well.
-		state = 0;
-		return;
-		}
-	air_frames -= frame_time;
-	if (air_frames <= 0) {
-		state = 0;
-		return;
-		}
-	if (air_frames > max_air_frames - 350) return;
-
-	target = ship->target;
-	if((target == NULL) || (air_frames < (max_air_frames / 2)) || target->isInvisible()) {
-		collide_flag_sameship |= bit(LAYER_SHIPS);
-		changeDirection(trajectory_angle(ship));
-		return;
-		}
-	collide_flag_sameship &= ~bit(LAYER_SHIPS);
-
-	if ((distance(target) < laser_range) && (batt <= 0)) {
-		collide_flag_sameship = 0;
-		vel = 0;
-		play_sound2(data->sampleExtra[0]);
-		add(new Laser(this, trajectory_angle(target),
-				pallete_color[laser_color], laser_range, laser_damage,
-				laser_frames, this, Vector2(0.0, -size.y / 2.0)));
-		batt = recharge_frames;
-		}
-	else {
-		Vector2 t = target->normal_pos();
-		double ta = target->get_angle();
-		double a = target->trajectory_angle(this) - target->get_angle();
-		a = normalize(a,PI2);
-		Vector2 l = t + unit_vector(ta+PI/2) * laser_range * 0.8;
-		Vector2 r = t + unit_vector(ta+PI*3/2) * laser_range * 0.8;
-		double d_l = distance_from(pos, l);
-		double d_r = distance_from(pos, r);
-		double d2t;
-		if (d_l < d_r) {
-			angle = atan(min_delta(l, pos));
-			d2t = d_l;
-			}
-		else {
-			angle = atan(min_delta(r, pos));
-			d2t = d_r;
-			}
-		if (d2t > 20) d2t = 20;
-		vel = v * unit_vector(angle) * d2t / 20;
-		sprite_index = get_index(angle);
-		}
-
-	if (batt) batt -= frame_time;
+	  angle = atan(min_delta(l, pos));
+	  d2t = d_l;
 	}
+      else 
+	{
+	  angle = atan(min_delta(r, pos));
+	  d2t = d_r;
+	}
+      if (d2t > 20) 
+	d2t = 20;
+      vel = v * unit_vector(angle) * d2t / 20;
+      sprite_index = get_index(angle);
+    }
+  
+  if (batt) 
+    batt -= frame_time;
+}
 
 
-int KzerZaFighter::handle_damage(SpaceLocation *source, double normal, double direct){
-	if (source->isPlanet()) {
-		state = 1;
-	}
-	else state = 0;
-	return 0;
+int KzerZaFighter::handle_damage(SpaceLocation *source, double normal, double direct)
+{
+  STACKTRACE;
+  if (source->isPlanet()) 
+    {
+      state = 1;
+    }
+  else 
+    state = 0;
+  return 0;
 }
 
-void KzerZaFighter::inflict_damage(SpaceObject *other) {
-	if (other == ship) {
-		play_sound2(data->sampleExtra[1]);
-		damage(ship, 0, -1);
-	} 
-	if (!other->isPlanet()) state = 0;
-	else {
-		double a = trajectory_angle(other);
-		translate(unit_vector(a) * -10);
-	}
-	return;
+void KzerZaFighter::inflict_damage(SpaceObject *other) 
+{
+  STACKTRACE;
+  if (other == ship) 
+    {
+      tw_sound->stop_sound(data_full_path(data->sampleExtra[1]));
+      tw_sound->play_sound(data_full_path(data->sampleExtra[1]));
+      damage(ship, 0, -1);
+    } 
+  if (!other->isPlanet()) state = 0;
+  else 
+    {
+      double a = trajectory_angle(other);
+      translate(unit_vector(a) * -10);
+    }
+  return;
 }
 
 

Modified: branches/multiplayer-branch/source/sc1ships/shpmmrxf.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpmmrxf.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc1ships/shpmmrxf.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
  
 #include "ship.h"
-REGISTER_FILE
 
 #define T_FORM 0
 #define Y_FORM 1
@@ -31,6 +30,7 @@
 	laser2(NULL),
 	laserSpark(0)
 	{
+  STACKTRACE;
 	form_data[T_FORM].speed_max       = speed_max;
 	form_data[T_FORM].accel_rate      = accel_rate;
 	form_data[T_FORM].turn_rate       = turn_rate;
@@ -79,13 +79,14 @@
 
 void MmrnmhrmXForm::calculate()
 {
+  STACKTRACE;
   if(laserSpark > 0) {
     laserSpark-= frame_time;
     if((laserSpark <= 0) && (laserSpark > -frame_time)) {
       if ((laser1->damage_factor > 0) && (laser2->damage_factor > 0))
         add(new Animation(this, 
           laser1->normal_pos() + laser1->edge(),
-          meleedata.sparkSprite, 0, SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
+          game->meleedata.sparkSprite, 0, SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
       laser1 = NULL;
       laser2 = NULL;
     }
@@ -96,6 +97,7 @@
 
 int MmrnmhrmXForm::activate_weapon()
 {
+  STACKTRACE;
   if(form == T_FORM) {
     add(laser1 = new Laser(this, angle + laserAngle,
       pallete_color[laserColor], laserRange, laserDamage, weapon_rate, this,
@@ -118,6 +120,7 @@
 
 int MmrnmhrmXForm::activate_special()
 {
+  STACKTRACE;
 	form_data[form].speed_max       = speed_max;
 	form_data[form].accel_rate      = accel_rate;
 	form_data[form].turn_rate       = turn_rate;
@@ -142,6 +145,7 @@
 }
 
 double MmrnmhrmXForm::handle_speed_loss(SpaceLocation *source, double normal) {
+  STACKTRACE;
 	Ship::handle_speed_loss(source, normal);
 	if (normal) {
 		activate_special();

Modified: branches/multiplayer-branch/source/sc1ships/shpmycpo.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpmycpo.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc1ships/shpmycpo.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
  
 #include "ship.h"
-REGISTER_FILE
 
 #include "sc1ships.h"
 
@@ -42,6 +41,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
   weaponDamage   = get_config_int("Weapon", "Damage", 0);
@@ -51,6 +51,7 @@
 
 int MyconPodship::activate_weapon()
 {
+  STACKTRACE;
   add(new MyconPlasma(Vector2(0.0, size.y),
     angle, weaponVelocity, weaponDamage, weaponRange, weaponHome, this,
     data->spriteWeapon, 64));
@@ -59,6 +60,7 @@
 
 int MyconPodship::activate_special()
 {
+  STACKTRACE;
   if(crew >= crew_max)
     return(FALSE);
   damage(this, 0, -4);
@@ -75,6 +77,7 @@
   frame_count(ofcount),
   max_damage(odamage)
 {
+  STACKTRACE;
 	spriteWeaponExplosion = data->spriteWeaponExplosion;
 	collide_flag_sameship |= bit(LAYER_SHIPS);
 	collide_flag_sameteam |= bit(LAYER_SHIPS);
@@ -82,6 +85,7 @@
 
 void MyconPlasma::calculate()
 {
+  STACKTRACE;
   HomingMissile::calculate();
 
   sprite_index = (int)((d / range) * (double)(frame_count - 1));
@@ -90,6 +94,7 @@
 
 void MyconPlasma::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   SpaceObject::inflict_damage(other);
   //if (!other->isShot()) {
   if (other->isblockingweapons)
@@ -107,6 +112,7 @@
 }
 
 int MyconPlasma::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	double total = normal + direct;
 
 	if (total) {

Modified: branches/multiplayer-branch/source/sc1ships/shpshosc.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpshosc.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc1ships/shpshosc.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
  
 #include "ship.h"
-REGISTER_FILE
 
 #include "sc1ships.h"
 
@@ -24,6 +23,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
   weaponDamage   = get_config_int("Weapon", "Damage", 0);
@@ -40,55 +40,57 @@
 
 int ShofixtiScout::activate_weapon()
 {
+  STACKTRACE;
   add(new Missile(this, Vector2(0.0, size.y / 2.0),
     angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
     this, data->spriteWeapon));
   return(TRUE);
 }
 
-void ShofixtiScout::calculate_fire_special() {
-	int gloryDamage;
-
-	if(fire_special) {
-		if(!flipSwitch) {
-			flipSwitch = TRUE;
-			glory++;
-			if(glory == 3) {
-				Query q;
-				for (q.begin(this, OBJECT_LAYERS, specialRange); q.currento; q.next()) {
-					if (q.currento->canCollide(this)) {
-						gloryDamage = (int)ceil((specialRange - distance(q.currento)) / specialRange * specialDamage);
-						damage(q.current, 0, gloryDamage);
-						}
-					}
-				q.end();
-				add(new Animation(this, pos, data->spriteSpecial, 
-						0, specialFrames, 50, DEPTH_EXPLOSIONS, specialScale));
-				play_sound2(data->sampleSpecial[0]);
-				damage(this, 0, 999);
-				}
-			else {
-				spritePanel->overlay(1, 5+glory, spritePanel->get_bitmap(2));
-				spritePanel->overlay(1, 5+glory, spritePanel->get_bitmap(3));
-				spritePanel->overlay(1, 5+glory, spritePanel->get_bitmap(4));
-				spritePanel->overlay(1, 5+glory, spritePanel->get_bitmap(5));
-				spritePanel->overlay(1, 5+glory, spritePanel->get_bitmap(1));
-/*				blit(data->bitmapPanel[5 + glory], panelBitmap[1], 0, 23, 0, 23,
-						CAPTAIN_WIDTH, 7);
-				blit(data->bitmapPanel[5 + glory], panelBitmap[2], 0, 23, 0, 23,
-						CAPTAIN_WIDTH, 7);
-				blit(data->bitmapPanel[5 + glory], panelBitmap[3], 0, 23, 0, 23,
-						CAPTAIN_WIDTH, 7);
-				blit(data->bitmapPanel[5 + glory], panelBitmap[4], 0, 23, 0, 23,
-						CAPTAIN_WIDTH, 7);
-				blit(data->bitmapPanel[5 + glory], panelBitmap[5], 0, 23, 0, 23,
-						CAPTAIN_WIDTH, 7);*/
-				}
-			}
+void ShofixtiScout::calculate_fire_special() 
+{
+  STACKTRACE;
+  int gloryDamage;
+  
+  if(fire_special) 
+    {
+      if(!flipSwitch) 
+	{
+	  flipSwitch = TRUE;
+	  glory++;
+	  if(glory == 3) 
+	    {
+	      Query q;
+	      for (q.begin(this, OBJECT_LAYERS, specialRange); q.currento; q.next()) 
+		{
+		  if (q.currento->canCollide(this)) 
+		    {
+		      gloryDamage = (int)ceil((specialRange - distance(q.currento)) / 
+					      specialRange * specialDamage);
+		      damage(q.current, 0, gloryDamage);
+		    }
 		}
-	else flipSwitch = FALSE;
-	return;
+	      q.end();
+	      add(new Animation(this, pos, data->spriteSpecial, 
+				0, specialFrames, 50, DEPTH_EXPLOSIONS, specialScale));
+	      tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+	      tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
+	      damage(this, 0, 999);
+	    }
+	  else 
+	    {
+	      spritePanel->overlay(1, 5+glory, spritePanel->get_bitmap(2));
+	      spritePanel->overlay(1, 5+glory, spritePanel->get_bitmap(3));
+	      spritePanel->overlay(1, 5+glory, spritePanel->get_bitmap(4));
+	      spritePanel->overlay(1, 5+glory, spritePanel->get_bitmap(5));
+	      spritePanel->overlay(1, 5+glory, spritePanel->get_bitmap(1));
+	    }
 	}
+    }
+  else 
+    flipSwitch = FALSE;
+  return;
+}
 
 
 

Modified: branches/multiplayer-branch/source/sc1ships/shpspael.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpspael.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc1ships/shpspael.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 #include "sc1ships.h"
 
@@ -24,6 +23,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 
 	weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
 	weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -39,6 +39,7 @@
 
 int SpathiEluder::activate_weapon()
 {
+  STACKTRACE;
 	add(new Missile( this, Vector2(0.0, size.y / 2.0),
 		angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
 		this, data->spriteWeapon));
@@ -47,6 +48,7 @@
 
 int SpathiEluder::activate_special()
 {
+  STACKTRACE;
 	SpaceLocation *tmp = new HomingMissile( this, 
 		Vector2(0.0, -size.y / 1.5), angle + PI, specialVelocity, specialDamage, specialRange, 
 		specialArmour, specialTurnRate, this, data->spriteSpecial, target);

Modified: branches/multiplayer-branch/source/sc1ships/shpsyrpe.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpsyrpe.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc1ships/shpsyrpe.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 #include "sc1ships.h"
 
@@ -44,6 +43,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 
 	weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
 	weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -58,6 +58,7 @@
 
 int SyreenPenetrator::activate_weapon()
 {
+  STACKTRACE;
 	Missile *m;
 	m = new Missile(this, Vector2(0.0, size.y / 2.0 + 10),
 			angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
@@ -69,6 +70,7 @@
 }
 
 int SyreenPenetrator::activate_special() {
+  STACKTRACE;
 	double minDist;
 	minDist = specialRange + (size.x / 2.0);
 	int j;
@@ -113,6 +115,7 @@
   life(0),
   lifetime(oLifeTime)
 {
+  STACKTRACE;
 	collide_flag_sameship = ALL_LAYERS;
 	collide_flag_sameteam = ALL_LAYERS;
 	layer = LAYER_SPECIAL;
@@ -122,10 +125,12 @@
 }
 
 int CrewPod::sameTeam(SpaceLocation *other) {
+  STACKTRACE;
 	return true;
 	}
 
 void CrewPod::calculate() {
+  STACKTRACE;
 	frame_step += frame_time;
 	while (frame_step >= frame_size) {
 		frame_step -= frame_size;
@@ -149,16 +154,19 @@
 
 void CrewPod::inflict_damage(SpaceObject *other)
 {
-  if (other->isShip() && other->damage_factor == 0) {
-    sound.stop(data->sampleExtra[0]);
-    sound.play(data->sampleExtra[0]);
-	damage(other, 0, -1);
-		state = 0;
+  STACKTRACE;
+  if (other->isShip() && other->damage_factor == 0) 
+    {
+      tw_sound->stop_sound(data_full_path(data->sampleExtra[0]));
+      tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
+      damage(other, 0, -1);
+      state = 0;
   }
 }
 
 int CrewPod::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
 	state = 0;
 	return 0;
 }

Modified: branches/multiplayer-branch/source/sc1ships/shpumgdr.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpumgdr.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc1ships/shpumgdr.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 #include "sc1ships.h"
 
@@ -44,6 +43,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 
   weaponDamage   = get_config_int("Weapon", "Damage", 0);
   specialRate    = special_rate;
@@ -54,12 +54,14 @@
 }
 
 int UmgahDrone::activate_weapon() {
+  STACKTRACE;
   firing = true;
   return(TRUE);
 }
 
 int UmgahDrone::activate_special()
 {
+  STACKTRACE;
   special_rate = specialRate;
   vel = 0;
   pos -= (unit_vector(angle) * size.x * 2.0);
@@ -69,12 +71,14 @@
 
 void UmgahDrone::calculate_thrust()
 {
+  STACKTRACE;
   if(special_recharge <= 0)
     Ship::calculate_thrust();
 }
 
 void UmgahDrone::calculate()
 {
+  STACKTRACE;
   if (fire_weapon)
     recharge_step = recharge_rate;
   else
@@ -88,6 +92,7 @@
   SpaceObject(oship, oship->normal_pos(), 0.0, osprite),
   dist(odist)
 {
+  STACKTRACE;
 	layer = LAYER_SHOTS;
 	set_depth(DEPTH_SHIPS - 0.1);
 
@@ -110,11 +115,13 @@
 }
 
 bool UmgahCone::change_owner(SpaceLocation *new_owner) {
+  STACKTRACE;
 	return false;
 	}
 
 void UmgahCone::calculate()
 {
+  STACKTRACE;
 	SpaceObject::calculate();
 
 	if(!(ship && ship->exists()))
@@ -141,6 +148,7 @@
 
 void UmgahCone::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   switch (damage_type) {
     case 0: {
             residual_damage = damage * frame_time / 2.0;
@@ -169,6 +177,7 @@
 }
 
 int UmgahCone::canCollide(SpaceLocation* other) {
+  STACKTRACE;
 //  calc_base();
   if (umgahship && umgahship->exists())
 	return (umgahship->firing & !other->isPlanet());
@@ -177,6 +186,7 @@
 }
 
 void UmgahCone::animate(Frame* space) {
+  STACKTRACE;
 //  calc_base();
   if (!umgahship || !umgahship->exists() || !umgahship->firing) return;
   int si = sprite_index;

Modified: branches/multiplayer-branch/source/sc1ships/shpvuxin.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpvuxin.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc1ships/shpvuxin.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 #include "sc1ships.h"
 
@@ -36,6 +35,7 @@
 	Ship(opos, angle, data, code)
 
 {
+  STACKTRACE;
   weaponColor  = get_config_int("Weapon", "Color", 0);
   weaponRange  = scale_range(get_config_float("Weapon", "Range", 0));
   weaponDamage = get_config_int("Weapon", "Damage", 0);
@@ -48,6 +48,7 @@
 
 int VuxIntruder::activate_weapon()
 {
+  STACKTRACE;
   add(new Laser(this, angle,
     pallete_color[weaponColor], weaponRange, weaponDamage, weapon_rate,
     this, Vector2(size.x/11, (size.y / 2.07)), true));
@@ -56,6 +57,7 @@
 
 int VuxIntruder::activate_special()
 {
+  STACKTRACE;
   add(new VuxLimpet(Vector2(0, -size.y / 2.8),
     specialVelocity, specialSlowdown, specialRange, specialArmour, this,
     data->spriteSpecial, 100, 5));
@@ -69,6 +71,7 @@
     ofcount, ofsize),
   slowdown_factor(slowdown)
 {
+  STACKTRACE;
   if((ship->target) && (!ship->target->isInvisible()))
     angle = trajectory_angle(ship->target);
   else
@@ -85,6 +88,7 @@
 
 void VuxLimpet::calculate()
 {
+  STACKTRACE;
 	if(!(ship && ship->exists())) {
 		state = 0;
 		return;
@@ -97,105 +101,111 @@
 	AnimatedShot::calculate();
 	}
 
-void VuxLimpet::inflict_damage(SpaceObject *other) {
-	if(!other->isShip()) {
-		if (other->damage_factor || other->mass) state = 0;
-		return;
-		}
+void VuxLimpet::inflict_damage(SpaceObject *other) 
+{
+  STACKTRACE;
+  if(!other->isShip()) 
+    {
+      if (other->damage_factor || other->mass) state = 0;
+      return;
+    }
 
-	Ship *target = (Ship *) other;
+  Ship *target = (Ship *) other;
 
-	play_sound(data->sampleSpecial[1]);
+  tw_sound->play_sound(data_full_path(data->sampleSpecial[1]));
 
-	//MYCODE begin
-	int hx,hy,tries, col;
-
-	if ( target->spritePanel )
+  //MYCODE begin
+  int hx,hy,tries, col;
+  
+  if ( target->spritePanel )
+    {
+      BITMAP *bmp = target->spritePanel->get_bitmap(0);
+      //find a random spot on the target ship where it "exist" 
+      tries = 0;
+      while (tries < 10) 
 	{
-		BITMAP *bmp = target->spritePanel->get_bitmap(0);
-		//find a random spot on the target ship where it "exist" 
-		tries = 0;
-		while (tries < 10) {
-			hx = 18 + (rand() % 27);	//graphics
-			hy = 15 + (rand() % 36);	//graphics
-			tries++;
-			col = getpixel(bmp,hx,hy);
-			if (col == bitmap_mask_color(bmp)) continue;
-			if (col == 0) continue;
-			if (col == -1) continue;
-			if (col == palette_color[8]) continue;
-			break;
-		} 
-		
-		// draw the Limplet on the ship panel
-		//BITMAP *s = sprite->get_bitmap(sprite_index);
-		//stretch_sprite(bmp, s, hx - s->w/4, hy - s->h/4,	s->w/2, s->h/2 );
-		sprite->draw(Vector2(hx,hy)-sprite->size()/4,
-			sprite->size()/2, 
-			sprite_index, bmp);
-		target->update_panel = TRUE;
-	}
+	  hx = 18 + (rand() % 27);	//graphics
+	  hy = 15 + (rand() % 36);	//graphics
+	  tries++;
+	  col = getpixel(bmp,hx,hy);
+	  if (col == bitmap_mask_color(bmp)) continue;
+	  if (col == 0) continue;
+	  if (col == -1) continue;
+	  if (col == palette_color[8]) continue;
+	  break;
+	} 
+      
+      // draw the Limplet on the ship panel
+      sprite->draw(Vector2(hx,hy)-sprite->size()/4,
+		   sprite->size()/2, 
+		   sprite_index, bmp);
+      target->update_panel = TRUE;
+    }
+  
+  target->handle_speed_loss(this, slowdown_factor);
+  state = 0;
+}
 
-	target->handle_speed_loss(this, slowdown_factor);
-	state = 0;
-	}
+void VuxIntruder::relocate() 
+{
+  STACKTRACE;
+  if ( control ) target = control->target; 
+  if (target && (distance(target) > 500)) {
+    pos = target->normal_pos() + (unit_vector(angle) * 125.0);
+    angle = trajectory_angle(target);
+    if (angle > PI2) angle -= PI2;
+    if (angle < 0) angle += PI2;
+  }
+  sprite_index = get_index(angle);
+  angle = (iround(angle / (PI2/64))) * (PI2/64);
+  return;
+}
 
-void VuxIntruder::relocate() {
-	if ( control ) target = control->target; 
-	if (target && (distance(target) > 500)) {
-		pos = target->normal_pos() + (unit_vector(angle) * 125.0);
-		angle = trajectory_angle(target);
-		if (angle > PI2) angle -= PI2;
-		if (angle < 0) angle += PI2;
-		}
-	sprite_index = get_index(angle);
-	angle = (iround(angle / (PI2/64))) * (PI2/64);
-	return;
-	}
 
-
-void VuxIntruder::animate(Frame *space){
-
-        double back_x=size.x/3.60, back_y=-size.y/2.33,
-               frnt_x=size.x/5.55, frnt_y=+size.y/17.01,
-               back_y_1=-size.y/2.06;
+void VuxIntruder::animate(Frame *space)
+{
+  STACKTRACE;
   
-        int s_index = get_index(angle);
-
-        if (turn_right)
-				data->spriteWeapon->animate(pos + 
-					rotate(Vector2(-frnt_x, frnt_y), angle-PI/2),
-					s_index + ((rand()%3) << 6), space);	//graphics
-        if (turn_left)
-				data->spriteWeapon->animate(pos + 
-					rotate(Vector2(frnt_x,frnt_y), angle-PI/2),
-					s_index + ((rand()%3) << 6), space);	//graphics
-
-        s_index += 32; s_index &= 63;
-
-        if (thrust) {
+  double back_x=size.x/3.60, back_y=-size.y/2.33,
+    frnt_x=size.x/5.55, frnt_y=+size.y/17.01,
+    back_y_1=-size.y/2.06;
+  
+  int s_index = get_index(angle);
+  
+  if (turn_right)
+    data->spriteWeapon->animate(pos + 
+				rotate(Vector2(-frnt_x, frnt_y), angle-PI/2),
+				s_index + ((rand()%3) << 6), space);	//graphics
+  if (turn_left)
+    data->spriteWeapon->animate(pos + 
+				rotate(Vector2(frnt_x,frnt_y), angle-PI/2),
+				s_index + ((rand()%3) << 6), space);	//graphics
+  
+  s_index += 32; s_index &= 63;
+  
+  if (thrust) {
 				data->spriteExtra->animate(pos + 
-					rotate(Vector2(back_x, back_y_1), angle-PI/2),
-					s_index + ((rand()%3) << 6), space);	//graphics
-                data->spriteExtra->animate(pos + 
-					rotate(Vector2(-back_x, back_y_1), angle-PI/2),
-					s_index + ((rand()%3) << 6), space); }	//graphics
-        else {
-                if (turn_left)
-						data->spriteWeapon->animate(pos + 
-							rotate(Vector2(-back_x, back_y), angle-PI/2),
-							s_index + ((rand()%3) << 6), space);	//graphics
-                if (turn_right)
-						data->spriteWeapon->animate(pos + 
-							rotate(Vector2(back_x, back_y), angle-PI/2),
-							s_index + ((rand()%3) << 6), space); }	//graphics
-
-        Ship::animate(space);
+							   rotate(Vector2(back_x, back_y_1), angle-PI/2),
+							   s_index + ((rand()%3) << 6), space);	//graphics
+				data->spriteExtra->animate(pos + 
+							   rotate(Vector2(-back_x, back_y_1), angle-PI/2),
+							   s_index + ((rand()%3) << 6), space); }	//graphics
+  else {
+    if (turn_left)
+      data->spriteWeapon->animate(pos + 
+				  rotate(Vector2(-back_x, back_y), angle-PI/2),
+				  s_index + ((rand()%3) << 6), space);	//graphics
+    if (turn_right)
+      data->spriteWeapon->animate(pos + 
+				  rotate(Vector2(back_x, back_y), angle-PI/2),
+				  s_index + ((rand()%3) << 6), space); }	//graphics
+  
+  Ship::animate(space);
 };
 
 
 class VuxPhaser : public Phaser {
-	public:
+public:
 	VuxPhaser(Vector2 opos, Vector2 n, VuxIntruder *ship, 
 			SpaceSprite *sprite, int osprite_index, int *ocolors, 
 			int onum_colors, int ofsize, int steps, int step_time) ;
@@ -213,10 +223,12 @@
 :
 Phaser(ship, opos, _n, ship, sprite, osprite_index, ocolors, onum_colors, ofsize, steps, step_size)
 {
+  STACKTRACE;
 	vuxship = ship;
 }
 
 void VuxPhaser::calculate() {
+  STACKTRACE;
 	Phaser::calculate();
 	if (!ship) return;
 	if( !(ship->attributes & ATTRIB_INGAME )) vuxship->relocate();//((VuxIntruder*)ship)->relocate();
@@ -228,6 +240,7 @@
 	}
 
 SpaceLocation *VuxIntruder::get_ship_phaser() {
+  STACKTRACE;
 	return new VuxPhaser(
 			pos - unit_vector(angle) * PHASE_MAX * size.x,
 			unit_vector(angle) * PHASE_MAX * size.x,

Modified: branches/multiplayer-branch/source/sc1ships/shpyehte.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpyehte.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc1ships/shpyehte.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 #include "frame.h"
 
@@ -26,6 +25,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -38,6 +38,7 @@
 
 int YehatTerminator::activate_weapon()
 {
+  STACKTRACE;
   add(new Missile(this, Vector2(-24.0, 14),
     angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
     this, data->spriteWeapon));
@@ -49,12 +50,14 @@
 
 int YehatTerminator::activate_special()
 {
+  STACKTRACE;
   shieldFrames = (shieldFrames % frame_time) + specialFrames;
   return(TRUE);
 }
 
 void YehatTerminator::calculate()
 {
+  STACKTRACE;
    if(shieldFrames > 0)
      shieldFrames-= frame_time;
    Ship::calculate();
@@ -62,6 +65,7 @@
 
 void YehatTerminator::animate(Frame *space)
 {
+  STACKTRACE;
   if(shieldFrames > 0)
     data->spriteSpecial->animate( pos, sprite_index, space);
   else
@@ -69,6 +73,7 @@
 }
 
 int YehatTerminator::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	if (shieldFrames > 0) normal = 0;
 	return Ship::handle_damage(source, normal, direct);
 	}

Modified: branches/multiplayer-branch/source/sc2ships/shpchmav.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shpchmav.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc2ships/shpchmav.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 #include "util/aastr.h"
 #include "sc2ships.h"
@@ -67,6 +66,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code) 
 	{
+  STACKTRACE;
 
 	weaponRange  = scale_range(get_config_float("Weapon", "Range", 0));
 	weaponDamage = get_config_int("Weapon", "Damage", 0);
@@ -87,6 +87,7 @@
 
 void ChmmrAvatar::calculate()
 {
+  STACKTRACE;
 	Ship::calculate();
 	
 	if ((uninterrupted_fire) && ((!fire_weapon) || weapon_low))
@@ -102,6 +103,7 @@
 
 int ChmmrAvatar::activate_weapon()
 {
+  STACKTRACE;
 	add(new ChmmrLaser(angle, weaponRange, weaponDamage, weapon_rate, this, Vector2(0.0, 25.0) ));
 	if (tw_random(150) < frame_time) {
 		add(new Animation(this, 
@@ -123,6 +125,7 @@
 
 int ChmmrAvatar::activate_special()
 {
+  STACKTRACE;
 	if (target && target->exists() && (!target->isInvisible()) && (target->mass > 0) && (distance(target) < specialRange)) {
 		add(new ChmmrBeam(this, special_rate));
 		target->accelerate(this, target->trajectory_angle(this), specialForce / target->mass, MAX_SPEED);
@@ -133,6 +136,7 @@
 
 void ChmmrAvatar::materialize()
 {
+  STACKTRACE;
 	Ship::materialize();
 	add(new ChmmrZapSat(0.0, extraRange,
 		extraDamage, extraFrames, extraRechargeRate, extraColor, extraArmour, this,
@@ -151,16 +155,18 @@
 	Laser(opos, langle, pallete_color[hot_color[random() % HOT_COLORS]], lrange,
 	ldamage, lfcount, opos, rel_pos, true)
 {
+  STACKTRACE;
 }
 
 ChmmrBeam::ChmmrBeam(Ship *oship, int oframes) :
 	SpaceObject(oship, oship->normal_pos(), oship->get_angle(), 
-    meleedata.sparkSprite),
+    game->meleedata.sparkSprite),
 	frame(0),
 	frame_count(oframes),
 	ship(oship),
 	target(oship->target)
 {
+  STACKTRACE;
 	set_depth(DEPTH_HOTSPOTS);
 	collide_flag_anyone = 0;
 	if(!(ship && ship->exists())) {
@@ -177,6 +183,7 @@
 
 void ChmmrBeam::calculate()
 {
+  STACKTRACE;
 
 	SpaceLocation::calculate();
 
@@ -202,6 +209,7 @@
 
 void ChmmrBeam::animate(Frame *space)
 {
+  STACKTRACE;
 	const int beam_color[5] = { 80, 81, 82, 83, 84 };
 	int i;//, old_trans;
 	double length = target->get_vel().length() + (target->get_size().x / 4.0);
@@ -236,6 +244,7 @@
   lColor(ocolor),
   armour(oarmour)
 {
+  STACKTRACE;
 	layer = LAYER_SPECIAL;
 	set_depth(DEPTH_SPECIAL);
 	collide_flag_anyone = ALL_LAYERS &~ bit(LAYER_CBODIES);
@@ -255,6 +264,7 @@
 }
 
 void ChmmrZapSat::calculate() {
+  STACKTRACE;
 
 	SpaceObject::calculate();
 
@@ -291,7 +301,7 @@
 		if (!q.currento->isInvisible() && !q.currento->sameTeam(this) && (q.currento->collide_flag_anyone&bit(LAYER_LINES))) {
 			add(new PointLaser(this, pallete_color[lColor], 1, lFrames,
                         		this, q.currento, Vector2(0.0, 0.0) ));
-			sound.play((SAMPLE *)(melee[MELEE_BOOM + 0].dat));
+			tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND1));
 			lRecharge += lRechargeRate;
 			break;
 			}
@@ -299,11 +309,13 @@
 	return;
 	}
 int ChmmrZapSat::canCollide(SpaceLocation *other) {
+  STACKTRACE;
 	if (!other->damage_factor) return false;
 	return SpaceObject::canCollide(other);
 	}
 
 int ChmmrZapSat::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	int total = iround(normal + direct);
 	if (total) {
 		armour -= total;
@@ -311,9 +323,10 @@
 			armour = 0;
 			state = 0;
 			add(new Animation(this, pos,
-					meleedata.kaboomSprite, 0, KABOOM_FRAMES, 50, DEPTH_EXPLOSIONS));
-			sound.stop(data->sampleExtra[0]);
-			sound.play(data->sampleExtra[0]);
+					  game->meleedata.kaboomSprite, 0, KABOOM_FRAMES, 
+					  50, DEPTH_EXPLOSIONS));
+			tw_sound->stop_sound(data_full_path(data->sampleExtra[0]));
+			tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
 			}
 		}
 	return total;

Modified: branches/multiplayer-branch/source/sc2ships/shpdruma.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shpdruma.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc2ships/shpdruma.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 
 #include "sc2ships.h"
@@ -37,6 +36,7 @@
 	ShipData *shipData, unsigned int code)
 	:
 	Ship(opos, shipAngle, shipData, code) {
+  STACKTRACE;
 
   weaponRange         = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity      = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -47,6 +47,7 @@
 
 
 int DruugeMauler::activate_weapon() {
+  STACKTRACE;
 	accelerate (this, angle + PI, weaponDriftVelocity / mass, MAX_SPEED);
 	add(new DruugeMissile(
 			Vector2(0.0, (get_size().y /*height()*/ / 2.0)), angle, weaponVelocity, weaponDamage,
@@ -57,6 +58,7 @@
 
 
 void DruugeMauler::calculate_fire_special() {
+  STACKTRACE;
   if((fire_special) && (crew > 1) && (batt < batt_max) &&
     (special_recharge <= 0)) {
 
@@ -67,28 +69,30 @@
 
     special_recharge = special_rate;
 
-    play_sound2(data->sampleSpecial[0]);
+    tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+    tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
   }
 }
 
-
 DruugeMissile::DruugeMissile(Vector2 opos, double oangle, double ov,
-    int odamage, double weaponDriftVelocity, double orange, int oarmour,
-    Ship *oship, SpaceSprite *osprite) :
-    Missile(oship, opos, oangle, ov, odamage, orange, oarmour, oship, osprite),
-    kick(weaponDriftVelocity)
+			     int odamage, double weaponDriftVelocity, double orange, int oarmour,
+			     Ship *oship, SpaceSprite *osprite) :
+  Missile(oship, opos, oangle, ov, odamage, orange, oarmour, oship, osprite),
+  kick(weaponDriftVelocity)
 {
+  STACKTRACE;
   explosionSprite     = data->spriteWeaponExplosion;
   explosionFrameCount = 5;
   explosionFrameSize  = 50;
 }
 
-void DruugeMissile::inflict_damage (SpaceObject *other) {
-//	if (other->getID() == SPACE_PLANET) other->accelerate (this, angle, kick/25., GLOBAL_MAXSPEED);
-	if (other->mass) 
-		other->accelerate (this, angle, kick / other->mass, MAX_SPEED);
-	Missile::inflict_damage(other);
-	}
+void DruugeMissile::inflict_damage (SpaceObject *other) 
+{
+  //	if (other->getID() == SPACE_PLANET) other->accelerate (this, angle, kick/25., GLOBAL_MAXSPEED);
+  if (other->mass) 
+    other->accelerate (this, angle, kick / other->mass, MAX_SPEED);
+  Missile::inflict_damage(other);
+}
 
 
 

Modified: branches/multiplayer-branch/source/sc2ships/shpkohma.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shpkohma.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc2ships/shpkohma.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 
 #include "sc2ships.h"
@@ -56,6 +55,7 @@
 };
 
 void KohrAhFRIED::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if ((other->getID() &~ SPACE_MASK) == CHMMR_SPEC) other->state = 0;
 	Shot::inflict_damage(other);
 	return;
@@ -65,6 +65,7 @@
 	ShipData *shipData, unsigned int code)
 	:
 	Ship(opos, shipAngle, shipData, code) {
+  STACKTRACE;
 	weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
 	weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
 	weaponDamage   = get_config_int("Weapon", "Damage", 0);
@@ -86,6 +87,7 @@
 	}
 
 int KohrAhMarauder::activate_weapon() {
+  STACKTRACE;
 	if (weaponFired) return(FALSE);
 	if (numblades == maxblades) {
 		weaponObject[0]->state = 0;
@@ -105,6 +107,7 @@
 	}
 
 int KohrAhMarauder::activate_special() {
+  STACKTRACE;
 	int i;
 	for(i = 0; i < 16; i++) {
 		add(new KohrAhFRIED(
@@ -115,6 +118,7 @@
 	}
 
 void KohrAhMarauder::calculate() {
+  STACKTRACE;
 	Ship::calculate();
 	
 	if (!fire_weapon) {
@@ -146,12 +150,14 @@
   passive(FALSE),
   passiveRange(orange)
 {
+  STACKTRACE;
   explosionSprite     = data->spriteWeaponExplosion;
   explosionFrameCount = 20;
   explosionFrameSize  = 40;
 }
 
 void KohrAhBlade::calculate() {
+  STACKTRACE;
 	SpaceObject *o, *t = NULL;
 	double oldrange = 999999;
 
@@ -186,12 +192,14 @@
 
 void KohrAhBlade::animateExplosion()
 {
+  STACKTRACE;
   add(new KohrAhBladeDecay(this, pos,
     vel, explosionSprite, explosionFrameCount, explosionFrameSize));
 }
 
 void KohrAhBlade::disengage()
 {
+  STACKTRACE;
   passive = TRUE;
 }
 
@@ -199,6 +207,7 @@
   SpaceSprite *osprite, int ofcount, int ofsize) :
   Animation(creator, opos, osprite, 0, ofcount, ofsize, DEPTH_EXPLOSIONS)
 {
+  STACKTRACE;
 //  vx = ovx / 2;
 //  vy = ovy / 2;
   vel = 0.5 * ovel;
@@ -210,12 +219,14 @@
   Shot(oship, Vector2(0.0, 0.0), oangle, ov, odamage, orange, oarmour, oship, osprite, 1.0),
   frame_count(ofcount)
 {
+  STACKTRACE;
 //  x += cos(angle) * 50.0;
 //  y += sin(angle) * 50.0;
   pos += 50.0 * unit_vector(angle);
 }
 
 void KohrAhFRIED::calculate() {
+  STACKTRACE;
   sprite_index = (int)((d / range) * (double)(frame_count - 1));
   Shot::calculate();
 }

Modified: branches/multiplayer-branch/source/sc2ships/shpmeltr.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shpmeltr.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc2ships/shpmeltr.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 
 #include "sc2ships.h"
@@ -76,6 +75,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponRangeUp  = scale_range(get_config_float("Weapon", "RangeUp", 0));
@@ -92,6 +92,7 @@
 
 void MelnormeTrader::calculate()
 {
+  STACKTRACE;
   Ship::calculate();
   if (weaponObject) {
     if (!weaponObject->exists()) weaponObject = NULL;
@@ -101,6 +102,7 @@
 
 int MelnormeTrader::activate_weapon()
 {
+  STACKTRACE;
   if(weaponObject)
     return(FALSE);
   add(weaponObject = new MelnormeShot(
@@ -110,6 +112,7 @@
 }
 
 int MelnormeTrader::activate_special() {
+  STACKTRACE;
   add( new MelnormeSpecial(
     Vector2(0.0, get_size().y /*(height()*/ / 2.0), angle, specialVelocity, specialFrames,
     specialRange, specialArmour, this, data->spriteSpecial, 20, 50));
@@ -129,65 +132,72 @@
   charge_phase(0),
   released(FALSE),
 	RangeUp(rangeup)
-{  
+{
+  STACKTRACE;  
 //  vx = ship->get_vx();
 //  vy = ship->get_vy();
   vel = ship->get_vel();
   set_depth(DEPTH_SHIPS+0.5);
 }
 
-void MelnormeShot::calculate() {
-	if(released) {
-		Shot::calculate();
+void MelnormeShot::calculate() 
+{
+  STACKTRACE;
+  if(released) 
+    {
+      Shot::calculate();
+    }
+  else 
+    {
+      SpaceObject::calculate();
+    }
+  if (!exists()) 
+    return;
+  frame_step += frame_time;
+  if(frame_step >= frame_size) 
+    {
+      frame_step -= frame_size;
+      frame++;
+      if(frame == frame_count) 
+	{
+	  frame = 0;
+	  if((!released) && (charge_phase < 3)) 
+	    {
+	      charge_frame++;
+	      if(charge_frame == 5) 
+		{
+		  charge_frame = 0;
+		  charge_phase++;
+		  damage_factor *= 2;
+		  armour *= 2;
+		  range += RangeUp;
+		  tw_sound->play_sound(data_full_path(data->sampleWeapon[0]));
 		}
-	else {
-		SpaceObject::calculate();
-		}
-	if (!exists()) return;
-	frame_step += frame_time;
-	if(frame_step >= frame_size) {
-		frame_step -= frame_size;
-		frame++;
-		if(frame == frame_count) {
-			frame = 0;
-			if((!released) && (charge_phase < 3)) {
-				charge_frame++;
-				if(charge_frame == 5) {
-					charge_frame = 0;
-					charge_phase++;
-					damage_factor *= 2;
-					armour *= 2;
-					range += RangeUp;
-					play_sound(data->sampleWeapon[0]);
-					}
-				}
-			}
-		}
-	sprite_index = (charge_phase * 10) + frame;
-	if(!released) {
-		if (!ship || !ship->fire_weapon) {
-//			vx = cos(angle) * v;
-//			vy = sin(angle) * v;
-			vel = v * unit_vector(angle);
-			released = TRUE;
-			play_sound(data->sampleSpecial[0]);
-			}
-		else {
-			angle = ship->get_angle();
-//			x = ship->normal_x() + (cos(angle) * (ship->width() / 2.0));
-//			y = ship->normal_y() + (sin(angle) * (ship->height() / 2.0));
-			pos = ship->normal_pos() + 0.5 * product(unit_vector(angle), ship->get_size());
-//			vx = ship->get_vx();
-//			vy = ship->get_vy();
-			vel = ship->get_vel();
-
-			}
-		}
-	return;
+	    }
 	}
+    }
+  sprite_index = (charge_phase * 10) + frame;
+  if(!released) 
+    {
+      if (!ship || !ship->fire_weapon) 
+	{
+	  vel = v * unit_vector(angle);
+	  released = TRUE;
+	  tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
+	}
+      else 
+	{
+	  angle = ship->get_angle();
+	  pos = ship->normal_pos() + 0.5 * product(unit_vector(angle), ship->get_size());
+	  vel = ship->get_vel();
+	}
+    }
+  return;
+}
 
 void MelnormeShot::animateExplosion()
 {
+  STACKTRACE;
   add( new Animation(this, pos,
     data->spriteWeaponExplosion, (charge_phase * 20), 20, 25, 
     DEPTH_EXPLOSIONS));
@@ -195,6 +205,7 @@
 
 int MelnormeShot::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   int old = iround(armour);
   Shot::handle_damage(source, normal, direct);
   if (!released && (armour > 0)) armour = old;
@@ -203,6 +214,7 @@
 
 void MelnormeShot::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
 	if (!other->exists()) return;
 	damage(other, damage_factor);
 
@@ -227,11 +239,13 @@
   frame_size(ofsize),
   frame_count(ofcount)
 {
+  STACKTRACE;
 	collide_flag_anyone = 0;
 	set_depth(DEPTH_EXPLOSIONS);
 }
 
 void MelnormeDisable::calculate() {
+  STACKTRACE;
 	frame_step+= frame_time;
 	while (frame_step >= frame_size) {
 		frame_step -= frame_size;
@@ -263,12 +277,15 @@
   disableFrames(oframes),
   disableSprite(data->spriteExtra)
 {
+  STACKTRACE;
 	collide_flag_anyone = bit(LAYER_SHIPS);
 }
 
-void MelnormeSpecial::animateExplosion() {}
+void MelnormeSpecial::animateExplosion() {
+  STACKTRACE;}
 
 void MelnormeSpecial::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if (other->isShip()) add(new MelnormeDisable( ship, 
 			(Ship *)(other), disableSprite, 20, 50, disableFrames));
 	state = 0;

Modified: branches/multiplayer-branch/source/sc2ships/shporzne.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shporzne.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc2ships/shporzne.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 #include "melee/mview.h"
 #include "melee/mcbodies.h"
@@ -59,6 +58,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   int i;
 
 	absorption = 0;
@@ -92,18 +92,21 @@
 
 void OrzNemesis::calculate_turn_left()
 {
+  STACKTRACE;
   if(!fire_special)
     Ship::calculate_turn_left();
 }
 
 void OrzNemesis::calculate_turn_right()
 {
+  STACKTRACE;
   if(!fire_special)
     Ship::calculate_turn_right();
 }
 
 int OrzNemesis::activate_weapon()
 {
+  STACKTRACE;
   if(fire_special)
     return(FALSE);
   add(new OrzMissile(
@@ -117,6 +120,7 @@
 
 int OrzNemesis::activate_special()
 {
+  STACKTRACE;
   if(turn_left && (recoil<=0))
     turret_turn_step -= frame_time * turret_turn_rate;
   if(turn_right && (recoil<=0))
@@ -152,6 +156,7 @@
 
 void OrzNemesis::calculate()
 {
+  STACKTRACE;
   int i;
 
   for(i = 0; i < MAX_MARINES; i++)
@@ -165,6 +170,7 @@
 
 void OrzNemesis::animate(Frame *space)
 {
+  STACKTRACE;
 	double rec;
 	int turret_index;
 	/*
@@ -194,6 +200,7 @@
   Missile(oship, Vector2(0.0, 0.0), oangle, ov, odamage, orange, oarmour, oship,
     osprite)
 {
+  STACKTRACE;
 //  x += cos(angle) * 30.0;
 //  y += sin(angle) * 30.0;
   pos += 30.0 * unit_vector(angle);
@@ -220,6 +227,7 @@
   slot(oSlot),
   damage_frame(-1)
 {
+  STACKTRACE;
 		layer = LAYER_SPECIAL;
 		set_depth(DEPTH_SPECIAL);
         mass = 0.001;
@@ -229,167 +237,183 @@
 		orzship = oship;
 }
 
-void OrzMarine::calculate() {
-	int    chance;
+void OrzMarine::calculate() 
+{
+  STACKTRACE;
+  int    chance;
 
-    if (!(orzship && orzship->exists()))
+  if (!(orzship && orzship->exists()))
+    {
+      orzship = 0;
+      // just this ... in case owner is changed, "ship" can still be used to do something
+    }
+
+  if (invading) 
+    {
+      
+      if (invading->exists()) 
 	{
-		orzship = 0;
-		// just this ... in case owner is changed, "ship" can still be used to do something
-	}
+	  pos = invading->normal_pos();
+	  
+	  if(damage_frame > 0) 
+	    {
+	      damage_frame -= frame_time;
+	      if(damage_frame <= 0 && invading->spritePanel) 
+		{
+		  sprite->draw(
+			       14 + ((slot % 4) * 6), 	16 + ((slot / 4) * 6), 
+			       0, invading->spritePanel->get_bitmap(0)
+			       );
+		  invading->update_panel = TRUE; 
+		}
+	      return; 
+	    }
 
-	if (invading) {
-        
-		if (invading->exists()) {
-//			x = invading->normal_x();
-//			y = invading->normal_y();
-			pos = invading->normal_pos();
-
-			if(damage_frame > 0) {
-				damage_frame -= frame_time;
-				if(damage_frame <= 0 && invading->spritePanel) {
-					sprite->draw(
-						14 + ((slot % 4) * 6), 	16 + ((slot / 4) * 6), 
-						0, invading->spritePanel->get_bitmap(0)
-						);
-					/*draw_sprite(invading->spritePanel->get_bitmap(0),	sprite->get_bitmap(0), 
-							14 + ((slot % 4) * 6), 16 + ((slot / 4) * 6));*/
-					invading->update_panel = TRUE; }
-				return; }
-
-			chance = random() % 10000;
-			if (chance < 9 * frame_time)
-			{
-				// the following is dangerous if eg a ploxis changes the owner (=ship pointer)
-				//if (ship && ((random() & 255) < (((OrzNemesis*)ship)->absorption))) {
-				if (orzship && orzship->exists() && (random() & 255) < orzship->absorption)
-				{
-					damage(orzship, 0, -1);
-				}
-
-				play_sound(data->sampleExtra[0]);
-				damage(invading, 0, 1);
-				damage_frame = 50;
-				if ( invading->spritePanel )
-				{
-				sprite->draw( 
-					14 + ((slot % 4) * 6), 
-					16 + ((slot / 4) * 6), 
-					1, invading->spritePanel->get_bitmap(0) );
-				/*draw_sprite(invading->spritePanel->get_bitmap(0), sprite->get_bitmap(1),
-						14 + ((slot % 4) * 6), 16 + ((slot / 4) * 6));*/
-				invading->update_panel = TRUE;
-			}}
-			else    if (chance < 10 * frame_time) {
-                        state = 0;
-				        play_sound(data->sampleExtra[2]);
-						if ( invading->spritePanel )
-						{
-				        blit(invading->data->spritePanel->get_bitmap(0), invading->spritePanel->get_bitmap(0),
-						14 + ((slot % 4) * 6), 16 + ((slot / 4) * 6),
-						14 + ((slot % 4) * 6), 16 + ((slot / 4) * 6), 12, 12);
-                                        invading->update_panel = TRUE;
-						}
-				        return; }
+	  chance = random() % 10000;
+	  if (chance < 9 * frame_time)
+	    {
+	      // the following is dangerous if eg a ploxis changes the owner (=ship pointer)
+	      //if (ship && ((random() & 255) < (((OrzNemesis*)ship)->absorption))) {
+	      if (orzship && orzship->exists() && (random() & 255) < orzship->absorption)
+		{
+		  damage(orzship, 0, -1);
 		}
-		else {	invading = NULL;
-			returning = TRUE;
-		        collide_flag_sameship = bit(LAYER_SHIPS);
-		        collide_flag_anyone = ALL_LAYERS;
-			sprite_index = 1; }
-        }
-	else {
-                if (!(ship && ship->exists()))
-				{
-					ship = 0;
-                        state = 0;
-						return;
-				}
-
-                if (returning)
-                        angle = trajectory_angle(ship);
-                else {
-		        if(ship->target && ship->target->exists() && (!ship->target->isInvisible()))
+	      
+	      tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
+	      damage(invading, 0, 1);
+	      damage_frame = 50;
+	      if ( invading->spritePanel )
+		{
+		  sprite->draw( 
+			       14 + ((slot % 4) * 6), 
+			       16 + ((slot / 4) * 6), 
+			       1, invading->spritePanel->get_bitmap(0) );
+		  
+		  invading->update_panel = TRUE;
+		}
+	    }
+	  else if (chance < 10 * frame_time) 
+	    {
+	      state = 0;
+	      tw_sound->play_sound(data_full_path(data->sampleExtra[2]));
+	      if ( invading->spritePanel )
+		{
+		  blit(invading->data->spritePanel->get_bitmap(0), invading->spritePanel->get_bitmap(0),
+		       14 + ((slot % 4) * 6), 16 + ((slot / 4) * 6),
+		       14 + ((slot % 4) * 6), 16 + ((slot / 4) * 6), 12, 12);
+		  invading->update_panel = TRUE;
+		}
+	      return; 
+	    }
+	}
+      else 
+	{	
+	  invading = NULL;
+	  returning = TRUE;
+	  collide_flag_sameship = bit(LAYER_SHIPS);
+	  collide_flag_anyone = ALL_LAYERS;
+	  sprite_index = 1; 
+	}
+    }
+  else 
+    {
+      if (!(ship && ship->exists()))
+	{
+	  ship = 0;
+	  state = 0;
+	  return;
+	}
+      
+      if (returning)
+	angle = trajectory_angle(ship);
+      else 
+	{
+	  if(ship->target && ship->target->exists() && (!ship->target->isInvisible()))
                                 angle = trajectory_angle(ship->target);
-                        else {  returning = true;
-		                collide_flag_sameship = bit(LAYER_SHIPS);
-		                collide_flag_anyone = ALL_LAYERS;
-			        sprite_index = 1; }
+	  else 
+	    {  
+	      returning = true;
+	      collide_flag_sameship = bit(LAYER_SHIPS);
+	      collide_flag_anyone = ALL_LAYERS;
+	      sprite_index = 1; 
+	    }
+	}
+      
+      Planet *spacePlanet = nearest_planet();
+      if (spacePlanet!=NULL) 
+	{
+	  double r = distance(spacePlanet);
+	  if (r < 0.33*spacePlanet->gravity_range) 
+	    {
+	      double t_a = trajectory_angle(spacePlanet);
+	      double d_a = normalize(t_a - angle, PI2);
+	      if (d_a > PI) d_a -= PI2;
+	      if (fabs(d_a)<PI/2) 
+		{
+		  if (d_a > 0)
+		    angle = normalize(t_a - PI/2, PI2);
+		  else
+		    angle = normalize(t_a + PI/2, PI2);
 		}
+	    }
+	}
+      
+      accelerate_gravwhip(this, angle, accel_rate * frame_time, speed_max);
+      if(hotspot_frame <= 0) 
+	{
+	  add(new Animation(this, 
+			    normal_pos() - product(unit_vector(angle), get_size()) / 2.0,
+			    game->meleedata.hotspotSprite,
+			    0, HOTSPOT_FRAMES, 50, DEPTH_HOTSPOTS));
+	  hotspot_frame += hotspot_rate;
+	}
+      if(hotspot_frame > 0) hotspot_frame-= frame_time;
+    }
 
-	        Planet *spacePlanet = nearest_planet();
-	        if (spacePlanet!=NULL) {
-                        double r = distance(spacePlanet);
-                        if (r < 0.33*spacePlanet->gravity_range) {
-                                double t_a = trajectory_angle(spacePlanet);
-                                double d_a = normalize(t_a - angle, PI2);
-                                if (d_a > PI) d_a -= PI2;
-//                                double p_a = normalize(atan3(1.9*spacePlanet->getSprite()->width()/2.0, r), PI2);
-//                                p_a = p_a - fabs(d_a);
-//                                if (p_a > 0) {
-                                if (fabs(d_a)<PI/2) {
-                                        if (d_a > 0)
-                                                angle = normalize(t_a - PI/2, PI2);
-                                        else
-                                                angle = normalize(t_a + PI/2, PI2);
-                                }
-                        }
-                }
-
-	accelerate_gravwhip(this, angle, accel_rate * frame_time, speed_max);
-                if(hotspot_frame <= 0) {
-                        add(new Animation(this, 
-					normal_pos() - product(unit_vector(angle), get_size()) / 2.0,
-//                  normal_x() - (cos(angle) * w / 2.5),
-//			        normal_y() - (sin(angle) * h / 2.5),
-					meleedata.hotspotSprite,
-			        0, HOTSPOT_FRAMES, 50, DEPTH_HOTSPOTS));
-		        hotspot_frame += hotspot_rate;
-	        }
-        	if(hotspot_frame > 0) hotspot_frame-= frame_time;
-        }
-
-	SpaceObject::calculate();
+  SpaceObject::calculate();
 }
 
 void OrzMarine::animate(Frame *space)
 {
-	if (!invading) SpaceObject::animate(space);
+  STACKTRACE;
+  if (!invading) SpaceObject::animate(space);
 }
 
-void OrzMarine::inflict_damage(SpaceObject *other) {
-	if (other->isShip() && (!returning) && (!other->sameTeam(this)) && (!other->isProtected()))
+void OrzMarine::inflict_damage(SpaceObject *other) 
+{
+  STACKTRACE;
+  if (other->isShip() && (!returning) && (!other->sameTeam(this)) && (!other->isProtected()))
+    {
+      invading = (Ship *) other;
+      
+      if (invading->damage_factor < armour)
 	{
-		invading = (Ship *) other;
-
-		if (invading->damage_factor < armour)
-		{
-			collide_flag_anyone = 0;
-			play_sound(data->sampleExtra[1]);
-			damage(invading, 0, 1);
-			if (invading->spritePanel)
-			{
-				sprite->draw(14 + ((slot % 4) * 6), 16 + ((slot / 4) * 6), 0, invading->spritePanel->get_bitmap(0) );
-				/*draw_sprite(invading->spritePanel->get_bitmap(0), sprite->get_bitmap(0),
-				14 + ((slot % 4) * 6), 16 + ((slot / 4) * 6));*/
-				invading->update_panel = TRUE;
-			}
-	}}
-	if((ship) && (other == ship) && (returning)) {
-		state = 0;
-		damage(ship, 0, -1);
+	  collide_flag_anyone = 0;
+	  tw_sound->play_sound(data_full_path(data->sampleExtra[1]));
+	  damage(invading, 0, 1);
+	  if (invading->spritePanel)
+	    {
+	      sprite->draw(14 + ((slot % 4) * 6), 16 + ((slot / 4) * 6), 0, 
+			   invading->spritePanel->get_bitmap(0) );
+	      invading->update_panel = TRUE;
+	    }
 	}
+    }
+  if((ship) && (other == ship) && (returning)) 
+    {
+      state = 0;
+      damage(ship, 0, -1);
+    }
 }
 
 int OrzMarine::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	int total = iround(normal + direct);
-	armour -= total;
-	if(armour <= 0)
-		state = 0;
-	return total;
+  STACKTRACE;
+  int total = iround(normal + direct);
+  armour -= total;
+  if(armour <= 0)
+    state = 0;
+  return total;
 }
 
-
-
 REGISTER_SHIP(OrzNemesis)

Modified: branches/multiplayer-branch/source/sc2ships/shppkufu.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shppkufu.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc2ships/shppkufu.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 #include "melee/mcbodies.h"
 
 #include "sc2ships.h"
@@ -31,6 +30,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -41,93 +41,65 @@
 	update_panel = true;
 }
 
-int PkunkFury::handle_damage(SpaceLocation *source, double normal, double direct) {
-	int r = iround(normal + direct);
-	crew -= r;
-	if (crew > 0) return r;
-
-	play_sound((SAMPLE *)(melee[MELEE_BOOMSHIP].dat));
-	game->add(new Animation(this, pos,	meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS));
-
-	
-	if (random() % 2) {
-		if (attributes & ATTRIB_NOTIFY_ON_DEATH){
-			game->ship_died(this, source);
-			attributes &= ~ATTRIB_NOTIFY_ON_DEATH;
-		}
-		die();
-		return r;
+int PkunkFury::handle_damage(SpaceLocation *source, double normal, double direct) 
+{
+  STACKTRACE;
+  int r = iround(normal + direct);
+  crew -= r;
+  if (crew > 0) 
+    return r;
+  
+  tw_sound->play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
+  game->add(new Animation(this, pos, game->meleedata.kaboomSprite, 0, KABOOM_FRAMES, 
+			  time_ratio, DEPTH_EXPLOSIONS));
+  
+  if (random() % 2) 
+    {
+      if (attributes & ATTRIB_NOTIFY_ON_DEATH)
+	{
+	  game->ship_died(this, source);
+	  attributes &= ~ATTRIB_NOTIFY_ON_DEATH;
 	}
+      die();
+      return r;
+    }
+  
+  pos = random(Vector2(3000,3000)) - Vector2(1500,1500);
+  SpaceLocation *spacePlanet = nearest_planet();
+  if (spacePlanet && (distance(spacePlanet) < 1000.0)) 
+    {
+      pos += 1000.0 * unit_vector(trajectory_angle(spacePlanet));
+    }
 	
+  state = 0;//-DEATH_FRAMES;
 	
 
-	pos = random(Vector2(3000,3000)) - Vector2(1500,1500);
-	SpaceLocation *spacePlanet = nearest_planet();
-	if (spacePlanet && (distance(spacePlanet) < 1000.0)) {
-//		x += cos(trajectory_angle(spacePlanet)) * 1000.0;
-//		y += sin(trajectory_angle(spacePlanet)) * 1000.0;
-		pos += 1000.0 * unit_vector(trajectory_angle(spacePlanet));
-		}
 	
-//	angle = random(PI2);
-//	sprite_index = get_index(angle);
-//	vx = vy = 0.0;
-//	vel = 0;
-//	crew = crew_max;
-//	batt = batt_max;
-//	reborn = TRUE;
-//	update_panel = TRUE;
-//	play_sound(data->sampleExtra[0]);
-	
-	// dangerous: a memory leak ...
-//	game->remove(this);
-	// that doesn't physically destroy it ... what does ?
-	state = 0;//-DEATH_FRAMES;
-	
+  add(new Phaser (this, 
+		  pos - PHASE_MAX * product(unit_vector(angle+0), get_size()),
+		  PHASE_MAX * product(unit_vector(angle+0), get_size()),
+		  this, sprite, sprite_index, hot_color, HOT_COLORS, 
+		  PHASE_DELAY, PHASE_MAX, PHASE_DELAY) );
+  add(new Phaser (this, 
+		  pos - PHASE_MAX * product(unit_vector(angle+PI/2), get_size()),
+		  PHASE_MAX * product(unit_vector(angle+PI/2), get_size()),
+		  NULL, sprite, (sprite_index+0)&63, hot_color, HOT_COLORS, 
+		  PHASE_DELAY, PHASE_MAX, PHASE_DELAY) );
+  add(new Phaser (this, 
+		  pos - PHASE_MAX * product(unit_vector(angle-PI/2), get_size()),
+		  PHASE_MAX * product(unit_vector(angle-PI/2), get_size()),
+		  NULL, sprite, (sprite_index-0)&63, hot_color, HOT_COLORS, 
+		  PHASE_DELAY, PHASE_MAX, PHASE_DELAY) );
 
-	
-	add(new Phaser (this, 
-//			x - cos(angle+0) * PHASE_MAX * w, 
-//			y - sin(angle+0) * PHASE_MAX * h, 
-			pos - PHASE_MAX * product(unit_vector(angle+0), get_size()),
-//			cos(angle+0) * PHASE_MAX * w, 
-//			sin(angle+0) * PHASE_MAX * h, 
-			PHASE_MAX * product(unit_vector(angle+0), get_size()),
-			this, sprite, sprite_index, hot_color, HOT_COLORS, 
-			PHASE_DELAY, PHASE_MAX, PHASE_DELAY) );
-	add(new Phaser (this, 
-//			x - cos(angle+PI/2) * PHASE_MAX * w, 
-//			y - sin(angle+PI/2) * PHASE_MAX * h, 
-			pos - PHASE_MAX * product(unit_vector(angle+PI/2), get_size()),
-//			cos(angle+PI/2) * PHASE_MAX * w, 
-//			sin(angle+PI/2) * PHASE_MAX * h, 
-			PHASE_MAX * product(unit_vector(angle+PI/2), get_size()),
-			NULL, sprite, (sprite_index+0)&63, hot_color, HOT_COLORS, 
-			PHASE_DELAY, PHASE_MAX, PHASE_DELAY) );
-	add(new Phaser (this, 
-//			x - cos(angle-PI/2) * PHASE_MAX * w, 
-//			y - sin(angle-PI/2) * PHASE_MAX * h, 
-			pos - PHASE_MAX * product(unit_vector(angle-PI/2), get_size()),
-//			cos(angle-PI/2) * PHASE_MAX * w, 
-//			sin(angle-PI/2) * PHASE_MAX * h, 
-			PHASE_MAX * product(unit_vector(angle-PI/2), get_size()),
-			NULL, sprite, (sprite_index-0)&63, hot_color, HOT_COLORS, 
-			PHASE_DELAY, PHASE_MAX, PHASE_DELAY) );
-
 	// copied from katpoly code
 	Ship *s;
 	s = game->create_ship( get_shiptype()->id, control, pos, angle, get_team() );
-
 	
+	
 	// the following prevents that a new ship will be "selected" based on this "empty" ship
 	attributes &= ~ATTRIB_NOTIFY_ON_DEATH;
 	control = 0;
 
-	//game->add( s );              // add the ship
-	//s->materialize();                // materialize it
-	//s->crew = crew;                  // set it's attributes
-	//s->batt = batt - special_drain;  // [battery has to be decreased now]
-	//s->vel = vel;
 	update_panel = true;                 // maybe the colors changed
 	// end of copy
 
@@ -139,22 +111,20 @@
 	ShipPanel *panel = new ShipPanel(s);
 	panel->window->init(game->window);
 	panel->window->locate(
-		0, 0.9,
-		0, i * (100.0/480), 
-		0, 0.1,
-		0, (100.0/480)
-		);
+			      0, 0.9,
+			      0, i * (100.0/480), 
+			      0, 0.1,
+			      0, (100.0/480)
+			      );
 	add(panel);
-	//add(s->get_ship_phaser());
 	add(s);
 	s->materialize();                // materialize it
 	s->update_panel = true;
 	
-
 	crew = 0;
 	state = 0;
 
-
+	
 	// find and delete the panel that points to the current ship
 	for ( std::list<Presence*>::iterator i = physics->presence.begin(); 
 	      i!=physics->presence.end(); 
@@ -172,12 +142,13 @@
 		  }
 	      }
 	  }
-
+	
 	return r;
-  }
+}
 
 int PkunkFury::activate_weapon()
 {
+  STACKTRACE;
   add(new AnimatedShot(this, 
     Vector2(0.0, (get_size().y / 2.0)), angle, weaponVelocity, weaponDamage, weaponRange,
     weaponArmour, this, data->spriteWeapon, 10, 1, 1.0));
@@ -193,22 +164,25 @@
 
 void PkunkFury::calculate_fire_special()
 {
+  STACKTRACE;
+  if(fire_special) 
+    {
+      if((special_recharge > 0) || (batt >= batt_max))
+	return;
+      
+      batt += special_drain;
+      if(batt > batt_max)
+	batt = batt_max;
+      
+      special_recharge = special_rate;
 
-  if(fire_special) {
-    if((special_recharge > 0) || (batt >= batt_max))
-      return;
+      tw_sound->stop_sound(data_full_path(data->sampleSpecial[special_sample]));
+      
+      special_sample = (special_sample + 1 + random(13)) % 14;
 
-    batt += special_drain;
-    if(batt > batt_max)
-      batt = batt_max;
-
-    special_recharge = special_rate;
-
-    //sound.stop(data->sampleSpecial[special_sample]);
-
-    special_sample = (special_sample + 1 + random(13)) % 14;
-	play_sound2(data->sampleSpecial[special_sample]);
-  }
+      tw_sound->stop_sound(data_full_path(data->sampleSpecial[special_sample]));
+      tw_sound->play_sound(data_full_path(data->sampleSpecial[special_sample]));
+    }
 }
 
 

Modified: branches/multiplayer-branch/source/sc2ships/shpslypr.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shpslypr.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc2ships/shpslypr.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -20,12 +20,12 @@
 
 #include "sc2ships.h"
 #include "frame.h"
-REGISTER_FILE
 
 static const int Ndirections = 16;
 
 int SlylandroProbe::accelerate_gravwhip(SpaceLocation *source, double angle, double velocity, 
 										 double max_speed) {
+  STACKTRACE;
 	if (source == this) 
 		return Ship::accelerate(source, angle, velocity, max_speed);
 	return false;
@@ -68,6 +68,7 @@
 thrustActive(FALSE),
 thrustForward(TRUE)
 {
+  STACKTRACE;
 	sprite_index2 = random() & 63;
 	segment_length = get_config_int("Weapon", "SegmentLength",0);
 	segment_dispersion = get_config_int("Weapon", "SegmentLengthDispersion",0);
@@ -87,12 +88,14 @@
 
 RGB SlylandroProbe::crewPanelColor(int k)
 {
+  STACKTRACE;
 	RGB c = {64,64,64};
 	return c;
 }
 
 void SlylandroProbe::calculate_turn_left()
 {
+  STACKTRACE;
 	if ( turn_left )
 	{
 		if (!last_turn_left)
@@ -101,20 +104,6 @@
 			realturnstep -= turn_rate * frame_time;
 	}
 
-	/*
-	if (!last_turn_left)
-	{
-		// turn at once ! This should make it look "jerky" since it responds
-		// immediately to a keypress; no delays !
-
-		realturnstep = -PI2 / Ndirections;
-	} else
-
-	// turnstep is the angle, really.
-  if(turn_left)
-		realturnstep -= turn_rate * frame_time;
-		*/
-
 	while (realturnstep < 0)
 	{
 		realturnstep += PI2 / 16;//Ndirections;
@@ -125,6 +114,7 @@
 
 void SlylandroProbe::calculate_turn_right()
 {
+  STACKTRACE;
 	if ( turn_right )
 	{
 	if (!last_turn_right)
@@ -133,19 +123,6 @@
 		realturnstep += turn_rate * frame_time;
 	}
 
-	/*
-	if (!last_turn_right)
-	{
-		// turn at once ! This should make it look "jerky" since it responds
-		// immediately to a keypress; no delays !
-
-		realturnstep = PI2 / Ndirections;
-	} else
-
-  if(turn_right)
-		realturnstep += turn_rate * frame_time;
-		*/
-
 	while (realturnstep > 0)
 	{
 		realturnstep -= PI2 / 16; // Ndirections;
@@ -157,65 +134,63 @@
 
 void SlylandroProbe::calculate()
 {
-	if (!(SlyLaser && SlyLaser->exists()) )
+  STACKTRACE;
+  if (!(SlyLaser && SlyLaser->exists()) )
+    SlyLaser = 0;
 
-		SlyLaser = 0;
+  last_turn_left = turn_left;
+  last_turn_right = turn_right;
 
+  Ship::calculate();
 	
-	last_turn_left = turn_left;
-	last_turn_right = turn_right;
-
-	Ship::calculate();
-
-	/*
-	// cause jerky movement ... 16 directions available, like in star control 2.
-	angle = (PI2/Ndirections) * int(0.5 + (Ndirections * realangle) / PI2 );
-	double v;
-	//	v = sqrt(vx*vx + vy*vy);
-	v = magnitude(vel);
-	//	vx = v * cos(angle*PI/180);
-	//	vy = v * sin(angle*PI/180);
 	
-	vel = v * unit_vector(angle);
-	// now you've jerky movement , 12 directions only.
-	*/
-	
-	if (fire_special) {
-		Query q;
-		for (q.begin(this, bit(LAYER_CBODIES), 100);q.current;q.next()) {
-			if (q.current->isAsteroid() && q.current->canCollide(this)) {
-				if (damage(q.current, 1)) {
-					batt = batt_max;
-					play_sound2(data->sampleSpecial[0]);
-				}
-			}
+  if (fire_special) 
+    {
+      Query q;
+      for (q.begin(this, bit(LAYER_CBODIES), 100);q.current;q.next()) 
+	{
+	  if (q.current->isAsteroid() && q.current->canCollide(this)) 
+	    {
+	      if (damage(q.current, 1)) 
+		{
+		  batt = batt_max;
+		  tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+		  tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
 		}
-		q.end();
+	    }
 	}
-	
-	frame+= frame_time;
-	if(frame >= 50) {
-		frame -= 50;
-		if(thrustForward) {
-			sprite_index2++;
-			if(sprite_index2 == 64)
-				sprite_index2 = 0;
-		} else {
-			sprite_index2--;
-			if(sprite_index2 == -1)
-				sprite_index2 = 63;
-		}
+      q.end();
+    }
+  
+  frame+= frame_time;
+  if(frame >= 50) 
+    {
+      frame -= 50;
+      if(thrustForward) 
+	{
+	  sprite_index2++;
+	  if(sprite_index2 == 64)
+	    sprite_index2 = 0;
+	} 
+      else 
+	{
+	  sprite_index2--;
+	  if(sprite_index2 == -1)
+	    sprite_index2 = 63;
 	}
-	sprite_index = sprite_index2;
-	
+    }
+  sprite_index = sprite_index2; 
 }
 
 void SlylandroProbe::calculate_hotspots() {
+  STACKTRACE;
 }
 void SlylandroProbe::calculate_fire_special() {
+  STACKTRACE;
 	return;
 }
 void SlylandroProbe::calculate_thrust() {
+  STACKTRACE;
 	if (thrust && !thrustActive) {
 		angle = angle + PI;
 		if (angle > PI2) angle -= PI2;
@@ -229,8 +204,7 @@
 
 int SlylandroProbe::activate_weapon()
 {
-	
-	
+  STACKTRACE;	
 	SpaceLocation *t = NULL;
 	double r = 99999;
 	int i;
@@ -240,11 +214,8 @@
 			t = s;
 			r = distance(t);
 		}
-	}
-	//add(new SlylandroLaser( this, this, t, segments, segment_length,
-    //                                     segment_dispersion, rnd_angle, aiming, dispersion));
+	}	
 	
-	
 	if (!(SlyLaser && SlyLaser->exists()) )
 	{
 		SlyLaser = new SlylandroLaserNew( this, t );
@@ -257,13 +228,9 @@
 }
 
 
-
-// ALTERNATIVE FOR THE SLYLANDRO LASER
-
-
-
 SlylandroLaserNew::SlylandroLaserNew(SpaceLocation *lroot, SpaceLocation *ltarget)
 {
+  STACKTRACE;
 	
 	max_length = 400.0;
 	existtime = 1200.0;		// in milliseconds ?
@@ -289,6 +256,7 @@
 
 void SlylandroLaserNew::calculate()
 {
+  STACKTRACE;
 	lifetime += frame_time;
 
 	if ( lifetime > existtime || !(mother && mother->exists()) )
@@ -496,6 +464,7 @@
 
 void SlylandroLaserNew::animate(Frame *frame)
 {
+  STACKTRACE;
 	int i, iline;
 	
 	if ( !(mother && mother->exists()) )

Modified: branches/multiplayer-branch/source/sc2ships/shpsupbl.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shpsupbl.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc2ships/shpsupbl.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 #include "sc2ships.h"
 
@@ -25,6 +24,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -34,6 +34,7 @@
 
 void SupoxBlade::calculate_thrust()
 {
+  STACKTRACE;
 
   if(thrust || ((fire_special) && (turn_left || turn_right || thrust))) {
     if((fire_special) && (turn_left)) {
@@ -54,31 +55,36 @@
 
 void SupoxBlade::calculate_turn_left()
 {
+  STACKTRACE;
   if(!fire_special)
     Ship::calculate_turn_left();
 }
 
 void SupoxBlade::calculate_turn_right()
 {
+  STACKTRACE;
   if(!fire_special)
     Ship::calculate_turn_right();
 }
 
 void SupoxBlade::calculate_hotspots()
 {
+  STACKTRACE;
   if(!fire_special)
     Ship::calculate_hotspots();
 }
 
 int SupoxBlade::activate_weapon()
 {
+  STACKTRACE;
   add(new Missile(this, Vector2(0.0, 0.5*get_size().y / 2.0),
     angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
     this, data->spriteWeapon));
   return(TRUE);
 }
 
-void SupoxBlade::calculate_fire_special() {}
+void SupoxBlade::calculate_fire_special() {
+  STACKTRACE;}
 
 
 

Modified: branches/multiplayer-branch/source/sc2ships/shpthrto.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shpthrto.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc2ships/shpthrto.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 #include "sc2ships.h"
 
@@ -36,6 +35,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -48,6 +48,7 @@
 }
 
 int ThraddashTorch::activate_weapon() {
+  STACKTRACE;
   add(new Missile(this, Vector2(0.0, 0.5*get_size().y),
     angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
     this, data->spriteWeapon));
@@ -55,6 +56,7 @@
 }
 
 int ThraddashTorch::activate_special() {
+  STACKTRACE;
 	accelerate(this, angle, specialThrust, MAX_SPEED);
   add(new ThraddashFlame(
 //    x ,//- cos(angle) * (width() / 2.0),
@@ -66,6 +68,7 @@
 
 void ThraddashTorch::calculate_thrust()
 {
+  STACKTRACE;
 	if(special_recharge <= 0) Ship::calculate_thrust();
 }
 
@@ -74,6 +77,7 @@
   Animation(oship, opos, osprite, 0, ofcount, ofsize, DEPTH_SHOTS),
   armour(oarmour)
 {
+  STACKTRACE;
 	  layer = LAYER_SHOTS;
 	collide_flag_anyone = ALL_LAYERS;
 	collide_flag_sameteam = ALL_LAYERS;
@@ -90,17 +94,19 @@
 
 void ThraddashFlame::calculate()
 {
+  STACKTRACE;
 	Animation::calculate();
 }
 
 int ThraddashFlame::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	int total = iround(normal + direct);
 	armour -= total;
 
 	if ((armour <= 0) || (source->isObject() && ((SpaceObject*)source)->mass)) {
 		state = 0;
 		add(new Animation(this, normal_pos(), //normal_x(), normal_y(), 
-				meleedata.sparkSprite, 0, SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
+				game->meleedata.sparkSprite, 0, SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
 		}
 	return total;
 	}

Modified: branches/multiplayer-branch/source/sc2ships/shputwju.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shputwju.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc2ships/shputwju.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 #include "frame.h"
 
@@ -27,6 +26,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -37,6 +37,7 @@
 
 void UtwigJugger::calculate()
 {
+  STACKTRACE;
         Ship::calculate();
         if (!fire_special)
                 special_recharge = 0;
@@ -44,6 +45,7 @@
 
 void UtwigJugger::calculate_fire_weapon()
 {
+  STACKTRACE;
   weapon_low = FALSE;
 
   if(fire_weapon) {
@@ -72,36 +74,46 @@
 
     weapon_recharge = weapon_rate;
 
-    play_sound2(data->sampleWeapon[0]);
+    tw_sound->stop_sound(data_full_path(data->sampleWeapon[0]));
+    tw_sound->play_sound(data_full_path(data->sampleWeapon[0]));
   }
 }
 
-void UtwigJugger::animate(Frame *space) {
-	if (special_recharge > 0) {
-		sprite->animate_character(pos, sprite_index, pallete_color[hot_color[((int)(special_recharge/10)) % HOT_COLORS]], space);
-		}
-	else sprite->animate( pos, sprite_index, space);
-	return;
+void UtwigJugger::animate(Frame *space) 
+{
+  STACKTRACE;
+  if (special_recharge > 0) 
+    {
+      sprite->animate_character(pos, sprite_index, 
+				pallete_color[hot_color[((int)(special_recharge/10)) % HOT_COLORS]], 
+				space);
+    }
+  else 
+    sprite->animate( pos, sprite_index, space);
 }
 
-int UtwigJugger::handle_damage(SpaceLocation *source, double normal, double direct) {
-	if (special_recharge > 0) {
-		batt += normal;
-		if (batt > batt_max) batt = batt_max;
-		normal = 0;
-	}
-	if (fortitude && (normal > 0)) {
-		if (normal > random(3)) normal -= fortitude;
-		if (normal < 0) normal = 0;
-	}
-	return Ship::handle_damage(source, normal, direct);
+int UtwigJugger::handle_damage(SpaceLocation *source, double normal, double direct) 
+{
+  STACKTRACE;
+  if (special_recharge > 0) 
+    {
+      batt += normal;
+      if (batt > batt_max) 
+	batt = batt_max;
+      normal = 0;
+    }
+  if (fortitude && (normal > 0)) 
+    {
+      if (normal > random(3)) 
+	normal -= fortitude;
+      if (normal < 0) normal = 0;
+    }
+  return Ship::handle_damage(source, normal, direct);
 }
 
 double UtwigJugger::isProtected() const
 {
-	return (special_recharge > 0) ? 1 : 0;
+  return (special_recharge > 0) ? 1 : 0;
 }
 
-
-
 REGISTER_SHIP(UtwigJugger)

Modified: branches/multiplayer-branch/source/sc2ships/shpzfpst.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shpzfpst.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/sc2ships/shpzfpst.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 #include <math.h>
 
@@ -56,6 +55,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -66,6 +66,7 @@
 }
 
 int ZoqFotPikStinger::activate_weapon() {
+  STACKTRACE;
   add(new ZoqFotPikShot(
     Vector2(0.0, 0.5*get_size().y), angle + ANGLE_RATIO * random(-10.0, 10.0),
     weaponVelocity, weaponDamage, weaponRange, weaponArmour, this,
@@ -75,6 +76,7 @@
 
 int ZoqFotPikStinger::activate_special()
 {
+  STACKTRACE;
   add(new ZoqFotPikTongue(
     39, specialDamage, this, data->spriteSpecial, 6, 50));
   return(TRUE);
@@ -86,10 +88,12 @@
   Shot(oship, opos, oangle, ov, odamage, orange, oarmour, oship, osprite),
   frame_count(num_frames)
 {
+  STACKTRACE;
 }
 
 void ZoqFotPikShot::calculate()
 {
+  STACKTRACE;
   Shot::calculate();
   sprite_index = (int)((d / range) * (double)(frame_count - 1));
 }
@@ -106,6 +110,7 @@
   frame_count(ofcount),
   frame_step(0)
 {
+  STACKTRACE;
   layer = LAYER_SHOTS;
   set_depth(DEPTH_SHOTS);
   damage_factor = abs(lick_factor);
@@ -122,6 +127,7 @@
 
 void ZoqFotPikTongue::calculate()
 {
+  STACKTRACE;
   int current_frame = frame;
 
   if (!(ship && ship->exists()))
@@ -154,6 +160,7 @@
 
 void ZoqFotPikTongue::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   SpaceObject::inflict_damage(other); 
   damage_factor = 0;
 

Modified: branches/multiplayer-branch/source/scp.cpp
===================================================================
--- branches/multiplayer-branch/source/scp.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/scp.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,7 +1,6 @@
-/* $Id: scp.cpp,v 1.6 2004/08/08 17:36:03 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -41,7 +40,6 @@
 #define APPLICATION_NAME "TW-Light"
 
 #include "melee.h"
-REGISTER_FILE
 #include "scp.h"
 #include "gui.h"
 #include "frame.h"
@@ -60,15 +58,48 @@
 #include "melee/mship.h" //remove
 #include "melee/mfleet.h"
 
-#include "util/sounds.h"
 
+/// Get SVN revision number from version file (this function work if user does not have subversion)
+std::string GetSVNVersion()
+{
+  std::string tw_svn_version = TW_SVNVERSION;
+  if(!(tw_svn_version=="exported"||tw_svn_version == ""))
+    return tw_svn_version;
+  
+  int i;
+  char buffy [16000] = {0};
+  PACKFILE *f;
+  
+  f = pack_fopen (data_full_path("version.txt").c_str(), F_READ);
+  if (!f)
+    {
+      tw_error("Unable to retrive version information");
+    }
+  else 
+    {
+      i = pack_fread (buffy, 15999, f);
+      pack_fclose(f);
+      buffy[i] = 0;
+    }
+  char *s = strchr(buffy, 'r');
+  if(!s)
+    {
+      return "";
+    }
+
+  char ver[30] = {0};
+  sscanf(s+1, "%s", ver);
+  return ver;
+}
+
 std::string tw_version() 
 {
+  STACKTRACE;
   std::string tw_version_string;
-	
+
   tw_version_string += std::string(APPLICATION_NAME) + " "  + std::string(TW_MAJOR_VERSION) 
     + "r" 
-    + std::string(TW_SVNVERSION)
+    + GetSVNVersion()
     + " Built: "
     + __DATE__
     + " "
@@ -81,11 +112,10 @@
 //this technique was ever created.
 #define SCPGUI_TITLE   0
 
-DATAFILE *scp = NULL;
 FILE *debug_file;
 
 /*! \brief Blits GUI background bitmap on to a video window */
-void showTitle(VideoWindow *window = &videosystem.window);
+void showTitle(VideoWindow *window = &videosystem->window);
 
 /*! \brief MELEE_EX dialog - selects alternate games as opposed to standard melee. 
   From here you can access diagnostics (DIAGNOSTICS dialog) and ship info. 
@@ -126,6 +156,7 @@
 
 Log *new_log (int logtype) 
 {
+  STACKTRACE;
   union 
   { 
     Log *log; 
@@ -158,6 +189,7 @@
 
 char *detect_gametype( Log *_log ) 
 {
+  STACKTRACE;
   int ltype;
   _log->unbuffer(Game::channel_init, &ltype, sizeof(int));
   ltype = intel_ordering(ltype);
@@ -191,8 +223,9 @@
 */
 void prepareTitleScreenAssets() 
 {
+  STACKTRACE;
   titleMusic = data_full_path("music/Robeter-Space-Gods-Loop.ogg");
-  tw_sound.play_music(titleMusic);
+  tw_sound->play_music(titleMusic);
 
   menuAccept   = data_full_path("sound/menu/MENUACCEPT.wav");
   menuFocus    = data_full_path("sound/menu/MENUFOCUS.wav");
@@ -202,57 +235,36 @@
   titlePic = load_bitmap(data_full_path("images/scptitle.jpg").c_str(), NULL);
 }
 
-/** clears the screen, and displays a loading message to the user.
-*/
-void showLoadingScreen() {
-    static BITMAP * logo = NULL;
-    static int depth = bitmap_color_depth(screen);
+/// clears the screen, and displays a loading message to the user.
+void showLoadingScreen() 
+{
+  STACKTRACE;
+  
+  std::vector<std::string> waitpics;
+  waitpics.push_back(data_full_path("images/bspab.jpg"));
+  waitpics.push_back(data_full_path("images/stangrop.jpg"));
+  
+  acquire_screen(); 
+  clear_to_color(screen, 0);
+ 
+  int pic = rand()%waitpics.size();
 
-    acquire_screen(); 
-    clear_to_color(screen, 0);
-
-    if (NULL == logo || bitmap_color_depth(screen) != depth) 
-    {
-        depth = bitmap_color_depth(screen);
-        
-	BITMAP * temp = load_bitmap(data_full_path("images/logo.bmp").c_str(),NULL);
-	logo = create_bitmap(temp->w, temp->h);
-	blit(temp, logo, 0,0, 0,0, temp->w, temp->h);
-	destroy_bitmap(temp);
-    }
-
-    if (logo != NULL ) {
-        if (screen->w/2 >= logo->w) {
-            draw_sprite(screen, logo, screen->w/2 - logo->w/2, screen->h/2 - logo->h/2);
-        }
-        else {
-            float ratio = logo->w / logo->h;
-            
-            int h = screen->h/4;
-            int w = iround(ratio * h);                
-
-            stretch_blit(logo, screen, 
-                0,0, 
-                logo->w, logo->h,
-                screen->w/2 - w/2, screen->h/2 - h/2,
-                w, h);
-        }
-    }
-
-    const char * loadString = "Loading...";
-    textout_right(screen, font, loadString, 
-        screen->w - 1*text_length(font, loadString), screen->h - 4*text_height(font), 
-        palette_color[15]);
-    release_screen();
+  BITMAP * temp = load_bitmap(waitpics[pic].c_str(), NULL);
+  stretch_blit(temp, screen, 0, 0, temp->w, temp->h, 0, 0, screen->w, screen->h);
+  destroy_bitmap(temp);
+  release_screen();
 }
 
-int is_escape_pressed() {
-	poll_keyboard();
-	return key[KEY_ESC];
+int is_escape_pressed() 
+{
+  STACKTRACE;
+  poll_keyboard();
+  return key[KEY_ESC];
 }
 
-void play_game(const char *_gametype_name, Log *_log) {
-  bool gui_stuff = false;
+void play_game(const char *_gametype_name, Log *_log) 
+{
+  STACKTRACE;
   char gametype_name[1024];
   char *c;
   Game *new_game = NULL;
@@ -262,72 +274,74 @@
   strncpy(gametype_name, _gametype_name, 1000);
   for (c = strchr(gametype_name, '_'); c; c = strchr(c, '_'))
     *c = ' ';
-  
-  
-  
-  if (scp) {
-    gui_stuff = true;
-    sound.stop_music();
-    if (scp) unload_datafile(scp);
-    scp = NULL;
-  }
-  
-  try {
-    if (game) {
-      delete game;
+
+  try 
+    {
+      if (game) 
+	{
+	  delete game;
+	  game = NULL;
+	}
+    
+      if (!_log) 
+	{
+	  _log = new Log();
+	  _log->init();
+	}
+      
+      GameType *type = gametype(gametype_name);
+      if (type)
+	new_game = type->new_game();
+      else
+	tw_error("wait a sec... I can't find that game type");
+    
+      new_game->preinit();
+      new_game->window = new VideoWindow;
+      new_game->window->preinit();
+      new_game->window->init(&videosystem->window);
+      new_game->window->locate(0,0,0,0,0,1,0,1);
+      new_game->init(_log);
+      new_game->play();
+      new_game->log->deinit();
+      new_game->setGameDone(true);
+      
+      //damn global variables!
+      // inside melee/mgame.cpp, in Game::prepare, ::game is set to the value of the current game
+      // inside ais/c_wussiebot.cpp (and some other places), ::game is used
+      delete new_game;
       game = NULL;
     }
-    
-    if (!_log) {
-      _log = new Log();
-      _log->init();
+  
+  catch (int i) 
+    {
+      if (i == -1) 
+	throw;
+      if (__error_flag & 1) 
+	throw;
+      if (i != 0) 
+	caught_error ("%s %s caught int %d", __FILE__, __LINE__, i);
+      if (__error_flag & 1) 
+	throw;
     }
-    
-    GameType *type = gametype(gametype_name);
-    if (type)
-      new_game = type->new_game();
-    else
-      tw_error("wait a sec... I can't find that game type");
-    
-    new_game->preinit();
-    new_game->window = new VideoWindow;
-    new_game->window->preinit();
-    new_game->window->init(&videosystem.window);
-    new_game->window->locate(0,0,0,0,0,1,0,1);
-    new_game->init(_log);
-    new_game->play();
-    new_game->log->deinit();
-    //game = NULL;
-    new_game->setGameDone(true);
-    
-    //damn global variables!
-    // inside melee/mgame.cpp, in Game::prepare, ::game is set to the value of the current game
-    // inside ais/c_wussiebot.cpp (and some other places), ::game is used
-    delete new_game;
-    game = NULL;
-  }
+  catch (const char *str) 
+    {
+      if (__error_flag & 1) 
+	throw;
+      caught_error("message: \"%s\"", str);
+      if (__error_flag & 1) 
+	throw;
+    }
+  catch (...) 
+    {
+      if (__error_flag & 1) 
+	throw;
+      caught_error("Ack(2)!!!\nAn error occured!\nBut I don't know what error!");
+      if (__error_flag & 1) 
+	throw;
+    }
   
-  catch (int i) {
-    if (i == -1) throw;
-    if (__error_flag & 1) throw;
-    if (i != 0) caught_error ("%s %s caught int %d", __FILE__, __LINE__, i);
-    if (__error_flag & 1) throw;
-  }
-  catch (const char *str) {
-    if (__error_flag & 1) throw;
-    caught_error("message: \"%s\"", str);
-    if (__error_flag & 1) throw;
-  }
-  catch (...) {
-    if (__error_flag & 1) throw;
-    caught_error("Ack(2)!!!\nAn error occured!\nBut I don't know what error!");
-    if (__error_flag & 1) throw;
-  }
-  
-  if (gui_stuff) {
-    prepareTitleScreenAssets();
-    showTitle();
-  }
+  prepareTitleScreenAssets();
+  showTitle();
   return;
 }
 
@@ -357,7 +371,9 @@
 int *player_config = NULL;
 int *player_team = NULL;
 
-Control *load_player(int i) {STACKTRACE
+Control *load_player(int i) 
+{
+  STACKTRACE;
 	char tmp[32];
 	Control *r = NULL;
 
@@ -371,7 +387,8 @@
 }
 
 
-class MainMenu : public BaseClass {
+class MainMenu : public BaseClass 
+{
 	public:
 	virtual void _event(Event * e);
 	virtual void preinit();
@@ -382,103 +399,119 @@
 	virtual void disable();
 	int state;
 	VideoWindow *window;
-	
-	/*! This is the title music object if the ogg title music is not available*/
-	Music * titleMusic;
 } mainmenu;
 
-void MainMenu::_event(Event *e) {
+void MainMenu::_event(Event *e) 
+{
+  STACKTRACE;
+		   
 	if (e->type == Event::VIDEO) {
 		if (e->subtype == VideoEvent::REDRAW) if (state & 1) showTitle();
 	}
 }
 
-void MainMenu::enable() {STACKTRACE
+void MainMenu::enable() 
+{
+  STACKTRACE;
+		   
 	if (!(state & 2)) window->add_callback(this);
 	state |= 3;
 }
 
-void MainMenu::disable() {STACKTRACE
-	state &=~ 1;
+void MainMenu::disable() 
+{
+  STACKTRACE;
+		   
+  state &=~ 1;
 }
 
-void MainMenu::preinit() {
-	window = NULL;
-	state = 0;
+void MainMenu::preinit() 
+{
+  STACKTRACE; 
+  window = NULL;
+  state = 0;
 }
 
-void MainMenu::init(VideoWindow *parent) {
-	if (window) window->init(parent);
-	else {
+void MainMenu::init(VideoWindow *parent) 
+{
+  STACKTRACE; 
+  if (window) window->init(parent);
+  else {
 		window = new VideoWindow();
 		window->preinit();
 		window->init(parent);
 	}
 }
 
-void MainMenu::deinit() {
-	STACKTRACE
-	if (state & 2) {
-		window->remove_callback(this);
-		window->deinit();
-		delete window;
-		window = NULL;
-	}
+void MainMenu::deinit() 
+{
+  STACKTRACE;   
+		   
+  if (state & 2) 
+    {
+      window->remove_callback(this);
+      window->deinit();
+      delete window;
+      window = NULL;
+    }
 }
 
-void MainMenu::doit() {STACKTRACE
-	int i;
-	char tmp[32];
-
-	tw_set_config_file("scp.ini");
-	if (!player_type) {		
-		MAX_PLAYERS        = get_config_int("Limits", "MaxPlayers", 12);
-		MAX_CONFIGURATIONS = get_config_int("Limits", "MaxConfigurations", 4);
-		MAX_TEAMS          = get_config_int("Limits", "MaxTeams", 6);
-		player_type = new char*[MAX_PLAYERS];
-		player_config = new int[MAX_PLAYERS];
-		player_team   = new int[MAX_PLAYERS];
-	}
-	for (i = 0; i < MAX_PLAYERS; i += 1) {
-		sprintf(tmp, "Player%d", i+1);
-		player_type[i] = strdup(get_config_string(tmp, "Type", "Human"));
-		player_config[i] = get_config_int (tmp, "Config", i % MAX_CONFIGURATIONS);
-		player_team[i] = get_config_int (tmp, "Team", 0);
-	}
-
-    prepareTitleScreenAssets();
-	showTitle();
-	enable();
-
-	int mainRet;
-	do {
-		//mainRet = popup_dialog(mainDialog, MAIN_DIALOG_MELEE);
-		mainRet = tw_do_dialog(window, mainDialog, MAIN_DIALOG_MELEE);
-		switch (mainRet) {
-			case MAIN_DIALOG_MELEE:
-				disable();
-				play_game("Melee");
-				enable();
-				break;
-			case MAIN_DIALOG_MELEE_EXTENDED:
-				disable();
-				extended_menu();
-				enable();
-				break;
-			case MAIN_DIALOG_OPTIONS:
-				showTitle();
-				options_menu(NULL);
-				break;
-			case MAIN_DIALOG_HELP:
-				show_file(data_full_path("ingame.txt").c_str());
-				break;
-			case MAIN_DIALOG_TEAMS:
-				change_teams();
-				showTitle();
-				break;
-		}
-	} while((mainRet != MAIN_DIALOG_EXIT) && (mainRet != -1));
-
+void MainMenu::doit() 
+{
+  STACKTRACE;
+		   
+  int i;
+  char tmp[32];
+  
+  tw_set_config_file("scp.ini");
+  if (!player_type) {		
+    MAX_PLAYERS        = get_config_int("Limits", "MaxPlayers", 12);
+    MAX_CONFIGURATIONS = get_config_int("Limits", "MaxConfigurations", 4);
+    MAX_TEAMS          = get_config_int("Limits", "MaxTeams", 6);
+    player_type = new char*[MAX_PLAYERS];
+    player_config = new int[MAX_PLAYERS];
+    player_team   = new int[MAX_PLAYERS];
+  }
+  for (i = 0; i < MAX_PLAYERS; i += 1) {
+    sprintf(tmp, "Player%d", i+1);
+    player_type[i] = strdup(get_config_string(tmp, "Type", "Human"));
+    player_config[i] = get_config_int (tmp, "Config", i % MAX_CONFIGURATIONS);
+    player_team[i] = get_config_int (tmp, "Team", 0);
+  }
+  
+  prepareTitleScreenAssets();
+  showTitle();
+  enable();
+  
+  int mainRet;
+  do {
+    //mainRet = popup_dialog(mainDialog, MAIN_DIALOG_MELEE);
+    mainRet = tw_do_dialog(window, mainDialog, MAIN_DIALOG_MELEE);
+    switch (mainRet) {
+    case MAIN_DIALOG_MELEE:
+      disable();
+      play_game("Melee");
+      enable();
+      break;
+    case MAIN_DIALOG_MELEE_EXTENDED:
+      disable();
+      extended_menu();
+      enable();
+      break;
+    case MAIN_DIALOG_OPTIONS:
+      showTitle();
+      options_menu(NULL);
+      break;
+    case MAIN_DIALOG_HELP:
+      show_file(data_full_path("ingame.txt").c_str());
+      break;
+    case MAIN_DIALOG_TEAMS:
+      change_teams();
+      showTitle();
+      break;
+    }
+  } while((mainRet != MAIN_DIALOG_EXIT) && (mainRet != -1));
+  
 }
 
 int tw_main(int argc, char *argv[]);
@@ -513,19 +546,18 @@
   strncpy(datapath, argv[0], i);
   chdir(datapath);
 #endif
-  
-#if (defined _MSC_VER) && (defined _DEBUG)
-  _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG|_CRTDBG_LEAK_CHECK_DF);
-#endif
-  
+
   log_debug(NULL);
   time_t start_time = time(NULL);
   log_debug("Log started at %s\n", asctime(localtime(&start_time)));
   if (allegro_init() < 0)
     tw_error_exit("Allegro initialization failed");
   create_user_ini();
-  videosystem.preinit();
   
+  VideoSystem video;
+  videosystem = &video;
+  videosystem->preinit();
+  
   try {
     init_time();
     init_error();
@@ -579,10 +611,6 @@
 	log_debug("command-line argument -window\n");
 	fullscreen = false;
       }
-      else if (!strcmp(argv[i], "-nosound") && (argc > i + 0)) {
-	log_debug("command-line argument -nosound\n");
-	sound.disable();
-      }
       else if (!strcmp(argv[i], "-nokeyboard") && (argc > i + 0)) {
 	log_debug("command-line argument -nokeyboard\n");
 	inputs &= ~1;
@@ -621,7 +649,7 @@
     srand(time(NULL));
     set_color_conversion(COLORCONV_KEEP_TRANS);
     
-    videosystem.set_resolution(screen_width, screen_height, screen_bpp, fullscreen);
+    videosystem->set_resolution(screen_width, screen_height, screen_bpp, fullscreen);
     register_bitmap_file_type("jpg", load_jpg, NULL);
     if(!theme)
 	theme = agup_theme_by_name("Photon");
@@ -634,56 +662,64 @@
     gui_text_list_proc = d_agup_text_list_proc;
 
     enable_input(inputs);
-    sound.init();
-    sound.load();
     
+    SoundSystem sound;
+    tw_sound = &sound;
+    tw_sound->set_sound_volume(tw_sound->load_sound_volume());
+    tw_sound->set_music_volume(tw_sound->load_music_volume());
+    
     showLoadingScreen();
     
     View *v = NULL;
     v = get_view ( get_config_string("View", "View", NULL) , NULL );
     if (!v) v = get_view ( "Hero", NULL );
     set_view(v);
-    
-
-    
     init_ships();
     init_fleet();
-    meleedata.init();//mainmain
     
     if (auto_play) {// FIX ME
       if (!strcmp(auto_play, "game")) play_game(auto_param, NULL);
     }
     else {
       mainmenu.preinit();
-      mainmenu.init(&videosystem.window);
+      mainmenu.init(&videosystem->window);
       mainmenu.doit();
       mainmenu.deinit();
     }
-    
+
     if(game)
       {
 	delete game;
 	game = NULL;
       }
-    meleedata.deinit();
-    sound.disable();
     disable_input(); 
   }
-  
   catch (int i) {
-    if (i == -1) throw;
-		if (__error_flag & 1) throw;
-		if (i != 0) caught_error("%s %s caught int %d", __FILE__, __LINE__, i);
-		if (__error_flag & 1) throw;
+    if (i == -1) 
+      throw;
+    if (__error_flag & 1) 
+      throw;
+    if (i != 0) 
+      {
+	char t[256];
+	sprintf(t, "caught int %d", i);
+	tw_error(t);
+      }
+    if (__error_flag & 1) 
+      throw;
   }
   catch (const char *str) {
-    if (__error_flag & 1) throw;
-    caught_error("message: \"%s\"", str);
-    if (__error_flag & 1) throw;
-	}
+    if (__error_flag & 1) 
+      throw;
+    std::string tmp = "message: \"";
+    tmp += std::string(str) + "\"";
+    tw_error(tmp.c_str());
+    if (__error_flag & 1) 
+      throw;
+  }
   catch (...) {
     if (__error_flag & 1) throw;
-    caught_error("Ack!!!\nAn error occured on startup!\nBut I don't know what error!");
+    tw_error("Ack!!!\nAn error occured on startup!\nBut I don't know what error!");
     if (__error_flag & 1) throw;
 	}
   
@@ -693,39 +729,44 @@
 
 
 
-void showTitle(VideoWindow *window) {
-	BITMAP *src = titlePic;
-	if(!src)
-	{
-		return;
-		tw_error("Unable to open title pic");
-	}
+void showTitle(VideoWindow *window) 
+{
+  STACKTRACE;
+  BITMAP *src = titlePic;
+  if(!src)
+    {
+      return;
+      tw_error("Unable to open title pic");
+    }
 
-	if (!window->surface)
-		return;
-	window->lock();
-	stretch_blit(src, window->surface, 
-		0,0,src->w,src->h,
-		window->x, window->y, window->w, window->h);
-	const char * version = tw_version().c_str();
-    textout_right(screen, font, version, 
-        screen->w - 0*text_length(font, version), screen->h - 1*text_height(font), 
-        palette_color[15]);
-	window->unlock();
-	return;
+  if (!window->surface)
+    return;
+  window->lock();
+  stretch_blit(src, window->surface, 
+	       0,0,src->w,src->h,
+	       window->x, window->y, window->w, window->h);
+
+  textout_right(screen, font, tw_version().c_str(), 
+		screen->w - 0*text_length(font, tw_version().c_str()), screen->h - 1*text_height(font), 
+		palette_color[15]);
+  window->unlock();
+  return;
 }
 
 
-const char *select_game_menu () {STACKTRACE
-	select_game_dialog[2].dp3 = game_names;
-	tw_set_config_file("client.ini");
-	select_game_dialog[2].d1 = get_config_int("Menu", "SelectGame", 0);
-	int i = tw_popup_dialog(NULL, select_game_dialog, 2);
-	if (i == -1) return NULL;
-	else {
-		set_config_int("Menu", "SelectGame", select_game_dialog[2].d1);
-		return game_names[select_game_dialog[2].d1];
-	}
+const char *select_game_menu () {
+  STACKTRACE;
+  select_game_dialog[2].dp3 = game_names;
+  tw_set_config_file("client.ini");
+  select_game_dialog[2].d1 = get_config_int("Menu", "SelectGame", 0);
+  int i = tw_popup_dialog(NULL, select_game_dialog, 2);
+  if (i == -1) 
+    return NULL;
+  else 
+    {
+      set_config_int("Menu", "SelectGame", select_game_dialog[2].d1);
+      return game_names[select_game_dialog[2].d1];
+    }
 }
 
 // MELEE_EX - dialog function
@@ -754,10 +795,9 @@
   case MELEE_EX_DIALOG_LICENSE:
   	  show_file(COPYING_FILE);
   	  break;
-  case MELEE_EX_DIALOG_SHIPINFO: {
-    ship_view_dialog(0, NULL);
-  }
-  break;
+  case MELEE_EX_DIALOG_SHIPINFO:
+    ship_view_dialog(0, reference_fleet);
+    break;
   case MELEE_EX_DIALOG_KEYTESTER: {
     keyjamming_tester();
   }
@@ -1101,8 +1141,6 @@
 
 	} while((fleetRet != FLEET_DIALOG_BACK_BUTTON) && (fleetRet != -1));
 
-//	reference_fleet = old_reference_fleet;
-
 	fleet->save("fleets.ini", tmp);
 	delete fleet;
 	showTitle();
@@ -1258,133 +1296,102 @@
 /*
  *** SHIPVIEW dialog section - begin
  */
-void ship_view_dialog(int si, Fleet *fleet) {
-	int i;
-	int r = 0;               // result of tw_do_dialog
-	const char *sname;
-	char textFile[MAX_SHIP_TEXT_FILE_SIZE] = ""; // ship description contents
-	BITMAP *sprite = NULL;
+void ship_view_dialog(int si, Fleet *fleet) 
+{
+  int i;
+  int r = 0;               // result of tw_do_dialog
+  const char *sname;
+  char textFile[MAX_SHIP_TEXT_FILE_SIZE] = ""; // ship description contents
+  BITMAP *sprite = NULL;
 
-	showLoadingScreen();
+  showLoadingScreen();
 
-	ASSERT(fleet);
+  ASSERT(fleet);
 
-	shipviewDialog[SHIPVIEW_DIALOG_LIST].d1 = si;
-	shipviewDialog[SHIPVIEW_DIALOG_LIST].dp3 = fleet;
-	shipviewDialog[SHIPVIEW_DIALOG_TXTFILE].dp = (char*)"";
-	shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp = (char*)"";//this is set later 
+  shipviewDialog[SHIPVIEW_DIALOG_LIST].d1 = si;
+  shipviewDialog[SHIPVIEW_DIALOG_LIST].dp3 = fleet;
+  shipviewDialog[SHIPVIEW_DIALOG_TXTFILE].dp = (char*)"";
+  shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp = (char*)"";//this is set later 
+  
+  // main dialog loop - begin
+  while ((r >= 0) && (r != SHIPVIEW_DIALOG_DONE)) 
+    {
+    
+      // update ship selection - begin
+      if ((r == 0) || (r == SHIPVIEW_DIALOG_LIST)) 
+	{
+	  si = shipviewDialog[SHIPVIEW_DIALOG_LIST].d1;
+	  sname = shipListboxGetter(si, NULL);
+	  if (!sname) 
+	    {
+	      sprintf(dialog_string[0], "(Null)");
+	      sprintf(dialog_string[1], "(Null)");
+	    }
+	  else 
+	    {
+	      ShipType *type = fleet->getShipType(si);
 
-	// main dialog loop - begin
-	while ((r >= 0) && (r != SHIPVIEW_DIALOG_DONE)) {
-
-		// update ship selection - begin
-		if ((r == 0) || (r == SHIPVIEW_DIALOG_LIST)) {
-			si = shipviewDialog[SHIPVIEW_DIALOG_LIST].d1;
-			sname = shipListboxGetter(si, NULL);
-			if (!sname) {
-				sprintf(dialog_string[0], "(Null)");
-				sprintf(dialog_string[1], "(Null)");
-			}
-			else {
-                
-				ShipType *type = fleet->getShipType(si);
-				
-				//DATAFILE *d;
-
-                if (sprite)
-					destroy_bitmap(sprite);
-				sprite = NULL;
-				type->data->lock();
-				if (type->data->spriteShip) {
-					sprite = create_bitmap(180, 180);
-					clear_to_color(sprite, 0);
-					type->data->spriteShip->draw( 
-						Vector2(90,90) - type->data->spriteShip->size()/2, 
-						type->data->spriteShip->size(), 
-						0, sprite 
-					);
-				}
-				type->data->unlock();
-                
-
-//				d = load_datafile_object(type->data->file, "SHIP_P00_PCX");
-
-				/*
-				if (!d) d = load_datafile_object(blah, "SHIP_S00_BMP");
-				if (!d) d = load_datafile_object(blah, "SHIP_S01_PCX");
-				if (!d) d = load_datafile_object(blah, "SHIP_S01_BMP");
-				*/
-				//if (!d) error (" viewships failed to load ship picture");
-/*
-				switch (d->type) {
-					case DAT_RLE_SPRITE: {
-						RLE_SPRITE *rle = (RLE_SPRITE*)(d->dat);
-						sprite = create_bitmap_ex(rle->color_depth, 180, 180);
-						clear_to_color(sprite, 0);
-						draw_rle_sprite(sprite, rle, 90-rle->w/2, 90-rle->h/2);
-						if (rle->color_depth != bitmap_color_depth(screen)) {
-							BITMAP *tmp = create_bitmap(180, 180);
-							convert_bitmap(sprite, tmp, 0);
-							destroy_bitmap(sprite);
-							sprite = tmp;
-						}
-					}
-					break;
-					case DAT_BITMAP: {
-						sprite = create_bitmap_ex(bitmap_color_depth(screen), 64, 100);
-						blit((BITMAP*)(d->dat), sprite, 0, 0, 0, 0, 64, 100);
-					}
-					break;
-				}
-				if (d)
-					unload_datafile_object(d);
-*/
-				// read ship text file contents
-				shipviewDialog[SHIPVIEW_DIALOG_TXTFILE].dp = (char*)textFile;
-				
-				{
-					PACKFILE * f = pack_fopen(type->text, F_READ);
-					if (!f) {
-						sprintf(textFile, "Failed to load file \"%s\"", type->text);
-					}
-					else {
-						unsigned long textFileSize = file_size(type->text);
-						if (textFileSize > MAX_SHIP_TEXT_FILE_SIZE)
-							textFileSize = MAX_SHIP_TEXT_FILE_SIZE;
-						i = pack_fread(textFile, textFileSize, f);
-						pack_fclose(f);
-						textFile[i] = '\0';
-					}
-                }
-
-				// read ship ini file contents
-				char * inifile = "";     // ship ini file contents
-				{
-					PACKFILE * f = pack_fopen(type->file, F_READ);
-					if (!f) {
-						inifile = (char*) malloc(strlen("Failed to load file \"\"") + strlen(type->file) + 1);
-						sprintf(inifile, "Failed to load file \"%s\"", type->file);
-					}
-					else {
-						unsigned long iniFileSize = file_size(type->file);
-						inifile = (char*) malloc(iniFileSize +1 );
-						i = pack_fread(inifile, iniFileSize, f);
-						pack_fclose(f);
-						inifile[i] = '\0';
-					}
-				}
-
-				// display ship description contents
-				char *c = (char*)malloc( strlen("Name: \n") + strlen(type->name) +
-					strlen("ID: \n")+strlen(type->id) +
-					strlen("Cost: \n")+3+
-					strlen("\n\n\n\nINI file: ()\n")+strlen(type->file) +
-					strlen("-------------------------\n")+strlen(inifile) );
-				char * description = c;
-				
-				c += sprintf(c, "Name: %s\n", type->name);
-				c += sprintf(c, "ID: %s\n", type->id);
-				c += sprintf(c, "Cost: %d\n", type->cost);
+	      if (sprite)
+		destroy_bitmap(sprite);
+	      sprite = NULL;
+	      type->data->lock();
+	      if (type->data->spriteShip) 
+		{
+		  sprite = create_bitmap(180, 180);
+		  clear_to_color(sprite, 0);
+		  type->data->spriteShip->draw( 
+					       Vector2(90,90) - type->data->spriteShip->size()/2, 
+					       type->data->spriteShip->size(), 
+					       0, sprite 
+					       );
+		}
+	      type->data->unlock();
+	      
+	      // read ship text file contents
+	      shipviewDialog[SHIPVIEW_DIALOG_TXTFILE].dp = (char*)textFile;
+	      {
+		PACKFILE * f = pack_fopen(type->text, F_READ);
+		if (!f) {
+		  sprintf(textFile, "Failed to load file \"%s\"", type->text);
+		}
+		else {
+		  unsigned long textFileSize = file_size(type->text);
+		  if (textFileSize > MAX_SHIP_TEXT_FILE_SIZE)
+		    textFileSize = MAX_SHIP_TEXT_FILE_SIZE;
+		  i = pack_fread(textFile, textFileSize, f);
+		  pack_fclose(f);
+		  textFile[i] = '\0';
+		}
+	      }
+	      
+	      // read ship ini file contents
+	      char * inifile = "";     // ship ini file contents
+	      {
+		PACKFILE * f = pack_fopen(type->file, F_READ);
+		if (!f) {
+		  inifile = (char*) malloc(strlen("Failed to load file \"\"") + strlen(type->file) + 1);
+		  sprintf(inifile, "Failed to load file \"%s\"", type->file);
+		}
+		else {
+		  unsigned long iniFileSize = file_size(type->file);
+		  inifile = (char*) malloc(iniFileSize +1 );
+		  i = pack_fread(inifile, iniFileSize, f);
+		  pack_fclose(f);
+		  inifile[i] = '\0';
+		}
+	      }
+	      
+	      // display ship description contents
+	      char *c = (char*)malloc( strlen("Name: \n") + strlen(type->name) +
+				       strlen("ID: \n")+strlen(type->id) +
+				       strlen("Cost: \n")+3+
+				       strlen("\n\n\n\nINI file: ()\n")+strlen(type->file) +
+				       strlen("-------------------------\n")+strlen(inifile) );
+	      char * description = c;
+	      
+	      c += sprintf(c, "Name: %s\n", type->name);
+	      c += sprintf(c, "ID: %s\n", type->id);
+	      c += sprintf(c, "Cost: %d\n", type->cost);
 				c += sprintf(c, "\n\n\n\nINI file: (%s)\n", type->file);
 				c += sprintf(c, "-------------------------\n%s", inifile);
 				
@@ -1422,7 +1429,8 @@
 		shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp = NULL;
 		free(shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp);
 	}
-
+	
+	videosystem->redraw();
 	return;
 }
 
@@ -1459,45 +1467,34 @@
 }
 
 // DIAGNOSTICS - dialog function
-void show_diagnostics() {STACKTRACE
-	int i;
-	char buffy [16000];//fix sometime
-	char buffy2[100000];//fix sometime
-	char buffy3[16000];//yeah right
-	char *tmp;
-	PACKFILE *f;
-
-	f = pack_fopen (data_full_path("version.txt").c_str(), F_READ);
-	if (!f)
-		strcpy(buffy, "Failed to load version.txt");
-	else {
-		i = pack_fread (buffy, 99999, f);
-		pack_fclose(f);
-		buffy[i] = 0;
-	}
-
-	diagnostics_dialog[DIAGNOSTICS_DIALOG_VERSION_TXT].dp = (void *) buffy;
-	diagnostics_dialog[DIAGNOSTICS_DIALOG_FILES].dp = (void *) buffy2;
-	tmp = buffy2;
-
-
-	for (i = 0; i < num_registered_files; i += 1) {
-		tmp += sprintf(tmp, "%s %s %s\n", registered_files[i].ftime, registered_files[i].fdate, registered_files[i].fname);
-	}
-	diagnostics_dialog[DIAGNOSTICS_DIALOG_MAIN].dp = (void *) buffy3;
-	tmp = buffy3;
-	tmp += get_diagnostics_string( tmp );
-
-/*	diagnostics_dialog[DIAGNOSTICS_DIALOG_SHIPS].dp = (void *) buffy4;
-	tmp = buffy4;
-	sprintf(tmp, "Ships datafiles missing: ");
-	int j = 0;
-	for (i = 0; i < num_shiptypes; i += 1) {
-		if (
-	}*/
-
-	tw_popup_dialog(NULL, diagnostics_dialog, 1);
-	return;
+void show_diagnostics() 
+{
+  int i;
+  char buffy [16000];//fix sometime
+  char buffy2[100000];//fix sometime
+  char buffy3[16000];//yeah right
+  char *tmp;
+  PACKFILE *f;
+  
+  f = pack_fopen (data_full_path("version.txt").c_str(), F_READ);
+  if (!f)
+    strcpy(buffy, "Failed to load version.txt");
+  else {
+    i = pack_fread (buffy, 99999, f);
+    pack_fclose(f);
+    buffy[i] = 0;
+  }
+  
+  diagnostics_dialog[DIAGNOSTICS_DIALOG_VERSION_TXT].dp = (void *) buffy;
+  diagnostics_dialog[DIAGNOSTICS_DIALOG_FILES].dp = (void *) buffy2;
+  tmp = buffy2;
+  
+  diagnostics_dialog[DIAGNOSTICS_DIALOG_MAIN].dp = (void *) buffy3;
+  tmp = buffy3;
+  tmp += get_diagnostics_string( tmp );
+    
+  tw_popup_dialog(NULL, diagnostics_dialog, 1);
+  return;
 }
 
 
@@ -1506,49 +1503,53 @@
  */
 
 
-void keyjamming_tester() {STACKTRACE
-	int i, j = 0;
-	char blah[256];
-
-	scare_mouse();
-	videosystem.window.lock();
-	clear_to_color(videosystem.window.surface, 0);
-	textprintf(screen, font, 40, 20, palette_color[15], "Press the keys combinations you wish to test");
-	textprintf(screen, font, 40, 40, palette_color[15], "When you're finished, press ESCAPE or F10");
-	videosystem.window.unlock();
-	unscare_mouse();
-
-	while (!key[KEY_F10] && !key[KEY_ESC]) {
-		if (videosystem.poll_redraw()) {
-			scare_mouse();
-			videosystem.window.lock();
-			clear_to_color(videosystem.window.surface, 0);
-			textprintf(screen, font, 40, 20, palette_color[15], "Press the keys combinations you wish to test");
-			textprintf(screen, font, 40, 40, palette_color[15], "When you're finished, press ESCAPE or F10");
-			videosystem.window.unlock();
-			unscare_mouse();
-		}
-		rectfill(screen, 50, 60, 500, 60 + 20 * j, palette_color[0]);
-		j = 0;
-		poll_input();
-		for (i = 0; (i < 32767) && (j < 16); i += 1) {
-			if (key_pressed(i)) {
-				key_to_description(i, blah);
-				scare_mouse();
-				acquire_screen();
-				textprintf(screen, font, 50, 60+j*20, palette_color[15], "%s", blah);
-				release_screen();
-				unscare_mouse();
-				j += 1;
-			}
-		}
-		idle(20);
+void keyjamming_tester() 
+{
+  int i, j = 0;
+  char blah[256];
+  
+  scare_mouse();
+  videosystem->window.lock();
+  clear_to_color(videosystem->window.surface, 0);
+  textprintf(screen, font, 40, 20, palette_color[15], "Press the keys combinations you wish to test");
+  textprintf(screen, font, 40, 40, palette_color[15], "When you're finished, press ESCAPE or F10");
+  videosystem->window.unlock();
+  unscare_mouse();
+  
+  while (!key[KEY_F10] && !key[KEY_ESC]) 
+    {
+      if (videosystem->poll_redraw()) 
+	{
+	  scare_mouse();
+	  videosystem->window.lock();
+	  clear_to_color(videosystem->window.surface, 0);
+	  textprintf(screen, font, 40, 20, palette_color[15], "Press the keys combinations you wish to test");
+	  textprintf(screen, font, 40, 40, palette_color[15], "When you're finished, press ESCAPE or F10");
+	  videosystem->window.unlock();
+	  unscare_mouse();
 	}
-	showTitle();
-	while (key[KEY_F10])
-		poll_keyboard();
-	clear_keybuf();
-	return;
+      rectfill(screen, 50, 60, 500, 60 + 20 * j, palette_color[0]);
+      j = 0;
+      poll_input();
+      for (i = 0; (i < 32767) && (j < 16); i += 1) {
+	if (key_pressed(i)) 
+	  {
+	    key_to_description(i, blah);
+	    scare_mouse();
+	    acquire_screen();
+	    textprintf(screen, font, 50, 60+j*20, palette_color[15], "%s", blah);
+	    release_screen();
+	    unscare_mouse();
+	    j += 1;
+	  }
+      }
+      idle(20);
+    }
+  showTitle();
+  while (key[KEY_F10])
+    poll_keyboard();
+  clear_keybuf();
+  return;
 }
 
 
@@ -1649,6 +1650,16 @@
   std::string home_file = home_ini_full_path(std::string("ships/") + ship_name);
   if(!exists(home_file.c_str()))
      CopyFile(filename, home_file.c_str());
+  
+  tw_set_config_file(home_file);
+  int version = get_config_int("Info", "Version", -1);
+  if(version<64)
+    {
+      CopyFile(filename, home_file.c_str());
+      tw_set_config_file(home_file);
+      std::string ver = GetSVNVersion();
+      set_config_string("Info", "Version", ver.c_str());
+    }
 }
 
 #ifdef WIN32

Modified: branches/multiplayer-branch/source/scp.h
===================================================================
--- branches/multiplayer-branch/source/scp.h	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/scp.h	2004-09-28 19:53:03 UTC (rev 71)
@@ -18,14 +18,13 @@
 #ifndef __SCP_H__
 #define __SCP_H__
 
-class VideoWindow;
+
 #include "allegro.h"
 
-#include "util/sounds.h"
-
 //class SAMPLE;
 
 #include <string>
+class VideoWindow;
 
 /// \brief run tests
 bool RunTests();
@@ -34,7 +33,7 @@
 
 void change_teams();
 void edit_fleet(int player) ;
-//void change_options() ;
+
 int connect_menu(VideoWindow *window, char **address, int *port) ;
 int is_escape_pressed() ;
 void ship_view_dialog(int si = 0, class Fleet *fleet = NULL);
@@ -43,6 +42,7 @@
 int scp_fleet_dialog_bitmap_proc(int msg, DIALOG* d, int c);
 
 int d_check_proc_fleeteditor(int msg, DIALOG *d, int c);
+
 // list box getter functions
 char *playerListboxGetter(int index, int *list_size) ;
 char *controlListboxGetter(int index, int *list_size) ;

Modified: branches/multiplayer-branch/source/ship.h
===================================================================
--- branches/multiplayer-branch/source/ship.h	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ship.h	2004-09-28 19:53:03 UTC (rev 71)
@@ -18,6 +18,7 @@
 #ifndef __SHIP_H__
 #define __SHIP_H__
 
+#include "util/sound.h"
 #include <allegro.h>
 
 #include "melee.h"
@@ -27,5 +28,6 @@
 #include "melee/mshot.h"
 #include "melee/manim.h"
 #include "id.h"
+#include "scp.h"
 
 #endif // __SHIP_H__

Modified: branches/multiplayer-branch/source/ships/shpaktgu.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpaktgu.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shpaktgu.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -15,10 +15,11 @@
 GNU General Public License for more details.
 */
 
+#include "util/sound.h"
 #include "ship.h"
 #include "melee/mshot.h"
-REGISTER_FILE
 #include <string.h>
+#include "scp.h"
 
 class AktunComSat : public SpaceObject {
 	int frame;
@@ -88,6 +89,7 @@
 Ship(opos, shipAngle, shipData, shipCollideFlag)
 
 {
+  STACKTRACE;
 	weaponColor  = get_config_int("Weapon", "Color", 0);
 	weaponRange1  = scale_range(get_config_float("Weapon", "Range1", 0));
 	weaponDamage = get_config_int("Weapon", "Damage", 0);
@@ -118,6 +120,7 @@
 
 int AktunGunner::activate_weapon()
 {
+  STACKTRACE;
 	if(fire_special)
 		return(FALSE);
 
@@ -140,6 +143,7 @@
 
 int AktunGunner::activate_special()
 {
+  STACKTRACE;
 //	if ((fire_weapon) && (batt >= extraDrain))
 //	{
 		if (num_ComSats == max_ComSats) {
@@ -173,113 +177,131 @@
 	  ldamage, lfcount, opos, relpos, true),
 	  owner(lowner)
 {
+  STACKTRACE;
 }
 
 void AktunLaser::inflict_damage(SpaceObject *other)
 {
-	sound.stop(owner->data->sampleWeapon[0]);
-	Laser::inflict_damage(other);
-	sound.stop((SAMPLE *)(melee[1].dat));
-	sound.play(owner->data->sampleWeapon[1]);
+  STACKTRACE;
+  tw_sound->stop_sound(data_full_path(owner->data->sampleWeapon[0]));
+  Laser::inflict_damage(other);
+  tw_sound->play_sound(data_full_path(owner->data->sampleWeapon[1]));
 }
 
 AktunComSat::AktunComSat(double oangle, double orange, int odamage,
-						 int oframes, int orechargerate, int ocolor, int oarmour, Ship *oship,
-						 SpaceSprite *osprite) :
-SpaceObject(oship, 0, 0, osprite),
-ship(oship),
-lRange(orange),
-lDamage(odamage),
-lFrames(oframes),
-lRechargeRate(orechargerate),
-lRecharge(0),
-lColor(ocolor),
-armour(oarmour)
+			 int oframes, int orechargerate, int ocolor, 
+			 int oarmour, Ship *oship,
+			 SpaceSprite *osprite) :
+  SpaceObject(oship, 0, 0, osprite),
+  ship(oship),
+  lRange(orange),
+  lDamage(odamage),
+  lFrames(oframes),
+  lRechargeRate(orechargerate),
+  lRecharge(0),
+  lColor(ocolor),
+  armour(oarmour)
 {
-	layer = LAYER_SPECIAL;
-	collide_flag_anyone = ALL_LAYERS - bit(LAYER_CBODIES);
-	angle = oangle;
-	pos = ship->normal_pos();
-	if(!(ship && ship->exists())) state = 0;
+  STACKTRACE;
+  layer = LAYER_SPECIAL;
+  collide_flag_anyone = ALL_LAYERS - bit(LAYER_CBODIES);
+  angle = oangle;
+  pos = ship->normal_pos();
+  if(!(ship && ship->exists())) state = 0;
 }
 
 void AktunComSat::calculate() {
-	
-	if(!(ship && ship->exists())) {
-		state = 0;
-		return;
+  STACKTRACE;
+  
+  if(!(ship && ship->exists())) 
+    {
+      state = 0;
+      return;
+  }
+  
+  SpaceObject::calculate();
+  
+  sprite_index++;
+  if(sprite_index == 40)
+    sprite_index = 0;
+  
+  if(lRecharge > 0) 
+    {
+      lRecharge -= frame_time;
+      return;
+    }
+  
+  vel *= 1 - .0005 * frame_time;
+  
+  if (magnitude_sqr(vel) < 0.05 * 0.05) 
+    {
+      vel = 0;
+    }
+  
+  Query q;
+  for (q.begin(this, OBJECT_LAYERS &~ bit(LAYER_CBODIES), lRange); q.currento; q.next()) 
+    {
+      if (!q.currento->isInvisible() && !q.currento->sameTeam(this)) 
+	{
+	  SpaceLocation *l;
+	  l = new PointLaser(this, pallete_color[lColor], 1, lFrames, 
+			     this, q.currento, 0);
+	  game->add(l);
+	  if (l->exists()) 
+	    {
+	      tw_sound->play_sound(data_full_path(ship->data->sampleExtra[0]));
+	      lRecharge += lRechargeRate;
+	      break;
+	    }
+	  else l->state = 0;
 	}
-	
-	SpaceObject::calculate();
-
-	sprite_index++;
-	if(sprite_index == 40)
-		sprite_index = 0;
-	
-	if(lRecharge > 0) {
-		lRecharge -= frame_time;
-		return;
-	}
-	
-	vel *= 1 - .0005 * frame_time;
-	
-	if (magnitude_sqr(vel) < 0.05 * 0.05) {
-		vel = 0;
-	}
-	
-	Query q;
-	for (q.begin(this, OBJECT_LAYERS &~ bit(LAYER_CBODIES), lRange); q.currento; q.next()) {
-		if (!q.currento->isInvisible() && !q.currento->sameTeam(this)) {
-			SpaceLocation *l;
-			l = new PointLaser(this, pallete_color[lColor], 1, lFrames, 
-				this, q.currento, 0);
-			game->add(l);
-			if (l->exists()) {
-				sound.play(ship->data->sampleExtra[0]);
-				lRecharge += lRechargeRate;
-				break;
-			}
-			else l->state = 0;
-		}
-	}
-	return;
+    }
+  return;
 }
 
-int AktunComSat::canCollide(SpaceLocation *other) {
-	return SpaceObject::canCollide(other);
+int AktunComSat::canCollide(SpaceLocation *other) 
+{
+  STACKTRACE;
+  return SpaceObject::canCollide(other);
 }
 
 int AktunComSat::handle_damage(SpaceLocation* source, double normal, double direct)
 {
-	double tot;
-	tot = normal+direct;
-	if ( tot > 0 ) {
-		armour -= iround(tot);
-		
-		if(armour <= 0) {
-			armour = 0;
-			state = 0;
-			game->add(new Animation(this, pos,
-				meleedata.kaboomSprite, 0, KABOOM_FRAMES, 50, LAYER_EXPLOSIONS));
-			sound.stop(data->sampleExtra[0]);
-			sound.play(data->sampleExtra[0]);
-		}
+  STACKTRACE;
+  double tot;
+  tot = normal+direct;
+  if ( tot > 0 ) 
+    {
+      armour -= iround(tot);
+      
+      if(armour <= 0) 
+	{
+	armour = 0;
+	state = 0;
+	game->add(new Animation(this, pos,
+				game->meleedata.kaboomSprite, 0, KABOOM_FRAMES, 50, LAYER_EXPLOSIONS));
+	tw_sound->stop_sound(data_full_path(data->sampleExtra[0]));
+	tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
 	}
-	return 1;
+    }
+  return 1;
 }
 
-void AktunComSat::death() {
-	for (int i = 0; i < ((AktunGunner*)ship)->num_ComSats; i++ ) {
-		if (((AktunGunner*)ship)->ComSat[i] == this) {
-			((AktunGunner*)ship)->ComSat[i] = NULL;
-			((AktunGunner*)ship)->num_ComSats -= 1;
-			memmove(&((AktunGunner*)ship)->ComSat[i], &((AktunGunner*)ship)->ComSat[i+1], 
-				(((AktunGunner*)ship)->num_ComSats-i) * sizeof(AktunComSat*));
-			return;
-		}
+void AktunComSat::death() 
+{
+  STACKTRACE;
+  for (int i = 0; i < ((AktunGunner*)ship)->num_ComSats; i++ ) 
+    {
+      if (((AktunGunner*)ship)->ComSat[i] == this) 
+	{
+	  ((AktunGunner*)ship)->ComSat[i] = NULL;
+	  ((AktunGunner*)ship)->num_ComSats -= 1;
+	  memmove(&((AktunGunner*)ship)->ComSat[i], &((AktunGunner*)ship)->ComSat[i+1], 
+		  (((AktunGunner*)ship)->num_ComSats-i) * sizeof(AktunComSat*));
+	  return;
 	}
+    }
 }
 
-
-
 REGISTER_SHIP(AktunGunner)
+  

Modified: branches/multiplayer-branch/source/ships/shpalabc.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpalabc.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shpalabc.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 #include "util/aastr.h"
 
@@ -27,964 +26,1044 @@
 class AlaryBC : public Ship
 {
 public:
-	int			death_frame, exp_frame;
-	bool		dying;
-	int			engine_phase;
-	double		weaponProximity, weaponVelocity, weaponAccel, weaponTR;
-	double		weaponArmour;
-	int			weaponLifetime;
+  int    death_frame, exp_frame;
+  bool   dying;
+  int    engine_phase;
+  double weaponProximity, weaponVelocity, weaponAccel, weaponTR;
+  double weaponArmour;
+  int    weaponLifetime;
+  
+  double warheadRange, warheadVelocity, warheadTR;
+  double warheadDamage, warheadArmour;
+  double specialDamage, specialArmour, turretArmour, specialDamThr;
+  double specialRange, specialVelocity, specialTurnRate;
+  double specialMaxShots;
+  bool   turrets_on, turrets_old;
+  int	 can_switch;
 
-	double		warheadRange, warheadVelocity, warheadTR;
-	double		warheadDamage, warheadArmour;
-	double		specialDamage, specialArmour, turretArmour, specialDamThr;
-	double		specialRange, specialVelocity, specialTurnRate;
-	double		specialMaxShots;
-	bool		turrets_on, turrets_old;
-	int			can_switch;
+  double specialRelativity;
+  int    side;
+  
+  double engines_armour;
+  int    engines_death_frame, engines_death_count;
+  int    old_shield_state;
 
-	double		specialRelativity;
-	int			side;
-	
-	double		engines_armour;
-	int			engines_death_frame, engines_death_count;
-	int			old_shield_state;
+  double extraThreshold, extraCapacity, extraRelaxation;
+  double extraDamageReduction, extraFuelSapReduction, extraSpeedLossReduction;
+  double extraDirectDamageReduction;
 
-	double		extraThreshold, extraCapacity, extraRelaxation;
-	double		extraDamageReduction, extraFuelSapReduction, extraSpeedLossReduction;
-	double		extraDirectDamageReduction;
-
-	double		absorbed_damage;//, residual_damage;
-
-	double		turn_step_128;
-
-	double		max_shield_flash_time, shield_flash_time, shield_flash_scale;
-
-	AlaryBCTurret *turret[3];
-
+  double absorbed_damage;//, residual_damage;
+  
+  double turn_step_128;
+  
+  double max_shield_flash_time, shield_flash_time, shield_flash_scale;
+  
+  AlaryBCTurret *turret[3];
+  
 public:
-	AlaryBC (Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code);
+  AlaryBC (Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code);
   
-	virtual void calculate();
-	virtual int  activate_weapon();
-	virtual void calculate_fire_special();
-	virtual void calculate_thrust();
-	virtual void calculate_turn_left();
-	virtual void calculate_turn_right();
-	virtual void calculate_hotspots();
-	virtual void animate(Frame *space);
-	virtual int  handle_damage(SpaceLocation* source, double normal, double direct);
-	virtual int  handle_fuel_sap(SpaceLocation *source, double normal);
-	virtual double handle_speed_loss(SpaceLocation *source, double normal);
+  virtual void calculate();
+  virtual int  activate_weapon();
+  virtual void calculate_fire_special();
+  virtual void calculate_thrust();
+  virtual void calculate_turn_left();
+  virtual void calculate_turn_right();
+  virtual void calculate_hotspots();
+  virtual void animate(Frame *space);
+  virtual int  handle_damage(SpaceLocation* source, double normal, double direct);
+  virtual int  handle_fuel_sap(SpaceLocation *source, double normal);
+  virtual double handle_speed_loss(SpaceLocation *source, double normal);
   
 };
 
 class AlaryBCTorpedo : public SpaceObject
 {
-	int			armour, lifetime, smoke_frame, inactive;
-	double		proximity, accel, maxspeed, turn_rate;
+  int    armour, lifetime, smoke_frame, inactive;
+  double proximity, accel, maxspeed, turn_rate;
 
-	int			wh_damage, wh_armour;
-	double		wh_v, wh_turn_rate, wh_range;
+  int    wh_damage, wh_armour;
+  double wh_v, wh_turn_rate, wh_range;
 
 public:
 
-	AlaryBCTorpedo(SpaceLocation *creator, double ox, double oy, double oangle, int oinactive, double oaccel, double  omaxspeed,
-		int olifetime, double oproximity, double oarmour, double otr, SpaceObject *otarget,
-		SpaceSprite *osprite,
-		double wdamage, double wrange, double warmour, double wv, double wtr);
+  AlaryBCTorpedo(SpaceLocation *creator, 
+		 double ox, double oy, double oangle, int oinactive, double oaccel, 
+		 double  omaxspeed, int olifetime, double oproximity, double oarmour, 
+		 double otr, SpaceObject *otarget,
+		 SpaceSprite *osprite,
+		 double wdamage, double wrange, double warmour, double wv, double wtr);
 
-	virtual void inflict_damage(SpaceObject *other);
-	virtual void calculate();
-	virtual int  handle_damage(SpaceLocation* source, double normal, double direct);
+  virtual void inflict_damage(SpaceObject *other);
+  virtual void calculate();
+  virtual int  handle_damage(SpaceLocation* source, double normal, double direct);
 };
 
 
 class AlaryBCWarhead : public HomingMissile
 {
-	int			smoke_frame;
+  int smoke_frame;
 public:
-	AlaryBCWarhead(SpaceLocation *creator, double ox, double oy, double oangle, double ov, double odamage,
-		double orange, double oarmour, double otrate, SpaceSprite *osprite, SpaceObject *otarget);
-	virtual void calculate();
+  AlaryBCWarhead(SpaceLocation *creator, double ox, double oy, 
+		 double oangle, double ov, double odamage,
+		 double orange, double oarmour, double otrate, 
+		 SpaceSprite *osprite, SpaceObject *otarget);
+  virtual void calculate();
 };
 
-
 class AlaryBCTurret : public SpaceLocation
 {
 public:
-	AlaryBC		*ship;
-	double		min_angle, max_angle, std_angle;
-	int			recharge;
-	bool		alive;
-	int			fire_frame[2], fire_time[2];
-	double		rel_x, rel_y;
-	double		armour;
+  AlaryBC *ship;
+  double min_angle, max_angle, std_angle;
+  int	 recharge;
+  bool	 alive;
+  int	 fire_frame[2], fire_time[2];
+  double rel_x, rel_y;
+  double armour;
 
-	int			barrel;
-	int			shots_fired;
+  int barrel;
+  int shots_fired;
 
 public:
-
-	AlaryBCTurret (AlaryBC *oship, double blah_or, double oa, double oangle,
-		double omin_angle, double omax_angle, int team);
-	double get_aim(SpaceObject *tgt);
-	SpaceObject *get_target(SpaceObject *tgt);
-	virtual void calculate();
-	void sinc_it();
+  
+  AlaryBCTurret (AlaryBC *oship, double blah_or, double oa, double oangle,
+		 double omin_angle, double omax_angle, int team);
+  double get_aim(SpaceObject *tgt);
+  SpaceObject *get_target(SpaceObject *tgt);
+  virtual void calculate();
+  void sinc_it();
 };
 
 class AlaryBCTShot : public Missile
 {
 public:
-	AlaryBCTShot(double ox, double oy, double oangle, double ov, double odamage, double orange, double oarmour,
-		SpaceLocation *creator, SpaceLocation *opos, SpaceSprite *osprite, double relativity);
+  AlaryBCTShot(double ox, double oy, double oangle, double ov, double odamage, 
+	       double orange, double oarmour,
+	       SpaceLocation *creator, SpaceLocation *opos, SpaceSprite *osprite, double relativity);
 };
 
 
 AlaryBC::AlaryBC (Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code) :
-        Ship(opos, shipAngle, shipData, code)
+  Ship(opos, shipAngle, shipData, code)
 {
 
-	engines_armour  = get_config_int("Ship", "EnginesArmour", 99);
+  engines_armour  = get_config_int("Ship", "EnginesArmour", 99);
+  
+  weaponVelocity	= scale_velocity(get_config_float("Weapon", "Velocity", 0));
+  weaponAccel		= scale_acceleration(get_config_float("Weapon", "Accel", 0), 0);
+  weaponTR		= scale_turning(get_config_float("Weapon", "TurnRate", 0));
+  weaponLifetime	= get_config_int("Weapon", "Lifetime", 0);
+  weaponArmour	        = get_config_float("Weapon", "Armour", 0);
+  weaponProximity	= scale_range(get_config_float("Weapon", "Proximity", 0));
+  
+  warheadRange	        = scale_range(get_config_float("Weapon", "WarheadRange", 0));
+  warheadVelocity	= scale_velocity(get_config_float("Weapon", "WarheadVelocity", 0));
+  warheadDamage	        = get_config_float("Weapon", "WarheadDamage", 0);
+  warheadArmour	        = get_config_float("Weapon", "WarheadArmour", 0);
+  warheadTR		= scale_turning(get_config_float("Weapon", "WarheadTurnRate", 0));
+  
+  specialRange          = scale_range(get_config_float("Special", "Range", 0));
+  specialVelocity       = scale_velocity(get_config_float("Special", "Velocity", 0));
+  specialDamage         = get_config_float("Special", "Damage", 0);
+  specialArmour         = get_config_float("Special", "Armour", 0);
+  specialTurnRate       = scale_turning(get_config_float("Special", "TurnRate", 0));
+  
+  turrets_on = false;
+  turrets_old = !turrets_on;
+  can_switch = 0;
+  
+  turretArmour    = get_config_float("Special", "TurretArmour", 0);
+  specialDamThr   = get_config_float("Special", "DamageFactorReactionThreshold", 0);
+  specialMaxShots = get_config_float("Special", "MaxShots", 1);
+  specialRelativity= get_config_float("Special", "Relativity", 0);
+  
+  side = -1;
+  
+  extraThreshold  = get_config_float("Extra", "Threshold", 0);
+  extraCapacity   = get_config_float("Extra", "Capacity", 0);
+  extraRelaxation = get_config_float("Extra", "Relaxation", 0) / 1000.0;
+  extraDamageReduction     = get_config_float("Extra", "DamageReduction", 1);
+  extraDirectDamageReduction = get_config_float("Extra", "DirectDamageReduction", 1);
+  extraFuelSapReduction    = get_config_float("Extra", "FuelSapReduction", 1);
+  extraSpeedLossReduction  = get_config_float("Extra", "SpeedLossReduction", 1);
+  
+  max_shield_flash_time = get_config_float("Extra", "ShieldFlashTime", 1);
+  shield_flash_time = max_shield_flash_time;
+  shield_flash_scale = 0;
+  
+  absorbed_damage = 0;
+  //	residual_damage = 0;
+  old_shield_state= -1;
+  engines_death_frame = -1;
+  engines_death_count = -1;
+  
+  engine_phase = 0;
+  
+  death_frame = 3500 + tw_random()%2000;
+  exp_frame = 0;
+  dying = false;
+  
+  int i;
+  for (i=0; i<3; i++) {
+    turret[i] =  new AlaryBCTurret(this, 70.7, PI2/3*i, PI2/3*i, PI2/3*i-PI/2, PI2/3*i+PI/2, ally_flag);
+    game->add(turret[i]);
+  }
 
-	weaponVelocity	= scale_velocity(get_config_float("Weapon", "Velocity", 0));
-	weaponAccel		= scale_acceleration(get_config_float("Weapon", "Accel", 0), 0);
-	weaponTR		= scale_turning(get_config_float("Weapon", "TurnRate", 0));
-	weaponLifetime	= get_config_int("Weapon", "Lifetime", 0);
-	weaponArmour	= get_config_float("Weapon", "Armour", 0);
-	weaponProximity	= scale_range(get_config_float("Weapon", "Proximity", 0));
-
-	warheadRange	= scale_range(get_config_float("Weapon", "WarheadRange", 0));
-	warheadVelocity	= scale_velocity(get_config_float("Weapon", "WarheadVelocity", 0));
-	warheadDamage	= get_config_float("Weapon", "WarheadDamage", 0);
-	warheadArmour	= get_config_float("Weapon", "WarheadArmour", 0);
-	warheadTR		= scale_turning(get_config_float("Weapon", "WarheadTurnRate", 0));
-	
-	specialRange    = scale_range(get_config_float("Special", "Range", 0));
-    specialVelocity = scale_velocity(get_config_float("Special", "Velocity", 0));
-	specialDamage   = get_config_float("Special", "Damage", 0);
-	specialArmour   = get_config_float("Special", "Armour", 0);
-	specialTurnRate = scale_turning(get_config_float("Special", "TurnRate", 0));
-
-	turrets_on = false;
-	turrets_old = !turrets_on;
-	can_switch = 0;
-
-    turretArmour    = get_config_float("Special", "TurretArmour", 0);
-	specialDamThr   = get_config_float("Special", "DamageFactorReactionThreshold", 0);
-	specialMaxShots = get_config_float("Special", "MaxShots", 1);
-	specialRelativity= get_config_float("Special", "Relativity", 0);
-
-	side = -1;
-
-	extraThreshold  = get_config_float("Extra", "Threshold", 0);
-	extraCapacity   = get_config_float("Extra", "Capacity", 0);
-	extraRelaxation = get_config_float("Extra", "Relaxation", 0) / 1000.0;
-	extraDamageReduction     = get_config_float("Extra", "DamageReduction", 1);extraDirectDamageReduction = get_config_float("Extra", "DirectDamageReduction", 1);
-	extraFuelSapReduction    = get_config_float("Extra", "FuelSapReduction", 1);
-    extraSpeedLossReduction  = get_config_float("Extra", "SpeedLossReduction", 1);
-
-	max_shield_flash_time = get_config_float("Extra", "ShieldFlashTime", 1);
-	shield_flash_scale = 0;
-
-	absorbed_damage = 0;
-//	residual_damage = 0;
-	old_shield_state= -1;
-	engines_death_frame = -1;
-	engines_death_count = -1;
-
-	engine_phase = 0;
-
-	death_frame = 3500 + tw_random()%2000;
-	exp_frame = 0;
-	dying = false;
-
-	int i;
-	for (i=0; i<3; i++) {
-		turret[i] =  new AlaryBCTurret(this, 70.7, PI2/3*i, PI2/3*i, PI2/3*i-PI/2, PI2/3*i+PI/2, ally_flag);
-		game->add(turret[i]);
-	}
-
-	turn_step_128 = 0;
-
-	sprite_index = iround(angle / (PI2/128)) + 32;
-	sprite_index &= 127;
-
+  turn_step_128 = 0;
+  
+  sprite_index = iround(angle / (PI2/128)) + 32;
+  sprite_index &= 127;
+  
 }
 
 void AlaryBC::calculate()
 {
-	STACKTRACE
-	update_panel = true;
+  STACKTRACE;
+  update_panel = true;
 
-	if (crew <= 0) {
-		death_frame -= frame_time;
-		if (death_frame <= 0) handle_damage(this,777,888);
-		turn_step_128 += turn_rate * frame_time;
-		
-		double aaa, rrr;
-		exp_frame -= frame_time;
-		while (exp_frame <= 0) {
-			exp_frame += 90+tw_random()%300;
-			aaa = PI2 * ((tw_random()%1001)/1000.0);
-			rrr = 66*sqrt((tw_random()%1001)/1000.0);
-			if (tw_random()%2 == 0) {
-				SpaceLocation *ani = new Animation(this, pos+rrr*unit_vector(aaa), data->spriteSpecialExplosion, 0, 10, 50, DEPTH_EXPLOSIONS);
-				game->add(ani); }
-//				ani->play_sound((SAMPLE *)(melee[MELEE_BOOM + 1].dat));}
-			else {
-				SpaceLocation *ani = new Animation(this, pos+rrr*unit_vector(aaa), data->spriteExtraExplosion, 0, 10, 50, DEPTH_EXPLOSIONS);
-				game->add(ani);
-				ani->play_sound(data->sampleWeapon[2]); }
-//				ani->play_sound((SAMPLE *)(melee[MELEE_BOOM + 3].dat)); }
-		}
+  if (crew <= 0) 
+    {
+      death_frame -= frame_time;
+      if (death_frame <= 0) handle_damage(this,777,888);
+      turn_step_128 += turn_rate * frame_time;
+      
+      double aaa, rrr;
+      exp_frame -= frame_time;
+      while (exp_frame <= 0) 
+	{
+	  exp_frame += 90+tw_random()%300;
+	  aaa = PI2 * ((tw_random()%1001)/1000.0);
+	  rrr = 66*sqrt((tw_random()%1001)/1000.0);
+	  if (tw_random()%2 == 0) 
+	    {
+	      SpaceLocation *ani = new Animation(this, pos+rrr*unit_vector(aaa), 
+						 data->spriteSpecialExplosion, 0, 10, 50, 
+						 DEPTH_EXPLOSIONS);
+	      game->add(ani); 
+	    }
+	else 
+	  {
+	    SpaceLocation *ani = new Animation(this, pos+rrr*unit_vector(aaa), 
+					       data->spriteExtraExplosion, 0, 10, 50, DEPTH_EXPLOSIONS);
+	    game->add(ani);
+	    tw_sound->play_sound(data_full_path(data->sampleWeapon[2])); 
+	  }
+	  tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND4)); 
 	}
-
-
-	if (!fire_special)
-		can_switch = true;
-
-	turn_step_128 += turn_step;
-	turn_step = 0;
-
-    Ship::calculate();
-
-	while(fabs(turn_step_128) > (PI2/64) / 4) {
-		if(turn_step_128 < 0.0) {
-			angle -= (PI2/128);
-			turn_step_128 += (PI2/128); }
-		else
-			if(turn_step_128 > 0.0) {
-				angle += (PI2/128);
-				turn_step_128 -= (PI2/128); }
-		if(angle < 0.0)
-			angle += PI2;
-		if(angle >= PI2)
-			angle -= PI2;
+    }
+  
+  
+  if (!fire_special)
+    can_switch = true;
+  
+  turn_step_128 += turn_step;
+  turn_step = 0;
+  
+  Ship::calculate();
+  
+  while(fabs(turn_step_128) > (PI2/64) / 4) 
+    {
+      if(turn_step_128 < 0.0) 
+	{
+	  angle -= (PI2/128);
+	  turn_step_128 += (PI2/128); 
 	}
+      else
+	if(turn_step_128 > 0.0) 
+	  {
+	    angle += (PI2/128);
+	    turn_step_128 -= (PI2/128); 
+	  }
+      if(angle < 0.0)
+	angle += PI2;
+      if(angle >= PI2)
+	angle -= PI2;
+    }
+  
+  sprite_index = iround(angle / (PI2/128)) + 32;
+  sprite_index &= 127;
+  
+  int i;
+  for (i=0; i<3; i++)
+    turret[i]->sinc_it();
 
-	sprite_index = iround(angle / (PI2/128)) + 32;
-	sprite_index &= 127;
-
-	int i;
-	for (i=0; i<3; i++)
-		turret[i]->sinc_it();
-
-
-	if (engines_death_frame > 0) {
-		if (engines_death_count > 0) engines_death_count -= frame_time;
-		else {
-			engines_death_count += 100 +random()%200;
-			engines_death_frame--;
-			double tx = cos(angle), ty = sin(angle);
-			double rrr= 42 - (random() % 85);
-			double xx = ( -54*tx - rrr*ty);
-			double yy = ( -54*ty + rrr*tx);
-			game->add(new Animation(this, pos + Vector2(xx,yy), data->spriteSpecialExplosion, 0, 10, 50, DEPTH_SHIPS-0.25));
-		}
+  
+  if (engines_death_frame > 0) 
+    {
+      if (engines_death_count > 0) engines_death_count -= frame_time;
+      else 
+	{
+	  engines_death_count += 100 +random()%200;
+	  engines_death_frame--;
+	  double tx = cos(angle), ty = sin(angle);
+	  double rrr= 42 - (random() % 85);
+	  double xx = ( -54*tx - rrr*ty);
+	  double yy = ( -54*ty + rrr*tx);
+	  game->add(new Animation(this, pos + Vector2(xx,yy), data->spriteSpecialExplosion, 0, 10, 50, DEPTH_SHIPS-0.25));
 	}
+    }
 
-	int aaa = (int)floor(3.999 * absorbed_damage / extraCapacity);
-
-	if ((aaa != old_shield_state) || (turrets_on != turrets_old)) {
-		int i;
-		for (i=6; i>0; i--)
-			spritePanel->overlay(1, 7+aaa+(turrets_on?4:0), spritePanel->get_bitmap(i));
-		update_panel = true;
-		old_shield_state = aaa; 
-		turrets_old = turrets_on;
-	}
-
-	absorbed_damage -= extraRelaxation * frame_time;
-	if (absorbed_damage < 0) absorbed_damage = 0;
-
-	shield_flash_time -= frame_time * 1E-3;
-	if (shield_flash_time < 0)
-		shield_flash_time = 0;
+  int aaa = (int)floor(3.999 * absorbed_damage / extraCapacity);
+  
+  if ((aaa != old_shield_state) || (turrets_on != turrets_old)) {
+    int i;
+    for (i=6; i>0; i--)
+      spritePanel->overlay(1, 7+aaa+(turrets_on?4:0), spritePanel->get_bitmap(i));
+    update_panel = true;
+    old_shield_state = aaa; 
+    turrets_old = turrets_on;
+  }
+  
+  absorbed_damage -= extraRelaxation * frame_time;
+  if (absorbed_damage < 0) absorbed_damage = 0;
+  
+  shield_flash_time -= frame_time * 1E-3;
+  if (shield_flash_time < 0)
+    shield_flash_time = 0;
 };
 
 int AlaryBC::activate_weapon()
 {
-	STACKTRACE
-	if (crew <= 0) return false;
-
-	game->add(new AlaryBCTorpedo(this, 30*side, 0, angle, 350/*oinactive*/, weaponAccel, weaponVelocity,
-		weaponLifetime, weaponProximity, weaponArmour, weaponTR, target,
-		data->spriteWeapon, warheadDamage,  warheadRange, warheadArmour, warheadVelocity, warheadTR));
-
-	side *= -1;
-	return true;
+  STACKTRACE;
+  if (crew <= 0) return false;
+  
+  game->add(new AlaryBCTorpedo(this, 30*side, 0, angle, 
+			       350/*oinactive*/, weaponAccel, weaponVelocity,
+			       weaponLifetime, weaponProximity, weaponArmour, 
+			       weaponTR, target,
+			       data->spriteWeapon, warheadDamage,  warheadRange, 
+			       warheadArmour, warheadVelocity, warheadTR));
+  
+  side *= -1;
+  return true;
 }
 
 void AlaryBC::calculate_fire_special()
 {
-	STACKTRACE
-	if (crew <= 0) return;
-
-	if (fire_special && can_switch) {
-		can_switch = false;
-		turrets_on = !turrets_on; }
-
+  STACKTRACE;
+  if (crew <= 0) return;
+  
+  if (fire_special && can_switch) 
+    {
+      can_switch = false;
+      turrets_on = !turrets_on; 
+    }
+  
 }
 
 void AlaryBC::calculate_thrust()
 {
-	STACKTRACE
-	if (crew <= 0) return;
-    Ship::calculate_thrust();
+  STACKTRACE;
+  if (crew <= 0) 
+    return;
+  Ship::calculate_thrust();
 }
 
 void AlaryBC::calculate_turn_left()
 {
-	STACKTRACE
-	if (crew <= 0) return;
-	if ((turn_left)&&(!turn_right))
-		turn_step_128 -= turn_rate * frame_time;
+  STACKTRACE;
+  if (crew <= 0) 
+    return;
+  if ((turn_left)&&(!turn_right))
+    turn_step_128 -= turn_rate * frame_time;
 }
 
 void AlaryBC::calculate_turn_right()
 {
-	STACKTRACE
-	if (crew <= 0) return;
-	if ((turn_right)&&(!turn_left))
-		turn_step_128 += turn_rate * frame_time;
+  STACKTRACE;
+  if (crew <= 0) 
+    return;
+  if ((turn_right)&&(!turn_left))
+    turn_step_128 += turn_rate * frame_time;
 }
 
 void AlaryBC::calculate_hotspots()
 {
-	STACKTRACE
-	if (crew <= 0) return;
-	if (engines_armour > 0) return;
-	if((thrust) && (hotspot_frame <= 0)) {
-		game->add(new Animation(this,
-			pos - unit_vector(angle)*size.x/3.8,
-//			normal_x() - (cos(angle) * w / 3.8),
-//			normal_y() - (sin(angle) * h / 3.8),
-			meleedata.hotspotSprite, 0, HOTSPOT_FRAMES, time_ratio, LAYER_HOTSPOTS));
-		hotspot_frame += hotspot_rate; }
-	if (hotspot_frame > 0) hotspot_frame -= frame_time;
+  STACKTRACE;
+  if (crew <= 0) 
+    return;
+  if (engines_armour > 0) 
+    return;
+  if((thrust) && (hotspot_frame <= 0)) 
+    {
+      game->add(new Animation(this,
+			      pos - unit_vector(angle)*size.x/3.8,
+			      game->meleedata.hotspotSprite, 0, HOTSPOT_FRAMES, time_ratio, LAYER_HOTSPOTS));
+      hotspot_frame += hotspot_rate; 
+    }
+  if (hotspot_frame > 0) hotspot_frame -= frame_time;
 	return;
 }
 
 
 void AlaryBC::animate(Frame *space)
 {
-	STACKTRACE
-	if (state == 0) return;
-
-	double tx = cos(angle), ty = sin(angle);
-
-	if ((thrust)&&(engines_armour > 0)&&(crew>0)) {
-		engine_phase = (engine_phase + 1) % 2;
-		data->more_sprites[3]->animate(Vector2(pos.x+0.5-50*tx, pos.y+0.5-50*ty), engine_phase, space);
-		data->more_sprites[4]->animate(Vector2(pos.x+0.5-49*tx-16*ty, pos.y+0.5-49*ty+16*tx), engine_phase, space);
-		data->more_sprites[4]->animate(Vector2(pos.x+0.5-49*tx+16*ty, pos.y+0.5-49*ty-16*tx), engine_phase, space);
-		data->more_sprites[5]->animate(Vector2(pos.x+0.5-49.5*tx-28.5*ty, pos.y+0.5-49.5*ty+28.5*tx), engine_phase, space);
-		data->more_sprites[5]->animate(Vector2(pos.x+0.5-49.5*tx+28.5*ty, pos.y+0.5-49.5*ty-28.5*tx), engine_phase, space);
-		data->more_sprites[6]->animate(Vector2(pos.x+0.5-48*tx-39*ty, pos.y+0.5-48*ty+39*tx), engine_phase, space);
-		data->more_sprites[6]->animate(Vector2(pos.x+0.5-48*tx+39*ty, pos.y+0.5-48*ty-39*tx), engine_phase, space);
+  STACKTRACE;
+  if (state == 0) 
+    return;
+  
+  double tx = cos(angle), ty = sin(angle);
+  
+  if ((thrust)&&(engines_armour > 0)&&(crew>0)) 
+    {
+      engine_phase = (engine_phase + 1) % 2;
+      data->more_sprites[3]->animate(Vector2(pos.x+0.5-50*tx, pos.y+0.5-50*ty), engine_phase, space);
+      data->more_sprites[4]->animate(Vector2(pos.x+0.5-49*tx-16*ty, 
+					     pos.y+0.5-49*ty+16*tx), engine_phase, space);
+      data->more_sprites[4]->animate(Vector2(pos.x+0.5-49*tx+16*ty, 
+					     pos.y+0.5-49*ty-16*tx), engine_phase, space);
+      data->more_sprites[5]->animate(Vector2(pos.x+0.5-49.5*tx-28.5*ty, 
+					     pos.y+0.5-49.5*ty+28.5*tx), engine_phase, space);
+      data->more_sprites[5]->animate(Vector2(pos.x+0.5-49.5*tx+28.5*ty, 
+					     pos.y+0.5-49.5*ty-28.5*tx), engine_phase, space);
+      data->more_sprites[6]->animate(Vector2(pos.x+0.5-48*tx-39*ty, 
+					     pos.y+0.5-48*ty+39*tx), engine_phase, space);
+      data->more_sprites[6]->animate(Vector2(pos.x+0.5-48*tx+39*ty, 
+					     pos.y+0.5-48*ty-39*tx), engine_phase, space);
+    }
+  
+  if ( shield_flash_time == 0 )
+    sprite->animate(pos,sprite_index, space);
+  else
+    {
+      int col = makecol(150,0,150);
+      sprite->animate_character(pos, sprite_index, col, space);
+      
+      int _old_trans = aa_get_trans();
+      aa_set_trans ( iround(128 * shield_flash_scale * shield_flash_time / max_shield_flash_time) );
+      sprite->animate(pos,sprite_index, space);
+      aa_set_trans(_old_trans);
+    }
+  
+  int i;
+  for (i=0; i<3; i++) 
+    {
+      double si, ta, ttx, tty, rx, ry;
+      rx = turret[i]->rel_x; ry = turret[i]->rel_y;
+      if (turret[i]->alive) 
+	{
+	  si = iround(normalize(angle+turret[i]->angle,PI2) / (PI2/128));
+	  ta = si * (PI2/128);
+	  ttx = cos(ta); tty = sin(ta);
+	  if (turret[i]->fire_frame[0] < 4)
+	    data->more_sprites[2]->animate(Vector2(pos.x+0.5+ry*tx-rx*ty + 
+						   13*ttx+3*tty, pos.y+0.5+ry*ty+rx*tx + 13*tty-3*ttx), 
+					   turret[i]->fire_frame[0], space);
+	  if (turret[i]->fire_frame[1] < 4)
+	    data->more_sprites[2]->animate(Vector2(pos.x+0.5+ry*tx-rx*ty + 13*ttx-3*tty, 
+						   pos.y+0.5+ry*ty+rx*tx + 13*tty+3*ttx), 
+					   turret[i]->fire_frame[1], space);
+	  data->more_sprites[0]->animate(Vector2(pos.x+0.5+ry*tx-rx*ty, 
+						 pos.y+0.5+ry*ty+rx*tx), 
+					 (iround(si) + 32) & 127, space);
 	}
-
-	if ( shield_flash_time == 0 )
-		sprite->animate(pos,sprite_index, space);
-	else
+      else	
 	{
-		int col = makecol(150,0,150);
-		sprite->animate_character(pos, sprite_index, col, space);
-
-		int	_old_trans = aa_get_trans();
-		aa_set_trans ( iround(128 * shield_flash_scale * shield_flash_time / max_shield_flash_time) );
-		sprite->animate(pos,sprite_index, space);
-		aa_set_trans(_old_trans);
+	  data->more_sprites[1]->animate(Vector2(pos.x+0.5+ry*tx-rx*ty, 
+						 pos.y+0.5+ry*ty+rx*tx), 
+					 ((iround(normalize(angle+turret[i]->angle,PI2)/(PI2/128)) 
+					   + 32) & 127), space); 
 	}
-
-	int i;
-	for (i=0; i<3; i++) {
-		double si, ta, ttx, tty, rx, ry;
-		rx = turret[i]->rel_x; ry = turret[i]->rel_y;
-		if (turret[i]->alive) {
-			si = iround(normalize(angle+turret[i]->angle,PI2) / (PI2/128));
-			ta = si * (PI2/128);
-            ttx = cos(ta); tty = sin(ta);
-			if (turret[i]->fire_frame[0] < 4)
-				data->more_sprites[2]->animate(Vector2(pos.x+0.5+ry*tx-rx*ty + 13*ttx+3*tty, pos.y+0.5+ry*ty+rx*tx + 13*tty-3*ttx), turret[i]->fire_frame[0], space);
-			if (turret[i]->fire_frame[1] < 4)
-				data->more_sprites[2]->animate(Vector2(pos.x+0.5+ry*tx-rx*ty + 13*ttx-3*tty, pos.y+0.5+ry*ty+rx*tx + 13*tty+3*ttx), turret[i]->fire_frame[1], space);
-			data->more_sprites[0]->animate(Vector2(pos.x+0.5+ry*tx-rx*ty, pos.y+0.5+ry*ty+rx*tx), (iround(si) + 32) & 127, space);
-		}
-		else	{
-			data->more_sprites[1]->animate(Vector2(pos.x+0.5+ry*tx-rx*ty, pos.y+0.5+ry*ty+rx*tx), ((iround(normalize(angle+turret[i]->angle,PI2)/(PI2/128)) + 32) & 127), space); }
-	}
-
+    }
 };
 
 
 int AlaryBC::handle_damage(SpaceLocation* source, double normal, double direct)
 {
-	STACKTRACE
-	double total = 0;
+  STACKTRACE;
+  double total = 0;
+  
+  //	check for "repair"
 
-//	check for "repair"
+  if (normal < 0) 
+    {
+      crew -= normal;
+      normal = 0; 
+    }
+  if (direct < 0) 
+    {
+      crew -= direct;
+      direct = 0; 
+    }
+  
+  if (crew > crew_max) 
+    crew = crew_max;
+  
+  if (normal+direct <= 0) 
+    return 0;
+  
+  //      damage reduction
 
-	if (normal < 0) {
-		crew -= normal;
-		normal = 0; }
-	if (direct < 0) {
-		crew -= direct;
-		direct = 0; }
-
-	if (crew > crew_max) crew = crew_max;
-
-	if (normal+direct <= 0) return 0;
-	
-	/*
-	Ini settings:
-	Threshold = 4
-	Capacity = 20
-	DamageReduction = 8.0
-	DirectDamageReduction = 2.0	
-
-	Relaxation = 3.5		reduction of absorbed_damage per second.
-	*/
-//      damage reduction
-
-	if (normal > extraThreshold) {
-		absorbed_damage += extraThreshold;
-		total += normal / extraDamageReduction;
-		total += (normal - extraThreshold) / extraDirectDamageReduction; }
-	else {
-		absorbed_damage += normal;
-		total += normal / extraDamageReduction; }
-
-	if (absorbed_damage > extraCapacity)
+  if (normal > extraThreshold) 
+    {
+      absorbed_damage += extraThreshold;
+      total += normal / extraDamageReduction;
+      total += (normal - extraThreshold) / extraDirectDamageReduction; 
+    }
+  else 
+    {
+      absorbed_damage += normal;
+      total += normal / extraDamageReduction; 
+    }
+  
+  if (absorbed_damage > extraCapacity)
+    {
+      // shield "fails", and the ships absorbs damage relatively normally (except the default reduction)
+      total += (absorbed_damage - extraCapacity) / extraDirectDamageReduction;
+      absorbed_damage = extraCapacity;
+    } 
+  else 
+    {
+      // give some sound for the shield if the shield absorbs its damage.
+      if (data->sampleExtra.size() >= 2)
 	{
-		// shield "fails", and the ships absorbs damage relatively normally (except the default reduction)
-		total += (absorbed_damage - extraCapacity) / extraDirectDamageReduction;
-		absorbed_damage = extraCapacity;
-	} else {
-		// give some sound for the shield if the shield absorbs its damage.
-		if (data->num_extra_samples >= 2)
-			play_sound(data->sampleExtra[1]);
-		shield_flash_time = max_shield_flash_time;	// 1 second ?
-		// 0=shield is almost drained, 1=shield is maxed.
-		shield_flash_scale = (extraCapacity - absorbed_damage) / extraCapacity;
+	  tw_sound->play_sound(data_full_path(data->sampleExtra[1]));
 	}
-
-//      direct_damage
-	total += direct / extraDirectDamageReduction;
-
-//      damage to deal right now
-//	int total = floor(residual_damage);
-//	residual_damage -= total;
-
-
+      shield_flash_time = max_shield_flash_time;	// 1 second ?
+      // 0=shield is almost drained, 1=shield is maxed.
+      shield_flash_scale = (extraCapacity - absorbed_damage) / extraCapacity;
+    }
+  
+  //      direct_damage
+  total += direct / extraDirectDamageReduction;
+  
+  
 //      hit zone calculation
 
-	Vector2 dp = source->normal_pos();
-	double dx = dp.x;//source->normal_x();
-	double dy = dp.y;//source->normal_y();
-	if (source->isLine()) {
-		dx += ((SpaceLine*)source)->edge_x();
-		dy += ((SpaceLine*)source)->edge_y(); }
-	dx = min_delta(dx, pos.x, map_size.x);
-	dy = min_delta(dy, pos.y, map_size.y);
+  Vector2 dp = source->normal_pos();
+  double dx = dp.x;//source->normal_x();
+  double dy = dp.y;//source->normal_y();
+  if (source->isLine()) {
+    dx += ((SpaceLine*)source)->edge_x();
+    dy += ((SpaceLine*)source)->edge_y(); }
+  dx = min_delta(dx, pos.x, map_size.x);
+  dy = min_delta(dy, pos.y, map_size.y);
 
-	double alpha = normalize(atan3(dy, dx) - angle, PI2);
+  double alpha = normalize(atan3(dy, dx) - angle, PI2);
 
-	if ((turret[0]->alive) && ((alpha > PI2-PI/12) || (alpha < PI/12)))
-		turret[0]->armour -= total;
-	if ((turret[2]->alive) && (alpha > 2*PI2/3-PI/12) && (alpha < 2*PI2/3 + PI/12))
-		turret[2]->armour -= total;
-	if ((turret[1]->alive) && (alpha > PI2/3-PI/12) && (alpha < PI2/3+PI/12))
-		turret[1]->armour -= total;
-	if ((engines_armour > 0) && (alpha >= PI-PI2/9) && (alpha <= PI+PI2/9)) {
-		engines_armour -= total;
-        if (engines_armour <=0) {
-			play_sound(data->sampleExtra[0]);
-			engines_death_frame = 8;
-			engines_death_count = 500 +random()%100;
-			speed_max /= 2.0;
-			accel_rate /= 4.0;
-			turn_rate /= 3.0; } }
-
-
-	if ((source == this) && (dying)) {
-//      remove turrets when dead;
-		int i;
-		for (i=0; i<3; i++)
-			turret[i]->state = 0;
-		play_sound((SAMPLE *)(melee[MELEE_BOOMSHIP].dat));
-		game->add(new Animation(this, pos,
-				meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS, 2.0));
-		if (attributes & ATTRIB_NOTIFY_ON_DEATH) game->ship_died(this, source);
-		state = 0; return 0;
+  if ((turret[0]->alive) && ((alpha > PI2-PI/12) || (alpha < PI/12)))
+    turret[0]->armour -= total;
+  if ((turret[2]->alive) && (alpha > 2*PI2/3-PI/12) && (alpha < 2*PI2/3 + PI/12))
+    turret[2]->armour -= total;
+  if ((turret[1]->alive) && (alpha > PI2/3-PI/12) && (alpha < PI2/3+PI/12))
+    turret[1]->armour -= total;
+  if ((engines_armour > 0) && (alpha >= PI-PI2/9) && (alpha <= PI+PI2/9)) 
+    {
+      engines_armour -= total;
+      if (engines_armour <=0) 
+	{
+	  tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
+	  engines_death_frame = 8;
+	  engines_death_count = 500 +random()%100;
+	  speed_max /= 2.0;
+	  accel_rate /= 4.0;
+	  turn_rate /= 3.0; 
+	} 
+    }
+  
+  
+  if ((source == this) && (dying)) {
+    //      remove turrets when dead;
+    int i;
+    for (i=0; i<3; i++)
+      turret[i]->state = 0;
+    tw_sound->play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
+    game->add(new Animation(this, pos,
+			    game->meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS, 2.0));
+    if (attributes & ATTRIB_NOTIFY_ON_DEATH) game->ship_died(this, source);
+    state = 0; return 0;
+  }
+  
+  crew -= total;
+  
+  if(crew > crew_max) 
+    {
+      total += crew_max - crew;
+      crew = crew_max;
+    }
+  if((crew <= 0)&&(!dying)) 
+    {
+      total += crew;
+      crew  = 0;
+      dying = true;
+      turn_rate = scale_turning(12+tw_random()%80) * (1-2*(tw_random()%2)); 
+      if (engines_armour > 0) 
+	{
+	  engines_armour = 0;
+	  tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
+	  engines_death_frame = 8;
+	  engines_death_count = 500 +random()%100;
 	}
-
-	crew -= total;
-
-	if(crew > crew_max) {
-		total += crew_max - crew;
-		crew = crew_max;
-	}
-    if((crew <= 0)&&(!dying)) {
-		total += crew;
-		crew  = 0;
-		dying = true;
-//		state = 0;
-//		play_sound((SAMPLE *)(melee[MELEE_BOOMSHIP].dat));
-//		game->add(new Animation(this, x, y,
-//			game->kaboomSprite, 0, KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS));
-//		if (attributes & ATTRIB_NOTIFY_ON_DEATH) game->ship_died(this, source);
-		turn_rate = scale_turning(12+tw_random()%80) * (1-2*(tw_random()%2)); 
-		if (engines_armour > 0) {
-			engines_armour = 0;
-			play_sound(data->sampleExtra[0]);
-			engines_death_frame = 8;
-			engines_death_count = 500 +random()%100;
-		}
-	}
-
-	if (crew < 0) {
-		recharge_amount = 0;
-		crew = 0; }
-
-	return iround(total);
+    }
+  
+  if (crew < 0) 
+    {
+      recharge_amount = 0;
+      crew = 0; 
+    }
+  
+  return iround(total);
 }
 
 int AlaryBC::handle_fuel_sap(SpaceLocation *source, double normal)
 {
-	STACKTRACE
-	normal = (normal / extraFuelSapReduction);
-	return Ship::handle_fuel_sap(source, normal);
+  STACKTRACE;
+  normal = (normal / extraFuelSapReduction);
+  return Ship::handle_fuel_sap(source, normal);
 }
 
 double AlaryBC::handle_speed_loss(SpaceLocation *source, double normal)
 {
-	STACKTRACE
-	normal = normal / extraSpeedLossReduction;
-	return Ship::handle_speed_loss(source, normal);
+  STACKTRACE;
+  normal = normal / extraSpeedLossReduction;
+  return Ship::handle_speed_loss(source, normal);
 }
 
 
-AlaryBCTorpedo::AlaryBCTorpedo(SpaceLocation *creator, double ox, double oy, double oangle, int oinactive, double oaccel, double  omaxspeed,
-		int olifetime, double oproximity, double oarmour, double otr, SpaceObject *otarget,
-		SpaceSprite *osprite, double wdamage, double wrange, double warmour, double wv,
-		double wtr) :
-	SpaceObject(creator, 0, oangle, osprite),
-	armour(iround(oarmour)), lifetime(olifetime), inactive(oinactive),
-	proximity(oproximity), accel(oaccel),
-	maxspeed(omaxspeed), turn_rate(otr),
-	wh_damage(iround(wdamage)), wh_armour(iround(warmour)), wh_v(wv),
-	wh_turn_rate(wtr), wh_range(wrange)
+AlaryBCTorpedo::AlaryBCTorpedo(SpaceLocation *creator, double ox, double oy, double oangle, 
+			       int oinactive, double oaccel, double  omaxspeed,
+			       int olifetime, double oproximity, double oarmour, 
+			       double otr, SpaceObject *otarget,
+			       SpaceSprite *osprite, double wdamage, double wrange, 
+			       double warmour, double wv,
+			       double wtr) :
+  SpaceObject(creator, 0, oangle, osprite),
+  armour(iround(oarmour)), lifetime(olifetime), inactive(oinactive),
+  proximity(oproximity), accel(oaccel),
+  maxspeed(omaxspeed), turn_rate(otr),
+  wh_damage(iround(wdamage)), wh_armour(iround(warmour)), wh_v(wv),
+  wh_turn_rate(wtr), wh_range(wrange)
 {
-	target = otarget;
-	layer = LAYER_SHOTS;
-	set_depth(DEPTH_SHOTS);
-//	attributes |= ATTRIB_SHOT;
+  STACKTRACE;
+  target = otarget;
+  layer = LAYER_SHOTS;
+  set_depth(DEPTH_SHOTS);
 
-	pos = normalize(creator->normal_pos() + rotate(Vector2(-ox, oy), -PI/2+creator->get_angle()));
-	vel = creator->get_vel();
-
-	smoke_frame = 0;
-//        explosionSprite     = data->spriteWeaponExplosion;
-//        explosionFrameCount = 10;
-//        explosionFrameSize  = 50;
-//        explosionSample = data->sampleWeapon[1];
-
-	isblockingweapons = false;
+  pos = normalize(creator->normal_pos() + rotate(Vector2(-ox, oy), -PI/2+creator->get_angle()));
+  vel = creator->get_vel();
+  
+  smoke_frame = 0;
+  //        explosionSprite     = data->spriteWeaponExplosion;
+  //        explosionFrameCount = 10;
+  //        explosionFrameSize  = 50;
+  //        explosionSample = data->sampleWeapon[1];
+  
+  isblockingweapons = false;
 }
 
 void AlaryBCTorpedo::calculate()
 {
-	STACKTRACE
-	SpaceObject::calculate();
-	lifetime -= frame_time;
-	if (lifetime < 0) {
-
-		//launch warheads or die
-		state = 0;
-		return;
-
-	}
-
-
-	if (inactive > 0) inactive -= frame_time;
-
-	if (target) if ((!target->isInvisible()) && (inactive <=0)) {
-		double d_a = normalize(trajectory_angle(target) - angle, PI2);
-		if (d_a > PI) d_a -= PI2;
-		double ta = turn_rate * frame_time;
-		if (fabs(d_a) < ta) ta = fabs(d_a);
-		if (d_a > 0) angle += ta;
-		else angle -= ta;
-		angle = normalize(angle, PI2);
-
-		if (distance(target) < proximity) {
-			game->add(new Animation(this, pos, data->spriteWeaponExplosion, 0, 10, 50, DEPTH_EXPLOSIONS));
+  STACKTRACE;
+  SpaceObject::calculate();
+  lifetime -= frame_time;
+  if (lifetime < 0) 
+    {
+      //launch warheads or die
+      state = 0;
+      return;
+  }
+  
+  if (inactive > 0) inactive -= frame_time;
+  
+  if (target) if ((!target->isInvisible()) && (inactive <=0)) 
+    {
+      double d_a = normalize(trajectory_angle(target) - angle, PI2);
+      if (d_a > PI) d_a -= PI2;
+      double ta = turn_rate * frame_time;
+      if (fabs(d_a) < ta) ta = fabs(d_a);
+      if (d_a > 0) angle += ta;
+      else angle -= ta;
+      angle = normalize(angle, PI2);
+      
+      if (distance(target) < proximity) 
+	{
+	  game->add(new Animation(this, pos, data->spriteWeaponExplosion, 0, 10, 50, DEPTH_EXPLOSIONS));
+	  
+	  game->add(new AlaryBCWarhead(this, 0, 10, angle,
+				       wh_v, wh_damage, wh_range*(1+0.0025*(tw_random()%101)), 
+				       wh_armour, wh_turn_rate, data->spriteExtra, target));
+	  game->add(new AlaryBCWarhead(this, 0, 10, angle - 50*PI/180,
+				       wh_v, wh_damage, wh_range*(1+0.0025*(tw_random()%101)), 
+				       wh_armour, wh_turn_rate, data->spriteExtra, target));
+	  game->add(new AlaryBCWarhead(this, 0, 10, angle + 50*PI/180,
+				       wh_v, wh_damage, wh_range*(1+0.0025*(tw_random()%101)), 
+				       wh_armour, wh_turn_rate, data->spriteExtra, target));
+	  game->add(new AlaryBCWarhead(this, 0, 10, angle - 75*PI/180,
+				       wh_v, wh_damage, wh_range*(1+0.0025*(tw_random()%101)), 
+				       wh_armour, wh_turn_rate, data->spriteExtra, target));
+	  game->add(new AlaryBCWarhead(this, 0, 10, angle + 75*PI/180,
+				       wh_v, wh_damage, wh_range*(1+0.0025*(tw_random()%101)), 
+				       wh_armour, wh_turn_rate, data->spriteExtra, target));
 			
-			game->add(new AlaryBCWarhead(this, 0, 10, angle,
-				wh_v, wh_damage, wh_range*(1+0.0025*(tw_random()%101)), wh_armour, wh_turn_rate, data->spriteExtra, target));
-			game->add(new AlaryBCWarhead(this, 0, 10, angle - 50*PI/180,
-				wh_v, wh_damage, wh_range*(1+0.0025*(tw_random()%101)), wh_armour, wh_turn_rate, data->spriteExtra, target));
-			game->add(new AlaryBCWarhead(this, 0, 10, angle + 50*PI/180,
-				wh_v, wh_damage, wh_range*(1+0.0025*(tw_random()%101)), wh_armour, wh_turn_rate, data->spriteExtra, target));
-			game->add(new AlaryBCWarhead(this, 0, 10, angle - 75*PI/180,
-				wh_v, wh_damage, wh_range*(1+0.0025*(tw_random()%101)), wh_armour, wh_turn_rate, data->spriteExtra, target));
-			game->add(new AlaryBCWarhead(this, 0, 10, angle + 75*PI/180,
-				wh_v, wh_damage, wh_range*(1+0.0025*(tw_random()%101)), wh_armour, wh_turn_rate, data->spriteExtra, target));
-			
-			state = 0;
-		}
+	  state = 0;
 	}
-	else {
-		if (inactive <= 0) target = NULL;
+    }
+  else 
+    {
+      if (inactive <= 0) target = NULL;
+      
+      //find another target???????
+      
+    }
+  
+  sprite_index = iround(angle / (PI2/64)) + 16;
+  sprite_index &= 63;
 
-		//find another target???????
-
-	}
-	
-	sprite_index = iround(angle / (PI2/64)) + 16;
-	sprite_index &= 63;
-
-	accelerate(this, angle, accel*frame_time, maxspeed);
-
-	while (smoke_frame <= 0) {
-		smoke_frame += 50;
-		game->add(new Animation(this, pos - 14*unit_vector(angle), data->more_sprites[7],
-			0, 12, 50, LAYER_HOTSPOTS));
-	}
-	smoke_frame -= frame_time;
-
-
-	return;
-
+  accelerate(this, angle, accel*frame_time, maxspeed);
+  
+  while (smoke_frame <= 0) 
+    {
+      smoke_frame += 50;
+      game->add(new Animation(this, pos - 14*unit_vector(angle), data->more_sprites[7],
+			      0, 12, 50, LAYER_HOTSPOTS));
+    }
+  smoke_frame -= frame_time;
+  
+  return;
 }
 
 void AlaryBCTorpedo::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
-	//if (!other->isShot()) {
-	if (other->isblockingweapons)
-	{
-		game->add(new Animation(this, pos, data->spriteWeaponExplosion, 0, 10, 50, DEPTH_EXPLOSIONS));
-		state = 0; 
-		play_sound((SAMPLE *)(melee[MELEE_BOOM].dat));
-	}
+  STACKTRACE;
+  if (other->isblockingweapons)
+    {
+      game->add(new Animation(this, pos, data->spriteWeaponExplosion, 0, 10, 50, DEPTH_EXPLOSIONS));
+      state = 0; 
+      tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND1));
+    }
 };
 
 int AlaryBCTorpedo::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE
-	if (direct+normal > 0) armour -= iround(direct+normal);
-	if (armour <= 0) {
-		game->add(new Animation(this, pos, data->spriteWeaponExplosion, 0, 10, 50, DEPTH_EXPLOSIONS));
-		state = 0; }
-	return iround(direct+normal);
+  STACKTRACE;
+  if (direct+normal > 0) 
+    armour -= iround(direct+normal);
+  if (armour <= 0) 
+    {
+      game->add(new Animation(this, pos, data->spriteWeaponExplosion, 0, 10, 50, DEPTH_EXPLOSIONS));
+      state = 0; 
+    }
+  return iround(direct+normal);
 }
 
 
-AlaryBCWarhead::AlaryBCWarhead(SpaceLocation *creator, double ox, double oy, double oangle, double ov, double odamage,
-		double orange, double oarmour, double otrate, SpaceSprite *osprite, SpaceObject *otarget) :
-	HomingMissile(creator, Vector2(ox,oy), oangle, ov, odamage, orange, oarmour, 
-	otrate, creator, osprite, otarget)
+AlaryBCWarhead::AlaryBCWarhead(SpaceLocation *creator, double ox, double oy, double oangle, 
+			       double ov, double odamage,
+			       double orange, double oarmour, double otrate, 
+			       SpaceSprite *osprite, SpaceObject *otarget) :
+  HomingMissile(creator, Vector2(ox,oy), oangle, ov, odamage, orange, oarmour, 
+		otrate, creator, osprite, otarget)
 {
-	explosionSprite     = data->spriteExtraExplosion;
-	explosionFrameCount = 10;
-	explosionFrameSize  = 50;
-	explosionSample = data->sampleWeapon[2];
-	smoke_frame = 0;
-	play_sound(data->sampleWeapon[1], 64);
+  STACKTRACE;
+  explosionSprite     = data->spriteExtraExplosion;
+  explosionFrameCount = 10;
+  explosionFrameSize  = 50;
+  explosionSample = data->sampleWeapon[2];
+  smoke_frame = 0;
+  tw_sound->play_sound(data_full_path(data->sampleWeapon[1])); // was vol 64
 }
 
 
 void AlaryBCWarhead::calculate()
 {
-	STACKTRACE
-	HomingMissile::calculate();
-	
-	while (smoke_frame <= 0) {
-		smoke_frame += 25;
-		game->add(new Animation(this, pos -2*unit_vector(angle), data->more_sprites[8],
-			0, 12, 50, LAYER_HOTSPOTS));
-	}
-	smoke_frame -= frame_time;
+  STACKTRACE;
+  HomingMissile::calculate();
+  
+  while (smoke_frame <= 0) 
+    {
+      smoke_frame += 25;
+      game->add(new Animation(this, pos -2*unit_vector(angle), data->more_sprites[8],
+			      0, 12, 50, LAYER_HOTSPOTS));
+    }
+  smoke_frame -= frame_time;
 }
 
 
 
 void AlaryBCTurret::sinc_it()
 {
-	STACKTRACE
-//	double tx = cos(ship->angle);
-//	double ty = sin(ship->angle);
-
-//	x = ship->x + rel_y*tx - rel_x*ty;
-//	y = ship->y + rel_y*ty + rel_x*tx;
-	pos = normalize(ship->normal_pos() + rotate(Vector2(-rel_x, rel_y), -PI/2+ship->get_angle()));
-
-//	vx = ship->vx;
-//	vy = ship->vy;
-	vel = ship->get_vel();
+  STACKTRACE;
+  pos = normalize(ship->normal_pos() + rotate(Vector2(-rel_x, rel_y), -PI/2+ship->get_angle()));
+  vel = ship->get_vel();
 }
 
 AlaryBCTurret::AlaryBCTurret (AlaryBC *oship, double blah_or, double oa, double oangle,
 				double omin_angle, double omax_angle, int team) :
-	SpaceLocation(oship,0,oangle)
-//	barrel(0), ship(oship), recharce(0)
-						
+  SpaceLocation(oship,0,oangle)
 {
-	target = NULL;
-	shots_fired = 0;
-	barrel = 0;
-	ship = oship;
-	rel_x = blah_or*sin(oa);
-	rel_y = blah_or*cos(oa);
-	recharge = 0;
-	min_angle = omin_angle; max_angle = omax_angle;
-	std_angle = oangle;
-	
-	collide_flag_anyone = 0;
-	collide_flag_sameteam = 0;
-	collide_flag_sameship = 0;
+  target = NULL;
+  shots_fired = 0;
+  barrel = 0;
+  ship = oship;
+  rel_x = blah_or*sin(oa);
+  rel_y = blah_or*cos(oa);
+  recharge = 0;
+  min_angle = omin_angle; max_angle = omax_angle;
+  std_angle = oangle;
+  
+  collide_flag_anyone = 0;
+  collide_flag_sameteam = 0;
+  collide_flag_sameship = 0;
+  
+  armour = ship->turretArmour;
+  
+  collide_flag_anyone = 0;
+  collide_flag_sameship = 0;
+  collide_flag_sameteam = 0;
+  sinc_it();
 
-	armour = ship->turretArmour;
-
-	collide_flag_anyone = 0;
-	collide_flag_sameship = 0;
-	collide_flag_sameteam = 0;
-	sinc_it();
-
-	fire_frame[0] = fire_frame[1] = 10;
-
-	alive = true;
+  fire_frame[0] = fire_frame[1] = 10;
+  fire_time[0] = fire_time[1] = 0;
+  alive = true;
 }
 
 double AlaryBCTurret::get_aim(SpaceObject *tgt)
 {
-	STACKTRACE
+  STACKTRACE;
+  if (tgt == NULL)
+    return (-1);
+  
+  Vector2 tv = tgt->get_vel() - ship->specialRelativity * ship->get_vel();
+  
+  double tvx = tv.x;
+  double tvy = tv.y;
 
-	if (tgt == NULL)
-		return (-1);
-		
-	Vector2 tv = tgt->get_vel() - ship->specialRelativity * ship->get_vel();
-
-	double tvx = tv.x;//tgt->get_vx() - ship->specialRelativity * ship->vx;
-	double tvy = tv.y;//tgt->get_vy() - ship->specialRelativity * ship->vy;
-//        double tv2 = tvx*tvx + tvy*tvy;
-	tv = min_delta(tgt->normal_pos(), pos);
-	double rx  = tv.x;//min_delta(tgt->normal_x(), normal_x(), X_MAX);
-	double ry  = tv.y;//min_delta(tgt->normal_y(), normal_y(), Y_MAX);
-	double r2  = rx*rx + ry*ry;
-	double u2  = ship->specialVelocity;
-	u2 *= u2;
-	double d2v = u2 - (tvx*tvx + tvy*tvy);
-	double t = (rx*tvx + ry*tvy);
-	double q, p;
-	if (fabs(d2v/u2) > 0.01 ) {
-		q = t*t + r2*d2v;
-		if (q > 0) q = sqrt(q);
-		else    return (-1);
-		p = (t+q)/d2v;
-		q = (t-q)/d2v;
-		if (p > 0) t = p;
-		else       t = q;
-		if (t < 0) return (-1);
-	}
-	else {
-		if (fabs(t)<1e-6) return (-1);
-		else    t = - 0.5 * r2 / t;
-		if (t < 0) return (-1); }
-	if (t * ship->specialVelocity > ship->specialRange) return(-1);
-	t = normalize((atan3(tvy*t + ry, tvx*t + rx)) - ship->angle, PI2);
-	double d_a = normalize(t - min_angle, PI2);
-	if (d_a > PI) d_a -= PI2;
-	if (d_a > 0) {
-		d_a = normalize(t - max_angle, PI2);
-		if (d_a > PI) d_a -= PI2;
-		if (d_a < 0)
-			return (t); }
-	return (-1);
+  tv = min_delta(tgt->normal_pos(), pos);
+  double rx  = tv.x;
+  double ry  = tv.y;
+  double r2  = rx*rx + ry*ry;
+  double u2  = ship->specialVelocity;
+  u2 *= u2;
+  double d2v = u2 - (tvx*tvx + tvy*tvy);
+  double t = (rx*tvx + ry*tvy);
+  double q, p;
+  if (fabs(d2v/u2) > 0.01 ) 
+    {
+      q = t*t + r2*d2v;
+      if (q > 0) q = sqrt(q);
+      else    return (-1);
+      p = (t+q)/d2v;
+      q = (t-q)/d2v;
+      if (p > 0) t = p;
+      else       t = q;
+      if (t < 0) return (-1);
+    }
+  else 
+    {
+      if (fabs(t)<1e-6) return (-1);
+      else    t = - 0.5 * r2 / t;
+      if (t < 0) 
+	return (-1); 
+    }
+  if (t * ship->specialVelocity > ship->specialRange) 
+    return(-1);
+  t = normalize((atan3(tvy*t + ry, tvx*t + rx)) - ship->angle, PI2);
+  double d_a = normalize(t - min_angle, PI2);
+  if (d_a > PI) d_a -= PI2;
+  if (d_a > 0) 
+    {
+      d_a = normalize(t - max_angle, PI2);
+      if (d_a > PI) d_a -= PI2;
+      if (d_a < 0)
+	return (t); 
+    }
+  return (-1);
 }
 
 SpaceObject *AlaryBCTurret::get_target(SpaceObject *tgt)
 {
-	STACKTRACE
-	double d_a, prix=-1, prix_c, aim; //!!!
-	Query q;
-	SpaceObject *tgt0=tgt;
-
-	for (q.begin(this, OBJECT_LAYERS, ship->specialRange); q.currento; q.next())
-		if ((!q.currento->isInvisible()) && (!q.currento->sameTeam(this))
-				&& (!q.currento->isPlanet())
-				&& (q.currento->collide_flag_anyone&bit(LAYER_SHOTS))
-				&& (q.currento != tgt) ) {
-			aim = get_aim(q.currento);
-			if (aim >= 0) {
-				d_a = normalize(aim - angle, PI2);
-				if (d_a > PI) d_a -= PI2;
-				d_a = fabs(d_a);
-			
-				if (q.currento->isShip()) {
-					if (q.currento == ship->target) prix_c = 4;
-					else
-						prix_c = 3; }
-				else
-					if (q.currento->damage_factor <= 0)
-						prix_c = 2;
-					else
-						if (q.currento->damage_factor >= ship->specialDamThr)
-							prix_c = 1;
-						else
-							prix_c = 0;
-				prix_c -= d_a/PI;
-				if (prix_c > prix) {
-					prix = prix_c;
-					tgt = q.currento; }
-			}
-		}
-	q.end();
-
-
-	if (tgt != tgt0)
-		return tgt;
-	else
-		return NULL;
-
+  STACKTRACE;
+  double d_a, prix=-1, prix_c, aim; //!!!
+  Query q;
+  SpaceObject *tgt0=tgt;
+  
+  for (q.begin(this, OBJECT_LAYERS, ship->specialRange); q.currento; q.next())
+    if ((!q.currento->isInvisible()) && (!q.currento->sameTeam(this))
+	&& (!q.currento->isPlanet())
+	&& (q.currento->collide_flag_anyone&bit(LAYER_SHOTS))
+	&& (q.currento != tgt) ) 
+      {
+	aim = get_aim(q.currento);
+	if (aim >= 0) 
+	  {
+	    d_a = normalize(aim - angle, PI2);
+	    if (d_a > PI) d_a -= PI2;
+	    d_a = fabs(d_a);
+	    
+	    if (q.currento->isShip()) 
+	      {
+		if (q.currento == ship->target) prix_c = 4;
+	      else
+		prix_c = 3; 
+	      }
+	    else
+	      if (q.currento->damage_factor <= 0)
+		prix_c = 2;
+	      else
+		if (q.currento->damage_factor >= ship->specialDamThr)
+		  prix_c = 1;
+		else
+		  prix_c = 0;
+	    prix_c -= d_a/PI;
+	    if (prix_c > prix) 
+	      {
+		prix = prix_c;
+		tgt = q.currento; 
+	      }
+	  }
+      }
+  q.end();
+  
+  if (tgt != tgt0)
+    return tgt;
+  else
+    return NULL;  
 }
 
 
 
 void AlaryBCTurret::calculate()
 {
-	STACKTRACE
-	if (!(ship && ship->exists()))
+  STACKTRACE;
+  if (!(ship && ship->exists()))
+    {
+      ship = 0;
+      state = 0;
+      return;
+    }
+  
+  SpaceLocation::calculate();
+  
+  if (!alive) return;
+  
+  if (armour <= 0) 
+    {
+      alive = false;
+      tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND2));
+      game->add(new FixedAnimation(this, this, ship->data->spriteSpecialExplosion,
+				   0, 10, 50, DEPTH_EXPLOSIONS));
+      return; 
+    }
+  
+  int i;
+  for (i=0; i<2; i++) 
+    {
+      if ((fire_time[i] > 0) && (fire_frame[i] < 4)) 
+	fire_time[i] -= frame_time;
+      else 
 	{
-		ship = 0;
-		state = 0;
-		return;
+	  fire_time[i] += turret_fire_frame_size;
+	  fire_frame[i]++; 
+	} 
+    }
+  
+  
+  double d_a, aim; //!!!
+
+  if (ship->turrets_on) 
+    {
+      if (target) 
+	{
+	  if (!target->exists()) 
+	    {
+	      shots_fired = 0;
+	      target = get_target(NULL); 
+	    }
 	}
+      else 
+	{
+	  shots_fired = 0;
+	  target = get_target(NULL); }
+      
+      aim = get_aim(target);
 
-	SpaceLocation::calculate();
-
-	if (!alive) return;
-
-	if (armour <= 0) {
-		alive = false;
-		play_sound((SAMPLE *)(melee[MELEE_BOOM + 1].dat));
-//		play_sound(ship->data->sampleSpecial[1]);
-//                        game->add(new Animation(this, turret[i]->normal_x(), turret[i]->normal_y(),
-//                                          ship->data->spriteWeaponExplosion, 0, 10, 50, DEPTH_EXPLOSIONS));
-		game->add(new FixedAnimation(this, this, ship->data->spriteSpecialExplosion,
-			0, 10, 50, DEPTH_EXPLOSIONS));
-		return; }
-
-	int i;
-	for (i=0; i<2; i++) {
-		if ((fire_time[i] > 0) && (fire_frame[i] < 4)) fire_time[i] -= frame_time;
-		else {
-			fire_time[i] += turret_fire_frame_size;
-			fire_frame[i]++; } }
-
-                
-	double d_a, aim; //!!!
-
-	if (ship->turrets_on) {
-		if (target) {
-			if (!target->exists()) {
-				shots_fired = 0;
-				target = get_target(NULL); }
-/*			else {
-				if (target->isShot()) {
-					if (shots_fired >= ((Shot*)target)->armour * ship->specialMaxShots / ship->specialDamage) {
-						shots_fired = 0;
-						target = get_target(NULL); } }
-				else {
-					if (target->isAsteroid()) 
-						if (shots_fired >= ship->specialMaxShots) {
-							shots_fired = 0;
-							target = get_target(NULL); }
-				}
-			}
-*/		
-		}
-		else {
-			shots_fired = 0;
-			target = get_target(NULL); }
-
-		aim = get_aim(target);
-
-		if (aim < 0) {
-			shots_fired = 0;
-			target = get_target(NULL); }
+      if (aim < 0) 
+	{
+	  shots_fired = 0;
+	  target = get_target(NULL); 
 	}
-
-	else {
-		target = NULL;
-		shots_fired = 0;
-		aim = -1; }
-        
-
-	if (aim >= 0)
-		d_a = normalize(aim - angle, PI2);
-	else
-		d_a = normalize(std_angle - angle, PI2);
-	if (d_a > PI)
-		d_a -= PI2;
-	
-	double delta = ship->specialTurnRate * frame_time;
-
-	if (fabs(d_a) <= delta)
-		delta = fabs(d_a);
-	if (d_a > 0)
-		angle += delta;
-	else
-		angle -= delta;
-
-	if (recharge > 0) recharge -= frame_time;
-	if (target && (recharge <= 0)) {
-		if (fabs(d_a) <= (0.25 * (target->size.x+target->size.y)/2.0) / distance(target)) {
-			if (ship->batt >= ship->special_drain) {
-				recharge += ship->special_rate;
-				ship->batt -= ship->special_drain;
-				play_sound(ship->data->sampleSpecial[0]);
-				shots_fired++;
-				if (barrel == 0) {
-					game->add(new AlaryBCTShot(-3, 14, normalize(angle+ship->angle, PI2), ship->specialVelocity,
-						ship->specialDamage, ship->specialRange,
-						ship->specialArmour, ship, this, ship->data->spriteSpecial, ship->specialRelativity));
-					fire_frame[0] = 0; fire_time[0] =  turret_fire_frame_size;
-					barrel = 1; }
-				else {
-					game->add(new AlaryBCTShot(3, 14, normalize(angle+ship->angle, PI2), ship->specialVelocity,
-						ship->specialDamage, ship->specialRange,
-						ship->specialArmour, ship, this, ship->data->spriteSpecial, ship->specialRelativity));
-					fire_frame[1] = 0; fire_time[1] =  turret_fire_frame_size;
-					barrel = 0; }
-			}
+    }
+  else 
+    {
+    target = NULL;
+    shots_fired = 0;
+    aim = -1; 
+  }
+  
+  
+  if (aim >= 0)
+    d_a = normalize(aim - angle, PI2);
+  else
+    d_a = normalize(std_angle - angle, PI2);
+  if (d_a > PI)
+    d_a -= PI2;
+  
+  double delta = ship->specialTurnRate * frame_time;
+  
+  if (fabs(d_a) <= delta)
+    delta = fabs(d_a);
+  if (d_a > 0)
+    angle += delta;
+  else
+    angle -= delta;
+  
+  if (recharge > 0) recharge -= frame_time;
+  if (target && (recharge <= 0)) 
+    {
+      if (fabs(d_a) <= (0.25 * (target->size.x+target->size.y)/2.0) / distance(target)) 
+	{
+	  if (ship->batt >= ship->special_drain) 
+	    {
+	      recharge += ship->special_rate;
+	      ship->batt -= ship->special_drain;
+	      tw_sound->play_sound(data_full_path(ship->data->sampleSpecial[0]));
+	      shots_fired++;
+	      if (barrel == 0) 
+		{
+		  game->add(new AlaryBCTShot(-3, 14, normalize(angle+ship->angle, PI2), 
+					     ship->specialVelocity,
+					     ship->specialDamage, ship->specialRange,
+					     ship->specialArmour, ship, this, 
+					     ship->data->spriteSpecial, ship->specialRelativity));
+		  fire_frame[0] = 0; 
+		  fire_time[0] =  turret_fire_frame_size;
+		  barrel = 1; 
 		}
+	      else 
+		{
+		  game->add(new AlaryBCTShot(3, 14, normalize(angle+ship->angle, PI2), 
+					     ship->specialVelocity,
+					     ship->specialDamage, ship->specialRange,
+					     ship->specialArmour, ship, this, 
+					     ship->data->spriteSpecial, ship->specialRelativity));
+		  fire_frame[1] = 0; 
+		  fire_time[1] =  turret_fire_frame_size;
+		  barrel = 0; 
+		}
+	    }
 	}
-
+    }
+  
 }
 
-AlaryBCTShot::AlaryBCTShot(double ox, double oy, double oangle, double ov, double odamage, double orange, double oarmour,
-               SpaceLocation *creator, SpaceLocation *opos, SpaceSprite *osprite, double relativity) :
-	Missile(creator, Vector2(ox,oy), oangle, ov, odamage, orange, oarmour, 
-	creator, osprite, relativity)
-
+AlaryBCTShot::AlaryBCTShot(double ox, double oy, double oangle, 
+			   double ov, double odamage, double orange, double oarmour,
+			   SpaceLocation *creator, SpaceLocation *opos, 
+			   SpaceSprite *osprite, double relativity) :
+  Missile(creator, Vector2(ox,oy), oangle, ov, odamage, orange, oarmour, 
+	  creator, osprite, relativity)
 {
-	set_depth(DEPTH_SHIPS+0.25);
-	collide_flag_sameship = 0;
-	collide_flag_sameteam = 0;
-
-	explosionSprite     = data->spriteSpecialExplosion;
-	explosionFrameCount = 10;
-	explosionFrameSize  = 50;
-	explosionSample = data->sampleSpecial[1];
-//	double tx = cos(angle);
-//	double ty = sin(angle);
-//	x = opos->normal_x() + oy*tx - ox*ty;
-//	y = opos->normal_y() + oy*ty + ox*tx;
-	pos = normalize(opos->normal_pos() + rotate(Vector2(-ox, oy), -PI/2+angle));
+  STACKTRACE;
+  set_depth(DEPTH_SHIPS+0.25);
+  collide_flag_sameship = 0;
+  collide_flag_sameteam = 0;
+  
+  explosionSprite     = data->spriteSpecialExplosion;
+  explosionFrameCount = 10;
+  explosionFrameSize  = 50;
+  explosionSample = data->sampleSpecial[1];
+  pos = normalize(opos->normal_pos() + rotate(Vector2(-ox, oy), -PI/2+angle));
 }
 
 

Modified: branches/multiplayer-branch/source/ships/shpbahbu.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpbahbu.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shpbahbu.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -19,7 +19,6 @@
 
 #include "frame.h"
 
-REGISTER_FILE
 
 class BahaoidBabyBuzzsaw;
 
@@ -79,6 +78,7 @@
 BahaoidBuzzsaw::BahaoidBuzzsaw(Vector2 opos, double shipAngle, ShipData *shipData, int shipCollideFlag) :
 	Ship(opos, shipAngle, shipData, shipCollideFlag)
 {
+  STACKTRACE;
 
 	weaponRange		= scale_range(get_config_float("Weapon", "Range", 0));
 	weaponSpeed		= get_config_float("Weapon", "Speed", 1) * ANGLE_RATIO;
@@ -95,6 +95,7 @@
 
 void BahaoidBuzzsaw::calculate_turn_left()
 {
+  STACKTRACE;
 	if(can_turn)
 	{
 		Ship::calculate_turn_left();
@@ -103,6 +104,7 @@
 
 void BahaoidBuzzsaw::calculate_turn_right()
 {
+  STACKTRACE;
 	if(can_turn)
 	{
 		Ship::calculate_turn_right();
@@ -111,6 +113,7 @@
 
 int BahaoidBuzzsaw::activate_weapon()
 {
+  STACKTRACE;
 	double xone = 0.8660254038;
 	double yone = 0.5;
 
@@ -145,6 +148,7 @@
 
 int BahaoidBuzzsaw::activate_special()
 {
+  STACKTRACE;
 	if(nummines>=specialNumber) return(FALSE);
 
 	game->add(new BahaoidBabyBuzzsaw(0, 0, angle, 0, specialArmour, this,
@@ -156,6 +160,7 @@
 
 void BahaoidBuzzsaw::calculate()
 {
+  STACKTRACE;
 
 	if(fire_weapon)
 	{
@@ -177,6 +182,7 @@
     AnimatedShot(oship, opos, oangle, ov, odamage, -1.0, oarmour, oship,
       osprite, ofcount, ofsize)
 {
+  STACKTRACE;
 	weaponRange		= rangey;
 	weaponSpeed		= speedy;
 	weaponDamage	= damagey;
@@ -192,6 +198,7 @@
 
 int BahaoidBabyBuzzsaw::handle_damage(SpaceLocation* source, double normal, double direct)
 {
+  STACKTRACE;
 	armour -= normal + direct;
 	
 	if(armour <= 0)
@@ -204,6 +211,7 @@
 
 void BahaoidBabyBuzzsaw::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
 	if((ship) && (other == ship))
 	{
 		state = 0;
@@ -217,6 +225,7 @@
 
 void BahaoidBabyBuzzsaw::calculate()
 {
+  STACKTRACE;
 	SpaceObject *o, *t = NULL;
 	double oldrange = 999999;
 

Modified: branches/multiplayer-branch/source/ships/shpbipka.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpbipka.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shpbipka.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 #include "melee/mview.h"
 #include "other/nullphas.h"
 
@@ -107,6 +106,7 @@
 };
 
 SpaceLocation* BipoleKatamaran::get_ship_phaser() {
+  STACKTRACE;
   return new NullPhaser( this );
 }
 
@@ -114,6 +114,7 @@
   ShipData *shipData, unsigned int code) :
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   collide_flag_anyone = 0;
   collide_flag_sameteam = 0;
   collide_flag_sameship = 0;
@@ -158,7 +159,7 @@
 }
 
 int BipoleKatamaran::activate_weapon(){
-	STACKTRACE
+  STACKTRACE;
   if( !left || !right ) return FALSE;
   weapon_sample = random(11);
   int left_w = left->activate_weapon();
@@ -167,7 +168,7 @@
 }
 
 int BipoleKatamaran::activate_special(){
-	STACKTRACE
+  STACKTRACE;
   if( !left || !right ) return FALSE;
   if( range >= specialMaxRange ){
     range = specialMaxRange;
@@ -178,12 +179,13 @@
 }
 
 void BipoleKatamaran::animate(Frame* space){
+  STACKTRACE;
   /* we do not show */
   return;
 }
 
 void BipoleKatamaran::calculate(){
-	STACKTRACE
+  STACKTRACE;
   if( left ) if( !left->exists() ){
     left = NULL;
     if( right ){
@@ -321,7 +323,7 @@
 }
 
 void BipoleKatamaran::calculate_thrust(){
-	STACKTRACE
+  STACKTRACE;
   if( !left || !right ) return;
   if( left->thrust && !left->turn_left && !left->turn_right ){
     left->accelerate(this, angle, accel_rate * frame_time, speed_max);
@@ -331,7 +333,7 @@
   }
 }
 void BipoleKatamaran::calculate_turn_left(){
-	STACKTRACE
+  STACKTRACE;
   if( !left || !right ) return;
   if( left->turn_left ){
     left->nextkeys &= ~keyflag::thrust;
@@ -343,7 +345,7 @@
   }
 }
 void BipoleKatamaran::calculate_turn_right(){
-	STACKTRACE
+  STACKTRACE;
   if( !left || !right ) return;
   if( left->turn_right ){
     left->nextkeys |= keyflag::thrust;
@@ -356,11 +358,12 @@
 }
 
 void BipoleKatamaran::calculate_hotspots(){
+  STACKTRACE;
   return;
 }
 
 void BipoleKatamaran::materialize(){
-	STACKTRACE;
+  STACKTRACE;
 	
 //  int i;
 //  for( i = 0; game->target[i] != this; i++ );
@@ -374,7 +377,7 @@
 }
 
 void BipoleKatamaran::death(){
-	STACKTRACE
+  STACKTRACE;
 	// bug fix Geo.
 	// added exists(), because I *think* that the "invisible" ships can be destroyed
 	// by some field weapon ? At the same time, this field weapon can destroy the
@@ -388,6 +391,7 @@
   ShipData *shipData, unsigned int code, Ship* oparent, SpaceSprite* osprite) :
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   parent = oparent;
   sprite = osprite;
 
@@ -403,7 +407,7 @@
 }
 
 int BipoleShip::activate_weapon(){
-	STACKTRACE
+  STACKTRACE;
   shooting = !shooting;
   if( !shooting ) return FALSE;  // if we would return TRUE single ship would fire slower
 
@@ -415,7 +419,7 @@
 }
 
 int BipoleShip::activate_special(){
-	STACKTRACE
+  STACKTRACE;
 
 	if ( vel != 0 )
 	{
@@ -430,27 +434,28 @@
 }
 
 void BipoleShip::calculate_fire_weapon(){
-	STACKTRACE
+  STACKTRACE;
   if( !sibling ) Ship::calculate_fire_weapon();
 }
 void BipoleShip::calculate_fire_special(){
-	STACKTRACE
+  STACKTRACE;
   if( !sibling ) Ship::calculate_fire_special();
 }
 void BipoleShip::calculate_thrust(){
-	STACKTRACE
+  STACKTRACE;
   if( !sibling ) Ship::calculate_thrust();
 }
 void BipoleShip::calculate_turn_left(){
-	STACKTRACE
+  STACKTRACE;
   if( !sibling ) Ship::calculate_turn_left();
 }
 void BipoleShip::calculate_turn_right(){
-	STACKTRACE
+  STACKTRACE;
   if( !sibling ) Ship::calculate_turn_right();
 }
 
 /*void BipoleShip::calculate_hotspots() {
+  STACKTRACE;
   if( thrust &&( hotspot_frame <= 0 )){
     game->addItem(new Animation( this, 
       normal_x() - (cos(angle ) * w / 2.5),
@@ -462,31 +467,29 @@
 }*/
 
 int BipoleShip::handle_damage(SpaceLocation *source, double normal, double direct) {
-	STACKTRACE
+  STACKTRACE;
 	int s = exists();
 	int i = Ship::handle_damage(source, normal, direct);
 	if (s && !exists()) destroyed( source );
 	return i;
 	}
 
-void BipoleShip::destroyed( SpaceLocation* source ){
-	STACKTRACE
-	play_sound((SAMPLE *)(melee[MELEE_BOOMSHIP].dat));
-	game->add(new Animation(this, pos,
-    meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, LAYER_EXPLOSIONS));
-
-// we do not report ship_died events -- the parent does
-//  game->ship_died(this, source);
+void BipoleShip::destroyed( SpaceLocation* source )
+{
+  STACKTRACE;
+  tw_sound->play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
+  game->add(new Animation(this, pos,
+			  game->meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, LAYER_EXPLOSIONS));
 }
 
 
 ShipType *BipoleShip::get_shiptype()
 {
-	STACKTRACE
-	// this is necessary, otherwise the Kat Poly ship crashes.
-	// also, "type" cannot be redirected inside the constructor, cause the
-	// parents' type is declared outside of its constructor (bad?).
-	return parent->type;
+  STACKTRACE;
+  // this is necessary, otherwise the Kat Poly ship crashes.
+  // also, "type" cannot be redirected inside the constructor, cause the
+  // parents' type is declared outside of its constructor (bad?).
+  return parent->type;
 };
 
 

Modified: branches/multiplayer-branch/source/ships/shpbogce.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpbogce.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shpbogce.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -15,8 +15,8 @@
 GNU General Public License for more details.
 */
 
+#include "util/sound.h"
 #include "ship.h"
-REGISTER_FILE
 
 #define BOGEI_CENTURION_ID SPACE_SHIP+0x00FE
 #define max_links 20
@@ -25,7 +25,7 @@
 {
   double        weaponRange, weaponSpread;
   int           weaponDamage;
-
+  
   int           specialDamage, specialArmour;
   int           specialLifetime, specialFuel;
   double        specialAccel, specialMaxspeed, specialBlastMaxspeed;
@@ -33,23 +33,23 @@
   double        specialHotspotThrust, specialHotspotSlowdown;
   int           special_slot;
   double        specialBlastAccel;
-
+  
   int           gun_phase, old_gun_phase;
   double        gun_position, gun_speed;
   int           startup_time, startup_delay, slowdown_time, delay_count;
   bool          slowing_down, gun_full_speed;
   int           flame_frame, flame_count, flame_duration;
-
+  
   int           exhaust_frame, exhaust_rate, exhaust_framesize, exhaust_count;
   int           exhaust_fry_chance;
   double        exhaust_slowdown, exhaust_thrust;
   bool          draw_hotspots, exhaust_on;
-
+  
   double        share_range;
   int           links_num;
-
+  
   double        residual_damage;
-
+  
   BoggCenturion        *link[max_links+1];
 
   public:
@@ -62,7 +62,6 @@
   virtual void  animate(Frame *space);
   virtual void  calculate_hotspots();
   virtual int handle_damage(SpaceLocation *source, double normal, double direct);
-  //virtual void  handle_damage(SpaceLocation *source);
 };
 
 
@@ -76,10 +75,13 @@
 
   public:
 
-  BoggCenturionMissile (SpaceLocation *creator, Vector2 opos, double oangle, int odamage, int oarmour,
-                int olifetime, int ofuel, double oaccel, double omaxspeed, double oblast_accel, double oblast_maxspeed,
-                int ohotspot_rate, int ohotspot_frame_size, double ohotspot_thrust, double ohotspot_slowdown,
-                SpaceSprite *osprite, SpaceSprite *hsprite, SAMPLE *s, SpaceSprite *esprite);
+  BoggCenturionMissile (SpaceLocation *creator, Vector2 opos, 
+			double oangle, int odamage, int oarmour,
+			int olifetime, int ofuel, double oaccel, 
+			double omaxspeed, double oblast_accel, double oblast_maxspeed,
+			int ohotspot_rate, int ohotspot_frame_size, 
+			double ohotspot_thrust, double ohotspot_slowdown,
+			SpaceSprite *osprite, SpaceSprite *hsprite, std::string s, SpaceSprite *esprite);
   virtual void  calculate();
   virtual void  inflict_damage(SpaceObject *other);
 };
@@ -89,9 +91,10 @@
 {
   double slowdown;
   public:
-  BoggCenturionExhaust (SpaceLocation *creator, double oangle, double dx, double dy, SpaceSprite *osprite,
-                int first_frame, int num_frames, int frame_size, double depth,
-                double v, double oslowdown, int ochance, SAMPLE *os);
+  BoggCenturionExhaust (SpaceLocation *creator, 
+			double oangle, double dx, double dy, SpaceSprite *osprite,
+			int first_frame, int num_frames, int frame_size, double depth,
+			double v, double oslowdown, int ochance, std::string os);
   virtual void  calculate();
 };
 
@@ -99,9 +102,9 @@
 class BoggCenturionExhaustShot : public Shot
 {
   SpaceLocation *amt;
-  SAMPLE *s;
-  public:
-  BoggCenturionExhaustShot (SpaceLocation *creator, SpaceSprite *osprite, SAMPLE *os);
+  std::string s;
+public:
+  BoggCenturionExhaustShot (SpaceLocation *creator, SpaceSprite *osprite, std::string os);
   virtual void  calculate();
   virtual void  inflict_damage(SpaceObject *other);
   virtual void  animate(Frame *space);
@@ -111,11 +114,11 @@
 class BoggCenturionShot : public Laser
 {
   SpaceSprite *ex_sprite;
-  SAMPLE *ex_sample;
+  std::string ex_sample;
   
-  public:
+public:
   BoggCenturionShot (SpaceLocation *creator, Vector2 opos, double oangle, int odamage,
-             double orange, SpaceSprite *esprite, SAMPLE *esample);
+		     double orange, SpaceSprite *esprite, std::string esample);
   virtual void animate(Frame *space);
   virtual void inflict_damage(SpaceObject *other);
   virtual void calculate();
@@ -125,420 +128,435 @@
 BoggCenturion::BoggCenturion (Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code) :
         Ship(opos, shipAngle, shipData, code)
 {
-        id                      = BOGEI_CENTURION_ID;
-
-        exhaust_on              = (get_config_int("Engines", "ExhaustOn", 0) != 0);
-        exhaust_rate            = get_config_int("Engines", "ExhaustRate", 0);
-        exhaust_frame           = 0;
-        exhaust_slowdown        = get_config_float("Engines", "ExhaustSlowdown", 0) / 1000.0;
-        exhaust_framesize       = get_config_int("Engines", "ExhaustFrameSize", 0);
-        exhaust_thrust          = scale_velocity(get_config_float("Engines", "ExhaustThrust", 0));
-        draw_hotspots           = (get_config_int("Engines", "DrawHotspots", 0) != 0);
-        exhaust_fry_chance      = get_config_int("Engines", "ExhaustFryChance", 0);
-        
-        share_range             = scale_range(get_config_float("Herd", "Range", 0));
-        links_num               = 0;
-        
-        weaponRange             = scale_range(get_config_float("Primary", "Range", 0));
-        weaponDamage            = get_config_int("Primary", "Damage", 0);
-        weaponSpread            = get_config_float("Primary", "Spread", 0) * ANGLE_RATIO;
-        flame_duration          = get_config_int("Primary", "FlameDuration", 0);
-
-        startup_time            = int(get_config_float("Primary", "StartupTime", 0) * 1000);
-        slowdown_time           = int(get_config_float("Primary", "SlowdownTime", 0) * 1000);
-        startup_delay           = int(get_config_float("Primary", "StartupDelay", 0) * 1000);
-
-        specialDamage           = get_config_int("Secondary", "Damage", 0);
-        specialArmour           = get_config_int("Secondary", "Armour", 0);
-        specialLifetime         = int(get_config_float("Secondary", "Lifetime", 0) * 1000);
-        specialFuel             = int(get_config_float("Secondary", "Fuel", 0) * 1000);
-        specialAccel            = scale_acceleration(get_config_float("Secondary", "Accel", 0),0);
-        specialBlastAccel       = scale_velocity(get_config_float("Secondary", "BlastAccel", 0));
-        specialBlastMaxspeed    = scale_velocity(get_config_float("Secondary", "BlastMaxspeed", 0));
-        specialMaxspeed         = scale_velocity(get_config_float("Secondary", "Maxspeed", 0));
-        specialHotspotRate      = get_config_int("Secondary", "HotspotRate", 0);
-        specialHotspotFrameSize = get_config_int("Secondary", "HotspotFrameSize", 0);
-        specialHotspotThrust    = scale_velocity(get_config_float("Secondary", "HotspotThrust", 0));
-        specialHotspotSlowdown  = get_config_float("Secondary", "HotspotSlowdown", 0) / 1000.0;
-        
-        special_slot            = 2;
-
-        gun_phase = 0; old_gun_phase = 0;
-        gun_position = 0;
-        gun_speed = 0;
-        slowing_down = false;
-        gun_full_speed = false;
-        flame_count = -1;
-        delay_count = 0;
-
-        residual_damage = 0;
+  id                      = BOGEI_CENTURION_ID;
+  
+  exhaust_on              = (get_config_int("Engines", "ExhaustOn", 0) != 0);
+  exhaust_rate            = get_config_int("Engines", "ExhaustRate", 0);
+  exhaust_frame           = 0;
+  exhaust_slowdown        = get_config_float("Engines", "ExhaustSlowdown", 0) / 1000.0;
+  exhaust_framesize       = get_config_int("Engines", "ExhaustFrameSize", 0);
+  exhaust_thrust          = scale_velocity(get_config_float("Engines", "ExhaustThrust", 0));
+  draw_hotspots           = (get_config_int("Engines", "DrawHotspots", 0) != 0);
+  exhaust_fry_chance      = get_config_int("Engines", "ExhaustFryChance", 0);
+  
+  share_range             = scale_range(get_config_float("Herd", "Range", 0));
+  links_num               = 0;
+  
+  weaponRange             = scale_range(get_config_float("Primary", "Range", 0));
+  weaponDamage            = get_config_int("Primary", "Damage", 0);
+  weaponSpread            = get_config_float("Primary", "Spread", 0) * ANGLE_RATIO;
+  flame_duration          = get_config_int("Primary", "FlameDuration", 0);
+  
+  startup_time            = int(get_config_float("Primary", "StartupTime", 0) * 1000);
+  slowdown_time           = int(get_config_float("Primary", "SlowdownTime", 0) * 1000);
+  startup_delay           = int(get_config_float("Primary", "StartupDelay", 0) * 1000);
+  
+  specialDamage           = get_config_int("Secondary", "Damage", 0);
+  specialArmour           = get_config_int("Secondary", "Armour", 0);
+  specialLifetime         = int(get_config_float("Secondary", "Lifetime", 0) * 1000);
+  specialFuel             = int(get_config_float("Secondary", "Fuel", 0) * 1000);
+  specialAccel            = scale_acceleration(get_config_float("Secondary", "Accel", 0),0);
+  specialBlastAccel       = scale_velocity(get_config_float("Secondary", "BlastAccel", 0));
+  specialBlastMaxspeed    = scale_velocity(get_config_float("Secondary", "BlastMaxspeed", 0));
+  specialMaxspeed         = scale_velocity(get_config_float("Secondary", "Maxspeed", 0));
+  specialHotspotRate      = get_config_int("Secondary", "HotspotRate", 0);
+  specialHotspotFrameSize = get_config_int("Secondary", "HotspotFrameSize", 0);
+  specialHotspotThrust    = scale_velocity(get_config_float("Secondary", "HotspotThrust", 0));
+  specialHotspotSlowdown  = get_config_float("Secondary", "HotspotSlowdown", 0) / 1000.0;
+  
+  special_slot            = 2;
+  
+  gun_phase = 0; old_gun_phase = 0;
+  gun_position = 0;
+  gun_speed = 0;
+  slowing_down = false;
+  gun_full_speed = false;
+  flame_count = -1;
+  delay_count = 0;
+  
+  residual_damage = 0;
 }
 
 int BoggCenturion::activate_weapon()
 {
-        if ((gun_phase >= old_gun_phase) || (!gun_full_speed) || (delay_count < startup_delay))
-                return false;
+  STACKTRACE;
+  if ((gun_phase >= old_gun_phase) || (!gun_full_speed) || (delay_count < startup_delay))
+    return false;
+  
+  double r = 1 - random(2.0);
+  
+  double l = sqrt(random(1.0));
+  game->add(new BoggCenturionShot(this, 
+				  Vector2(+8 + 8*r, 21), 
+				  angle + r*weaponSpread, weaponDamage, weaponRange * l,
+				  data->spriteWeapon, data->sampleWeapon[1]));
 
-        double r = 1 - random(2.0);
-//        r *= r;
-//        double l = sqrt(1 - r*r) * (1 - (random()%101)/50.0);
-//        l *= l * sin(weaponSpread*ANGLE_RATIO) * weaponRange;
-
-        double l = sqrt(random(1.0));
-        game->add(new BoggCenturionShot(this, Vector2(+8 + 8*r, 21), angle + r*weaponSpread, weaponDamage, weaponRange * l,
-                          data->spriteWeapon, data->sampleWeapon[1]));
-
-        flame_frame = random(4);
-        flame_count = flame_duration;
-
-        return true;
+  flame_frame = random(4);
+  flame_count = flame_duration;
+  
+  return true;
 }
 
-
 void BoggCenturion::calculate_fire_special()
 {
-
-        special_low = FALSE;
-
-        if(fire_special) {
-                if(batt < special_drain) {
-                        special_low = TRUE;
-                        return; } }
-        else return;
-
-        if(special_recharge > 0) return;
-
-        double dx, dy;
-        dx = (19 + 6.3 * special_slot);
-        dy = 2 * special_slot;
-
-        game->add(new BoggCenturionMissile(this, Vector2(dx, dy), angle,
-                          specialDamage, specialArmour, specialLifetime, specialFuel,
-                          specialAccel, specialMaxspeed, specialBlastAccel, specialBlastMaxspeed,
-                          specialHotspotRate, specialHotspotFrameSize, specialHotspotThrust, specialHotspotSlowdown,
-                          data->spriteSpecial, data->spriteExtra, data->sampleSpecial[0],
-                          data->spriteSpecialExplosion));
-        game->add(new BoggCenturionMissile(this, Vector2(-dx, dy), angle,
-                          specialDamage, specialArmour, specialLifetime, specialFuel,
-                          specialAccel, specialMaxspeed, specialBlastAccel, specialBlastMaxspeed,
-                          specialHotspotRate, specialHotspotFrameSize, specialHotspotThrust, specialHotspotSlowdown,
-                          data->spriteSpecial, data->spriteExtra, data->sampleSpecial[0],
-                          data->spriteSpecialExplosion));
-
-        special_slot--;
-        if (special_slot < 0)
-                special_slot = 2;
-
-
-        batt -= special_drain;
-        special_recharge += special_rate;
+  STACKTRACE;
+  special_low = FALSE;
+  
+  if(fire_special) 
+    {
+      if(batt < special_drain) {
+	special_low = TRUE;
+	return; } 
+    }
+  else return;
+  
+  if(special_recharge > 0) return;
+  
+  double dx, dy;
+  dx = (19 + 6.3 * special_slot);
+  dy = 2 * special_slot;
+  
+  game->add(new BoggCenturionMissile(this, Vector2(dx, dy), angle,
+				     specialDamage, specialArmour, specialLifetime, specialFuel,
+				     specialAccel, specialMaxspeed, specialBlastAccel, 
+				     specialBlastMaxspeed, specialHotspotRate, specialHotspotFrameSize, 
+				     specialHotspotThrust, specialHotspotSlowdown,
+				     data->spriteSpecial, data->spriteExtra, data->sampleSpecial[0],
+				     data->spriteSpecialExplosion));
+  game->add(new BoggCenturionMissile(this, Vector2(-dx, dy), angle,
+				     specialDamage, specialArmour, specialLifetime, specialFuel,
+				     specialAccel, specialMaxspeed, specialBlastAccel, 
+				     specialBlastMaxspeed, specialHotspotRate, specialHotspotFrameSize, 
+				     specialHotspotThrust, specialHotspotSlowdown,
+				     data->spriteSpecial, data->spriteExtra, data->sampleSpecial[0],
+				     data->spriteSpecialExplosion));
+  
+  special_slot--;
+  if (special_slot < 0)
+    special_slot = 2;
+  
+  batt -= special_drain;
+  special_recharge += special_rate;
 }
 
 void BoggCenturion::calculate()
 {
-        Ship::calculate();
-
-        if ((fire_weapon) && !( (batt < weapon_drain) || slowing_down)  ) {
-                if (startup_time > 0)
-                        gun_speed += frame_time / (double)startup_time;
-                else    gun_speed = 1.0; }
+  STACKTRACE;
+  Ship::calculate();
+  
+  if ((fire_weapon) && !( (batt < weapon_drain) || slowing_down)  ) {
+    if (startup_time > 0)
+      gun_speed += frame_time / (double)startup_time;
+    else    gun_speed = 1.0; }
         else {  slowing_down = true;
-                gun_full_speed = false;
-                delay_count = 0;
-                if (slowdown_time > 0)
-                        gun_speed -= frame_time / (double)slowdown_time;
+	gun_full_speed = false;
+	delay_count = 0;
+	if (slowdown_time > 0)
+	  gun_speed -= frame_time / (double)slowdown_time;
                 else    gun_speed = 0; }
-        if (gun_speed >= 1.0)  {
-                gun_full_speed = true;
-                gun_speed = 1.0;
-                if (delay_count < startup_delay) delay_count += frame_time; }
-        else
-                if ((gun_speed <= 0) && (slowing_down)) {
-                        gun_speed = 0;
-                        slowing_down = false; }
-        gun_position += frame_time*gun_speed/weapon_rate;
-        while (gun_position >= 1) gun_position -= 1;
-
-        old_gun_phase = gun_phase;
-        gun_phase = (int)floor(gun_position * 8);
-
-        flame_count -= frame_time;
-
-        Query q;
-        links_num = 0;
-        BoggCenturion* bro;
-        for (q.begin(this, bit(LAYER_SHIPS), share_range); q.currento; q.next())
-                if (q.currento->getID() == BOGEI_CENTURION_ID) {
-                        bro = (BoggCenturion*)q.currento;
-                        if (bro->exists())
-                                links_num += 1;
-                        if (links_num == 2) break; }
-
+  if (gun_speed >= 1.0)  {
+    gun_full_speed = true;
+    gun_speed = 1.0;
+    if (delay_count < startup_delay) delay_count += frame_time; }
+  else
+    if ((gun_speed <= 0) && (slowing_down)) {
+      gun_speed = 0;
+      slowing_down = false; }
+  gun_position += frame_time*gun_speed/weapon_rate;
+  while (gun_position >= 1) gun_position -= 1;
+  
+  old_gun_phase = gun_phase;
+  gun_phase = (int)floor(gun_position * 8);
+  
+  flame_count -= frame_time;
+  
+  Query q;
+  links_num = 0;
+  BoggCenturion* bro;
+  for (q.begin(this, bit(LAYER_SHIPS), share_range); q.currento; q.next())
+    if (q.currento->getID() == BOGEI_CENTURION_ID) {
+      bro = (BoggCenturion*)q.currento;
+      if (bro->exists())
+	links_num += 1;
+      if (links_num == 2) break; }  
 }
 
 void BoggCenturion::animate(Frame* space)
 {
-        BITMAP *bmp;
-        bmp = sprite->get_bitmap(64, 0);
-        clear_to_color( bmp, makecol(255,0,255));
+  STACKTRACE;
+  BITMAP *bmp;
+  bmp = sprite->get_bitmap(64, 0);
+  clear_to_color( bmp, makecol(255,0,255));
+  
+  double tx, ty;
+  int ix, iy;
+  
+  //      prepare for the gun
+  tx = sin((sprite_index+5) * 2 * PI / 64.0);
+  ty = cos((sprite_index+5) * 2 * PI / 64.0);
+  int ix1 = 42 + int(19*tx) - 12;
+  int iy1 = 42 - int(19*ty) - 12;
+  
+  blit(data->spriteSpecial->get_bitmap(64), bmp, 0, 0, ix1, iy1, 20, 20);
+  
+  //      flame
+  
+  if (flame_count >= 0) {
+    
+    tx = sin((sprite_index+3) * 2 * PI / 64.0);
+    ty = cos((sprite_index+3) * 2 * PI / 64.0);
+    ix = 42 + int(35*tx) - 10;
+    iy = 42 - int(35*ty) - 10;
+    data->spriteExtraExplosion->draw(ix, iy, 40 + sprite_index + 64*flame_frame, bmp);
+  }
+  
+  //      ship itself
+  sprite->draw(0, 0, sprite_index, bmp);
+  
+  //      gun
+  
+  data->spriteWeaponExplosion->draw(ix1, iy1, sprite_index+64*gun_phase, bmp);
 
-        double tx, ty;
-        int ix, iy;
-
-//      prepare for the gun
-        tx = sin((sprite_index+5) * 2 * PI / 64.0);
-        ty = cos((sprite_index+5) * 2 * PI / 64.0);
-        int ix1 = 42 + int(19*tx) - 12;
-        int iy1 = 42 - int(19*ty) - 12;
-
-        blit(data->spriteSpecial->get_bitmap(64), bmp, 0, 0, ix1, iy1, 20, 20);
-
-//      flame
-
-        if (flame_count >= 0) {
-
-                tx = sin((sprite_index+3) * 2 * PI / 64.0);
-                ty = cos((sprite_index+3) * 2 * PI / 64.0);
-                ix = 42 + int(35*tx) - 10;
-                iy = 42 - int(35*ty) - 10;
-                data->spriteExtraExplosion->draw(ix, iy, 40 + sprite_index + 64*flame_frame, bmp);
-        }
-
-//      ship itself
-        sprite->draw(0, 0, sprite_index, bmp);
-
-//      gun
-
-        data->spriteWeaponExplosion->draw(ix1, iy1, sprite_index+64*gun_phase, bmp);
-
-
-///     shield link indicator
-        tx = sin(sprite_index * 2 * PI / 64.0);
-        ty = cos(sprite_index * 2 * PI / 64.0);
-        ix = 42 + int(-9*tx) - 10;
-        iy = 42 - int(-9*ty) - 10;
-
-        if (links_num)
-                data->spriteExtraExplosion->draw(ix, iy, 296+sprite_index+64*(links_num-1), bmp);
-
-//      final
-        //sprite->animate(pos, 64, space);
-		animate_bmp(bmp, pos, space);
+  
+  ///     shield link indicator
+  tx = sin(sprite_index * 2 * PI / 64.0);
+  ty = cos(sprite_index * 2 * PI / 64.0);
+  ix = 42 + int(-9*tx) - 10;
+  iy = 42 - int(-9*ty) - 10;
+  
+  if (links_num)
+    data->spriteExtraExplosion->draw(ix, iy, 296+sprite_index+64*(links_num-1), bmp);
+  
+  //      final
+  //sprite->animate(pos, 64, space);
+  animate_bmp(bmp, pos, space);
 }
 
 void BoggCenturion::calculate_hotspots()
 {
-        if (draw_hotspots)
-                Ship::calculate_hotspots();
-
-        if (exhaust_frame > 0) exhaust_frame -= frame_time;
-        else    if (thrust) {
-                exhaust_frame += exhaust_rate;
-                if (exhaust_count < 7) exhaust_count += 1;
-                game->add(new BoggCenturionExhaust(this, angle,
-                                  -8.5, -36, data->spriteExtraExplosion, 10*(random(4)) + 10 - exhaust_count,
-                                  exhaust_count, exhaust_framesize, LAYER_HOTSPOTS,
-                                  exhaust_thrust, exhaust_slowdown,
+  STACKTRACE;
+  if (draw_hotspots)
+    Ship::calculate_hotspots();
+  
+  if (exhaust_frame > 0) exhaust_frame -= frame_time;
+  else    if (thrust) {
+    exhaust_frame += exhaust_rate;
+    if (exhaust_count < 7) exhaust_count += 1;
+    game->add(new BoggCenturionExhaust(this, angle,
+				       -8.5, -36, data->spriteExtraExplosion, 10*(random(4)) + 10 - exhaust_count,
+				       exhaust_count, exhaust_framesize, LAYER_HOTSPOTS,
+				       exhaust_thrust, exhaust_slowdown,
                                   exhaust_fry_chance, data->sampleExtra[0]));
-                game->add(new BoggCenturionExhaust(this, angle,
-                                  +9.5, -36, data->spriteExtraExplosion, 10*(random(4)) + 10 - exhaust_count,
-                                  exhaust_count, exhaust_framesize, LAYER_HOTSPOTS,
-                                  exhaust_thrust, exhaust_slowdown,
-                                  exhaust_fry_chance, data->sampleExtra[0])); }
-
-        if (!thrust)
-                exhaust_count = 0;
+    game->add(new BoggCenturionExhaust(this, angle,
+				       +9.5, -36, data->spriteExtraExplosion, 10*(random(4)) + 10 - exhaust_count,
+				       exhaust_count, exhaust_framesize, LAYER_HOTSPOTS,
+				       exhaust_thrust, exhaust_slowdown,
+				       exhaust_fry_chance, data->sampleExtra[0])); }
+  
+  if (!thrust)
+    exhaust_count = 0;
 }
 
 
 int BoggCenturion::handle_damage(SpaceLocation *source, double normal, double direct)
 //void BoggCenturion::handle_damage(SpaceLocation *source)
 {
-        if (source == this) {
-                return Ship::handle_damage(source, normal, direct);
-                 }
-        
-		double tot = normal + direct;
-
-        Query q;
-        int ln = 0;
-        BoggCenturion* bro;
-        for (q.begin(this, bit(LAYER_SHIPS), share_range); q.currento; q.next())
-                if (q.currento->getID() == BOGEI_CENTURION_ID) {
-                        bro = (BoggCenturion*)q.currento;
-                        if (bro->exists()) {
-                                ln += 1;
-                                link[ln] = bro; }
-                        if (links_num == max_links) break; }
-
-        if (ln) {
-                double d = tot;
-
-                if (ln < 2)
-					d *= 0.75;
-                else
-					d *= 0.5;
-
-				tot = (int)floor(d);
-
-                d -= tot;
-                residual_damage += d;
-
-                int dx = (int)floor(residual_damage);
-                tot += dx;
-
-                residual_damage -= dx;
-		
-		}
-
-		Ship::handle_damage(source, tot);
-
-        return 0;
+  STACKTRACE;
+  if (source == this) {
+    return Ship::handle_damage(source, normal, direct);
+  }
+  
+  double tot = normal + direct;
+  
+  Query q;
+  int ln = 0;
+  BoggCenturion* bro;
+  for (q.begin(this, bit(LAYER_SHIPS), share_range); q.currento; q.next())
+    if (q.currento->getID() == BOGEI_CENTURION_ID) {
+      bro = (BoggCenturion*)q.currento;
+      if (bro->exists()) {
+	ln += 1;
+	link[ln] = bro; }
+      if (links_num == max_links) break; }
+  
+  if (ln) {
+    double d = tot;
+    
+    if (ln < 2)
+      d *= 0.75;
+    else
+      d *= 0.5;
+    
+    tot = (int)floor(d);
+    
+    d -= tot;
+    residual_damage += d;
+    
+    int dx = (int)floor(residual_damage);
+    tot += dx;
+    
+    residual_damage -= dx;
+    
+  }
+  
+  Ship::handle_damage(source, tot);
+  
+  return 0;
 }
 
 
-BoggCenturionMissile::BoggCenturionMissile (SpaceLocation *creator, Vector2 opos, double oangle, int odamage, int oarmour,
-                            int olifetime, int ofuel, double oaccel, double omaxspeed, double oblast_accel, double oblast_maxspeed,
-                            int ohotspot_rate, int ohotspot_frame_size, double ohotspot_thrust, double ohotspot_slowdown,
-                            SpaceSprite *osprite, SpaceSprite *hsprite, SAMPLE *s, SpaceSprite *esprite) :
-        Missile (creator, opos, oangle, 0, odamage, -1, oarmour, creator, osprite, 1.0),
-        lifetime(olifetime), fuel(ofuel), accel(oaccel), maxspeed(omaxspeed),
-        hotspot_rate(ohotspot_rate), hotspot_frame_size(ohotspot_frame_size),
-        hotspot_thrust(ohotspot_thrust), hotspot_slowdown(ohotspot_slowdown),
-        hotspot_sprite(hsprite)
+BoggCenturionMissile::BoggCenturionMissile (SpaceLocation *creator, Vector2 opos, 
+					    double oangle, int odamage, int oarmour,
+					    int olifetime, int ofuel, double oaccel, 
+					    double omaxspeed, double oblast_accel, 
+					    double oblast_maxspeed, int ohotspot_rate, 
+					    int ohotspot_frame_size, double ohotspot_thrust, 
+					    double ohotspot_slowdown, SpaceSprite *osprite, 
+					    SpaceSprite *hsprite, std::string s, SpaceSprite *esprite) :
+  Missile (creator, opos, oangle, 0, odamage, -1, oarmour, creator, osprite, 1.0),
+  lifetime(olifetime), fuel(ofuel), accel(oaccel), maxspeed(omaxspeed),
+  hotspot_rate(ohotspot_rate), hotspot_frame_size(ohotspot_frame_size),
+  hotspot_thrust(ohotspot_thrust), hotspot_slowdown(ohotspot_slowdown),
+  hotspot_sprite(hsprite)
 {
-        blast_accel = oblast_accel;
-        blast_maxspeed = oblast_maxspeed;
-        hotspot_frame = 0;
-        play_sound(s, 128);
-        explosionSprite = esprite;
-        explosionFrameCount = 10;
-        explosionFrameSize = 50;
-        explosionSample = data->sampleSpecial[1];
+  blast_accel = oblast_accel;
+  blast_maxspeed = oblast_maxspeed;
+  hotspot_frame = 0;
+  tw_sound->play_sound(data_full_path(s));//       play_sound(s, 128);
+  explosionSprite = esprite;
+  explosionFrameCount = 10;
+  explosionFrameSize = 50;
+  explosionSample = data->sampleSpecial[1];
 }
 
 void BoggCenturionMissile::calculate()
 {
-        SpaceObject::calculate();
-        if (lifetime > 0) lifetime -= frame_time;
-        else    state = 0;
-        
-        if (fuel > 0) {
-                fuel -= frame_time;
-                accelerate(this, angle, accel*frame_time, maxspeed);
-                if (hotspot_frame > 0) hotspot_frame -= frame_time;
-                else {  hotspot_frame += hotspot_rate;
-                        game->add(new BoggCenturionExhaust(this, angle, 0, -8.5, hotspot_sprite, 0, 20,
-                                          hotspot_frame_size, LAYER_HOTSPOTS,
-                                          hotspot_thrust, hotspot_slowdown, 0, NULL)); } }
-
-        //sprite_index = (int(angle / 5.625 + 16)) & 63;
-		sprite_index = get_index(angle);
+  STACKTRACE;
+  SpaceObject::calculate();
+  if (lifetime > 0) 
+    lifetime -= frame_time;
+  else    state = 0;
+  
+  if (fuel > 0) 
+    {
+      fuel -= frame_time;
+      accelerate(this, angle, accel*frame_time, maxspeed);
+      if (hotspot_frame > 0) 
+	hotspot_frame -= frame_time;
+      else 
+	{  
+	  hotspot_frame += hotspot_rate;
+	  game->add(new BoggCenturionExhaust(this, angle, 0, -8.5, hotspot_sprite, 0, 20,
+					     hotspot_frame_size, LAYER_HOTSPOTS,
+					     hotspot_thrust, hotspot_slowdown, 0, NULL)); 
+	} 
+    }
+  sprite_index = get_index(angle);
 };
 
 void  BoggCenturionMissile::inflict_damage(SpaceObject *other)
 {
-        if ((!other->isPlanet()) && (other->mass))
-                other->accelerate(this, normalize(trajectory_angle(other), 360), blast_accel/other->mass, blast_maxspeed);
-        Missile::inflict_damage(other);
+  STACKTRACE;
+  if ((!other->isPlanet()) && (other->mass))
+    other->accelerate(this, normalize(trajectory_angle(other), 360), blast_accel/other->mass, blast_maxspeed);
+  Missile::inflict_damage(other);
 }
 
 
-BoggCenturionExhaust::BoggCenturionExhaust (SpaceLocation *creator, double oangle, double dx, double dy, SpaceSprite *osprite,
-                                          int first_frame, int num_frames, int frame_size, double depth,
-                                          double v, double oslowdown, int ochance, SAMPLE *os) :
-        Animation (creator, creator->normal_pos(), osprite,
-        first_frame, num_frames, frame_size, depth)
+BoggCenturionExhaust::BoggCenturionExhaust (SpaceLocation *creator, double oangle, double dx, 
+					    double dy, SpaceSprite *osprite,
+					    int first_frame, int num_frames, int frame_size, 
+					    double depth, double v, double oslowdown, 
+					    int ochance, std::string os) :
+  Animation (creator, creator->normal_pos(), osprite,
+	     first_frame, num_frames, frame_size, depth)
 {
-        if (random(100) < ochance)
-                game->add(new BoggCenturionExhaustShot(this, osprite, os));
-
-        //double alpha = oangle * ANGLE_RATIO;
-        //double tx = cos(alpha);
-        //double ty = sin(alpha);
-        //x += dy * tx - dx*ty;
-        //y += dy * ty + dx*tx;
-		pos += rotate(Vector2(dy,dx), oangle);
-        //vx = creator->get_vx() - vel * tx;
-        //vy = creator->get_vy() - vel * ty;
-		vel = creator->get_vel() - v * unit_vector(oangle);
-        slowdown = oslowdown;
+  if (random(100) < ochance)
+    game->add(new BoggCenturionExhaustShot(this, osprite, os));  
+  pos += rotate(Vector2(dy,dx), oangle);
+  vel = creator->get_vel() - v * unit_vector(oangle);
+  slowdown = oslowdown;
 }
 
 void BoggCenturionExhaust::calculate()
 {
-        Animation::calculate();
-        double gamma = exp( - slowdown * frame_time);
-        vel *= gamma;
-        //vy *= gamma;
+  STACKTRACE;
+  Animation::calculate();
+  double gamma = exp( - slowdown * frame_time);
+  vel *= gamma;
 }
 
 
-BoggCenturionExhaustShot::BoggCenturionExhaustShot (SpaceLocation *creator, SpaceSprite *osprite, SAMPLE *os) :
-        Shot(creator, 0, 0, 0, 1, 1e40, 1, creator, osprite, 1.0)
+BoggCenturionExhaustShot::BoggCenturionExhaustShot (SpaceLocation *creator, SpaceSprite *osprite, 
+						    std::string os) :
+  Shot(creator, 0, 0, 0, 1, 1e40, 1, creator, osprite, 1.0)
 {
-        amt = creator;
-        s = os;
-        sprite_index = 5;
+  amt = creator;
+  s = os;
+  sprite_index = 5;
 }
 
 void BoggCenturionExhaustShot::calculate()
 {
-        Shot::calculate();
-        if (!amt->exists()) state = 0;
-        //x = amt->normal_x();
-        //y = amt->normal_y();
-		pos = amt->normal_pos();
-        //vx = amt->get_vx();
-        //vy = amt->get_vy();
-		vel = amt->get_vel();
+  STACKTRACE;
+  Shot::calculate();
+  if (!amt->exists()) 
+    state = 0;
+  
+  pos = amt->normal_pos();
+  vel = amt->get_vel();
 }
 
 void BoggCenturionExhaustShot::animate(Frame *space)
 {
+  STACKTRACE;
 }
 
 void BoggCenturionExhaustShot::inflict_damage(SpaceObject *other)
 {
-        //other->damage += 1;
-        other->handle_damage(this, 1);
-        if (s)  play_sound(s, 160);
-        state = 0;
+  STACKTRACE;
+  other->handle_damage(this, 1);
+  if (!s.empty())  
+    {
+      tw_sound->play_sound(data_full_path(s)); // was vol 160
+    }
+  state = 0;
 }
 
-
-BoggCenturionShot::BoggCenturionShot (SpaceLocation *creator, Vector2 opos, double oangle, int odamage,
-                      double orange, SpaceSprite *esprite, SAMPLE *esample) :
-        Laser(creator, oangle, 0, orange, odamage, 300, creator, opos, true)
+BoggCenturionShot::BoggCenturionShot (SpaceLocation *creator, Vector2 opos, 
+				      double oangle, int odamage,
+				      double orange, SpaceSprite *esprite, 
+				      std::string esample) :
+  Laser(creator, oangle, 0, orange, odamage, 300, creator, opos, true)
 {
-        ex_sprite = esprite; ex_sample = esample;
+  ex_sprite = esprite; ex_sample = esample;
 }
 
 void BoggCenturionShot::animate(Frame *space)
 {
-	// for testing show the lasers
-//color = makecol(255,255,255); Laser::animate(space);
+  STACKTRACE;
 }
 
 void BoggCenturionShot::inflict_damage(SpaceObject *other)
 {
-        //x += edge_x(); y += edge_y();
-		pos += edge();
-//        play_sound(ex_sample, 240);
-        game->add(new Animation(this, pos, ex_sprite, 0, 10, 50, LAYER_EXPLOSIONS));
-        //other->damage += damage_factor;
-        other->handle_damage(this, damage_factor);
-        state = 0;
+  STACKTRACE;
+  pos += edge();
+  tw_sound->play_sound(data_full_path(ex_sample)); // was vol 240
+  game->add(new Animation(this, pos, ex_sprite, 0, 10, 50, LAYER_EXPLOSIONS));
+  other->handle_damage(this, damage_factor);
+  state = 0;
 }
 
 void BoggCenturionShot::calculate()
 {
-        if (frame > 0) {
-                state = 0;
-                return; }
-        Laser::calculate();
+  STACKTRACE;
+  if (frame > 0) 
+    {
+      state = 0;
+      return; 
+    }
+  Laser::calculate();
 }
 
 
-
 REGISTER_SHIP(BoggCenturion)

Modified: branches/multiplayer-branch/source/ships/shpchoex.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpchoex.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shpchoex.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -18,7 +18,6 @@
 #include "ship.h"
 #include "melee/mcbodies.h"
 
-REGISTER_FILE
 /*
 Since this is my first ship, I obviously nabbed a lot of this code from other ship files.
 The sources of my inspiration:
@@ -51,6 +50,7 @@
 AsteroidDebris::AsteroidDebris(Ship *creator1, Vector2 new_pos, int tforce)
 : Asteroid()
 {
+  STACKTRACE;
   creator=creator1;
   translate(new_pos - pos);
   frame_born=(int)(game->frame_number);
@@ -61,7 +61,7 @@
 }
 void AsteroidDebris::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
   step-= frame_time;
   while(step <= 0) {
     step += speed * time_ratio;
@@ -83,7 +83,7 @@
 }
 int AsteroidDebris::canCollide(SpaceLocation *other) 
 {
-	STACKTRACE
+  STACKTRACE;
   if (collide_flag)
     { return SpaceObject::canCollide(other);
     }
@@ -107,13 +107,14 @@
 AsteroidCenter::AsteroidCenter(Ship *creator1, Vector2 new_pos) 
 : AsteroidDebris(creator1, new_pos, 0)
 {
+  STACKTRACE;
   layer = LAYER_SHOTS;
   collide_flag_anyone = ALL_LAYERS &~ bit(LAYER_CBODIES);
   creator=creator1;
 }
 void AsteroidCenter::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
   if (creator == NULL)
     {
       this->~AsteroidCenter();
@@ -127,16 +128,18 @@
 }
 int AsteroidCenter::canCollide(SpaceLocation *other) 
 {
-	STACKTRACE
+  STACKTRACE;
   if (!other->damage_factor) return false;
   return SpaceObject::canCollide(other);
 }
 int AsteroidCenter::handle_damage(SpaceLocation *source, double normal, double direct) 
 {
+  STACKTRACE;
 	return iround(normal + direct);
 }
 int AsteroidCenter::isAsteroid()
 {
+  STACKTRACE;
   return 0;
 }
 
@@ -162,6 +165,7 @@
 Laser(creator1, langle, lcolor, lrange, 
        ldamage, lfcount, opos, Vector2(rel_x,rel_y), osinc_angle)
 {
+  STACKTRACE;
   tractorForce = tForce;
   tractorPushForce = tPushForce;
   creator=creator1;
@@ -169,7 +173,7 @@
 
 void ChoraliTractorBeam::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
   // SpaceObject::inflict_damage(other);
  if(other != NULL)
   {
@@ -257,8 +261,9 @@
     int R, int Rm, int G, int Gm, int B, int Bm) :
   HomingMissile(oship, Vector2(ox,oy), oangle, ov, odamage, orange, oarmour, otrate, 
 		oship, osprite, oship->target), 
-  explosion(meleedata.asteroidExplosionSprite), frame_count(oframe_count) 
+  explosion(game->meleedata.asteroidExplosionSprite), frame_count(oframe_count) 
 {
+  STACKTRACE;
 	collide_flag_sameship = bit(LAYER_SHIPS) | bit(LAYER_SHOTS);
 	//	explosionSprite     = game->asteroidExplosionSprite;
 	
@@ -283,7 +288,7 @@
 
 void AsteroidMissile::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
   HomingMissile::calculate();
   if(sprite_index_count<63)
@@ -306,7 +311,7 @@
 
 void AsteroidMissile::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
   SpaceObject::inflict_damage(other);
   add(new Animation(this, pos, explosion, 0, explosion->frames(), time_ratio, LAYER_CBODIES));
   state=0;
@@ -314,7 +319,7 @@
 
 int AsteroidMissile::handle_damage(SpaceLocation *source, double normal, double direct) 
 {
-	STACKTRACE
+  STACKTRACE;
   if (!exists()) return 0;
   if (!normal && !direct) return 0;
   
@@ -326,7 +331,7 @@
 }
 void AsteroidMissile::death()
 {
-	STACKTRACE
+  STACKTRACE;
   HomingMissile::death();
   add(new Animation(this, pos, explosion, 0, explosion->frames(), time_ratio, LAYER_CBODIES));
 }
@@ -416,6 +421,7 @@
 	Ship(opos, shipAngle, shipData, code)
 
 {
+  STACKTRACE;
   weaponFrames = get_config_int("Weapon", "Frames", 0);
   drillFrames  = 0;
   weaponDamage   = get_config_int("Weapon", "Damage", 0);
@@ -456,7 +462,7 @@
 
 void ChoraliExtractor::death()
 {
-	STACKTRACE
+  STACKTRACE;
   Ship::death();
 
   // dangerous, this is a memory leak:
@@ -465,26 +471,26 @@
 }
 void ChoraliExtractor::materialize()
 {
-	STACKTRACE
+  STACKTRACE;
 	Ship::materialize();
 	add(asteroid_center = new AsteroidCenter(this, this->normal_pos()));
 }
 
 void ChoraliExtractor::calculate_turn_left()
 {
-	STACKTRACE
+  STACKTRACE;
   Ship::calculate_turn_left();
 }
 
 void ChoraliExtractor::calculate_turn_right()
 {
-	STACKTRACE
+  STACKTRACE;
   Ship::calculate_turn_right();
 }
 
 int ChoraliExtractor::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
   if (drillFrames > 0)
     {
       count=0;      
@@ -501,7 +507,7 @@
       else
 	{
 	  grabbed->die();
-       	  add(new AsteroidMissile(0.0, (size.y * 1.0), angle, AsteroidMissileVelocity, AsteroidMissileDamage, AsteroidMissileRange, AsteroidMissileArmour, AsteroidMissileTurnRate, this, meleedata.asteroidSprite, 1,
+       	  add(new AsteroidMissile(0.0, (size.y * 1.0), angle, AsteroidMissileVelocity, AsteroidMissileDamage, AsteroidMissileRange, AsteroidMissileArmour, AsteroidMissileTurnRate, this, game->meleedata.asteroidSprite, 1,
                  tractorR, tractorRmin, tractorG, tractorGmin, tractorB, tractorBmin ));
 	  return(TRUE);
      	}
@@ -516,7 +522,7 @@
 
 int ChoraliExtractor::activate_special()
 {
-	STACKTRACE
+  STACKTRACE;
 
   if(this->nearest_planet() != NULL)
     {
@@ -541,37 +547,43 @@
 
 void ChoraliExtractor::calculate()
 {
-	STACKTRACE
-   if(drillFrames > 0) 
-     {
-       if(grabbed == NULL)
-	 {
-	   amt_beams=(random()%tractorMaxBeams)+1;
+  STACKTRACE;
+  if(drillFrames > 0) 
+    {
+      if(grabbed == NULL)
+	{
+	  amt_beams=(random()%tractorMaxBeams)+1;
+	  
+	  for(int i=0;i<amt_beams;i++)
+	    {
+	      add(new ChoraliTractorBeam(this, (double)(angle+(((random() % tractorSpread) - 
+								(tractorSpread/2))*ANGLE_RATIO) ),
+					 makecol((random()%(tractorR-tractorRmin+1))+tractorRmin, 
+						 (random()%(tractorG-tractorGmin+1))+tractorGmin, 
+						 (random()%(tractorB-tractorBmin+1))+tractorBmin), 
+					 tractorRange, tractorDamage, tractorRate, this, 0.0, 0.0, 
+					 true, tractorForce, tractorPushForce));
 
-	   for(int i=0;i<amt_beams;i++)
-	     {
-	      
-	       add(new ChoraliTractorBeam(this, (double)(angle+(((random() % tractorSpread) - (tractorSpread/2))*ANGLE_RATIO) ),
-		      makecol((random()%(tractorR-tractorRmin+1))+tractorRmin, (random()%(tractorG-tractorGmin+1))+tractorGmin, (random()%(tractorB-tractorBmin+1))+tractorBmin), 
-		      tractorRange, tractorDamage, tractorRate, this, 0.0, 0.0, true, tractorForce, tractorPushForce));
-
+	    }
+	  if(count>=PI)
+	    { 
+	      count=0;
+	    }
+	  if(count==0)
+	    {
+	      tw_sound->stop_sound(data_full_path(data->sampleExtra[0]));
+	      tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
 	     }
-	   if(count>=PI)
-	     { count=0;
-	     }
-	   if(count==0)
-	     {
-	       play_sound2(data->sampleExtra[0]);
-	     }
-	   count++;
-
+	  count++;
+	  
 	 }
-
-       drillFrames-= frame_time;
-       if ((drillFrames <= 0) && (!latched)) 
-	 {
-	   play_sound2(data->sampleWeapon[0]);
-	 }
+      
+      drillFrames-= frame_time;
+      if ((drillFrames <= 0) && (!latched)) 
+	{
+	  tw_sound->stop_sound(data_full_path(data->sampleWeapon[0]));
+	  tw_sound->play_sound(data_full_path(data->sampleWeapon[0]));
+	}
      }
    else 
      {
@@ -647,7 +659,7 @@
 
 int ChoraliExtractor::canCollide(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
   if ((latched) && (grabbed!=NULL) && (grabbed->exists()))
     {
       if (grabbed == other)
@@ -658,14 +670,14 @@
  
 void ChoraliExtractor::animate(Frame *space)
 {
-	STACKTRACE
-    sprite->animate( pos, sprite_index, space);
+  STACKTRACE;
+  sprite->animate( pos, sprite_index, space);
 }
 
 
 void ChoraliExtractor::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
   if (drillFrames > 0)
     {
       if (!latched)
@@ -681,7 +693,8 @@
 		  grabdistance = (distance(other) * 1.1);
 		  grabshipangle = (other->get_angle());
 		  drillDamageLeft = weaponDamage;
-		  play_sound2(data->sampleExtra[1]);
+		  tw_sound->stop_sound(data_full_path(data->sampleExtra[1]));
+		  tw_sound->play_sound(data_full_path(data->sampleExtra[1]));
 		  if ((drillFrames / frame_time)< weaponDamage) 
 		    {
 		      drillDamagePerDamageFrame = (weaponDamage/drillFrames)

Modified: branches/multiplayer-branch/source/ships/shpconca.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpconca.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shpconca.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -18,8 +18,6 @@
 #include <stdio.h>
 #include "ship.h"
 #include "melee/mview.h"
-//#include "link.h"
-REGISTER_FILE
 
 inline double sqr(double x)
 {
@@ -73,6 +71,7 @@
 	SpaceObject *Next_Object):SpaceObject(creator,
 	opos,oangle,osprite)
 {
+  STACKTRACE;
 	Prev_Link=(Link *)Prev_Object;
 	Next_Link=(Link *)Next_Object;
 }
@@ -121,7 +120,7 @@
 
 void CargoLink::do_area_damage()
 {
-	STACKTRACE
+  STACKTRACE;
 	Query q;
 	for (q.begin(this, OBJECT_LAYERS, explosionRange); q.currento; q.next())
 	{
@@ -137,48 +136,50 @@
 
 int CargoLink::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE
-	int  totalDamage = int( normal+direct + 0.5);
+  STACKTRACE;
+  int  totalDamage = int( normal+direct + 0.5);
 
-	if (totalDamage == 0) return 0;
+  if (totalDamage == 0) 
+    return 0;
 
-	//If there are no links, the link is destroyed.
-	if (!Prev_Link && !Next_Link)
+  //If there are no links, the link is destroyed.
+  if (!Prev_Link && !Next_Link)
+    {
+      state=0;
+      
+      // small chance of causing an explosion here, 1:5
+      // (later changed into a big chance)
+      
+      if ( random(1) == 0 )
 	{
-		state=0;
-
-		// small chance of causing an explosion here, 1:5
-		// (later changed into a big chance)
-
-		if ( random(1) == 0 )
-		{
-			
-			do_area_damage( );
-
-			play_sound((SAMPLE *)(melee[MELEE_BOOMSHIP].dat));
-			game->add(new Animation(this, pos,	meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS));
-
-		}
-		
-
-
-		return totalDamage;
+	  
+	  do_area_damage( );
+	  
+	  tw_sound->play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
+	  game->add(new Animation(this, pos,	game->meleedata.kaboomSprite, 0, 
+				  KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS));
+	  
 	}
-
-	//If a previous link exists, the damage is passed to it.
-	//directDamage is used so that we don't play the damage sound
-	//again.
-
-	if (Prev_Link) return damage(Prev_Link, 0, totalDamage);
-	else {
-		die();
-		return totalDamage;
-	}
+      
+      return totalDamage;
+    }
+  
+  //If a previous link exists, the damage is passed to it.
+  //directDamage is used so that we don't play the damage sound
+  //again.
+  
+  if (Prev_Link) 
+    return damage(Prev_Link, 0, totalDamage);
+  else 
+    {
+      die();
+      return totalDamage;
+    }
 }
 
 void CargoLink::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	Link::calculate();
 	sprite_index = get_index(angle);
 	if (Prev_Link && !Prev_Link->exists()) Prev_Link = NULL;
@@ -191,6 +192,7 @@
 :
 Link(creator,opos,oangle,osprite,Prev_Object,Next_Object)
 {
+  STACKTRACE;
 	mass=omass;
 	layer = LAYER_SPECIAL;
 
@@ -207,7 +209,7 @@
 
 void Chain::Pull_Last_Link()
 {
-	STACKTRACE
+  STACKTRACE;
 	Link *l=this;
 
 	//Seek to the end of the list
@@ -219,13 +221,13 @@
 
 int Chain::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE
+  STACKTRACE;
 	return damage(Prev_Link, 0, normal+direct);
 }
 
 void Chain::Uncouple()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	for(Link *l=this->Next_Link ; l!=NULL; l=l->Next_Link)
 	{
@@ -270,6 +272,7 @@
 :
 Link(creator,opos, oangle,osprite,NULL,NULL)
 {
+  STACKTRACE;
 		
 	Prev_Link=(Link *)creator;	//Attach the first link to the ship
 	
@@ -308,7 +311,7 @@
 
 void Chain::addlink(SpaceLocation *creator, double oangle, SpaceSprite *osprite, double ospacing, double omass)
 {
-	STACKTRACE
+  STACKTRACE;
 	// first, find the last link in the list:
 	
 	Link *Cur_Link = this;					// Chain is also of type Link.
@@ -353,7 +356,7 @@
 //backwards.
 void Chain::ChainRecur(Link *other,int num)
 {
-	STACKTRACE
+  STACKTRACE;
 	//Call ChainRecur for the next link UNLESS you're at the last link
 	if(other->Next_Link!=NULL) ChainRecur(other->Next_Link,num+1);
 
@@ -364,7 +367,7 @@
 
 void Chain::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	if( !(ship && ship->exists()) )
 	{	//If the mothership is killed, the chain dies.
 		Uncouple();		//Shatters chain, links become independent
@@ -383,7 +386,7 @@
 
 void Chain::ChainPhysics(SpaceObject *first, SpaceObject *second)
 {
-	STACKTRACE
+  STACKTRACE;
 
 
 	// first = towards the head, second = towards the tail
@@ -503,6 +506,7 @@
 	Ship(opos, angle, data, code)
 
 {
+  STACKTRACE;
 	weaponColor   =  get_config_int("Weapon", "Color", 0);
 	weaponRange   =  scale_range(get_config_float("Weapon", "Range", 0));
 	weaponDamage  =  get_config_int("Weapon", "Damage", 0);
@@ -516,7 +520,7 @@
 
 int ConfedCargotran::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
 	if(fire_special) return(FALSE);
 
 	//Add weapon code here
@@ -529,7 +533,7 @@
 
 int ConfedCargotran::activate_special()
 {
-	STACKTRACE
+  STACKTRACE;
 	//Cuts loose all links and remembers that it did so.
 	if(Head==NULL)
 		return(FALSE);
@@ -551,7 +555,7 @@
 
 void ConfedCargotran::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 	double back_x=size.x/3.60, back_y=-size.y/2.33,
 	       frnt_x=size.x/5.55, frnt_y=+size.y/17.01,
 	       back_y_1=-size.y/2.06;
@@ -588,7 +592,7 @@
 
 void ConfedCargotran::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	Ship::calculate();
 
 }
@@ -596,7 +600,7 @@
 
 void ConfedCargotran::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE;
+  STACKTRACE;
 	if (!(other && other->exists()))
 		return;
 

Modified: branches/multiplayer-branch/source/ships/shpconho.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpconho.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shpconho.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 #include "melee/mmain.h"
 #include "melee/mcbodies.h"
@@ -78,6 +77,7 @@
 		ShipData *shipData, unsigned int code) :
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   regenrateFrames = get_config_int("Extra", "Frames", 0);
   regenrating     = FALSE;
   regenrateAmount = get_config_int("Extra", "RechargeAmount", 0);
@@ -114,7 +114,7 @@
 }
 
 int ConfederationHornet::activate_weapon() {
-	STACKTRACE
+  STACKTRACE;
   add(new Missile(this, Vector2(7,35),
     angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
     this, data->spriteWeapon));
@@ -126,7 +126,7 @@
 
 int ConfederationHornet::activate_special()
 {
-	STACKTRACE
+  STACKTRACE;
   add(new TorpedoMissile(0.0, (size.y / 2.0),
     angle, specialVelocity, specialDamage, specialDDamage, specialRange, specialArmour, specialTurnRate, this, this, data->spriteSpecial, target));
   return(TRUE);
@@ -134,7 +134,7 @@
 
 void ConfederationHornet::calculate()
 {
-	STACKTRACE;
+  STACKTRACE;
 
 //   int shield_color = 9; // Blue
 //   int i, bar_x, bar_y, shield_panel;
@@ -183,7 +183,7 @@
 }
 
 int ConfederationHornet::handle_damage(SpaceLocation *source, double normal, double direct) {
-	STACKTRACE
+  STACKTRACE;
    if ((normal - shield) <= 0) {
      shield -= iround(normal);
 	 normal = 0;
@@ -197,6 +197,7 @@
 
 RGB ConfederationHornet::crewPanelColor(int k)
 {
+  STACKTRACE;
 	RGB c1 = {0,255,0};
 	RGB c2 = {0,0,255};		// blue
 
@@ -209,6 +210,7 @@
 // returns the "real" live crew (this can fool the Syreen).
 double ConfederationHornet::getCrew()
 {
+  STACKTRACE;
 	if (crew)
 		return 1;
 	else
@@ -225,10 +227,11 @@
   HomingMissile(creator, Vector2(ox,oy), oangle, ov, odamage, orange, oarmour, otrate, opos, osprite, otarget),
   Direct_Damage(oddamage)
 {
+  STACKTRACE;
 }
 
 void TorpedoMissile::inflict_damage(SpaceObject *other) {
-	STACKTRACE
+  STACKTRACE;
 	damage(other, 0, Direct_Damage);
   HomingMissile::inflict_damage(other);
 }

Modified: branches/multiplayer-branch/source/ships/shpdragr.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpdragr.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shpdragr.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -17,7 +17,6 @@
 
 #include <assert.h>
 #include "ship.h"
-REGISTER_FILE
 
 #include "frame.h"
 
@@ -76,6 +75,7 @@
 						 ShipData *shipData, unsigned int code) :
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -102,7 +102,7 @@
 
 int DraxGryphon::activate_weapon()
 {
-	STACKTRACE;
+  STACKTRACE;
   weaponoffset++;
 
   if (weaponoffset > 3)
@@ -119,9 +119,8 @@
 
 int DraxGryphon::activate_special()
 {
+  STACKTRACE;
 
-	STACKTRACE;
-
 	if (numMines == maxMines) {
 	  weaponObject[0]->state = 0;
 	  numMines -= 1;
@@ -140,7 +139,7 @@
 
 void DraxGryphon::calculate()
 {
-STACKTRACE;
+  STACKTRACE;
 
    int j = 0;
    for (int i = 0; i < numMines; i += 1) {
@@ -161,6 +160,7 @@
     AnimatedShot(oship, Vector2(ox,oy), oangle, ov, odamage, -1.0, oarmour, oship,
       osprite, ofcount, ofsize)
 {
+  STACKTRACE;
   MineMoving = TRUE;
   MineRange = miner;
   MineTimer = minet;
@@ -172,9 +172,8 @@
 }
 
 void DraxMine::calculate() {
+  STACKTRACE;
 
-	STACKTRACE;
-
 	AnimatedShot::calculate();
 
 	if (!exists()) return;
@@ -241,8 +240,7 @@
 }
 
 void DraxMine::inflict_damage(SpaceObject *other) {
-
-	STACKTRACE;
+  STACKTRACE;
   if (other->isShip())
      damage_factor = 0;
 

Modified: branches/multiplayer-branch/source/ships/shpearc3.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpearc3.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shpearc3.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -17,7 +17,6 @@
 
 #include "ship.h"
 #include "util/aastr.h"
-REGISTER_FILE
 
 class EarthlingCruiserMk3Beam;
 
@@ -80,6 +79,7 @@
 		ShipData *shipData, unsigned int code) :
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 	weaponRange			= scale_range(get_config_float("Weapon", "Range", 0));
 	weaponVelocity		= scale_velocity(get_config_float("Weapon", "Velocity", 0));
 	weaponDamage		= get_config_int("Weapon", "Damage", 0);
@@ -102,7 +102,7 @@
 
 void EarthlingCruiserMk3::calculate()
 {
-	STACKTRACE;
+  STACKTRACE;
 	Ship::calculate();
 
 	double track_angle = 0;
@@ -149,7 +149,7 @@
 
 int EarthlingCruiserMk3::activate_weapon()
 {
-	STACKTRACE;
+  STACKTRACE;
 	add(new EarthlingCruiserMk3Shot(this, Vector2(0.0, 28.0),
 		normalize(angle + launch_angle + turn_step + tw_random(-weaponSpread, +weaponSpread), PI2),
 		weaponVelocity,	weaponDamage, weaponRange, weaponArmour, data->spriteWeapon));
@@ -158,41 +158,44 @@
 
 int EarthlingCruiserMk3::activate_special()
 {
-	STACKTRACE;
-	bool fire = false;;
-	SpaceObject *o;
-	double rng = 1e40;
-	SpaceObject *tgt = NULL;
-
-	pos -= unit_vector(angle) * 6;	//!!!
-	Query q;
-	for (q.begin(this, bit(LAYER_SHIPS) + bit(LAYER_SHOTS) + bit(LAYER_SPECIAL) + 
-			bit(LAYER_CBODIES), specialRange); q.current; q.next()) {
-		o = q.currento;
-		if (!o->isInvisible() && !o->sameTeam(this)	&& (o->collide_flag_anyone&bit(LAYER_LINES))
-				&& (distance(o) < rng)) {
-			tgt = o;
-			rng = distance(o);
-		}
-	}
-	q.end();
-	pos += unit_vector(angle) * 6;	//!!!
-
-	if (tgt) {
-		game->add(new EarthlingCruiserMk3Beam(this, Vector2(0,-6), specialRange,
-				specialDamage, specialDamageShots, specialFrames, tgt));
-		play_sound(data->sampleSpecial[0]);
-		fire = true; }
-
-	return(fire);
+  STACKTRACE;
+  bool fire = false;;
+  SpaceObject *o;
+  double rng = 1e40;
+  SpaceObject *tgt = NULL;
+  
+  pos -= unit_vector(angle) * 6;	//!!!
+  Query q;
+  for (q.begin(this, bit(LAYER_SHIPS) + bit(LAYER_SHOTS) + bit(LAYER_SPECIAL) + 
+	       bit(LAYER_CBODIES), specialRange); q.current; q.next()) {
+    o = q.currento;
+    if (!o->isInvisible() && !o->sameTeam(this)	&& (o->collide_flag_anyone&bit(LAYER_LINES))
+	&& (distance(o) < rng)) 
+      {
+	tgt = o;
+	rng = distance(o);
+      }
+  }
+  q.end();
+  pos += unit_vector(angle) * 6;	//!!!
+  
+  if (tgt) 
+    {
+      game->add(new EarthlingCruiserMk3Beam(this, Vector2(0,-6), specialRange,
+					    specialDamage, specialDamageShots, 
+					    specialFrames, tgt));
+	    tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
+	    fire = true; 
+    }
+  
+  return(fire);
 }
 
-
-
 EarthlingCruiserMk3Shot::EarthlingCruiserMk3Shot(SpaceLocation *creator, Vector2 opos, double oangle,
 		double ov, double odamage, double orange, double oarmour, SpaceSprite *osprite) :
 	Shot(creator, opos, oangle, ov, odamage, orange, oarmour, creator, osprite)
 {
+  STACKTRACE;
 	explosionSprite     = data->spriteWeaponExplosion;
 	explosionFrameCount = 20;
 	explosionFrameSize  = 25;
@@ -200,22 +203,22 @@
 	sprite_index = 32;
 
 	attributes &= ~ATTRIB_STANDARD_INDEX;
-	play_sound(data->sampleWeapon[0]);
+	tw_sound->play_sound(data_full_path(data->sampleWeapon[0]));
 }
 
 
 void EarthlingCruiserMk3Shot::animate(Frame *space)
 {
-	STACKTRACE;
-	if (exists())
-		sprite->animate(pos, sprite_index = (int)(31.99 * d / range), space);
+  STACKTRACE;
+  if (exists())
+    sprite->animate(pos, sprite_index = (int)(31.99 * d / range), space);
 }
 
 void EarthlingCruiserMk3Shot::soundExplosion()
 {
-	STACKTRACE;
-	play_sound(explosionSample);
-	return;
+  STACKTRACE;
+  tw_sound->play_sound(data_full_path(explosionSample));
+  return;
 }
 
 
@@ -226,6 +229,7 @@
 	frame(0), frame_count(lfcount), lpos(creator), rel_pos(rpos), damage_shots(sdamage)
 
 {
+  STACKTRACE;
 	set_depth(DEPTH_EXPLOSIONS);
 	target = tgt;
 	base_length = length;
@@ -250,7 +254,7 @@
 
 void EarthlingCruiserMk3Beam::calculate()
 {
-	STACKTRACE;
+  STACKTRACE;
 	if(!(lpos && lpos->exists()))
 	{
 		lpos = 0;
@@ -305,7 +309,7 @@
 
 void EarthlingCruiserMk3Beam::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE;
+  STACKTRACE;
 	if (other->isShot())
 		damage(other, damage_shots*frame_time/frame_count);
 	else
@@ -314,7 +318,7 @@
 	int aa = get_tw_aa_mode();
 	if (!((aa & AA_BLEND) && (aa & AA_ALPHA) && (!got_spark) && !(aa & AA_NO_AA))) {
 		physics->add(new Animation( this, 
-				pos + edge(), meleedata.sparkSprite, 0, 
+				pos + edge(), game->meleedata.sparkSprite, 0, 
 				SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
 		got_spark = true; }
 
@@ -323,7 +327,7 @@
 
 void EarthlingCruiserMk3Beam::animate(Frame *space)
 {
-	STACKTRACE;
+  STACKTRACE;
 	int aa = get_tw_aa_mode();
 	SpaceLine::animate(space);
 	if ((aa & AA_BLEND) && (aa & AA_ALPHA) && !(aa & AA_NO_AA) && (length < base_length*0.9999) && (target)) {

Modified: branches/multiplayer-branch/source/ships/shpforsh.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpforsh.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shpforsh.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -18,7 +18,6 @@
 //ForevianShocker lousy code by Richardyzo at ig.com.br
 
 #include "ship.h"
-REGISTER_FILE
 
 class ForevianShocker : public Ship
 {	double		weaponRange, weaponVelocity;
@@ -59,6 +58,7 @@
 ForevianShocker::ForevianShocker(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code) :
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 	weaponRange		= scale_range(get_config_float("Weapon", "Range", 0)); 
 	weaponVelocity	= scale_velocity(get_config_float("Weapon", "Velocity", 0));
 	weaponDamage	= get_config_int("Weapon", "Damage", 0); 
@@ -91,116 +91,159 @@
 
 int ForevianShocker::activate_weapon()
 {
-	STACKTRACE
-
-	SpaceSprite *tmp_s = data->spriteWeapon;
-	if (weapon_type==2)	tmp_s = data->spriteExtra;
-	play_sound2(data->sampleWeapon[0]);
-	if (weapon_type == 0) {
-		if(random()%2)
-			tmp_s = data->spriteExtra;
-		add(new AnimatedShot(this, Vector2(27.0,20.0), angle , weaponVelocity,	weaponDamage, weaponRange, weaponArmour, this, tmp_s, 32, weapon_frame_size, 1.0));
-		if (weapon_type == 0) {
-			if(random()%2)	tmp_s = data->spriteExtra;
-			else	tmp_s = data->spriteWeapon; } }
-	add(new AnimatedShot(this, Vector2(-27.0,20.0), angle , weaponVelocity,	weaponDamage, weaponRange, weaponArmour, this, tmp_s, 32, weapon_frame_size, 1.0));	return(TRUE);
+  STACKTRACE;
+  SpaceSprite *tmp_s = data->spriteWeapon;
+  if (weapon_type==2)	
+    tmp_s = data->spriteExtra;
+  tw_sound->stop_sound(data_full_path(data->sampleWeapon[0]));
+  tw_sound->play_sound(data_full_path(data->sampleWeapon[0]));
+	
+  if (weapon_type == 0) 
+    {
+      if(random()%2)
+	tmp_s = data->spriteExtra;
+      add(new AnimatedShot(this, Vector2(27.0,20.0), angle , weaponVelocity,	
+			   weaponDamage, weaponRange, weaponArmour, this, tmp_s, 
+			   32, weapon_frame_size, 1.0));
+      if (weapon_type == 0) 
+	{
+	  if(random()%2)	
+	    tmp_s = data->spriteExtra;
+	  else	
+	    tmp_s = data->spriteWeapon; 
+	} 
+    }
+  add(new AnimatedShot(this, Vector2(-27.0,20.0), angle , weaponVelocity,	
+		       weaponDamage, weaponRange, weaponArmour, this, tmp_s, 32, 
+		       weapon_frame_size, 1.0));	
+  return(TRUE);
 }
 
 int ForevianShocker::activate_special()
 {
-	STACKTRACE
-	if(shockingFrames == 0) {
-		play_sound2(data->sampleSpecial[0]);
-		shockingFrames = specialFrames;
-		shockVar = 1;
-		recharge_amount = 0; }
-	return true;
+  STACKTRACE;
+  if(shockingFrames == 0) 
+    {
+      tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+      tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
+      shockingFrames = specialFrames;
+      shockVar = 1;
+      recharge_amount = 0; 
+    }
+  return true;
 }
 
 void ForevianShocker::calculate()
 {
-	STACKTRACE
-	if(shockVar == 1)
+  STACKTRACE;
+  if(shockVar == 1)
+    {
+      if(shockingFrames > 0)
+	shockingFrames -= frame_time;
+      
+      if(shockVar && shockingFrames == 2500 )
 	{
-		if(shockingFrames > 0)
-			shockingFrames -= frame_time;
-		
-		//if(shockVar && shockingFrames <= 2500 )
-		if(shockVar && shockingFrames == 2500 )
-		{
-			add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
-		}
-		if(shockingFrames == 2000 )
-		{
-			play_sound2(data->sampleSpecial[0]);
-			add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
-		}
-		if(shockingFrames == 1500 )
-		{
-			play_sound2(data->sampleSpecial[0]);
-			add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
-		}
-		if(shockingFrames == 1000 )
-		{
-			play_sound2(data->sampleSpecial[0]);
-			add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
-		}
-		if(shockingFrames == 500 )
-		{
-			play_sound2(data->sampleSpecial[0]);
-			add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
-		}
-		if(shockingFrames == 50 )
-		{
-			play_sound2(data->sampleSpecial[1]);
-			
-			add( new ForevianShockwave(0, 70, angle , specialVelocity, specialDamage, specialRange, specialArmour, this, this, special_sprite, special_frame_num, special_frame_size, specialLoss));
-			
-			shockingFrames = 0;
-			shockVar = 0;
-			recharge_amount = 1;
-		}
+	  add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
 	}
-	
-	Ship::calculate();
+      if(shockingFrames == 2000 )
+	{
+	  tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+	  tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
+
+	  add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
+	}
+      if(shockingFrames == 1500 )
+	{
+	  tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+	  tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
+	  
+	  add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
+	}
+      if(shockingFrames == 1000 )
+	{
+	  tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+	  tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
+	  
+	  add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
+	}
+      if(shockingFrames == 500 )
+	{
+	  tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+	  tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
+	  
+	  add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
+	}
+      if(shockingFrames == 50 )
+	{
+	  tw_sound->stop_sound(data_full_path(data->sampleSpecial[1]));
+	  tw_sound->play_sound(data_full_path(data->sampleSpecial[1]));
+	  
+	  add( new ForevianShockwave(0, 70, angle , specialVelocity, specialDamage, 
+				     specialRange, specialArmour, this, this, special_sprite, 
+				     special_frame_num, special_frame_size, specialLoss));
+	  
+	  shockingFrames = 0;
+	  shockVar = 0;
+	  recharge_amount = 1;
+	}
+    }
+  
+  Ship::calculate();
 }
 
-ForevianShockwave::ForevianShockwave(double ox, double oy, double oangle, double ov, int odamage, double orange, int oarmour, Ship *oship, SpaceLocation *opos, SpaceSprite *osprite, int ofcount, int ofsize, int ol) :
-	AnimatedShot(oship, Vector2(ox,oy), oangle, ov, odamage, orange, oarmour, oship, osprite, ofcount, ofsize)
-{ 
-	collide_flag_anyone = OBJECT_LAYERS&~bit(LAYER_SHOTS);
-	collide_flag_sameship = collide_flag_anyone;
-	last_hit = oship;
-	loss = ol;
+ForevianShockwave::ForevianShockwave(double ox, double oy, double oangle, double ov, 
+				     int odamage, double orange, int oarmour, Ship *oship, 
+				     SpaceLocation *opos, SpaceSprite *osprite, int ofcount, 
+				     int ofsize, int ol) :
+  AnimatedShot(oship, Vector2(ox,oy), oangle, ov, odamage, orange, 
+	       oarmour, oship, osprite, ofcount, ofsize)
+{
+  STACKTRACE; 
+  collide_flag_anyone = OBJECT_LAYERS&~bit(LAYER_SHOTS);
+  collide_flag_sameship = collide_flag_anyone;
+  last_hit = oship;
+  loss = ol;
 }
 
 void ForevianShockwave::inflict_damage(SpaceObject *other)
-{	
-	STACKTRACE
-	if (other==last_hit)
-		return;
-	play_sound2(data->sampleSpecial[2]);
-	if (!other->sameShip(this))
-		damage(other, 0, damage_factor);
-	add( new Animation(this, pos, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
-	if ((damage_factor-=loss) <= 0) {
-		die(); return; }
+{
+  STACKTRACE;	
+  if (other==last_hit)
+    return;
+  
+  tw_sound->stop_sound(data_full_path(data->sampleSpecial[2]));
+  tw_sound->play_sound(data_full_path(data->sampleSpecial[2]));
+	  
+  if (!other->sameShip(this))
+    damage(other, 0, damage_factor);
+  add( new Animation(this, pos, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
+  if ((damage_factor-=loss) <= 0) 
+    {
+      die(); return; 
+    }
 	
-	last_hit=other;
+  last_hit=other;
 
-	Query q;
-	double r0=1e40;
-	SpaceObject *tgt = NULL;
-	for (q.begin(this, OBJECT_LAYERS&~bit(LAYER_SHOTS), range-d); q.currento; q.next()) {
-		if ((q.currento==last_hit) || q.currento->isPlanet() || !(q.currento->canCollide(this)&&canCollide(q.currento)) ) continue;	if (distance(q.currento)<r0) {
-			tgt = q.currento;
-			r0 = distance(tgt); } }
-	q.end();
+  Query q;
+  double r0=1e40;
+  SpaceObject *tgt = NULL;
+  for (q.begin(this, OBJECT_LAYERS&~bit(LAYER_SHOTS), range-d); q.currento; q.next()) 
+    {
+      if ((q.currento==last_hit) || q.currento->isPlanet() || 
+	  !(q.currento->canCollide(this)&&canCollide(q.currento)) ) 
+	continue;	
+      if (distance(q.currento)<r0) 
+	{
+	  tgt = q.currento;
+	  r0 = distance(tgt); 
+	} 
+    }
+  q.end();
 
-	if (tgt)
-		changeDirection(trajectory_angle(tgt));
+  if (tgt)
+    changeDirection(trajectory_angle(tgt));
 
-	return;
+  return;
 }
 
 

Modified: branches/multiplayer-branch/source/ships/shpgarty.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpgarty.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shpgarty.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -17,8 +17,6 @@
 
 #include "ship.h"
 
-REGISTER_FILE
-
 class GarashTyrant : public Ship {
   double       weaponVelocity;
   int          weaponDamage;
@@ -118,6 +116,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
 	weaponDamage					 = get_config_int("Weapon", "Damage", 8);
 	weaponArmour					 = get_config_int("Weapon", "Armour", 8);
@@ -147,7 +146,7 @@
 
 void GarashTyrant::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 if (!fire_weapon  &&
 		!fire_special &&
@@ -227,7 +226,7 @@
 }
 
 void GarashTyrant::stun_ship(SpaceObject *other){
-	STACKTRACE
+  STACKTRACE;
   GarashRepulsarStun* GRS;
   if (other->state==0) return;
 	if (other->isShip()) {
@@ -244,7 +243,7 @@
 
 void GarashTyrant::calculate_fire_weapon()
 	{
-	STACKTRACE
+  STACKTRACE;
 	weapon_low = FALSE;
 
 	if (fire_weapon) {
@@ -270,7 +269,7 @@
 
 int GarashTyrant::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
   if(weaponObject)
     return(FALSE);
 
@@ -283,6 +282,7 @@
 }
 
 int GarashTyrant::activate_special() {
+  STACKTRACE;
 
 	repulse = true;
 
@@ -296,6 +296,7 @@
   ship(oship), stunframe(0), stunframe_count(stunFrames),
   frame_step(0), frame_size(ofsize), frame_count(ofcount)
 {
+  STACKTRACE;
   targetIsDead = FALSE;
 	collide_flag_anyone = 0;
 	layer = LAYER_EXPLOSIONS;
@@ -303,7 +304,7 @@
 }
 
 void GarashRepulsarStun::calculate() {
-	STACKTRACE
+  STACKTRACE;
   if(!ship) targetIsDead = TRUE;
   else {
     if(!ship->exists()) targetIsDead = TRUE;
@@ -362,6 +363,7 @@
 	CD(oChargingDistance),
 	CDD(oChargingDistanceDamage)
 {
+  STACKTRACE;
 	  vel = ship->get_vel();
 
 	Timer  = 0;
@@ -378,144 +380,159 @@
 
 }
 
-void GarashShot::calculate() {
-	STACKTRACE
+void GarashShot::calculate() 
+{
+  STACKTRACE;
+  if(released) 
+    Shot::calculate();
+  else SpaceObject::calculate();
+  
+  if (!exists()) 
+    return;
 
-	if(released) Shot::calculate();
-	else SpaceObject::calculate();
+  if (!done_once)
+    {
+      tw_sound->play_sound(data_full_path(data->sampleExtra[0])); //charge
+      done_once=TRUE;
+    }
 
-	if (!exists()) return;
-
-	if (!done_once)
-		{
-			play_sound(data->sampleExtra[0]); //charge
-			done_once=TRUE;
-		}
-
-
-	frame_step += frame_time;
-	if(frame_step >= frame_size) { //1
-		frame_step -= frame_size;
-		frame++;
-		if(frame == frame_count) { //2
-			frame = 0;
-
-			if(!released)  { //3
-				charge_frame++;
-				if(charge_frame == 5) { //4
-			    play_sound(data->sampleExtra[0]); //charge
-					charge_frame = 0;
-					charge_phase++;
-					damage_factor += Charge;
-					armour += Charge;
-					range  += scale_range(Charge);
-					} //4
-				} //3
-			} //2
-		} //1
-
-	if(!released) {
-
-		if (!ship || !ship->fire_weapon || Timer > MaxTL) {
-			vel = unit_vector(angle) * v;
-			released = TRUE;
-			if (Timer > MinTL)
-				play_sound(data->sampleWeapon[0]); //shoot
-			}
-		else {
-			angle = ship->get_angle();
-			pos = ship->normal_pos() + unit_vector(angle) * ship->size.y/2.6;
-			vel = ship->get_vel();
-		}
-
-		StartC = pos;
-
-		if (ship)
-			{ int sprite_phase = charge_phase;
-		  if (sprite_phase > 2)	sprite_phase = 2;
-			sprite_index = (get_index(ship->get_angle()) +
-										 (sprite_phase * 64));
-			}
-		 else released = TRUE;
-
-
-
-			Timer += frame_time;
-		} else if (Timer < MinTL) {
-		    released=TRUE;
-				sound.stop(data->sampleExtra[0]);
-				play_sound2(data->sampleExtra[1]); //cancel if less than min time limit
-				state=0;
-				}
-
-
-	return;
+  frame_step += frame_time;
+  if(frame_step >= frame_size) 
+    { 
+      frame_step -= frame_size;
+      frame++;
+      if(frame == frame_count) 
+	{ 
+	  frame = 0;
+	  
+	  if(!released)  
+	    { 
+	      charge_frame++;
+	      if(charge_frame == 5) 
+		{ 
+		  tw_sound->play_sound(data_full_path(data->sampleExtra[0])); //charge
+		  charge_frame = 0;
+		  charge_phase++;
+		  damage_factor += Charge;
+		  armour += Charge;
+		  range  += scale_range(Charge);
+		} 
+	    } 
+	} 
+    }
+  
+  if(!released) 
+    {
+      
+      if (!ship || !ship->fire_weapon || Timer > MaxTL) 
+	{
+	  vel = unit_vector(angle) * v;
+	  released = TRUE;
+	  if (Timer > MinTL)
+	    {
+	      tw_sound->play_sound(data_full_path(data->sampleWeapon[0])); //shoot
+	    }
 	}
+      else 
+	{
+	  angle = ship->get_angle();
+	  pos = ship->normal_pos() + unit_vector(angle) * ship->size.y/2.6;
+	  vel = ship->get_vel();
+	}
+      
+      StartC = pos;
+      
+      if (ship)
+	{ 
+	  int sprite_phase = charge_phase;
+	  if (sprite_phase > 2)	
+	    sprite_phase = 2;
+	  sprite_index = (get_index(ship->get_angle()) +
+			  (sprite_phase * 64));
+	}
+      else released = TRUE;
+      
+      Timer += frame_time;
+    } 
+  else if (Timer < MinTL) 
+    {
+      released=TRUE;
+      tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
+      tw_sound->stop_sound(data_full_path(data->sampleExtra[1])); //cancel if less than min time limit
+      tw_sound->play_sound(data_full_path(data->sampleExtra[1])); //cancel if less than min time limit
+      
+      state=0;
+    }
+    
+  return;
+}
 
 void GarashShot::animateExplosion()
 {
-	return;
+  STACKTRACE;
+  return;
 }
 
 void GarashShot::inflict_damage(SpaceObject *other)
-	{
-	STACKTRACE
+{
+  STACKTRACE;
+  int Distance_Travelled = iround(distance_from(StartC, other->normal_pos()));
+  int AddDamage = iround((Distance_Travelled / CD) * CDD);
+  
+  
+  if (!ship_hit || !released)
+    damage (other ,damage_factor + AddDamage);
+  
+  if (!other->isShip() &&
+      !other->isPlanet() && other->exists())
+    other->die();
+  
+  if (other->isShip()) 
+    {
+      ship_hit=TRUE;
+      if (other->mass > 20 || !released)
+	state=0;
+    }
+  else 
+    ship_hit=FALSE;
+  
+  if (other->isShip() && other->mass > 0) 
+    {
+      animateExplosion();
+      soundExplosion();
+    }
 
-	int Distance_Travelled = iround(distance_from(StartC, other->normal_pos()));
-	int AddDamage = iround((Distance_Travelled / CD) * CDD);
+  if (other->mass <= 0) 
+    return;
+  
+  if(other->isShip())
+    add(new FixedAnimation(this, other,
+			   explosionSprite, 0, explosionFrameCount,
+			   explosionFrameSize, LAYER_EXPLOSIONS));
+  
+  else
+    add(new Animation(this, pos,
+		      explosionSprite, 0, explosionFrameCount,
+		      explosionFrameSize, LAYER_EXPLOSIONS));
+  return;
+}
 
 
-	if (!ship_hit || !released)
-	  damage (other ,damage_factor + AddDamage);
-
-	if (!other->isShip() &&
-		  !other->isPlanet() && other->exists())
-			other->die();
-
-
-	if (other->isShip()) {
-		ship_hit=TRUE;
-		if (other->mass > 20 || !released)
-			 state=0;
-		}
-	 else ship_hit=FALSE;
-
-
-	if (other->isShip() && other->mass > 0) {
-		animateExplosion();
-		soundExplosion();
-	}
-
-		if (other->mass <= 0) return;
-
-		if(other->isShip())
-			add(new FixedAnimation(this, other,
-				explosionSprite, 0, explosionFrameCount,
-				explosionFrameSize, LAYER_EXPLOSIONS));
-
-		else
-			add(new Animation(this, pos,
-				explosionSprite, 0, explosionFrameCount,
-				explosionFrameSize, LAYER_EXPLOSIONS));
-		return;
-	}
-
-
-
 int GarashShot::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE
-	armour += damage_factor + direct ; // nullify damage
-	if (((!ship_hit && !source->isShip()) ||
-			(ship_hit && source->isShip())) && !released)
-			play_sound(data->sampleExtra[2]);
-	Shot::handle_damage(source, normal, direct);
-	return 0;
+  STACKTRACE;
+  armour += damage_factor + direct ; // nullify damage
+  if (((!ship_hit && !source->isShip()) ||
+       (ship_hit && source->isShip())) && !released)
+    tw_sound->play_sound(data_full_path(data->sampleExtra[2]));
+  Shot::handle_damage(source, normal, direct);
+  return 0;
 }
 
 int GarashShot::canCollide(SpaceLocation *other)
-	{
-		return(TRUE);
-	}
+{
+  STACKTRACE;
+  return(TRUE);
+}
 REGISTER_SHIP(GarashTyrant)
-
+  

Modified: branches/multiplayer-branch/source/ships/shpilwsp.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpilwsp.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shpilwsp.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 #include "shpilwsp.h"
 
@@ -83,6 +82,7 @@
 		ShipData *shipData, unsigned int code) :
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange       = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity    = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -99,7 +99,7 @@
 
 int IlwrathSpider::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
   game->add( new AnimatedShot( this, Vector2(size.x*0.12, size.y*0.35),
     angle + weaponAngle, weaponVelocity, weaponDamage, weaponRange, weaponArmour, this,
     data->spriteWeapon, data->spriteWeapon->frames(), ILWRATH_FIRE_ANIM_RATE, 1 ));
@@ -112,7 +112,7 @@
 
 int IlwrathSpider::activate_special()
 {
-	STACKTRACE;
+  STACKTRACE;
     double alpha = specialSpread / specialNumber;
     double beta = normalize( angle + PI - 0.5 * specialSpread + random(alpha), PI2 );
     double tx = cos( angle );
@@ -131,13 +131,13 @@
 
 void IlwrathSpider::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
     Ship::calculate();
 }
 
 void IlwrathSpiderMine::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
   double alpha = (-10 + random(21)) * ANGLE_RATIO;
   alpha *= randomness;
   angle += alpha * frame_time;
@@ -170,75 +170,96 @@
 
 void IlwrathSpiderMine::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
-    state = 0;
-
-    int freq;
-    if( other->isShot() ){
-        freq = (int)(magnitude_sqr(other->get_vel())*2000.0);
-    }else{
-        freq = 2000 - 80*(int)other->mass;
+  STACKTRACE;
+  state = 0;
+  
+  int freq;
+  if( other->isShot() )
+    {
+      freq = (int)(magnitude_sqr(other->get_vel())*2000.0);
     }
-    play_sound2( data->sampleExtra[0], 512, freq<500?500:freq );
-    game->add( new FixedAnimation( this, other, data->spriteExtra, 0, data->spriteExtra->frames(), time_ratio, LAYER_EXPLOSIONS ));
+  else
+    {
+      freq = 2000 - 80*(int)other->mass;
+    }
 
-    if( other->vel != 0 ){
-		other->vel = 0;
-        if( other->isShip() ) ((Ship*)other)->nextkeys &= ~(keyflag::thrust | keyflag::left | keyflag::right);
-
-        game->add( new IlwrathStop( this, other, stoptime ));
+  tw_sound->stop_sound(data_full_path(data->sampleExtra[0]));
+  tw_sound->play_sound(data_full_path(data->sampleExtra[0])); 
+  game->add( new FixedAnimation( this, other, data->spriteExtra, 0, 
+				 data->spriteExtra->frames(), time_ratio, LAYER_EXPLOSIONS ));
+  
+  if( other->vel != 0 )
+    {
+      other->vel = 0;
+      if( other->isShip() ) ((Ship*)other)->nextkeys &= ~(keyflag::thrust | 
+							  keyflag::left | keyflag::right);
+      game->add( new IlwrathStop( this, other, stoptime ));
     }
 }
 
-IlwrathSpiderMine::IlwrathSpiderMine( SpaceLocation *creator, double ox, double oy, double oangle, double v, int olife, double orandomness, int ostoptime, SpaceSprite* osprite ):
+IlwrathSpiderMine::IlwrathSpiderMine( SpaceLocation *creator, double ox, double oy, double oangle, 
+				      double v, int olife, double orandomness, int ostoptime, 
+				      SpaceSprite* osprite ):
   SpaceObject( creator, Vector2(ox,oy), oangle, osprite ),
   step( 0 ), life( olife ), inc( 1 ),
   randomness( orandomness ), stoptime( ostoptime )
 {
-	  layer = LAYER_SPECIAL;
-	vel = unit_vector(angle) * v;
+  STACKTRACE;
+  layer = LAYER_SPECIAL;
+  vel = unit_vector(angle) * v;
 }
 
 IlwrathStop::IlwrathStop( SpaceLocation* creator, SpaceObject* ovictim, int olife ):
   SpaceLocation( creator, 0, 0 ),
   victim( ovictim ), life( olife )
 {
-  if( victim ){
-    if( !victim->exists() ){
-      victim = 0;
-      state = 0;
-    }else{
-      if( victim->isShot() ){
-        old_v = ((Shot*)victim)->v;
-        ((Shot*)victim)->v = 0;
-      }else{
-        old_v = 0;
-      }
+  STACKTRACE;
+  if( victim )
+    {
+      if( !victim->exists() )
+	{
+	  victim = 0;
+	  state = 0;
+	}
+      else
+	{
+	  if( victim->isShot() )
+	    {
+	      old_v = ((Shot*)victim)->v;
+	      ((Shot*)victim)->v = 0;
+	    }
+	  else
+	    {
+	      old_v = 0;
+	    }
+	}
     }
-  }
 }
 
 void IlwrathStop::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
   SpaceLocation::calculate();
   if( !(victim && victim->exists()) )
-  {
-    victim = 0;
-    state = 0;
-    return;
-  }
-  if( victim->isShip() ) ((Ship*)victim)->nextkeys &= ~(keyflag::thrust | keyflag::left | keyflag::right);
+    {
+      victim = 0;
+      state = 0;
+      return;
+    }
+  if( victim->isShip() ) 
+    ((Ship*)victim)->nextkeys &= ~(keyflag::thrust | keyflag::left | keyflag::right);
   victim->vel = 0;
-
+  
   life -= frame_time;
-  if( life <= 0 ){
-    state = 0;
-    if( victim->isShot() ){
-      ((Shot*)victim)->v = old_v;
+  if( life <= 0 )
+    {
+      state = 0;
+      if( victim->isShot() )
+	{
+	  ((Shot*)victim)->v = old_v;
 	  victim->vel = old_v * unit_vector(victim->get_angle());
+	}
     }
-  }
 }
 
 REGISTER_SHIP(IlwrathSpider)

Modified: branches/multiplayer-branch/source/ships/shpkahbo.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpkahbo.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shpkahbo.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 #include "melee/mmain.h"
 
@@ -142,6 +141,7 @@
 	:
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   weapon1Range    = scale_range(get_config_float("WeaponS", "Range", 0));
   weapon1Turn     = scale_turning(get_config_float("WeaponS","Turn", 0));
   weapon1Velocity = scale_velocity(get_config_float("WeaponS", "Velocity", 0));
@@ -175,7 +175,7 @@
 
 int KahrBoomerang::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
   int chance;
   int answer = FALSE;
   if (weaponChoice == SMALL_BOOMERANG) {
@@ -210,7 +210,7 @@
 
 int KahrBoomerang::activate_special()
 {
-	STACKTRACE
+  STACKTRACE;
   int answer;
   if (weaponChoice == SMALL_BOOMERANG) {
     weapon_drain = weapon2Drain;
@@ -233,7 +233,7 @@
 
 void KahrBoomerang::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
   if ((boomerangL != NULL) && (!boomerangL->exists()))
     boomerangL=NULL;
   Ship::calculate();
@@ -249,7 +249,7 @@
 
 void KahrBoomerang::calculate_fire_special()
 {
-	STACKTRACE
+  STACKTRACE;
   if (weaponChoice == SMALL_BOOMERANG) {
     blit(this->spritePanel->get_bitmap(7), this->spritePanel->get_bitmap(1), 36, 0, 36, 0, 19, 30);
     blit(this->spritePanel->get_bitmap(7), this->spritePanel->get_bitmap(2), 36, 0, 36, 0, 19, 30);
@@ -280,6 +280,7 @@
 	Shot(oship, Vector2(ox,oy), oangle, ov, odamage, -1.0 , oarmour, oship, osprite)
 
 {
+  STACKTRACE;
   mass = 0.25;
   frame = 0;
   frame_step = 0;
@@ -294,7 +295,7 @@
 
 void KahrSmall::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	if (!(ship && ship->exists()))
 	{
 		state = 0;
@@ -335,7 +336,7 @@
 
 void KahrSmall::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 	if (other == ship) {
 		state = 0;
 		mass = 0;
@@ -354,6 +355,7 @@
 	Shot(oship, Vector2(ox,oy), oangle, ov, odamage, -1.0 , oarmour, oship, osprite)
 
 {
+  STACKTRACE;
   mass = 3.0;
   frame = 0;
   frame_step = 0;
@@ -369,13 +371,13 @@
 }
 
 void KahrMedium::death() {
-	STACKTRACE;
+  STACKTRACE;
 	if (kahrship) (kahrship)->num_medium_boomerangs -= 1;
 	Shot::death();
 	}
 
 void KahrMedium::calculate() {
-	STACKTRACE
+  STACKTRACE;
 	if (!(ship && ship->exists()))
 	{
 		state = 0;
@@ -419,7 +421,7 @@
 
 void KahrMedium::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 	if (other == ship) {
 		state = 0;
 		mass = 0;
@@ -438,6 +440,7 @@
 	Shot(oship, Vector2(ox,oy), oangle, ov, odamage, -1.0 , oarmour, oship, osprite)
 
 {
+  STACKTRACE;
   mass =5.0;
   frame = 0;
   frame_step = 0;
@@ -452,7 +455,7 @@
 
 void KahrLarge::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	if (!(ship && ship->exists()))
 	{
 		state = 0;
@@ -491,7 +494,7 @@
 
 void KahrLarge::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 	if (other == ship) {
 		state = 0;
 		mass = 0;
@@ -506,7 +509,7 @@
 
 int KahrLarge::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE
+  STACKTRACE;
   return Shot::handle_damage(source, 0, 0);
 }
 

Modified: branches/multiplayer-branch/source/ships/shprogsq.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shprogsq.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shprogsq.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -15,8 +15,8 @@
 GNU General Public License for more details.
 */
 
+#include "util/sound.h"
 #include "ship.h"
-REGISTER_FILE
 
 #include "util/aastr.h"
 
@@ -24,8 +24,8 @@
 #include <stdio.h>
 
 #include "melee/mview.h"
+#include "scp.h"
 
-
 /*
 rogsc
 
@@ -144,6 +144,7 @@
 :
 Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 	
 	weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
 	weaponDamage   = get_config_int("Weapon", "Damage", 0);
@@ -215,7 +216,7 @@
 // This is called just before the first calculate(), after the ship phases into battle
 void RogueSquadron::materialize()
 {
-	STACKTRACE
+  STACKTRACE;
 	int i;
 
 	formation = 0;
@@ -266,6 +267,7 @@
 
 int RogueSquadron::activate_weapon()
 {
+  STACKTRACE;
 	// all ships fire a pulse laser:
 	fire_main = 1;
 	return TRUE;
@@ -274,8 +276,7 @@
 
 int RogueSquadron::activate_special()
 {
-
-	STACKTRACE
+  STACKTRACE;
 	int	i;
 
 	// first of all, clean up the old formation.
@@ -324,8 +325,8 @@
 
 
 void RogueSquadron::calculate()
-{	
-	STACKTRACE
+{
+  STACKTRACE;
 	fire_main = 0;	// reset this first.
 
 	int i;
@@ -440,7 +441,7 @@
 
 void RogueSquadron::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 	int a;
 	a = aa_get_trans();
 	aa_set_trans(100);
@@ -452,6 +453,7 @@
 
 int RogueSquadron::handle_damage(SpaceLocation* source, double normal, double direct)
 {
+  STACKTRACE;
 	// the Syreen, and maybe other area-effect weapons, can do damage to
 	// the virtual ship, which I don't want. So, I'll disable all damage
 	// taking by this ship
@@ -463,6 +465,7 @@
 
 void RogueSquadron::calculate_hotspots()
 {
+  STACKTRACE;
 	// do nothing: no hotspots for this virtual thing
 }
 
@@ -472,6 +475,7 @@
 :
 Ship(creator, creator->pos, creator->angle, osprite)
 {
+  STACKTRACE;
 	mother = creator;
 	pos = mother->pos;
 
@@ -502,7 +506,7 @@
 
 SpaceObject* RogueFighter::nearest_location()
 {
-	STACKTRACE
+  STACKTRACE;
 	SpaceObject *p = NULL;
 	double r = 99999999;
 	Query q;
@@ -526,7 +530,7 @@
 // should be added to SpaceLocation I think !
 void RogueFighter::avoid_location(SpaceObject *o)
 {
-	STACKTRACE
+  STACKTRACE;
 	double t_a = trajectory_angle(o);
 	double d_a = normalize(t_a - angle, PI2);
 	
@@ -548,7 +552,7 @@
 
 void RogueFighter::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	if ( !(mother && mother->exists()) )
 	{
 		state = 0;
@@ -639,7 +643,7 @@
 
 int RogueFighter::handle_damage(SpaceLocation* source, double normal, double direct)
 {
-	STACKTRACE
+  STACKTRACE;
 	if (!state)
 		return 0;	// to avoid an infinite feedback with enemy rogue.
 
@@ -668,11 +672,11 @@
 
 	if ( !state )
 	{
-		// this ship dies :(
-		play_sound((SAMPLE *)(melee[MELEE_BOOMSHIP].dat));
-		game->add(new Animation(this, pos, meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS));
+	  tw_sound->play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
+	  game->add(new Animation(this, pos, game->meleedata.kaboomSprite, 0, 
+				  KABOOM_FRAMES, time_ratio, DEPTH_EXPLOSIONS));
 	}
-
+	
 	return total;
 }
 
@@ -689,6 +693,7 @@
   lpos(opos),
   rel_pos(rpos)
 {
+  STACKTRACE;
 
 // angle conventions fucked up??
 	rel_pos.x *= -1;
@@ -708,7 +713,7 @@
 
 
 void PulseLaser::calculate() {
-	STACKTRACE
+  STACKTRACE;
 	if((frame < frame_count) && (lpos->exists())) {
 //		pos = lpos->normal_pos() + rotate(rel_pos, lpos->get_angle() - PI/2);
 //		vel = lpos->get_vel();
@@ -722,18 +727,37 @@
 
 void PulseLaser::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
-	// copied from space_line:
-	int i;
-	i = iround_down(damage_factor / 2);
-	if(i >= BOOM_SAMPLES)
-		i = BOOM_SAMPLES - 1;
-	play_sound((SAMPLE *)(melee[MELEE_BOOM + i].dat));
-	damage(other, damage_factor);
+  STACKTRACE;
+  // copied from space_line:
+  int i;
+  i = iround_down(damage_factor / 2);
+  if(i >= BOOM_SAMPLES)
+    i = BOOM_SAMPLES - 1;
 
-	state = 0;	// this is different from space_line :)
-	return;
-	}
+  switch(i)
+    {
+    case 0:
+      tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND1));
+      break;
+    case 1:
+      tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND2));
+      break;
+    case 2:
+      tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND3));
+      break;
+    case 3:
+      tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND4));
+      break;
+    default:
+      {
+	tw_error("Unknown BOOM sound");
+      }
+    }
+  damage(other, damage_factor);
+  
+  state = 0;	// this is different from space_line :)
+  return;
+}
 
 
 REGISTER_SHIP ( RogueSquadron )

Modified: branches/multiplayer-branch/source/ships/shpstaba.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpstaba.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shpstaba.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 class StarBase : public Ship {
   double       weaponRange;
@@ -49,6 +48,7 @@
 	:
 	Ship(opos, angle, data, code)
 	{
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -68,7 +68,7 @@
 }
 
 int StarBase::activate_weapon() {
-	STACKTRACE
+  STACKTRACE;
    
 	double a;
 	if (target) {
@@ -97,7 +97,7 @@
 }
 
 int StarBase::activate_special() {
-	STACKTRACE
+  STACKTRACE;
   int fire = FALSE;
   SpaceObject *o;
 
@@ -114,51 +114,60 @@
                                 l->set_depth(LAYER_EXPLOSIONS); }
 			}
 		}
-	if (fire) play_sound((SAMPLE *)(melee[MELEE_BOOM + 0].dat));
+	if (fire) 
+	  {
+	    tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND1));
+	  }
 
 	return(fire);
 	}
 
-void StarBase::calculate() {
-	STACKTRACE
-
+void StarBase::calculate() 
+{
+  STACKTRACE;
   int fire = FALSE;
   Ship *o;
 
-	Query a;
-	for (a.begin(this, bit(LAYER_SHIPS), HealRange); a.current; a.next()) {
-		o = (Ship *)a.currento;
-		if((!o->isInvisible()) && o->sameTeam(this))
-		{
-			if((random()%HealRate)!=0) continue;
-			if(batt<HealCost) continue;
-			if(o->crew==o->crew_max) continue;
-			batt-=HealCost;
-			SpaceLocation *l = new PointLaser(this, pallete_color[HealColor], -1,
-					specialFrames, this, o, Vector2(0.0, 10.0));
-			game->add(l);
-			if (l->exists())
-			{
-                                fire = TRUE;
-                                l->set_depth(LAYER_EXPLOSIONS); }
-			}
-		}
-	if (fire) play_sound((SAMPLE *)(melee[MELEE_BOOM + 0].dat));
-
-	Ship::calculate();
+  Query a;
+  for (a.begin(this, bit(LAYER_SHIPS), HealRange); a.current; a.next()) {
+    o = (Ship *)a.currento;
+    if((!o->isInvisible()) && o->sameTeam(this))
+      {
+	if((random()%HealRate)!=0) continue;
+	if(batt<HealCost) continue;
+	if(o->crew==o->crew_max) continue;
+	batt-=HealCost;
+	SpaceLocation *l = new PointLaser(this, pallete_color[HealColor], -1,
+					  specialFrames, this, o, Vector2(0.0, 10.0));
+	game->add(l);
+	if (l->exists())
+	  {
+	    fire = TRUE;
+	    l->set_depth(LAYER_EXPLOSIONS); }
+      }
+  }
+  if (fire) 
+    {
+      tw_sound->play_sound(data_full_path(MELEE_BOOM_SOUND1));
+    }
+  
+  Ship::calculate();
 }   
 
 int StarBase::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE
-		  batt -= normal;
-        if (batt < 0) {
-                normal = -batt;
-                batt = 0; }
-        else    normal = 0;
-        return Ship::handle_damage(source, normal, direct);
+  STACKTRACE;
+  batt -= normal;
+  if (batt < 0) 
+    {
+      normal = -batt;
+      batt = 0; 
+    }
+  else    normal = 0;
+  return Ship::handle_damage(source, normal, direct);
 }
 
-void StarBase::calculate_gravity() {}
+void StarBase::calculate_gravity() {
+  STACKTRACE;}
 
 REGISTER_SHIP ( StarBase )

Modified: branches/multiplayer-branch/source/ships/shptauar.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shptauar.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shptauar.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -24,8 +24,6 @@
 #include "melee/mcbodies.h"
 
 
-REGISTER_FILE
-
 void TauArchonFreezeColorEffects (RGB *c)
 {
 STACKTRACE
@@ -122,6 +120,7 @@
 TauArchon::TauArchon(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code) :
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 	weaponChargeTime	= (int)(get_config_float("Weapon", "ChargeTime", 0) * 1000);
 	weapon_charge_counter	= 0;
 	weaponVelocity		= scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -169,6 +168,7 @@
 
 bool TauArchon::ShotTakeBatt()
 {
+  STACKTRACE;
 	if(numDamage_steps > 0)
 	{
 		bool bWhat2Do;
@@ -186,96 +186,92 @@
 
 void TauArchon::calculate()
 {
-STACKTRACE
-/* Removed by Jad at *Jumping Peppers*'s behest
-	recharge_rate = base_recharge_rate * (1 - batt / (double)batt_max);
-	if (recharge_rate <= frame_time)
-		recharge_rate = frame_time + 1;
-	if (recharge_rate <= 2*weapon_rate)
-		recharge_rate = 2*weapon_rate + 1;
-	recharge_amount = batt_max;
-*/
-	Ship::calculate();
+  STACKTRACE;
+  Ship::calculate();
 	
-	if ((fire_weapon || fire_special) && (batt >= weapon_drain/(double)special_drain)/* && (weapon_recharge <= 0)*/)
+  if ((fire_weapon || fire_special) && 
+      (batt >= weapon_drain/(double)special_drain))
+    {
+      weapon_charge_counter += frame_time;
+      if (weapon_charge_counter > weaponChargeTime)
+	weapon_charge_counter = weaponChargeTime;
+    }
+  else 
+    {
+      if(bCoolDownThenCharge)
+	recharge_amount = 0;
+      weapon_charge_counter -= frame_time;
+      if (weapon_charge_counter < 0)
 	{
-		weapon_charge_counter += frame_time;
-		if (weapon_charge_counter > weaponChargeTime)
-			weapon_charge_counter = weaponChargeTime;
-//		recharge_step = recharge_rate;
+	  weapon_charge_counter = 0;
+	  if(bCoolDownThenCharge)
+	    recharge_amount = orig_amount;
 	}
-	else 
-	{
-		if(bCoolDownThenCharge)
-			recharge_amount = 0;
-		weapon_charge_counter -= frame_time;
-		if (weapon_charge_counter < 0)
-		{
-			weapon_charge_counter = 0;
-			if(bCoolDownThenCharge)
-				recharge_amount = orig_amount;
-		}
-	}
-
-	if (weapon_sound_timer > 0)
-		weapon_sound_timer -= frame_time;
-
-	return;
+    }
+  
+  if (weapon_sound_timer > 0)
+    weapon_sound_timer -= frame_time;
+  
+  return;
 }
 
 
 void TauArchon::calculate_fire_weapon()
 {
-STACKTRACE
-	weapon_low = FALSE;
+  STACKTRACE;
+  weapon_low = FALSE;
 
-	if ((fire_weapon || fire_special) && (weapon_charge_counter >= weaponChargeTime))
+ if ((fire_weapon || fire_special) && (weapon_charge_counter >= weaponChargeTime))
 
-		while (weapon_recharge <= 0)
-		{
-			
-			if (batt < weapon_drain/(double)special_drain)
-			{
-				weapon_low = true;
-				return; 
-			}
-
-			double rx = tw_random(-12.0, 12.0);
-			double ax = (rx/3.0) * ANGLE_RATIO;
-
-			game->add(new TauArchonShot(this, Vector2(rx/2,11), angle+ax,
-					weaponVelocity * tw_random(0.96, 1.08), weaponDamage,
-					weaponDamageMin, (fire_special?specialRange:weaponRange) * tw_random(0.77, 1.17),
-					weaponArmour, weaponFuelSap,
-					data->spriteWeapon, weaponDoFreeze,
-					fire_special?specialMaxDivergence:(-1),
-					weaponReactiveDamage, specialRangeLimiter));
-
-			batt -= (weapon_drain/(double)special_drain);//*0.9999;
-
-			if (batt < 0) 
-				batt = 0;
-
-			recharge_step = recharge_rate;
-
-			weapon_recharge += weapon_rate;
-
-			if (weapon_sound_timer <= 0) 
-			{
-				if (fire_special)
-					play_sound(data->sampleSpecial[0]);
-				else
-					play_sound(data->sampleWeapon[0]);
-				weapon_sound_timer = iround(weaponSoundTimer * tw_random(0.49, 1.63));
-			}
-		}
-	return;
+   while (weapon_recharge <= 0)
+     {
+       
+       if (batt < weapon_drain/(double)special_drain)
+	 {
+	   weapon_low = true;
+	   return; 
+	 }
+       
+       double rx = tw_random(-12.0, 12.0);
+       double ax = (rx/3.0) * ANGLE_RATIO;
+       
+       game->add(new TauArchonShot(this, Vector2(rx/2,11), angle+ax,
+				   weaponVelocity * tw_random(0.96, 1.08), weaponDamage,
+				   weaponDamageMin, (fire_special?specialRange:weaponRange) * tw_random(0.77, 1.17),
+				   weaponArmour, weaponFuelSap,
+				   data->spriteWeapon, weaponDoFreeze,
+				   fire_special?specialMaxDivergence:(-1),
+				   weaponReactiveDamage, specialRangeLimiter));
+       
+       batt -= (weapon_drain/(double)special_drain);//*0.9999;
+       
+       if (batt < 0) 
+	 batt = 0;
+       
+       recharge_step = recharge_rate;
+       
+       weapon_recharge += weapon_rate;
+       
+       if (weapon_sound_timer <= 0) 
+	 {
+	   if (fire_special)
+	     {
+	       tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
+	     }
+	   else
+	     {
+	       tw_sound->play_sound(data_full_path(data->sampleWeapon[0]));
+	     }
+	   weapon_sound_timer = iround(weaponSoundTimer * tw_random(0.49, 1.63));
+	 }
+     }
+ return;
 }
 
 
 void TauArchon::calculate_fire_special()
 {
-STACKTRACE
+  STACKTRACE;
 	special_low = false;
 	return;
 }
@@ -283,7 +279,7 @@
 
 void TauArchon::animate(Frame *space)
 {
-STACKTRACE
+  STACKTRACE;
 	int aa = get_tw_aa_mode();
 	if ((weapon_charge_counter > 0) && (aa & AA_BLEND) && !(aa & AA_NO_AA)) 
 	{
@@ -308,6 +304,7 @@
 /*	Removed by Jad
 RGB TauArchon::crewPanelColor(int k)
 {
+  STACKTRACE;
 	RGB c = {255, 255, 255};
 	return c;
 }
@@ -315,6 +312,7 @@
 
 RGB TauArchon::battPanelColor(int k)
 {
+  STACKTRACE;
 	RGB c = {85, 85, 255};
 	return c;
 }
@@ -322,7 +320,7 @@
 
 void TauArchon::calculate_hotspots()
 {
-STACKTRACE
+  STACKTRACE;
 	if((thrust) && (hotspot_frame <= 0)) {
 		game->add(new Animation( this, 
 				normal_pos() - unit_vector(angle) * 15,
@@ -341,11 +339,12 @@
 	Shot(creator, opos, oangle, ov, odamage, orange, oarmour, creator, osprite),
 	min_damage(omindamage), fuel_sap(ofsap)
 {
+  STACKTRACE;
 	do_reactive_damage = oreactive;
 	explosionSprite     = data->spriteWeaponExplosion;
 	explosionFrameCount = 10;
 	explosionFrameSize  = 50;
-	explosionSample = data->sampleWeapon[1+tw_random()%3];
+	//	explosionSample = data->sampleWeapon[1+tw_random()%3];
 	sprite_index = 80;
 
 	do_freeze = ofreeze;
@@ -385,7 +384,7 @@
 
 void TauArchonShot::calculate()
 {
-STACKTRACE
+  STACKTRACE;
 	Shot::calculate();
 
 	if (rotation_base) {
@@ -408,14 +407,14 @@
 
 void TauArchonShot::animate(Frame *space)
 {
-STACKTRACE
+  STACKTRACE;
 	if (exists())
 		sprite->animate(pos, index_base + (int)(19.89 * d / range), space);
 }
 
 void TauArchonShot::inflict_damage(SpaceObject *other)
 {
-STACKTRACE
+  STACKTRACE;
 	double d_f = damage_factor;
 
 	if (other->isShip()) 
@@ -475,15 +474,15 @@
 		image->type = DAT_RLE_SPRITE;
 		tmp = create_bitmap_ex( bitmap_color_depth( bmp ), bmp->w, bmp->h );
 		//void* old_color_effects = videosystem.color_effects;
-		void* old_color_effects = (void *)videosystem.color_effects; //added (void *) 7/1/2003 Culture20
-		videosystem.color_effects = TauArchonFreezeColorEffects;
+		void* old_color_effects = (void *)videosystem->color_effects; //added (void *) 7/1/2003 Culture20
+		videosystem->color_effects = TauArchonFreezeColorEffects;
 	//	videosystem.update_colors();
 		blit( bmp, tmp, 0, 0, 0, 0, bmp->w, bmp->h );
 		image->dat = get_rle_sprite( tmp );
 		SpaceSprite* frozen_sprite = new SpaceSprite( image, 1 );
 		destroy_bitmap( tmp );
 		//videosystem.color_effects = (void (__cdecl *)(struct RGB *))old_color_effects;
-		videosystem.color_effects = (void (*)(struct RGB *))old_color_effects; //removed __cdecl 7/1/2003 Culture20
+		videosystem->color_effects = (void (*)(struct RGB *))old_color_effects; //removed __cdecl 7/1/2003 Culture20
 	//	videosystem.update_colors();
 		delete image;
 		game->add(new TauArchonFrozen(this, other, frozen_sprite));
@@ -502,6 +501,7 @@
 TauArchonFrozen::TauArchonFrozen(SpaceLocation *creator, SpaceObject *source, SpaceSprite *osprite) :
 	Shot(creator, 0, source->get_angle(), 0, 0, 999, source->mass, source, osprite, 1.0)
 {
+  STACKTRACE;
 	collide_flag_anyone = collide_flag_sameteam = collide_flag_sameship = ALL_LAYERS;
 	ally_flag = 0;
 	mass = source->mass;
@@ -510,15 +510,21 @@
 	set_depth(source->get_depth());
 	attributes &= ~ATTRIB_SHOT;
 	old_vel = vel;
-	explosionSample = data->sampleExtra[tw_random()%4];
+
+	// explosionSample = data->sampleExtra[tw_random()%4]; replace to valid sound
+
 	exploded_already = false;
 
 	lifetime = 3000 + tw_random()%(15*60000);
 
 	if (tw_random()%2)
-		play_sound(data->sampleWeapon[4]);
+	  {
+	    tw_sound->play_sound(data_full_path(data->sampleWeapon[4]));
+	  }
 	else
-		play_sound(data->sampleWeapon[5]);
+	  {
+	    tw_sound->play_sound(data_full_path(data->sampleWeapon[5]));
+	  }
 }
 
 TauArchonFrozen::~TauArchonFrozen()
@@ -528,11 +534,12 @@
 
 void TauArchonFrozen::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
 }
 
 void TauArchonFrozen::calculate()
 {
-STACKTRACE
+  STACKTRACE;
 
 	Shot::calculate();
 	if (length(vel-old_vel) > scale_velocity(15+tw_random()%20))
@@ -545,7 +552,7 @@
 
 void TauArchonFrozen::animateExplosion()
 {
-	STACKTRACE
+  STACKTRACE;
 	if (!exploded_already) {
 		exploded_already = true;	
 		game->add(new Animation(this, normal_pos(),

Modified: branches/multiplayer-branch/source/ships/shptauda.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shptauda.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shptauda.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -20,8 +20,6 @@
 #include "melee/mview.h"
 #include "frame.h"
 
-REGISTER_FILE
-
 class TauDagger : public Ship
 {
 	double		weaponRange, weaponDamage, weaponFrameCount;
@@ -73,6 +71,7 @@
 TauDagger::TauDagger(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code) :
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
 	weaponRange			= scale_range(get_config_float("Weapon", "Range", 0));
 	weaponDamage		= get_config_float("Weapon", "Damage", 0);
@@ -88,14 +87,14 @@
 
 int TauDagger::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
 	game->add(new TauDaggerBeam(this, Vector2(0,30), weaponRange, weaponDamage, iround(weaponFrameCount), angle));
 	return true;
 }
 
 int TauDagger::activate_special()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	game->add(new TauDaggerShot(this, Vector2(0,55), angle, specialVelocity,
 			specialDamage, specialRange, specialArmour, data->spriteSpecial));
@@ -112,6 +111,7 @@
 	frame(0), frame_count(lfcount), lpos(creator), rel_pos(rpos)
 
 {
+  STACKTRACE;
 	if (ldamage <= 0) collide_flag_anyone = 0;
 	set_depth(DEPTH_SHOTS);
 	base_length = length;
@@ -131,7 +131,7 @@
 
 void TauDaggerBeam::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	if((frame < frame_count) && (lpos->exists())) {
 		length = base_length;
 		pos = lpos->normal_pos() + rotate(rel_pos, lpos->get_angle() - PI/2);
@@ -150,13 +150,13 @@
 
 void TauDaggerBeam::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 	damage(other, damage_factor*frame_time/frame_count);
 
 	int aa = get_tw_aa_mode();
 	if (!((aa & AA_BLEND) && (aa & AA_ALPHA) && (!got_spark) && !(aa & AA_NO_AA))) {
 		physics->add(new Animation( this, 
-				pos + edge(), meleedata.sparkSprite, 0, 
+				pos + edge(), game->meleedata.sparkSprite, 0, 
 				SPARK_FRAMES, 50, DEPTH_EXPLOSIONS));
 		got_spark = true; }
 
@@ -165,7 +165,7 @@
 
 void TauDaggerBeam::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 	int aa = get_tw_aa_mode();
 	SpaceLine::animate(space);
 	if ((aa & AA_BLEND) && (aa & AA_ALPHA) && !(aa & AA_NO_AA) && (length < base_length*0.9999) && (target)) {
@@ -182,10 +182,11 @@
 		double ov, double odamage, double orange, double oarmour, SpaceSprite *osprite) :
 	Missile(creator, opos, oangle, ov, odamage, orange, oarmour, creator, osprite)
 {
+  STACKTRACE;
 	explosionSprite     = data->spriteSpecialExplosion;
 	explosionFrameCount = 20;
 	explosionFrameSize  = 25;
-	explosionSample = data->sampleSpecial[1];
+	//	explosionSample = data->sampleSpecial[1];
 	s_ind = 0;
 
 	add(new Animation(this, pos, data->spriteExtra, 0, 10, 25, DEPTH_HOTSPOTS+0.25));
@@ -194,7 +195,7 @@
 
 void TauDaggerShot::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 	sprite->animate(pos, sprite_index + 64 * s_ind, space);
 	s_ind = (s_ind + 1) % 2;
 }

Modified: branches/multiplayer-branch/source/ships/shptaume.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shptaume.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shptaume.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -19,8 +19,6 @@
 #include "melee/mview.h"
 #include "frame.h"
 
-REGISTER_FILE
-
 class TauMercury : public Ship {
 	double	weaponRange, weaponVelocity, weaponRelativity;
 	double	weaponDamage, weaponArmour;
@@ -77,6 +75,7 @@
 TauMercury::TauMercury(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code) :
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 	weaponRange		= scale_range(get_config_float("Weapon", "Range", 0));
 	weaponVelocity	= scale_velocity(get_config_float("Weapon", "Velocity", 0));
     weaponDamage	= get_config_float("Weapon", "Damage", 0);
@@ -108,7 +107,7 @@
 
 int TauMercury::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
 	double da = (1-0.002*(random()%1001));
 	if (da >= 0)
 		da *= da;
@@ -123,7 +122,7 @@
 
 void TauMercury::calculate_turn_right()
 {
-	STACKTRACE
+  STACKTRACE;
 	if (turn_right) {
 		bank_position += bank_max * frame_time / bank_time;
 		if (!turn_lag)
@@ -132,7 +131,7 @@
 
 void TauMercury::calculate_turn_left()
 {
-	STACKTRACE
+  STACKTRACE;
 	if (turn_left) {
 		bank_position -= bank_max * frame_time / bank_time;
 		if (!turn_lag)
@@ -141,7 +140,7 @@
 
 void TauMercury::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	double vl;
 	bool locked_rail = false;
 
@@ -216,7 +215,7 @@
 
 int TauMercury::accelerate(SpaceLocation *source, double angle, double velocity, double max_speed)
 {
-	STACKTRACE
+  STACKTRACE;
 	double ov;
 	double nvs, nvl;
 
@@ -242,11 +241,12 @@
 
 void TauMercury::calculate_hotspots()
 {
-	STACKTRACE
+  STACKTRACE;
 	if((thrust) && (hotspot_frame <= 0)) {
 		game->add(new Animation( this, 
 				normal_pos() - unit_vector(angle) * 14,
-				meleedata.hotspotSprite, 0, HOTSPOT_FRAMES, time_ratio, DEPTH_HOTSPOTS));
+				game->meleedata.hotspotSprite, 0, HOTSPOT_FRAMES, 
+					 time_ratio, DEPTH_HOTSPOTS));
 		hotspot_frame += hotspot_rate; }
 	if (hotspot_frame > 0) hotspot_frame -= frame_time;
 	return;
@@ -254,11 +254,12 @@
 
 void TauMercury::calculate_thrust()
 {
+  STACKTRACE;
 }
 
 void TauMercury::calculate_fire_special()
 {
-	STACKTRACE
+  STACKTRACE;
 	special_low = FALSE;
 	if (!fire_special)
 		return;
@@ -303,14 +304,17 @@
 	AnimatedShot(creator, Vector2(ox,oy), oangle, ov, odamage, orange, oarmour, creator, osprite, 10, 50, relativity),
 	sparks(osparks), frags(ofrags)
 {
+  STACKTRACE;
 		if (frags)
-			explosionSample = data->sampleWeapon[1];
+		  {
+		    //			explosionSample = data->sampleWeapon[1];
+		  }
 }
 
 
 void TauMercuryShot::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	int si = sprite_index;
 	AnimatedShot::calculate();
 	
@@ -343,7 +347,7 @@
 
 void TauMercuryShot::animateExplosion()
 {
-	STACKTRACE
+  STACKTRACE;
 	if (!frags) {
 		Shot::animateExplosion();
 		return; }
@@ -389,7 +393,7 @@
 
 void TauMercurySpark::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	lifetime -= frame_time;
 	if (lifetime <= 0)
 		state = 0;
@@ -399,14 +403,14 @@
 
 void TauMercurySpark::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 	SpaceLine::inflict_damage(other);
 	state =0;
 }
 
 void TauMercurySpark::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 	drawing_mode(DRAW_MODE_TRANS, NULL, 0, 0);
 
 	double c = lifetime/(double)lifetime_max;

Modified: branches/multiplayer-branch/source/ships/shptausl.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shptausl.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shptausl.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 
 #define trace_lifetime 200.0
 #define trace_rate 50
@@ -126,6 +125,7 @@
 
 int TauSlider::activate_weapon()
 {
+  STACKTRACE;
         if (in_jump) return false;
         add(new TauSliderLaser(+21, 15, angle - 15*ANGLE_RATIO,
                           weaponVelocity, weaponRange, weaponLength, this));
@@ -141,74 +141,101 @@
 
 void TauSlider::calculate_fire_special()
 {
-        special_low = false;
+  STACKTRACE;
+  special_low = false;
 
-        if (fire_special) {
-                if (in_jump) return;
-                holding_special = true;
-                if (special_recharge <= 0) {
-                        if (batt < special_drain) {
-                                special_low = true;
-                                activate_special();
-                                return; }
-                        else {  special_charge++;
-                                batt -= special_drain;
-                                special_recharge += special_rate;
-                                play_sound2(data->sampleSpecial[0]);
-                                if (special_charge >= max_charge)
-                                        activate_special(); } } }
-        else {
-                if (holding_special)
-                        if (!in_jump)
-                                activate_special();
-                holding_special = false; }
+  if (fire_special) 
+    {
+      if (in_jump) 
+	return;
+      holding_special = true;
+      if (special_recharge <= 0) 
+	{
+	  if (batt < special_drain) 
+	    {
+	      special_low = true;
+	      activate_special();
+	      return; 
+	    }
+	  else 
+	    {  
+	      special_charge++;
+	      batt -= special_drain;
+	      special_recharge += special_rate;
+	      
+	      tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+	      tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
+	      
+	      if (special_charge >= max_charge)
+		activate_special(); 
+	    } 
+	} 
+    }
+  else 
+    {
+      if (holding_special)
+	if (!in_jump)
+	  activate_special();
+      holding_special = false; 
+    }
 }
 
 
 int TauSlider::activate_special()
 {
-        if (special_charge >= critical_charge) {
-                in_jump = true;
-                collide_flag_anyone = 0;
-                layer = LAYER_HOTSPOTS;
-                double a = special_charge - sub_velocity;
-                jv = velocity0 + a * (velocity1 + a * velocity2);
-                //jvx = jv * cos(angle*ANGLE_RATIO);
-                //jvy = jv * sin(angle*ANGLE_RATIO);
-				jvp = jv * unit_vector(angle);
-                a = special_charge - sub_range;
-                jd = range0 + a * (range1 + a * range2);
-                trace_recharge = 0;
-                play_sound2(data->sampleSpecial[2]); }
-        else    play_sound2(data->sampleSpecial[1]);
+  STACKTRACE;
+  if (special_charge >= critical_charge) 
+    {
+      in_jump = true;
+      collide_flag_anyone = 0;
+      layer = LAYER_HOTSPOTS;
+      double a = special_charge - sub_velocity;
+      jv = velocity0 + a * (velocity1 + a * velocity2);
+      jvp = jv * unit_vector(angle);
+      a = special_charge - sub_range;
+      jd = range0 + a * (range1 + a * range2);
+      trace_recharge = 0;
+      tw_sound->stop_sound(data_full_path(data->sampleSpecial[2]));
+      tw_sound->play_sound(data_full_path(data->sampleSpecial[2]));
+    }
+  else    
+    {
+      tw_sound->stop_sound(data_full_path(data->sampleSpecial[1]));
+      tw_sound->play_sound(data_full_path(data->sampleSpecial[1]));
+    }
 
-        special_charge = 0;
-        return true;
+  special_charge = 0;
+  return true;
 }
 
 void TauSlider::calculate()
 {
-        just_exited = false;
-        Ship::calculate();
-        if (in_jump) {
-                trace_recharge -= frame_time;
-                if (trace_recharge < 0) {
-                        trace_recharge += trace_rate;
-                        ct = (ct + 1) % max_trace_number;
-                        tr[ct] = new TauSliderTrace(this); 
-						add(tr[ct]);}
-                //x = normalize(x + jvx * frame_time, X_MAX);
-                //y = normalize(y + jvy * frame_time, Y_MAX);
-				pos = normalize(pos + jvp * frame_time, map_size);
-                jd -= jv * frame_time;
-                if (jd <= 0) {
-                        in_jump = false;
-                        layer = LAYER_SHIPS;
-                        collide_flag_anyone = collide_flag_reserve; }                        
-        }        
+  STACKTRACE;
+  just_exited = false;
+  Ship::calculate();
+  if (in_jump) 
+    {
+      trace_recharge -= frame_time;
+      if (trace_recharge < 0) 
+	{
+	  trace_recharge += trace_rate;
+	  ct = (ct + 1) % max_trace_number;
+	  tr[ct] = new TauSliderTrace(this); 
+	  add(tr[ct]);
+	}
+      pos = normalize(pos + jvp * frame_time, map_size);
+      jd -= jv * frame_time;
+      if (jd <= 0) 
+	{
+	  in_jump = false;
+	  layer = LAYER_SHIPS;
+	  collide_flag_anyone = collide_flag_reserve; 
+	}
+    }        
 }
 
 int TauSlider::handle_damage(SpaceLocation *source, int normal, int direct) {
+  STACKTRACE;
         if (in_jump) {
                 return 0; }
         if (just_exited && source->isPlanet())
@@ -218,23 +245,27 @@
 
 int TauSlider::canCollide(SpaceLocation *other)
 {
+  STACKTRACE;
         return ((!in_jump)&&Ship::canCollide(other));
 }
 
 int TauSlider::translate(double dx, double dy)
 {
+  STACKTRACE;
         if (!in_jump) return Ship::translate(dx, dy);
 				return false;
 }
 
 int TauSlider::accelerate(SpaceLocation *source, double oangle, double vel, double omax_speed)
 {
+  STACKTRACE;
         if (!in_jump) return Ship::accelerate(source, oangle, vel, omax_speed);
 				return false;
 }
 
 void TauSlider::animate(Frame* space)
 {
+  STACKTRACE;
         int i,j,r,g,b;
         double a;
         for (i=max_trace_number; i>=0; i--) {
@@ -261,11 +292,13 @@
 
 int TauSlider::isProtected()
 {
+  STACKTRACE;
         return (in_jump);
 }
 
 void TauSlider::calculate_hotspots()
 {
+  STACKTRACE;
         if (!in_jump) Ship::calculate_hotspots();
 }
 
@@ -289,6 +322,7 @@
 
 void TauSliderLaser::calculate()
 {
+  STACKTRACE;
         double a = (d) / range;
         int r = (int)floor(255 - a*400);
         if (r < 0) r = 0;
@@ -304,6 +338,7 @@
 
 void TauSliderLaser::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
         SpaceLine::inflict_damage(other);
         state = 0;
 }
@@ -312,6 +347,7 @@
 TauSliderTrace::TauSliderTrace(Ship* oship) :
         SpaceLocation(oship, oship->normal_pos(), oship->get_angle())
 {
+  STACKTRACE;
         collide_flag_anyone = 0;
         lifetime = 0;
         //vx = oship->get_vx();
@@ -322,6 +358,7 @@
 
 void TauSliderTrace::calculate()
 {
+  STACKTRACE;
         if ((lifetime += frame_time) >= trace_lifetime)
                 state = 0;
 }

Modified: branches/multiplayer-branch/source/ships/shptaust.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shptaust.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shptaust.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -15,245 +15,246 @@
 GNU General Public License for more details.
 */
 
+#include "util/sound.h"
 #include "ship.h"
+#include "scp.h"
 
-REGISTER_FILE
-
 class TauStorm : public Ship
 {
-	double		weaponVelocity, weaponAccel, weaponTurnRate, weaponThrust, weaponFuel, weaponStart;
-	double		specialVelocity, specialAccel, specialTurnRate, specialThrust, specialFuel, specialStart;
-	double		weaponBoosterSpeed, weaponRotation, weaponKick, weaponKickMaxspeed;
-	double		specialBoosterSpeed, specialRotation, specialKick, specialKickMaxspeed;
-	double		weaponMass;
-	double		weaponRandom, specialRandom;
+  double weaponVelocity, weaponAccel, weaponTurnRate;
+  double weaponThrust, weaponFuel, weaponStart;
+  double specialVelocity, specialAccel, specialTurnRate;
+  double specialThrust, specialFuel, specialStart;
+  double weaponBoosterSpeed, weaponRotation, weaponKick, weaponKickMaxspeed;
+  double specialBoosterSpeed, specialRotation, specialKick, specialKickMaxspeed;
+  double weaponMass;
+  double weaponRandom, specialRandom;
 
-	int			slot;
+  int slot;
 
 public:
-	TauStorm(Vector2 opos, double shipAngle,
-		ShipData *shipData, unsigned int code);
-
-	virtual int  activate_weapon();
-	virtual int  activate_special();
-	virtual void animate(Frame *space);
+  TauStorm(Vector2 opos, double shipAngle,
+	   ShipData *shipData, unsigned int code);
+  
+  virtual int  activate_weapon();
+  virtual int  activate_special();
+  virtual void animate(Frame *space);
 };
 
 
 class TauStormMissile : public HomingMissile
 {
-	int	fuel;
-
-	double ra, pa, rr, rt;
-
-	SpaceObject *latched;
-	
-	double booster_speed, thrust, accel, rotation;
-	int smoke_frame, first_frame;
-
+  int	fuel;
+  
+  double ra, pa, rr, rt;
+  
+  SpaceObject *latched;
+  
+  double booster_speed, thrust, accel, rotation;
+  int smoke_frame, first_frame;
+  
 public:
 
-	TauStormMissile (SpaceLocation *creator, double ox, double oy, double oangle, double oaccel,
-				double ov, double otr, SpaceObject *otarget,
-				int ofuel, double othrust, double omass, double oboosterspeed,
-				SpaceSprite *osprite, double omr, double osv, SAMPLE *s);				
-	virtual void calculate();
-	virtual void inflict_damage (SpaceObject *other);
-	virtual void handle_damage (SpaceObject *other, double normal, double direct = 0);
-	virtual int  canCollide(SpaceLocation *other);
+  TauStormMissile (SpaceLocation *creator, double ox, double oy, double oangle, double oaccel,
+		   double ov, double otr, SpaceObject *otarget,
+		   int ofuel, double othrust, double omass, double oboosterspeed,
+		   SpaceSprite *osprite, double omr, double osv, std::string s);
+  virtual void calculate();
+  virtual void inflict_damage (SpaceObject *other);
+  virtual void handle_damage (SpaceObject *other, double normal, double direct = 0);
+  virtual int  canCollide(SpaceLocation *other);
 };
 
 
 
 TauStorm::TauStorm(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code) :
-	Ship(opos, shipAngle, shipData, code)
+  Ship(opos, shipAngle, shipData, code)
 {
-
-	weaponMass = get_config_float("Weapon", "Mass", 0.01);
-
-	weaponVelocity		= scale_velocity(get_config_float("Weapon", "Velocity", 0));
-	weaponAccel			= scale_acceleration(get_config_float("Weapon", "Accel", 0), 0);
-	weaponTurnRate		= scale_turning(get_config_float("Weapon", "TurnRate", 0));
-	weaponFuel			= get_config_int("Weapon", "Fuel", 0);
-	weaponThrust		= scale_acceleration(get_config_int("Weapon", "Thrust", 0), 0);
-	weaponBoosterSpeed	= scale_velocity(get_config_float("Weapon", "BoosterSpeed", 0));
-	weaponRotation		= get_config_float("Weapon", "Rotation", 0)*PI/180;
-	weaponKick			= scale_velocity(get_config_float("Weapon", "Kick", 0));
-	weaponKickMaxspeed	= scale_velocity(get_config_float("Weapon", "KickMaxspeed", 0));
-	weaponStart			= get_config_float("Weapon", "StartSpeed", 0);
-	weaponRandom		= get_config_float("Weapon", "Random", 0);
-
-	specialVelocity		= scale_velocity(get_config_float("Special", "Velocity", 0));
-	specialAccel		= scale_acceleration(get_config_float("Special", "Accel", 0), 0);
-	specialTurnRate		= scale_turning(get_config_float("Special", "TurnRate", 0));
-	specialFuel			= get_config_int("Special", "Fuel", 0);
-	specialThrust		= scale_acceleration(get_config_int("Special", "Thrust", 0), 0);
-	specialBoosterSpeed	= scale_velocity(get_config_float("Special", "BoosterSpeed", 0));
-	specialRotation		= get_config_float("Special", "Rotation", 0)*PI/180;
-	specialKick			= scale_velocity(get_config_float("Special", "Kick", 0));
-	specialKickMaxspeed	= scale_velocity(get_config_float("Special", "KickMaxspeed", 0));
-	specialStart		= get_config_float("Special", "StartSpeed", 0);
-	specialRandom		= get_config_float("Special", "Random", 0);
-
-	slot = 0;
-
-	weapon_sample		= -1;
-	special_sample		= -1;
+  STACKTRACE;
+  
+  weaponMass = get_config_float("Weapon", "Mass", 0.01);
+  
+  weaponVelocity	= scale_velocity(get_config_float("Weapon", "Velocity", 0));
+  weaponAccel		= scale_acceleration(get_config_float("Weapon", "Accel", 0), 0);
+  weaponTurnRate	= scale_turning(get_config_float("Weapon", "TurnRate", 0));
+  weaponFuel		= get_config_int("Weapon", "Fuel", 0);
+  weaponThrust		= scale_acceleration(get_config_int("Weapon", "Thrust", 0), 0);
+  weaponBoosterSpeed	= scale_velocity(get_config_float("Weapon", "BoosterSpeed", 0));
+  weaponRotation	= get_config_float("Weapon", "Rotation", 0)*PI/180;
+  weaponKick		= scale_velocity(get_config_float("Weapon", "Kick", 0));
+  weaponKickMaxspeed	= scale_velocity(get_config_float("Weapon", "KickMaxspeed", 0));
+  weaponStart		= get_config_float("Weapon", "StartSpeed", 0);
+  weaponRandom		= get_config_float("Weapon", "Random", 0);
+  
+  specialVelocity	= scale_velocity(get_config_float("Special", "Velocity", 0));
+  specialAccel		= scale_acceleration(get_config_float("Special", "Accel", 0), 0);
+  specialTurnRate	= scale_turning(get_config_float("Special", "TurnRate", 0));
+  specialFuel		= get_config_int("Special", "Fuel", 0);
+  specialThrust		= scale_acceleration(get_config_int("Special", "Thrust", 0), 0);
+  specialBoosterSpeed	= scale_velocity(get_config_float("Special", "BoosterSpeed", 0));
+  specialRotation	= get_config_float("Special", "Rotation", 0)*PI/180;
+  specialKick		= scale_velocity(get_config_float("Special", "Kick", 0));
+  specialKickMaxspeed	= scale_velocity(get_config_float("Special", "KickMaxspeed", 0));
+  specialStart		= get_config_float("Special", "StartSpeed", 0);
+  specialRandom		= get_config_float("Special", "Random", 0);
+  
+  slot = 0;
+  
+  weapon_sample		= -1;
+  special_sample	= -1;
 }
 
 int TauStorm::activate_weapon()
 {
-	STACKTRACE
-	int rx;
-	if (slot<2)	rx = 9;
-	else rx = 13;
-	if (slot%2)	rx = -rx;
-	game->add(new TauStormMissile (this, rx, 10, angle, weaponAccel,
-				weaponVelocity, weaponTurnRate, target,
-				iround(weaponFuel*(1+weaponRandom*(100-random()%201)/100.0)), weaponThrust, weaponMass,
-				weaponBoosterSpeed, data->spriteWeapon,
-				weaponRotation, weaponStart, data->sampleWeapon[0]));
-	slot = (slot +1) % 6;
-	accelerate(this, angle+PI, weaponKick, weaponKickMaxspeed);
-    return true;
+  STACKTRACE;
+  int rx;
+  if (slot<2)	
+    rx = 9;
+  else rx = 13;
+  if (slot%2)	rx = -rx;
+  game->add(new TauStormMissile (this, rx, 10, angle, weaponAccel,
+				 weaponVelocity, weaponTurnRate, target,
+				 iround(weaponFuel*(1+weaponRandom*(100-random()%201)/100.0)), 
+				 weaponThrust, weaponMass,
+				 weaponBoosterSpeed, data->spriteWeapon,
+				 weaponRotation, weaponStart, data->sampleWeapon[0]));
+  slot = (slot +1) % 6;
+  accelerate(this, angle+PI, weaponKick, weaponKickMaxspeed);
+  return true;
 }
 
 int TauStorm::activate_special()
 {
-	STACKTRACE
-	int rx;
-	if (slot<2)	rx = 9;
-	else rx = 13;
-	if (slot%2)	rx = -rx;
-	game->add(new TauStormMissile (this, rx, 10, angle, specialAccel,
-			specialVelocity, specialTurnRate, target,
-			iround(specialFuel*(1+specialRandom*(100-random()%201)/100.0)), specialThrust, weaponMass,
-			specialBoosterSpeed, data->spriteSpecial,
-			specialRotation, specialStart, data->sampleSpecial[0]));
-	slot = (slot + 1) % 6;
-	accelerate(this, angle+PI, specialKick, specialKickMaxspeed);
-    return true;
+  STACKTRACE;
+  int rx;
+  if (slot<2)	rx = 9;
+  else rx = 13;
+  if (slot%2)	rx = -rx;
+  game->add(new TauStormMissile (this, rx, 10, angle, specialAccel,
+				 specialVelocity, specialTurnRate, target,
+				 iround(specialFuel*(1+specialRandom*(100-random()%201)/100.0)), 
+				 specialThrust, weaponMass,
+				 specialBoosterSpeed, data->spriteSpecial,
+				 specialRotation, specialStart, data->sampleSpecial[0]));
+  slot = (slot + 1) % 6;
+  accelerate(this, angle+PI, specialKick, specialKickMaxspeed);
+  return true;
 }
 
 
 void TauStorm::animate(Frame *space)
 {
-	STACKTRACE
-	if (thrust)
-		sprite->animate(pos, sprite_index + 64, space);
-	else
-		sprite->animate(pos, sprite_index, space);
+  STACKTRACE;
+  if (thrust)
+    sprite->animate(pos, sprite_index + 64, space);
+  else
+    sprite->animate(pos, sprite_index, space);
 }
 
 
-TauStormMissile::TauStormMissile (SpaceLocation *creator, double ox, double oy, double oangle, double oaccel,
-				double ov, double otr, SpaceObject *otarget,
-				int ofuel, double othrust, double omass, double oboosterspeed,
-				SpaceSprite *osprite, double omr, double osv, SAMPLE *s) :
-	HomingMissile(creator, Vector2(ox,oy), oangle, ov, 1, 1e40, 1, otr, creator,  osprite, otarget),
-	fuel(ofuel), booster_speed(oboosterspeed),
-	thrust(othrust), accel(oaccel), rotation(omr)
-
+TauStormMissile::TauStormMissile (SpaceLocation *creator, double ox, double oy, 
+				  double oangle, double oaccel,
+				  double ov, double otr, SpaceObject *otarget,
+				  int ofuel, double othrust, double omass, double oboosterspeed,
+				  SpaceSprite *osprite, double omr, double osv, std::string s) :
+  HomingMissile(creator, Vector2(ox,oy), oangle, ov, 1, 1e40, 1, otr, creator,  osprite, otarget),
+  fuel(ofuel), booster_speed(oboosterspeed),
+  thrust(othrust), accel(oaccel), rotation(omr)
 {
-
-	latched = NULL;
-	mass = omass;
-
-	vel = vel*osv + creator->get_vel();
-
-	explosionSprite = data->spriteWeaponExplosion;
-	explosionFrameCount = 10;
-	explosionFrameSize = 50;
-	explosionSample = data->sampleExtra[0];
-
-	smoke_frame = 0;
-	first_frame = 12;
-
-	play_sound(s);
+  
+  latched = NULL;
+  mass = omass;
+  
+  vel = vel*osv + creator->get_vel();
+  
+  explosionSprite = data->spriteWeaponExplosion;
+  explosionFrameCount = 10;
+  explosionFrameSize = 50;
+  explosionSample = data->sampleExtra[0];
+  
+  smoke_frame = 0;
+  first_frame = 12;
+  
+  tw_sound->play_sound(data_full_path(s));
 }
 
 
 void TauStormMissile::calculate()
 {
-	STACKTRACE
-	if (latched) {
-
-		if (!latched->exists())
-			handle_damage(this, 999);
-
-		double alpha;
-		alpha = ((latched->get_angle() + pa));
-		pos = latched->normal_pos() + rr * unit_vector(latched->get_angle() + pa);
-
-		vel = latched->get_vel();
-
-		angle = normalize(ra + latched->get_angle(), PI2);
-		sprite_index = iround(angle / (PI2/64)) + 16;
-		sprite_index &= 63;
-
-		double jr = (latched->size.x/2.0);
-		if (latched->mass > 1) {
-			latched->accelerate(this, angle, thrust * frame_time / latched->mass, booster_speed);
-			jr *= jr * 0.5 * latched->mass; }
-		else {
-			latched->accelerate(this, angle, thrust * frame_time, booster_speed);
-			jr *= jr * 0.5; }
-
-		if (latched->isShip())
-			((Ship*)latched)->turn_step += rotation * 1000 * rt * frame_time / jr;
-		else
-			latched->angle += rotation * 1000 * rt * frame_time / jr;
-	};
-
-              
-	if (smoke_frame > 0) smoke_frame -= frame_time;
-	else {
-		while (smoke_frame <= 0)
-			smoke_frame += 25;
-		game->add(new Animation(this, pos, data->spriteExtra,
-			first_frame, 20-first_frame, 50, LAYER_HOTSPOTS));
-		if (first_frame > 0) first_frame -= 3; }
-
-
-	if (fuel > 0) {
-		fuel -= frame_time;	
-		Vector2 ov = vel;
-		HomingMissile::calculate();
-		vel = ov;
-		accelerate(this, angle, accel*frame_time, v); }
-	else {
-		if (latched)
-			damage(latched, 0, 1);
-		handle_damage(this, 999); }
+  STACKTRACE;
+  if (latched) 
+    {
+      if (!latched->exists())
+	handle_damage(this, 999);
+      
+      double alpha;
+      alpha = ((latched->get_angle() + pa));
+      pos = latched->normal_pos() + rr * unit_vector(latched->get_angle() + pa);
+      
+      vel = latched->get_vel();
+      
+      angle = normalize(ra + latched->get_angle(), PI2);
+      sprite_index = iround(angle / (PI2/64)) + 16;
+      sprite_index &= 63;
+      
+      double jr = (latched->size.x/2.0);
+      if (latched->mass > 1) {
+	latched->accelerate(this, angle, thrust * frame_time / latched->mass, booster_speed);
+	jr *= jr * 0.5 * latched->mass; }
+      else {
+	latched->accelerate(this, angle, thrust * frame_time, booster_speed);
+	jr *= jr * 0.5; }
+      
+      if (latched->isShip())
+	((Ship*)latched)->turn_step += rotation * 1000 * rt * frame_time / jr;
+      else
+	latched->angle += rotation * 1000 * rt * frame_time / jr;
+    };
+  
+  
+  if (smoke_frame > 0) smoke_frame -= frame_time;
+  else {
+    while (smoke_frame <= 0)
+      smoke_frame += 25;
+    game->add(new Animation(this, pos, data->spriteExtra,
+			    first_frame, 20-first_frame, 50, LAYER_HOTSPOTS));
+    if (first_frame > 0) first_frame -= 3; }
+  
+  
+  if (fuel > 0) {
+    fuel -= frame_time;	
+    Vector2 ov = vel;
+    HomingMissile::calculate();
+    vel = ov;
+    accelerate(this, angle, accel*frame_time, v); }
+  else {
+    if (latched)
+      damage(latched, 0, 1);
+    handle_damage(this, 999); }
 }
 
 void TauStormMissile::inflict_damage (SpaceObject *other)
 {
-	STACKTRACE
-
-	if (latched || other->isShot()) return;
-	latched = other;
-	rr = distance(other);
-	ra = angle - other->get_angle();
-	pa = other->trajectory_angle(this) - other->get_angle();
-	rt = thrust * rr * sin((angle-other->trajectory_angle(this)));
-
-//	play_sound
+  if (latched || other->isShot()) return;
+  latched = other;
+  rr = distance(other);
+  ra = angle - other->get_angle();
+  pa = other->trajectory_angle(this) - other->get_angle();
+  rt = thrust * rr * sin((angle-other->trajectory_angle(this)));
 }
 
 void TauStormMissile::handle_damage (SpaceObject *other, double normal, double direct)
 {
-	STACKTRACE
-	Shot::handle_damage(other, normal, direct);
-	if ((state == 0) && (other->isShot()))
-		damage(other, 1);
+  Shot::handle_damage(other, normal, direct);
+  if ((state == 0) && (other->isShot()))
+    damage(other, 1);
 }
 
 int TauStormMissile::canCollide(SpaceLocation *other)
 {
-	STACKTRACE
-	if (other == latched) return false;
-	return Shot::canCollide(other);
+  STACKTRACE;
+  if (other == latched) return false;
+  return Shot::canCollide(other);
 }
 
 

Modified: branches/multiplayer-branch/source/ships/shptauto.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shptauto.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shptauto.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -18,8 +18,6 @@
 #include "ship.h"
 #include "melee/mview.h"
 
-REGISTER_FILE
-
 class TauTor : public Ship
 {
   double        weaponRange;
@@ -53,7 +51,6 @@
 
 class TauTorTwister : public AnimatedShot
 {
-  // SAMPLE* sample_midd;
   
   public:
   
@@ -80,6 +77,7 @@
         Ship(opos, shipAngle, shipData, code)
 
 {
+  STACKTRACE;
         weaponRange     = scale_range(get_config_float("Weapon", "Range", 0));
         weaponVelocity  = scale_velocity(get_config_float("Weapon", "Velocity", 0));
         weaponDamage    = get_config_int("Weapon", "Damage", 0);
@@ -109,6 +107,7 @@
 
 int TauTor::activate_weapon()
 {
+  STACKTRACE;
         if (transition_count > 0) return false;
 
         if (TauTor_state) {
@@ -128,111 +127,130 @@
 
 void TauTor::calculate_fire_special()
 {
-        special_low = false;
-        if (fire_special && can_switch && (transition_count <=0)) {
-                can_switch = false;
-                if (TauTor_state) {
-                        play_sound(data->sampleExtra[1]);
-                        residual_drain = 0.0;
-                        recharge_amount = extra_recharge;
-                        weapon_rate  = extra_rate;
-                        weapon_drain = extra_drain;
-                        sprite = data->spriteShip;
-                        TauTor_state = false; }
-                else    if (batt > switch_drain) {
-                                transition_count = transition_time;
-                                residual_drain = 0.0;
-                                recharge_amount = 0;
-                                play_sound(data->sampleExtra[0]);
-                                weapon_rate  = special_rate;
-                                weapon_drain = special_drain; }
-                        else    special_low = true; }
+  STACKTRACE;
+  special_low = false;
+  if (fire_special && can_switch && (transition_count <=0)) 
+    {
+      can_switch = false;
+      if (TauTor_state) 
+	{
+	  tw_sound->play_sound(data_full_path(data->sampleExtra[1]));
+	  residual_drain = 0.0;
+	  recharge_amount = extra_recharge;
+	  weapon_rate  = extra_rate;
+	  weapon_drain = extra_drain;
+	  sprite = data->spriteShip;
+	  TauTor_state = false; 
+	}
+      else if (batt > switch_drain) 
+	{
+	  transition_count = transition_time;
+	  residual_drain = 0.0;
+	  recharge_amount = 0;
+	  tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
+	  weapon_rate  = special_rate;
+	  weapon_drain = special_drain; 
+	}
+      else    
+	special_low = true; 
+    }
 }
 
 void TauTor::calculate()
 {
-		
-        if (transition_count > 0) {
-                if ((transition_count -= frame_time) <= 0) {
-                        sprite = data->spriteExtraExplosion;
-                        TauTor_state = true; }
-                residual_drain += switch_drain * frame_time / (double)transition_time; }
-        int a = (int)floor(residual_drain);
-        batt -= a;
-        residual_drain -= a;
-        if (batt < 0) batt = 0;
-
-        if (TauTor_state && (batt == 0)) {
-                play_sound(data->sampleExtra[1]);
-                residual_drain = 0.0;
-                recharge_amount = extra_recharge;
-                weapon_rate  = extra_rate;
-                weapon_drain = extra_drain;
-                sprite = data->spriteShip;
-                TauTor_state = false; }
-        
-        Ship::calculate();
-        if (!fire_special) can_switch = true;
+  STACKTRACE;
+  if (transition_count > 0) 
+    {
+      if ((transition_count -= frame_time) <= 0) 
+	{
+	  sprite = data->spriteExtraExplosion;
+	  TauTor_state = true; 
+	}
+      residual_drain += switch_drain * frame_time / (double)transition_time; 
+    }
+  int a = (int)floor(residual_drain);
+  batt -= a;
+  residual_drain -= a;
+  if (batt < 0)
+    batt = 0;
+  
+  if (TauTor_state && (batt == 0)) 
+    {
+      tw_sound->play_sound(data_full_path(data->sampleExtra[1]));
+      residual_drain = 0.0;
+      recharge_amount = extra_recharge;
+      weapon_rate  = extra_rate;
+      weapon_drain = extra_drain;
+      sprite = data->spriteShip;
+      TauTor_state = false; 
+    }
+  
+  Ship::calculate();
+  if (!fire_special) 
+    can_switch = true;
 }
 
 void TauTor::calculate_thrust()
 {
-
-        if (thrust && (transition_count <=0)) {
-                if (TauTor_state && (batt > 0)) {
-                        residual_drain += engine_drain * frame_time;
-                        accelerate(this, angle, accel_rate * frame_time * accel_boost, speed_max * speed_boost); }
-                else    accelerate(this, angle, accel_rate * frame_time, speed_max); }
+  STACKTRACE;
+  if (thrust && (transition_count <=0)) 
+    {
+      if (TauTor_state && (batt > 0)) 
+	{
+	  residual_drain += engine_drain * frame_time;
+	  accelerate(this, angle, accel_rate * frame_time * accel_boost, speed_max * speed_boost); 
+	}
+      else    
+	accelerate(this, angle, accel_rate * frame_time, speed_max); 
+    }
 }
 
 void TauTor::calculate_hotspots ()
 {
-	if((thrust) && (hotspot_frame <= 0) && (transition_count <=0)) {
-                if (TauTor_state && (batt > 0))
-			add(new Animation(this, 
-					  //normal_x() - (cos(angle * ANGLE_RATIO) * 21),
-					  //normal_y() - (sin(angle * ANGLE_RATIO) * 21),
-					  normal_pos() - 21 * unit_vector(angle),
-					  data->spriteExtra, 0, 12, time_ratio, LAYER_HOTSPOTS));
-		else	add(new Animation(this, 
-					  //normal_x() - (cos(angle * ANGLE_RATIO) * 21),
-					  //normal_y() - (sin(angle * ANGLE_RATIO) * 21),
-					  normal_pos() - 21 * unit_vector(angle),
-					  meleedata.hotspotSprite, 0, HOTSPOT_FRAMES, time_ratio, LAYER_HOTSPOTS));
-		hotspot_frame += hotspot_rate; }
-	if (hotspot_frame > 0) hotspot_frame -= frame_time;
-	return;
+  if((thrust) && (hotspot_frame <= 0) && (transition_count <=0)) 
+    {
+      if (TauTor_state && (batt > 0))
+	add(new Animation(this, 
+			  normal_pos() - 21 * unit_vector(angle),
+			  data->spriteExtra, 0, 12, time_ratio, LAYER_HOTSPOTS));
+      else	
+	add(new Animation(this, 
+			  normal_pos() - 21 * unit_vector(angle),
+			  game->meleedata.hotspotSprite, 0, HOTSPOT_FRAMES, time_ratio, LAYER_HOTSPOTS));
+      hotspot_frame += hotspot_rate; 
+    }
+  if (hotspot_frame > 0) 
+    hotspot_frame -= frame_time;
+  return;
 }
 
 
 TauTorTwister::TauTorTwister(Vector2 opos, double oangle, double ov, int odamage,
-                                 double orange, int oarmour, SpaceLocation *creator, SpaceLocation *lpos,
-                                 SpaceSprite *osprite, int ofcount, int ofsize, double relativity) :
-        AnimatedShot(creator, opos, oangle, ov, odamage, orange, oarmour,
-        lpos, osprite, ofcount, ofsize, relativity)
+			     double orange, int oarmour, SpaceLocation *creator, SpaceLocation *lpos,
+			     SpaceSprite *osprite, int ofcount, int ofsize, double relativity) :
+  AnimatedShot(creator, opos, oangle, ov, odamage, orange, oarmour,
+	       lpos, osprite, ofcount, ofsize, relativity)
 {
-        explosionSprite     = data->spriteWeaponExplosion;
-        explosionFrameCount = 12;
-        explosionFrameSize  = 50;
-        //sample_midd         = data->sampleSpecial[0];
+  STACKTRACE;
+  explosionSprite     = data->spriteWeaponExplosion;
+  explosionFrameCount = 12;
+  explosionFrameSize  = 50;
 }
 
 
 TauTorPlasma::TauTorPlasma(Vector2 opos, double oangle, double ov, int odamage,
-                               double orange, int oarmour, SpaceLocation *creator, SpaceLocation *lpos,
-                               SpaceSprite *osprite, int ofcount, int ofsize, double relativity) :
+			   double orange, int oarmour, SpaceLocation *creator, SpaceLocation *lpos,
+			   SpaceSprite *osprite, int ofcount, int ofsize, double relativity) :
         AnimatedShot(creator, opos, oangle, ov, odamage, orange, oarmour,
-        lpos, osprite, ofcount, ofsize, relativity)
+		     lpos, osprite, ofcount, ofsize, relativity)
 {
-        explosionSprite     = data->spriteSpecialExplosion;
-        explosionFrameCount = 12;
-        explosionFrameSize  = 50;
-
+  STACKTRACE;
+  explosionSprite     = data->spriteSpecialExplosion;
+  explosionFrameCount = 12;
+  explosionFrameSize  = 50;
+  
 }
 
-
-
-
-
 REGISTER_SHIP(TauTor)
-
+  
+  

Modified: branches/multiplayer-branch/source/ships/shpwolmi.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpwolmi.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shpwolmi.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -17,7 +17,6 @@
 
 
 #include "ship.h"
-REGISTER_FILE
 
 #include "frame.h"
 
@@ -75,6 +74,7 @@
 :
 Ship(opos,  shipAngle, shipData, code)
 {
+  STACKTRACE;
 	
 	weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
 	weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
@@ -88,8 +88,8 @@
 
 
 int Wolly::activate_weapon()
-{	
-	STACKTRACE;
+{
+  STACKTRACE;
 	
 
 	Vector2 rpos;
@@ -106,7 +106,7 @@
 
 int Wolly::activate_special()
 {
-	STACKTRACE;
+  STACKTRACE;
 
 	WollyMine *o;
 	Vector2 rpos;
@@ -130,6 +130,7 @@
 :
 Shot(creator, rpos, oangle, ov, odamage, orange, oarmour, opos, osprite, relativity)
 {
+  STACKTRACE;
 	default_range = orange;
 
 	collide_flag_anyone = ALL_LAYERS;
@@ -141,7 +142,7 @@
 
 int WollyPlasma::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE;
+  STACKTRACE;
 
 	armour += normal + direct;
 
@@ -165,7 +166,7 @@
 
 void WollyPlasma::calculate()
 {
-	STACKTRACE;
+  STACKTRACE;
 	
 	Shot::calculate();
 
@@ -192,6 +193,7 @@
 
 int WollyPlasma::canCollide(SpaceLocation *other)
 {
+  STACKTRACE;
 	if (other->id == ID_WOLLYPLASMA)
 		return FALSE;
 		
@@ -207,6 +209,7 @@
 :
 SpaceObject(creator, opos, oangle, osprite)
 {
+  STACKTRACE;
 	lifetime = olifetime;
 	existtime = 0;
 
@@ -226,6 +229,7 @@
 
 void WollyMine::calculate()
 {
+  STACKTRACE;
 	SpaceObject::calculate();
 
 	existtime += frame_time * 1E-3;
@@ -240,6 +244,7 @@
 
 int WollyMine::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
 	state = 0;
 	return true;
 }

Modified: branches/multiplayer-branch/source/ships/shpyusra.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpyusra.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shpyusra.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -16,7 +16,6 @@
 */
 
 #include "ship.h"
-REGISTER_FILE
 #include "other/objanim.h"
 
 class YushSpear;
@@ -69,6 +68,7 @@
   ShipData *shipData, unsigned int code ):
   Ship( opos, shipAngle, shipData, code )
 {
+  STACKTRACE;
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
   weaponDamage   = get_config_int("Weapon", "Damage", 0);
@@ -78,7 +78,7 @@
 }
 
 int YushRanger::activate_weapon(){
-	STACKTRACE
+  STACKTRACE;
   if( weaponObject ) return FALSE;
   game->add( weaponObject = new YushSpear( this, Vector2(0, 0.5*get_size().y), angle, weaponVelocity,
     weaponDamage, weaponRange, weaponArmour, weaponControl, this, data->spriteWeapon ));
@@ -86,7 +86,7 @@
 }
 
 int YushRanger::activate_special(){
-	STACKTRACE;
+  STACKTRACE;
 	double alpha = atan3(vel.y, vel.x);
 	alpha = normalize(alpha, PI2);
 	double v = vel.length();		//sqrt( vx*vx + vy*vy );
@@ -107,17 +107,17 @@
 }
 
 void YushRanger::calculate_turn_left(){
-	STACKTRACE;
+  STACKTRACE;
 	if( !fire_weapon ) Ship::calculate_turn_left();
 }
 
 void YushRanger::calculate_turn_right(){
-	STACKTRACE;
+  STACKTRACE;
   if( !fire_weapon ) Ship::calculate_turn_right();
 }
 
 void YushRanger::calculate(){
-	STACKTRACE;
+  STACKTRACE;
   Ship::calculate();
   if( weaponObject ){
     if( !weaponObject->exists() || weaponObject->released ){
@@ -137,11 +137,12 @@
 control( ocontrol ), 
 released( false )
 {
+  STACKTRACE;
 }
 
 void YushSpear::calculate()
 {
-	STACKTRACE;
+  STACKTRACE;
 
 	if (latched)
 	{
@@ -191,33 +192,39 @@
 }
 
 void YushSpear::release(){
+  STACKTRACE;
 	released = true;
 }
 
 void YushSpear::inflict_damage( SpaceObject* other )
 {
-	STACKTRACE;
-	if( latched || other->isShot() ) return;
-	if( !other->isAsteroid() ) Shot::inflict_damage( other );
-	state = 1;                   // don't want to die on contact
-	attributes &= ~ATTRIB_SHOT;  // not a shot anymore
-	released = true;
-	latched = other;
-	rel_angle = other->trajectory_angle( this ) - other->get_angle();
-	old_angle = angle - other->get_angle();
-	rel_dist = distance( other );
-	change_owner( other );       // are now part of the other ship
-	play_sound2( data->sampleWeapon[1 + random() % 2] );
+  STACKTRACE;
+  if( latched || other->isShot() ) return;
+  if( !other->isAsteroid() ) Shot::inflict_damage( other );
+  state = 1;                   // don't want to die on contact
+  attributes &= ~ATTRIB_SHOT;  // not a shot anymore
+  released = true;
+  latched = other;
+  rel_angle = other->trajectory_angle( this ) - other->get_angle();
+  old_angle = angle - other->get_angle();
+  rel_dist = distance( other );
+  change_owner( other );       // are now part of the other ship
+  std::string smpl = data->sampleWeapon[1 + random() % 2];
+  tw_sound->stop_sound(data_full_path(smpl));
+  tw_sound->play_sound(data_full_path(smpl));
 }
 
-int YushSpear::handle_damage( SpaceLocation* other, double normal, double direct ){
-	STACKTRACE;
-	if( latched ){
-		latched->handle_damage( other, normal, direct );
-		// commenting out the following two lines makes the spears vulnerable to damage
-		normal = direct = 0;
-	}
-	return Shot::handle_damage( other, normal, direct );
+int YushSpear::handle_damage( SpaceLocation* other, double normal, double direct )
+{
+  STACKTRACE;
+  if( latched )
+    {
+      latched->handle_damage( other, normal, direct );
+      // commenting out the following two lines makes the spears vulnerable to damage
+      normal = direct = 0;
+    }
+  return Shot::handle_damage( other, normal, direct );
 }
 
 REGISTER_SHIP(YushRanger)
+  

Modified: branches/multiplayer-branch/source/ships/shpzeksh.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpzeksh.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/ships/shpzeksh.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -18,7 +18,6 @@
 //ZekfahanShocker lousy code by Richardyzo at ig.com.br
 
 #include "ship.h"
-REGISTER_FILE
 
 class ZekfahanShocker : public Ship {
   double       weaponRange;
@@ -61,6 +60,7 @@
 	:
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   weaponRange    = scale_range(get_config_float("Weapon", "Range", 0));
   weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
   weaponDamage   = get_config_int("Weapon", "Damage", 0);
@@ -77,66 +77,59 @@
 
 int ZekfahanShocker::activate_weapon()
 {
-	STACKTRACE
-	play_sound2(data->sampleWeapon[0]);
+  STACKTRACE;
+  tw_sound->stop_sound(data_full_path(data->sampleWeapon[0]));
+  tw_sound->play_sound(data_full_path(data->sampleWeapon[0]));
+  
   add(new AnimatedShot(this, Vector2(42.0, 15.0), angle , weaponVelocity,
-    weaponDamage, weaponRange, weaponArmour, this, data->spriteWeapon, 5, 12, 1.0));
+		       weaponDamage, weaponRange, weaponArmour, this, data->spriteWeapon, 5, 12, 1.0));
   add(new AnimatedShot(this, Vector2(-42.0, 15.0), angle , weaponVelocity,
-    weaponDamage, weaponRange, weaponArmour, this, data->spriteWeapon, 5, 12, 1.0));
+		       weaponDamage, weaponRange, weaponArmour, this, data->spriteWeapon, 5, 12, 1.0));
   return(TRUE);
 }
 
-int ZekfahanShocker::activate_special() {
-	STACKTRACE
+int ZekfahanShocker::activate_special() 
+{
+  STACKTRACE;
   if(shockingFrames == 0)
-  {
-	play_sound2(data->sampleSpecial[0]);
-        shockingFrames = specialFrames;
-	shockVar = 1;
-	recharge_amount = 0;
-  }
+    {
+      tw_sound->stop_sound(data_full_path(data->sampleSpecial[0]));
+      tw_sound->play_sound(data_full_path(data->sampleSpecial[0]));
+      
+      shockingFrames = specialFrames;
+      shockVar = 1;
+      recharge_amount = 0;
+    }
   return(TRUE);
 }
 
 void ZekfahanShocker::calculate()
-{ 
-	STACKTRACE
+{
+  STACKTRACE; 
   if(shockVar == 1)
   {
-   if(shockingFrames > 0) {
-     shockingFrames -= frame_time;
-     }
-   if(shockingFrames % 500 == 0 ) {
-     add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
-     }
-   /*
-   if(shockingFrames == 2000 ) {
-	play_sound2(data->sampleSpecial[0]);
-     add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
-     }
-   if(shockingFrames == 1500 ) {
-	play_sound2(data->sampleSpecial[0]);
-     add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
-     }
-   if(shockingFrames == 1000 ) {
-	play_sound2(data->sampleSpecial[0]);
-     add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
-     }
-   if(shockingFrames == 500 ) {
-	play_sound2(data->sampleSpecial[0]);
-     add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
-     }
-	 */
-   if(shockVar && shockingFrames <= 50 )
-   {
-	play_sound2(data->sampleSpecial[1]);
-     add( new Shockwave(Vector2(0, 70), angle , specialVelocity, specialDamage, specialRange, specialArmour, this, this, data->spriteSpecial, 2, 50));
-     shockingFrames = 0;
-     shockVar = 0;
-     recharge_amount = 1;
-     }
+    if(shockingFrames > 0) 
+      {
+	shockingFrames -= frame_time;
+      }
+    if(shockingFrames % 500 == 0 ) 
+      {
+	add( new FixedAnimation(this, this, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
+      }
+    if(shockVar && shockingFrames <= 50 )
+      {
+	tw_sound->stop_sound(data_full_path(data->sampleSpecial[1]));
+	tw_sound->play_sound(data_full_path(data->sampleSpecial[1]));
+	
+	add( new Shockwave(Vector2(0, 70), angle , specialVelocity, 
+			   specialDamage, specialRange, specialArmour, this, this, 
+			   data->spriteSpecial, 2, 50));
+	shockingFrames = 0;
+	shockVar = 0;
+	recharge_amount = 1;
+      }
   }
-   Ship::calculate();
+  Ship::calculate();
 }
 
 Shockwave::Shockwave(Vector2 oposvec, double oangle, double ov,
@@ -144,16 +137,20 @@
   SpaceSprite *osprite, int ofcount, int ofsize) :
   AnimatedShot(oship, oposvec, oangle, ov, odamage, orange, oarmour, oship, osprite, ofcount, ofsize)
 {
+  STACKTRACE;
   collide_flag_anyone = (ALL_LAYERS);
 }
 
-void Shockwave::inflict_damage(SpaceObject *other) {
-	STACKTRACE
-	play_sound2(data->sampleSpecial[2]);
-	damage(other, 0, damage_factor);
-	add( new Animation(this, pos, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
-	return;
-	}
+void Shockwave::inflict_damage(SpaceObject *other) 
+{
+  STACKTRACE;
+  tw_sound->stop_sound(data_full_path(data->sampleSpecial[2]));
+  tw_sound->play_sound(data_full_path(data->sampleSpecial[2]));
+ 
+  damage(other, 0, damage_factor);
+  add( new Animation(this, pos, data->spriteSpecial, 0, 6, 30, LAYER_EXPLOSIONS));
+  return;
+}
 
 
 

Modified: branches/multiplayer-branch/source/twgui/twbutton.cpp
===================================================================
--- branches/multiplayer-branch/source/twgui/twbutton.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/twgui/twbutton.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -23,8 +23,6 @@
 
 #include "melee.h"
 
-REGISTER_FILE
-
 #include "twbutton.h"
 #include "twwindow.h"
 #include "other/twconfig.h"
@@ -33,6 +31,7 @@
 
 EmptyButton::EmptyButton(TWindow *menu, char *identbranch, int asciicode, bool akeepkey)
 {
+  STACKTRACE;
   prev = 0;
   next = 0;
   selected = false;
@@ -80,6 +79,7 @@
 
 bool EmptyButton::hasmouse()
 {
+  STACKTRACE;
   return (mainwindow->mpos.x >= pos.x &&
 	  mainwindow->mpos.y >= pos.y &&
 	  mainwindow->mpos.x < (pos+size).x &&
@@ -90,11 +90,13 @@
 
 bool EmptyButton::haskey()
 {
+  STACKTRACE;
   return flag.haskey;
 }
 
 bool EmptyButton::haskeypress()
 {
+  STACKTRACE;
   return flag.haskeypress;
 }
 
@@ -104,6 +106,7 @@
 // made for the detection flag
 void EmptyButton::check_key()
 {
+  STACKTRACE;
   // this is usually the case.
   flag.haskey = false;
   flag.haskeypress = false;
@@ -159,7 +162,8 @@
 
 
 void EmptyButton::handle_focus()
-{	
+{
+  STACKTRACE;	
   //mainwindow->setfocus(this);
   
   //focus = 1;
@@ -171,7 +175,8 @@
 
 
 void EmptyButton::handle_defocus()
-{	
+{
+  STACKTRACE;	
   flag.focus = false;
   
   //	if (button_event)
@@ -181,6 +186,7 @@
 
 void EmptyButton::check_focus()
 {
+  STACKTRACE;
   flag.lastfocus = flag.focus;
   
   if (haskey())
@@ -217,6 +223,7 @@
 // calls to calculate aren't made...
 void EmptyButton::handle_menu_focus_loss()
 {
+  STACKTRACE;
   selected = 0;
   //update_key();
   flag.reset();
@@ -224,6 +231,7 @@
 
 void EmptyButton::calculate()
 {
+  STACKTRACE;
   
   // copy information from the TWindow manager
   //	update_mouse();
@@ -299,12 +307,14 @@
 
 void EmptyButton::animate()
 {
+  STACKTRACE;
 }
 	
 
 
 EmptyButton::flag_struct::flag_struct()
 {
+  STACKTRACE;
 	// these flags are updated by the area's calculate function.
 //	focus = 0;
 //	left_mouse_press = left_mouse_release = left_mouse_hold = 0;
@@ -315,6 +325,7 @@
 
 void EmptyButton::flag_struct::reset()
 {
+  STACKTRACE;
   // these flags are updated by the area's calculate function.
   focus = 0;
   left_mouse_press = left_mouse_release = left_mouse_hold = 0;
@@ -325,6 +336,7 @@
 
 bool EmptyButton::isvalid()
 {
+  STACKTRACE;
   return true;
 }
 
@@ -340,11 +352,13 @@
 :
 EmptyButton(menu, identbranch, asciicode, akeepkey)
 {
+  STACKTRACE;
 //	mainwindow->scalepos(&x, &y);
 }
 
 void GraphicButton::locate(int ax, int ay)
 {
+  STACKTRACE;
   pos.x = ax;
   pos.y = ay;
   mainwindow->scalepos(&pos);
@@ -357,6 +371,7 @@
 
 void GraphicButton::animate()
 {
+  STACKTRACE;
   // check if button 1 (left) releases -> clicks for this item
   // unconditional drawing:
   if (flag.focus)
@@ -374,14 +389,17 @@
 
 void GraphicButton::draw_default()
 {
+  STACKTRACE;
 }
 
 void GraphicButton::draw_focus()
 {
+  STACKTRACE;
 }
 
 void GraphicButton::draw_selected()
 {
+  STACKTRACE;
 }
 
 
@@ -406,6 +424,7 @@
 // check a square area to see if it has the mouse on it.
 bool GraphicButton::hasmouse(BITMAP *bmpref)
 {
+  STACKTRACE;
   // first, check the square bitmap area
   if (EmptyButton::hasmouse())
     {
@@ -422,6 +441,7 @@
 
 void GraphicButton::draw_rect()
 {
+  STACKTRACE;
   BITMAP *b = mainwindow->drawarea;
   int x1, y1, x2, y2;
   
@@ -460,6 +480,7 @@
 
 void GraphicButton::draw_rect_fancy()
 {
+  STACKTRACE;
   BITMAP *b = mainwindow->drawarea;
   int x1, y1, x2, y2;
   
@@ -530,6 +551,7 @@
 
 void GraphicButton::draw_boundaries(BITMAP *bmpref)
 {
+  STACKTRACE;
   BITMAP *b = mainwindow->drawarea;
   
   int i, j;
@@ -576,6 +598,7 @@
 */
 void GraphicButton::locate_by_backgr(char *strid)
 {
+  STACKTRACE;
   char stron[128];
   strcpy(stron,  ident);
   strcat(stron,  strid);
@@ -631,6 +654,7 @@
 // obtain a bitmap, specific to this "object" :
 BITMAP *GraphicButton::getbmp(char *name)
 {
+  STACKTRACE;
   char streditbox[128];
   strcpy(streditbox,  ident);
   strcat(streditbox,  name);
@@ -643,6 +667,7 @@
 // obtain a bitmap using "absolute" path, so that it can come from anywhere...
 BITMAP *GraphicButton::getbmp_nobutton(char *name)
 {
+  STACKTRACE;
   // a background image is needed of course.
   return mainwindow->bmp(name);
 }
@@ -652,6 +677,7 @@
 
 void GraphicButton::init_pos_size(BITMAP **bmp_default, char *idstr)
 {
+  STACKTRACE;
   *bmp_default = getbmp(idstr);
   
   if (*bmp_default)
@@ -677,6 +703,7 @@
 
 bool GraphicButton::draw(BITMAP *b)
 {
+  STACKTRACE;
   if (b)
     {
       masked_blit(b, mainwindow->drawarea, 0, 0, pos.x, pos.y, b->w, b->h);

Modified: branches/multiplayer-branch/source/twgui/twbuttontypes.cpp
===================================================================
--- branches/multiplayer-branch/source/twgui/twbuttontypes.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/twgui/twbuttontypes.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -21,7 +21,6 @@
 
 #include "melee.h"
 #include "melee/mview.h"
-REGISTER_FILE
 
 #include "twwindow.h"
 #include "twbuttontypes.h"
@@ -37,6 +36,7 @@
 :
 GraphicButton(menu, identbranch, asciicode, akeepkey)
 {
+  STACKTRACE;
 	init_pos_size(&bmp_default, "default");
 
 	bmp_focus = getbmp("focus");
@@ -55,11 +55,13 @@
 // this is the default drawing (at rest):
 void Button::draw_default()
 {
+  STACKTRACE;
 	draw(bmp_default);
 }
 
 void Button::draw_focus()
 {
+  STACKTRACE;
 	if (!draw(bmp_focus))
 	{
 		draw_default();
@@ -69,6 +71,7 @@
 
 void Button::draw_selected()
 {
+  STACKTRACE;
 	if (!draw(bmp_selected))
 		draw_default();
 }
@@ -76,12 +79,14 @@
 
 bool Button::hasmouse()
 {
+  STACKTRACE;
 	return GraphicButton::hasmouse(bmp_default);
 }
 
 
 bool Button::isvalid()
 {
+  STACKTRACE;
 	return bmp_default != 0;
 };
 
@@ -92,6 +97,7 @@
 :
 GraphicButton(menu, identbranch, asciicode, akeepkey)
 {
+  STACKTRACE;
 	init_pos_size(&backgr, "backgr");
 
 	markfordeletion = true;
@@ -106,6 +112,7 @@
 
 void Area::changebackgr(char *fname)
 {
+  STACKTRACE;
 	BITMAP *newb;
 	//newb = getbmp(fname);
 	newb = getbmp_nobutton(fname);
@@ -123,6 +130,7 @@
 
 void Area::changebackgr(BITMAP *newb)
 {
+  STACKTRACE;
 	if (newb)
 	{
 		if (markfordeletion)
@@ -135,6 +143,7 @@
 
 void Area::overwritebackgr(BITMAP *newb, double scale, int col)
 {
+  STACKTRACE;
 	if (newb && backgr)
 	{
 		clear_to_color(backgr, col);
@@ -147,12 +156,14 @@
 
 void Area::animate()
 {
+  STACKTRACE;
 	draw(backgr);
 }
 
 
 bool Area::hasmouse()
 {
+  STACKTRACE;
 	// the first rough check whether it's in the boxed bitmap area
 	return GraphicButton::hasmouse(backgr);
 }
@@ -160,6 +171,7 @@
 
 bool Area::isvalid()
 {
+  STACKTRACE;
 	return backgr != 0;
 };
 
@@ -176,6 +188,7 @@
 :
 Area(menu, identbranch, asciicode, akeepkey)
 {
+  STACKTRACE;
 
 	//init_pos_size(&backgr, "backgr");
 
@@ -197,6 +210,7 @@
 
 void AreaTablet::animate()
 {
+  STACKTRACE;
 	blit(backgr, drawarea, 0, 0, 0, 0, iround(size.x), iround(size.y));
 
 	subanimate();
@@ -208,6 +222,7 @@
 
 void AreaTablet::subanimate()
 {
+  STACKTRACE;
 	// nothing; you can put extra drawing commands here, stuff that's drawn onto
 	// the background before being blitted onto the reserved area.
 }
@@ -215,6 +230,7 @@
 
 bool AreaTablet::hasmouse()
 {
+  STACKTRACE;
 	// the first rough check whether it's in the boxed bitmap area
 	return GraphicButton::hasmouse(backgr);
 }
@@ -222,6 +238,7 @@
 
 bool AreaTablet::isvalid()
 {
+  STACKTRACE;
 	return backgr != 0;
 };
 
@@ -238,6 +255,7 @@
 :
 GraphicButton(menu, identbranch, asciicode)
 {
+  STACKTRACE;
 	init_pos_size(&bmp_on, "on");
 	bmp_off = getbmp("off");
 
@@ -252,6 +270,7 @@
 
 void SwitchButton::draw_default()
 {
+  STACKTRACE;
 	if (state)
 		draw(bmp_on);
 	else
@@ -260,6 +279,7 @@
 
 void SwitchButton::draw_focus()
 {
+  STACKTRACE;
 	draw_default();
 	draw_rect_fancy();
 }
@@ -267,12 +287,14 @@
 // is the same as focus, cause a switch cannot be selected all the time !!
 void SwitchButton::draw_selected()
 {
+  STACKTRACE;
 	draw_focus();
 }
 
 
 void SwitchButton::calculate()
 {
+  STACKTRACE;
 	GraphicButton::calculate();
 
 	// determine if the state of the button is being changed by (some) interaction:
@@ -283,6 +305,7 @@
 
 bool SwitchButton::hasmouse()
 {
+  STACKTRACE;
 	// the first rough check whether it's in the boxed bitmap area
 	return GraphicButton::hasmouse(bmp_on);
 }
@@ -290,6 +313,7 @@
 
 bool SwitchButton::isvalid()
 {
+  STACKTRACE;
 	return bmp_on != 0;
 };
 
@@ -302,6 +326,7 @@
 :
 EmptyButton(menu)
 {
+  STACKTRACE;
 	passive = true;
 }
 GhostButton::~GhostButton()
@@ -316,6 +341,7 @@
 :
 AreaTablet(menu, identbranch, 255)
 {
+  STACKTRACE;
 	relpos = 0.0;	// between 0 and 1
 
 	button = getbmp("button");
@@ -355,6 +381,7 @@
 
 void ScrollBar::handle_lhold()
 {
+  STACKTRACE;
 	if (direction == ver)
 		pbutton = iround(mainwindow->mpos.y - pos.y);		// mouse pos relative in the little bar area
 	else
@@ -372,6 +399,7 @@
 
 void ScrollBar::subanimate()
 {
+  STACKTRACE;
 	AreaTablet::subanimate();
 
 	if (direction == ver)
@@ -383,6 +411,7 @@
 
 void ScrollBar::setrelpos(double arelpos)
 {
+  STACKTRACE;
 	if (relpos == arelpos)
 		return;
 
@@ -395,6 +424,7 @@
 
 void ScrollBar::calculate()
 {
+  STACKTRACE;
 	AreaTablet::calculate();
 }
 

Modified: branches/multiplayer-branch/source/twgui/twgui.cpp
===================================================================
--- branches/multiplayer-branch/source/twgui/twgui.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/twgui/twgui.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -24,7 +24,6 @@
 
 #include "melee.h"
 #include "melee/mview.h"
-REGISTER_FILE
 
 #include "twgui.h"
 #include "twwindow.h"
@@ -39,18 +38,21 @@
 :
 AreaTablet(menu, identbranch, asciicode, akeepkey)
 {
+  STACKTRACE;
 	scroll.setup(mainwindow, identbranch);//, &scroll);
 }
 
 
 int AreaTabletScrolled::gety()
 {
+  STACKTRACE;
 	return scroll.yselect;
 }
 
 
 void AreaTabletScrolled::calculate()
 {
+  STACKTRACE;
 	AreaTablet::calculate();
 
 	scroll.calculate();
@@ -68,6 +70,7 @@
 :
 AreaTablet(menu, identbranch, 255)
 {
+  STACKTRACE;
 	usefont = afont;
 	text = 0;
 
@@ -82,6 +85,7 @@
 
 void TextButton::set_text(char *newtext, int color)
 {
+  STACKTRACE;
 	if (newtext)
 	{
 		if (text && strlen(text) < strlen(newtext))
@@ -101,6 +105,7 @@
 
 void TextButton::subanimate()
 {
+  STACKTRACE;
 	int xcentre, ycentre;
 
 	xcentre = iround(size.x / 2);
@@ -126,6 +131,7 @@
 :
 AreaTabletScrolled(menu, identbranch, 255)
 {
+  STACKTRACE;
 	usefont = afont;
 	Htxt = text_height(usefont);
 	text_color = makecol(0,0,0);
@@ -155,6 +161,7 @@
 
 void TextList::calculate()
 {
+  STACKTRACE;
 	AreaTablet::calculate();
 
 	scroll.calculate();
@@ -171,6 +178,7 @@
 
 void TextList::set_selected(int iy)
 {
+  STACKTRACE;
 //	yselected = iy;
 	if ( iy >= 0 && iy < N )
 		scroll.yselect = iy;
@@ -180,6 +188,7 @@
 
 void TextList::clear_optionlist()
 {
+  STACKTRACE;
 	int i;
 
 	if (optionlist)			// delete an existing set of strings first.
@@ -201,6 +210,7 @@
 
 void TextList::set_optionlist(char **aoptionlist, int color)
 {
+  STACKTRACE;
 	int aN;
 
 	// in this case, where the number of elements in the list isn't explicitly
@@ -217,6 +227,7 @@
 
 void TextList::set_optionlist(char **aoptionlist, int aN, int color)
 {
+  STACKTRACE;
 	int i;
 
 	clear_optionlist();		// note that this resets N .
@@ -250,6 +261,7 @@
 
 void TextList::add_optionlist(char *newstr)
 {
+  STACKTRACE;
 	if (!optionlist)
 	{
 		Nreserved = 128;
@@ -278,6 +290,7 @@
 // if the mouse is clicked within the window:
 void TextList::handle_lpress()
 {
+  STACKTRACE;
 
 	int iy;
 	
@@ -305,12 +318,14 @@
 
 int TextList::getk()
 {
+  STACKTRACE;
 	return scroll.yselect;
 }
 
 // select and center the list on "that" item
 void TextList::handle_rpress()
 {
+  STACKTRACE;
 	
 	int iy;
 	
@@ -330,6 +345,7 @@
 
 void TextList::subanimate()
 {
+  STACKTRACE;
 
 	if (!optionlist || N == 0)
 		return;				// if it's an empty list
@@ -393,6 +409,7 @@
 :
 AreaTabletScrolled(menu, identbranch, 255)
 {
+  STACKTRACE;
 	usefont = afont;
 //	Htxt = text_height(usefont);
 	text_color = makecol(0,0,0);
@@ -426,6 +443,7 @@
 // the following could be used for editing text that's stored elsewhere
 void TextInfoArea::set_textinfo_unbuffered(char *newtext, int Nchars)
 {
+  STACKTRACE;
 	if (textinfo)
 		delete textinfo;
 
@@ -440,6 +458,7 @@
 // other external factors.
 void TextInfoArea::set_textinfo(char *newtext, int Nchars)
 {
+  STACKTRACE;
 
 	if (localcopy)
 		delete localcopy;
@@ -458,6 +477,7 @@
 
 void TextInfoArea::set_textinfo(char *atextinfo)
 {
+  STACKTRACE;
 	set_textinfo(atextinfo, strlen(atextinfo));
 }
 
@@ -465,6 +485,7 @@
 
 void TextInfoArea::subanimate()
 {
+  STACKTRACE;
 
 	text_mode(-1);
 
@@ -529,6 +550,7 @@
 :
 TextInfoArea(menu, identbranch, afont, atext, amaxtext)
 {
+  STACKTRACE;
 	//usefont = afont;
 	text = atext;
 	maxchars = amaxtext;	// a short line?
@@ -575,6 +597,7 @@
 
 void TextEditBox::set_textcolor(int c)
 {
+  STACKTRACE;
 	text_color = c;
 }
 
@@ -584,6 +607,7 @@
 // if the mouse button was pressed .. update text pos to current mouse cursor pos.
 void TextEditBox::handle_lpress()
 {
+  STACKTRACE;
 	// but only if the enter-key wasn't pressed (that can also intiate this?)
 	if (keyhandler.keyhit[KEY_ENTER])
 		return;
@@ -616,6 +640,7 @@
 
 void TextEditBox::text_reset(char *newtext, int N)
 {
+  STACKTRACE;
 	textinfo->textinfo = newtext;
 	text = newtext;
 	textinfo->Nchars = N;
@@ -625,6 +650,7 @@
 
 void TextEditBox::text_reset()
 {
+  STACKTRACE;
 
 	textinfo->reset(&scroll);
 
@@ -644,6 +670,7 @@
 // this is, where text is detected and entered ... I think ....
 void TextEditBox::calculate()
 {
+  STACKTRACE;
 	if (textinfo->textinfo != text) {tw_error("text mismatch");}
 
 	TextInfoArea::calculate();
@@ -814,6 +841,7 @@
 
 void TextEditBox::subanimate()
 {
+  STACKTRACE;
 
 //	TextInfoArea::subanimate();
 
@@ -880,6 +908,7 @@
 
 char *TextEditBox::get_text()
 {
+  STACKTRACE;
 	return text;
 }
 
@@ -907,6 +936,7 @@
 :
 AreaTabletScrolled(menu, identbranch, akey)
 {
+  STACKTRACE;
 
 	scroll.set(0, 0, 1, 1, 1, 1);
 
@@ -946,6 +976,7 @@
 
 void MatrixIcons::set_iconinfo(BITMAP **alistIcon, double ascale)
 {
+  STACKTRACE;
 	listIcon = alistIcon;
 
 	// do nothing, if there are no data (doh)
@@ -991,6 +1022,7 @@
 // this is done just after mouse/key update, but before the handle* routines.
 void MatrixIcons::subcalculate()
 {
+  STACKTRACE;
 
 	// additionally, if there's mouse movement within this region, you should
 	// override settings of the scroll menu, namely, which particular icon is
@@ -1006,6 +1038,7 @@
 
 void MatrixIcons::subanimate()
 {
+  STACKTRACE;
 
 	int i, j;
 	int ix, iy;
@@ -1066,6 +1099,7 @@
 // this action is used to scroll left/right/up/down
 void MatrixIcons::handle_rpress()
 {
+  STACKTRACE;
 	int mx, my;
 	
 	// mouse position relative to the center of the item window:
@@ -1080,12 +1114,14 @@
 // select some icon :
 void MatrixIcons::handle_lpress()
 {
+  STACKTRACE;
 	selected = true;
 }
 
 
 int MatrixIcons::getk()
 {
+  STACKTRACE;
 	int k;
 	k = scroll.xselect + scroll.yselect * Nx;
 

Modified: branches/multiplayer-branch/source/twgui/twhelpers.cpp
===================================================================
--- branches/multiplayer-branch/source/twgui/twhelpers.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/twgui/twhelpers.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -22,9 +22,7 @@
 
 
 #include "melee.h"
-//#include "melee/mview.h"
 
-REGISTER_FILE
 
 #include "twbutton.h"
 #include "twwindow.h"
@@ -34,6 +32,7 @@
 
 ScrollControl::ScrollControl()
 {
+  STACKTRACE;
 	x = 0;
 	y = 0;
 
@@ -49,6 +48,7 @@
 void ScrollControl::set(int xscroll, int yscroll, int Nxscroll, int Nyscroll,
 						int Nx_show, int Ny_show)
 {
+  STACKTRACE;
 	x = xscroll;	// this is top-left corner item of the visible screen
 	y = yscroll;
 
@@ -76,6 +76,7 @@
 
 void ScrollControl::check_pos()
 {
+  STACKTRACE;
 	// check the scroll position
 	if (x > Nx-1)
 		x = Nx-1;
@@ -108,6 +109,7 @@
 
 void ScrollControl::add(int dx, int dy)
 {
+  STACKTRACE;
 	x += dx;
 	y += dy;
 
@@ -118,6 +120,7 @@
 
 void ScrollControl::check_sel()
 {
+  STACKTRACE;
 	if (xselect < x)
 		x = xselect;
 
@@ -135,6 +138,7 @@
 
 void ScrollControl::set_sel(int xsel, int ysel)
 {
+  STACKTRACE;
 	xselect = xsel;
 	yselect = ysel;
 
@@ -147,18 +151,21 @@
 // alpha is a value between 0 and 1
 void ScrollControl::set_percent_pos_x(double alpha)
 {
+  STACKTRACE;
 	x = iround( (Nx-1) * alpha );
 	check_pos();
 }
 
 void ScrollControl::set_percent_pos_y(double alpha)
 {
+  STACKTRACE;
 	y = iround( (Ny-1) * alpha );
 	check_pos();
 }
 
 void ScrollControl::set_pos(int xnew, int ynew)
 {
+  STACKTRACE;
 	if ( xnew >= 0 && xnew < Nx && ynew >= 0 && ynew < Ny )
 	{
 		x = xnew;
@@ -177,6 +184,7 @@
 // vertical, or a default value.
 double ScrollControl::get_relpos()
 {
+  STACKTRACE;
 	if (scrollhor)
 		return scrollhor->relpos;
 	if (scrollvert)
@@ -188,6 +196,7 @@
 
 void ScrollControl::calculate()
 {
+  STACKTRACE;
 	int xold, yold;
 
 	xold = x;
@@ -249,6 +258,7 @@
 								EmptyButton *aup, EmptyButton *adown,
 								ScrollBar *ascrollhor, ScrollBar *ascrollvert)
 {
+  STACKTRACE;
 	left = aleft;
 	right = aright;
 	up = aup;
@@ -357,6 +367,7 @@
 
 TextInfo::TextInfo(FONT *afont, BITMAP *abmp, char *atextinfo, int aNchars)
 {
+  STACKTRACE;
 	bmp = abmp;
 	usefont = afont;
 	textinfo = atextinfo;
@@ -376,6 +387,7 @@
 
 void TextInfo::reset(ScrollControl *scroll)
 {
+  STACKTRACE;
 
 	// "initialize" the text:
 	int n, len;
@@ -460,6 +472,7 @@
 // go from line-coordinate to bitmap coordinate
 void TextInfo::getxy(int charpos, int *x, int *y)
 {
+  STACKTRACE;
 	int iline;
 
 	iline = 0;
@@ -495,6 +508,7 @@
 // map (x) coordinate to character number
 int TextInfo::getcharpos(char *scantxt, int x, int max)
 {
+  STACKTRACE;
 	int i;
 	i = 0;
 
@@ -525,6 +539,7 @@
 // map (x,y) coordinate to character number
 int TextInfo::getcharpos(int x, int y)
 {
+  STACKTRACE;
 	int iline;
 
 	iline = y / Htxt;
@@ -565,6 +580,7 @@
 
 void TextInfo::changeline(int *charpos, int line1, int line2)
 {
+  STACKTRACE;
 
 	if (line2 > Nlines-1)
 		line2 = Nlines-1;

Modified: branches/multiplayer-branch/source/twgui/twmenuexamples.cpp
===================================================================
--- branches/multiplayer-branch/source/twgui/twmenuexamples.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/twgui/twmenuexamples.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -23,8 +23,6 @@
 
 #include "melee.h"
 
-REGISTER_FILE
-
 #include "twbutton.h"
 #include "twwindow.h"
 
@@ -42,6 +40,7 @@
 :
 PopupT(creator, ident, axshift, ayshift)
 {
+  STACKTRACE;
 	// add a text list box
 	tia = new TextInfoArea(this, id2, afont, atext, aNchar);//, &scroll);
 	//tia->set_textinfo(atext, aNchar);
@@ -64,6 +63,7 @@
 
 void PopupTextInfo::check_end()
 {
+  STACKTRACE;
 	if (closebutton->flag.left_mouse_press)
 		close(-1);
 }
@@ -77,12 +77,14 @@
 :
 PopupTextInfo(creator, ident, id2, axshift, ayshift, afont, atext, aNchar)
 {
+  STACKTRACE;
 };
 
 
 
 void PopupTextInfo_toggle::calculate()
 {
+  STACKTRACE;
 	PopupTextInfo::calculate();
 }
 
@@ -106,6 +108,7 @@
 :
 PopupT(ident, axshift, ayshift, outputscreen)
 {
+  STACKTRACE;
 	tbl = new TextList(this, id2, afont);
 	tbl->set_optionlist(aoptionslist, makecol(0,0,0));
 
@@ -118,6 +121,7 @@
 :
 PopupT(atrigger, ident, axshift, ayshift)
 {
+  STACKTRACE;
 	//optionslist = aoptionslist;
 
 	// add a text list box
@@ -142,6 +146,7 @@
 // this calls close with return value
 void PopupList::check_end()
 {
+  STACKTRACE;
 	PopupT::check_end();		// this is also a way to end (without choosing anything)
 
 	if (tbl->selected)
@@ -166,6 +171,7 @@
 :
 Popup(ident, axshift, ayshift, outputscreen)
 {
+  STACKTRACE;
 
 	icons = new MatrixIcons(this, "icon_", KEY_ENTER);
 
@@ -200,6 +206,7 @@
 // (the general close is ok, it closes and hides the menu).
 void PopupFleetSelection::check_end()
 {
+  STACKTRACE;
 	if (icons->selected)
 		close(icons->getk());
 }
@@ -208,6 +215,7 @@
 
 void PopupFleetSelection::newscan(BITMAP **alistIcon, double ascale, char *txt)
 {
+  STACKTRACE;
 	Popup::newscan();
 	icons->set_iconinfo(alistIcon, ascale);
 	info->set_text(txt, makecol(255,255,0));
@@ -220,6 +228,7 @@
 // let the "main" routine determine whether to stop or not ;)
 void PopupFleetSelection::check_end()
 {
+  STACKTRACE;
 	if (icons->selected)
 		close(icons->getk());
 }
@@ -240,6 +249,7 @@
 			xcenter, ycenter,
 			outputscreen)
 {
+  STACKTRACE;
 	yes = new Button(this, "yes_",KEY_Y);
 
 	no = new Button(this, "no_", KEY_N);
@@ -253,6 +263,7 @@
 
 void PopupYN::check_end()
 {
+  STACKTRACE;
 	if (yes->flag.left_mouse_press)
 		close(1);
 	if (no->flag.left_mouse_press)
@@ -274,6 +285,7 @@
 			xcenter, ycenter,
 			outputscreen)
 {
+  STACKTRACE;
 	ok = new Button(this, "ok_", KEY_ENTER);
 
 	exclusive = true;
@@ -285,6 +297,7 @@
 
 void PopupOk::check_end()
 {
+  STACKTRACE;
 	if (ok->flag.left_mouse_press)
 		close(1);
 }
@@ -302,6 +315,7 @@
 :
 PopupList(creator, ident, "list_", axshift, ayshift, afont, 0)
 {
+  STACKTRACE;
 	strcpy(dir, ".");	// you can't get below this (which is the game directory)
 	strcpy(fname, "none");
 
@@ -323,6 +337,7 @@
 
 void FileBrowser::set_dir(char *newdir)
 {
+  STACKTRACE;
 	strcpy(dir, newdir);
 	reset_dirlist();
 }
@@ -331,6 +346,7 @@
 
 void FileBrowser::set_ext(char *ext)
 {
+  STACKTRACE;
 	strcpy(required_ext, ".");
 	strcat(required_ext, ext);
 }
@@ -338,6 +354,7 @@
 
 void FileBrowser::reset_dirlist()
 {
+  STACKTRACE;
 	int err;
 	al_ffblk info;
 	
@@ -390,6 +407,7 @@
 
 void FileBrowser::calculate()
 {
+  STACKTRACE;
 	PopupList::calculate();
 
 	if (disabled)
@@ -440,6 +458,7 @@
 // this calls close with return value
 void FileBrowser::check_end()
 {
+  STACKTRACE;
 	if (selection)
 	{
 		selection = false;
@@ -467,6 +486,7 @@
 
 void ValueStr::set(valuetypes atype, char *adescr, double amin, double amax)
 {
+  STACKTRACE;
 	type = atype;
 	strncpy(descr, adescr, sizeof(descr)-1);
 	min = amin;
@@ -482,6 +502,7 @@
 
 double ValueStr::getval()
 {
+  STACKTRACE;
 	if (type == vtype_float)
 		return value;
 	else
@@ -495,6 +516,7 @@
 :
 EmptyButton(menu, identbranch)
 {
+  STACKTRACE;
 	Nmax = aNmax;
 	values = new ValueStr* [Nmax];
 
@@ -540,12 +562,14 @@
 
 void ValueEdit::edit_update()
 {
+  STACKTRACE;
 	sprintf(edit->text, values[isel]->format, values[isel]->value);
 }
 
 
 void ValueEdit::calculate()
 {
+  STACKTRACE;
 	EmptyButton::calculate();
 
 	// the scrollbar:

Modified: branches/multiplayer-branch/source/twgui/twpopup.cpp
===================================================================
--- branches/multiplayer-branch/source/twgui/twpopup.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/twgui/twpopup.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -22,11 +22,8 @@
 
 
 #include "melee.h"
-//#include "melee/mview.h"
 
-REGISTER_FILE
 
-
 #include "twbutton.h"
 #include "twpopup.h"
 
@@ -40,6 +37,7 @@
 :
 TWindow(ident, xcenter, ycenter, outputscreen)
 {
+  STACKTRACE;
 	movingthereserve = false;
 
 	center(xcenter, ycenter);		// center around this position, in relative coordinates
@@ -54,6 +52,7 @@
 
 void Popup::doneinit()
 {
+  STACKTRACE;
 	TWindow::doneinit();
 
 	hide();
@@ -64,12 +63,14 @@
 // (the general close is ok, it closes and hides the menu).
 void Popup::check_end()
 {
+  STACKTRACE;
 	// nothing
 }
 
 
 void Popup::calculate()
 {
+  STACKTRACE;
 	// must be called before the "return", otherwise focus-loss isn't called
 	TWindow::calculate();
 
@@ -122,6 +123,7 @@
 
 void Popup::close(int areturnstatus)
 {
+  STACKTRACE;
 	hide();
 
 	returnstatus = areturnstatus;
@@ -133,6 +135,7 @@
 // resets its "ready" status as well.
 bool Popup::ready()
 {
+  STACKTRACE;
 	if (returnvalueready)
 	{
 		returnvalueready = false;
@@ -144,6 +147,7 @@
 // call this to get a int-value from some selection mechanism (eg a list)
 int Popup::getvalue()
 {
+  STACKTRACE;
 //	if (!returnvalueready)
 //		return -1;				// otherwise it's undefined
 
@@ -155,6 +159,7 @@
 // restore the ability to do calculations and actions
 void Popup::enable()
 {
+  STACKTRACE;
 	TWindow::enable();
 	returnvalueready = false;
 }
@@ -163,6 +168,7 @@
 
 void Popup::newscan()
 {
+  STACKTRACE;
 	show();	// (more general than enable)
 	ready();
 }
@@ -195,6 +201,7 @@
 :
 Popup(identbranch, axshift, ayshift, outputscreen)
 {
+  STACKTRACE;
 	trigger = 0;
 
 	init_components(identbranch);
@@ -209,6 +216,7 @@
 			axshift, ayshift,
 			atrigger->mainwindow->screen)
 {
+  STACKTRACE;
 	trigger = atrigger;
 
 	init_components(identbranch);
@@ -221,6 +229,7 @@
 
 void PopupT::init_components(char *id)
 {
+  STACKTRACE;
 	returnvalueready = false;
 
 	// and default option settings:
@@ -257,6 +266,7 @@
 
 void PopupT::calculate()
 {
+  STACKTRACE;
 	// must be called before the "return", otherwise focus-loss isn't called
 	Popup::calculate();
 
@@ -322,6 +332,7 @@
 
 void PopupT::handle_focus_loss()
 {
+  STACKTRACE;
 	/*
 	if (!close_on_defocus)
 		return;
@@ -338,6 +349,7 @@
 
 void PopupT::close(int areturnstatus)
 {
+  STACKTRACE;
 	if (trigger)
 	{
 		// give back focus/control to the window that called this window.
@@ -356,6 +368,7 @@
 // you can (and should) replace this routine with one suited for your own purposes
 void PopupT::check_end()
 {
+  STACKTRACE;
 //	if (!hidden && !hasfocus && close_on_defocus)	// to prevent this from being called twice, due to recursive call to handle_focus() in hide()
 //	{
 		//tw_error("PopupList : Losing focus !!");

Modified: branches/multiplayer-branch/source/twgui/twwindow.cpp
===================================================================
--- branches/multiplayer-branch/source/twgui/twwindow.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/twgui/twwindow.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -24,7 +24,6 @@
 //#include "melee/mview.h"
 #include "other/twconfig.h"
 
-REGISTER_FILE
 
 
 #include "twwindow.h"
@@ -48,6 +47,7 @@
 // this is used to scale them to other screen resolutions.
 TWindow::TWindow(char *identbase, int dx, int dy, BITMAP *outputscreen, bool vidwin)
 {
+  STACKTRACE;
 	prev = 0;
 	next = 0;
 
@@ -225,6 +225,7 @@
 
 TWindow *TWindow::tree_root()
 {
+  STACKTRACE;
 	TWindow *current;
 	current = this;
 	while (current->prev)
@@ -236,6 +237,7 @@
 
 TWindow *TWindow::tree_last()
 {
+  STACKTRACE;
 	TWindow *current;
 	current = this;
 	while (current->next)
@@ -248,6 +250,7 @@
 
 void TWindow::tree_calculate()
 {
+  STACKTRACE;
 	TWindow *current;
 	current = tree_root();
 
@@ -274,6 +277,7 @@
 
 void TWindow::tree_animate()
 {
+  STACKTRACE;
 	TWindow *current;
 	current = tree_last();
 
@@ -293,6 +297,7 @@
 
 void TWindow::focus()
 {
+  STACKTRACE;
 	// no need if this already is the root ... cause then it already has the focus.
 	if (!prev)
 		return;
@@ -324,6 +329,7 @@
 
 void TWindow::tree_setscreen(BITMAP *scr)
 {
+  STACKTRACE;
 	TWindow *current;
 	current = tree_root();
 
@@ -339,6 +345,7 @@
 // add a window at the end of the window list
 void TWindow::add(TWindow *newwindow)
 {
+  STACKTRACE;
 	TWindow *current;
 	current = this;
 	while (current->next)
@@ -352,6 +359,7 @@
 // call all the clean up routines for all the menus
 void TWindow::tree_doneinit()
 {
+  STACKTRACE;
 	TWindow *current;
 	current = tree_root();
 
@@ -366,6 +374,7 @@
 
 bool TWindow::hasfocus()
 {
+  STACKTRACE;
 	// only the root has primary focus...
 	return (prev != 0);
 }
@@ -388,6 +397,7 @@
 
 BITMAP* TWindow::bmp(char *bmpname, bool vidmem)
 {
+  STACKTRACE;
 	BITMAP *bmp, *tmpbmp;
 	int bpp;
 
@@ -418,12 +428,14 @@
 
 void TWindow::doneinit()
 {
+  STACKTRACE;
 	del_bitmap(&backgr_forsearch);
 	//if (datafile)			unload_datafile(datafile);
 }
 
 void TWindow::setscreen(BITMAP *scr)
 {
+  STACKTRACE;
 	screen = scr;
 }
 
@@ -431,6 +443,7 @@
 
 void TWindow::center(int xcenter, int ycenter)
 {
+  STACKTRACE;
 	// put back the background
 	//blit(originalscreen, screen, 0, 0, x, y, W, H);
 
@@ -447,6 +460,7 @@
 
 void TWindow::center_abs(int xcenter, int ycenter)
 {
+  STACKTRACE;
 	// put back the background
 	//blit(originalscreen, screen, 0, 0, x, y, W, H);
 
@@ -460,6 +474,7 @@
 
 void TWindow::center()
 {
+  STACKTRACE;
 	ASSERT(screen)
 	center(screen->w/2, screen->h/2);
 }
@@ -468,12 +483,14 @@
 // changes the "disabled" flag, and possibly does other stuff as well?
 void TWindow::enable()
 {
+  STACKTRACE;
 	disabled = false;
 //	mouse.reset();		// reset the mouse to the newest values.
 }
 
 void TWindow::disable()
 {
+  STACKTRACE;
 	if (!disabled)				// to prevent possible recursive call (disable can be called within focus loss in some cases...)
 	{
 		disabled = true;
@@ -485,6 +502,7 @@
 
 void TWindow::show()
 {
+  STACKTRACE;
 	hidden = false;	// allow animation
 	enable();		// allow calculation
 	focus();		// bring this window to the front of the list, so that it draws on top of the rest
@@ -492,6 +510,7 @@
 
 void TWindow::hide()
 {
+  STACKTRACE;
 	hidden = true;
 	disable();
 	//blit(originalscreen, screen, 0, 0, 0, 0, W, H);
@@ -501,6 +520,7 @@
 
 void TWindow::add(EmptyButton *newbutton)
 {
+  STACKTRACE;
 	if (!button_first)
 	{
 		button_first = newbutton;
@@ -516,6 +536,7 @@
 
 void TWindow::rem(EmptyButton *newbutton)
 {
+  STACKTRACE;
 	if (! newbutton)
 		return;
 
@@ -543,6 +564,7 @@
 
 bool TWindow::checkmouse()
 {
+  STACKTRACE;
 	if (!(prev && prev->grabbedmouse))
 	{
 		// If the mouse hasn't been "grabbed" by a window above this window
@@ -570,6 +592,7 @@
 
 void TWindow::setfocus(EmptyButton *newbutton)
 {
+  STACKTRACE;
 	if (button_focus)
 		button_focus->handle_defocus();
 
@@ -583,6 +606,7 @@
 
 void TWindow::calculate()
 {
+  STACKTRACE;
 
 	if (disabled)
 	{
@@ -713,6 +737,7 @@
 
 void TWindow::animate()
 {
+  STACKTRACE;
 
 	if (hidden)
 		return;
@@ -762,6 +787,7 @@
 
 void TWindow::handle_focus()
 {
+  STACKTRACE;
 	// bring it first in the list ...
 	focus();
 }
@@ -769,6 +795,7 @@
 
 void TWindow::handle_focus_loss()
 {
+  STACKTRACE;
 	//for (int i = 0; i < Nareas; ++i )
 	//	area[i]->handle_menu_focus_loss();
 	EmptyButton *button;
@@ -784,12 +811,14 @@
 
 void TWindow::scalepos(int *ax, int *ay)
 {
+  STACKTRACE;
 	(*ax) = iround( (*ax) * scale );
 	(*ay) = iround( (*ay) * scale );
 }
 
 void TWindow::scalepos(Vector2 *apos)
 {
+  STACKTRACE;
 	(apos->x) = iround( (apos->x) * scale );
 	(apos->y) = iround( (apos->y) * scale );
 }
@@ -839,6 +868,7 @@
 
 bool TWindow::search_bmp_location(BITMAP *bmp_default, Vector2 *apos)
 {
+  STACKTRACE;
 	ASSERT(bmp_default);
 	ASSERT(apos);
 	
@@ -909,6 +939,7 @@
 /*
 void TWindow::focus2other(TWindow *other)
 {
+  STACKTRACE;
 	disable();			// this menu won't generate signals now, but it'll be drawn still
 	other->show();
 	other->prev = this;
@@ -916,6 +947,7 @@
 
 void TWindow::back2other()
 {
+  STACKTRACE;
 	prev->enable();			// switch control back to the meleemenu
 	hide();					// this menu is disabled, and won't be drawn
 	prev = 0;
@@ -925,17 +957,20 @@
 
 void TWindow::update_time()
 {
+  STACKTRACE;
 	menu_time = get_time() - menu_starttime;
 }
 
 /*
 void TWindow::clear_keys()
 {
+  STACKTRACE;
 	keybuff_count = 0;
 }
 
 void TWindow::add_key(int akey)
 {
+  STACKTRACE;
 	if (disabled)
 		return;
 
@@ -949,6 +984,7 @@
 
 void TWindow::add_keys()
 {
+  STACKTRACE;
 	if (keyboard_needs_poll())
 		poll_keyboard();
 

Modified: branches/multiplayer-branch/source/twgui/utils.cpp
===================================================================
--- branches/multiplayer-branch/source/twgui/utils.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/twgui/utils.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -42,138 +42,128 @@
 // note, separated are the "key" and the extra "control" key (ctrl, alt)
 int mapkey(int scancode_key, int scancode_ctrl)
 {
-	int k;
+  int k;
 
-	k = scancode_key;
+  k = scancode_key;
 
-	k |= scancode_ctrl << 8;
-	
-	// thus we have 2 scan codes, no more needed.
-	return k;
+  k |= scancode_ctrl << 8;
+  
+  // thus we have 2 scan codes, no more needed.
+  return k;
 }
 
 int unmapkey1(int k)
 {
-	// return the 1st scancode
-	return k & 0x0FF;
+  // return the 1st scancode
+  return k & 0x0FF;
 }
 
 int unmapkey2(int k)
 {
-	// return the 1st scancode
-	return (k >> 8) & 0x0FF;
+  // return the 1st scancode
+  return (k >> 8) & 0x0FF;
 }
 
 
 BITMAP *find_datafile_bmp(DATAFILE *datafile, char *identif)
 {
-	char objname[128];
+  char objname[128];
+  
+  if (strlen(identif) > 120)
+    {
+      tw_error("string exceeds max length");
+    }
+  
+  strcpy(objname, identif);
+  strcat(objname, "_BMP");	// default extension for .bmp files.
 
-	if (strlen(identif) > 120)
-	{
-		tw_error("string exceeds max length");
-	}
+  DATAFILE *dat = find_datafile_object(datafile, objname);
 
-	strcpy(objname, identif);
-	strcat(objname, "_BMP");	// default extension for .bmp files.
-
-	DATAFILE *dat = find_datafile_object(datafile, objname);
-
-	if (!dat)
-	{
-		//char txt[512];
-		//sprintf(txt, "Could not find %s", objname);
-		//tw_error(txt);
-		return 0;
-	}
-
-	if (dat->type == DAT_BITMAP)
-		return (BITMAP*) dat->dat;
-	else
-		return 0;
+  if (!dat)
+    {
+      //char txt[512];
+      //sprintf(txt, "Could not find %s", objname);
+      //tw_error(txt);
+      return 0;
+    }
+  
+  if (dat->type == DAT_BITMAP)
+    return (BITMAP*) dat->dat;
+  else
+    return 0;
 }
 
 
 BITMAP *clone_bitmap(int bpp, BITMAP *src, double scale, bool vidmem)
 {
-	BITMAP *dest, *convert;
+  BITMAP *dest, *convert;
+  
+  if ( !src )
+    return 0;
 
-	if ( !src )
-		return 0;
+  int W, H;
+  
+  W = iround( src->w * scale );
+  H = iround( src->h * scale );
+  
+  dest = create_bitmap_ex(bpp, W, H);
+  
+  convert = create_bitmap_ex(bpp, src->w, src->h);
+  blit(src, convert, 0, 0, 0, 0, src->w, src->h);		// use this to convert color depth
+  
+  if (W != src->w || H != src->h )
+    stretch_blit(convert, dest, 0, 0, convert->w, convert->h, 0, 0, dest->w, dest->h);
+  else
+    blit(convert, dest, 0, 0, 0, 0, W, H);
+  
+  del_bitmap(&convert);
 
-	int W, H;
 
-	W = iround( src->w * scale );
-	H = iround( src->h * scale );
-
-	dest = create_bitmap_ex(bpp, W, H);
-
-	convert = create_bitmap_ex(bpp, src->w, src->h);
-	blit(src, convert, 0, 0, 0, 0, src->w, src->h);		// use this to convert color depth
-
-	if (W != src->w || H != src->h )
-		stretch_blit(convert, dest, 0, 0, convert->w, convert->h, 0, 0, dest->w, dest->h);
-	else
-		blit(convert, dest, 0, 0, 0, 0, W, H);
-
-	del_bitmap(&convert);
-
-
 	
-	// try to store this in memory, if there's enough room for it
-	// cause the menu-bitmaps are pretty large, and take lotsa time to draw ...
-	if (vidmem)
+  // try to store this in memory, if there's enough room for it
+  // cause the menu-bitmaps are pretty large, and take lotsa time to draw ...
+  if (vidmem)
+    {
+      convert = create_video_bitmap(W, H);
+      if (convert)
 	{
-		convert = create_video_bitmap(W, H);
-		if (convert)
-		{
-			blit(dest, convert, 0, 0, 0, 0, W, H);
-			del_bitmap(&dest);
-			dest = convert;
-		}
+	  blit(dest, convert, 0, 0, 0, 0, W, H);
+	  del_bitmap(&dest);
+	  dest = convert;
 	}
+    }
 	
-
-	return dest;
+  
+  return dest;
 }
 
-
-
-
-
-
-
-
-
-
-
 normalmouse::normalmouse()
 {
-	bmp.original_mouse_sprite = mouse_sprite;
-	bmp.newmousebmp = 0;
+  bmp.original_mouse_sprite = mouse_sprite;
+  bmp.newmousebmp = 0;
 
-	reset();
+  reset();
 }
 
 
 void normalmouse::reset()
 {
-	update();		// initialize with current mouse values.
-	pos2 = pos;
-	oldpos = pos;
+  update();		// initialize with current mouse values.
+  pos2 = pos;
+  oldpos = pos;
 }
 
 
 void normalmouse::copyinfo(normalmouse *othermouse)
 {
-	pos    = othermouse->pos;
-	oldpos = othermouse->oldpos;
-	pos2 = othermouse->pos2;
-	left   = othermouse->left;
-	mid    = othermouse->mid;
-	right  = othermouse->right;
-	bmp.newmousebmp = othermouse->bmp.newmousebmp;
-	bmp.original_mouse_sprite = othermouse->bmp.original_mouse_sprite;
+  pos    = othermouse->pos;
+  oldpos = othermouse->oldpos;
+  pos2 = othermouse->pos2;
+  left   = othermouse->left;
+  mid    = othermouse->mid;
+  right  = othermouse->right;
+  bmp.newmousebmp = othermouse->bmp.newmousebmp;
+  bmp.original_mouse_sprite = othermouse->bmp.original_mouse_sprite;
 }
 
 
@@ -182,134 +172,133 @@
 // (unmoved) position every iteration.
 void normalmouse::move(int dx, int dy)
 {
-	pos.x += dx;
-	pos.y += dy;
-
-	oldpos.x += dx;
-	oldpos.y += dy;
+  pos.x += dx;
+  pos.y += dy;
+	
+  oldpos.x += dx;
+  oldpos.y += dy;
 }
 
 int normalmouse::vx()
 {
-	return pos.x - oldpos.x;
+  return pos.x - oldpos.x;
 }
 
 int normalmouse::vy()
 {
-	return pos.y - oldpos.y;
+  return pos.y - oldpos.y;
 }
 
 
 void normalmouse::update()
 {
-	if (mouse_needs_poll())
-		poll_mouse();
+  if (mouse_needs_poll())
+    poll_mouse();
 	
-	oldpos = pos2;	// this is exactly the "old" position, unmoved
-	pos.set(mouse_x, mouse_y, mouse_z);
-	pos2 = pos;
-
-	int b = mouse_b;
-
-	left.update(bool(b & 1));		// make distinction here; individual buttons shouldn't know of each other
-	mid.update(bool(b & 4));
-	right.update(bool(b & 2));
+  oldpos = pos2;	// this is exactly the "old" position, unmoved
+  pos.set(mouse_x, mouse_y, mouse_z);
+  pos2 = pos;
+  
+  int b = mouse_b;
+  
+  left.update(bool(b & 1));		// make distinction here; individual buttons shouldn't know of each other
+  mid.update(bool(b & 4));
+  right.update(bool(b & 2));
 }
 
 
 void normalmouse::mousebutton::update(bool newstatus)
 {
-	// we are mainly interested in changes in the button status.
-	if (newstatus != button.status)
-	{
-		oldbutton = button;
-	
-		button.status = newstatus;	// on or of ;)
+  // we are mainly interested in changes in the button status.
+  if (newstatus != button.status)
+    {
+      oldbutton = button;
+      
+      button.status = newstatus;	// on or of ;)
 
-		if (button.status != oldbutton.status)
-			button.time = get_time() * 1E-3;				// detect timing of a change in button status
-
-		button.change = true;
-
-	} else
-		button.change = false;
+      if (button.status != oldbutton.status)
+	button.time = get_time() * 1E-3;				// detect timing of a change in button status
+      
+      button.change = true;
+      
+    } else
+      button.change = false;
 }
 
 
 
 bool normalmouse::mousebutton::press()
 {
-	if (!button.change)
-		return false;
-
-	if (button.status && (!oldbutton.status))
-		return true;
-	else 
-		return false;
-
+  if (!button.change)
+    return false;
+  
+  if (button.status && (!oldbutton.status))
+    return true;
+  else 
+    return false;
 }
 
 bool normalmouse::mousebutton::release()
 {
-	if (!button.change)
-		return false;
-
-	if ((!button.status) && oldbutton.status)
-		return true;
-	else 
-		return false;
+  if (!button.change)
+    return false;
+  
+  if ((!button.status) && oldbutton.status)
+    return true;
+  else 
+    return false;
 }
 
 bool normalmouse::mousebutton::dclick()
 {
-	if (!button.change)		// check if the mouse is clicked
-		return false;
+  if (!button.change)		// check if the mouse is clicked
+    return false;
+  
+  if (!button.status)		// check if the mouse button is pressed
+    return false;
+  
+  if (button.time - oldbutton.time < 0.2)	// check time between release and press
+    return true;
+  
 
-	if (!button.status)		// check if the mouse button is pressed
-		return false;
-
-	if (button.time - oldbutton.time < 0.2)	// check time between release and press
-		return true;
-	
-
-	return false;
+  return false;
 }
 
 bool normalmouse::mousebutton::hold()
 {
-	return button.status;
+  return button.status;
 }
 
 
 void normalmouse::bmpstr::init(BITMAP *newbmp)
 {
-	newmousebmp = newbmp;
+  newmousebmp = newbmp;
 }
 
 void normalmouse::bmpstr::set()
 {
-	if (newmousebmp)
-	{
-		set_mouse_sprite(newmousebmp);
-	}
+  if (newmousebmp)
+    {
+      set_mouse_sprite(newmousebmp);
+    }
 }
 
 void normalmouse::bmpstr::restore()
 {
-	set_mouse_sprite(original_mouse_sprite);
+  set_mouse_sprite(original_mouse_sprite);
 }
 
 void normalmouse::posstr::set(int xnew, int ynew, int znew)
 {
-	x = xnew;
-	y = ynew;
-	wheel = znew;
+  x = xnew;
+  y = ynew;
+  wheel = znew;
 }
 
 void normalmouse::posstr::move(int dx, int dy)
 {
-	x += dx;
-	y += dy;
+  x += dx;
+  y += dy;
 }
 
 
@@ -332,42 +321,42 @@
 // just make a copy of the input.
 static int my_callback(int key)
 {
-	keyhandler.add(key);
-	return key;
+  keyhandler.add(key);
+  return key;
 }
 
 
 
 TKeyHandler::TKeyHandler()
 {
-	keyboard_callback = my_callback;
-
-	clear();
+  keyboard_callback = my_callback;
+  
+  clear();
 }
 
 
 void TKeyHandler::clear()
 {
-	Nbuf = 0;
-	Nbackbuf = 0;
-
-	int i;
-	for ( i = 0; i < KEY_MAX; ++i )
-	{
-		keynew[i] = key[i];
-		keyold[i] = key[i];
-	}
+  Nbuf = 0;
+  Nbackbuf = 0;
+  
+  int i;
+  for ( i = 0; i < KEY_MAX; ++i )
+    {
+      keynew[i] = key[i];
+      keyold[i] = key[i];
+    }
 }
 
 
 void TKeyHandler::add(int key)
 {
-	if (Nbackbuf >= buffmax)
-		return;
-
-	keybackbuf[Nbackbuf] = key;
-
-	++Nbackbuf;
+  if (Nbackbuf >= buffmax)
+    return;
+  
+  keybackbuf[Nbackbuf] = key;
+  
+  ++Nbackbuf;
 }
 
 void TKeyHandler::clearbuf()
@@ -378,64 +367,64 @@
 
 void TKeyHandler::update()
 {
-	if (keyboard_needs_poll())
-		poll_keyboard();
-
-	// detect key changes ...
-	// (note that changes in-between updates are not seen by this so it's not 100% accurate)
-	int i;
-	for ( i = 0; i < KEY_MAX; ++i )
+  if (keyboard_needs_poll())
+    poll_keyboard();
+  
+  // detect key changes ...
+  // (note that changes in-between updates are not seen by this so it's not 100% accurate)
+  int i;
+  for ( i = 0; i < KEY_MAX; ++i )
+    {
+      // keep record of prev and new states
+      keyold[i] = keynew[i];
+      keynew[i] = key[i];
+      
+      // detect changes
+      keyhit[i] = 0;
+      keyreleased[i] = 0;
+      
+      if (keynew[i] != keyold[i])
 	{
-		// keep record of prev and new states
-		keyold[i] = keynew[i];
-		keynew[i] = key[i];
-
-		// detect changes
-		keyhit[i] = 0;
-		keyreleased[i] = 0;
-
-		if (keynew[i] != keyold[i])
-		{
-			if (keynew[i])
-				keyhit[i] = 1;
-			else
-				keyreleased[i] = 1;
-		}
-
+	  if (keynew[i])
+	    keyhit[i] = 1;
+	  else
+	    keyreleased[i] = 1;
 	}
-
-
-	Nbuf = Nbackbuf;
-	for ( i = 0; i < Nbuf; ++i )
-	{
-		keybuf[i] = keybackbuf[i];
-	}
-	// reset the back-buffer for reading new stuf.
-	Nbackbuf = 0;
-
+      
+    }
+  
+  
+  Nbuf = Nbackbuf;
+  for ( i = 0; i < Nbuf; ++i )
+    {
+      keybuf[i] = keybackbuf[i];
+    }
+  // reset the back-buffer for reading new stuf.
+  Nbackbuf = 0;
+  
 }
 
 
 bool TKeyHandler::pressed(char key)
 {
-	// only compare if the key != 0, otherwise you can get matches with
-	// wierd key combos or something. So, key==0 has the meaning of, don't compare me!
-	if (key == 0)
-		return false;
-
-	//char teststring[128];
-	int i;
-	for (i = 0; i < Nbuf; ++i)
-	{
-		//teststring[i] = keybuf[i] & 0x0FF;
-
-		if ( (keybuf[i] & 0x0FF) == key )	// only compare by ascii code...
-			return true;
-	}
-
-	//teststring[i] = 0;
-	//message.out(teststring);
-
-	return false;
+  // only compare if the key != 0, otherwise you can get matches with
+  // wierd key combos or something. So, key==0 has the meaning of, don't compare me!
+  if (key == 0)
+    return false;
+  
+  //char teststring[128];
+  int i;
+  for (i = 0; i < Nbuf; ++i)
+    {
+      //teststring[i] = keybuf[i] & 0x0FF;
+      
+      if ( (keybuf[i] & 0x0FF) == key )	// only compare by ascii code...
+	return true;
+    }
+  
+  //teststring[i] = 0;
+  //message.out(teststring);
+  
+  return false;
 }
 

Modified: branches/multiplayer-branch/source/util/aastr.c
===================================================================
--- branches/multiplayer-branch/source/util/aastr.c	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/util/aastr.c	2004-09-28 19:53:03 UTC (rev 71)
@@ -74,156 +74,167 @@
 	int dw, int dh, 
 	int mode ) 
 {
-	unsigned long addr;
-	int xscale, yscale, xbase, ybase;
-	int y1, y2, x1, x2;
-	int cx, cy, cw, ch;
-	int iy, ix;
-	int idx, idy;
-	int mw, mh;
-	ADD_TYPE *add;
-	PUT_TYPE *put;
+  unsigned long addr;
+  int xscale, yscale, xbase, ybase;
+  int y1, y2, x1, x2;
+  int cx, cy, cw, ch;
+  int iy, ix;
+  int idx, idy;
+  int mw, mh;
+  ADD_TYPE *add;
+  PUT_TYPE *put;
 
-	if (((mode&~(AA_MASKED)) == AA_NO_AA) && 
-		(bitmap_color_depth(src) == bitmap_color_depth(dest))) 
-//	if (0)
-	{
-		if (mode & AA_MASKED) masked_stretch_blit(src, dest, 
-			sx>>aa_BITS, sy>>aa_BITS, sw>>aa_BITS, sh>>aa_BITS, 
-			dx>>aa_BITS, dy>>aa_BITS, dw>>aa_BITS, dh>>aa_BITS);
-		else stretch_blit(src, dest, 
-			sx>>aa_BITS, sy>>aa_BITS, sw>>aa_BITS, sh>>aa_BITS, 
-			dx>>aa_BITS, dy>>aa_BITS, dw>>aa_BITS, dh>>aa_BITS);
-		return;
-	}
-
-	if ((dx + dw < 0) || (dy + dh < 0) || 
-		(dx >= dest->w << aa_BITS) || (dy >= dest->h << aa_BITS)) return;
-
-	if (!(mode & AA_NO_ALIGN)) {
-		sx &= (sx + bit(aa_BITS-1)) &~bitn(aa_BITS);
-		sy &= (sy + bit(aa_BITS-1)) &~bitn(aa_BITS);
-		sw &= (sw + bit(aa_BITS-1)) &~bitn(aa_BITS);
-		sh &= (sh + bit(aa_BITS-1)) &~bitn(aa_BITS);
-		dx &= (dx + bit(aa_BITS-1)) &~bitn(aa_BITS);
-		dy &= (dy + bit(aa_BITS-1)) &~bitn(aa_BITS);
-		dw &= (dw + bit(aa_BITS-1)) &~bitn(aa_BITS);
-		dh &= (dh + bit(aa_BITS-1)) &~bitn(aa_BITS);
-	}
-
-	if ((sw < (1 << (aa_BITS/2))) || (sh < (1 << (aa_BITS/2)))) 
-		return;
-	if ((dw < (1 << (aa_BITS/2))) || (dh < (1 << (aa_BITS/2)))) 
-		return;
-
-	yscale = ((sh) << aa_BITS) / dh;
-	ybase = (((dy&bitn(aa_BITS)) * yscale) >> aa_BITS) - sy;
-	xscale = ((sw) << aa_BITS) / dw;
-	xbase = (((dx&bitn(aa_BITS)) * xscale) >> aa_BITS) - sx;
-
- 	add = get_aa_add_function(src, mode);
-	put = get_aa_put_function(dest, mode);
-	if (!add || !put) return;
-
+  if (((mode&~(AA_MASKED)) == AA_NO_AA) && 
+      (bitmap_color_depth(src) == bitmap_color_depth(dest))) 
+    //	if (0)
+    {
+      if (mode & AA_MASKED) 
+	masked_stretch_blit(src, dest, 
+			    sx>>aa_BITS, sy>>aa_BITS, sw>>aa_BITS, 
+			    sh>>aa_BITS, 
+			    dx>>aa_BITS, dy>>aa_BITS, dw>>aa_BITS, 
+			    dh>>aa_BITS);
+      else 
+	stretch_blit(src, dest, 
+		     sx>>aa_BITS, sy>>aa_BITS, sw>>aa_BITS, sh>>aa_BITS, 
+		     dx>>aa_BITS, dy>>aa_BITS, dw>>aa_BITS, dh>>aa_BITS);
+      return;
+    }
+    
+    if ((dx + dw < 0) || (dy + dh < 0) || 
+	(dx >= dest->w << aa_BITS) || (dy >= dest->h << aa_BITS)) 
+      return;
+    
+    if (!(mode & AA_NO_ALIGN)) 
+      {
+	sx &= (sx + bit(aa_BITS-1)) &~bitn(aa_BITS);
+	sy &= (sy + bit(aa_BITS-1)) &~bitn(aa_BITS);
+	sw &= (sw + bit(aa_BITS-1)) &~bitn(aa_BITS);
+	sh &= (sh + bit(aa_BITS-1)) &~bitn(aa_BITS);
+	dx &= (dx + bit(aa_BITS-1)) &~bitn(aa_BITS);
+	dy &= (dy + bit(aa_BITS-1)) &~bitn(aa_BITS);
+	dw &= (dw + bit(aa_BITS-1)) &~bitn(aa_BITS);
+	dh &= (dh + bit(aa_BITS-1)) &~bitn(aa_BITS);
+      }
+    
+    if ((sw < (1 << (aa_BITS/2))) || (sh < (1 << (aa_BITS/2)))) 
+      return;
+    if ((dw < (1 << (aa_BITS/2))) || (dh < (1 << (aa_BITS/2)))) 
+      return;
+    
+    yscale = ((sh) << aa_BITS) / dh;
+    ybase = (((dy&bitn(aa_BITS)) * yscale) >> aa_BITS) - sy;
+    xscale = ((sw) << aa_BITS) / dw;
+    xbase = (((dx&bitn(aa_BITS)) * xscale) >> aa_BITS) - sx;
+    
+    add = get_aa_add_function(src, mode);
+    put = get_aa_put_function(dest, mode);
+    if (!add || !put) return;
+    
 #if AASTR2_HW_SUPPORT_LEVEL >= 1
-	bmp_select(dest);
+    bmp_select(dest);
 #endif
-
-	y1 = (dy        >> aa_BITS);
-	y2 = ((dy+dh-1) >> aa_BITS);
-	x1 = (dx        >> aa_BITS);
-	x2 = ((dx+dw-1) >> aa_BITS);
-	cw = xscale;
-	ch = yscale;
-	idy = dy >> aa_BITS;
-	idx = dx >> aa_BITS;
-	mw = sx+sw;
-	mh = sy+sh;
-	if ((unsigned int)cw < aa_SIZE) cw = aa_SIZE;
-	if ((unsigned int)ch < aa_SIZE) ch = aa_SIZE;
-	_aa.total = cw * ch;
-	if (!(mode & (AA_NO_ALIGN | AA_NO_FILTER))) {
-		if (_aa.total > aa_MAX_NUM) {
-			if ((unsigned int)cw > aa_MAX_SIZE) {
-//				xbase -= (cw - aa_MAX_SIZE) >> 1;
-//				xbase = 0;
-				cw = aa_MAX_SIZE;
-			}
-			if ((unsigned int)ch > aa_MAX_SIZE) {
-//				ybase -= (ch - aa_MAX_SIZE) >> 1;
-//				ybase = 0;
-				ch = aa_MAX_SIZE;
-			}
-			_aa.total = cw * ch;
-		}
+    
+    y1 = (dy        >> aa_BITS);
+    y2 = ((dy+dh-1) >> aa_BITS);
+    x1 = (dx        >> aa_BITS);
+    x2 = ((dx+dw-1) >> aa_BITS);
+    cw = xscale;
+    ch = yscale;
+    idy = dy >> aa_BITS;
+    idx = dx >> aa_BITS;
+    mw = sx+sw;
+    mh = sy+sh;
+    if ((unsigned int)cw < aa_SIZE) cw = aa_SIZE;
+    if ((unsigned int)ch < aa_SIZE) ch = aa_SIZE;
+    _aa.total = cw * ch;
+    if (!(mode & (AA_NO_ALIGN | AA_NO_FILTER))) {
+      if (_aa.total > aa_MAX_NUM) {
+	if ((unsigned int)cw > aa_MAX_SIZE) {
+	  //				xbase -= (cw - aa_MAX_SIZE) >> 1;
+	  //				xbase = 0;
+	  cw = aa_MAX_SIZE;
 	}
-	if (_aa_mode & AA_VFLIP) {
-		ybase -= yscale * (y2-idy);
-		yscale *= -1;
+	if ((unsigned int)ch > aa_MAX_SIZE) {
+	  //				ybase -= (ch - aa_MAX_SIZE) >> 1;
+	  //				ybase = 0;
+	  ch = aa_MAX_SIZE;
 	}
-	if (_aa_mode & AA_HFLIP) {
-		xbase -= xscale * (x2-idx);
-		xscale *= -1;
-	}
-	if (dest->clip) {
-		if (y1 < dest->ct) y1 = dest->ct;
-		if (y2 >= dest->cb) y2 = dest->cb - 1;
-		if (x1 < dest->cl) x1 = dest->cl;
-		if (x2 >= dest->cr) x2 = dest->cr - 1;
-	}
-	if (_aa_trans) {
-		if (_aa_trans2 >= 256) return;
-		_aa.total += (_aa.total * (Uint64)_aa_trans) >> 8;
-	}
-	_aa.inverse = 1 + (0xffffffffUL /  _aa.total );
-	for (iy = y1; iy <= y2; iy += 1) {
-		int th;
-		cy = (iy-idy) * yscale - ybase;
+	_aa.total = cw * ch;
+      }
+    }
+    if (_aa_mode & AA_VFLIP) {
+      ybase -= yscale * (y2-idy);
+      yscale *= -1;
+    }
+    if (_aa_mode & AA_HFLIP) {
+      xbase -= xscale * (x2-idx);
+      xscale *= -1;
+    }
+    if (dest->clip) {
+      if (y1 < dest->ct) y1 = dest->ct;
+      if (y2 >= dest->cb) y2 = dest->cb - 1;
+      if (x1 < dest->cl) x1 = dest->cl;
+      if (x2 >= dest->cr) x2 = dest->cr - 1;
+    }
+    if (_aa_trans) {
+      if (_aa_trans2 >= 256) return;
+      _aa.total += (_aa.total * (Uint64)_aa_trans) >> 8;
+    }
+
+    if(_aa.total)
+      _aa.inverse = 1 + (0xffffffffUL /  _aa.total );
+    else
+      _aa.inverse = 1;
+    
+    for (iy = y1; iy <= y2; iy += 1) {
+      int th;
+      cy = (iy-idy) * yscale - ybase;
 #if AASTR2_HW_SUPPORT_LEVEL >= 2
-		addr = bmp_write_line(dest, iy); //this helps if dest is a video bitmap
+      addr = bmp_write_line(dest, iy); //this helps if dest is a video bitmap
 #else
-		addr = (int)dest->line[iy];
+      addr = (int)dest->line[iy];
 #endif
-		_aa.y = iy;
+      _aa.y = iy;
 		th = ch;
 		if (cy < 0) { //top edge of image
-			th += cy;
-			cy = 0;
+		  th += cy;
+		  cy = 0;
 		}
 		if (cy + th > mh) { //bottom edge of image
-			th = mh - cy;
+		  th = mh - cy;
 		}
 		if ((unsigned int)th < aa_SIZE) { //either edge
-			cy -= (aa_SIZE - th) / 2;
-			th = aa_SIZE;
-			if (cy < 0) cy = 0;
-			if (cy > (int)(mh - aa_SIZE)) cy = mh - aa_SIZE;
+		  cy -= (aa_SIZE - th) / 2;
+		  th = aa_SIZE;
+		  if (cy < 0) cy = 0;
+		  if (cy > (int)(mh - aa_SIZE)) cy = mh - aa_SIZE;
 		}
 		for (ix = x1; ix <= x2; ix += 1) {
-			int tw;
-			cx = (ix-idx) * xscale - xbase;
-			tw = cw;
-			if (cx < 0) {//left edge of image
-				tw += cx;
-				cx = 0;
-			}
-			if (cx + tw > mw) {//right edge of image
-				tw = mw - cx;
-			}
-			if ((unsigned int)tw < aa_SIZE) {//either edge of image
-				cx -= (aa_SIZE - tw) / 2;
-				tw = aa_SIZE;
-				if (cx < 0) cx = 0;
-				if (cx > (int)(mw - aa_SIZE)) cx = mw - aa_SIZE;
-			}
+		  int tw;
+		  cx = (ix-idx) * xscale - xbase;
+		  tw = cw;
+		  if (cx < 0) {//left edge of image
+		    tw += cx;
+		    cx = 0;
+		  }
+		  if (cx + tw > mw) {//right edge of image
+		    tw = mw - cx;
+		  }
+		  if ((unsigned int)tw < aa_SIZE) {//either edge of image
+		    cx -= (aa_SIZE - tw) / 2;
+		    tw = aa_SIZE;
+		    if (cx < 0) cx = 0;
+		    if (cx > (int)(mw - aa_SIZE)) cx = mw - aa_SIZE;
+		  }
 			add ((BITMAP *)src, cx, cx + tw, cy, cy + th);
 			AA_PUT_PIXEL (put, addr, ix);
 		}
-	}
+    }
 #if AASTR2_HW_SUPPORT_LEVEL >= 2
-	bmp_unwrite_line(dest); //this helps if dest is a video bitmap
+    bmp_unwrite_line(dest); //this helps if dest is a video bitmap
 #endif
-	return;
+    return;
 }
 
 /*

Modified: branches/multiplayer-branch/source/util/base.cpp
===================================================================
--- branches/multiplayer-branch/source/util/base.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/util/base.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -44,6 +44,7 @@
 ------------------------------*/
 
 void BaseClass::preinit() {
+  STACKTRACE;
 	return;
 }
 BaseClass::~BaseClass() {
@@ -55,12 +56,14 @@
 	return ((void**)this);
 }
 int BaseClass::serialize(void *stream) {
+  STACKTRACE;
 	return 0;
 }
 int BaseClass::_get_size() const {
 	return 0;
 }
 void BaseClass::_event( Event *e) {
+  STACKTRACE;
 	return;
 }
 void BaseClass::issue_event ( std::list<BaseClass*>& recipients, Event *e) {

Modified: branches/multiplayer-branch/source/util/errors.cpp
===================================================================
--- branches/multiplayer-branch/source/util/errors.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/util/errors.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -7,81 +7,88 @@
 #include <stdarg.h>
 
 #include "melee.h"
-REGISTER_FILE
 
 #include "other/dialogs.h"
 
-static DIALOG *tw_alert_dialogs[4] = { 
-	tw_alert_dialog1, 
-	tw_alert_dialog2, 
-	tw_alert_dialog3, 
-	tw_alert_dialog4
-};
+static DIALOG *tw_alert_dialogs[5] = 
+  { 
+    tw_alert_dialog1, 
+    tw_alert_dialog2, 
+    tw_alert_dialog3, 
+    tw_alert_dialog4,
+    tw_alert_dialog5
+  };
 
-char find_shortcut_key(const char *s) {
-	while (true) {
-		s = strchr(s, '&');
-		if (s && (s[1] != '&')) {
-			s++;
-			break;
-		}
-		if (!s) return 0;
+char find_shortcut_key(const char *s) 
+{
+  while (true) 
+    {
+      s = strchr(s, '&');
+      if (s && (s[1] != '&')) 
+	{
+	  s++;
+	  break;
 	}
-	return *s;
+      if (!s) 
+	return 0;
+    }
+  return *s;
 }
 
 int _tw_alert ( 
-	bool popup, 
-	char *message, 
-	const char *b1, 
-	const char *b2 = NULL, 
-	const char *b3 = NULL, 
-	const char *b4 = NULL
-) 
+	       bool popup, 
+	       char *message, 
+	       const char *b1, 
+	       const char *b2 = NULL, 
+	       const char *b3 = NULL, 
+	       const char *b4 = NULL,
+	       const char *b5 = NULL
+	       ) 
 {
-	char *s1 = message;
-	char *s2 = NULL, *s3 = NULL;
-
-	s2 = strchr(s1, '\n');
-	if (s2) {
-		s2[0] = 0;
-		s2 += 1;
-		s3 = strchr(s2, '\n');
-		if (s3) {
-			s3[0]= 0;
-			s3 += 1;
-		}
-	}
-
-	int l = 1;
-	if (b2) l = 2;
-	if (b3) l = 3;
-	if (b4) l = 4;
-	DIALOG *dialog = tw_alert_dialogs[l-1];
-	dialog[1].dp = (void*)message;
-	if (b1) {
-		dialog[2].dp = (void*)b1;
-		dialog[2].key = find_shortcut_key(b1);
-	}
-	if (b2) {
-		dialog[3].dp = (void*)b2;
-		dialog[3].key = find_shortcut_key(b2);
-	}
-	if (b3) {
-		dialog[4].dp = (void*)b3;
-		dialog[4].key = find_shortcut_key(b3);
-	}
-	if (b4) {
-		dialog[5].dp = (void*)b4;
-		dialog[5].key = find_shortcut_key(b4);
-	}
-
-	int i;
-
-	if (popup) i = tw_popup_dialog(&videosystem.window, dialog, 2) - 2;
-	else       i = tw_do_dialog   (&videosystem.window, dialog, 2) - 2;
-	return i + 1;
-	//return alert3(s1, s2, s3, b1, b2, b3, 0, 0, 0);
+  int l = 1;
+  if (b2) 
+    l = 2;
+  if (b3) 
+    l = 3;
+  if (b4) 
+    l = 4;
+  if (b5)
+    l = 5;
+  DIALOG *dialog = tw_alert_dialogs[l-1];
+  dialog[1].dp = (void*)message;
+  if (b1) 
+    {
+      dialog[2].dp = (void*)b1;
+      dialog[2].key = find_shortcut_key(b1);
+    }
+  if (b2) 
+    {
+      dialog[3].dp = (void*)b2;
+      dialog[3].key = find_shortcut_key(b2);
+    }
+  if (b3) 
+    {
+      dialog[4].dp = (void*)b3;
+      dialog[4].key = find_shortcut_key(b3);
+    }
+  if (b4) 
+    {
+      dialog[5].dp = (void*)b4;
+      dialog[5].key = find_shortcut_key(b4);
+    }
+  if (b5) 
+    {
+      dialog[6].dp = (void*)b5;
+      dialog[6].key = find_shortcut_key(b5);
+    }
+  
+  int i;
+  
+  if (popup) 
+    i = tw_popup_dialog(&videosystem->window, dialog, 2) - 2;
+  else
+    i = tw_do_dialog   (&videosystem->window, dialog, 2) - 2;
+  return i + 1;
 }
 
 
@@ -100,92 +107,102 @@
 	const char *message
 ) 
 {
-	char error_string[4096];
-	int i;
+  char error_string[32000];
+  int i;
 
-	if (__error_flag & 2) return;
+  if (__error_flag & 2) return;
+  
+  char *cp = &error_string[0];
+  if (file) 
+    {
+      char *_file = strstr(file, "source");
+      if (_file) file = _file;
+    }
 
-	char *cp = &error_string[0];
-	if (file) {
-		char *_file = strstr(file, "source");
-		if (_file) file = _file;
-	}
+  log_debug("tw_error_handler invoked: ");
+  int len = strlen(message);
+  memcpy(error_string, message, len);
+  cp += len;
+  if (line >= 0) 
+    {
+      log_debug(        "(from %s, Line %d)\n", file, line);
+      cp += sprintf(cp, "\n(from %s, line %d)\n", file, line);
+    }
+  else 
+    {
+      log_debug("(from unspecified file & linenumber)\n");
+      cp += sprintf(cp, "\n");
+    }
+  cp += sprintf(cp, "\nStack Trace:\n");
+  cp += sprintf(cp, "%s", UserStackTraceHelper::get_stack_trace_string().c_str());
 
-	log_debug("tw_error_handler invoked: ");
-	int len = strlen(message);
-	memcpy(error_string, message, len);
-	cp += len;
-	if (line >= 0) {//display line # and file name
-		log_debug(        "(from %s, Line %d)\n", file, line);
-		cp += sprintf(cp, "\n(from %s, line %d)\n", file, line);
-	}
-	else {
-		log_debug("(from unspecified file & linenumber)\n");
-		cp += sprintf(cp, "\n");
-	}
-	log_debug("begin error message:\n%s\nend error message\n", message);
-
-
-
-	if (videosystem.width <= 0) {
-		allegro_message("Critical Error$: %s\n", error_string);
-		log_debug("\nUnable to display messge, shutting down\n");
-		throw -1;
-	}
-
-	log_debug("Pressenting graphical error prompt\n");
-
-	const char *es[] = {"&Abort", "&Retry", "&Debug", "&Ignore"};
-	enum {
-		ES_ABORT = 0,
-		ES_RETRY,
-		ES_DEBUG,
-		ES_IGNORE
-	};
-	int selection = -1;
-
-	if ( in_catch_statement ) {
-		int les[] = { ES_ABORT, ES_DEBUG };
-		i = _tw_alert( false, error_string, es[les[0]], es[les[1]] );
-		if (i > 0) selection = les[i - 1];
-	}
-	else {
-		int les[] = { ES_ABORT, ES_RETRY, ES_DEBUG, ES_IGNORE };
-		i = _tw_alert( false, error_string, es[les[0]], es[les[1]], es[les[2]], es[les[3]] );
-		if (i > 0) selection = les[i - 1];
-	}
-	if (selection < 0) selection = ES_ABORT;
-	log_debug("Option \"%s\" selected\n", es[selection]);
-
-	videosystem.screen_corrupted = true;
-
-	if (selection == ES_DEBUG) {//"Debug"
-		__error_flag |= 1;
-		if (in_catch_statement) {
-			return;
-		}
+  log_debug("begin error message:\n%s\nend error message\n", message);
+  log_debug(UserStackTraceHelper::get_stack_trace_string().c_str());
+  
+  
+  if (videosystem->width <= 0) {
+    allegro_message("Critical Error$: %s\n", error_string);
+    log_debug("\nUnable to display messge, shutting down\n");
+    throw -1;
+  }
+  
+  log_debug("Pressenting graphical error prompt\n");
+  
+  const char *es[] = {"&Abort", "&Retry", "&Debug", "&Ignore", "&Stack Trace"};
+  enum {
+    ES_ABORT = 0,
+    ES_RETRY,
+    ES_DEBUG,
+    ES_IGNORE,
+    ES_STACKTRACE
+  };
+  int selection = -1;
+  
+  i = _tw_alert( false, error_string, es[ES_ABORT], es[ES_RETRY], 
+		 es[ES_DEBUG], es[ES_IGNORE], es[ES_STACKTRACE] );
+  if (i > 0) 
+    selection = i - 1;
+  
+  if (selection < 0) 
+    selection = ES_ABORT;
+  log_debug("Option \"%s\" selected\n", es[selection]);
+  
+  videosystem->screen_corrupted = true;
+  
+  if (selection == ES_DEBUG) {//"Debug"
+    __error_flag |= 1;
+    if (in_catch_statement) {
+      return;
+    }
 #		if defined ALLEGRO_MSVC
-			__asm int 3;
+    __asm int 3;
 #		elif defined __GNUC__ && defined __i386__
-			asm("int $0x03");
+    asm("int $0x03");
 #		else
-			if (1) (*((int*)NULL)) = 0;
+    if (1) (*((int*)NULL)) = 0;
 #		endif
-		return;
-	}
-
-	if (selection == ES_IGNORE) {//"Ignore"
-		__error_flag |= 2;
-		return;
-	}
-
-	if (selection == ES_RETRY) {//"Retry"
-		return;
-	}
-
-	//"Abort"
-	if (in_catch_statement) return;
-	else throw 0;
+    return;
+  }
+  
+  if (selection == ES_IGNORE) {//"Ignore"
+    __error_flag |= 2;
+    return;
+  }
+  
+  if (selection == ES_RETRY) {//"Retry"
+    return;
+  }
+  
+  if(selection == ES_STACKTRACE)
+    {
+      show_text(UserStackTraceHelper::get_stack_trace_string().c_str());
+      tw_error_handler ( in_catch_statement, file, line, message );
+      return;
+    }
+  //"Abort"
+  if (in_catch_statement) 
+    return;
+  else throw 0;
 }
 static void _register_tw_error_hanlde() {_error_handler = &tw_error_handler;}
 CALL_BEFORE_MAIN(_register_tw_error_hanlde);
@@ -197,7 +214,7 @@
 
 void tw_error_exit(const char* message) {
 	log_debug("\nCritical Error!: %s\n\n", message);
-	if ((videosystem.width > 0) && (strlen(message) < 1000)) {
+	if ((videosystem->width > 0) && (strlen(message) < 1000)) {
 		char buf[1024];
 		sprintf(buf, "Critical Error!: %s", message);
 		tw_alert (buf, "Quit");
@@ -212,21 +229,66 @@
 //char tw_error_str[tw_error_str_len];
 
 void caught_error(const char *format, ...) {
-	char error_string[4096];
+  	char error_string[4096];
 	if (format) {
 		va_list those_dots;
 		va_start(those_dots, format);
 		vsprintf(error_string, format, those_dots);
 		va_end(those_dots);
 	}
+ 
+  	tw_error_handler( 1, NULL, -1, error_string);
+	// tw_error_handler( 1, NULL, -1, format);
 
-	_error_handler( 1, NULL, -1, error_string);
-
 	return;
 }
 
+std::stack<SOURCE_LINE*> UserStackTraceHelper::call_stack;
+UserStackTraceHelper::UserStackTraceHelper( SOURCE_LINE* srcline)
+{
+  #ifdef DEBUG
+  //  debug_log(GetStackNodeString(srcline).c_str());
+  #endif 
+      call_stack.push(srcline);
+}
 
+UserStackTraceHelper::~UserStackTraceHelper()
+{
+      call_stack.pop();
+}
 
+std::string UserStackTraceHelper::GetStackNodeString(SOURCE_LINE* stNode)
+{
+  std::string strFile;
+  char *_file = strstr(stNode->file, "source");
+  if (_file) 
+    strFile = _file;
+  
+  char line[20] = {0};
+  sprintf(line, "%d", stNode->line);
+      
+  std::string strName;
+  if(stNode->name!=NULL)
+    strName = std::string(" ") + stNode->name;
+  
+  return std::string("from: ") + strFile + ", line " + line + " funct: " + stNode->funct + strName + "\n";
+}
+
+std::string UserStackTraceHelper::get_stack_trace_string()
+{
+  std::string stack_string = "";
+  
+  std::stack<SOURCE_LINE*> tmp;
+  tmp = call_stack;
+  while(!tmp.empty())
+    {
+      SOURCE_LINE* stNode = tmp.top();
+      stack_string += GetStackNodeString(stNode);
+      tmp.pop();
+    }
+  return stack_string;
+}
+
 void init_error() {
 }
 void deinit_error() {

Modified: branches/multiplayer-branch/source/util/errors.h
===================================================================
--- branches/multiplayer-branch/source/util/errors.h	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/util/errors.h	2004-09-28 19:53:03 UTC (rev 71)
@@ -15,39 +15,49 @@
  */
 
 #ifdef __cplusplus
+#include <stack>
 
 int tw_alert(const char *message, const char *b1 = 0, const char *b2 = 0, const char *b3 = 0, const char *b4 = 0) ;
 
 // for errors caught in "catch" clauses
 void caught_error(const char *format, ...);
 
-//const int tw_error_str_len = 2048;	// should be plenty of room.
-//extern char tw_error_str[tw_error_str_len];
-//bool get_stacklist_info(int N, const char **filename, int **linenum, int **level);
-//bool get_stacktrace_info(int N, const char **filename, int **linenum, int **level);
 
-
-
 //quits TW with an error message
 //used for catastrophic errors
 void tw_error_exit(const char* message) ;
 
-
-//stacktrace and profiling stuff:
-
 #include "get_time.h"
 
-struct SOURCE_LINE {
-	int line;         // __LINE__
-	const char *file; // __FILE__
-	const char *name; // NULL or a descriptor string
+struct SOURCE_LINE 
+{
+  int line;         // __LINE__
+  const char *file; // __FILE__
+  const char *funct; // __FUNCTION__
+  const char *name; // NULL or a descriptor string
 };
 
+/// \brief Call stack tracker
+///
+/// Object of this class is created on stack in STACKTRACE macro, so it's creating/destruction can 
+/// be used to manage  call stack. 
+class UserStackTraceHelper 
+{
+  static std::stack<SOURCE_LINE*> call_stack;
+  static std::string GetStackNodeString(SOURCE_LINE* stNode);
+ public:
+  UserStackTraceHelper( SOURCE_LINE* srcline);
+  ~UserStackTraceHelper();
+  
+  /// \brief get stack trace string 
+  static std::string get_stack_trace_string();
+};
 
-#	define STACKTRACE
-#	define _STACKTRACE(A)
 
+#define STACKTRACE static SOURCE_LINE _srcline = { __LINE__, __FILE__, __FUNCTION__, 0 }; UserStackTraceHelper _stacktrace_ ( &_srcline );
+#define _STACKTRACE(A) static SOURCE_LINE _srcline = { __LINE__, __FILE__, __FUNCTION__, A }; UserStackTraceHelper _stacktrace_ ( &_srcline );
 
+
 extern "C" {
 #endif
 
@@ -84,41 +94,29 @@
  */
 
 #	define tw_error _prep_error_func(__FILE__, __LINE__)
-//#	define tw_error _prep_error(__FILE__, __LINE__); _error
-	void error_handler ( const char *message);
-	extern void (*_error_handler) ( 
-		int in_catch_statement, //"retry" is invalid inside a catch statement
-		const char *src_file, 
-		int line, 
-		const char *message 
-	);
 
-	typedef void (*ERROR_FUNC_TYPE)(const char *fmt, ...);
+  void error_handler ( const char *message);
+  extern void (*_error_handler) ( 
+				 int in_catch_statement, //"retry" is invalid inside a catch statement
+				 const char *src_file, 
+				 int line, 
+				 const char *message 
+				 );
 
-	ERROR_FUNC_TYPE _prep_error_func ( const char *file, int line );
-	void _prep_error(const char *file, int line);
-	void _error(const char *format, ...);
+  typedef void (*ERROR_FUNC_TYPE)(const char *fmt, ...);
+  
+  ERROR_FUNC_TYPE _prep_error_func ( const char *file, int line );
+  void _prep_error(const char *file, int line);
+  void _error(const char *format, ...);
+  
 
 /*
- * void error(const char *format, ...)
- *
- * This function is more or less the same as tw_error(const char *format, ...)
- *
- * The primary difference is, this function will not display extra debugging 
- * information.  Specifically, it won't attempt to display the call stack.  
- * 
- */
-
-	void error(const char *format, ...);
-
-
-/*
  * void log_debug(const char *format, ...)
  *
  * Records a log of certain information to disk.
  * Typical log message: "Sound Initialized (10 voices sfx, 22 for music)"
  */
-	void log_debug(const char *format, ...);
+  void log_debug(const char *format, ...);
 
 /*
  * void tw_error_exit(char* message)

Modified: branches/multiplayer-branch/source/util/history.cpp
===================================================================
--- branches/multiplayer-branch/source/util/history.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/util/history.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -2,8 +2,8 @@
 #include <math.h>
 #include "base.h"
 #include "history.h"
+#include "errors.h"
 
-
 ////////////////////////////////////////////////////////////////////////
 //				Histograph stuff
 ////////////////////////////////////////////////////////////////////////
@@ -30,6 +30,7 @@
 */
 
 Histograph::Histograph(Uint16 max) {
+  STACKTRACE;
 	num = 0;
 	base = 0;
 	this->max = max;
@@ -42,9 +43,11 @@
 	delete[] element;
 }
 void Histograph::add_element(double v) {
+  STACKTRACE;
 	_add(v);
 }
 void Histograph::_add(double v) {
+  STACKTRACE;
 	int i;
 	if (num == max) {
 		num -= next_ratio;

Modified: branches/multiplayer-branch/source/util/random.cpp
===================================================================
--- branches/multiplayer-branch/source/util/random.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/util/random.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -41,9 +41,11 @@
 	ADDITIVE   = 123456789
 };
 Uint32 RNG_lcg64a::randi(Uint32 max) {
+  STACKTRACE;
 	return _rng_dist_32_flat(max, raw32());
 }
 Uint32 RNG_lcg64a::raw32() {
+  STACKTRACE;
 #	if defined(_MSC_VER) && defined(__i386__) && !defined(NO_ASM)
 		split_int_64 i64 = s64;
 		_asm { mov eax, [i64.s.high] } 
@@ -73,6 +75,7 @@
 	return s64.s.high;
 }
 Uint64 RNG_lcg64a::raw64() {
+  STACKTRACE;
 	Uint64 bob = raw32();
 	bob = (bob << 32) | raw32();
 	return bob;
@@ -95,11 +98,13 @@
 }
 
 void RNG_lcg64a::seed( int s ) {
+  STACKTRACE;
 	s64.s.low = s;
 	s64.s.high = 0;
 	return;
 }
 void RNG_lcg64a::seed_more( int s ) {
+  STACKTRACE;
 	if (s64.s.high & 0x80000000) raw32();
 	raw32();
 	s64.s.low += ((s64.s.high >> 27) | (s64.s.high << 5)) ^ s;

Modified: branches/multiplayer-branch/source/util/sound.cpp
===================================================================
--- branches/multiplayer-branch/source/util/sound.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/util/sound.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -24,11 +24,13 @@
 
 #include <allegro.h>
 #include "other/twconfig.h"
+#include "errors.h"
 
+SoundSystem* tw_sound = NULL;
 
-SoundSystem2 tw_sound;
-SoundSystem2::SoundSystem2(bool sound_on)
+SoundSystem::SoundSystem(bool sound_on)
 {
+  STACKTRACE;
   mix_ok = false;
   current_music = "";
   
@@ -48,20 +50,27 @@
   const size_t buf_size = 1024;
 #endif
   
-  const int res = Mix_OpenAudio(MIX_DEFAULT_FREQUENCY,MIX_DEFAULT_FORMAT,2,buf_size);
+  int res = Mix_OpenAudio(MIX_DEFAULT_FREQUENCY,MIX_DEFAULT_FORMAT,2,buf_size);
   if(res >= 0) 
     {
       mix_ok = true;
-      Mix_AllocateChannels(16);
+      Mix_AllocateChannels(32);
     } 
   else 
     {
       mix_ok = false;
       std::cerr << "Could not initialize audio: " << SDL_GetError() << "\n";
     }
+
+  res = Mix_QuerySpec(&frequency, &format, &channels);
+  if(!res)
+    {
+      mix_ok = false;
+      std::cerr << "Could not initialize audio: " << SDL_GetError() << "\n";
+    }
 };
 
-SoundSystem2::~SoundSystem2()
+SoundSystem::~SoundSystem()
 {
   std::cerr << "closing audio...\n";
   if(!mix_ok)
@@ -87,8 +96,9 @@
   std::cerr << "done closing audio...\n";
 }
   
-void SoundSystem2::play_music(const std::string& file, int loops)
+void SoundSystem::play_music(const std::string file, int loops)
 {
+  STACKTRACE;
   if(!mix_ok || current_music == file)
     return;
   
@@ -120,10 +130,10 @@
   
   if(Mix_PlayingMusic()) 
     {
-      Mix_FadeOutMusic(500);
+      Mix_FadeOutMusic(0);
     }
   
-  const int res = Mix_FadeInMusic(itor->second,loops,500);
+  const int res = Mix_FadeInMusic(itor->second,loops,0);
   if(res < 0) 
     {
       std::cerr << "Could not play music: " << SDL_GetError() << "\n";
@@ -132,8 +142,9 @@
   current_music = file;
 }
 
-void SoundSystem2::play_sound(const std::string& file)
+void SoundSystem::play_sound(const std::string file, double vol)
 {
+  STACKTRACE;
   if(!mix_ok || sound_off)
     return;
   
@@ -164,10 +175,38 @@
     {
       std::cerr << "error playing sound effect: " << SDL_GetError() << "\n";
     }
+  if(vol!=-1)
+    {
+      
+      Mix_VolumeChunk(itor->second, int(vol*double(MIX_MAX_VOLUME)));
+    }
 }
 
-void SoundSystem2::set_music_volume(double vol)
+void SoundSystem::stop_sound(const std::string file)
 {
+  STACKTRACE;
+  if(!mix_ok || sound_off)
+    return;
+  
+  std::map<std::string,Mix_Chunk*>::const_iterator itor = sound_cache.find(file);
+  if(itor == sound_cache.end()) 
+    {
+      return;
+    }
+  
+  for (int i=0; i<32; i++)
+    {
+      Mix_Chunk * chunk = Mix_GetChunk(i);
+      if(chunk == itor->second)
+	{
+	  Mix_HaltChannel(i);
+	}
+    }
+}
+
+void SoundSystem::set_music_volume(double vol)
+{
+  STACKTRACE;
   if(!mix_ok)
     return;
   
@@ -195,8 +234,9 @@
   set_config_float("Sound", "MusicVolume", vol);
 }
 
-void SoundSystem2::set_sound_volume(double vol)
+void SoundSystem::set_sound_volume(double vol)
 {
+  STACKTRACE;
   if(!mix_ok)
     return;
   
@@ -214,14 +254,22 @@
   set_config_float("Sound", "SoundVolume", vol);
 }
 
-double SoundSystem2::load_music_volume()
+double SoundSystem::load_music_volume()
 {
+  STACKTRACE;
   tw_set_config_file("client.ini");
   return get_config_float("Sound", "MusicVolume", 0.5);
 }
 
-double SoundSystem2::load_sound_volume()
+double SoundSystem::load_sound_volume()
 {
+  STACKTRACE;
   tw_set_config_file("client.ini");
   return get_config_float("Sound", "SoundVolume", 0.5);
 }
+
+bool SoundSystem::playing_music()
+{
+  STACKTRACE;
+  return Mix_PlayingMusic();
+}

Modified: branches/multiplayer-branch/source/util/sound.h
===================================================================
--- branches/multiplayer-branch/source/util/sound.h	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/util/sound.h	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,16 +1,19 @@
-/* modified by Yurand for TW-Light */
-/* $Id: sound.hpp,v 1.11 2004/08/30 01:23:16 Sirp Exp $ */
 /*
-   Copyright (C) 2003 by David White <davidnwhite at optusnet.com.au>
-   Part of the Battle for Wesnoth Project http://wesnoth.whitevine.net
+This file is part of "TW-Light" 
+                    http://tw-light.berlios.de/
+Copyright (C) 2001-2004  TimeWarp development team
 
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License.
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
 
-   See the COPYING file for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 */
+
 #ifndef TW_SOUND_H_INCLUDED
 #define TW_SOUND_H_INCLUDED
 
@@ -20,7 +23,7 @@
 #include "SDL_mixer.h"
 
 /// \brief All work with sound must be implemented using this class
-class SoundSystem2
+class SoundSystem
 {  
   bool mix_ok;
   std::map<std::string,Mix_Chunk*> sound_cache;
@@ -30,26 +33,40 @@
   
   bool music_off;
   bool sound_off;
+  
+  int frequency;
+  Uint16 format;
+  int channels;
 
  public:
-  SoundSystem2(bool sound_on = true);
-  ~SoundSystem2();
+  SoundSystem(bool sound_on = true);
+  ~SoundSystem();
 
   /// \brief play music file
-  void play_music(const std::string& file, int loops = -1);
+  /// \param file - path to music file
+  /// \param loops - -1 play instantly
+  void play_music(const std::string file, int loops = -1);
   /// \brief play sound effect from file
-  void play_sound(const std::string& file);
-  
+  /// \param file - path to sound file
+  /// \param vol - sound volume 1 - max, 0 min
+  void play_sound(const std::string file, double vol = -1);
+  /// \brief stop playing current sound
+  void stop_sound(const std::string file);
+
   /// \brief set music volume
   void set_music_volume(double vol);
   /// \brief set sound effect volume
   void set_sound_volume(double vol);
 
   // this functions will die after config would be implemented
-  
+  /// \brief get music volume from .ini 
   double load_music_volume();
+  /// \brief get sound volume from .ini
   double load_sound_volume();
+
+  /// \brief return true if music playing
+  bool playing_music();
 };
-extern SoundSystem2 tw_sound;
+extern SoundSystem* tw_sound;
 
 #endif

Deleted: branches/multiplayer-branch/source/util/sounds.cpp
===================================================================
--- branches/multiplayer-branch/source/util/sounds.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/util/sounds.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,62 +0,0 @@
-
-//#define NO_JGMOD
-
-#include <allegro.h>
-#ifdef WIN32
-#include <winalleg.h>
-#endif
-
-#include "base.h"
-#include "sounds.h"
-#include "errors.h" //only used for log_debug() function
-
-
-
-/* static int is_jgmod_compiled() {return 0;} */
-
-
-SoundSystem tw_soundsystem;
-SoundSystem::SoundSystem() {
-	return;
-}
-int SoundSystem::is_music_supported() const {
-  return 0;
-}
-int SoundSystem::is_music_playing() const {
-  return 0;
-}
-void SoundSystem::disable() {
-	return;
-}
-void SoundSystem::load() {
-	return;
-}
-void SoundSystem::save() {
-	return;
-}
-void SoundSystem::init() {
-	return;
-}
-int SoundSystem::play (SAMPLE *spl, int vol, int pan, int freq, bool loop) {
-  return -1;
-}
-void SoundSystem::stop (SAMPLE *spl) {
-}
-void SoundSystem::stop (int voice_id) {
-}
-void SoundSystem::play_music (Music *music, int loop) {
-}
-void SoundSystem::stop_music () {
-}
-void SoundSystem::set_volumes(int sound_volume, int music_volume, int sound_on, int music_on) {
-}
-
-Music *SoundSystem::load_music(const char *fname) 
-{
-  return NULL;
-}
-
-
-void SoundSystem::unload_music(Music *mus) 
-{
-}

Deleted: branches/multiplayer-branch/source/util/sounds.h
===================================================================
--- branches/multiplayer-branch/source/util/sounds.h	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/util/sounds.h	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,68 +0,0 @@
-#ifndef __SOUNDS_H__
-#define __SOUNDS_H__
-
-#define PLATFORM_IS_ALLEGRO
-
-#ifdef PLATFORM_IS_ALLEGRO
-	struct SAMPLE;
-	struct JGMOD;
-	typedef SAMPLE  Sound;
-	typedef JGMOD   Music;
-#else
-	#error unknown platform (allegro?)
-#endif
-
-#include "base.h"
-
-class SoundSystem : public BaseClass {
-	public:
-	enum {
-		ENABLED = 1,
-		DISABLED = 2,
-		MOD_ENABLED = 4,
-		MOD_DISABLED = 8, 
-		SOUND_ON = 16,
-		MUSIC_ON = 32,
-		OGG_ENABLED = 64,
-		OGG_DISABLED = 128
-		};
-	Music *looping_music;
-	char fake_mod_playing;
-	char sound_on, music_on;
-	char sound_channels, music_channels;
-	int sound_volume, music_volume;
-	unsigned int state;
-
-	SoundSystem() ;
-	void disable() ;
-
-	void load() ;
-	void save() ;
-	void init() ;
-
-	int play (Sound *spl, int vol = 256, int pan = 128, int freq = 1000, bool loop = false) ;
-	void stop (Sound *spl);
-	void stop (int voice_id);
-	
-	void pause_music(SAMPLE * sample);
-	void resume_music(SAMPLE * sample);
-
-	void play_music (Music *mus, int loop = false);
-	void stop_music ();
-	int is_music_playing() const;
-	int is_music_supported() const;
-
-	void set_volumes(int sound_volume, int music_volume, int sound_on, int music_on) ;
-
-	Music *load_music(const char *fname);
-	void unload_music(Music *music);
-	
-}
-extern tw_soundsystem;
-#define sound tw_soundsystem
-
-/*------------------------------
-		Sound (and MODs)
-------------------------------*/
-
-#endif // __SOUNDS_H__

Modified: branches/multiplayer-branch/source/util/vector2.cpp
===================================================================
--- branches/multiplayer-branch/source/util/vector2.cpp	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/source/util/vector2.cpp	2004-09-28 19:53:03 UTC (rev 71)
@@ -4,15 +4,21 @@
 #include "vector2.h"
 #include "random.h"
 #include "round.h"
+#include "errors.h"
 //#include "../melee.h"
 
-Vector2::Vector2(Vector2i v2i) : x(v2i.x), y(v2i.y) {}
+Vector2::Vector2(Vector2i v2i) : x(v2i.x), y(v2i.y) 
+{
+  STACKTRACE;
+}
 Vector2i Vector2::round()
 {
+  STACKTRACE;
 	return Vector2i(iround(x), iround(y));
 }
 Vector2i Vector2::truncate()
 {
+  STACKTRACE;
 	return Vector2i(int(x), int(y));
 }
 
@@ -71,6 +77,7 @@
 
 Vector3D::Vector3D(double ax, double ay, double az)
 {
+  STACKTRACE;
 	x = ax;
 	y = ay;
 	z = az;
@@ -78,16 +85,19 @@
 
 double Vector3D::dot(Vector3D v)
 {
+  STACKTRACE;
 	return x*v.x + y*v.y + z*v.z;
 }
 
 Vector3D Vector3D::cross(Vector3D b)
 {
+  STACKTRACE;
 	return Vector3D(y*b.z - z*b.y, -x*b.z + z*b.x, x*b.y - y*b.x);
 }
 
 void Vector3D::normalize()
 {
+  STACKTRACE;
 	double r;
 	r = sqrt(x*x + y*y + z*z);
 	x /= r;

Modified: branches/multiplayer-branch/sources.lst
===================================================================
--- branches/multiplayer-branch/sources.lst	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/sources.lst	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,162 +1,191 @@
+source/ais/c_wussie.cpp
+source/ais/c_other.cpp
 source/ais/c_input.cpp
-source/ais/c_other.cpp
-source/ais/c_wussie.cpp
-source/doxygen.cpp
 source/frame.cpp
+source/util/random.cpp
+source/util/vector2.cpp
+source/util/round.c
+source/util/history.cpp
+source/util/types.cpp
+source/util/aautil.c
+source/util/sound.cpp
+source/util/get_time.c
+source/util/aarot.c
+source/util/aastr.c
+source/util/errors.cpp
+source/util/errors_c.c
+source/util/endian.cpp
+source/util/pmask.c
+source/util/base.cpp
+source/games/ggob.cpp
 source/games/gflmelee.cpp
-source/games/MultiplayerGame.cpp
-source/gui.cpp
-source/input.cpp
-source/libraries/agup/aalg.c
-source/libraries/agup/aase.c
-source/libraries/agup/abeos.c
-source/libraries/agup/abitmap.c
-source/libraries/agup/agtk.c
-source/libraries/agup/agup.c
-source/libraries/agup/ans.c
-source/libraries/agup/aphoton.c
-source/libraries/agup/awin95.c
-source/libraries/jpgalleg/decode.c
-source/libraries/jpgalleg/encode.c
-source/libraries/jpgalleg/io.c
-source/libraries/jpgalleg/jpgalleg.c
-source/libraries/raknet/AES128.cpp
-source/libraries/raknet/AsynchronousFileIO.cpp
-source/libraries/raknet/BitStream.cpp
-source/libraries/raknet/CheckSum.cpp
-source/libraries/raknet/DataBlockEncryptor.cpp
-source/libraries/raknet/DistributedNetworkObject.cpp
-source/libraries/raknet/DistributedNetworkObjectManager.cpp
-source/libraries/raknet/DistributedNetworkObjectStub.cpp
-source/libraries/raknet/EncodeClassName.cpp
-source/libraries/raknet/Euclid.cpp
-source/libraries/raknet/ExtendedOverlappedPool.cpp
-source/libraries/raknet/GetTime.cpp
-source/libraries/raknet/HuffmanEncodingTree.cpp
-source/libraries/raknet/HuffmanEncodingTreeFactory.cpp
-source/libraries/raknet/InternalPacketPool.cpp
-source/libraries/raknet/MPUInt.cpp
-source/libraries/raknet/NetworkObject.cpp
-source/libraries/raknet/NetworkTypes.cpp
-source/libraries/raknet/PacketPool.cpp
-source/libraries/raknet/RakClient.cpp
-source/libraries/raknet/RakNetworkFactory.cpp
-source/libraries/raknet/RakPeer.cpp
-source/libraries/raknet/RakServer.cpp
-source/libraries/raknet/rand.cpp
-source/libraries/raknet/ReliabilityLayer.cpp
-source/libraries/raknet/RPCNode.cpp
-source/libraries/raknet/RSA.cpp
-source/libraries/raknet/SHA1.cpp
-source/libraries/raknet/SimpleMutex.cpp
-source/libraries/raknet/SocketLayer.cpp
-source/libraries/raknet/StringCompressor.cpp
-source/melee/manim.cpp
-source/melee/mcbodies.cpp
-source/melee/mcontrol.cpp
-source/melee/mfleet.cpp
-source/melee/mframe.cpp
-source/melee/mgame.cpp
-source/melee/mhelpers.cpp
+source/games/gdefender.cpp
+source/melee/mlog.cpp
 source/melee/mitems.cpp
-source/melee/mlog.cpp
-source/melee/mmain.cpp
-source/melee/mmath.cpp
 source/melee/mnet1.cpp
 source/melee/moptions.cpp
+source/melee/mgame.cpp
+source/melee/mhelpers.cpp
+source/melee/mfleet.cpp
+source/melee/mview.cpp
 source/melee/mship.cpp
+source/melee/mcontrol.cpp
+source/melee/manim.cpp
+source/melee/mframe.cpp
 source/melee/mshot.cpp
 source/melee/mshpdata.cpp
 source/melee/mshppan.cpp
 source/melee/msprite.cpp
+source/melee/mcbodies.cpp
+source/melee/mmain.cpp
 source/melee/mtarget.cpp
-source/melee/mview.cpp
+source/melee/mmath.cpp
+source/other/orbit.cpp
 source/other/configrw.cpp
-source/other/dialogs.cpp
+source/other/shippart.cpp
 source/other/fontmorph.cpp
+source/other/vtarget.cpp
+source/other/twconfig.cpp
+source/other/vbodies.cpp
+source/other/gup.cpp
+source/other/objanim.cpp
 source/other/nullphas.cpp
-source/other/objanim.cpp
-source/other/orbit.cpp
 source/other/planet3d.cpp
 source/other/radar.cpp
-source/other/shippart.cpp
-source/other/twconfig.cpp
-source/other/vbodies.cpp
-source/other/vtarget.cpp
-source/sc1ships/shpandgu.cpp
-source/sc1ships/shparisk.cpp
-source/sc1ships/shpchebr.cpp
-source/sc1ships/shpearcr.cpp
-source/sc1ships/shpilwav.cpp
-source/sc1ships/shpkzedr.cpp
-source/sc1ships/shpmmrxf.cpp
-source/sc1ships/shpmycpo.cpp
-source/sc1ships/shpshosc.cpp
-source/sc1ships/shpspael.cpp
-source/sc1ships/shpsyrpe.cpp
-source/sc1ships/shpumgdr.cpp
-source/sc1ships/shpvuxin.cpp
-source/sc1ships/shpyehte.cpp
-source/sc2ships/shpchmav.cpp
-source/sc2ships/shpdruma.cpp
-source/sc2ships/shpkohma.cpp
-source/sc2ships/shpmeltr.cpp
-source/sc2ships/shporzne.cpp
-source/sc2ships/shppkufu.cpp
-source/sc2ships/shpslypr.cpp
-source/sc2ships/shpsupbl.cpp
-source/sc2ships/shpthrto.cpp
-source/sc2ships/shputwju.cpp
-source/sc2ships/shpzfpst.cpp
-source/scp.cpp
+source/other/dialogs.cpp
+source/ships/shptauar.cpp
+source/ships/shpbogce.cpp
 source/ships/shpaktgu.cpp
+source/ships/shptauda.cpp
+source/ships/shpforsh.cpp
+source/ships/shptaume.cpp
+source/ships/shpdragr.cpp
+source/ships/shptausl.cpp
+source/ships/shptaust.cpp
+source/ships/shptauto.cpp
+source/ships/shpgarty.cpp
+source/ships/shprogsq.cpp
+source/ships/shpzeksh.cpp
+source/ships/shpconca.cpp
+source/ships/shpchoex.cpp
+source/ships/shpconho.cpp
+source/ships/shpilwsp.cpp
 source/ships/shpalabc.cpp
+source/ships/shpyusra.cpp
 source/ships/shpbahbu.cpp
 source/ships/shpbipka.cpp
-source/ships/shpbogce.cpp
-source/ships/shpchoex.cpp
-source/ships/shpconca.cpp
-source/ships/shpconho.cpp
-source/ships/shpdragr.cpp
+source/ships/shpwolmi.cpp
 source/ships/shpearc3.cpp
-source/ships/shpforsh.cpp
-source/ships/shpgarty.cpp
-source/ships/shpilwsp.cpp
 source/ships/shpkahbo.cpp
-source/ships/shprogsq.cpp
 source/ships/shpstaba.cpp
-source/ships/shptauar.cpp
-source/ships/shptauda.cpp
-source/ships/shptaume.cpp
-source/ships/shptausl.cpp
-source/ships/shptaust.cpp
-source/ships/shptauto.cpp
-source/ships/shpwolmi.cpp
-source/ships/shpyusra.cpp
-source/ships/shpzeksh.cpp
+source/tests/testmain.cpp
 source/tests/testdatapath.cpp
-source/tests/testmain.cpp
-source/twgui/twbutton.cpp
-source/twgui/twbuttontypes.cpp
 source/twgui/twgui.cpp
 source/twgui/twhelpers.cpp
+source/twgui/twbuttontypes.cpp
+source/twgui/twbutton.cpp
 source/twgui/twmenuexamples.cpp
 source/twgui/twpopup.cpp
 source/twgui/twwindow.cpp
 source/twgui/utils.cpp
-source/util/aarot.c
-source/util/aastr.c
-source/util/aautil.c
-source/util/base.cpp
-source/util/endian.cpp
-source/util/errors.cpp
-source/util/errors_c.c
-source/util/get_time.c
-source/util/history.cpp
-source/util/pmask.c
-source/util/random.cpp
-source/util/round.c
-source/util/sound.cpp
-source/util/sounds.cpp
-source/util/types.cpp
-source/util/vector2.cpp
+source/libraries/lua/lib/ldblib.c
+source/libraries/lua/lib/lauxlib.c
+source/libraries/lua/lib/lbaselib.c
+source/libraries/lua/lib/loadlib.c
+source/libraries/lua/lib/ltablib.c
+source/libraries/lua/lib/lmathlib.c
+source/libraries/lua/lib/lstrlib.c
+source/libraries/lua/lib/liolib.c
+source/libraries/lua/lundump.c
+source/libraries/lua/ldebug.c
+source/libraries/lua/ldo.c
+source/libraries/lua/lgc.c
+source/libraries/lua/ltm.c
+source/libraries/lua/lvm.c
+source/libraries/lua/lcode.c
+source/libraries/lua/ldump.c
+source/libraries/lua/lfunc.c
+source/libraries/lua/lparser.c
+source/libraries/lua/ltable.c
+source/libraries/lua/ltests.c
+source/libraries/lua/lstate.c
+source/libraries/lua/lapi.c
+source/libraries/lua/llex.c
+source/libraries/lua/lmem.c
+source/libraries/lua/lzio.c
+source/libraries/lua/lopcodes.c
+source/libraries/lua/lobject.c
+source/libraries/lua/lstring.c
+source/libraries/agup/aphoton.c
+source/libraries/agup/ans.c
+source/libraries/agup/awin95.c
+source/libraries/agup/aalg.c
+source/libraries/agup/aase.c
+source/libraries/agup/agtk.c
+source/libraries/agup/agup.c
+source/libraries/agup/abeos.c
+source/libraries/agup/abitmap.c
+source/libraries/raknet/AES128.cpp
+source/libraries/raknet/PacketPool.cpp
+source/libraries/raknet/ExtendedOverlappedPool.cpp
+source/libraries/raknet/RakServer.cpp
+source/libraries/raknet/RPCNode.cpp
+source/libraries/raknet/RSA.cpp
+source/libraries/raknet/RakClient.cpp
+source/libraries/raknet/HuffmanEncodingTreeFactory.cpp
+source/libraries/raknet/RakPeer.cpp
+source/libraries/raknet/SocketLayer.cpp
+source/libraries/raknet/StringCompressor.cpp
+source/libraries/raknet/DataBlockEncryptor.cpp
+source/libraries/raknet/InternalPacketPool.cpp
+source/libraries/raknet/SHA1.cpp
+source/libraries/raknet/rand.cpp
+source/libraries/raknet/GetTime.cpp
+source/libraries/raknet/EncodeClassName.cpp
+source/libraries/raknet/NetworkObject.cpp
+source/libraries/raknet/SimpleMutex.cpp
+source/libraries/raknet/Euclid.cpp
+source/libraries/raknet/DistributedNetworkObjectStub.cpp
+source/libraries/raknet/ReliabilityLayer.cpp
+source/libraries/raknet/AsynchronousFileIO.cpp
+source/libraries/raknet/HuffmanEncodingTree.cpp
+source/libraries/raknet/BitStream.cpp
+source/libraries/raknet/RakNetworkFactory.cpp
+source/libraries/raknet/DistributedNetworkObject.cpp
+source/libraries/raknet/MPUInt.cpp
+source/libraries/raknet/CheckSum.cpp
+source/libraries/raknet/DistributedNetworkObjectManager.cpp
+source/libraries/raknet/NetworkTypes.cpp
+source/libraries/jpgalleg/io.c
+source/libraries/jpgalleg/encode.c
+source/libraries/jpgalleg/decode.c
+source/libraries/jpgalleg/jpgalleg.c
+source/scp.cpp
+source/doxygen.cpp
+source/input.cpp
+source/sc1ships/shpearcr.cpp
+source/sc1ships/shpchebr.cpp
+source/sc1ships/shpandgu.cpp
+source/sc1ships/shpilwav.cpp
+source/sc1ships/shpkzedr.cpp
+source/sc1ships/shpyehte.cpp
+source/sc1ships/shpsyrpe.cpp
+source/sc1ships/shpspael.cpp
+source/sc1ships/shpvuxin.cpp
+source/sc1ships/shpumgdr.cpp
+source/sc1ships/shparisk.cpp
+source/sc1ships/shpmycpo.cpp
+source/sc1ships/shpmmrxf.cpp
+source/sc1ships/shpshosc.cpp
+source/sc2ships/shpthrto.cpp
+source/sc2ships/shporzne.cpp
+source/sc2ships/shpdruma.cpp
+source/sc2ships/shpmeltr.cpp
+source/sc2ships/shpchmav.cpp
+source/sc2ships/shpkohma.cpp
+source/sc2ships/shputwju.cpp
+source/sc2ships/shpsupbl.cpp
+source/sc2ships/shppkufu.cpp
+source/sc2ships/shpslypr.cpp
+source/sc2ships/shpzfpst.cpp
+source/gui.cpp

Copied: branches/multiplayer-branch/web/3dlogo.jpg (from rev 69, trunk/web/3dlogo.jpg)


Property changes on: branches/multiplayer-branch/web/3dlogo.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Copied: branches/multiplayer-branch/web/background.jpg (from rev 69, trunk/web/background.jpg)


Property changes on: branches/multiplayer-branch/web/background.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Copied: branches/multiplayer-branch/web/dialog-editor-win32-62.zip (from rev 69, trunk/web/dialog-editor-win32-62.zip)


Property changes on: branches/multiplayer-branch/web/dialog-editor-win32-62.zip
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Copied: branches/multiplayer-branch/web/downloads.html (from rev 69, trunk/web/downloads.html)

Modified: branches/multiplayer-branch/web/index.html
===================================================================
--- branches/multiplayer-branch/web/index.html	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/web/index.html	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,117 +1,78 @@
 <html>
 
 <head>
-	<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
+<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
 <meta http-equiv="content-type" content="text/html; charset=windows-1251">
 <meta name="description" content="Homepage of TW-Light.">
-<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan 
-orz spathi adventure opensource game zip yurand fork TW">
+<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
 <title>TW-Light</title>
 </head>
 
 <body>
 
-<!--
-<div align="center"><center>
-<table border="0" cellpadding="0" cellspacing="0">
-	<tr><td align="center"><img border="0" src="logo.png" alt="TW-Light" width="390" height="150"></td></tr>
-</table>
-</center>
+<div class="navbar">
+  <table class="navlinks" summary="navigation bar">
+    <tr>
+      <td>
+        <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
+      </td>
+      <td>
+      <a id="curpagelink" href="./index.html">News</a> | <a href="./info.html">Info</a> | <a href="./team.html">Team</a> | <a  href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a href="./links.html">Links</a>
+      </td>
+    </tr>
+  </table>
 </div>
--->
 
-<p><div class="title"><center>about</center></div>
-<p></p>
-<table border="0" width="100%">
-<td>
-	<a href="snapshot.png"><img src="snapshot.png" alt="snapshot" width="240" height="180" border="1"></a>
-</td>
-<td>
-	<p align="left"><font size="3">TW-Light is an open source clone/sequel to the epic cross-genre 
-		game Star Control II. Currently it includes only a combat portion, although there 
-		are some plans to expand it to include an epic adventure. TW-Light is derivative work
-		from <a href="http://timewarp.sourceforge.net/">Star Control: Timewarp</a>
-		</font>
-	</p>
+<div class="main">
+  <h3 class="important">TW-Light</h3>
+  <p class="indented">
+  TW-Light is an open source clone/sequel to the epic cross-genre game
+ Star Control II. Currently it includes only a combat portion, although
+ epic adventure part that is called TW:Legacies is actively developed
+ now. TW-Light is derivative work from Star Control: Timewarp
+  
+<a href="http://timewarp.sourceforge.net/">Star Control: Timewarp</a>
+</p>
 
-
-	<p align="left"><font size="3">
-		TW-Light is written in portable C++ 							
-		and is known to compile and run on <b>Linux</b>  and <b>Windows</b> 
-		(with the exception that it is still not 64-bit clean 
-		as nobody of us has access to such hardware)</font>
-	</p>
-</td>
-	</table>
-	
-<p align="left"><font size="3">More detailed information about the game: 
-<a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a>, 
-<!--
-<br>
-<br>
-Subscribe to our <a href="http://sourceforge.net/mail/?group_id=13354">mailing lists</a> if you want to always know the latest news about TimeWarp.
---></font>
+<p class="indented">
+TW-Light is written in portable C++ and is known to compile and run on <b>Linux</b>  
+and <b>Windows</b> (with the exception that it is still not 64-bit clean as nobody of 
+us has access to such hardware)
 </p>
 
-<div class="title"><center>downloads</center></div>
-<p><div class="indented">
-	The latest version is <b>0.2r16</b>.
-	You can download it <a href="http://developer.berlios.de/project/showfiles.php?group_id=2082&release_id=3153">here.</a><br>
+<br />
 
-	To successfully compile the sources and play the game on Linux/Unix you first need 
-	<a href="http://www.allegro.cc/files/index.html">Allegro</a>
-	<!--	
-	 and <a href="http://www.lua.org">Lua</a>
-	View <a href="">ChangeLog</a> to see the list of the latest changes.<br>
-	-->
-</div>	
-</div></p>
+<h2>News</h2>
 
-<!-- <div class="title"><center>news</center></div> -->
+<!--
+<h3>Announcing the Ultronomicon<span class="date">(Friday, September 3 2004)</span></h3>
+<p class="indented">
+    The <a href="http://uqm.stack.nl/wiki/">Ultronomicon</a>, our new wiki
+    database, is now officially open.
+    We've chosen the <a href="http://creativecommons.org/licenses/by/2.0/">
+    Creative Commons Attribution 2.0</a> license for all its text.
+</p>
 
+<p class="indented">
+    The goal is to make it a complete reference work for everything relating
+    to The Ur-Quan Masters, including the Star Control universe, gameplay,
+    technical tips, and developer info.
+</p>
 
-<div class="title"><center>development</center></div>
-<p>
-TW-Light is developed by a group of Star Control fans. Though the game is quite playable 
-now, it is far from being complete. The development of this game is still going 
-on. Please note, that this is a <b>real project</b>, not just a collection of 
-plans, ideas and dreams like in some other places in the net.
-
-Things may seem to change slow, but there is real progress and every new version 
-is (we hope ;-) better than previous one. Anyway it is better to have a working 
-game than lots of ideas, but no code at all. All the work is done in our spare 
-time, so don't expect that your nice suggestion will be implemented in a short 
-time. If you are badly missing some feature and think that you can make it 
-youself, your patch will be welcome (if it does not break all the rest ;-)
+<p class="indented">
+    I encourage everyone to write a bit about their favourite Ur-Quan Masters
+    subject, so that we will have something to show soon.
+</p>
+-->
+  
+</div>
+	
+<!--
 <br>
 <br>
-You can support the project by participating discussion in 
-<a href="http://timewarp.sourceforge.net/forum/index.php">TimeWarp forum</a>, 
-where you can post suggestions for future development or just any questions about TW-Light.<br>
-<br>
-You can support the project by posting bugreports and patches in 
-<a href="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">TimeWarp Bugzilla</a>
-<br><br>
-<br>
-<a href="http://svn.berlios.de/viewcvs/tw-light/">TW-Light SVN repository</a> 
+Subscribe to our <a href="http://sourceforge.net/mail/?group_id=13354">mailing lists</a> if you want to always know the latest news about TimeWarp.
+-->
 
-</p>
-
-<p align="left"><font size="3"><strong>TW-Light resources</strong></font></p>
-
-<ul>
-    <li><a href="http://developer.berlios.de/projects/tw-light/">BerliOS: TW-Light Project Info</a></li>
-    <li><a href="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">TW-Light Bugzilla</a> </li>
-    <li><a href="http://timewarp.sourceforge.net/forum/index.php">TimeWarp Forum (official)</a> </li>
-</ul>
-
-<p align="left"><font size="3"><strong>other Star Control inspired game projects in development</strong></font></p>
-<ul>
-    <li><a href="http://timewarp.sourceforge.net">TimeWarp</a> </li>
-    <li><a href="http://sc2.sourceforge.net">The Ur-quan Masters</a> </li>
-    <li><a href="http://twx.sourceforge.net">TWX</a> </li>
-</ul>
-
 <p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
 <table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>

Copied: branches/multiplayer-branch/web/info.html (from rev 69, trunk/web/info.html)

Copied: branches/multiplayer-branch/web/links.html (from rev 69, trunk/web/links.html)

Deleted: branches/multiplayer-branch/web/logo.png
===================================================================
(Binary files differ)

Modified: branches/multiplayer-branch/web/style.css
===================================================================
--- branches/multiplayer-branch/web/style.css	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/web/style.css	2004-09-28 19:53:03 UTC (rev 71)
@@ -31,6 +31,7 @@
   padding: 0px 0px 0px 2px;
 }
 
+
 p {
   padding: 0px 0px 0px 2px;
 }
@@ -63,9 +64,10 @@
 }
 
 /* top navigation bar */
-.topbar {
+.navbar {
   color: #ffffff;
   background-color: #001133;
+  background-image: url(background.jpg);
   margin-left: 1em;
   margin-right: 1em;
   margin-top: 1em;
@@ -77,19 +79,19 @@
   font-weight: bold;
 }
 
-/* topbar links */
-.toplinks {
+/* navbar links */
+.navlinks {
   font-size: 110%;
   text-align: center;
 }
 
-/* topbar links table settings */
-table.toplinks td {
+/* navbar links table settings */
+table.navlinks td {
   padding: 0px 10px 0px 0px;
   margin-left: 1em;
 }
 
-/* current page in topbar links */
+/* current page in navbar links */
 #curpagelink {
   color: white;
   background-color: transparent;
@@ -104,6 +106,7 @@
 .main {
   color: #ffffff;
   background-color: #001133;
+/*  background-image: url(./bluepurplenebula2.jpg);*/
   margin-left: 1em;
   margin-right: 1em;
   margin-top: 1em;
@@ -163,6 +166,7 @@
   width: 100%;
 }
 
+
 /* important (red) <h3> */
 h3.important {
   color: white;
@@ -172,14 +176,4 @@
   border-right: 2px solid #bb0000;
   border-bottom: 2px solid #bb0000;
   padding: 0px 0px 0px 2px;
-}
-
-.title {
-  color: white;
-  background-color: #661166;
-  border-top: 2px solid #994499;
-  border-left: 2px solid #994499;
-  border-right: 2px solid #994499;
-  border-bottom: 2px solid #994499;    
-  padding: 0px 0px 0px 2px;
-}
+}
\ No newline at end of file

Copied: branches/multiplayer-branch/web/team.html (from rev 69, trunk/web/team.html)

Modified: branches/multiplayer-branch/web/update.sh
===================================================================
--- branches/multiplayer-branch/web/update.sh	2004-09-28 19:44:24 UTC (rev 70)
+++ branches/multiplayer-branch/web/update.sh	2004-09-28 19:53:03 UTC (rev 71)
@@ -1,2 +1,2 @@
 #!/bin/bash
-pscp index.html yurand at shell.berlios.de:/home/groups/tw-light/htdocs
\ No newline at end of file
+pscp 3dlogo.jpg background.jpg downloads.html index.html info.html links.html team.html style.css yurand at shell.berlios.de:/home/groups/tw-light/htdocs
\ No newline at end of file



From yurand at sheep.berlios.de  Wed Sep 29 20:40:05 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Wed, 29 Sep 2004 20:40:05 +0200
Subject: [Tw-light-svn] r72 - in trunk: source source/libraries/raknet web
Message-ID: <200409291840.i8TIe5up017927@sheep.berlios.de>

Author: yurand
Date: 2004-09-29 20:40:02 +0200 (Wed, 29 Sep 2004)
New Revision: 72

Modified:
   trunk/source/libraries/raknet/Queue.h
   trunk/source/scp.cpp
   trunk/web/downloads.html
   trunk/web/index.html
   trunk/web/update.sh
Log:
Fixed bug #104, in raknet library


Modified: trunk/source/libraries/raknet/Queue.h
===================================================================
--- trunk/source/libraries/raknet/Queue.h	2004-09-28 19:53:03 UTC (rev 71)
+++ trunk/source/libraries/raknet/Queue.h	2004-09-29 18:40:02 UTC (rev 72)
@@ -209,7 +209,7 @@
 		array = new queue_type [original_copy.size()+1];
 
 		for (unsigned long counter=0L; counter < original_copy.size(); ++counter)
-			array[counter] = original_copy.array[(original_copy.head + counter)%(orignal_copy.allocation_size)];
+			array[counter] = original_copy.array[(original_copy.head + counter)%(original_copy.allocation_size)];
 			
 		head=0L;
 		tail=original_copy.size();

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2004-09-28 19:53:03 UTC (rev 71)
+++ trunk/source/scp.cpp	2004-09-29 18:40:02 UTC (rev 72)
@@ -651,6 +651,8 @@
     
     videosystem->set_resolution(screen_width, screen_height, screen_bpp, fullscreen);
     register_bitmap_file_type("jpg", load_jpg, NULL);
+    showLoadingScreen();
+    
     if(!theme)
 	theme = agup_theme_by_name("Photon");
     agup_init(theme);    
@@ -668,8 +670,6 @@
     tw_sound->set_sound_volume(tw_sound->load_sound_volume());
     tw_sound->set_music_volume(tw_sound->load_music_volume());
     
-    showLoadingScreen();
-    
     View *v = NULL;
     v = get_view ( get_config_string("View", "View", NULL) , NULL );
     if (!v) v = get_view ( "Hero", NULL );

Modified: trunk/web/downloads.html
===================================================================
--- trunk/web/downloads.html	2004-09-28 19:53:03 UTC (rev 71)
+++ trunk/web/downloads.html	2004-09-29 18:40:02 UTC (rev 72)
@@ -27,7 +27,7 @@
   <h2>Downloads</h2>
   
 <p class="indented">
-The latest version is <b>0.2r16</b>. You can download it <a href="http://developer.berlios.de/project/showfiles.php?group_id=2082&release_id=3153">here.</a>
+The latest version is <b>0.3r69</b>. You can download it <a href="http://developer.berlios.de/project/showfiles.php?group_id=2082&release_id=3480">here.</a>
 
 <p class="indented">
 To successfully compile the sources and play the game on Linux/Unix you first need 

Modified: trunk/web/index.html
===================================================================
--- trunk/web/index.html	2004-09-28 19:53:03 UTC (rev 71)
+++ trunk/web/index.html	2004-09-29 18:40:02 UTC (rev 72)
@@ -25,13 +25,11 @@
 
 <div class="main">
   <h3 class="important">TW-Light</h3>
-  <p class="indented">
+<p class="indented">
   TW-Light is an open source clone/sequel to the epic cross-genre game
  Star Control II. Currently it includes only a combat portion, although
  epic adventure part that is called TW:Legacies is actively developed
- now. TW-Light is derivative work from Star Control: Timewarp
-  
-<a href="http://timewarp.sourceforge.net/">Star Control: Timewarp</a>
+ now. TW-Light is derivative work from <a href="http://timewarp.sourceforge.net/">Star Control: Timewarp</a>
 </p>
 
 <p class="indented">
@@ -40,6 +38,10 @@
 us has access to such hardware)
 </p>
 
+<p class="indented">
+Subscribe to our <a href="https://developer.berlios.de/mail/?group_id=2082">mailing lists</a> if you want to always know the latest news about TW-Light.
+</p>
+
 <br />
 
 <h2>News</h2>
@@ -70,7 +72,7 @@
 <!--
 <br>
 <br>
-Subscribe to our <a href="http://sourceforge.net/mail/?group_id=13354">mailing lists</a> if you want to always know the latest news about TimeWarp.
+Subscribe to our <a href="http://sourceforge.net/mail/?group_id=13354">mailing lists</a> if you want to always know the latest news about TW-Light.
 -->
 
 <p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>

Modified: trunk/web/update.sh
===================================================================
--- trunk/web/update.sh	2004-09-28 19:53:03 UTC (rev 71)
+++ trunk/web/update.sh	2004-09-29 18:40:02 UTC (rev 72)
@@ -1,2 +1,2 @@
 #!/bin/bash
-pscp 3dlogo.jpg background.jpg downloads.html index.html info.html links.html team.html style.css yurand at shell.berlios.de:/home/groups/tw-light/htdocs
\ No newline at end of file
+pscp siglogo.jpeg yurand at shell.berlios.de:/home/groups/tw-light/htdocs
\ No newline at end of file



From youbastrd at sheep.berlios.de  Wed Sep 29 22:59:38 2004
From: youbastrd at sheep.berlios.de (Paul Forest at BerliOS)
Date: Wed, 29 Sep 2004 22:59:38 +0200
Subject: [Tw-light-svn] r73 - trunk/web
Message-ID: <200409292059.i8TKxcdl024922@sheep.berlios.de>

Author: youbastrd
Date: 2004-09-29 22:59:37 +0200 (Wed, 29 Sep 2004)
New Revision: 73

Added:
   trunk/web/www.robeterproductions.com.jpg
Modified:
   trunk/web/team.html
Log:
adding image and link to Robeter Productions webpage; adding Abe to credit list

Modified: trunk/web/team.html
===================================================================
--- trunk/web/team.html	2004-09-29 18:40:02 UTC (rev 72)
+++ trunk/web/team.html	2004-09-29 20:59:37 UTC (rev 73)
@@ -47,6 +47,12 @@
     <li>Rick Bushie <a href="mailto:firehazurd at yahoo.com">(Firehazurd)</a></li>
   </ul>
   
+  <h4>Music</h>
+  <ul>
+    <li>Robeter Productions <a href=http://www.robeterproductions.com>(www.robeterproductions.com)<img style="float:right" src=www.robeterproductions.com.jpg></a></li>
+    <li>Mark Forest (Abe Froman)</li>
+  </ul>
+  
   <h4>Special Thanks:</h4>
   <ul>
     <li>Tau</li>

Added: trunk/web/www.robeterproductions.com.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/web/www.robeterproductions.com.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



