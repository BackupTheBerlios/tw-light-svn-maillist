From yurand at sheep.berlios.de  Sun Oct  3 00:14:54 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 3 Oct 2004 00:14:54 +0200
Subject: [Tw-light-svn] r74 - in trunk: Util/deditor source web
Message-ID: <200410022214.i92MEs6H005192@sheep.berlios.de>

Author: yurand
Date: 2004-10-03 00:14:53 +0200 (Sun, 03 Oct 2004)
New Revision: 74

Removed:
   trunk/web/dialog-editor-win32-62.zip
Modified:
   trunk/Util/deditor/mainwidget.cpp
   trunk/Util/deditor/node.cpp
   trunk/Util/deditor/node.h
   trunk/source/scp.cpp
   trunk/web/downloads.html
   trunk/web/index.html
   trunk/web/info.html
   trunk/web/links.html
   trunk/web/team.html
   trunk/web/update.sh
Log:
Dialog editor ID order fix


Modified: trunk/Util/deditor/mainwidget.cpp
===================================================================
--- trunk/Util/deditor/mainwidget.cpp	2004-09-29 20:59:37 UTC (rev 73)
+++ trunk/Util/deditor/mainwidget.cpp	2004-10-02 22:14:53 UTC (rev 74)
@@ -1,514 +1,516 @@
-
-#include "mainwidget.h"
-#include <qtextbrowser.h>
-#include <qtable.h> 
-#include <qlistview.h>
-#include <qlineedit.h>
-#include <qxml.h> 
-#include <qfile.h>
-#include <qmessagebox.h>
-#include <qmultilineedit.h>
-#include <qimage.h>
-#include <qdir.h>
-#include <qcheckbox.h>
-#include <qspinbox.h>
-
-#include <assert.h>
-
-#include "node.h"
-#include "xmlparser.h"
-#include <io.h>
-
-extern "C" {
-#	include "lua.h"
-#	include "lualib.h"
-#	include "lauxlib.h"
-}
-
-DialogEditor::DialogEditor( QWidget* parent, const char* name, WFlags fl ): DialogEditorGenerated(parent, name, fl)
-{
-	WriteLog("DialogEditor::DialogEditor\n");
-	alienTextBrowser->setFrameStyle( QFrame::Panel | QFrame::Sunken );
-	alienTextBrowser->setText("<HTML><BODY><center><img width=\"100\" height=\"100\" src=\"./tw-logo.png\"><br>Alien text and picture will be here</center></BODY></HTML>");
-	alienTextBrowser->mimeSourceFactory()->setExtensionType("qml", "text/utf8");
-
-	CreateNewNode();
-	answersListView->setSorting(-1);
-}
-
-DialogEditor::~DialogEditor()
-{
-	WriteLog("DialogEditor::~DialogEditor\n");
-}
-
-
-PlayerAnswer* DialogEditor::getPlayerAnswer(QString& text)
-{
-	NodeItem * node = (NodeItem*)nodeListView->currentItem();
-	PlayerAnswer * a;
-	for(a = node->m_answers.first();
-			a; a = node->m_answers.next())
-		if(a->m_strText == text)
-			break;
-	assert(a&&"Answer was not found in node!!!");
-	return a;
-}
-
-int DialogEditor::getPlayerAnswerPos(QString& text)
-{
-	NodeItem * node = (NodeItem*)nodeListView->currentItem();
-	PlayerAnswer * a;
-	int pos = 0;
-	for(a = node->m_answers.first();
-			a; a = node->m_answers.next())
-			{
-				if(a->m_strText == text)
-					break;
-				pos++;
-			}
-	assert(a&&"Answer was not found in node!!!");
-	return pos;
-}
-
-void DialogEditor::removeAnswer()
-{		
-	WriteLog("DialogEditor::removeAnswer()\n");
-	QListViewItem * curAnsw = answersListView->currentItem();
-	if (!curAnsw)
-			return;
-	NodeItem * node = (NodeItem*)nodeListView->currentItem();
-	node->m_answers.remove(getPlayerAnswer(curAnsw->text(0)));
-
-	delete curAnsw;
-}
-
-void DialogEditor::removeNode()
-{
-	WriteLog("DialogEditor::removeNode()\n");
-	if(nodeListView->childCount()==1)
-		return;
-	
-	QListViewItem* item= nodeListView->currentItem();
-	QListViewItemIterator it( item );
-	it++;
-	if(it.current())
-	{
-		nodeListView->setCurrentItem(it.current());
-	}
-	else
-	{
-		QListViewItemIterator i( item );
-		i--;
-		nodeListView->setCurrentItem(i.current());
-	}
-	delete item;
-}
-
-void DialogEditor::CreateNewNode()
-{
-	WriteLog("DialogEditor::CreateNewNode()\n");
-	int nodeCount = nodeListView->childCount();
-	
-	QString strId;
-	if (nodeCount)
-	{
-		int id = 0;
-		QListViewItem* item = nodeListView->firstChild ();
-		QListViewItemIterator it( item );
-		for(;it.current();it++)
-		{
-			if(it.current()->text(0).toInt()>id)
-				id = it.current()->text(0).toInt();
-		}
-		strId.sprintf("%d",id+1);
-	}
-	else
-	{
-		strId = "0";
-	}
-	NodeItem* critem = new NodeItem ( nodeListView ) ;
-
-	NodeItem * node = (NodeItem*)nodeListView->currentItem();
-	if(node)
-	{
-		critem->setFont(node->m_strFont);
-		critem->setPicture(node->m_strPicture);
-		critem->setTextLocation(node->m_strTextLocation);
-		critem->setMusic(node->m_strMusic);
-	}
-	critem->setName("New node name");
-	critem->setID( strId );
-	nodeListView->setCurrentItem(critem);
-}
-
-void DialogEditor::nodeChangedSlot(QListViewItem* i)
-{
-	WriteLog("DialogEditor::nodeChangedSlot\n");
-	NodeItem * node = (NodeItem*)i;
-	if (!i)
-		return;
-
-	// disconnect edits from previous
-	disconnect( nodeIdLineEdit,     0, 0, 0 );
-	disconnect( NodeNameLineEdit,   0, 0, 0 );
-	disconnect( MusicEdit,          0, 0, 0 );
-	disconnect( BackgroundLineEdit, 0, 0, 0 );
-	disconnect( textLocationLineEdit, 0, 0, 0 );
-	disconnect( fontLineEdit, 0, 0, 0 );
-
-	connect( nodeIdLineEdit, SIGNAL( textChanged ( const QString&)), 
-		node, SLOT(setID(const QString&)));
-	connect( NodeNameLineEdit, SIGNAL( textChanged ( const QString&)), 
-		node, SLOT(setName(const QString&)));
-	connect( MusicEdit, SIGNAL( textChanged ( const QString&)), 
-		node, SLOT(setMusic(const QString&)));
-	connect( BackgroundLineEdit, SIGNAL( textChanged ( const QString&)), 
-		node, SLOT(setPicture(const QString&)));
-	connect( textLocationLineEdit, SIGNAL( textChanged ( const QString&)), 
-		node, SLOT(setTextLocation(const QString&)));
-	connect( fontLineEdit, SIGNAL( textChanged ( const QString&)), 
-		node, SLOT(setFont(const QString&)));
-
-	nodeIdLineEdit      ->setText(node->text(0));
-	NodeNameLineEdit    ->setText(node->text(1));
-	MusicEdit           ->setText(node->m_strMusic);
-	BackgroundLineEdit  ->setText(node->m_strPicture);
-	textLocationLineEdit->setText(node->m_strTextLocation);
-	fontLineEdit        ->setText(node->m_strFont);
-
-	// Set Browser
-	QString browserText;
-	browserText += "<HTML><BODY><CENTER>";
-	if(node->m_strPicture!= "")
-	{
-		browserText += QString("").sprintf("<img width=\"100\" height=\"100\""
-			"src=\"alien\" alt=\"Home\" border=\"0\"><br>");
-	}
-
-	browserText += node->m_strAlienText;
-	browserText += "</CENTER></BODY></HTML>";
-
-	alienTextBrowser->mimeSourceFactory()->setFilePath( QDir::currentDirPath() );
-	alienTextBrowser->mimeSourceFactory()->setImage("alien",QImage(BackgroundLineEdit->text()));
-	alienTextBrowser->setText(browserText);
-
-	// Set Answers
-	disconnectAnswer();
-	answersListView->clear();
-	for(PlayerAnswer * a = node->m_answers. last();
-		a; a = node->m_answers.prev())
-	{
-		if (script_check_condition(a->m_strAppearCondition) || !TestModeCheckBox->isChecked ())
-			QListViewItem * item = new QListViewItem(answersListView,a->m_strText);
-	//	answersListView     ->setCurrentItem(item);
-	}
-}
-
-
-void DialogEditor::disconnectAnswer()
-{
-	WriteLog("DialogEditor::disconnectAnswer()\n");
-	disconnect(condition1LineEdit, 0, 0, 0);
-	condition1LineEdit->setText("");
-	condition1LineEdit->setEnabled(FALSE);
-	disconnect(condition2LineEdit, 0, 0, 0);
-	condition2LineEdit->setText("");
-	condition2LineEdit->setEnabled(FALSE);
-	disconnect(condition3LineEdit, 0, 0, 0);
-	condition3LineEdit->setText("");
-	condition3LineEdit->setEnabled(FALSE);
-	disconnect(condition4LineEdit, 0, 0, 0);
-	condition4LineEdit->setText("");
-	condition4LineEdit->setEnabled(FALSE);
-	disconnect(condition5LineEdit, 0, 0, 0);
-	condition5LineEdit->setText("");
-	condition5LineEdit->setEnabled(FALSE);
-
-	disconnect(action1LineEdit, 0, 0, 0);
-	action1LineEdit->setText("");
-	action1LineEdit->setEnabled(FALSE);
-	disconnect(action2LineEdit, 0, 0, 0);
-	action2LineEdit->setText("");
-	action2LineEdit->setEnabled(FALSE);
-	disconnect(action3LineEdit, 0, 0, 0);
-	action3LineEdit->setText("");
-	action3LineEdit->setEnabled(FALSE);
-	disconnect(action4LineEdit, 0, 0, 0);
-	action4LineEdit->setText("");
-	action4LineEdit->setEnabled(FALSE);
-	disconnect(action5LineEdit, 0, 0, 0);
-	action5LineEdit->setText("");
-	action5LineEdit->setEnabled(FALSE);
-
-	disconnect(appearConditionLineEdit, 0, 0, 0);
-	appearConditionLineEdit->setText("");
-	appearConditionLineEdit->setEnabled(FALSE);
-}
-
-
-void DialogEditor::answerChangedSlot(QListViewItem* item)
-{
-	WriteLog("DialogEditor::answerChangedSlot(QListViewItem* item)\n");
-	disconnectAnswer();
-	if(!item)
-	{
-		condition1LineEdit->setEnabled ( FALSE ) ;
-		return;
-	}
-	
-
-	PlayerAnswer * pa = getPlayerAnswer(item->text(0));
-
-	connect( condition1LineEdit, SIGNAL( textChanged ( const QString&)), 
-		pa, SLOT(setCondition1Line(const QString&)));
-	condition1LineEdit->setEnabled(TRUE);
-	connect( condition2LineEdit, SIGNAL( textChanged ( const QString&)), 
-		pa, SLOT(setCondition2Line(const QString&)));
-	condition2LineEdit->setEnabled(TRUE);
-	connect( condition3LineEdit, SIGNAL( textChanged ( const QString&)), 
-		pa, SLOT(setCondition3Line(const QString&)));
-	condition3LineEdit->setEnabled(TRUE);
-	connect( condition4LineEdit, SIGNAL( textChanged ( const QString&)), 
-		pa, SLOT(setCondition4Line(const QString&)));
-	condition4LineEdit->setEnabled(TRUE);
-	connect( condition5LineEdit, SIGNAL( textChanged ( const QString&)), 
-		pa, SLOT(setCondition5Line(const QString&)));
-	condition5LineEdit->setEnabled(TRUE);
-
-	connect( action1LineEdit, SIGNAL( textChanged ( const QString&)), 
-		pa, SLOT(setAction1Line(const QString&)));
-	action1LineEdit->setEnabled(TRUE);
-	connect( action2LineEdit, SIGNAL( textChanged ( const QString&)), 
-		pa, SLOT(setAction2Line(const QString&)));
-	action2LineEdit->setEnabled(TRUE);
-	connect( action3LineEdit, SIGNAL( textChanged ( const QString&)), 
-		pa, SLOT(setAction3Line(const QString&)));
-	action3LineEdit->setEnabled(TRUE);
-	connect( action4LineEdit, SIGNAL( textChanged ( const QString&)), 
-		pa, SLOT(setAction4Line(const QString&)));
-	action4LineEdit->setEnabled(TRUE);
-	connect( action5LineEdit, SIGNAL( textChanged ( const QString&)), 
-		pa, SLOT(setAction5Line(const QString&)));
-	action5LineEdit->setEnabled(TRUE);
-
-	connect( appearConditionLineEdit, SIGNAL( textChanged ( const QString&)), 
-		pa, SLOT(setAppearCondition(const QString&)));
-	appearConditionLineEdit->setEnabled(TRUE);
-
-	condition1LineEdit->setText(pa->m_strCond[0]);
-	condition2LineEdit->setText(pa->m_strCond[1]);
-	condition3LineEdit->setText(pa->m_strCond[2]);
-	condition4LineEdit->setText(pa->m_strCond[3]);
-	condition5LineEdit->setText(pa->m_strCond[4]);
-
-	action1LineEdit->setText(pa->m_strAct[0]);
-	action2LineEdit->setText(pa->m_strAct[1]);
-	action3LineEdit->setText(pa->m_strAct[2]);
-	action4LineEdit->setText(pa->m_strAct[3]);
-	action5LineEdit->setText(pa->m_strAct[4]);
-
-	appearConditionLineEdit->setText(pa->m_strAppearCondition);
-
-	commonMultiLineEdit->setText(item->text(0));
-}
-
-QString DialogEditor::GetXML()
-{
-	WriteLog("DialogEditor::edited()\n");
-	QString strRes;
-	strRes += "<NODES>";
-	QListViewItem* item = nodeListView->firstChild ();
-	QListViewItemIterator it( item );
-	for(;it.current();it++)
-	{
-		NodeItem *item = (NodeItem*)it.current();
-		strRes += "<NODE id=\""   + TWEscapeXML(item->text(0)) + "\"";
-		strRes += " name=\""      + TWEscapeXML(item->text(1)) + "\"";
-		strRes += " music=\""     + TWEscapeXML(item->m_strMusic) + "\"";
-		strRes += " background=\""+ TWEscapeXML(item->m_strPicture) + "\"";
-		strRes += " alien_text=\""+ TWEscapeXML(item->m_strAlienText) + "\"";
-		strRes += " font=\""+ TWEscapeXML(item->m_strFont) + "\"";
-		strRes += " text_location=\""+ TWEscapeXML(item->m_strTextLocation) + "\"";
-		strRes += ">";
-
-
-		for(PlayerAnswer * a = item->m_answers.first();
-			a; a = item->m_answers.next())
-		{	
-			strRes +="<PLAYER_ANSWER ";
-			strRes +="text=\"" + TWEscapeXML(a->m_strText) + "\" ";
-			strRes +="appear_condition=\"" + TWEscapeXML(a->m_strAppearCondition) + "\">";
-			
-			for(int j=0;j<5;j++)
-				if( !(a->m_strCond[j].isEmpty()) && !(a->m_strAct[j].isEmpty()))
-				{
-					strRes += "<ACTION ";
-					strRes += "condition=\"" + TWEscapeXML(a->m_strCond[j]) + "\" ";
-					strRes += "action=\"" + TWEscapeXML(a->m_strAct[j]) + "\">";
-					strRes += "</ACTION>";
-				}
-			strRes +="</PLAYER_ANSWER>";
-		}
-		strRes += "</NODE>";
-	}
-	strRes += "</NODES>";
-	return strRes;
-}
-
-void DialogEditor::loadDoc(QString fileName)
-{
-  WriteLog("DialogEditor::loadDoc(QString fileName)\n");
-
-  if(fileName.find(".xml", 0, FALSE)==-1)
-  {
-	  QString mes;
-	  mes.sprintf("file:\n%s\nDoes not have xml extension", fileName);
-
-	  QMessageBox::warning (this, "TW-Light editor",
-			mes);
-  }
-
-  QFile f(fileName);
-  XMLParser handler(this);
-  QXmlInputSource source(f);
-
-  QXmlSimpleReader reader;
-  reader.setContentHandler( &handler );
-  reader.parse( source );
-}
-
-void DialogEditor::setAlienText()
-{
-	WriteLog("DialogEditor::setAlienText()\n");
-	NodeItem * node = (NodeItem*)nodeListView->currentItem();
-	node->m_strAlienText = commonMultiLineEdit->text();
-	nodeChangedSlot(node);
-}
-
-void DialogEditor::setPlayerAnswerText()
-{
-	WriteLog("DialogEditor::setPlayerAnswerText()\n");
-	QListViewItem * curAnsw = answersListView->currentItem();
-	if(!curAnsw)
-		return;
-	PlayerAnswer * pa = getPlayerAnswer(curAnsw->text(0));
-	pa->m_strText = commonMultiLineEdit->text();
-	curAnsw->setText(0, commonMultiLineEdit->text());
-}
-
-void DialogEditor::AddPlayerAnswer()
-{
-	WriteLog("DialogEditor::AddPlayerAnswer()\n");
-	NodeItem * node = (NodeItem*)nodeListView->currentItem();
-	PlayerAnswer * item = new PlayerAnswer;
-	item->m_strText = commonMultiLineEdit->text();
-	item->m_strAppearCondition = "1";
-
-	node->m_answers.append(item);
-	nodeChangedSlot(node);
-}
-
-// To be implemented
-bool DialogEditor::script_check_condition(QString & condition)
-{
-	WriteLog("DialogEditor::script_check_condition(QString & condition)\n");
-	return true;
-}
-
-NodeItem * DialogEditor::getNodeItem(QString& id)
-{
-	WriteLog("DialogEditor::getNodeItem(QString& id)\n");
-	QListViewItem* item = nodeListView->firstChild ();
-	QListViewItemIterator it( item );
-	for(;it.current();it++)
-	{
-		if(it.current()->text(0) == id)
-			return (NodeItem *)it.current();
-	}
-	return NULL;
-}
-
-
-void DialogEditor::processAnswerSlot(QListViewItem* item)
-{
-	WriteLog("DialogEditor::processAnswerSlot(QListViewItem* item)\n");
-	PlayerAnswer* answer = getPlayerAnswer(item->text(0));
-	for(int i=0;i<5;i++)
-	{
-			lua_State * L = lua_open();
-			lua_baselibopen(L);
-			lua_iolibopen(L);
-			lua_strlibopen(L);
-			lua_mathlibopen(L);
-			bool eva = lua_dostring(L, "function goto(id) gotoid = id; end");
-			eva = lua_dostring(L, answer->m_strAct[i]);
-			lua_getglobal(L, "gotoid");
-			if (lua_isstring(L, -1)) 
-			{
-				const char * id = lua_tostring(L, -1);
-				NodeItem * node = getNodeItem(QString(id));
-				if(node)
-					nodeListView->setCurrentItem(node);
-			}
-			lua_close(L);
-	}
-}
-
-void DialogEditor::answerUp()
-{
-	NodeItem * node = (NodeItem*)nodeListView->currentItem();
-	QListViewItem * item = answersListView->currentItem();
-
-	if(!node || !item)
-		return;
-	
-	int pos = getPlayerAnswerPos(item->text(0));
-	if(pos==0)
-		return;
-	
-	QString strText = item->text(0);
-	PlayerAnswer* answer = node->m_answers.take(pos);
-	node->m_answers.insert(pos-1, answer);
-
-	nodeChangedSlot(node);	
-
-	QListViewItemIterator it( answersListView->firstChild () );
-	for(;it.current();it++)
-	{
-		if(it.current()->text(0)==strText)
-		{
-			answersListView->setCurrentItem(it.current());
-			break;
-		}
-	}
-}
-
-void DialogEditor::answerDown()
-{
-	NodeItem * node = (NodeItem*)nodeListView->currentItem();
-	QListViewItem * item = answersListView->currentItem();
-	
-	if(!node || !item)
-		return;
-
-	int pos = getPlayerAnswerPos(item->text(0));
-	if(pos==node->m_answers.count()-1 )
-		return;
-	
-	QString strText = item->text(0);
-
-	PlayerAnswer* answer = node->m_answers.take(pos);
-	node->m_answers.insert(pos+1, answer);
-
-	nodeChangedSlot(node);	
-	QListViewItemIterator it( answersListView->firstChild () );
-	for(;it.current();it++)
-	{
-		if(it.current()->text(0)==strText)
-		{
-			answersListView->setCurrentItem(it.current());
-			break;
-		}
-	}
-}
-
+
+#include "mainwidget.h"
+#include <qtextbrowser.h>
+#include <qtable.h> 
+#include <qlistview.h>
+#include <qlineedit.h>
+#include <qxml.h> 
+#include <qfile.h>
+#include <qmessagebox.h>
+#include <qmultilineedit.h>
+#include <qimage.h>
+#include <qdir.h>
+#include <qcheckbox.h>
+#include <qspinbox.h>
+
+#include <assert.h>
+
+#include "node.h"
+#include "xmlparser.h"
+#include <io.h>
+
+extern "C" {
+#	include "lua.h"
+#	include "lualib.h"
+#	include "lauxlib.h"
+}
+
+DialogEditor::DialogEditor( QWidget* parent, const char* name, WFlags fl ): DialogEditorGenerated(parent, name, fl)
+{
+	WriteLog("DialogEditor::DialogEditor\n");
+	alienTextBrowser->setFrameStyle( QFrame::Panel | QFrame::Sunken );
+	alienTextBrowser->setText("<HTML><BODY><center><img width=\"100\" height=\"100\" src=\"./tw-logo.png\"><br>Alien text and picture will be here</center></BODY></HTML>");
+	alienTextBrowser->mimeSourceFactory()->setExtensionType("qml", "text/utf8");
+
+	CreateNewNode();
+	answersListView->setSorting(-1);
+}
+
+DialogEditor::~DialogEditor()
+{
+	WriteLog("DialogEditor::~DialogEditor\n");
+}
+
+
+PlayerAnswer* DialogEditor::getPlayerAnswer(QString& text)
+{
+	NodeItem * node = (NodeItem*)nodeListView->currentItem();
+	PlayerAnswer * a;
+	for(a = node->m_answers.first();
+			a; a = node->m_answers.next())
+		if(a->m_strText == text)
+			break;
+	assert(a&&"Answer was not found in node!!!");
+	return a;
+}
+
+int DialogEditor::getPlayerAnswerPos(QString& text)
+{
+	NodeItem * node = (NodeItem*)nodeListView->currentItem();
+	PlayerAnswer * a;
+	int pos = 0;
+	for(a = node->m_answers.first();
+			a; a = node->m_answers.next())
+			{
+				if(a->m_strText == text)
+					break;
+				pos++;
+			}
+	assert(a&&"Answer was not found in node!!!");
+	return pos;
+}
+
+void DialogEditor::removeAnswer()
+{		
+	WriteLog("DialogEditor::removeAnswer()\n");
+	QListViewItem * curAnsw = answersListView->currentItem();
+	if (!curAnsw)
+			return;
+	NodeItem * node = (NodeItem*)nodeListView->currentItem();
+	node->m_answers.remove(getPlayerAnswer(curAnsw->text(0)));
+
+	delete curAnsw;
+}
+
+void DialogEditor::removeNode()
+{
+	WriteLog("DialogEditor::removeNode()\n");
+	if(nodeListView->childCount()==1)
+		return;
+	
+	QListViewItem* item= nodeListView->currentItem();
+	QListViewItemIterator it( item );
+	it++;
+	if(it.current())
+	{
+		nodeListView->setCurrentItem(it.current());
+	}
+	else
+	{
+		QListViewItemIterator i( item );
+		i--;
+		nodeListView->setCurrentItem(i.current());
+	}
+	delete item;
+}
+
+void DialogEditor::CreateNewNode()
+{
+	WriteLog("DialogEditor::CreateNewNode()\n");
+	int nodeCount = nodeListView->childCount();
+	
+	QString strId;
+	if (nodeCount)
+	{
+		int id = 0;
+		QListViewItem* item = nodeListView->firstChild ();
+		QListViewItemIterator it( item );
+		for(;it.current();it++)
+		{
+			if(it.current()->text(0).toInt()>id)
+				id = it.current()->text(0).toInt();
+		}
+		strId.sprintf("%d",id+1);
+	}
+	else
+	{
+		strId = "0";
+	}
+	NodeItem* critem = new NodeItem ( nodeListView ) ;
+
+	NodeItem * node = (NodeItem*)nodeListView->currentItem();
+	if(node)
+	{
+		critem->setFont(node->m_strFont);
+		critem->setPicture(node->m_strPicture);
+		critem->setTextLocation(node->m_strTextLocation);
+		critem->setMusic(node->m_strMusic);
+	}
+	critem->setName("New node name");
+	critem->setID( strId );
+	nodeListView->setCurrentItem(critem);
+}
+
+void DialogEditor::nodeChangedSlot(QListViewItem* i)
+{
+	WriteLog("DialogEditor::nodeChangedSlot\n");
+	NodeItem * node = (NodeItem*)i;
+	if (!i)
+		return;
+
+	// disconnect edits from previous
+	disconnect( nodeIdLineEdit,     0, 0, 0 );
+	disconnect( NodeNameLineEdit,   0, 0, 0 );
+	disconnect( MusicEdit,          0, 0, 0 );
+	disconnect( BackgroundLineEdit, 0, 0, 0 );
+	disconnect( textLocationLineEdit, 0, 0, 0 );
+	disconnect( fontLineEdit, 0, 0, 0 );
+
+	connect( nodeIdLineEdit, SIGNAL( textChanged ( const QString&)), 
+		node, SLOT(setID(const QString&)));
+	connect( NodeNameLineEdit, SIGNAL( textChanged ( const QString&)), 
+		node, SLOT(setName(const QString&)));
+	connect( MusicEdit, SIGNAL( textChanged ( const QString&)), 
+		node, SLOT(setMusic(const QString&)));
+	connect( BackgroundLineEdit, SIGNAL( textChanged ( const QString&)), 
+		node, SLOT(setPicture(const QString&)));
+	connect( textLocationLineEdit, SIGNAL( textChanged ( const QString&)), 
+		node, SLOT(setTextLocation(const QString&)));
+	connect( fontLineEdit, SIGNAL( textChanged ( const QString&)), 
+		node, SLOT(setFont(const QString&)));
+
+	nodeIdLineEdit      ->setText(node->text(0));
+	NodeNameLineEdit    ->setText(node->text(1));
+	MusicEdit           ->setText(node->m_strMusic);
+	BackgroundLineEdit  ->setText(node->m_strPicture);
+	textLocationLineEdit->setText(node->m_strTextLocation);
+	fontLineEdit        ->setText(node->m_strFont);
+
+	// Set Browser
+	QString browserText;
+	browserText += "<HTML><BODY><CENTER>";
+	if(node->m_strPicture!= "")
+	{
+		browserText += QString("").sprintf("<img width=\"100\" height=\"100\""
+			"src=\"alien\" alt=\"Home\" border=\"0\"><br>");
+	}
+
+	browserText += node->m_strAlienText;
+	browserText += "</CENTER></BODY></HTML>";
+
+	alienTextBrowser->mimeSourceFactory()->setFilePath( QDir::currentDirPath() );
+	alienTextBrowser->mimeSourceFactory()->setImage("alien",QImage(BackgroundLineEdit->text()));
+	alienTextBrowser->setText(browserText);
+
+	// Set Answers
+	disconnectAnswer();
+	answersListView->clear();
+	for(PlayerAnswer * a = node->m_answers. last();
+		a; a = node->m_answers.prev())
+	{
+		if (script_check_condition(a->m_strAppearCondition) || !TestModeCheckBox->isChecked ())
+			QListViewItem * item = new QListViewItem(answersListView,a->m_strText);
+	//	answersListView     ->setCurrentItem(item);
+	}
+}
+
+
+void DialogEditor::disconnectAnswer()
+{
+	WriteLog("DialogEditor::disconnectAnswer()\n");
+	disconnect(condition1LineEdit, 0, 0, 0);
+	condition1LineEdit->setText("");
+	condition1LineEdit->setEnabled(FALSE);
+	disconnect(condition2LineEdit, 0, 0, 0);
+	condition2LineEdit->setText("");
+	condition2LineEdit->setEnabled(FALSE);
+	disconnect(condition3LineEdit, 0, 0, 0);
+	condition3LineEdit->setText("");
+	condition3LineEdit->setEnabled(FALSE);
+	disconnect(condition4LineEdit, 0, 0, 0);
+	condition4LineEdit->setText("");
+	condition4LineEdit->setEnabled(FALSE);
+	disconnect(condition5LineEdit, 0, 0, 0);
+	condition5LineEdit->setText("");
+	condition5LineEdit->setEnabled(FALSE);
+
+	disconnect(action1LineEdit, 0, 0, 0);
+	action1LineEdit->setText("");
+	action1LineEdit->setEnabled(FALSE);
+	disconnect(action2LineEdit, 0, 0, 0);
+	action2LineEdit->setText("");
+	action2LineEdit->setEnabled(FALSE);
+	disconnect(action3LineEdit, 0, 0, 0);
+	action3LineEdit->setText("");
+	action3LineEdit->setEnabled(FALSE);
+	disconnect(action4LineEdit, 0, 0, 0);
+	action4LineEdit->setText("");
+	action4LineEdit->setEnabled(FALSE);
+	disconnect(action5LineEdit, 0, 0, 0);
+	action5LineEdit->setText("");
+	action5LineEdit->setEnabled(FALSE);
+
+	disconnect(appearConditionLineEdit, 0, 0, 0);
+	appearConditionLineEdit->setText("");
+	appearConditionLineEdit->setEnabled(FALSE);
+}
+
+
+void DialogEditor::answerChangedSlot(QListViewItem* item)
+{
+	WriteLog("DialogEditor::answerChangedSlot(QListViewItem* item)\n");
+	disconnectAnswer();
+	if(!item)
+	{
+		condition1LineEdit->setEnabled ( FALSE ) ;
+		return;
+	}
+	
+
+	PlayerAnswer * pa = getPlayerAnswer(item->text(0));
+
+	connect( condition1LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setCondition1Line(const QString&)));
+	condition1LineEdit->setEnabled(TRUE);
+	connect( condition2LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setCondition2Line(const QString&)));
+	condition2LineEdit->setEnabled(TRUE);
+	connect( condition3LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setCondition3Line(const QString&)));
+	condition3LineEdit->setEnabled(TRUE);
+	connect( condition4LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setCondition4Line(const QString&)));
+	condition4LineEdit->setEnabled(TRUE);
+	connect( condition5LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setCondition5Line(const QString&)));
+	condition5LineEdit->setEnabled(TRUE);
+
+	connect( action1LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setAction1Line(const QString&)));
+	action1LineEdit->setEnabled(TRUE);
+	connect( action2LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setAction2Line(const QString&)));
+	action2LineEdit->setEnabled(TRUE);
+	connect( action3LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setAction3Line(const QString&)));
+	action3LineEdit->setEnabled(TRUE);
+	connect( action4LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setAction4Line(const QString&)));
+	action4LineEdit->setEnabled(TRUE);
+	connect( action5LineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setAction5Line(const QString&)));
+	action5LineEdit->setEnabled(TRUE);
+
+	connect( appearConditionLineEdit, SIGNAL( textChanged ( const QString&)), 
+		pa, SLOT(setAppearCondition(const QString&)));
+	appearConditionLineEdit->setEnabled(TRUE);
+
+	condition1LineEdit->setText(pa->m_strCond[0]);
+	condition2LineEdit->setText(pa->m_strCond[1]);
+	condition3LineEdit->setText(pa->m_strCond[2]);
+	condition4LineEdit->setText(pa->m_strCond[3]);
+	condition5LineEdit->setText(pa->m_strCond[4]);
+
+	action1LineEdit->setText(pa->m_strAct[0]);
+	action2LineEdit->setText(pa->m_strAct[1]);
+	action3LineEdit->setText(pa->m_strAct[2]);
+	action4LineEdit->setText(pa->m_strAct[3]);
+	action5LineEdit->setText(pa->m_strAct[4]);
+
+	appearConditionLineEdit->setText(pa->m_strAppearCondition);
+
+	commonMultiLineEdit->setText(item->text(0));
+}
+
+QString DialogEditor::GetXML()
+{
+	WriteLog("DialogEditor::edited()\n");
+	QString strRes;
+	strRes += "<NODES>";
+	QListViewItem* item = nodeListView->firstChild ();
+	QListViewItemIterator it( item );
+	for(;it.current();it++)
+	{
+		NodeItem *item = (NodeItem*)it.current();
+		strRes += "<NODE id=\""   + TWEscapeXML(item->text(0)) + "\"";
+		strRes += " name=\""      + TWEscapeXML(item->text(1)) + "\"";
+		strRes += " music=\""     + TWEscapeXML(item->m_strMusic) + "\"";
+		strRes += " background=\""+ TWEscapeXML(item->m_strPicture) + "\"";
+		strRes += " alien_text=\""+ TWEscapeXML(item->m_strAlienText) + "\"";
+		strRes += " font=\""+ TWEscapeXML(item->m_strFont) + "\"";
+		strRes += " text_location=\""+ TWEscapeXML(item->m_strTextLocation) + "\"";
+		strRes += ">";
+
+
+		for(PlayerAnswer * a = item->m_answers.first();
+			a; a = item->m_answers.next())
+		{	
+			strRes +="<PLAYER_ANSWER ";
+			strRes +="text=\"" + TWEscapeXML(a->m_strText) + "\" ";
+			strRes +="appear_condition=\"" + TWEscapeXML(a->m_strAppearCondition) + "\">";
+			
+			for(int j=0;j<5;j++)
+				if( !(a->m_strCond[j].isEmpty()) && !(a->m_strAct[j].isEmpty()))
+				{
+					strRes += "<ACTION ";
+					strRes += "condition=\"" + TWEscapeXML(a->m_strCond[j]) + "\" ";
+					strRes += "action=\"" + TWEscapeXML(a->m_strAct[j]) + "\">";
+					strRes += "</ACTION>";
+				}
+			strRes +="</PLAYER_ANSWER>";
+		}
+		strRes += "</NODE>";
+	}
+	strRes += "</NODES>";
+	return strRes;
+}
+
+void DialogEditor::loadDoc(QString fileName)
+{
+  WriteLog("DialogEditor::loadDoc(QString fileName)\n");
+
+  if(fileName.find(".xml", 0, FALSE)==-1)
+  {
+	  QString mes;
+	  mes.sprintf("file:\n%s\nDoes not have xml extension", fileName);
+
+	  QMessageBox::warning (this, "TW-Light editor",
+			mes);
+  }
+
+  QFile f(fileName);
+  XMLParser handler(this);
+  QXmlInputSource source(f);
+
+  QXmlSimpleReader reader;
+  reader.setContentHandler( &handler );
+  reader.parse( source );
+  if(nodeListView-> childCount ())
+	nodeListView->setCurrentItem( nodeListView->firstChild ());
+}
+
+void DialogEditor::setAlienText()
+{
+	WriteLog("DialogEditor::setAlienText()\n");
+	NodeItem * node = (NodeItem*)nodeListView->currentItem();
+	node->m_strAlienText = commonMultiLineEdit->text();
+	nodeChangedSlot(node);
+}
+
+void DialogEditor::setPlayerAnswerText()
+{
+	WriteLog("DialogEditor::setPlayerAnswerText()\n");
+	QListViewItem * curAnsw = answersListView->currentItem();
+	if(!curAnsw)
+		return;
+	PlayerAnswer * pa = getPlayerAnswer(curAnsw->text(0));
+	pa->m_strText = commonMultiLineEdit->text();
+	curAnsw->setText(0, commonMultiLineEdit->text());
+}
+
+void DialogEditor::AddPlayerAnswer()
+{
+	WriteLog("DialogEditor::AddPlayerAnswer()\n");
+	NodeItem * node = (NodeItem*)nodeListView->currentItem();
+	PlayerAnswer * item = new PlayerAnswer;
+	item->m_strText = commonMultiLineEdit->text();
+	item->m_strAppearCondition = "1";
+
+	node->m_answers.append(item);
+	nodeChangedSlot(node);
+}
+
+// To be implemented
+bool DialogEditor::script_check_condition(QString & condition)
+{
+	WriteLog("DialogEditor::script_check_condition(QString & condition)\n");
+	return true;
+}
+
+NodeItem * DialogEditor::getNodeItem(QString& id)
+{
+	WriteLog("DialogEditor::getNodeItem(QString& id)\n");
+	QListViewItem* item = nodeListView->firstChild ();
+	QListViewItemIterator it( item );
+	for(;it.current();it++)
+	{
+		if(it.current()->text(0) == id)
+			return (NodeItem *)it.current();
+	}
+	return NULL;
+}
+
+
+void DialogEditor::processAnswerSlot(QListViewItem* item)
+{
+	WriteLog("DialogEditor::processAnswerSlot(QListViewItem* item)\n");
+	PlayerAnswer* answer = getPlayerAnswer(item->text(0));
+	for(int i=0;i<5;i++)
+	{
+			lua_State * L = lua_open();
+			lua_baselibopen(L);
+			lua_iolibopen(L);
+			lua_strlibopen(L);
+			lua_mathlibopen(L);
+			bool eva = lua_dostring(L, "function goto(id) gotoid = id; end");
+			eva = lua_dostring(L, answer->m_strAct[i]);
+			lua_getglobal(L, "gotoid");
+			if (lua_isstring(L, -1)) 
+			{
+				const char * id = lua_tostring(L, -1);
+				NodeItem * node = getNodeItem(QString(id));
+				if(node)
+					nodeListView->setCurrentItem(node);
+			}
+			lua_close(L);
+	}
+}
+
+void DialogEditor::answerUp()
+{
+	NodeItem * node = (NodeItem*)nodeListView->currentItem();
+	QListViewItem * item = answersListView->currentItem();
+
+	if(!node || !item)
+		return;
+	
+	int pos = getPlayerAnswerPos(item->text(0));
+	if(pos==0)
+		return;
+	
+	QString strText = item->text(0);
+	PlayerAnswer* answer = node->m_answers.take(pos);
+	node->m_answers.insert(pos-1, answer);
+
+	nodeChangedSlot(node);	
+
+	QListViewItemIterator it( answersListView->firstChild () );
+	for(;it.current();it++)
+	{
+		if(it.current()->text(0)==strText)
+		{
+			answersListView->setCurrentItem(it.current());
+			break;
+		}
+	}
+}
+
+void DialogEditor::answerDown()
+{
+	NodeItem * node = (NodeItem*)nodeListView->currentItem();
+	QListViewItem * item = answersListView->currentItem();
+	
+	if(!node || !item)
+		return;
+
+	int pos = getPlayerAnswerPos(item->text(0));
+	if(pos==node->m_answers.count()-1 )
+		return;
+	
+	QString strText = item->text(0);
+
+	PlayerAnswer* answer = node->m_answers.take(pos);
+	node->m_answers.insert(pos+1, answer);
+
+	nodeChangedSlot(node);	
+	QListViewItemIterator it( answersListView->firstChild () );
+	for(;it.current();it++)
+	{
+		if(it.current()->text(0)==strText)
+		{
+			answersListView->setCurrentItem(it.current());
+			break;
+		}
+	}
+}
+

Modified: trunk/Util/deditor/node.cpp
===================================================================
--- trunk/Util/deditor/node.cpp	2004-09-29 20:59:37 UTC (rev 73)
+++ trunk/Util/deditor/node.cpp	2004-10-02 22:14:53 UTC (rev 74)
@@ -1,111 +1,123 @@
-
-#include "node.h"
-
-PlayerAnswer::PlayerAnswer()
-{
-	m_strAppearCondition = "";
-	m_strText = "";
-
-	m_strCond[0] = "";
-	m_strCond[1] = "";
-	m_strCond[2] = "";
-	m_strCond[3] = "";
-	m_strCond[4] = "";
-
-	m_strAct[0] = "";
-	m_strAct[1] = "";
-	m_strAct[2] = "";
-	m_strAct[3] = "";
-	m_strAct[4] = "";
-}
-
-void PlayerAnswer::setCondition1Line(const QString& text)
-{
-	m_strCond[0] = text;
-}
-void PlayerAnswer::setCondition2Line(const QString& text)
-{
-	m_strCond[1] = text;
-}
-void PlayerAnswer::setCondition3Line(const QString& text)
-{
-	m_strCond[2] = text;
-}
-void PlayerAnswer::setCondition4Line(const QString& text)
-{
-	m_strCond[3] = text;
-}
-void PlayerAnswer::setCondition5Line(const QString& text)
-{
-	m_strCond[4] = text;
-}
-
-
-void PlayerAnswer::setAction1Line(const QString& text)
-{
-	m_strAct[0] = text;
-}
-void PlayerAnswer::setAction2Line(const QString& text)
-{
-	m_strAct[1] = text;
-}
-void PlayerAnswer::setAction3Line(const QString& text)
-{
-	m_strAct[2] = text;
-}
-void PlayerAnswer::setAction4Line(const QString& text)
-{
-	m_strAct[3] = text;
-}
-
-void PlayerAnswer::setAction5Line(const QString& text)
-{
-	m_strAct[4] = text;
-}
-
-void PlayerAnswer::setAppearCondition(const QString& text)
-{
-	m_strAppearCondition = text;
-}
-
-
-NodeItem::NodeItem ( QListView * parent ):
-	QListViewItem(parent) 
-{
-		m_strMusic = "";
-		m_strPicture = "";
-		m_strAlienText ="";
-		m_strTextLocation = "";
-		m_strFont = "";
-}; 
-
-void NodeItem::setID       ( const QString & text)
-{
-	setText(0,text);
-}
-void NodeItem::setName     ( const QString & text)
-{
-	setText(1,text);
-}
-void NodeItem::setMusic    ( const QString & text)
-{
-	m_strMusic = text;
-}
-void NodeItem::setPicture  ( const QString & text)
-{
-	m_strPicture = text;
-}
-void NodeItem::setAlienText( const QString & text)
-{
-	m_strAlienText = text;
-}
-void NodeItem::setTextLocation(const QString& text)
-{
-	m_strTextLocation = text;
-}
-
-void NodeItem::setFont(const QString& text)
-{
-	m_strFont = text;
-}
-
+
+#include <qmessagebox.h>
+
+#include "node.h"
+
+PlayerAnswer::PlayerAnswer()
+{
+	m_strAppearCondition = "";
+	m_strText = "";
+
+	m_strCond[0] = "";
+	m_strCond[1] = "";
+	m_strCond[2] = "";
+	m_strCond[3] = "";
+	m_strCond[4] = "";
+
+	m_strAct[0] = "";
+	m_strAct[1] = "";
+	m_strAct[2] = "";
+	m_strAct[3] = "";
+	m_strAct[4] = "";
+}
+
+void PlayerAnswer::setCondition1Line(const QString& text)
+{
+	m_strCond[0] = text;
+}
+void PlayerAnswer::setCondition2Line(const QString& text)
+{
+	m_strCond[1] = text;
+}
+void PlayerAnswer::setCondition3Line(const QString& text)
+{
+	m_strCond[2] = text;
+}
+void PlayerAnswer::setCondition4Line(const QString& text)
+{
+	m_strCond[3] = text;
+}
+void PlayerAnswer::setCondition5Line(const QString& text)
+{
+	m_strCond[4] = text;
+}
+
+
+void PlayerAnswer::setAction1Line(const QString& text)
+{
+	m_strAct[0] = text;
+}
+void PlayerAnswer::setAction2Line(const QString& text)
+{
+	m_strAct[1] = text;
+}
+void PlayerAnswer::setAction3Line(const QString& text)
+{
+	m_strAct[2] = text;
+}
+void PlayerAnswer::setAction4Line(const QString& text)
+{
+	m_strAct[3] = text;
+}
+
+void PlayerAnswer::setAction5Line(const QString& text)
+{
+	m_strAct[4] = text;
+}
+
+void PlayerAnswer::setAppearCondition(const QString& text)
+{
+	m_strAppearCondition = text;
+}
+
+
+QString NodeItem::key ( int column, bool ascending ) const
+{
+	bool ok;
+	int id = text(column).toInt( &ok, 10 ); 
+
+	QString strKey;
+	strKey.sprintf("%10d", id);
+	return strKey;
+}
+
+NodeItem::NodeItem ( QListView * parent ):
+	QListViewItem(parent) 
+{
+		m_strMusic = "";
+		m_strPicture = "";
+		m_strAlienText ="";
+		m_strTextLocation = "";
+		m_strFont = "";
+}; 
+
+void NodeItem::setID       ( const QString & text)
+{
+	setText(0,text);
+}
+void NodeItem::setName     ( const QString & text)
+{
+	setText(1,text);
+}
+void NodeItem::setMusic    ( const QString & text)
+{
+	m_strMusic = text;
+}
+void NodeItem::setPicture  ( const QString & text)
+{
+	m_strPicture = text;
+}
+void NodeItem::setAlienText( const QString & text)
+{
+	m_strAlienText = text;
+}
+void NodeItem::setTextLocation(const QString& text)
+{
+	m_strTextLocation = text;
+}
+
+void NodeItem::setFont(const QString& text)
+{
+	m_strFont = text;
+}
+

Modified: trunk/Util/deditor/node.h
===================================================================
--- trunk/Util/deditor/node.h	2004-09-29 20:59:37 UTC (rev 73)
+++ trunk/Util/deditor/node.h	2004-10-02 22:14:53 UTC (rev 74)
@@ -1,62 +1,65 @@
-#ifndef TW_DIALOG_EDITOR_NODE
-#define TW_DIALOG_EDITOR_NODE
-
-#include <qlistview.h>
-#include <qstring.h>
-#include <qlistbox.h>
-#include <qsortedlist.h>
-
-class PlayerAnswer : public QObject
-{
-	Q_OBJECT
-public:
-	PlayerAnswer();
-	
-	QString m_strText;
-	QString m_strAppearCondition;
-
-	QString m_strCond[5];
-	QString m_strAct[5];
-
-public slots:
-	virtual void setCondition1Line(const QString&);
-	virtual void setCondition2Line(const QString&);
-	virtual void setCondition3Line(const QString&);
-	virtual void setCondition4Line(const QString&);
-	virtual void setCondition5Line(const QString&);
-	virtual void setAction1Line(const QString&);
-	virtual void setAction2Line(const QString&);
-	virtual void setAction3Line(const QString&);
-	virtual void setAction4Line(const QString&);
-	virtual void setAction5Line(const QString&);
-	virtual void setAppearCondition(const QString&);
-};
-
-
-class NodeItem : public QObject, public QListViewItem
-{ 
-  Q_OBJECT
-	// column 0 - String id, 1 - string name
-public:
-
-	NodeItem ( QListView * parent ); 
-
-	QString m_strMusic;
-	QString m_strPicture;
-	QString m_strAlienText;
-	QString m_strTextLocation;
-	QString m_strFont;
-
-	QList<PlayerAnswer> m_answers;
-public slots:
-	virtual void setID       ( const QString & text);
-	virtual void setName     ( const QString & text);
-	virtual void setMusic    ( const QString & text);
-	virtual void setPicture  ( const QString & text);
-	virtual void setAlienText( const QString & text);
-	virtual void setTextLocation(const QString& text);
-	virtual void setFont(const QString& text);
-};
-
-
-#endif
+#ifndef TW_DIALOG_EDITOR_NODE
+#define TW_DIALOG_EDITOR_NODE
+
+#include <qlistview.h>
+#include <qstring.h>
+#include <qlistbox.h>
+#include <qsortedlist.h>
+
+class PlayerAnswer : public QObject
+{
+	Q_OBJECT
+public:
+	PlayerAnswer();
+	
+	QString m_strText;
+	QString m_strAppearCondition;
+
+	QString m_strCond[5];
+	QString m_strAct[5];
+
+public slots:
+	virtual void setCondition1Line(const QString&);
+	virtual void setCondition2Line(const QString&);
+	virtual void setCondition3Line(const QString&);
+	virtual void setCondition4Line(const QString&);
+	virtual void setCondition5Line(const QString&);
+	virtual void setAction1Line(const QString&);
+	virtual void setAction2Line(const QString&);
+	virtual void setAction3Line(const QString&);
+	virtual void setAction4Line(const QString&);
+	virtual void setAction5Line(const QString&);
+	virtual void setAppearCondition(const QString&);
+};
+
+
+class NodeItem : public QObject, public QListViewItem
+{ 
+  Q_OBJECT
+	// column 0 - String id, 1 - string name
+public:
+
+	NodeItem ( QListView * parent ); 
+
+	QString m_strMusic;
+	QString m_strPicture;
+	QString m_strAlienText;
+	QString m_strTextLocation;
+	QString m_strFont;
+
+	QList<PlayerAnswer> m_answers;
+
+	QString key ( int column, bool ascending ) const;
+
+public slots:
+	virtual void setID       ( const QString & text);
+	virtual void setName     ( const QString & text);
+	virtual void setMusic    ( const QString & text);
+	virtual void setPicture  ( const QString & text);
+	virtual void setAlienText( const QString & text);
+	virtual void setTextLocation(const QString& text);
+	virtual void setFont(const QString& text);
+};
+
+
+#endif

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2004-09-29 20:59:37 UTC (rev 73)
+++ trunk/source/scp.cpp	2004-10-02 22:14:53 UTC (rev 74)
@@ -250,6 +250,10 @@
   int pic = rand()%waitpics.size();
 
   BITMAP * temp = load_bitmap(waitpics[pic].c_str(), NULL);
+  if(!temp)
+    {
+      tw_error("Unable to load background!!!\n%s", waitpics[pic].c_str());
+    }
   stretch_blit(temp, screen, 0, 0, temp->w, temp->h, 0, 0, screen->w, screen->h);
   destroy_bitmap(temp);
   release_screen();
@@ -651,7 +655,6 @@
     
     videosystem->set_resolution(screen_width, screen_height, screen_bpp, fullscreen);
     register_bitmap_file_type("jpg", load_jpg, NULL);
-    showLoadingScreen();
     
     if(!theme)
 	theme = agup_theme_by_name("Photon");
@@ -670,6 +673,8 @@
     tw_sound->set_sound_volume(tw_sound->load_sound_volume());
     tw_sound->set_music_volume(tw_sound->load_music_volume());
     
+    showLoadingScreen();
+    
     View *v = NULL;
     v = get_view ( get_config_string("View", "View", NULL) , NULL );
     if (!v) v = get_view ( "Hero", NULL );

Deleted: trunk/web/dialog-editor-win32-62.zip
===================================================================
(Binary files differ)

Modified: trunk/web/downloads.html
===================================================================
--- trunk/web/downloads.html	2004-09-29 20:59:37 UTC (rev 73)
+++ trunk/web/downloads.html	2004-10-02 22:14:53 UTC (rev 74)
@@ -17,7 +17,7 @@
         <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
       </td>
       <td>
-      <a href="./index.html">News</a> | <a href="./info.html">Info</a> | <a href="./team.html">Team</a> | <a  id="curpagelink" href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a href="./links.html">Links</a>
+      <a href="./index.html">News</a> | <a href="./info.html">Info</a> | <a href="./team.html">Team</a> | <a  id="curpagelink" href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://tw-light.berlios.de/mantis/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a href="./links.html">Links</a>
       </td>
     </tr>
   </table>
@@ -32,7 +32,7 @@
 <p class="indented">
 To successfully compile the sources and play the game on Linux/Unix you first need 
 <a href="http://www.allegro.cc/files/index.html">Allegro</a>, SDL 1.2.5 (or newer),
-libogg and libvorbis installed, See makefile after unpacking for more instructions.
+SDL_mixer with ogg support installed. See makefile after unpacking for more instructions.
 	<!--	
 	 and <a href="http://www.lua.org">Lua</a>
 	View <a href="">ChangeLog</a> to see the list of the latest changes.<br>
@@ -40,8 +40,10 @@
 </p>
 <p class="indented">
 If you want to contribute TW-Light by writting good dialogs, download and use 
-our dialog editor. The latest version is <b>62</b>. You can download Windows binaries 
-<a href="./dialog-editor-win32-62.zip">here</a>.
+our dialog editor. The latest version is <b>73</b>. You can download Windows binaries 
+<a href="./dialog-editor-win32-73.zip">here</a>. This 
+<a href="./tutorial.zip">tutorial</a> contains few instruction about how to use it.
+
 </p>
 </div>
 

Modified: trunk/web/index.html
===================================================================
--- trunk/web/index.html	2004-09-29 20:59:37 UTC (rev 73)
+++ trunk/web/index.html	2004-10-02 22:14:53 UTC (rev 74)
@@ -17,7 +17,7 @@
         <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
       </td>
       <td>
-      <a id="curpagelink" href="./index.html">News</a> | <a href="./info.html">Info</a> | <a href="./team.html">Team</a> | <a  href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a href="./links.html">Links</a>
+      <a id="curpagelink" href="./index.html">News</a> | <a href="./info.html">Info</a> | <a href="./team.html">Team</a> | <a  href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://tw-light.berlios.de/mantis/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a href="./links.html">Links</a>
       </td>
     </tr>
   </table>

Modified: trunk/web/info.html
===================================================================
--- trunk/web/info.html	2004-09-29 20:59:37 UTC (rev 73)
+++ trunk/web/info.html	2004-10-02 22:14:53 UTC (rev 74)
@@ -16,7 +16,7 @@
         <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
       </td>
       <td>
-      <a href="./index.html">News</a> | <a id="curpagelink" href="./info.html">Info</a> | <a href="./team.html">Team</a> | <a  href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a href="./links.html">Links</a>
+      <a href="./index.html">News</a> | <a id="curpagelink" href="./info.html">Info</a> | <a href="./team.html">Team</a> | <a  href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://tw-light.berlios.de/mantis/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a href="./links.html">Links</a>
       </td>
     </tr>
   </table>

Modified: trunk/web/links.html
===================================================================
--- trunk/web/links.html	2004-09-29 20:59:37 UTC (rev 73)
+++ trunk/web/links.html	2004-10-02 22:14:53 UTC (rev 74)
@@ -17,7 +17,7 @@
         <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
       </td>
       <td>
-      <a href="./index.html">News</a> | <a href="./info.html">Info</a> | <a href="./team.html">Team</a> | <a href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a id="curpagelink" href="./links.html">Links</a>
+      <a href="./index.html">News</a> | <a href="./info.html">Info</a> | <a href="./team.html">Team</a> | <a href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://tw-light.berlios.de/mantis/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a id="curpagelink" href="./links.html">Links</a>
       </td>
     </tr>
   </table>
@@ -27,7 +27,7 @@
   <h3>TW-Light resources</h3>
   <ul>
     <li><a href="http://developer.berlios.de/projects/tw-light/">BerliOS: TW-Light Project Info</a></li>
-    <li><a href="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">TW-Light Bugzilla</a> </li>
+    <li><a href="http://tw-light.berlios.de/mantis/">TW-Light Bugzilla</a> </li>
     <li><a href="http://timewarp.sourceforge.net/forum/index.php">TimeWarp Forum (official)</a> </li>
 </ul>
 

Modified: trunk/web/team.html
===================================================================
--- trunk/web/team.html	2004-09-29 20:59:37 UTC (rev 73)
+++ trunk/web/team.html	2004-10-02 22:14:53 UTC (rev 74)
@@ -16,7 +16,7 @@
         <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
       </td>
       <td>
-      <a href="./index.html">News</a> | <a href="./info.html">Info</a> | <a id="curpagelink" href="./team.html">Team</a> | <a  href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a href="./links.html">Links</a>
+      <a href="./index.html">News</a> | <a href="./info.html">Info</a> | <a id="curpagelink" href="./team.html">Team</a> | <a  href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://tw-light.berlios.de/mantis/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a href="./links.html">Links</a>
       </td>
     </tr>
   </table>

Modified: trunk/web/update.sh
===================================================================
--- trunk/web/update.sh	2004-09-29 20:59:37 UTC (rev 73)
+++ trunk/web/update.sh	2004-10-02 22:14:53 UTC (rev 74)
@@ -1,2 +1,2 @@
 #!/bin/bash
-pscp siglogo.jpeg yurand at shell.berlios.de:/home/groups/tw-light/htdocs
\ No newline at end of file
+pscp info.html downloads.html index.html links.html team.html yurand at shell.berlios.de:/home/groups/tw-light/htdocs
\ No newline at end of file



From youbastrd at sheep.berlios.de  Wed Oct  6 23:22:24 2004
From: youbastrd at sheep.berlios.de (Paul Forest at BerliOS)
Date: Wed, 6 Oct 2004 23:22:24 +0200
Subject: [Tw-light-svn] r75 - in branches/multiplayer-branch: . source source/ais source/games source/libraries/raknet source/melee source/ships
Message-ID: <200410062122.i96LMOog015574@sheep.berlios.de>

Author: youbastrd
Date: 2004-10-06 23:22:23 +0200 (Wed, 06 Oct 2004)
New Revision: 75

Added:
   branches/multiplayer-branch/source/games/MultiplayerGame.cpp
   branches/multiplayer-branch/source/games/MultiplayerGame.h
   branches/multiplayer-branch/source/games/gmelee.cpp
   branches/multiplayer-branch/source/games/gmelee.h
Removed:
   branches/multiplayer-branch/source/melee/mmain.cpp
   branches/multiplayer-branch/source/melee/mmain.h
Modified:
   branches/multiplayer-branch/source/ais/c_wussie.cpp
   branches/multiplayer-branch/source/games/gflmelee.cpp
   branches/multiplayer-branch/source/games/ggob.cpp
   branches/multiplayer-branch/source/libraries/raknet/Multiplayer.h
   branches/multiplayer-branch/source/melee/mhelpers.cpp
   branches/multiplayer-branch/source/melee/mnet1.h
   branches/multiplayer-branch/source/scp.cpp
   branches/multiplayer-branch/source/ships/shpconho.cpp
   branches/multiplayer-branch/source/ships/shpkahbo.cpp
   branches/multiplayer-branch/sources.lst
Log:
Adding bare-bones multiplayer -- still doesn't work, but you can at least you can start a server, and connect a client to it.

Modified: branches/multiplayer-branch/source/ais/c_wussie.cpp
===================================================================
--- branches/multiplayer-branch/source/ais/c_wussie.cpp	2004-10-02 22:14:53 UTC (rev 74)
+++ branches/multiplayer-branch/source/ais/c_wussie.cpp	2004-10-06 21:22:23 UTC (rev 75)
@@ -27,7 +27,7 @@
 #include "melee/mcontrol.h"
 #include "melee/mframe.h"
 #include "melee/mship.h"
-#include "melee/mmain.h"
+#include "games/gmelee.h"
 
 #define OPTION_UNKNOWN 0
 #define OPTION_NONE 1

Added: branches/multiplayer-branch/source/games/MultiplayerGame.cpp
===================================================================
--- branches/multiplayer-branch/source/games/MultiplayerGame.cpp	2004-10-02 22:14:53 UTC (rev 74)
+++ branches/multiplayer-branch/source/games/MultiplayerGame.cpp	2004-10-06 21:22:23 UTC (rev 75)
@@ -0,0 +1,507 @@
+/* $Id: melee.h,v 1.3 2004/08/08 17:36:03 Yura Exp $ */ 
+/*
+This file is part of "TW-Light" 
+                    http://timewarp.sourceforge.net/
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#include "MultiplayerGame.h"
+
+
+#include "libraries/raknet/RakClientInterface.h"
+#include "libraries/raknet/RakServerInterface.h"
+//#include "Raknet/RakNetworkFactory.h"	
+
+// If you don't want to use distributed network objects, delete this include
+#include "../libraries/raknet/DistributedNetworkObjectManager.h"
+#include "../libraries/raknet/PacketEnumerations.h"
+#include "../libraries/raknet/NetworkTypes.h"
+#include <assert.h>
+#include <stdio.h>
+#include "../libraries/raknet/GetTime.h"
+	
+
+//#ifdef DEBUG
+	#define _DEBUG
+//#endif
+
+#ifdef _DEBUG
+#include <memory.h>
+#endif
+
+template <class InterfaceType>
+MultiplayerGameTemplate<InterfaceType>::MultiplayerGameTemplate() :
+	_isServer(false)
+{
+    message.print(5000,15,"Game on!");
+}
+
+template <class InterfaceType>
+MultiplayerGameTemplate<InterfaceType>::~MultiplayerGameTemplate()
+{
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ProcessPackets(InterfaceType *interfaceType)
+{
+	Packet* p;
+	unsigned char packetIdentifier;
+
+	p = interfaceType->Receive();
+
+	while (p)
+	{
+		if ((unsigned char)p->data[0] == ID_TIMESTAMP)
+		{
+			if (p->length > sizeof(unsigned char) + sizeof(unsigned long))
+				packetIdentifier = (unsigned char) p->data[sizeof(unsigned char) + sizeof(unsigned long)];
+			else
+				break;
+		}
+		else
+			packetIdentifier = (unsigned char) p->data[0];
+
+		// Check if this is a native packet
+		switch (packetIdentifier)
+		{
+		case ID_REMOTE_DISCONNECTION_NOTIFICATION:
+			ReceiveRemoteDisconnectionNotification(p,interfaceType);
+		    message.print(5000,15,"client : told to bugger off");
+		break;
+		case ID_REMOTE_CONNECTION_LOST:
+			ReceiveRemoteConnectionLost(p,interfaceType);
+		    message.print(5000,15,"client lost connection");
+		break;
+		case ID_REMOTE_NEW_INCOMING_CONNECTION:
+			ReceiveRemoteNewIncomingConnection(p,interfaceType);
+			message.print(5000,15,"Got a new connection!");
+		break;
+		case ID_REMOTE_EXISTING_CONNECTION:
+			ReceiveRemoteExistingConnection(p,interfaceType);
+		    message.print(5000,15,"Player leaving");
+		break;
+		case ID_CONNECTION_BANNED:
+			ReceiveConnectionBanned(p, interfaceType);
+		break;
+		case ID_CONNECTION_REQUEST_ACCEPTED:
+			ReceiveConnectionRequestAccepted(p,interfaceType);
+		    message.print(5000,15,"We're allowed to connect!!");
+			break;
+		case ID_NEW_INCOMING_CONNECTION:
+			ReceiveNewIncomingConnection(p,interfaceType);
+			break;
+		case ID_NO_FREE_INCOMING_CONNECTIONS:
+			ReceiveNoFreeIncomingConnections(p,interfaceType);
+			break;
+		case ID_DISCONNECTION_NOTIFICATION:
+			ReceiveDisconnectionNotification(p,interfaceType);
+			break;
+		case ID_CONNECTION_LOST:
+			ReceiveConnectionLost(p,interfaceType);
+			break;
+		case ID_RECEIVED_STATIC_DATA:
+			ReceivedStaticData(p,interfaceType);
+			break;
+		case ID_INVALID_PASSWORD:
+			ReceiveInvalidPassword(p,interfaceType);
+			break;
+		case ID_MODIFIED_PACKET:
+			ReceiveModifiedPacket(p,interfaceType);
+			break;
+		case ID_REMOTE_PORT_REFUSED:
+			ReceiveRemotePortRefused(p,interfaceType);
+			break;
+		case ID_VOICE_PACKET:
+			ReceiveVoicePacket(p,interfaceType);
+			break;
+		case ID_PONG:
+			ReceivePong(p,interfaceType);
+			break;
+		case ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT:
+			ReceiveDistributedNetworkObject(p,interfaceType);
+			break;
+		case ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_ACCEPTED:
+			ReceiveDistributedNetworkObjectCreationAccepted(p,interfaceType);
+			break;
+		case ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_REJECTED:
+			ReceiveDistributedNetworkObjectCreationRejected(p,interfaceType);
+			break;
+		case ID_AUTOPATCHER_REQUEST_FILE_LIST:
+			ReceiveAutopatcherRequestFileList(p,interfaceType);
+			break;
+		case ID_AUTOPATCHER_FILE_LIST:
+			ReceiveAutopatcherFileList(p,interfaceType);
+			break;
+		case ID_AUTOPATCHER_REQUEST_FILES:
+			ReceiveAutopatcherRequestFiles(p,interfaceType);
+			break;
+		case ID_AUTOPATCHER_SET_DOWNLOAD_LIST:
+			ReceiveAutopatcherSetDownloadList(p,interfaceType);
+			break;
+		case ID_AUTOPATCHER_WRITE_FILE:
+			ReceiveAutopatcherWriteFile(p,interfaceType);
+			break;
+		default:
+			// If not a native packet send it to ProcessUnhandledPacket which should have been written by the user
+			ProcessUnhandledPacket(p, packetIdentifier,interfaceType);
+			break;
+		}
+
+		interfaceType->DeallocatePacket(p);
+
+		p = interfaceType->Receive();
+	}
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ProcessUnhandledPacket(Packet *p, unsigned char packetIdentifier, InterfaceType *interfaceType)
+{
+	// Remove the annoying warnings
+	//packetIdentifier;
+	//interfaceType;
+
+	// This class should have been overrided to handle user defined packets
+#ifdef _DEBUG
+	// Uncomment this to show output as integers
+	
+//	int i;
+//	static unsigned packetNumber=0;
+//	// Raw output (nonstring)
+//	message.print(5000,15,"MultiplayerGameTemplate::ProcessUnhandledPacket (%i) (%i): ", packetNumber++, p->length);
+//	for (i=0; i < p->length; i++)
+//	message.print(5000,15,"%i ",p->data[i]);
+//	message.print(5000,15,"\n");
+	
+
+	// Uncomment this to show output as a string
+	
+	// Raw output (string)
+	message.print(5000,15,"%s\n", p->data);
+	
+#endif
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveRemoteDisconnectionNotification(Packet *packet,InterfaceType *interfaceType)
+{
+	// Another system has disconnected.  Client only.
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_REMOTE_DISCONNECTION_NOTIFICATION from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+//	ProcessUnhandledPacket(packet, ID_REMOTE_DISCONNECTION_NOTIFICATION,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveRemoteConnectionLost(Packet *packet,InterfaceType *interfaceType)
+{
+	// Another system has been dropped by the server.  Client only.
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_REMOTE_CONNECTION_LOST from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+//	ProcessUnhandledPacket(packet, ID_REMOTE_CONNECTION_LOST,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveRemoteNewIncomingConnection(Packet *packet,InterfaceType *interfaceType)
+{
+	// Another system has connected.  Client only.
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_REMOTE_NEW_INCOMING_CONNECTION from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+//	ProcessUnhandledPacket(packet, ID_REMOTE_NEW_INCOMING_CONNECTION,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveRemoteExistingConnection(Packet *packet,InterfaceType *interfaceType)
+{
+	// We just connected to the server and are getting a list of players already connected
+	// Note due to thread timing you might get both this and ID_REMOTE_NEW_INCOMING_CONNECTION when first connecting.
+	//  Client only.
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_REMOTE_EXISTING_CONNECTION from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+	//	ProcessUnhandledPacket(packet, ID_REMOTE_EXISTING_CONNECTION,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveConnectionBanned(Packet *packet,InterfaceType *interfaceType)
+{
+	// We are banned from connecting to the system specified in packet->playerId
+	// Peer or client
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_CONNECTION_BANNED from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+	//	ProcessUnhandledPacket(packet, ID_REMOTE_EXISTING_CONNECTION,interfaceType);
+}
+
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveConnectionRequestAccepted(Packet *packet, InterfaceType *interfaceType)
+{
+    message.print(5000,15,"We're accepted to connect");
+	// Our request to connect to another system has been accepted.  Client only.
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_CONNECTION_REQUEST_ACCEPTED from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+//	ProcessUnhandledPacket(packet, ID_CONNECTION_REQUEST_ACCEPTED,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveNewIncomingConnection(Packet *packet, InterfaceType *interfaceType)
+{
+	// Another system has requested to connect to us, which we have accepted.  Server or peer only.
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_NEW_INCOMING_CONNECTION from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+//	ProcessUnhandledPacket(packet, ID_NEW_INCOMING_CONNECTION,interfaceType);
+
+	// This will send all existing distributed objects to the new player
+//#ifdef __DISTRIBUTED_NETWORK_OBJECT_MANAGER_H
+	DistributedNetworkObjectManager::Instance()->SendAllDistributedObjects(packet->playerId);
+//#endif
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveConnectionResumption(Packet *packet, InterfaceType *interfaceType)
+{
+	// Someone who was already connected to us connected again.  Server or peer only.
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_CONNECTION_RESUMPTION from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+//	ProcessUnhandledPacket(packet, ID_CONNECTION_RESUMPTION,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveNoFreeIncomingConnections(Packet *packet, InterfaceType *interfaceType)
+{
+	// The system we connected to has no free slots to connect to
+	// Set free slots by calling SetMaximumIncomingConnections
+	// Client or peer only.
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_NO_FREE_INCOMING_CONNECTIONS from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+//	ProcessUnhandledPacket(packet, ID_NO_FREE_INCOMING_CONNECTIONS,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveDisconnectionNotification(Packet *packet, InterfaceType *interfaceType)
+{
+	// A remote system terminated the connection.  packet->playerId specifies which remote system
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_DISCONNECTION_NOTIFICATION from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+//	ProcessUnhandledPacket(packet, ID_DISCONNECTION_NOTIFICATION,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveConnectionLost(Packet *packet, InterfaceType *interfaceType)
+{
+	// The network cannot send reliable packets so has terminated the connection. packet->playerId specifies which remote system
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_CONNECTION_LOST from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+//	ProcessUnhandledPacket(packet, ID_CONNECTION_LOST,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceivedStaticData(Packet *packet, InterfaceType *interfaceType)
+{
+	// Another system has just sent their static data to us (which we recorded automatically)
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_RECEIVED_STATIC_DATA from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+//	ProcessUnhandledPacket(packet, ID_RECEIVED_STATIC_DATA,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveInvalidPassword(Packet *packet, InterfaceType *interfaceType)
+{
+	// Our connection to another system was refused because the passwords do not match
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_INVALID_PASSWORD from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+//	ProcessUnhandledPacket(packet, ID_INVALID_PASSWORD,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveModifiedPacket(Packet *packet, InterfaceType *interfaceType)
+{
+	// The network layer has detected packet tampering
+	// This does NOT automatically close the connection
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_MODIFIED_PACKET from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+//	ProcessUnhandledPacket(packet, ID_MODIFIED_PACKET,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveRemotePortRefused(Packet *packet, InterfaceType *interfaceType)
+{
+	// The remote system has responded with ICMP_PORT_UNREACHABLE
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_REMOTE_PORT_REFUSED from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+//	ProcessUnhandledPacket(packet, ID_REMOTE_PORT_REFUSED,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveVoicePacket(Packet *packet, InterfaceType *interfaceType)
+{
+	// We got a voice packet
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_VOICE_PACKET from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+//	ProcessUnhandledPacket(packet, ID_VOICE_PACKET,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceivePong(Packet *packet, InterfaceType *interfaceType)
+{
+	// Peer or client.  Response from a ping for an unconnected system.
+//#ifdef _DEBUG
+	unsigned long time;
+	memcpy((char*)&time, packet->data+sizeof(unsigned char), sizeof(unsigned long));
+	message.print(5000,15,"ID_PONG from PlayerID:%u:%u on %p. Value is %i\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType, time);
+//#endif
+	//	ProcessUnhandledPacket(packet, ID_PONG,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveDistributedNetworkObject(Packet *packet,InterfaceType *interfaceType)
+{
+	// Packet to create a distributed network object
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+
+	#ifdef __DISTRIBUTED_NETWORK_OBJECT_MANAGER_H
+
+	// This packet is only valid if the server or client was registered with the DistributedNetworkObjectManager
+	// If you this this assert, you need to call
+	// DistributedNetworkObjectManager::Instance()->RegisterRakServerInterface(myInstanceOfRakServer);
+	// and / or
+	// DistributedNetworkObjectManager::Instance()->RegisterRakClientInterface(myInstanceOfRakClient);
+	assert(DistributedNetworkObjectManager::Instance()->GetRakClientInterface() || DistributedNetworkObjectManager::Instance()->GetRakServerInterface());
+
+	DistributedNetworkObjectManager::Instance()->HandleDistributedNetworkObjectPacket(packet);
+	#endif
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveDistributedNetworkObjectCreationAccepted(Packet *packet,InterfaceType *interfaceType)
+{
+	// Client only - creation of a distributed network object was accepted
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_ACCEPTED from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+
+#ifdef __DISTRIBUTED_NETWORK_OBJECT_MANAGER_H
+	// This packet is only valid if the client was registered with the DistributedNetworkObjectManager
+	// DistributedNetworkObjectManager::Instance()->RegisterRakClientInterface(myInstanceOfRakClient);
+	assert(DistributedNetworkObjectManager::Instance()->GetRakClientInterface());
+
+	DistributedNetworkObjectManager::Instance()->HandleDistributedNetworkObjectPacketCreationAccepted(packet);
+#endif
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveDistributedNetworkObjectCreationRejected(Packet *packet,InterfaceType *interfaceType)
+{
+	// Client only - creation of a distributed network object was accepted
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_REJECTED from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+
+#ifdef __DISTRIBUTED_NETWORK_OBJECT_MANAGER_H
+	// This packet is only valid if the client was registered with the DistributedNetworkObjectManager
+	// DistributedNetworkObjectManager::Instance()->RegisterRakClientInterface(myInstanceOfRakClient);
+	assert(DistributedNetworkObjectManager::Instance()->GetRakClientInterface());
+
+	DistributedNetworkObjectManager::Instance()->HandleDistributedNetworkObjectPacketCreationRejected(packet);
+#endif
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveAutopatcherRequestFileList(Packet *packet, InterfaceType *interfaceType)
+{
+	// Request for a list of files served by the autopatcher.
+	// Send to Autopatcher::SendDownloadableFileList(packet->playerId)
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_AUTOPATCHER_REQUEST_FILE_LIST from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+	// ProcessUnhandledPacket(packet, ID_AUTOPATCHER_REQUEST_FILE_LIST,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveAutopatcherFileList(Packet *packet, InterfaceType *interfaceType)
+{
+	// Got a list of files served by a remote autopatcher
+	// Send to Autopatcher::OnAutopatcherFileList(packet, bool);
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_AUTOPATCHER_FILE_LIST from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+	// ProcessUnhandledPacket(packet, ID_AUTOPATCHER_FILE_LIST,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveAutopatcherRequestFiles(Packet *packet, InterfaceType *interfaceType)
+{
+	// Got a request for a set of files from our autopatcher
+	// Send to Autopatcher::OnAutopatcherRequestFiles(packet);
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_AUTOPATCHER_REQUEST_FILES from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+	// ProcessUnhandledPacket(packet, ID_AUTOPATCHER_REQUEST_FILES,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveAutopatcherSetDownloadList(Packet *packet, InterfaceType *interfaceType)
+{
+	// Got confirmation of what files we are about to get from the remote autopatcher
+	// Send to Autopatcher::OnAutopatcherSetDownloadList(packet);
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_AUTOPATCHER_SET_DOWNLOAD_LIST from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+	// ProcessUnhandledPacket(packet, ID_AUTOPATCHER_SET_DOWNLOAD_LIST,interfaceType);
+}
+
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::ReceiveAutopatcherWriteFile(Packet *packet, InterfaceType *interfaceType)
+{
+	// Got a file from a remote autopatcher
+	// Send to Autopatcher::OnAutopatcherWriteFile(packet);
+//#ifdef _DEBUG
+	message.print(5000,15,"ID_AUTOPATCHER_WRITE_FILE from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+//#endif
+	// ProcessUnhandledPacket(packet, ID_AUTOPATCHER_WRITE_FILE,interfaceType);
+};
+
+// Copied from Multiplayer.cpp
+// If the first byte is ID_TIMESTAMP, then we want the 5th byte
+// Otherwise we want the 1st byte
+unsigned char GetPacketIdentifier(Packet *p)
+{
+	if (p==0)
+		return 255;
+
+	if ((unsigned char)p->data[0] == ID_TIMESTAMP)
+	{
+		assert(p->length > sizeof(unsigned char) + sizeof(unsigned long));
+		return (unsigned char) p->data[sizeof(unsigned char) + sizeof(unsigned long)];
+	}
+	else
+		return (unsigned char) p->data[0];
+}
+
+REGISTER_GAME(MultiplayerGameClient, "MultiplayerGameClient")
+REGISTER_GAME(MultiplayerGameServer, "MultiplayerGameServer")

Added: branches/multiplayer-branch/source/games/MultiplayerGame.h
===================================================================
--- branches/multiplayer-branch/source/games/MultiplayerGame.h	2004-10-02 22:14:53 UTC (rev 74)
+++ branches/multiplayer-branch/source/games/MultiplayerGame.h	2004-10-06 21:22:23 UTC (rev 75)
@@ -0,0 +1,285 @@
+/* $Id: melee.h,v 1.3 2004/08/08 17:36:03 Yura Exp $ */ 
+/*
+This file is part of "TW-Light" 
+                    http://timewarp.sourceforge.net/
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#ifndef MULTIPLAYERGAME_HEADER
+#define MULTIPLAYERGAME_HEADER
+
+#include "allegro.h"
+#include "melee.h"
+#include "scp.h"
+#include "frame.h"
+#include "melee/mgame.h"
+#include "melee/mview.h"
+
+//#include "games/gmelee.h"
+//#include "melee/mview.h"
+//#include "melee/mcontrol.h"
+//#include "other/planet3d.h"
+////#include "mshppan.h"
+//#include "melee/mship.h"
+//#include "melee/mlog.h"
+////#include "mnet1.h"
+//#include "melee/mitems.h"
+//#include "melee/mfleet.h"
+
+
+#include "../libraries/raknet/PacketEnumerations.h"
+#include "../libraries/raknet/RakNetworkFactory.h"
+#include "../libraries/raknet/RakClientInterface.h"
+#include "../libraries/raknet/RakServerInterface.h"
+#include "../libraries/raknet/NetworkTypes.h"
+#include "../libraries/raknet/BitStream.h"
+#include "../libraries/raknet/Multiplayer.h"
+	
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <time.h>
+//#include <allegro.h>
+
+
+//! 
+unsigned char GetPacketIdentifier(Packet *p);
+
+// Holds enumeration data
+const int MOTD_MAXIMUM_LENGTH=50; // Characters allocated for the message of the day, used for enumerations
+const int SERVER_NAME_MAXIMUM_LENGTH=40; // Characters allocated for the server name
+
+//! data on the server which changes infrequently.  This information is transmitted to all joining clients.
+struct StaticServerDataStruct
+{
+	char MOTD[MOTD_MAXIMUM_LENGTH];  // (Message of the day) Optional, replace with whatever and/or add more fields
+	char serverName[SERVER_NAME_MAXIMUM_LENGTH];
+};
+
+const int SCDS_MAXIMUM_NAME_LENGTH=40;
+
+//! data on the client, which is automatically transmitted to the server and all other clients.  
+struct StaticClientDataStruct
+{
+	unsigned char typeId;  // ID_SET_CLIENT_DATA
+	char name[SCDS_MAXIMUM_NAME_LENGTH];
+};
+
+//! A class to implement Multiplayer Games with.  You should subclass this, rather than using it directly.
+//! You should also create a server and client class that can be used to start a game in the GUI and from the
+//! commandline (see MultiplayerGameServer for more explaination on how to do this).
+//! 
+//! This has default implementations of methods needed to:
+//! - start a server 
+//! - have clients connect to it
+//! - let players on a client to join a game.  Once in a game, players can:
+//! - - when first joining a match, select a fleet, according to the FleetSelectionPolicy
+//! - - when spawning, select a ship from their fleet, according to the SpawnTimeShipSelectionPolicy
+//! - - fly their ship, fire its weapons, etc.
+//! - - blow up other ships etc, and get blown up themselves, keeping score all the while.  Great fun!
+//! - the server will finish the game according to its victory conditions.
+//! 
+//! This class is templated to use any of three RakNet interface types. 
+//! Examples:
+//! - using MultiplayerGameTemplate<RakClientInterface> means we're using a RakClientInterface
+//! - using MultiplayerGameTemplate<RakServerInterface> means we're using a RakServerInterface
+//! - using MultiplayerGameTemplate<RakPeerInterface> means we're using a RakPeerInterface
+//!
+//! @see MultiplayerGameServer
+//! @see MultiplayerGameClient
+//! @see FleetSelectionPolicy
+//! @see SpawnTimeShipSelectionPolicy
+template <class InterfaceType>
+class MultiplayerGameTemplate : 
+	public Multiplayer<InterfaceType>,
+	public Game
+{
+public:
+    
+	//! 
+	MultiplayerGameTemplate();
+
+    //!
+	~MultiplayerGameTemplate();
+	
+	// Methods and data stuctures from class Game /////////////////////////////////////////////////
+	
+	//! pre-initialization (enough so that the destructor won't crash)
+	virtual void preinit() { Game::preinit(); }	
+	
+    //! initialization (loading data, creating a few game objects, whatever)
+    virtual void init(Log *log) { Game::init(log); }
+    
+    //! changes the view.  That is, the method that the screen is drawn for the user is selected.
+    //! @param new_view the View data structure to use.
+    virtual void change_view (View *new_view) { Game::change_view(new_view); }
+    
+    //! changes the view.  That is, the method that the screen is drawn for the user is selected.
+    //! @param name the name of the view method
+    virtual void change_view (const char * name ) { Game::change_view(name); }
+    
+    //! called before doing anything with game objects contained within you.  
+    virtual void prepare() { Game::prepare(); }
+    
+    //! called once per game loop.  Performs all game logic.
+    virtual void calculate() { 
+    	Game::calculate(); 
+    	ProcessPackets(networkInterface);
+    }
+    
+    //! called once per game execution.  This contains the game loop itself.
+    virtual void play() { Game::play(); }
+    
+    //! draws the entire world to a specific frame.
+    virtual void animate(Frame *frame) { Game::animate(frame); }
+    
+    //! draws the entire world.
+    virtual void animate() { Game::animate(); }
+
+  	//! called when an object is killed/died/exploded in the game.
+    //! \param who the SpaceObject that is in the process of dying.  Note that this may be a ship, an asteroid, a projectile, anything.
+    //! \param source this is what killed the SpaceObject who.  Note that it may be NULL
+  	virtual void object_died(SpaceObject *who, SpaceLocation *source) { Game::object_died(who, source); }
+  	
+  	//! called when a ship is killed/died/exploded in the game.
+    //!  TODO say which of these is true:
+    //!	 Note that object_died() will also be called when this happens.
+    //!	 Note that object_died() will *not* be called when this happens.
+    //! \param who the Ship that is in the immediate process of dying
+    //! \param source the target which killed the ship.  Note that it may not be a Ship, and it may be NULL
+  	virtual void ship_died(Ship *who, SpaceLocation *source) { Game::ship_died(who, source); }
+
+	//! Determines if the game has loaded/prepared all its data structures and ready to start.
+    //! @return true if the game is ready to start, false otherwise.
+	virtual bool game_ready() {return Game::game_ready(); }
+	
+	
+	// Methods and data stuctures from class Multiplayer ///////////////////////////////////////////
+		
+	//! Automagically processes all incoming packets, and calls appropriate handlers.  This method
+    //! must be called every frame, and this is done by default inside calculate().
+	void ProcessPackets(InterfaceType *interfaceType);
+	virtual void ProcessUnhandledPacket(Packet *p, unsigned char packetIdentifier, InterfaceType *interfaceType);
+	virtual void ReceiveRemoteDisconnectionNotification(Packet *packet,InterfaceType *interfaceType);
+	virtual void ReceiveRemoteConnectionLost(Packet *packet,InterfaceType *interfaceType);
+	virtual void ReceiveRemoteNewIncomingConnection(Packet *packet,InterfaceType *interfaceType);
+	virtual void ReceiveRemoteExistingConnection(Packet *packet,InterfaceType *interfaceType);
+	virtual void ReceiveConnectionBanned(Packet *packet,InterfaceType *interfaceType);
+	virtual void ReceiveConnectionRequestAccepted(Packet *packet, InterfaceType *interfaceType);
+	virtual void ReceiveNewIncomingConnection(Packet *packet, InterfaceType *interfaceType);
+	virtual void ReceiveConnectionResumption(Packet *packet, InterfaceType *interfaceType);
+	virtual void ReceiveNoFreeIncomingConnections(Packet *packet, InterfaceType *interfaceType);
+	virtual void ReceiveDisconnectionNotification(Packet *packet, InterfaceType *interfaceType);
+	virtual void ReceiveConnectionLost(Packet *packet, InterfaceType *interfaceType);
+	virtual void ReceivedStaticData(Packet *packet, InterfaceType *interfaceType);
+	virtual void ReceiveInvalidPassword(Packet *packet, InterfaceType *interfaceType);
+	virtual void ReceiveModifiedPacket(Packet *packet, InterfaceType *interfaceType);
+	virtual void ReceiveRemotePortRefused(Packet *packet, InterfaceType *interfaceType);
+	virtual void ReceiveVoicePacket(Packet *packet, InterfaceType *interfaceType);
+	virtual void ReceivePong(Packet *packet, InterfaceType *interfaceType);
+	virtual void ReceiveDistributedNetworkObject(Packet *packet,InterfaceType *interfaceType);
+	virtual void ReceiveDistributedNetworkObjectCreationAccepted(Packet *packet,InterfaceType *interfaceType);
+	virtual void ReceiveDistributedNetworkObjectCreationRejected(Packet *packet,InterfaceType *interfaceType);
+	virtual void ReceiveAutopatcherRequestFileList(Packet *packet, InterfaceType *interfaceType);
+	virtual void ReceiveAutopatcherFileList(Packet *packet, InterfaceType *interfaceType);
+	virtual void ReceiveAutopatcherRequestFiles(Packet *packet, InterfaceType *interfaceType);
+	virtual void ReceiveAutopatcherSetDownloadList(Packet *packet, InterfaceType *interfaceType);
+	virtual void ReceiveAutopatcherWriteFile(Packet *packet, InterfaceType *interfaceType);
+	
+// methods exclusive to this class /////////////////////////////////////////////////////////	
+	virtual bool isServer() { return _isServer; }
+	
+protected:
+	//! this is the object which is used in all interactions with the RakNet API.  Note that the actual type
+	//! of this variable depends on the type of InterfaceType.  This means if this templated class is used as a client,
+	//! this variable is a RakClientInterface.  
+	//! Examples:
+	//! - using MultiplayerGameTemplate<RakClientInterface> means this variable is a RakClientInterface
+	//! - using MultiplayerGameTemplate<RakServerInterface> means this variable is a RakServerInterface
+	//! - using MultiplayerGameTemplate<RakPeerInterface> means this variable is a RakPeerInterface
+	InterfaceType * networkInterface;
+
+protected:
+	bool _isServer;
+};
+
+//! This class is exposed to the list of available games.  Note that this class is
+//! for testing only, and it shouldn't be used as an actual gametype.  Instead,
+//! subclass MultiplayerGameTemplate, putting all functionality in there.  Then
+//! make two classes similar to MultiplayerGameClient and MultiplayerGameServer, like so:
+//! 
+//! template <class InterfaceType>
+//! class YourGameTemplate : 
+//! 	public MultiplayerGameTemplate<InterfaceType>,
+//! 	public Game
+//! {
+//!   ... // implement your game here by customizing methods here
+//! }
+//!
+//! class YourGameClient : public YourGameTemplate<RakClientInterface> { 
+//! public:
+//!   YourGameServer() { networkInterface = RakNetworkFactory::GetRakServerInterface(); }
+//!   ~YourGameServer() { RakNetworkFactory::DestroyRakServerInterface(networkInterface); }
+//! };
+//!
+//! class YourGameServer : public YourGameServerTemplate<RakClientInterface> { 
+//! public:
+//!   YourGameServer() { networkInterface = RakNetworkFactory::GetRakClientInterface(); }
+//!   ~YourGameServer() { RakNetworkFactory::DestroyRakClientInterface(networkInterface); }
+//! };
+//!
+class MultiplayerGameServer : public MultiplayerGameTemplate<RakServerInterface> 
+{ 
+public:
+	MultiplayerGameServer()
+    { 
+        _isServer = true;
+		networkInterface = RakNetworkFactory::GetRakServerInterface(); 
+        networkInterface->SetStaticServerData((char*)&staticServerData, sizeof(staticServerData));
+        bool b = networkInterface->Start(2, 0, true, 15515);
+        if (!b)
+            throw "Can't start server!";
+        message.print(5000,15,"Started server!");
+	}
+	~MultiplayerGameServer() { RakNetworkFactory::DestroyRakServerInterface(networkInterface); }
+    
+    StaticServerDataStruct staticServerData;
+};
+
+class MultiplayerGameClient : public MultiplayerGameTemplate<RakClientInterface> 
+{ 
+public:
+	MultiplayerGameClient()
+    { 
+      networkInterface = RakNetworkFactory::GetRakClientInterface(); 
+      networkInterface->SetStaticClientData(UNASSIGNED_PLAYER_ID, (char*)&staticClientData, sizeof(StaticClientDataStruct));
+      bool b = false;
+      while (!b) {
+        b = networkInterface->Connect("127.0.0.1", 15515, 15516, 0, true);
+        if (!b)
+            message.out("Couldn't connect, retrying...");
+      }
+      message.out("Connected to server!");
+      
+    }
+	~MultiplayerGameClient() { RakNetworkFactory::DestroyRakClientInterface(networkInterface);  }
+    StaticClientDataStruct staticClientData;
+};
+
+
+
+
+
+	
+	
+#endif

Modified: branches/multiplayer-branch/source/games/gflmelee.cpp
===================================================================
--- branches/multiplayer-branch/source/games/gflmelee.cpp	2004-10-02 22:14:53 UTC (rev 74)
+++ branches/multiplayer-branch/source/games/gflmelee.cpp	2004-10-06 21:22:23 UTC (rev 75)
@@ -28,8 +28,8 @@
 #include "melee/mshppan.h"
 
 #include "melee/mframe.h"
-#include "melee/mgame.h"
-#include "melee/mmain.h"
+#include "games/gmelee.h"
+#include "games/gmelee.h"
 #include "melee/mcbodies.h"
 #include "melee/mview.h"
 #include "other/orbit.h"

Modified: branches/multiplayer-branch/source/games/ggob.cpp
===================================================================
--- branches/multiplayer-branch/source/games/ggob.cpp	2004-10-02 22:14:53 UTC (rev 74)
+++ branches/multiplayer-branch/source/games/ggob.cpp	2004-10-06 21:22:23 UTC (rev 75)
@@ -26,7 +26,7 @@
 #include "frame.h"
 
 #include "melee/mgame.h"
-#include "melee/mmain.h"
+#include "games/gmelee.h"
 #include "melee/mview.h"
 #include "melee/mcontrol.h"
 #include "melee/mcbodies.h"

Copied: branches/multiplayer-branch/source/games/gmelee.cpp (from rev 71, branches/multiplayer-branch/source/melee/mmain.cpp)
===================================================================
--- branches/multiplayer-branch/source/melee/mmain.cpp	2004-09-28 19:53:03 UTC (rev 71)
+++ branches/multiplayer-branch/source/games/gmelee.cpp	2004-10-06 21:22:23 UTC (rev 75)
@@ -0,0 +1,723 @@
+/* $Id$ */ 
+/*
+This file is part of "TW-Light" 
+                    http://timewarp.sourceforge.net/
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <time.h>
+#include <allegro.h>
+
+#include "melee.h"
+#include "scp.h"
+#include "frame.h"
+
+
+#include "gmelee.h"
+#include "melee/mview.h"
+#include "melee/mcontrol.h"
+#include "other/planet3d.h"
+#include "melee/mshppan.h"
+#include "melee/mship.h"
+#include "melee/mlog.h"
+//#include "mnet1.h"
+#include "melee/mitems.h"
+#include "melee/mfleet.h"
+
+#include "gflmelee.h"
+
+#include "other/twconfig.h"
+	
+#include "ais.h"
+
+int MeleeGame::add_player (Control *c, int team_index, const char *name, const char *fleet_section, const char *fleet_file) {STACKTRACE
+	int i = num_players;
+	num_players += 1;
+	player_control = (Control**) realloc(player_control,   sizeof(Control*)   * num_players);
+	player_name    =    (char**) realloc(player_name,      sizeof(char*)      * num_players);
+//	player_panel = (ShipPanel**) realloc(player_panel,     sizeof(ShipPanel*) * num_players);
+	player_fleet =     (Fleet**) realloc(player_fleet,     sizeof(Fleet *)    * num_players);
+	player_team =    (TeamCode*) realloc(player_team,      sizeof(TeamCode)   * num_players);
+	player_control[i] = c;
+	add_focus(c, c->channel);
+//	player_panel[i] = NULL;
+	player_fleet[i] = new Fleet();
+	player_fleet[i]->reset();
+	player_name[i] = strdup(name);
+	if (team_index >= team_table_size) {
+		int i = team_table_size;
+		team_table_size = team_index + 1;
+		team_table = (TeamCode*) realloc(team_table, sizeof(TeamCode) * team_table_size);
+		for (; i < team_table_size; i += 1) {
+			if (i) team_table[i] = new_team();
+			else team_table[i] = 0;
+		}
+	}
+	if (team_index) player_team[i] = team_table[team_index];
+	else player_team[i] = new_team();
+	char sect[40];
+	sprintf(sect, "Player%d", i+1);
+	if (c->channel == channel_none) {
+		tw_error("channel_none not allowed here");
+		//log_file(fleet_file);
+		//::fleet->load(NULL, fleet_section);
+		}
+	else if (log->get_direction(c->channel) & Log::direction_write) {
+		player_fleet[i]->load(fleet_file, fleet_section);
+		log_fleet(c->channel, player_fleet[i]);
+		c->target_sign_color = ((3+i) % 7) + 1;
+		}
+	else {
+		log_fleet(c->channel, player_fleet[i]);
+		}
+	tw_set_config_file("tmp.ini");
+	set_config_string(sect, "Name", name);
+	set_config_string(sect, "Type", c->getTypeName());
+	set_config_int(sect, "Team", team_index);
+	set_config_int(sect, "Channel", c->channel);
+	set_config_int(sect, "StartingFleetCost", player_fleet[i]->getCost());
+	set_config_int(sect, "StartingFleetSize", player_fleet[i]->getSize());
+	player_fleet[i]->save(NULL, sect);
+	player_fleet[i]->save("fleets.tmp", sect);
+	return i;
+	}
+
+void MeleeGame::init_objects() {
+  STACKTRACE;
+	int i;
+	add(new Stars());
+	Planet *planet = create_planet();
+	//Planet *planet = new Planet (size/2, planetSprite, random(planetSprite->frames()));
+	//add (planet);
+	if (view) view->camera.pos = size/2;
+	add(new WedgeIndicator(planet, 75, 4));
+	for (i = 0; i < num_asteroids; i += 1) add(new Asteroid());
+	}
+
+void MeleeGame::init_players() {
+  STACKTRACE;
+	switch (log->type) {
+		case Log::log_normal: {
+			for (int i = 0; true; i += 1) {
+				char buffy[64];
+				sprintf(buffy, "Player%d", i + 1);
+				tw_set_config_file("scp.ini");
+				const char *type = get_config_string(buffy, "Type", NULL);
+				if (!type) break;
+				if (strcmp(type, "none") == 0) continue;
+				const char *name = get_config_string(buffy, "Name", buffy);
+				char config[64];
+				sprintf(config, "Config%d", get_config_int(buffy, "Config", 0));
+				//int channel = channel_server;
+				//if (strcmp(type, "WussieBot") == 0) channel = channel_none;
+				//if (strcmp(type, "MoronBot") == 0) channel = channel_none;
+				int ti = get_config_int(buffy, "Team", 0);
+				add_player(create_control(channel_server, type, config), ti, name, buffy);
+			}
+		}
+		break;
+		case Log::log_net1client:
+		case Log::log_net1server: {
+			log_file("server.ini");
+			//int use_teams_menu = get_config_int("Network", "NetworkMeleeUseTeams", 0);
+			//if (use_teams_menu) {
+			if (1) {
+				int j;
+				for (j = 0; j < 2; j += 1) {
+					int ch;
+					if (j == 0) ch = channel_server;
+					else ch = channel_client;
+					if (is_local(ch)) {
+						tw_set_config_file("client.ini");//each side determines whether they are using manually specified teams
+						int use_teams_menu = get_config_int("Network", "NetworkMeleeUseTeams", 0);
+						const char *simple_config = 
+							"[Player1]\nType=Human\nConfig=0\nTeam=0\n";
+						for (int i = 0; true; i += 1) {
+							char buffy[64];
+							sprintf(buffy, "Player%d", i + 1);
+							if (use_teams_menu) tw_set_config_file("scp.ini");
+							else set_config_data(simple_config, strlen(simple_config));
+							const char *type = get_config_string(buffy, "Type", NULL);
+							if (!type) {
+								int tmp = 0;
+								log_int(ch, tmp);
+								break;
+							}
+							if (strcmp(type, "none") == 0) continue;
+							const char *name = get_config_string(buffy, "Name", buffy);
+							char config[64];
+							sprintf(config, "Config%d", get_config_int(buffy, "Config", 0));
+							//int channel = channel_server;
+							//if (strcmp(type, "WussieBot") == 0) channel = channel_none;
+							//if (strcmp(type, "MoronBot") == 0) channel = channel_none;
+							int ti = get_config_int(buffy, "Team", 0);
+							{int tmp = 1; log_int(ch, tmp);}
+							log_int(ch, ti);
+							int name_length = strlen(name);
+							log_int(ch, name_length);
+							log_data(ch, (char*)name, name_length);
+							add_player(create_control(ch, type, config), ti, name, buffy);
+						}
+					}
+					else {
+						for (int i = 0; true; i += 1) {
+							int tmp;
+							log_int(ch, tmp);
+							if (tmp == 0) break;
+							int team;
+							char *name;
+							log_int(ch, team);
+							int name_length;
+							log_int(ch, name_length);
+							name = (char*)malloc((name_length+1)*sizeof(char));
+							log_data(ch, name, name_length);
+							name[name_length] = 0;
+							add_player(create_control(ch, "Whatever"), team, name, NULL);
+						}
+					}
+				}
+			}
+		}
+		break;
+	}
+	return;
+}
+
+void MeleeGame::set_resolution(int screen_x, int screen_y) {
+  STACKTRACE;
+	int view_x, view_y;
+	view_x = screen_x;
+	view_y = screen_y;
+	int n, m;
+	n = 99;//int(ceil(double(num_players) / int(view_y / PANEL_HEIGHT)));
+	if (n) m = int(ceil(num_players / (double)n));
+	else m = 0;
+	//view->set_window(screen, 0, 0, view_x - PANEL_WIDTH * m, view_y);
+	redraw();
+	return;
+	}
+
+void MeleeGame::preinit() {
+  STACKTRACE;
+	Game::preinit();
+	player_control = NULL;
+	player_name = NULL;
+//	player_panel = NULL;
+	player_fleet = NULL;
+
+	player_team = NULL;
+	team_table = NULL;
+	num_kills = 0;
+	kills = NULL;
+	num_players = 0;
+	
+	gameEnding = false;
+	gameEndingTime = DefaultEndingTime;
+	}
+void MeleeGame::init(Log *_log) {
+  STACKTRACE;
+	Game::init(_log);
+
+	team_table_size = 0;
+
+	view->window->locate(0,0,0,0,0,0.9,0,1);
+
+	tw_delete_file("tmp.ini");
+	tw_delete_file("fleets.tmp");
+	tw_set_config_file ("tmp.ini");
+	set_config_string (NULL, "Ignorethis", "");
+	if (!log->playback) init_players();
+	log_file("tmp.ini");
+	if (log->playback) {
+		for (int i = 0; true; i += 1) {
+			char buffy[64];
+			sprintf(buffy, "Player%d", i + 1);
+			log_file("tmp.ini");
+			const char *type = get_config_string(buffy, "Type", NULL);
+			if (!type) break;
+			const char *name = get_config_string(buffy, "Name", buffy);
+			int channel = get_config_int(buffy, "Channel", -2);
+			int ti = get_config_int(buffy, "Team", 0);
+			add_player(create_control(channel, type), ti, name, buffy);
+			player_fleet[i]->load(NULL, buffy);
+			player_fleet[i]->save("fleets.tmp", buffy);
+			}
+		}
+
+
+	prepare();
+	init_objects();
+
+	next_choose_new_ships_time = game_time + 200;
+
+	// team and health indicators.
+	indteamtoggle = 0;
+	indhealthtoggle = 0;
+
+	return;
+	}
+
+MeleeGame::~MeleeGame() {STACKTRACE
+	if (player_control) free (player_control);
+	int i;
+	if (player_name) {
+		for (i = 0; i < num_players; i += 1) {
+			free(player_name[i]);
+			}
+		free(player_name);
+		}
+//	if (player_panel) free (player_panel);
+
+	if (player_team) free(player_team);
+	if (kills) free(kills);
+	}
+
+static int kill_all_delay_counter = 0;
+void MeleeGame::calculate() {
+  STACKTRACE;
+	Game::calculate();
+	if (next_choose_new_ships_time <= game_time) {
+		choose_new_ships();
+		next_choose_new_ships_time = game_time + 24*60*60*1000;
+	}
+
+	// specially for play-testers:
+	// kill all ships and ship-objects in the melee-game
+	if (kill_all_delay_counter > 0)
+	{
+		kill_all_delay_counter -= frame_time;
+	} else {
+
+		if (key[KEY_LCONTROL] && key[KEY_ALT] && key[KEY_K])
+		{
+			kill_all_delay_counter += 1000;	// 1 second delay
+
+			
+			for(std::list<SpaceLocation*>::iterator i=physics->item.begin();i!=physics->item.end();i++)
+			  {
+			    SpaceLocation *o;
+			    o = *i;
+			    if (!(o && o->exists()))
+			      continue;
+			    if (o->isPlanet() || o->isAsteroid())
+			      continue;
+			    o->die();
+			  }
+		}
+	}
+
+
+	return;
+	}
+
+void MeleeGame::ship_died(Ship *who, SpaceLocation *source) {
+  STACKTRACE;
+	char victimName[80] = "";
+	char killerName[80] = "";
+	int victimID = -1;
+	int killerID = -1;
+
+	// determine who died.
+	if (who && who->control) {
+		for (int i=0; i<num_players; i++) {
+			if (player_control[i] == who->control) {
+				victimID = i;
+				break;
+			}
+		}
+		strcpy(victimName, player_name[victimID]);
+	}
+	
+	// determine who killed, but skip it if nobody died.
+	if (strlen(victimName)>0 && source) {
+		
+		if ( ! source->isPlanet())
+		{
+			if (source->ship && source->ship->control) {
+				for (int i=0; i<num_players; i++) {
+					if (player_control[i] == source->ship->control) {
+						killerID = i;
+						break;
+					}
+				}
+				strcpy(killerName, player_name[killerID]);
+			}
+		}
+	}
+	
+	if (killerID == victimID) {
+		message.print(5000,15,"%s killed itself.", victimName);
+	}
+	else { 
+		if (source && source->isPlanet())
+			message.print(5000,15,"%s dove into a planet.", victimName);
+		else {
+			if (strlen(killerName) > 0) {
+				message.print(5000,15,"%s killed %s.", killerName, victimName);
+			}
+			else {
+				message.print(5000,15,"%s died.", victimName);
+			}
+		}
+	}
+	
+	if ( (victimID != -1) &&  
+		 (player_fleet[victimID]->getSize() <= 0) )
+	{
+		message.print(8000,15,"%s has been eliminated!", victimName);
+	}
+	
+	int n = game_time + 4000;
+	if (next_choose_new_ships_time > n) next_choose_new_ships_time = n;
+	Game::ship_died(who, source);
+	return;
+	}
+
+void MeleeGame::display_stats() {
+  STACKTRACE;
+	pause();
+	int i;
+	for (i = 0; i < num_players; i += 1) {
+		Fleet *fleet = player_fleet[i];
+		switch (log->type) {
+			case Log::log_net1client:
+			case Log::log_net1server: {
+//				if (log->get_direction(player_control[i]->channel) & Log::direction_write) 
+					message.print(6000, 15, "%s status: : %d / ?? Ships, %d / ??? points", player_name[i], fleet->getSize(), fleet->getCost());
+//				else
+//					message.print(6000, 15, "%s status: : %d / %d points", buffy, fleet->cost, player_total_fleet[i]);
+			}
+			break;
+			default: {
+				message.print(6000, 15, "%s status: : %d / ?? Ships, %d / ??? points", player_name[i], fleet->getSize(), fleet->getCost());
+			}
+			break;
+		}
+	}
+	unpause();
+	return;
+}
+bool MeleeGame::handle_key(int k)
+{
+  STACKTRACE;
+	switch (k >> 8) {
+		default: {
+			return Game::handle_key(k);
+			}
+		break;
+		case KEY_F5: {
+			display_stats();
+			return true;
+			}
+		break;
+		case KEY_F7: {
+			if (log->type == Log::log_normal) Game::handle_key(k);
+			return true;
+			}
+		break;
+		case KEY_F9: {
+			if (log->type != Log::log_normal) return false;
+			message.out("MUHAHAHAHAHA!!!!", 5000, 12);
+			add(new Planet(random(size), meleedata.planetSprite, random(meleedata.planetSprite->frames())));
+			return true;
+			}
+		break;
+		//don't use hardwired normal keys
+		case KEY_H:
+			if ((k & 255) == 'H'-'A'+1) indhealthtoggle = ~indhealthtoggle;
+			break;
+		case KEY_T:
+			if ((k & 255) == 'T'-'A'+1) indteamtoggle = ~indteamtoggle;
+			break;
+		}
+	return false;
+	}
+
+
+
+// added ROB
+class TeamIndicator : public Presence
+{
+public:
+	int		*indtoggle;
+	Ship	*mother;
+	TeamIndicator(Ship *creator, int *toggle);
+
+	virtual void calculate();
+	virtual void animate(Frame *space);
+};
+
+
+
+void MeleeGame::choose_new_ships() 
+{
+  STACKTRACE;
+  char tmp[40];
+  int i;
+  pause();
+
+  int *slot = new int[num_players];
+  //choose ships and send them across network
+  for (i = 0; i < num_players; i += 1) 
+    {
+      slot[i] = -2;
+      if (player_control[i]->ship) 
+	{
+	}
+      else 
+	{
+	  sprintf (tmp, "Player%d", i+1);
+	  Fleet *fleet = player_fleet[i];
+	  if (fleet->getSize() == 0) continue;
+	  char buffy[512];
+	  
+	  if (strlen(fleet->getTitle()) != 0) 
+	    sprintf(buffy, "%s\n%s\n", player_name[i], fleet->getTitle());
+	  else
+	    sprintf(buffy, "%s\n", player_name[i]);
+	  
+	  slot[i] = player_control[i]->choose_ship(window, buffy, fleet);
+	  if (player_control[i]->channel != channel_none) {
+	    slot[i] = intel_ordering(slot[i]);
+	    log->buffer(player_control[i]->channel, &slot[i], sizeof(int));
+	    log->flush();
+	  }
+	}
+    }
+  //recieve the ships that were chosen
+  log->listen();
+  for (i = 0; i < num_players; i += 1) 
+    {
+      if (slot[i] == -2) continue;
+      if (player_control[i]->channel != channel_none) 
+	{
+	  log->unbuffer(player_control[i]->channel, &slot[i], sizeof(int));
+	  slot[i] = intel_ordering(slot[i]);
+	}
+    }
+  //create the ships that were chosen
+  for (i = 0; i < num_players; i += 1) 
+    {
+      if (slot[i] == -2) continue;
+      sprintf (tmp, "Player%d", i+1);
+
+      Fleet *fleet = player_fleet[i];
+      if (slot[i] == -1) slot[i] = random() % fleet->getSize();
+      if (slot[i] < 0 || slot[i] >= fleet->getSize()) {tw_error("trying to load invalid ship");}
+      Ship *s = create_ship(fleet->getShipType(slot[i])->id, player_control[i], random(size), random(PI2), player_team[i]);
+      if (!s) {tw_error("unable to create ship");}
+      fleet->clear_slot(slot[i]);
+      fleet->Sort();
+      
+      s->locate();
+      add ( new WedgeIndicator ( s, 30, i+1 ) );
+      ShipPanel *panel = new ShipPanel(s);
+      panel->window->init(window);
+      panel->window->locate(
+			    0, 0.9,
+			    0, i * (100.0/480), 
+			    0, 0.1,
+			    0, (100.0/480)
+			    );
+      add(panel);
+      add(s->get_ship_phaser());
+      
+      // add a healthbar for the ship, and also a team indicator.
+      add(new HealthBar(s, &indhealthtoggle));
+      add(new TeamIndicator(s, &indteamtoggle));
+      
+      
+      // CHECK FILE SIZES !! to intercept desynch before they happen.
+      int myfsize, otherfsize;
+      
+      myfsize = 0;
+      otherfsize = myfsize;
+      if (player_control[i]->channel != channel_none) 
+	{
+	  log_int(player_control[i]->channel, otherfsize);
+	}
+      
+      if (otherfsize != myfsize)
+	{
+	  // the player who loads the ship doesn't get this message, cause his own file is identical by default
+	  tw_error("DAT files have different size! This may cause a desynch. Press Retry to continue");
+	}
+		
+		
+    }
+  delete[] slot;
+  //message.out("Finished selecting ships...", 1500);
+  unpause();
+  return;
+}
+
+bool MeleeGame::isGameDone() 
+{
+  STACKTRACE;
+  /*! we'll only check this every now and again, to avoid bogging down the engine.  */  
+  enum { IterationsToSkip = 30 };
+  static long iterationsToSkip = IterationsToSkip;
+  
+  /*! */
+  if (gameEnding) {
+    /*! how long do we wait after a victory before exiting the game? */
+    if (--gameEndingTime > 0)
+      return Game::isGameDone();
+    else {
+      game_done = true;
+    }
+  }
+  
+  if (iterationsToSkip-- <=0 ) {
+    iterationsToSkip = IterationsToSkip;
+    
+    //determine how many teams are still alive
+    unsigned numAliveTeams = 0;
+    TeamCode * teams = (TeamCode*)calloc(MAX_TEAMS, sizeof(TeamCode));
+    
+    for (int i=0; i<num_players; i++) {
+      
+      //check for: 
+      //* does the player have any ships left in her fleet?
+      //* is the player controlling a ship right now?
+      if ( ( player_fleet[i] && 
+	     player_fleet[i]->getSize() > 0)
+	   ||
+	   (player_control[i] &&
+	    player_control[i]->ship)
+	   )
+	{
+	  if (teams[ player_team[i] ] == 0)
+	    numAliveTeams++;
+	  teams[ player_team[i] ]++;
+	}
+    }
+    
+    //either there's one team left standing, or none. :)
+    // either way, the game is over.
+    //we delay ending the game a few seconds for dramatic effect
+    if (numAliveTeams <= 1) {
+      gameEnding = true;
+      if (numAliveTeams==1) {
+	for (int i=0; i<num_players; i++) {
+	  if ( ( player_fleet[i] && 
+		 player_fleet[i]->getSize() > 0)
+	       ||
+	       (player_control[i] &&
+		player_control[i]->ship) )
+	    {
+	      if (player_control[i]->isHuman())
+		message.print(8000,15,"%s won the match!", player_name[i]);
+	      else
+		message.print(8000,15,"%s won the match!", control_name[ player_control[i]->getControlType() ]);
+	    				break;
+	    }
+	}
+      } else {
+	message.print(8000,15,"Match ends in a draw!");
+      }
+    }
+    free(teams);
+  }
+  return Game::isGameDone();
+}
+
+// this should be places elsewhere I think ...
+TeamIndicator::TeamIndicator(Ship *s, int *atoggle)
+{
+  STACKTRACE;
+	indtoggle = atoggle;
+	mother = s;
+}
+
+void TeamIndicator::calculate()
+{
+  STACKTRACE;
+	if ( !(mother && mother->exists()) )
+	{
+		mother = 0;
+		state = 0;
+		return;
+	}
+}
+
+void TeamIndicator::animate(Frame *space) {
+  STACKTRACE;
+  if (!*indtoggle)
+    return;
+  
+  if (mother->isInvisible())
+    return;
+  
+  Vector2i co1, co2;
+  
+  co1 = corner(mother->pos - 0.5 * mother->size).round();
+  co2 = corner(mother->pos + 0.5 * mother->size).round();
+  
+  if (co2.x < 0) return;
+  if (co2.y < 0) return;
+  if (co1.x >= space->surface->w) return;
+  if (co1.y >= space->surface->h) return;
+  
+  int col;
+  col = palette_color[mother->get_team() + 1];	// team 0 is black ...
+  
+  rect(space->surface, co1.x, co1.y, co2.x, co2.y, col);
+  space->add_box(co1.x, co1.y, co2.x, co2.y);
+  
+}
+void MeleeGame::showHelpText() {
+  STACKTRACE;
+	const char * file = data_full_path("ingame.txt").c_str();
+	char text[10000] = "";
+	char controlHelp[3000] = "";
+	
+	sprintf(text, "In-Game Keys:\n");
+	for (int i=0; i<num_players; i++) {
+		if (player_control[i])// && player_control[i]->isHuman() ) {
+		{
+			strcpy(controlHelp, "");
+			player_control[i]->getHelpText(controlHelp);
+			strcat(controlHelp, "\n");
+			
+			strcat(text, controlHelp);
+		}
+	}
+	
+	int i;
+	PACKFILE *f;
+	char * willy = NULL;
+	f = pack_fopen (file, F_READ);
+	if (!f) {
+		willy = (char*) malloc(strlen(file)+strlen("Failed to load file \"\"")+1);
+		sprintf(text, "Failed to load file \"%s\"",file);
+	}
+	else {
+		i = file_size(file);
+		willy = (char*)malloc(i+1);
+		i = pack_fread (willy, i, f);
+		pack_fclose(f);
+		willy[i] = 0;
+	}
+	strcat(text, willy);
+	show_text(text);
+	free(willy); // now this is funny :)
+	return;
+}
+
+
+
+REGISTER_GAME(MeleeGame, "Melee")

Copied: branches/multiplayer-branch/source/games/gmelee.h (from rev 71, branches/multiplayer-branch/source/melee/mmain.h)
===================================================================
--- branches/multiplayer-branch/source/melee/mmain.h	2004-09-28 19:53:03 UTC (rev 71)
+++ branches/multiplayer-branch/source/games/gmelee.h	2004-10-06 21:22:23 UTC (rev 75)
@@ -0,0 +1,85 @@
+/* $$ */ 
+/*
+This file is part of "TW-Light" 
+                    http://timewarp.sourceforge.net/
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#ifndef __MMAIN_H__
+#define __MMAIN_H__
+
+#include "melee.h"
+#include "melee/mgame.h"
+
+enum { DefaultEndingTime = 1000 };
+
+class MeleeGame : public Game {
+	public:
+	enum { 
+		num_asteroids = 4 
+		};
+		
+	~MeleeGame();
+
+	virtual void calculate();
+	virtual void preinit();	
+	virtual void init (Log *_log = NULL);
+	virtual void set_resolution(int screen_x, int screen_y);
+
+	virtual void init_players();
+	virtual void init_objects();
+
+	virtual void ship_died(Ship *who, SpaceLocation *source);
+	//kill history stuff
+	int num_kills;
+	struct ShipKill {
+		int time;
+		struct Party {
+			unsigned int ally_flag;
+			ShipData *data;
+			ShipType *type;
+		};
+		Party victim, killer;
+		} *kills;
+	void display_stats();
+
+	virtual int add_player (Control *c, int team_index, const char *name, const char *fleet, const char *fleet_file = "fleets.ini") ;
+	virtual bool isGameDone();
+	int num_players;
+	Control **player_control;
+//	ShipPanel **player_panel;
+	Fleet **player_fleet;
+	char **player_name;
+	char *player_attributes;
+	TeamCode *player_team;
+	TeamCode *team_table;
+	int team_table_size;
+//	virtual void player_said(int who, const char *what);
+
+	protected:
+	virtual bool handle_key(int k);
+	
+	virtual void showHelpText();
+	
+	bool gameEnding;
+	long gameEndingTime;
+
+	int next_choose_new_ships_time;
+	virtual void choose_new_ships() ;
+
+	int indhealthtoggle, indteamtoggle;
+
+	};
+
+
+#endif // __MMAIN_H__

Modified: branches/multiplayer-branch/source/libraries/raknet/Multiplayer.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/Multiplayer.h	2004-10-02 22:14:53 UTC (rev 74)
+++ branches/multiplayer-branch/source/libraries/raknet/Multiplayer.h	2004-10-06 21:22:23 UTC (rev 75)
@@ -209,8 +209,8 @@
 void Multiplayer<InterfaceType>::ProcessUnhandledPacket(Packet *p, unsigned char packetIdentifier, InterfaceType *interfaceType)
 {
 	// Remove the annoying warnings
-	packetIdentifier;
-	interfaceType;
+	//packetIdentifier;
+	//interfaceType;
 
 	// This class should have been overrided to handle user defined packets
 #ifdef _DEBUG

Modified: branches/multiplayer-branch/source/melee/mhelpers.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mhelpers.cpp	2004-10-02 22:14:53 UTC (rev 74)
+++ branches/multiplayer-branch/source/melee/mhelpers.cpp	2004-10-06 21:22:23 UTC (rev 75)
@@ -27,7 +27,7 @@
 #include <assert.h>
 #include "other/dialogs.h"
 
-#include "melee/mmain.h"
+#include "games/gmelee.h"
 #include "scp.h"
 #include "melee.h"
 #include "melee/mcontrol.h"

Deleted: branches/multiplayer-branch/source/melee/mmain.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mmain.cpp	2004-10-02 22:14:53 UTC (rev 74)
+++ branches/multiplayer-branch/source/melee/mmain.cpp	2004-10-06 21:22:23 UTC (rev 75)
@@ -1,723 +0,0 @@
-/* $Id: mmain.cpp,v 1.3 2004/08/08 17:36:06 Yura Exp $ */ 
-/*
-This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
-Copyright (C) 2001-2004  TimeWarp development team
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-*/
-
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <time.h>
-#include <allegro.h>
-
-#include "melee.h"
-#include "scp.h"
-#include "frame.h"
-
-
-#include "mmain.h"
-#include "mview.h"
-#include "mcontrol.h"
-#include "other/planet3d.h"
-#include "mshppan.h"
-#include "mship.h"
-#include "mlog.h"
-//#include "mnet1.h"
-#include "mitems.h"
-#include "mfleet.h"
-
-#include "games/gflmelee.h"
-
-#include "other/twconfig.h"
-	
-#include "ais.h"
-
-int NormalGame::add_player (Control *c, int team_index, const char *name, const char *fleet_section, const char *fleet_file) {STACKTRACE
-	int i = num_players;
-	num_players += 1;
-	player_control = (Control**) realloc(player_control,   sizeof(Control*)   * num_players);
-	player_name    =    (char**) realloc(player_name,      sizeof(char*)      * num_players);
-//	player_panel = (ShipPanel**) realloc(player_panel,     sizeof(ShipPanel*) * num_players);
-	player_fleet =     (Fleet**) realloc(player_fleet,     sizeof(Fleet *)    * num_players);
-	player_team =    (TeamCode*) realloc(player_team,      sizeof(TeamCode)   * num_players);
-	player_control[i] = c;
-	add_focus(c, c->channel);
-//	player_panel[i] = NULL;
-	player_fleet[i] = new Fleet();
-	player_fleet[i]->reset();
-	player_name[i] = strdup(name);
-	if (team_index >= team_table_size) {
-		int i = team_table_size;
-		team_table_size = team_index + 1;
-		team_table = (TeamCode*) realloc(team_table, sizeof(TeamCode) * team_table_size);
-		for (; i < team_table_size; i += 1) {
-			if (i) team_table[i] = new_team();
-			else team_table[i] = 0;
-		}
-	}
-	if (team_index) player_team[i] = team_table[team_index];
-	else player_team[i] = new_team();
-	char sect[40];
-	sprintf(sect, "Player%d", i+1);
-	if (c->channel == channel_none) {
-		tw_error("channel_none not allowed here");
-		//log_file(fleet_file);
-		//::fleet->load(NULL, fleet_section);
-		}
-	else if (log->get_direction(c->channel) & Log::direction_write) {
-		player_fleet[i]->load(fleet_file, fleet_section);
-		log_fleet(c->channel, player_fleet[i]);
-		c->target_sign_color = ((3+i) % 7) + 1;
-		}
-	else {
-		log_fleet(c->channel, player_fleet[i]);
-		}
-	tw_set_config_file("tmp.ini");
-	set_config_string(sect, "Name", name);
-	set_config_string(sect, "Type", c->getTypeName());
-	set_config_int(sect, "Team", team_index);
-	set_config_int(sect, "Channel", c->channel);
-	set_config_int(sect, "StartingFleetCost", player_fleet[i]->getCost());
-	set_config_int(sect, "StartingFleetSize", player_fleet[i]->getSize());
-	player_fleet[i]->save(NULL, sect);
-	player_fleet[i]->save("fleets.tmp", sect);
-	return i;
-	}
-
-void NormalGame::init_objects() {
-  STACKTRACE;
-	int i;
-	add(new Stars());
-	Planet *planet = create_planet();
-	//Planet *planet = new Planet (size/2, planetSprite, random(planetSprite->frames()));
-	//add (planet);
-	if (view) view->camera.pos = size/2;
-	add(new WedgeIndicator(planet, 75, 4));
-	for (i = 0; i < num_asteroids; i += 1) add(new Asteroid());
-	}
-
-void NormalGame::init_players() {
-  STACKTRACE;
-	switch (log->type) {
-		case Log::log_normal: {
-			for (int i = 0; true; i += 1) {
-				char buffy[64];
-				sprintf(buffy, "Player%d", i + 1);
-				tw_set_config_file("scp.ini");
-				const char *type = get_config_string(buffy, "Type", NULL);
-				if (!type) break;
-				if (strcmp(type, "none") == 0) continue;
-				const char *name = get_config_string(buffy, "Name", buffy);
-				char config[64];
-				sprintf(config, "Config%d", get_config_int(buffy, "Config", 0));
-				//int channel = channel_server;
-				//if (strcmp(type, "WussieBot") == 0) channel = channel_none;
-				//if (strcmp(type, "MoronBot") == 0) channel = channel_none;
-				int ti = get_config_int(buffy, "Team", 0);
-				add_player(create_control(channel_server, type, config), ti, name, buffy);
-			}
-		}
-		break;
-		case Log::log_net1client:
-		case Log::log_net1server: {
-			log_file("server.ini");
-			//int use_teams_menu = get_config_int("Network", "NetworkMeleeUseTeams", 0);
-			//if (use_teams_menu) {
-			if (1) {
-				int j;
-				for (j = 0; j < 2; j += 1) {
-					int ch;
-					if (j == 0) ch = channel_server;
-					else ch = channel_client;
-					if (is_local(ch)) {
-						tw_set_config_file("client.ini");//each side determines whether they are using manually specified teams
-						int use_teams_menu = get_config_int("Network", "NetworkMeleeUseTeams", 0);
-						const char *simple_config = 
-							"[Player1]\nType=Human\nConfig=0\nTeam=0\n";
-						for (int i = 0; true; i += 1) {
-							char buffy[64];
-							sprintf(buffy, "Player%d", i + 1);
-							if (use_teams_menu) tw_set_config_file("scp.ini");
-							else set_config_data(simple_config, strlen(simple_config));
-							const char *type = get_config_string(buffy, "Type", NULL);
-							if (!type) {
-								int tmp = 0;
-								log_int(ch, tmp);
-								break;
-							}
-							if (strcmp(type, "none") == 0) continue;
-							const char *name = get_config_string(buffy, "Name", buffy);
-							char config[64];
-							sprintf(config, "Config%d", get_config_int(buffy, "Config", 0));
-							//int channel = channel_server;
-							//if (strcmp(type, "WussieBot") == 0) channel = channel_none;
-							//if (strcmp(type, "MoronBot") == 0) channel = channel_none;
-							int ti = get_config_int(buffy, "Team", 0);
-							{int tmp = 1; log_int(ch, tmp);}
-							log_int(ch, ti);
-							int name_length = strlen(name);
-							log_int(ch, name_length);
-							log_data(ch, (char*)name, name_length);
-							add_player(create_control(ch, type, config), ti, name, buffy);
-						}
-					}
-					else {
-						for (int i = 0; true; i += 1) {
-							int tmp;
-							log_int(ch, tmp);
-							if (tmp == 0) break;
-							int team;
-							char *name;
-							log_int(ch, team);
-							int name_length;
-							log_int(ch, name_length);
-							name = (char*)malloc((name_length+1)*sizeof(char));
-							log_data(ch, name, name_length);
-							name[name_length] = 0;
-							add_player(create_control(ch, "Whatever"), team, name, NULL);
-						}
-					}
-				}
-			}
-		}
-		break;
-	}
-	return;
-}
-
-void NormalGame::set_resolution(int screen_x, int screen_y) {
-  STACKTRACE;
-	int view_x, view_y;
-	view_x = screen_x;
-	view_y = screen_y;
-	int n, m;
-	n = 99;//int(ceil(double(num_players) / int(view_y / PANEL_HEIGHT)));
-	if (n) m = int(ceil(num_players / (double)n));
-	else m = 0;
-	//view->set_window(screen, 0, 0, view_x - PANEL_WIDTH * m, view_y);
-	redraw();
-	return;
-	}
-
-void NormalGame::preinit() {
-  STACKTRACE;
-	Game::preinit();
-	player_control = NULL;
-	player_name = NULL;
-//	player_panel = NULL;
-	player_fleet = NULL;
-
-	player_team = NULL;
-	team_table = NULL;
-	num_kills = 0;
-	kills = NULL;
-	num_players = 0;
-	
-	gameEnding = false;
-	gameEndingTime = DefaultEndingTime;
-	}
-void NormalGame::init(Log *_log) {
-  STACKTRACE;
-	Game::init(_log);
-
-	team_table_size = 0;
-
-	view->window->locate(0,0,0,0,0,0.9,0,1);
-
-	tw_delete_file("tmp.ini");
-	tw_delete_file("fleets.tmp");
-	tw_set_config_file ("tmp.ini");
-	set_config_string (NULL, "Ignorethis", "");
-	if (!log->playback) init_players();
-	log_file("tmp.ini");
-	if (log->playback) {
-		for (int i = 0; true; i += 1) {
-			char buffy[64];
-			sprintf(buffy, "Player%d", i + 1);
-			log_file("tmp.ini");
-			const char *type = get_config_string(buffy, "Type", NULL);
-			if (!type) break;
-			const char *name = get_config_string(buffy, "Name", buffy);
-			int channel = get_config_int(buffy, "Channel", -2);
-			int ti = get_config_int(buffy, "Team", 0);
-			add_player(create_control(channel, type), ti, name, buffy);
-			player_fleet[i]->load(NULL, buffy);
-			player_fleet[i]->save("fleets.tmp", buffy);
-			}
-		}
-
-
-	prepare();
-	init_objects();
-
-	next_choose_new_ships_time = game_time + 200;
-
-	// team and health indicators.
-	indteamtoggle = 0;
-	indhealthtoggle = 0;
-
-	return;
-	}
-
-NormalGame::~NormalGame() {STACKTRACE
-	if (player_control) free (player_control);
-	int i;
-	if (player_name) {
-		for (i = 0; i < num_players; i += 1) {
-			free(player_name[i]);
-			}
-		free(player_name);
-		}
-//	if (player_panel) free (player_panel);
-
-	if (player_team) free(player_team);
-	if (kills) free(kills);
-	}
-
-static int kill_all_delay_counter = 0;
-void NormalGame::calculate() {
-  STACKTRACE;
-	Game::calculate();
-	if (next_choose_new_ships_time <= game_time) {
-		choose_new_ships();
-		next_choose_new_ships_time = game_time + 24*60*60*1000;
-	}
-
-	// specially for play-testers:
-	// kill all ships and ship-objects in the melee-game
-	if (kill_all_delay_counter > 0)
-	{
-		kill_all_delay_counter -= frame_time;
-	} else {
-
-		if (key[KEY_LCONTROL] && key[KEY_ALT] && key[KEY_K])
-		{
-			kill_all_delay_counter += 1000;	// 1 second delay
-
-			
-			for(std::list<SpaceLocation*>::iterator i=physics->item.begin();i!=physics->item.end();i++)
-			  {
-			    SpaceLocation *o;
-			    o = *i;
-			    if (!(o && o->exists()))
-			      continue;
-			    if (o->isPlanet() || o->isAsteroid())
-			      continue;
-			    o->die();
-			  }
-		}
-	}
-
-
-	return;
-	}
-
-void NormalGame::ship_died(Ship *who, SpaceLocation *source) {
-  STACKTRACE;
-	char victimName[80] = "";
-	char killerName[80] = "";
-	int victimID = -1;
-	int killerID = -1;
-
-	// determine who died.
-	if (who && who->control) {
-		for (int i=0; i<num_players; i++) {
-			if (player_control[i] == who->control) {
-				victimID = i;
-				break;
-			}
-		}
-		strcpy(victimName, player_name[victimID]);
-	}
-	
-	// determine who killed, but skip it if nobody died.
-	if (strlen(victimName)>0 && source) {
-		
-		if ( ! source->isPlanet())
-		{
-			if (source->ship && source->ship->control) {
-				for (int i=0; i<num_players; i++) {
-					if (player_control[i] == source->ship->control) {
-						killerID = i;
-						break;
-					}
-				}
-				strcpy(killerName, player_name[killerID]);
-			}
-		}
-	}
-	
-	if (killerID == victimID) {
-		message.print(5000,15,"%s killed itself.", victimName);
-	}
-	else { 
-		if (source && source->isPlanet())
-			message.print(5000,15,"%s dove into a planet.", victimName);
-		else {
-			if (strlen(killerName) > 0) {
-				message.print(5000,15,"%s killed %s.", killerName, victimName);
-			}
-			else {
-				message.print(5000,15,"%s died.", victimName);
-			}
-		}
-	}
-	
-	if ( (victimID != -1) &&  
-		 (player_fleet[victimID]->getSize() <= 0) )
-	{
-		message.print(8000,15,"%s has been eliminated!", victimName);
-	}
-	
-	int n = game_time + 4000;
-	if (next_choose_new_ships_time > n) next_choose_new_ships_time = n;
-	Game::ship_died(who, source);
-	return;
-	}
-
-void NormalGame::display_stats() {
-  STACKTRACE;
-	pause();
-	int i;
-	for (i = 0; i < num_players; i += 1) {
-		Fleet *fleet = player_fleet[i];
-		switch (log->type) {
-			case Log::log_net1client:
-			case Log::log_net1server: {
-//				if (log->get_direction(player_control[i]->channel) & Log::direction_write) 
-					message.print(6000, 15, "%s status: : %d / ?? Ships, %d / ??? points", player_name[i], fleet->getSize(), fleet->getCost());
-//				else
-//					message.print(6000, 15, "%s status: : %d / %d points", buffy, fleet->cost, player_total_fleet[i]);
-			}
-			break;
-			default: {
-				message.print(6000, 15, "%s status: : %d / ?? Ships, %d / ??? points", player_name[i], fleet->getSize(), fleet->getCost());
-			}
-			break;
-		}
-	}
-	unpause();
-	return;
-}
-bool NormalGame::handle_key(int k)
-{
-  STACKTRACE;
-	switch (k >> 8) {
-		default: {
-			return Game::handle_key(k);
-			}
-		break;
-		case KEY_F5: {
-			display_stats();
-			return true;
-			}
-		break;
-		case KEY_F7: {
-			if (log->type == Log::log_normal) Game::handle_key(k);
-			return true;
-			}
-		break;
-		case KEY_F9: {
-			if (log->type != Log::log_normal) return false;
-			message.out("MUHAHAHAHAHA!!!!", 5000, 12);
-			add(new Planet(random(size), meleedata.planetSprite, random(meleedata.planetSprite->frames())));
-			return true;
-			}
-		break;
-		//don't use hardwired normal keys
-		case KEY_H:
-			if ((k & 255) == 'H'-'A'+1) indhealthtoggle = ~indhealthtoggle;
-			break;
-		case KEY_T:
-			if ((k & 255) == 'T'-'A'+1) indteamtoggle = ~indteamtoggle;
-			break;
-		}
-	return false;
-	}
-
-
-
-// added ROB
-class TeamIndicator : public Presence
-{
-public:
-	int		*indtoggle;
-	Ship	*mother;
-	TeamIndicator(Ship *creator, int *toggle);
-
-	virtual void calculate();
-	virtual void animate(Frame *space);
-};
-
-
-
-void NormalGame::choose_new_ships() 
-{
-  STACKTRACE;
-  char tmp[40];
-  int i;
-  pause();
-
-  int *slot = new int[num_players];
-  //choose ships and send them across network
-  for (i = 0; i < num_players; i += 1) 
-    {
-      slot[i] = -2;
-      if (player_control[i]->ship) 
-	{
-	}
-      else 
-	{
-	  sprintf (tmp, "Player%d", i+1);
-	  Fleet *fleet = player_fleet[i];
-	  if (fleet->getSize() == 0) continue;
-	  char buffy[512];
-	  
-	  if (strlen(fleet->getTitle()) != 0) 
-	    sprintf(buffy, "%s\n%s\n", player_name[i], fleet->getTitle());
-	  else
-	    sprintf(buffy, "%s\n", player_name[i]);
-	  
-	  slot[i] = player_control[i]->choose_ship(window, buffy, fleet);
-	  if (player_control[i]->channel != channel_none) {
-	    slot[i] = intel_ordering(slot[i]);
-	    log->buffer(player_control[i]->channel, &slot[i], sizeof(int));
-	    log->flush();
-	  }
-	}
-    }
-  //recieve the ships that were chosen
-  log->listen();
-  for (i = 0; i < num_players; i += 1) 
-    {
-      if (slot[i] == -2) continue;
-      if (player_control[i]->channel != channel_none) 
-	{
-	  log->unbuffer(player_control[i]->channel, &slot[i], sizeof(int));
-	  slot[i] = intel_ordering(slot[i]);
-	}
-    }
-  //create the ships that were chosen
-  for (i = 0; i < num_players; i += 1) 
-    {
-      if (slot[i] == -2) continue;
-      sprintf (tmp, "Player%d", i+1);
-
-      Fleet *fleet = player_fleet[i];
-      if (slot[i] == -1) slot[i] = random() % fleet->getSize();
-      if (slot[i] < 0 || slot[i] >= fleet->getSize()) {tw_error("trying to load invalid ship");}
-      Ship *s = create_ship(fleet->getShipType(slot[i])->id, player_control[i], random(size), random(PI2), player_team[i]);
-      if (!s) {tw_error("unable to create ship");}
-      fleet->clear_slot(slot[i]);
-      fleet->Sort();
-      
-      s->locate();
-      add ( new WedgeIndicator ( s, 30, i+1 ) );
-      ShipPanel *panel = new ShipPanel(s);
-      panel->window->init(window);
-      panel->window->locate(
-			    0, 0.9,
-			    0, i * (100.0/480), 
-			    0, 0.1,
-			    0, (100.0/480)
-			    );
-      add(panel);
-      add(s->get_ship_phaser());
-      
-      // add a healthbar for the ship, and also a team indicator.
-      add(new HealthBar(s, &indhealthtoggle));
-      add(new TeamIndicator(s, &indteamtoggle));
-      
-      
-      // CHECK FILE SIZES !! to intercept desynch before they happen.
-      int myfsize, otherfsize;
-      
-      myfsize = 0;
-      otherfsize = myfsize;
-      if (player_control[i]->channel != channel_none) 
-	{
-	  log_int(player_control[i]->channel, otherfsize);
-	}
-      
-      if (otherfsize != myfsize)
-	{
-	  // the player who loads the ship doesn't get this message, cause his own file is identical by default
-	  tw_error("DAT files have different size! This may cause a desynch. Press Retry to continue");
-	}
-		
-		
-    }
-  delete[] slot;
-  //message.out("Finished selecting ships...", 1500);
-  unpause();
-  return;
-}
-
-bool NormalGame::isGameDone() 
-{
-  STACKTRACE;
-  /*! we'll only check this every now and again, to avoid bogging down the engine.  */  
-  enum { IterationsToSkip = 30 };
-  static long iterationsToSkip = IterationsToSkip;
-  
-  /*! */
-  if (gameEnding) {
-    /*! how long do we wait after a victory before exiting the game? */
-    if (--gameEndingTime > 0)
-      return Game::isGameDone();
-    else {
-      game_done = true;
-    }
-  }
-  
-  if (iterationsToSkip-- <=0 ) {
-    iterationsToSkip = IterationsToSkip;
-    
-    //determine how many teams are still alive
-    unsigned numAliveTeams = 0;
-    TeamCode * teams = (TeamCode*)calloc(MAX_TEAMS, sizeof(TeamCode));
-    
-    for (int i=0; i<num_players; i++) {
-      
-      //check for: 
-      //* does the player have any ships left in her fleet?
-      //* is the player controlling a ship right now?
-      if ( ( player_fleet[i] && 
-	     player_fleet[i]->getSize() > 0)
-	   ||
-	   (player_control[i] &&
-	    player_control[i]->ship)
-	   )
-	{
-	  if (teams[ player_team[i] ] == 0)
-	    numAliveTeams++;
-	  teams[ player_team[i] ]++;
-	}
-    }
-    
-    //either there's one team left standing, or none. :)
-    // either way, the game is over.
-    //we delay ending the game a few seconds for dramatic effect
-    if (numAliveTeams <= 1) {
-      gameEnding = true;
-      if (numAliveTeams==1) {
-	for (int i=0; i<num_players; i++) {
-	  if ( ( player_fleet[i] && 
-		 player_fleet[i]->getSize() > 0)
-	       ||
-	       (player_control[i] &&
-		player_control[i]->ship) )
-	    {
-	      if (player_control[i]->isHuman())
-		message.print(8000,15,"%s won the match!", player_name[i]);
-	      else
-		message.print(8000,15,"%s won the match!", control_name[ player_control[i]->getControlType() ]);
-	    				break;
-	    }
-	}
-      } else {
-	message.print(8000,15,"Match ends in a draw!");
-      }
-    }
-    free(teams);
-  }
-  return Game::isGameDone();
-}
-
-// this should be places elsewhere I think ...
-TeamIndicator::TeamIndicator(Ship *s, int *atoggle)
-{
-  STACKTRACE;
-	indtoggle = atoggle;
-	mother = s;
-}
-
-void TeamIndicator::calculate()
-{
-  STACKTRACE;
-	if ( !(mother && mother->exists()) )
-	{
-		mother = 0;
-		state = 0;
-		return;
-	}
-}
-
-void TeamIndicator::animate(Frame *space) {
-  STACKTRACE;
-  if (!*indtoggle)
-    return;
-  
-  if (mother->isInvisible())
-    return;
-  
-  Vector2i co1, co2;
-  
-  co1 = corner(mother->pos - 0.5 * mother->size).round();
-  co2 = corner(mother->pos + 0.5 * mother->size).round();
-  
-  if (co2.x < 0) return;
-  if (co2.y < 0) return;
-  if (co1.x >= space->surface->w) return;
-  if (co1.y >= space->surface->h) return;
-  
-  int col;
-  col = palette_color[mother->get_team() + 1];	// team 0 is black ...
-  
-  rect(space->surface, co1.x, co1.y, co2.x, co2.y, col);
-  space->add_box(co1.x, co1.y, co2.x, co2.y);
-  
-}
-void NormalGame::showHelpText() {
-  STACKTRACE;
-	const char * file = data_full_path("ingame.txt").c_str();
-	char text[10000] = "";
-	char controlHelp[3000] = "";
-	
-	sprintf(text, "In-Game Keys:\n");
-	for (int i=0; i<num_players; i++) {
-		if (player_control[i])// && player_control[i]->isHuman() ) {
-		{
-			strcpy(controlHelp, "");
-			player_control[i]->getHelpText(controlHelp);
-			strcat(controlHelp, "\n");
-			
-			strcat(text, controlHelp);
-		}
-	}
-	
-	int i;
-	PACKFILE *f;
-	char * willy = NULL;
-	f = pack_fopen (file, F_READ);
-	if (!f) {
-		willy = (char*) malloc(strlen(file)+strlen("Failed to load file \"\"")+1);
-		sprintf(text, "Failed to load file \"%s\"",file);
-	}
-	else {
-		i = file_size(file);
-		willy = (char*)malloc(i+1);
-		i = pack_fread (willy, i, f);
-		pack_fclose(f);
-		willy[i] = 0;
-	}
-	strcat(text, willy);
-	show_text(text);
-	free(willy); // now this is funny :)
-	return;
-}
-
-
-
-REGISTER_GAME(NormalGame, "Melee")

Deleted: branches/multiplayer-branch/source/melee/mmain.h
===================================================================
--- branches/multiplayer-branch/source/melee/mmain.h	2004-10-02 22:14:53 UTC (rev 74)
+++ branches/multiplayer-branch/source/melee/mmain.h	2004-10-06 21:22:23 UTC (rev 75)
@@ -1,85 +0,0 @@
-/* $Id: mmain.h,v 1.1.1.1 2004/08/01 10:21:22 Yura Exp $ */ 
-/*
-This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
-Copyright (C) 2001-2004  TimeWarp development team
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-*/
-
-#ifndef __MMAIN_H__
-#define __MMAIN_H__
-
-#include "melee.h"
-#include "mgame.h"
-
-enum { DefaultEndingTime = 1000 };
-
-class NormalGame : public Game {
-	public:
-	enum { 
-		num_asteroids = 4 
-		};
-		
-	~NormalGame();
-
-	virtual void calculate();
-	virtual void preinit();	
-	virtual void init (Log *_log = NULL);
-	virtual void set_resolution(int screen_x, int screen_y);
-
-	virtual void init_players();
-	virtual void init_objects();
-
-	virtual void ship_died(Ship *who, SpaceLocation *source);
-	//kill history stuff
-	int num_kills;
-	struct ShipKill {
-		int time;
-		struct Party {
-			unsigned int ally_flag;
-			ShipData *data;
-			ShipType *type;
-		};
-		Party victim, killer;
-		} *kills;
-	void display_stats();
-
-	virtual int add_player (Control *c, int team_index, const char *name, const char *fleet, const char *fleet_file = "fleets.ini") ;
-	virtual bool isGameDone();
-	int num_players;
-	Control **player_control;
-//	ShipPanel **player_panel;
-	Fleet **player_fleet;
-	char **player_name;
-	char *player_attributes;
-	TeamCode *player_team;
-	TeamCode *team_table;
-	int team_table_size;
-//	virtual void player_said(int who, const char *what);
-
-	protected:
-	virtual bool handle_key(int k);
-	
-	virtual void showHelpText();
-	
-	bool gameEnding;
-	long gameEndingTime;
-
-	int next_choose_new_ships_time;
-	virtual void choose_new_ships() ;
-
-	int indhealthtoggle, indteamtoggle;
-
-	};
-
-
-#endif // __MMAIN_H__

Modified: branches/multiplayer-branch/source/melee/mnet1.h
===================================================================
--- branches/multiplayer-branch/source/melee/mnet1.h	2004-10-02 22:14:53 UTC (rev 74)
+++ branches/multiplayer-branch/source/melee/mnet1.h	2004-10-06 21:22:23 UTC (rev 75)
@@ -18,7 +18,7 @@
 #ifndef __MNET1_H__
 #define __MNET1_H__
 
-#include "mmain.h"
+#include "games/gmelee.h"
 #include "mlog.h"
 #include "mship.h"
 

Modified: branches/multiplayer-branch/source/scp.cpp
===================================================================
--- branches/multiplayer-branch/source/scp.cpp	2004-10-02 22:14:53 UTC (rev 74)
+++ branches/multiplayer-branch/source/scp.cpp	2004-10-06 21:22:23 UTC (rev 75)
@@ -52,7 +52,7 @@
 #include "melee/mgame.h"
 
 
-#include "melee/mmain.h"
+#include "games/gmelee.h"
 #include "melee/mnet1.h"
 #include "util/aastr.h"
 #include "melee/mship.h" //remove

Modified: branches/multiplayer-branch/source/ships/shpconho.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpconho.cpp	2004-10-02 22:14:53 UTC (rev 74)
+++ branches/multiplayer-branch/source/ships/shpconho.cpp	2004-10-06 21:22:23 UTC (rev 75)
@@ -17,7 +17,7 @@
 
 #include "ship.h"
 
-#include "melee/mmain.h"
+#include "games/gmelee.h"
 #include "melee/mcbodies.h"
 
 #include "frame.h"

Modified: branches/multiplayer-branch/source/ships/shpkahbo.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpkahbo.cpp	2004-10-02 22:14:53 UTC (rev 74)
+++ branches/multiplayer-branch/source/ships/shpkahbo.cpp	2004-10-06 21:22:23 UTC (rev 75)
@@ -17,7 +17,7 @@
 
 #include "ship.h"
 
-#include "melee/mmain.h"
+#include "games/gmelee.h"
 
 #define SMALL_BOOMERANG 1
 #define MEDIUM_BOOMERANG 2

Modified: branches/multiplayer-branch/sources.lst
===================================================================
--- branches/multiplayer-branch/sources.lst	2004-10-02 22:14:53 UTC (rev 74)
+++ branches/multiplayer-branch/sources.lst	2004-10-06 21:22:23 UTC (rev 75)
@@ -1,191 +1,192 @@
+source/ais/c_input.cpp
+source/ais/c_other.cpp
 source/ais/c_wussie.cpp
-source/ais/c_other.cpp
-source/ais/c_input.cpp
+source/doxygen.cpp
 source/frame.cpp
-source/util/random.cpp
-source/util/vector2.cpp
-source/util/round.c
-source/util/history.cpp
-source/util/types.cpp
-source/util/aautil.c
-source/util/sound.cpp
-source/util/get_time.c
-source/util/aarot.c
-source/util/aastr.c
-source/util/errors.cpp
-source/util/errors_c.c
-source/util/endian.cpp
-source/util/pmask.c
-source/util/base.cpp
+source/games/gdefender.cpp
+source/games/gflmelee.cpp
 source/games/ggob.cpp
-source/games/gflmelee.cpp
-source/games/gdefender.cpp
+source/games/gmelee.cpp
+source/games/MultiplayerGame.cpp
+source/gui.cpp
+source/input.cpp
+source/libraries/agup/aalg.c
+source/libraries/agup/aase.c
+source/libraries/agup/abeos.c
+source/libraries/agup/abitmap.c
+source/libraries/agup/agtk.c
+source/libraries/agup/agup.c
+source/libraries/agup/ans.c
+source/libraries/agup/aphoton.c
+source/libraries/agup/awin95.c
+source/libraries/jpgalleg/decode.c
+source/libraries/jpgalleg/encode.c
+source/libraries/jpgalleg/io.c
+source/libraries/jpgalleg/jpgalleg.c
+source/libraries/lua/lapi.c
+source/libraries/lua/lcode.c
+source/libraries/lua/ldebug.c
+source/libraries/lua/ldo.c
+source/libraries/lua/ldump.c
+source/libraries/lua/lfunc.c
+source/libraries/lua/lgc.c
+source/libraries/lua/lib/lauxlib.c
+source/libraries/lua/lib/lbaselib.c
+source/libraries/lua/lib/ldblib.c
+source/libraries/lua/lib/liolib.c
+source/libraries/lua/lib/lmathlib.c
+source/libraries/lua/lib/loadlib.c
+source/libraries/lua/lib/lstrlib.c
+source/libraries/lua/lib/ltablib.c
+source/libraries/lua/llex.c
+source/libraries/lua/lmem.c
+source/libraries/lua/lobject.c
+source/libraries/lua/lopcodes.c
+source/libraries/lua/lparser.c
+source/libraries/lua/lstate.c
+source/libraries/lua/lstring.c
+source/libraries/lua/ltable.c
+source/libraries/lua/ltests.c
+source/libraries/lua/ltm.c
+source/libraries/lua/lundump.c
+source/libraries/lua/lvm.c
+source/libraries/lua/lzio.c
+source/libraries/raknet/AES128.cpp
+source/libraries/raknet/AsynchronousFileIO.cpp
+source/libraries/raknet/BitStream.cpp
+source/libraries/raknet/CheckSum.cpp
+source/libraries/raknet/DataBlockEncryptor.cpp
+source/libraries/raknet/DistributedNetworkObject.cpp
+source/libraries/raknet/DistributedNetworkObjectManager.cpp
+source/libraries/raknet/DistributedNetworkObjectStub.cpp
+source/libraries/raknet/EncodeClassName.cpp
+source/libraries/raknet/Euclid.cpp
+source/libraries/raknet/ExtendedOverlappedPool.cpp
+source/libraries/raknet/GetTime.cpp
+source/libraries/raknet/HuffmanEncodingTree.cpp
+source/libraries/raknet/HuffmanEncodingTreeFactory.cpp
+source/libraries/raknet/InternalPacketPool.cpp
+source/libraries/raknet/MPUInt.cpp
+source/libraries/raknet/NetworkObject.cpp
+source/libraries/raknet/NetworkTypes.cpp
+source/libraries/raknet/PacketPool.cpp
+source/libraries/raknet/RakClient.cpp
+source/libraries/raknet/RakNetworkFactory.cpp
+source/libraries/raknet/RakPeer.cpp
+source/libraries/raknet/RakServer.cpp
+source/libraries/raknet/rand.cpp
+source/libraries/raknet/ReliabilityLayer.cpp
+source/libraries/raknet/RPCNode.cpp
+source/libraries/raknet/RSA.cpp
+source/libraries/raknet/SHA1.cpp
+source/libraries/raknet/SimpleMutex.cpp
+source/libraries/raknet/SocketLayer.cpp
+source/libraries/raknet/StringCompressor.cpp
+source/melee/manim.cpp
+source/melee/mcbodies.cpp
+source/melee/mcontrol.cpp
+source/melee/mfleet.cpp
+source/melee/mframe.cpp
+source/melee/mgame.cpp
+source/melee/mhelpers.cpp
+source/melee/mitems.cpp
 source/melee/mlog.cpp
-source/melee/mitems.cpp
+source/melee/mmath.cpp
 source/melee/mnet1.cpp
 source/melee/moptions.cpp
-source/melee/mgame.cpp
-source/melee/mhelpers.cpp
-source/melee/mfleet.cpp
-source/melee/mview.cpp
 source/melee/mship.cpp
-source/melee/mcontrol.cpp
-source/melee/manim.cpp
-source/melee/mframe.cpp
 source/melee/mshot.cpp
 source/melee/mshpdata.cpp
 source/melee/mshppan.cpp
 source/melee/msprite.cpp
-source/melee/mcbodies.cpp
-source/melee/mmain.cpp
 source/melee/mtarget.cpp
-source/melee/mmath.cpp
-source/other/orbit.cpp
+source/melee/mview.cpp
 source/other/configrw.cpp
-source/other/shippart.cpp
+source/other/dialogs.cpp
 source/other/fontmorph.cpp
-source/other/vtarget.cpp
-source/other/twconfig.cpp
-source/other/vbodies.cpp
 source/other/gup.cpp
+source/other/nullphas.cpp
 source/other/objanim.cpp
-source/other/nullphas.cpp
+source/other/orbit.cpp
 source/other/planet3d.cpp
 source/other/radar.cpp
-source/other/dialogs.cpp
+source/other/shippart.cpp
+source/other/twconfig.cpp
+source/other/vbodies.cpp
+source/other/vtarget.cpp
+source/sc1ships/shpandgu.cpp
+source/sc1ships/shparisk.cpp
+source/sc1ships/shpchebr.cpp
+source/sc1ships/shpearcr.cpp
+source/sc1ships/shpilwav.cpp
+source/sc1ships/shpkzedr.cpp
+source/sc1ships/shpmmrxf.cpp
+source/sc1ships/shpmycpo.cpp
+source/sc1ships/shpshosc.cpp
+source/sc1ships/shpspael.cpp
+source/sc1ships/shpsyrpe.cpp
+source/sc1ships/shpumgdr.cpp
+source/sc1ships/shpvuxin.cpp
+source/sc1ships/shpyehte.cpp
+source/sc2ships/shpchmav.cpp
+source/sc2ships/shpdruma.cpp
+source/sc2ships/shpkohma.cpp
+source/sc2ships/shpmeltr.cpp
+source/sc2ships/shporzne.cpp
+source/sc2ships/shppkufu.cpp
+source/sc2ships/shpslypr.cpp
+source/sc2ships/shpsupbl.cpp
+source/sc2ships/shpthrto.cpp
+source/sc2ships/shputwju.cpp
+source/sc2ships/shpzfpst.cpp
+source/scp.cpp
+source/ships/shpaktgu.cpp
+source/ships/shpalabc.cpp
+source/ships/shpbahbu.cpp
+source/ships/shpbipka.cpp
+source/ships/shpbogce.cpp
+source/ships/shpchoex.cpp
+source/ships/shpconca.cpp
+source/ships/shpconho.cpp
+source/ships/shpdragr.cpp
+source/ships/shpearc3.cpp
+source/ships/shpforsh.cpp
+source/ships/shpgarty.cpp
+source/ships/shpilwsp.cpp
+source/ships/shpkahbo.cpp
+source/ships/shprogsq.cpp
+source/ships/shpstaba.cpp
 source/ships/shptauar.cpp
-source/ships/shpbogce.cpp
-source/ships/shpaktgu.cpp
 source/ships/shptauda.cpp
-source/ships/shpforsh.cpp
 source/ships/shptaume.cpp
-source/ships/shpdragr.cpp
 source/ships/shptausl.cpp
 source/ships/shptaust.cpp
 source/ships/shptauto.cpp
-source/ships/shpgarty.cpp
-source/ships/shprogsq.cpp
+source/ships/shpwolmi.cpp
+source/ships/shpyusra.cpp
 source/ships/shpzeksh.cpp
-source/ships/shpconca.cpp
-source/ships/shpchoex.cpp
-source/ships/shpconho.cpp
-source/ships/shpilwsp.cpp
-source/ships/shpalabc.cpp
-source/ships/shpyusra.cpp
-source/ships/shpbahbu.cpp
-source/ships/shpbipka.cpp
-source/ships/shpwolmi.cpp
-source/ships/shpearc3.cpp
-source/ships/shpkahbo.cpp
-source/ships/shpstaba.cpp
+source/tests/testdatapath.cpp
 source/tests/testmain.cpp
-source/tests/testdatapath.cpp
+source/twgui/twbutton.cpp
+source/twgui/twbuttontypes.cpp
 source/twgui/twgui.cpp
 source/twgui/twhelpers.cpp
-source/twgui/twbuttontypes.cpp
-source/twgui/twbutton.cpp
 source/twgui/twmenuexamples.cpp
 source/twgui/twpopup.cpp
 source/twgui/twwindow.cpp
 source/twgui/utils.cpp
-source/libraries/lua/lib/ldblib.c
-source/libraries/lua/lib/lauxlib.c
-source/libraries/lua/lib/lbaselib.c
-source/libraries/lua/lib/loadlib.c
-source/libraries/lua/lib/ltablib.c
-source/libraries/lua/lib/lmathlib.c
-source/libraries/lua/lib/lstrlib.c
-source/libraries/lua/lib/liolib.c
-source/libraries/lua/lundump.c
-source/libraries/lua/ldebug.c
-source/libraries/lua/ldo.c
-source/libraries/lua/lgc.c
-source/libraries/lua/ltm.c
-source/libraries/lua/lvm.c
-source/libraries/lua/lcode.c
-source/libraries/lua/ldump.c
-source/libraries/lua/lfunc.c
-source/libraries/lua/lparser.c
-source/libraries/lua/ltable.c
-source/libraries/lua/ltests.c
-source/libraries/lua/lstate.c
-source/libraries/lua/lapi.c
-source/libraries/lua/llex.c
-source/libraries/lua/lmem.c
-source/libraries/lua/lzio.c
-source/libraries/lua/lopcodes.c
-source/libraries/lua/lobject.c
-source/libraries/lua/lstring.c
-source/libraries/agup/aphoton.c
-source/libraries/agup/ans.c
-source/libraries/agup/awin95.c
-source/libraries/agup/aalg.c
-source/libraries/agup/aase.c
-source/libraries/agup/agtk.c
-source/libraries/agup/agup.c
-source/libraries/agup/abeos.c
-source/libraries/agup/abitmap.c
-source/libraries/raknet/AES128.cpp
-source/libraries/raknet/PacketPool.cpp
-source/libraries/raknet/ExtendedOverlappedPool.cpp
-source/libraries/raknet/RakServer.cpp
-source/libraries/raknet/RPCNode.cpp
-source/libraries/raknet/RSA.cpp
-source/libraries/raknet/RakClient.cpp
-source/libraries/raknet/HuffmanEncodingTreeFactory.cpp
-source/libraries/raknet/RakPeer.cpp
-source/libraries/raknet/SocketLayer.cpp
-source/libraries/raknet/StringCompressor.cpp
-source/libraries/raknet/DataBlockEncryptor.cpp
-source/libraries/raknet/InternalPacketPool.cpp
-source/libraries/raknet/SHA1.cpp
-source/libraries/raknet/rand.cpp
-source/libraries/raknet/GetTime.cpp
-source/libraries/raknet/EncodeClassName.cpp
-source/libraries/raknet/NetworkObject.cpp
-source/libraries/raknet/SimpleMutex.cpp
-source/libraries/raknet/Euclid.cpp
-source/libraries/raknet/DistributedNetworkObjectStub.cpp
-source/libraries/raknet/ReliabilityLayer.cpp
-source/libraries/raknet/AsynchronousFileIO.cpp
-source/libraries/raknet/HuffmanEncodingTree.cpp
-source/libraries/raknet/BitStream.cpp
-source/libraries/raknet/RakNetworkFactory.cpp
-source/libraries/raknet/DistributedNetworkObject.cpp
-source/libraries/raknet/MPUInt.cpp
-source/libraries/raknet/CheckSum.cpp
-source/libraries/raknet/DistributedNetworkObjectManager.cpp
-source/libraries/raknet/NetworkTypes.cpp
-source/libraries/jpgalleg/io.c
-source/libraries/jpgalleg/encode.c
-source/libraries/jpgalleg/decode.c
-source/libraries/jpgalleg/jpgalleg.c
-source/scp.cpp
-source/doxygen.cpp
-source/input.cpp
-source/sc1ships/shpearcr.cpp
-source/sc1ships/shpchebr.cpp
-source/sc1ships/shpandgu.cpp
-source/sc1ships/shpilwav.cpp
-source/sc1ships/shpkzedr.cpp
-source/sc1ships/shpyehte.cpp
-source/sc1ships/shpsyrpe.cpp
-source/sc1ships/shpspael.cpp
-source/sc1ships/shpvuxin.cpp
-source/sc1ships/shpumgdr.cpp
-source/sc1ships/shparisk.cpp
-source/sc1ships/shpmycpo.cpp
-source/sc1ships/shpmmrxf.cpp
-source/sc1ships/shpshosc.cpp
-source/sc2ships/shpthrto.cpp
-source/sc2ships/shporzne.cpp
-source/sc2ships/shpdruma.cpp
-source/sc2ships/shpmeltr.cpp
-source/sc2ships/shpchmav.cpp
-source/sc2ships/shpkohma.cpp
-source/sc2ships/shputwju.cpp
-source/sc2ships/shpsupbl.cpp
-source/sc2ships/shppkufu.cpp
-source/sc2ships/shpslypr.cpp
-source/sc2ships/shpzfpst.cpp
-source/gui.cpp
+source/util/aarot.c
+source/util/aastr.c
+source/util/aautil.c
+source/util/base.cpp
+source/util/endian.cpp
+source/util/errors.cpp
+source/util/errors_c.c
+source/util/get_time.c
+source/util/history.cpp
+source/util/pmask.c
+source/util/random.cpp
+source/util/round.c
+source/util/sound.cpp
+source/util/types.cpp
+source/util/vector2.cpp



From youbastrd at sheep.berlios.de  Fri Oct  8 23:42:01 2004
From: youbastrd at sheep.berlios.de (Paul Forest at BerliOS)
Date: Fri, 8 Oct 2004 23:42:01 +0200
Subject: [Tw-light-svn] r76 - branches/multiplayer-branch/source/libraries/raknet
Message-ID: <200410082142.i98Lg11Y021760@sheep.berlios.de>

Author: youbastrd
Date: 2004-10-08 23:41:59 +0200 (Fri, 08 Oct 2004)
New Revision: 76

Added:
   branches/multiplayer-branch/source/libraries/raknet/BigTypes.h
   branches/multiplayer-branch/source/libraries/raknet/RSACrypt.h
   branches/multiplayer-branch/source/libraries/raknet/RakNetStatistics.cpp
   branches/multiplayer-branch/source/libraries/raknet/RakNetStatistics.h
   branches/multiplayer-branch/source/libraries/raknet/Types.h
Modified:
   branches/multiplayer-branch/source/libraries/raknet/ArrayList.h
   branches/multiplayer-branch/source/libraries/raknet/AsynchronousFileIO.cpp
   branches/multiplayer-branch/source/libraries/raknet/BinarySearchTree.h
   branches/multiplayer-branch/source/libraries/raknet/BitStream.cpp
   branches/multiplayer-branch/source/libraries/raknet/BitStream.h
   branches/multiplayer-branch/source/libraries/raknet/ClientContextStruct.h
   branches/multiplayer-branch/source/libraries/raknet/DataBlockEncryptor.cpp
   branches/multiplayer-branch/source/libraries/raknet/DataBlockEncryptor.h
   branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObject.cpp
   branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObject.h
   branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObjectHeader.h
   branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObjectManager.cpp
   branches/multiplayer-branch/source/libraries/raknet/EncodeClassName.cpp
   branches/multiplayer-branch/source/libraries/raknet/GetTime.cpp
   branches/multiplayer-branch/source/libraries/raknet/GetTime.h
   branches/multiplayer-branch/source/libraries/raknet/HuffmanEncodingTree.cpp
   branches/multiplayer-branch/source/libraries/raknet/HuffmanEncodingTree.h
   branches/multiplayer-branch/source/libraries/raknet/InternalPacket.h
   branches/multiplayer-branch/source/libraries/raknet/InternalPacketPool.cpp
   branches/multiplayer-branch/source/libraries/raknet/LinkedList.h
   branches/multiplayer-branch/source/libraries/raknet/Multiplayer.h
   branches/multiplayer-branch/source/libraries/raknet/NetworkTypes.cpp
   branches/multiplayer-branch/source/libraries/raknet/NetworkTypes.h
   branches/multiplayer-branch/source/libraries/raknet/PacketEnumerations.h
   branches/multiplayer-branch/source/libraries/raknet/PacketPriority.h
   branches/multiplayer-branch/source/libraries/raknet/Queue.h
   branches/multiplayer-branch/source/libraries/raknet/RakClient.cpp
   branches/multiplayer-branch/source/libraries/raknet/RakClient.h
   branches/multiplayer-branch/source/libraries/raknet/RakClientInterface.h
   branches/multiplayer-branch/source/libraries/raknet/RakNetworkFactory.h
   branches/multiplayer-branch/source/libraries/raknet/RakPeer.cpp
   branches/multiplayer-branch/source/libraries/raknet/RakPeer.h
   branches/multiplayer-branch/source/libraries/raknet/RakPeerInterface.h
   branches/multiplayer-branch/source/libraries/raknet/RakServer.cpp
   branches/multiplayer-branch/source/libraries/raknet/RakServer.h
   branches/multiplayer-branch/source/libraries/raknet/RakServerInterface.h
   branches/multiplayer-branch/source/libraries/raknet/ReliabilityLayer.cpp
   branches/multiplayer-branch/source/libraries/raknet/ReliabilityLayer.h
   branches/multiplayer-branch/source/libraries/raknet/SHA1.h
   branches/multiplayer-branch/source/libraries/raknet/SocketLayer.cpp
   branches/multiplayer-branch/source/libraries/raknet/SocketLayer.h
   branches/multiplayer-branch/source/libraries/raknet/StringCompressor.cpp
   branches/multiplayer-branch/source/libraries/raknet/StringCompressor.h
Log:
updating Raknet source code to 2.28, downloaded on 2004.10.07.  This should be the most current, stable version of Raknet.

Modified: branches/multiplayer-branch/source/libraries/raknet/ArrayList.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/ArrayList.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/ArrayList.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -125,11 +125,7 @@
 template <class list_type>
 inline list_type& List<list_type>::operator[] (unsigned long position)
 {
-	if (position >= list_size)
-	{
-		assert(0); // Reading past the end of the list
-		return array[0];
-	}
+	assert (position < list_size);
 	return array[position];
 }
 

Modified: branches/multiplayer-branch/source/libraries/raknet/AsynchronousFileIO.cpp
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/AsynchronousFileIO.cpp	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/AsynchronousFileIO.cpp	2004-10-08 21:41:59 UTC (rev 76)
@@ -269,7 +269,7 @@
 				{
 					assert(dwIoSize>0);
 
-					ProcessNetworkPacket(lpOverlapped->playerId.binaryAddress, lpOverlapped->playerId.port, lpOverlapped->data, dwIoSize, lpOverlapped->rakPeer);
+					ProcessNetworkPacket(lpOverlapped->binaryAddress, lpOverlapped->port, lpOverlapped->data, dwIoSize, lpOverlapped->rakPeer);
 	
 					// Issue a new read so we always have one outstanding read per socket
 					// Finished a read.  Reuse the overlapped pointer

Added: branches/multiplayer-branch/source/libraries/raknet/BigTypes.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/BigTypes.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/BigTypes.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -0,0 +1,1609 @@
+/*
+	(128)2^7-bit to (32768)2^14-bit signed 2's complement & unsigned extended arithmetic
+
+	catid(cat02e at fsu.edu)
+
+	7/30/2004	Fixed VS6 compat
+	7/28/2004	Fixed macros so they can be used outside of the big namespace
+				Now using pre-processor definitions from types.h for inline assembly
+	7/26/2004	Removed a lot of assembly, made add/sub assembly optional
+	7/25/2004	Merged the wrapper class Int<T> from older code
+	7/24/2004	Replaced trivial assembly code with std:: functions
+				Refined some assembly code with Art of Assembly chapter 9
+				Added binary ops
+	7/23/2004	Finished assembly coding
+				Removed Int<T> class, for now
+				Added old C++ code back in with USEASSEMBLY
+	7/22/2004	Signed arithmetic (needed for ext. Euclidean algo)
+				Cleaned up coding style
+				Began rewriting parts in assembly
+	7/21/2004	Began writing
+
+	Tabs: 4 spaces
+	Dist: public
+*/
+
+#ifndef BIGTYPES_H
+#define BIGTYPES_H
+
+#include "Types.h"
+
+//#define BIG_USES_STRINGS /* undefining this means you cannot convert bigs to strings or from strings */
+
+#ifdef BIG_USES_STRINGS
+#	include <string>
+#endif
+
+namespace big
+{
+	using namespace cat;
+
+	//// basic definitions ////
+
+	// word size
+	typedef u32 word; // assembly implementation is for 32-bit word size
+	const u32 WORDBITS = sizeof(word) * 8;
+	const u32 HALFWORDBITS = sizeof(word) * 8 / 2;
+	const word WORDHIGHBIT = (word)1 << (WORDBITS - 1);
+	const word WORDALLBITS = (word)0 - 1;
+	const word WORDLOBITS = ((word)1 << HALFWORDBITS) - 1;
+	const word WORDHIBITS = WORDALLBITS ^ WORDLOBITS;
+#define BIGHIGHBIT(n) ((n)[sizeof(n) / sizeof(big::word) - 1] & WORDHIGHBIT)
+
+	// template operator parameter modes
+#define BIGONETYPE template<class T> /* supports only one class */
+#define BIGTWOTYPES template<class T, class Bigger> /* sizeof Bigger >= sizeof T */
+#define BIGSMALLTYPE template<class Smaller> /* sizeof self >= sizeof Smaller */
+
+
+	//// big types ////
+
+#define BIGWORDCOUNT_FROMBITCOUNT(bits) ((bits) / 8 / sizeof(big::word))
+#define BIGWORDCOUNT(T) (sizeof(T) / sizeof(big::word))
+#define BIGBITCOUNT(T) (sizeof(T) * 8)
+
+	// low words -- [0] < [1] < [2] < [3] -- high words
+	typedef word u128[BIGWORDCOUNT_FROMBITCOUNT(128)];
+	typedef word u256[BIGWORDCOUNT_FROMBITCOUNT(256)];
+	typedef word u512[BIGWORDCOUNT_FROMBITCOUNT(512)];
+	typedef word u1024[BIGWORDCOUNT_FROMBITCOUNT(1024)];
+	typedef word u2048[BIGWORDCOUNT_FROMBITCOUNT(2048)];
+	typedef word u4096[BIGWORDCOUNT_FROMBITCOUNT(4096)];
+	typedef word u8192[BIGWORDCOUNT_FROMBITCOUNT(8192)];
+	typedef word u16384[BIGWORDCOUNT_FROMBITCOUNT(16384)];
+	typedef word u32768[BIGWORDCOUNT_FROMBITCOUNT(32768)];
+
+	// use these macros to create temporary variables when
+	// those variables are to be twice/half the size of another
+	// variable of varying size.
+#define BIGDOUBLESIZE(T, var_name) big::word (var_name)[BIGWORDCOUNT(T) * 2] /* WARNING: invalid w/ u32768 */
+#define BIGHALFSIZE(T, var_name) big::word (var_name)[BIGWORDCOUNT(T) / 2] /* WARNING: invalid w/ u128 */
+
+
+	//// library summary ////
+
+	// assignment
+	BIGONETYPE INLINE void zero(T &n); // n = 0
+	BIGONETYPE INLINE void usetw(T &a, word b); // a = b, zero-extend
+	BIGONETYPE INLINE void ssetw(T &a, word b); // a = b, sign-extend
+	BIGONETYPE INLINE void set(T &a, T &b); // a = b
+	BIGTWOTYPES INLINE void usetlow(Bigger &a, T &b); // a_low = b (zero-extend)
+	BIGTWOTYPES INLINE void ssetlow(Bigger &a, T &b); // a_low = b (sign-extend)
+	BIGTWOTYPES INLINE void sethigh(Bigger &a, T &b); // a_high = b
+	BIGTWOTYPES INLINE void takelow(T &a, Bigger &b); // a = b_low
+	BIGTWOTYPES INLINE void takehigh(T &a, Bigger &b); // a = b_high
+
+	// comparison
+	BIGONETYPE bool ugreater(T &a, T &b); // a > b (unsigned)
+	BIGONETYPE bool ugreaterOrEqual(T &a, T &b); // a >= b (unsigned)
+	BIGONETYPE bool sgreater(T &a, T &b); // a > b (signed)
+	BIGONETYPE bool sgreaterOrEqual(T &a, T &b); // a >= b (signed)
+	BIGONETYPE INLINE bool equal(T &a, T &b); // a == b
+	BIGONETYPE INLINE bool isZero(T &n); // a == 0
+
+	// binary
+	BIGONETYPE void bAND(T &a, T &b); // a &= b
+	BIGONETYPE void bOR(T &a, T &b); // a |= b
+	BIGONETYPE void bXOR(T &a, T &b); // a ^= b
+	BIGONETYPE void bNOT(T &n); // n = ~n
+
+	// shifting
+	BIGONETYPE void shiftLeft1(T &n); // n <<= 1
+	BIGONETYPE void shiftLeft(T &n, u32 s); // n <<= s (s <= WORDBITS)
+	BIGONETYPE void ushiftRight1(T &n); // n >>= 1 (unsigned)
+	BIGONETYPE void ushiftRight(T &n, u32 s); // n >>= s (unsigned) (s <= WORDBITS)
+	BIGONETYPE void sshiftRight1(T &n); // n >>= 1 (signed)
+	BIGONETYPE void sshiftRight(T &n, u32 s); // n >>= s (signed) (s <= WORDBITS)
+
+	// addition/subtraction
+	BIGONETYPE void add(T &a, T &b); // a += b
+	BIGONETYPE void increment(T &n); // ++n
+	BIGONETYPE void subtract(T &a, T &b); // a -= b
+	BIGONETYPE void decrement(T &n); // --n
+
+	// negation
+	BIGONETYPE void negate(T &n); // n = -n
+
+	// multiplication
+	BIGONETYPE void usquare(T &a); // a *= a, signed
+	BIGTWOTYPES void umultiply(T &a, T &b, Bigger &m); // m = a * b (&a != &b != &m), unsigned
+	BIGTWOTYPES void umultiply(Bigger &a, T &b); // a *= b (&a != &b), unsigned
+	BIGONETYPE void ssquare(T &a); // a *= a, signed
+	BIGTWOTYPES void smultiply(T &a, T &b, Bigger &m); // m = a * b (&a != &b != &m), signed
+	BIGTWOTYPES void smultiply(Bigger &a, T &b); // a *= b (&a != &b), signed
+
+	// division/remainder
+	BIGONETYPE void udivide(T &a, T &b, T &q, T &r); // {q, r} = a / b (&q != &r), unsigned
+	BIGONETYPE void umodulo(T &a, T &b, T &r); // r = a Mod b, unsigned
+	BIGONETYPE void sdivide(T &a, T &b, T &q, T &r); // {q, r} = a / b (&q != &r), signed
+	BIGONETYPE void smodulo(T &a, T &b, T &r); // r = a Mod b, signed
+
+#ifdef BIG_USES_STRINGS
+	// converting to/from strings
+	BIGONETYPE std::string toString(T &n, bool sign, u16 radix); // n -> string
+	BIGONETYPE void fromString(std::string s, T &n, bool sign, u16 radix); // s -> n
+#endif
+
+
+	//////// wrapper class ////////
+
+#define BIGINTFAST INLINE Int<T> & /* operation is done to self, returns itself */
+#define BIGINTSLOW Int<T> /* new object is created and returned */
+
+	BIGONETYPE class Int
+	{
+	protected:
+		T raw;
+
+	public:
+		operator T &(); // automatic casting to T: you may use BigInt classes as parameters to the functions
+
+	public:
+		Int();
+		Int(word n);
+#ifdef BIG_USES_STRINGS
+		Int(std::string &s);
+#endif
+		Int(T &n);
+
+	public:
+		BIGINTFAST zero();
+		BIGINTFAST operator=(word n);
+		BIGINTFAST operator=(T &n);
+
+	public:
+		BIGINTFAST operator<<=(u32 s);
+		BIGINTSLOW operator<<(u32 s);
+		BIGINTFAST operator>>=(u32 s);
+		BIGINTSLOW operator>>(u32 s);
+
+	public:
+		BIGINTFAST operator+=(T &n);
+		BIGINTSLOW operator+(T &n);
+		BIGINTFAST operator-=(T &n);
+		BIGINTSLOW operator-(T &n);
+		BIGINTFAST operator++(); // prefix
+		BIGINTSLOW operator++(int); // postfix
+		BIGINTFAST operator--(); // prefix
+		BIGINTSLOW operator--(int); // postfix
+
+	public:
+		BIGINTSLOW operator-(int); // negation
+
+	public:
+		BIGSMALLTYPE BIGINTFAST operator*=(Smaller &n)
+		{
+			smultiply(raw, n);
+			return *this;
+		}
+		BIGINTSLOW operator*(T &n);
+		BIGINTFAST square();
+
+	public:
+		BIGINTFAST operator/=(T &n);
+		BIGINTSLOW operator/(T &n);
+		BIGINTFAST operator%=(T &n);
+		BIGINTSLOW operator%(T &n);
+
+	public:
+		/* fast */ bool operator>(T &n);
+		/* fast */ bool operator>=(T &n);
+		/* fast */ bool operator<(T &n);
+		/* fast */ bool operator<=(T &n);
+		/* fast */ bool operator==(T &n);
+		/* fast */ bool operator!=(T &n);
+		/* fast */ bool operator!();
+
+	public:
+#ifdef BIG_USES_STRINGS
+		/* fast */ std::string str();
+		BIGINTFAST operator=(std::string &s);
+		BIGINTFAST operator=(const char *s);
+#endif
+	};
+
+
+	//////// assignment ////////
+
+	// n = 0
+	BIGONETYPE INLINE void zero(T &n)
+	{
+		memset(n, 0, sizeof(T));
+	}
+
+	// a = b, zero-extend
+	BIGONETYPE INLINE void usetw(T &a, word b)
+	{
+		a[0] = b;
+		memset(a + 1, 0, sizeof(T) - sizeof(word));
+	}
+
+	// a = b, sign-extend
+	BIGONETYPE INLINE void ssetw(T &a, word b)
+	{
+		a[0] = b;
+		memset(a + 1, (b & WORDHIGHBIT) ? WORDALLBITS : 0, sizeof(T) - sizeof(word));
+	}
+
+	// a = b
+	BIGONETYPE INLINE void set(T &a, T &b)
+	{
+		memcpy(a, b, sizeof(T));
+	}
+
+	// a_low = b (zero-extend)
+	BIGTWOTYPES INLINE void usetlow(Bigger &a, T &b)
+	{
+		memcpy(a, b, sizeof(T));
+		memset(a + BIGWORDCOUNT(T), 0, sizeof(Bigger) - sizeof(T));
+	}
+
+	// a_low = b (sign-extend)
+	BIGTWOTYPES INLINE void ssetlow(Bigger &a, T &b)
+	{
+		memcpy(a, b, sizeof(T));
+		memset(a + BIGWORDCOUNT(T), BIGHIGHBIT(b) ? WORDALLBITS : 0, sizeof(Bigger) - sizeof(T));
+	}
+
+	// a_high = b
+	BIGTWOTYPES INLINE void sethigh(Bigger &a, T &b)
+	{
+		memcpy(a + BIGWORDCOUNT(Bigger) - BIGWORDCOUNT(T), b, sizeof(T));
+		memset(a, 0, sizeof(Bigger) - sizeof(T));
+	}
+
+	// a = b_low
+	BIGTWOTYPES INLINE void takelow(T &a, Bigger &b)
+	{
+		memcpy(a, b, sizeof(T));
+	}
+
+	// a = b_high
+	BIGTWOTYPES INLINE void takehigh(T &a, Bigger &b)
+	{
+		memcpy(a, b + BIGWORDCOUNT(Bigger) - BIGWORDCOUNT(T), sizeof(T));
+	}
+
+
+	//////// comparison ////////
+
+	// a > b
+	BIGONETYPE bool ugreater(T &a, T &b)
+	{
+		for (s32 ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+		{
+			if (a[ii] > b[ii]) return true;
+			if (a[ii] < b[ii]) return false;
+		}
+
+		return false;
+	}
+
+	// a >= b
+	BIGONETYPE bool ugreaterOrEqual(T &a, T &b)
+	{
+		for (s32 ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+		{
+			if (a[ii] > b[ii]) return true;
+			if (a[ii] < b[ii]) return false;
+		}
+
+		return true;
+	}
+
+	// a > b
+	BIGONETYPE bool sgreater(T &a, T &b)
+	{
+		for (s32 ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+		{
+			if (a[ii] > b[ii]) return BIGHIGHBIT(a) == 0;
+			if (a[ii] < b[ii]) return BIGHIGHBIT(b) != 0;
+		}
+		return false;
+	}
+
+	// a >= b
+	BIGONETYPE bool sgreaterOrEqual(T &a, T &b)
+	{
+		for (s32 ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+		{
+			if (a[ii] > b[ii]) return BIGHIGHBIT(a) == 0;
+			if (a[ii] < b[ii]) return BIGHIGHBIT(b) != 0;
+		}
+		return true;
+	}
+
+	// a == b
+	BIGONETYPE INLINE bool equal(T &a, T &b)
+	{
+		return memcmp(a, b, sizeof(T)) == 0;
+	}
+
+	// a == 0
+	BIGONETYPE INLINE bool isZero(T &n)
+	{
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+			if (n[ii]) return false;
+		return true;
+	}
+
+
+	//////// binary ////////
+
+	// a &= b
+	BIGONETYPE void bAND(T &a, T &b)
+	{
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+			a[ii] &= b[ii];
+	}
+
+	// a |= b
+	BIGONETYPE void bOR(T &a, T &b)
+	{
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+			a[ii] |= b[ii];
+	}
+
+	// a ^= b
+	BIGONETYPE void bXOR(T &a, T &b)
+	{
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+			a[ii] ^= b[ii];
+	}
+
+	// n = ~n
+	BIGONETYPE void bNOT(T &n)
+	{
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+			n[ii] = ~n[ii];
+	}
+
+
+	//////// shifting ////////
+
+	// n <<= 1
+	BIGONETYPE void shiftLeft1(T &n)
+	{
+		register word w_i, carry = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			w_i = n[ii];
+
+			n[ii] = (w_i << 1) | carry;
+			carry = w_i >> (WORDBITS - 1);
+		}
+	}
+
+	// n <<= s (s <= WORDBITS)
+	BIGONETYPE void shiftLeft(T &n, u32 s)
+	{
+		register s32 ii;
+		register u32 bases = s / WORDBITS;
+		u32 bits = s % WORDBITS;
+
+		// move whole bases first
+		if (bases)
+		{
+			// shift bases
+			for (ii = BIGWORDCOUNT(T) - 1 - bases; ii >= 0; --ii)
+				n[ii + bases] = n[ii];
+
+			// clear the original locii of those bases
+			memset(n, 0, bases * sizeof(word));
+		}
+
+		if (bits)
+		{
+			register word w_i, carry = 0;
+
+			for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+			{
+				w_i = n[ii];
+
+				n[ii] = (w_i << bits) | carry;
+				carry = w_i >> (WORDBITS - bits);
+			}
+		}
+	}
+
+	// n >>= 1 (unsigned)
+	BIGONETYPE void ushiftRight1(T &n)
+	{
+		register word w_i, carry = 0;
+
+		for (s32 ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+		{
+			w_i = n[ii];
+
+			n[ii] = carry | (w_i >> 1);
+			carry = w_i << (WORDBITS - 1);
+		}
+	}
+
+	// n >>= s (unsigned) (s <= WORDBITS)
+	BIGONETYPE void ushiftRight(T &n, u32 s)
+	{
+		register s32 ii;
+		register u32 bases = s / WORDBITS;
+		register u32 bits = s % WORDBITS;
+
+		// move whole bases first
+		if (bases)
+		{
+			// shift bases
+			for (ii = bases; ii < BIGWORDCOUNT(T); ++ii)
+				n[ii - bases] = n[ii];
+
+			// clear the original locii of those bases
+			memset(n + BIGWORDCOUNT(T) - bases, 0, bases * sizeof(word));
+		}
+
+		if (bits)
+		{
+			register word w_i, carry = 0;
+
+			for (ii = BIGWORDCOUNT(T) - 1 - bases; ii >= 0; --ii)
+			{
+				w_i = n[ii];
+
+				n[ii] = carry | (w_i >> bits);
+				carry = w_i << (WORDBITS - bits);
+			}
+		}
+	}
+
+	// n >>= 1 (signed)
+	BIGONETYPE void sshiftRight1(T &n)
+	{
+		register word w_i, carry = BIGHIGHBIT(n) ? 1 : 0;
+
+		for (s32 ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+		{
+			w_i = n[ii];
+
+			n[ii] = carry | (w_i >> 1);
+			carry = w_i << (WORDBITS - 1);
+		}
+	}
+
+	// n >>= s (signed) (s <= WORDBITS)
+	BIGONETYPE void sshiftRight(T &n, u32 s)
+	{
+		register s32 ii;
+		register u32 bases = s / WORDBITS;
+		register u32 bits = s % WORDBITS;
+
+		word filler = BIGHIGHBIT(n) ? WORDALLBITS : 0;
+
+		// move whole bases first
+		if (bases)
+		{
+			// shift bases
+			for (ii = bases; ii < BIGWORDCOUNT(T); ++ii)
+				n[ii - bases] = n[ii];
+
+			// clear the original locii of those bases
+			memset(n + BIGWORDCOUNT(T) - bases, filler, bases * sizeof(word));
+		}
+
+		if (bits)
+		{
+			register word w_i, carry = filler << (WORDBITS - bits);
+
+			for (ii = BIGWORDCOUNT(T) - 1 - bases; ii >= 0; --ii)
+			{
+				w_i = n[ii];
+
+				n[ii] = carry | (w_i >> bits);
+				carry = w_i << (WORDBITS - bits);
+			}
+		}
+	}
+
+
+	//////// addition/subtraction ////////
+
+#if defined(NO_TEMPLATE_INLINE_ASSEMBLY) && defined(ASSEMBLY_INTEL_SYNTAX)
+	void BorlandAdd(void *a, void *b, u32 c)
+	{
+		ASSEMBLY_BLOCK // BorlandC, x86, 32-bit words
+		{
+			mov esi, b
+			mov edi, a
+			mov ecx, c
+
+			// unrolled loop since word count is a multiple of 4 >= 4
+			mov eax, [esi]
+			xor edx, edx		// edx used later to index later words >= 4
+			add [edi], eax		// and now we can use ADD instead of ADC on the first addition
+			mov eax, [esi + 4]
+			adc [edi + 4], eax
+			mov eax, [esi + 8]
+			adc [edi + 8], eax
+			mov eax, [esi + 12]
+			adc [edi + 12], eax
+
+			jecxz done_already
+
+next_word:	inc edx
+			inc edx
+
+			// unrolled loop since word count is a multiple of 4 >= 4
+			mov eax, [esi + edx * 8]
+			adc [edi + edx * 8], eax
+			mov eax, [esi + edx * 8 + 4]
+			adc [edi + edx * 8 + 4], eax
+			mov eax, [esi + edx * 8 + 8]
+			adc [edi + edx * 8 + 8], eax
+			mov eax, [esi + edx * 8 + 12]
+			adc [edi + edx * 8 + 12], eax
+
+			loop next_word
+done_already:
+		}
+	}
+#endif
+
+	// a += b
+	BIGONETYPE void add(T &a, T &b)
+	{
+#if defined(NO_TEMPLATE_INLINE_ASSEMBLY) && defined(ASSEMBLY_INTEL_SYNTAX)
+		const u32 qc1 = BIGWORDCOUNT(T) / 4 - 1;
+
+		BorlandAdd(a, b, qc1);
+
+#elif defined(ASSEMBLY_INTEL_SYNTAX)
+		const u32 qc1 = BIGWORDCOUNT(T) / 4 - 1;
+
+		ASSEMBLY_BLOCK // VS.NET, x86, 32-bit words
+		{
+			mov esi, b
+			mov edi, a
+			mov ecx, qc1
+
+			// unrolled loop since word count is a multiple of 4 >= 4
+			mov eax, [esi]
+			xor edx, edx		// edx used later to index later words >= 4
+			add [edi], eax		// and now we can use ADD instead of ADC on the first addition
+			mov eax, [esi + 4]
+			adc [edi + 4], eax
+			mov eax, [esi + 8]
+			adc [edi + 8], eax
+			mov eax, [esi + 12]
+			adc [edi + 12], eax
+
+			jecxz done_already
+
+next_word:	inc edx
+			inc edx
+
+			// unrolled loop since word count is a multiple of 4 >= 4
+			mov eax, [esi + edx * 8]
+			adc [edi + edx * 8], eax
+			mov eax, [esi + edx * 8 + 4]
+			adc [edi + edx * 8 + 4], eax
+			mov eax, [esi + edx * 8 + 8]
+			adc [edi + edx * 8 + 8], eax
+			mov eax, [esi + edx * 8 + 12]
+			adc [edi + edx * 8 + 12], eax
+
+			loop next_word
+done_already:
+		}
+#else
+		register word carry = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			word a_i = a[ii];
+			word b_i = b[ii];
+			a[ii] += b_i + carry;
+
+			carry = ((a_i & (WORDALLBITS >> 1)) + (b_i & (WORDALLBITS >> 1)) + carry) >> (WORDBITS - 1);
+			carry += (a_i >> (WORDBITS - 1)) + (b_i >> (WORDBITS - 1));
+			carry >>= 1;
+		}
+#endif
+	}
+
+	// ++n
+	BIGONETYPE void increment(T &n)
+	{
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+			if (++n[ii]) break;
+	}
+
+#if defined(NO_TEMPLATE_INLINE_ASSEMBLY) && defined(ASSEMBLY_INTEL_SYNTAX)
+	void BorlandSubtract(void *a, void *b, u32 c)
+	{
+		ASSEMBLY_BLOCK // BorlandC, x86, 32-bit words
+		{
+			mov esi, b
+			mov edi, a
+			mov ecx, c
+
+			// unrolled loop since word count is a multiple of 4 >= 4
+			mov eax, [esi]
+			xor edx, edx		// edx used later to index later words >= 4
+			add [edi], eax		// and now we can use ADD instead of ADC on the first addition
+			mov eax, [esi + 4]
+			adc [edi + 4], eax
+			mov eax, [esi + 8]
+			adc [edi + 8], eax
+			mov eax, [esi + 12]
+			adc [edi + 12], eax
+
+			jecxz done_already
+
+next_word:	inc edx
+			inc edx
+
+			// unrolled loop since word count is a multiple of 4 >= 4
+			mov eax, [esi + edx * 8]
+			adc [edi + edx * 8], eax
+			mov eax, [esi + edx * 8 + 4]
+			adc [edi + edx * 8 + 4], eax
+			mov eax, [esi + edx * 8 + 8]
+			adc [edi + edx * 8 + 8], eax
+			mov eax, [esi + edx * 8 + 12]
+			adc [edi + edx * 8 + 12], eax
+
+			loop next_word
+done_already:
+		}
+	}
+#endif
+
+	// a -= b
+	BIGONETYPE void subtract(T &a, T &b)
+	{
+#if defined(NO_TEMPLATE_INLINE_ASSEMBLY) && defined(ASSEMBLY_INTEL_SYNTAX)
+		const u32 qc1 = BIGWORDCOUNT(T) / 4 - 1;
+
+		BorlandSubtract(a, b, qc1);
+
+#elif defined(ASSEMBLY_INTEL_SYNTAX)
+
+		const u32 qc1 = BIGWORDCOUNT(T) / 4 - 1;
+
+		ASSEMBLY_BLOCK // VS.NET, x86, 32-bit words
+		{
+			mov esi, b
+			mov edi, a
+			mov ecx, qc1
+
+			// unrolled loop since word count is a multiple of 4 >= 4
+			mov eax, [esi]
+			xor edx, edx		// edx used later to index later words >= 4
+			sub [edi], eax		// first subtraction doesn't need to borrow
+			mov eax, [esi + 4]
+			sbb [edi + 4], eax
+			mov eax, [esi + 8]
+			sbb [edi + 8], eax
+			mov eax, [esi + 12]
+			sbb [edi + 12], eax
+
+			jecxz done_already
+
+next_word:	inc edx
+			inc edx
+
+			// unrolled loop since word count is a multiple of 4 >= 4
+			mov eax, [esi + edx * 8]
+			sbb [edi + edx * 8], eax
+			mov eax, [esi + edx * 8 + 4]
+			sbb [edi + edx * 8 + 4], eax
+			mov eax, [esi + edx * 8 + 8]
+			sbb [edi + edx * 8 + 8], eax
+			mov eax, [esi + edx * 8 + 12]
+			sbb [edi + edx * 8 + 12], eax
+
+			loop next_word
+done_already:
+		}
+#else
+		register word borrow = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			word a_i = a[ii];
+			word b_i = b[ii];
+			a[ii] -= b_i + borrow;
+
+			borrow = ((a_i & (WORDALLBITS >> 1)) - (b_i & (WORDALLBITS >> 1)) - borrow) >> (WORDBITS - 1);
+			borrow += (b_i >> (WORDBITS - 1)) - (a_i >> (WORDBITS - 1));
+			++borrow;
+			borrow >>= 1;
+		}
+#endif
+	}
+
+	// --n
+	BIGONETYPE void decrement(T &n)
+	{
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+			if (n[ii]--) break;
+	}
+
+
+	//////// negation ////////
+
+	// n = -n
+	BIGONETYPE void negate(T &n)
+	{
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+			n[ii] = ~n[ii];
+
+		increment(n);
+	}
+
+
+	//////// multiplication ////////
+
+	// a *= a, unsigned
+	BIGONETYPE void usquare(T &a)
+	{
+		T a0, a1;
+
+		set(a0, a);
+		set(a1, a);
+		zero(a);
+
+		u32 shifts = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			word w_i = a0[ii];
+
+			u16 ctr = WORDBITS;
+
+			while (w_i)
+			{
+				if (w_i & 1)
+				{
+					if (shifts)
+					{
+						shiftLeft(a1, shifts);
+						shifts = 0;
+					}
+
+					add(a, a1);
+				}
+
+				w_i >>= 1;
+				++shifts;
+				--ctr;
+			}
+
+			shifts += ctr;
+		}
+	}
+
+	// m = a * b (&a != &b != &m), unsigned
+	BIGTWOTYPES void umultiply(T &a0, T &b0, Bigger &m)
+	{
+		Bigger a;
+		usetlow(a, a0);
+
+		zero(m);
+
+		u32 shifts = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			word w_i = b0[ii];
+
+			u16 ctr = WORDBITS;
+
+			while (w_i)
+			{
+				if (w_i & 1)
+				{
+					if (shifts)
+					{
+						shiftLeft(a, shifts);
+						shifts = 0;
+					}
+
+					add(m, a);
+				}
+
+				w_i >>= 1;
+				++shifts;
+				--ctr;
+			}
+
+			shifts += ctr;
+		}
+	}
+
+	// a *= b (&a != &b), unsigned
+	BIGTWOTYPES void umultiply(Bigger &a0, T &b0)
+	{
+		Bigger a;
+		set(a, a0);
+
+		zero(a0);
+
+		u32 shifts = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			word w_i = b0[ii];
+
+			u16 ctr = WORDBITS;
+
+			while (w_i)
+			{
+				if (w_i & 1)
+				{
+					if (shifts)
+					{
+						shiftLeft(a, shifts);
+						shifts = 0;
+					}
+
+					add(a0, a);
+				}
+
+				w_i >>= 1;
+				++shifts;
+				--ctr;
+			}
+
+			shifts += ctr;
+		}
+	}
+
+	// a *= a, signed
+	BIGONETYPE void ssquare(T &a)
+	{
+		T a0, a1;
+
+		if (BIGHIGHBIT(a))
+			negate(a);
+
+		set(a0, a);
+		set(a1, a);
+		zero(a);
+
+		u32 shifts = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			word w_i = a0[ii];
+
+			u16 ctr = WORDBITS;
+
+			while (w_i)
+			{
+				if (w_i & 1)
+				{
+					if (shifts)
+					{
+						shiftLeft(a1, shifts);
+						shifts = 0;
+					}
+
+					add(a, a1);
+				}
+
+				w_i >>= 1;
+				++shifts;
+				--ctr;
+			}
+
+			shifts += ctr;
+		}
+	}
+
+	// m = a * b (&a != &b != &m), signed
+	BIGTWOTYPES void smultiply(T &a0, T &b0, Bigger &m)
+	{
+		Bigger a;
+		ssetlow(a, a0);
+
+		word sign_a = BIGHIGHBIT(a);
+		if (sign_a) negate(a);
+
+		T b;
+		set(b, b0);
+
+		word sign_b = BIGHIGHBIT(b);
+		if (sign_b) negate(b);
+
+		zero(m);
+
+		u32 shifts = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			word w_i = b[ii];
+
+			u16 ctr = WORDBITS;
+
+			while (w_i)
+			{
+				if (w_i & 1)
+				{
+					if (shifts)
+					{
+						shiftLeft(a, shifts);
+						shifts = 0;
+					}
+
+					add(m, a);
+				}
+
+				w_i >>= 1;
+				++shifts;
+				--ctr;
+			}
+
+			shifts += ctr;
+		}
+
+		if (sign_a ^ sign_b)
+			negate(m);
+	}
+
+	// a *= b (&a != &b), signed
+	BIGTWOTYPES void smultiply(Bigger &a0, T &b0)
+	{
+		Bigger a;
+		ssetlow(a, a0);
+
+		word sign_a = BIGHIGHBIT(a);
+		if (sign_a) negate(a);
+
+		T b;
+		set(b, b0);
+
+		word sign_b = BIGHIGHBIT(b);
+		if (sign_b) negate(b);
+
+		zero(a0);
+
+		u32 shifts = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			word w_i = b[ii];
+
+			u16 ctr = WORDBITS;
+
+			while (w_i)
+			{
+				if (w_i & 1)
+				{
+					if (shifts)
+					{
+						shiftLeft(a, shifts);
+						shifts = 0;
+					}
+
+					add(a0, a);
+				}
+
+				w_i >>= 1;
+				++shifts;
+				--ctr;
+			}
+
+			shifts += ctr;
+		}
+
+		if (sign_a ^ sign_b)
+			negate(a0);
+	}
+
+
+	//////// division/remainder ////////
+
+	// {q, r} = a / b (&q != &r), unsigned
+	BIGONETYPE void udivide(T &a, T &b0, T &q, T &r)
+	{
+		T b;
+
+		set(b, b0);
+		set(r, a);
+		zero(q);
+
+		u32 shifts = 1;
+
+		// sort of: shift b left until b > r, then shift back one
+		if (!BIGHIGHBIT(b) && ugreater(r, b))
+		{
+			s32 ii, jj;
+
+			// shift by words if possible
+			for (ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+				if (r[ii]) break;
+			for (jj = ii; jj >= 0; --jj)
+				if (b[jj]) break;
+
+			if (ii != jj)
+			{
+				shifts = (ii - jj) * WORDBITS;
+				shiftLeft(b, shifts);
+				++shifts;
+			}
+
+			while (!BIGHIGHBIT(b) && ugreater(r, b))
+			{
+				shiftLeft1(b);
+
+				++shifts;
+			}
+
+			while (ugreater(b, r))
+			{
+				ushiftRight1(b);
+
+				--shifts;
+			}
+		}
+		else if (ugreater(b, r))
+		{
+			ushiftRight1(b);
+
+			--shifts;
+		}
+
+		u32 qshifts = 0;
+
+		while (shifts--)
+		{
+			++qshifts;
+
+			if (!ugreater(b, r))
+			{
+				subtract(r, b);
+
+				shiftLeft(q, qshifts);
+				qshifts = 0;
+
+				q[0] |= 1;
+			}
+
+			ushiftRight1(b);
+		}
+
+		shiftLeft(q, qshifts);
+	}
+
+	// r = a Mod b, unsigned
+	BIGONETYPE void umodulo(T &a, T &b0, T &r)
+	{
+		T b;
+		u32 shifts = 1;
+
+		set(b, b0);
+		set(r, a);
+
+		if (!BIGHIGHBIT(b) && ugreater(r, b))
+		{
+			s32 ii, jj;
+
+			// shift by words if possible
+			for (ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+				if (r[ii]) break;
+			for (jj = ii; jj >= 0; --jj)
+				if (b[jj]) break;
+
+			if (ii != jj)
+			{
+				shifts = (ii - jj) * WORDBITS;
+				shiftLeft(b, shifts);
+				++shifts;
+			}
+
+			while (!BIGHIGHBIT(b) && ugreater(r, b))
+			{
+				shiftLeft1(b);
+
+				++shifts;
+			}
+
+			while (ugreater(b, r))
+			{
+				ushiftRight1(b);
+
+				--shifts;
+			}
+		}
+		else if (ugreater(b, r))
+		{
+			ushiftRight1(b);
+
+			--shifts;
+		}
+
+		while (shifts--)
+		{
+			if (!ugreater(b, r))
+				subtract(r, b);
+
+			ushiftRight1(b);
+		}
+	}
+
+	// {q, r} = a / b (&q != &r), signed
+	BIGONETYPE void sdivide(T &a, T &b0, T &q, T &r)
+	{
+		T b;
+
+		set(b, b0);
+		set(r, a);
+		zero(q);
+
+		word sign_a = BIGHIGHBIT(a);
+		if (sign_a) negate(r);
+
+		word sign_b = BIGHIGHBIT(b);
+		if (sign_b) negate(b);
+
+		u32 shifts = 1;
+
+		if (!BIGHIGHBIT(b) && ugreater(r, b))
+		{
+			s32 ii, jj;
+
+			// shift by words if possible
+			for (ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+				if (r[ii]) break;
+			for (jj = ii; jj >= 0; --jj)
+				if (b[jj]) break;
+
+			if (ii != jj)
+			{
+				shifts = (ii - jj) * WORDBITS;
+				shiftLeft(b, shifts);
+				++shifts;
+			}
+
+			while (!BIGHIGHBIT(b) && ugreater(r, b))
+			{
+				shiftLeft1(b);
+
+				++shifts;
+			}
+
+			while (ugreater(b, r))
+			{
+				ushiftRight1(b);
+
+				--shifts;
+			}
+		}
+		else if (ugreater(b, r))
+		{
+			ushiftRight1(b);
+
+			--shifts;
+		}
+
+		u32 qshifts = 0;
+
+		while (shifts--)
+		{
+			++qshifts;
+
+			if (!ugreater(b, r))
+			{
+				subtract(r, b);
+
+				shiftLeft(q, qshifts);
+				qshifts = 0;
+
+				q[0] |= 1;
+			}
+
+			ushiftRight1(b);
+		}
+
+		shiftLeft(q, qshifts);
+
+		if (sign_a ^ sign_b) negate(q);
+
+		if (sign_a) negate(r);
+	}
+
+	// r = a Mod b, signed
+	BIGONETYPE void smodulo(T &a, T &b0, T &r)
+	{
+		T b;
+		u32 shifts = 1;
+
+		set(b, b0);
+		set(r, a);
+
+		word sign_a = BIGHIGHBIT(a);
+		if (sign_a) negate(r);
+
+		word sign_b = BIGHIGHBIT(b);
+		if (sign_b) negate(b);
+
+		if (!BIGHIGHBIT(b) && ugreater(r, b))
+		{
+			s32 ii, jj;
+
+			// shift by words if possible
+			for (ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+				if (r[ii]) break;
+			for (jj = ii; jj >= 0; --jj)
+				if (b[jj]) break;
+
+			if (ii != jj)
+			{
+				shifts = (ii - jj) * WORDBITS;
+				shiftLeft(b, shifts);
+				++shifts;
+			}
+
+			while (!BIGHIGHBIT(b) && ugreater(r, b))
+			{
+				shiftLeft1(b);
+
+				++shifts;
+			}
+
+			while (ugreater(b, r))
+			{
+				ushiftRight1(b);
+
+				--shifts;
+			}
+		}
+		else if (ugreater(b, r))
+		{
+			ushiftRight1(b);
+
+			--shifts;
+		}
+
+		while (shifts--)
+		{
+			if (!ugreater(b, r))
+				subtract(r, b);
+
+			ushiftRight1(b);
+		}
+
+		if (sign_a) negate(r);
+	}
+
+
+	//////// converting to/from strings ////////
+
+#ifdef BIG_USES_STRINGS
+
+	// n -> string
+	BIGONETYPE std::string toString(T &n0, bool sign = true, u16 radix = 10)
+	{
+		T n, base, r;
+		std::string s;
+
+		set(n, n0);
+		usetw(base, radix);
+
+		word sign_n = 0;
+		if (sign && (sign_n = BIGHIGHBIT(n)))
+			negate(n);
+
+		do // always allow first iteration for zero
+		{
+			// {q, r} = n / base
+			udivide(n, base, n, r);
+
+			char ch = (char)r[0];
+
+			if (ch >= 10)
+				ch += 'a' - 10;
+			else
+				ch += '0';
+
+			// insert character
+			s = ch + s;
+		} while (!isZero(n));
+
+		if (sign_n) s = '-' + s;
+
+		return s;
+	}
+
+	// s -> n, signed
+	BIGONETYPE void fromString(std::string s, T &n, bool sign = true, u16 radix = 10)
+	{
+		T acc, base, temp;
+
+		usetw(acc, 1);
+		usetw(base, radix);
+		zero(n);
+
+		u32 len = (u32)s.length();
+		const char *citer = s.c_str() + len;
+
+		while (len--)
+		{
+			char ch = *(--citer);
+
+			if (IS_ALPHA(ch)) // assumes alpha characters only up to radix
+				ch = TO_LOWER(ch) - 'a' + 10;
+			else if (sign && ch == '-') // '-' should be first character
+			{
+				negate(n);
+				break;
+			}
+			else // assumes it's alphanumeric/-
+				ch -= '0';
+
+			usetw(temp, ch);
+
+			umultiply(temp, acc);
+
+			add(n, temp);
+
+			umultiply(acc, base);
+		}
+	}
+
+#endif // BIG_USES_STRINGS
+
+
+	//////// class wrapper ////////
+
+	BIGONETYPE INLINE Int<T>::Int()
+	{
+		big::zero(raw);
+	}
+
+	BIGONETYPE INLINE Int<T>::Int(word n)
+	{
+		ssetw(raw, n);
+	}
+
+#ifdef BIG_USES_STRINGS
+
+	BIGONETYPE INLINE Int<T>::Int(std::string &s)
+	{
+		fromString(s, raw);
+	}
+
+#endif
+
+	BIGONETYPE INLINE Int<T>::Int(T &n)
+	{
+		set(raw, n);
+	}
+
+	BIGONETYPE INLINE Int<T>::operator T &()
+	{
+		return raw;
+	}
+
+
+	BIGONETYPE BIGINTFAST Int<T>::zero()
+	{
+		big::zero(raw);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::operator=(word n)
+	{
+		ssetw(raw, n);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::operator=(T &n)
+	{
+		set(raw, n);
+		return *this;
+	}
+
+
+	BIGONETYPE BIGINTFAST Int<T>::operator<<=(u32 s)
+	{
+		shiftLeft(raw, s);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator<<(u32 s)
+	{
+		Int<T> temp(raw);
+		return temp <<= s;
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::operator>>=(u32 s)
+	{
+		shiftRight(raw, s);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator>>(u32 s)
+	{
+		Int<T> temp(raw);
+		return temp >>= s;
+	}
+
+
+	BIGONETYPE BIGINTFAST Int<T>::operator+=(T &n)
+	{
+		add(raw, n);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator+(T &n)
+	{
+		Int<T> temp(raw);
+		return temp += n;
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::operator-=(T &n)
+	{
+		subtract(raw, n);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator-(T &n)
+	{
+		Int<T> temp(raw);
+		return temp -= n;
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::operator++() // prefix
+	{
+		increment(raw);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator++(int) // postfix
+	{
+		Int<T> temp(raw);
+		increment(raw);
+		return temp;
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::operator--() // prefix
+	{
+		decrement(raw);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator--(int) // postfix
+	{
+		Int<T> temp(raw);
+		decrement(raw);
+		return temp;
+	}
+
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator-(int) // negation
+	{
+		Int<T> temp(raw);
+		negate(temp);
+		return temp;
+	}
+
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator*(T &n)
+	{
+		Int<T> temp(raw);
+		return temp *= n;
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::square()
+	{
+		square(raw);
+		return *this;
+	}
+
+
+	BIGONETYPE BIGINTFAST Int<T>::operator/=(T &n)
+	{
+		T discard;
+		divide(raw, n, raw, discard);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator/(T &n)
+	{
+		Int<T> temp(raw);
+		return temp /= n;
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::operator%=(T &n)
+	{
+		modulus(raw, n, raw);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator%(T &n)
+	{
+		Int<T> temp(raw);
+		return temp %= n;
+	}
+
+
+	BIGONETYPE INLINE /* fast */ bool Int<T>::operator>(T &n)
+	{
+		return sgreater(raw, n);
+	}
+
+	BIGONETYPE INLINE /* fast */ bool Int<T>::operator>=(T &n)
+	{
+		return sgreaterOrEqual(raw, n);
+	}
+
+	BIGONETYPE INLINE /* fast */ bool Int<T>::operator<(T &n)
+	{
+		return !sgreaterOrEqual(raw, n);
+	}
+
+	BIGONETYPE INLINE /* fast */ bool Int<T>::operator<=(T &n)
+	{
+		return !sgreater(raw, n);
+	}
+
+	BIGONETYPE INLINE /* fast */ bool Int<T>::operator==(T &n)
+	{
+		return equal(raw, n);
+	}
+
+	BIGONETYPE INLINE /* fast */ bool Int<T>::operator!=(T &n)
+	{
+		return !equal(raw, n);
+	}
+
+	BIGONETYPE INLINE /* fast */ bool Int<T>::operator!()
+	{
+		return isZero(raw);
+	}
+
+#ifdef BIG_USES_STRINGS
+
+	BIGONETYPE INLINE /* fast */ std::string Int<T>::str()
+	{
+		return toString(raw);
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::operator=(std::string &s)
+	{
+		fromString(s, raw);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::operator=(const char *s)
+	{
+		fromString(std::string(s), raw);
+		return *this;
+	}
+
+#endif // BIG_USES_STRINGS
+}
+
+#endif // BIGTYPES_H
+
+
+

Modified: branches/multiplayer-branch/source/libraries/raknet/BinarySearchTree.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/BinarySearchTree.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/BinarySearchTree.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -52,6 +52,8 @@
 The assignment operator is defined between BinarySearchTree and AVLBalancedBinarySearchTree as long as they are of the same template type. However, passing a BinarySearchTree to an AVLBalancedBinarySearchTree will lose its structure unless it happened to be AVL balanced to begin with
 Requires queue_linked_list.cpp for the breadth first search used in the copy constructor, overloaded assignment operator, and display_breadth_first_search.
 
+9/04 Giblet - updated code to work with new compilers adhering more closely to ISO standard
+
 */
 
 #ifndef __BINARY_SEARCH_TREE_H
@@ -156,7 +158,7 @@
 				break;
 		}
 
-		if (current==root)
+		if (current==this->root)
 			break;
 
 		current=find_parent(*(current->item));
@@ -234,11 +236,11 @@
 	if (A)
 	{
 		// Direction was set by the last find_parent call
-		if (direction==LEFT) A->left=C;
+		if (this->direction==this->LEFT) A->left=C;
 			else A->right=C;
 	}
 	else
-		root=C;  // If B has no parent parent then B must have been the root node
+		this->root=C;  // If B has no parent parent then B must have been the root node
 
 	B->left = D;
 	C->right = B;
@@ -293,11 +295,11 @@
 	if (A)
 	{
 		// Direction was set by the last find_parent call
-		if (direction==LEFT) A->left=C;
+		if (this->direction==this->LEFT) A->left=C;
 			else A->right=C;
 	}
 	else
-		root=C;  // If B has no parent parent then B must have been the root node
+		this->root=C;  // If B has no parent parent then B must have been the root node
 
 	B->right = D;
 	C->left = B;
@@ -314,7 +316,7 @@
 template <class BinarySearchTreeType>
 AVLBalancedBinarySearchTree<BinarySearchTreeType>::~AVLBalancedBinarySearchTree()
 {
-	clear();
+	this->clear();
 }
 
 template <class BinarySearchTreeType>
@@ -358,7 +360,7 @@
 template <class BinarySearchTreeType>
 BinarySearchTree<BinarySearchTreeType>::~BinarySearchTree()
 {
-	clear();
+	this->clear();
 }
 
 template <class BinarySearchTreeType>
@@ -367,7 +369,7 @@
 	static typename BinarySearchTree::node* tempnode;
 	static BinarySearchTreeType* dummyptr=0;
 	tempnode = find (element, &tempnode);
-	if (direction==NOT_FOUND)
+	if (this->direction==this->NOT_FOUND)
 		return dummyptr;
 
 	return tempnode->item;
@@ -378,24 +380,24 @@
 {
 	static typename BinarySearchTree::node* current;
 
-	current=root;
+	current=this->root;
 	*parent=0;
-	direction=ROOT;
+	this->direction=this->ROOT;
 
 	if (BinarySearchTree_size==0L) 
 	{
-		direction=NOT_FOUND;
+		this->direction=this->NOT_FOUND;
 		return current=0;
 	}
 
 	// Check if the item is at the root
-	if (element == *(current->item)) {direction=ROOT; return current;}
+	if (element == *(current->item)) {this->direction=this->ROOT; return current;}
 
 	while (true)
 	{	
 		// Move pointer
-		if (element < *(current->item)) {*parent=current; direction=LEFT; current=current->left;}
-		else if (element > *(current->item)) {*parent=current; direction=RIGHT; current=current->right;}
+		if (element < *(current->item)) {*parent=current; this->direction=this->LEFT; current=current->left;}
+		else if (element > *(current->item)) {*parent=current; this->direction=this->RIGHT; current=current->right;}
 		
 		if (current==0) break;
 
@@ -404,7 +406,7 @@
 	}
 	
 
-	direction=NOT_FOUND;
+	this->direction=this->NOT_FOUND;
 	return current=0;
 }
 

Modified: branches/multiplayer-branch/source/libraries/raknet/BitStream.cpp
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/BitStream.cpp	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/BitStream.cpp	2004-10-08 21:41:59 UTC (rev 76)
@@ -26,6 +26,8 @@
 #include <stdio.h>
 #include <string.h>
 
+using namespace RakNet;
+
 BitStream::BitStream()
 {
 	numberOfBitsUsed=0;
@@ -35,7 +37,7 @@
 #ifdef _DEBUG
 	assert(data);
 #endif
-	memset(data, 0, 32);
+	//memset(data, 0, 32);
 	copyData=true;
 }
 
@@ -48,7 +50,7 @@
 	#ifdef _DEBUG
 	assert(data);
 	#endif
-	memset(data, 0, initialBytesToAllocate);
+//	memset(data, 0, initialBytesToAllocate);
 	copyData=true;
 }
 
@@ -92,14 +94,18 @@
 
 void BitStream::Reset(void)
 {
+	if (numberOfBitsUsed>0)
+	{
+//		memset(data, 0, BITS_TO_BYTES(numberOfBitsUsed));
+	}
 	// Don't free memory here for speed efficiency
 	//free(data);  // Use realloc and free so we are more efficient than delete and new for resizing
 	numberOfBitsUsed=0;
 	//numberOfBitsAllocated=8;
 	readOffset=0;
 	//data=(unsigned char*)malloc(1);
-	if (numberOfBitsAllocated>0)
-		memset(data, 0, BITS_TO_BYTES(numberOfBitsAllocated));
+//	if (numberOfBitsAllocated>0)
+//		memset(data, 0, BITS_TO_BYTES(numberOfBitsAllocated));
 }
 
 // Write the native types to the end of the buffer
@@ -598,8 +604,11 @@
 {
 	AddBitsAndReallocate(1);
 
-	// New bits are set to 0 as default
-	numberOfBitsUsed++;
+	// New bytes need to be zeroed
+	if ((numberOfBitsUsed%8)==0)
+		data[numberOfBitsUsed>>3] = 0;
+
+	numberOfBitsUsed++; // This ++ was in the line above - but boundschecker didn't like that for some reason.
 }
 
  // Write a 1
@@ -607,7 +616,12 @@
 {
 	AddBitsAndReallocate(1);
 
-	data[numberOfBitsUsed>>3] |= 0x80 >> (numberOfBitsUsed%8); // Set the bit to 1
+	int numberOfBitsMod8 = numberOfBitsUsed%8;
+	if (numberOfBitsMod8==0)
+		data[numberOfBitsUsed>>3] = 0x80;
+	else
+		data[numberOfBitsUsed>>3] |= 0x80 >> (numberOfBitsMod8); // Set the bit to 1
+	
 	numberOfBitsUsed++; // This ++ was in the line above - but boundschecker didn't like that for some reason.
 }
 
@@ -681,8 +695,8 @@
 // Write numberToWrite bits from the input source
 void BitStream::WriteBits(unsigned char *input, int numberOfBitsToWrite, bool rightAlignedBits)
 {
-	if (numberOfBitsToWrite<=0)
-		return;
+//	if (numberOfBitsToWrite<=0)
+//		return;
 
 	AddBitsAndReallocate(numberOfBitsToWrite);
 	int offset=0;
@@ -691,19 +705,31 @@
 
 	numberOfBitsUsedMod8=numberOfBitsUsed%8;
 
-	do
+	// Faster to put the while at the top surprisingly enough
+	while(numberOfBitsToWrite>0)
+	//do
 	{
 		dataByte = *(input+offset);
 		if (numberOfBitsToWrite<8 && rightAlignedBits) // rightAlignedBits means in the case of a partial byte, the bits are aligned from the right (bit 0) rather than the left (as in the normal internal representation)
 			dataByte<<=8-numberOfBitsToWrite;	 // shift left to get the bits on the left, as in our internal representation
 
-		// Copy over the new data.
-		*(data+(numberOfBitsUsed>>3)) |= dataByte >> (numberOfBitsUsedMod8); // First half
-		if (8 - (numberOfBitsUsedMod8) < 8 && 8 - (numberOfBitsUsedMod8) < numberOfBitsToWrite) // If we didn't write it all out in the first half (8 - (numberOfBitsUsed%8) is the number we wrote in the first half)
-			*(data+(numberOfBitsUsed>>3) + 1) |= (unsigned char)(dataByte << (8 - (numberOfBitsUsedMod8))); // Second half (overlaps byte boundary)
-	
+		// Writing to a new byte each time
+		if (numberOfBitsUsedMod8==0)
+			*(data+(numberOfBitsUsed>>3)) = dataByte;
+		else
+		{
+			// Copy over the new data.
+			*(data+(numberOfBitsUsed>>3)) |= dataByte >> (numberOfBitsUsedMod8); // First half
+			if (8 - (numberOfBitsUsedMod8) < 8 && 8 - (numberOfBitsUsedMod8) < numberOfBitsToWrite) // If we didn't write it all out in the first half (8 - (numberOfBitsUsed%8) is the number we wrote in the first half)
+			{
+				*(data+(numberOfBitsUsed>>3) + 1) = (unsigned char)(dataByte << (8 - (numberOfBitsUsedMod8))); // Second half (overlaps byte boundary)
+			}
+		}
+
 		if (numberOfBitsToWrite>=8)
+		{
 			numberOfBitsUsed+= 8;
+		}
 		else
 		{
 			numberOfBitsUsed+= numberOfBitsToWrite;
@@ -711,8 +737,8 @@
 		numberOfBitsToWrite-= 8;
 		
 		offset++;
-	} while(numberOfBitsToWrite>0);
-
+	}
+//	} while(numberOfBitsToWrite>0);
 }
 
 // Set the stream to some initial data.  For internal use
@@ -760,7 +786,7 @@
 			Write(b);
 
 			WriteBits(input,(currentByte+1)<<3, true);
-			currentByte--;
+	//		currentByte--;
 
 	
 			return;
@@ -793,8 +819,8 @@
 	#ifdef _DEBUG
 	assert(numberOfBitsToRead>0);
 	#endif
-	if (numberOfBitsToRead<=0)
-		return false;
+//	if (numberOfBitsToRead<=0)
+//		return false;
 
 	if (readOffset+numberOfBitsToRead >numberOfBitsUsed)
 		return false;
@@ -806,7 +832,9 @@
 
 	readOffsetMod8=readOffset%8;
 
-	do
+//	do
+	// Faster to put the while at the top surprisingly enough
+	while(numberOfBitsToRead>0)
 	{
 			*(output + offset) |= *(data+(readOffset>>3)) << (readOffsetMod8); // First half
 
@@ -825,7 +853,8 @@
 
 			offset++;
 
-	} while(numberOfBitsToRead>0);
+	}
+	//} while(numberOfBitsToRead>0);
 
 	return true;
 }
@@ -920,7 +949,7 @@
 		#ifdef _DEBUG
 		assert(data); // Make sure realloc succeeded
 		#endif
-		memset(data+newByteOffset, 0,  ((newNumberOfBitsAllocated-1)>>3) - ((numberOfBitsAllocated-1)>>3)); // Set the new data block to 0
+//		memset(data+newByteOffset, 0,  ((newNumberOfBitsAllocated-1)>>3) - ((numberOfBitsAllocated-1)>>3)); // Set the new data block to 0
 	}
 
 	if (newNumberOfBitsAllocated > numberOfBitsAllocated)

Modified: branches/multiplayer-branch/source/libraries/raknet/BitStream.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/BitStream.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/BitStream.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -10,6 +10,9 @@
 #ifndef  __BITSTREAM_H
 #define __BITSTREAM_H
 
+namespace RakNet
+{
+
 #define BITS_TO_BYTES(x) (((x)+7)>>3)
 
 class BitStream
@@ -168,4 +171,6 @@
 	bool copyData;
 };
 
+}
+
 #endif

Modified: branches/multiplayer-branch/source/libraries/raknet/ClientContextStruct.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/ClientContextStruct.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/ClientContextStruct.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -30,7 +30,8 @@
 	OVERLAPPED overlapped;
 	char data[MAXIMUM_MTU_SIZE]; // Used to hold data to send
 	int length; // Length of the actual data to send, always under MAXIMUM_MTU_SIZE
-	PlayerID playerId;
+	unsigned long binaryAddress;
+	unsigned short port;
 	RakPeer *rakPeer;
 	bool read; // Set to true for reads, false for writes
 };

Modified: branches/multiplayer-branch/source/libraries/raknet/DataBlockEncryptor.cpp
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/DataBlockEncryptor.cpp	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/DataBlockEncryptor.cpp	2004-10-08 21:41:59 UTC (rev 76)
@@ -9,6 +9,9 @@
 {
 	keySet=false;
 }
+DataBlockEncryptor::~DataBlockEncryptor()
+{
+}
 bool DataBlockEncryptor::IsKeySet(void) const
 {
 	return keySet;
@@ -40,21 +43,22 @@
 
 	assert(input && inputLength);
 
+
 	// randomChar will randomize the data so the same data sent twice will not look the same
 	randomChar=(unsigned char)randomMT();
 
-
 	// 16-(((x-1) % 16)+1) 
 
 	// # of padding bytes is 16 -(((input_length + extra_data -1) % 16)+1)
 	paddingBytes = (unsigned char)(16 -(((inputLength + sizeof(randomChar)+sizeof(checkSum)+sizeof(encodedPad) -1) % 16)+1));
-	*outputLength=inputLength + sizeof(randomChar)+sizeof(checkSum)+sizeof(encodedPad)+paddingBytes;
 
 	// Randomize the pad size variable
 	encodedPad=(unsigned char)randomMT();
 	encodedPad<<=4;
 	encodedPad|=paddingBytes;
 
+	*outputLength=inputLength + sizeof(randomChar)+sizeof(checkSum)+sizeof(encodedPad)+paddingBytes;
+
 	// Write the data first, in case we are overwriting ourselves
 	if (input==output)
 		memmove(output+sizeof(checkSum)+sizeof(randomChar)+sizeof(encodedPad)+paddingBytes, input, inputLength);
@@ -108,9 +112,6 @@
 	
 	if (input==0 || inputLength<16 || (inputLength % 16) != 0)
 	{
-#ifdef _DEBUG
-		assert(0);
-#endif
 		return false;
 	}
 
@@ -121,7 +122,7 @@
 
 		for (byteIndex=0; byteIndex<16; byteIndex++)
 		{
-			if (index+16==inputLength)
+			if (index+16==(unsigned)inputLength)
 				input[index+byteIndex]^=input[byteIndex];
 			else
 				input[index+byteIndex]^=input[index+16+byteIndex];
@@ -142,10 +143,11 @@
 	// Ignore the high 4 bytes
 	paddingBytes=encodedPad&0x0F;
 
+
 	// Get the data length
 	*outputLength=inputLength - sizeof(randomChar)-sizeof(checkSum)-sizeof(encodedPad)-paddingBytes;
 
-	// Calculate the checksum on the data
+	// Calculate the checksum on the data.
 	checkSumCalculator.add(input+sizeof(checkSum), *outputLength+sizeof(randomChar)+sizeof(encodedPad)+paddingBytes);
 	if (checkSum != checkSumCalculator.get())
 		return false;
@@ -156,5 +158,6 @@
 	else
 		memcpy(output, input+sizeof(randomChar)+sizeof(checkSum)+sizeof(encodedPad)+paddingBytes, *outputLength);
 
+
 	return true;
 }

Modified: branches/multiplayer-branch/source/libraries/raknet/DataBlockEncryptor.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/DataBlockEncryptor.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/DataBlockEncryptor.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -7,6 +7,7 @@
 {
 public:
 	DataBlockEncryptor();
+	~DataBlockEncryptor();
 	bool IsKeySet(void) const;
 
 	void SetKey(const unsigned char key[16]);

Modified: branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObject.cpp
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObject.cpp	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObject.cpp	2004-10-08 21:41:59 UTC (rev 76)
@@ -17,6 +17,7 @@
 #include <string.h>
 #include "DistributedNetworkObjectManager.h"
 
+
 DistributedNetworkObject::DistributedNetworkObject()
 {
 	maximumUpdateFrequency=50; // 50 ms by default
@@ -35,8 +36,8 @@
 	if (DistributedNetworkObjectManager::Instance()->GetRakServerInterface())
 	{
 		// These 3 lines of code will broadcast to destroy the object
-		BitStream bitStream;
-		SerializeClassHeader(&bitStream, 0, false, false, 0);
+		RakNet::BitStream bitStream;
+		SerializeClassHeader(&bitStream, 0, 0, false, 0);
 		BroadcastSerializedClass(&bitStream);
 	}
 
@@ -55,8 +56,8 @@
 void DistributedNetworkObject::DestroyObjectOnNetwork(void)
 {
 	// These 3 lines of code will broadcast to destroy the object
-	BitStream bitStream;
-	SerializeClassHeader(&bitStream, 0, false, false, 0);
+	RakNet::BitStream bitStream;
+	SerializeClassHeader(&bitStream, 0, 0, false, 0);
 	BroadcastSerializedClass(&bitStream);
 
 	DistributedNetworkObjectManager::Instance()->UnregisterNetworkObject(this);
@@ -68,7 +69,7 @@
 	}
 }
 
-void DistributedNetworkObject::SynchronizeMemory(unsigned char memoryBlockIndex, char* memoryBlock, int memoryBlockSize, bool serverAuthority)
+void DistributedNetworkObject::SynchronizeMemory(unsigned char memoryBlockIndex, char* memoryBlock, unsigned short memoryBlockSize, bool serverAuthority)
 {
 	// Was memory previously allocated?
 	if (heapNodeList[memoryBlockIndex].lastWriteValue)
@@ -96,7 +97,7 @@
 	heapNodeList[memoryBlockIndex].watchedData=memoryBlock;
 
 	// Initialize nextUpdateTime to the current time.
-	heapNodeList[memoryBlockIndex].nextUpdateTime=getTime();
+	heapNodeList[memoryBlockIndex].nextUpdateTime=RakNetGetTime();
 
 	// Set the authority
 	heapNodeList[memoryBlockIndex].serverAuthority=serverAuthority;
@@ -130,12 +131,12 @@
 }
 // Same as ProcessDistributedMemoryStack, but for the heapNodeList.
 // Returns true if data was written
-bool DistributedNetworkObject::WriteToBitstreamFromHeap(BitStream *bitStream, bool forceWrite)
+bool DistributedNetworkObject::WriteToBitstreamFromHeap(RakNet::BitStream *bitStream, bool forceWrite)
 {
     int heapNodeIndex;
 	unsigned long time;
-	BitStream heapData(256);
-	time=getTime();
+	RakNet::BitStream heapData(256);
+	time=RakNetGetTime();
 	unsigned char numberOfBlocksWritten;
 
 	numberOfBlocksWritten=0;
@@ -143,7 +144,7 @@
 	for (heapNodeIndex=0; heapNodeIndex < 256; heapNodeIndex++)
 	{
 		// Is this a block we are responsible for updating, and it is time to update?
-		if (IsMemoryBlockIndexUsed(heapNodeIndex) &&
+		if (IsMemoryBlockIndexUsed((unsigned char)heapNodeIndex) &&
 			forceWrite ||
 			(time >= heapNodeList[heapNodeIndex].nextUpdateTime &&
 			((DistributedNetworkObjectManager::Instance()->GetRakServerInterface() && heapNodeList[heapNodeIndex].serverAuthority) ||
@@ -172,24 +173,35 @@
 
 	if (numberOfBlocksWritten>0)
 	{
+		bitStream->Write(true);
 		bitStream->WriteCompressed(numberOfBlocksWritten);
 		bitStream->Write((char*)heapData.GetData(), heapData.GetNumberOfBytesUsed());
 		return true;
 	}
+	else
+		bitStream->Write(false);
 
+	if (forceWrite)
+		WriteCreationData(bitStream);
+
 	return false;
 }
 
-void DistributedNetworkObject::WriteToHeapFromBitstream(BitStream *bitStream)
+void DistributedNetworkObject::WriteToHeapFromBitstream(RakNet::BitStream *bitStream)
 {
 	int index;
 	unsigned char heapNodeIndex;
 	unsigned char numberOfBlocksWritten;
+	bool anyDataWritten;
 
 #ifdef _DEBUG
 	unsigned short usedBlockSize;
 #endif
 
+	bitStream->Read(anyDataWritten);
+	if (anyDataWritten==false)
+		return;
+
 	bitStream->ReadCompressed(numberOfBlocksWritten);
 
 	for (index=0; index < numberOfBlocksWritten; index++)
@@ -230,7 +242,7 @@
 }
 
 // Writes to or reads from a bitstream for all distributed memory.  This function does not need to be modified by the end-user
-bool DistributedNetworkObject::ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)
+bool DistributedNetworkObject::ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)
 {
 	return false;
 }
@@ -256,7 +268,7 @@
 	 (DistributedNetworkObjectManager::Instance()->GetRakClientInterface() && DistributedNetworkObjectManager::Instance()->GetRakClientInterface()->IsConnected()))
 	{
 		char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH];
-		BitStream bitStream;
+		RakNet::BitStream bitStream;
 
 		if (isClassIDEncoded)
 			memcpy(classIdentifier, classID, MAXIMUM_CLASS_IDENTIFIER_LENGTH);
@@ -267,24 +279,34 @@
 		// The only purpose of registering and unregistering network objects is so we can call SendAllDistributedObjects from
 		// DistributedNetworkObjectManager to new players
 		firstTimeAddedToRegistry = DistributedNetworkObjectManager::Instance()->RegisterNetworkObject(this,classIdentifier, localObjectIdentifier);
+		if (serverProcess && firstTimeAddedToRegistry && isClassIDEncoded==false)
+		{
+			// This is like a local echo - call OnDistributedObjectCreation for the server when it is not
+			// created by the network
+			if (OnDistributedObjectCreation(UNASSIGNED_PLAYER_ID)==false)
+			{
+				DistributedNetworkObjectManager::Instance()->UnregisterNetworkObject(this);
+				return;
+			}
+		}
 
 		// This logic is correct - ProcessDistributedMemoryStack has a side effect of updating network memory to the last send so you don't
 		// want to call it unnecessarily
 		if (firstTimeAddedToRegistry && (localObject || DistributedNetworkObjectManager::Instance()->GetRakServerInterface()))
 		{
-			SerializeClassHeader(&bitStream, classIdentifier, true, firstTimeAddedToRegistry && DistributedNetworkObjectManager::Instance()->GetRakClientInterface(), localObjectIdentifier);
+			SerializeClassHeader(&bitStream, classIdentifier, 2, firstTimeAddedToRegistry && DistributedNetworkObjectManager::Instance()->GetRakClientInterface(), localObjectIdentifier);
 			ProcessDistributedMemoryStack(&bitStream, true, true,serverProcess);
-			WriteToBitstreamFromHeap(&bitStream, true);
+			WriteToBitstreamFromHeap(&bitStream, true);	
 			BroadcastSerializedClass(&bitStream);
 		}
 		else if ((localObject == false || DistributedNetworkObjectManager::Instance()->GetRakServerInterface()) &&
-			getTime() > lastBroadcastTime + maximumUpdateFrequency)
+			RakNetGetTime() > lastBroadcastTime + maximumUpdateFrequency)
 		{
-			SerializeClassHeader(&bitStream, classIdentifier, true, firstTimeAddedToRegistry && DistributedNetworkObjectManager::Instance()->GetRakClientInterface(), localObjectIdentifier);
+			SerializeClassHeader(&bitStream, classIdentifier, 1, firstTimeAddedToRegistry && DistributedNetworkObjectManager::Instance()->GetRakClientInterface(), localObjectIdentifier);
 			dataWritten1=ProcessDistributedMemoryStack(&bitStream, true, false,serverProcess);
 			dataWritten2=WriteToBitstreamFromHeap(&bitStream, false);
 			if (dataWritten1 || dataWritten2)
-			{					
+			{
 				BroadcastSerializedClass(&bitStream);
 			}
 		}
@@ -293,12 +315,20 @@
 	InterpolateDistributedMemory(serverProcess);
 }
 
+void DistributedNetworkObject::WriteCreationData(RakNet::BitStream *initialData)
+{
+}
+
+void DistributedNetworkObject::ReadCreationData(RakNet::BitStream *initialData)
+{
+}
+
 void DistributedNetworkObject::SetMaximumUpdateFrequency(unsigned long frequency)
 {
 	maximumUpdateFrequency=frequency;
 }
 
-void DistributedNetworkObject::BroadcastSerializedClass(BitStream *bitStream)
+void DistributedNetworkObject::BroadcastSerializedClass(RakNet::BitStream *bitStream)
 {
 	if (DistributedNetworkObjectManager::Instance()->GetRakServerInterface() && DistributedNetworkObjectManager::Instance()->GetRakServerInterface()->IsActive())
 	{
@@ -310,28 +340,28 @@
 		}
 
 		DistributedNetworkObjectManager::Instance()->GetRakServerInterface()->Send(bitStream, HIGH_PRIORITY, RELIABLE_ORDERED, 0, localClient, true);
-		lastBroadcastTime=getTime();
+		lastBroadcastTime=RakNetGetTime();
 	}
 	else if (DistributedNetworkObjectManager::Instance()->GetRakClientInterface() && DistributedNetworkObjectManager::Instance()->GetRakClientInterface()->IsConnected())
 	{
 		// This sends a request to create or update the object
 		DistributedNetworkObjectManager::Instance()->GetRakClientInterface()->Send(bitStream, HIGH_PRIORITY, RELIABLE_ORDERED, 0);
-		lastBroadcastTime=getTime();
+		lastBroadcastTime=RakNetGetTime();
 	}
 }
 
-void DistributedNetworkObject::SerializeClassHeader(BitStream *bitStream, char *classIdentifier, bool construction, bool localObject, unsigned char localObjectIndex)
+void DistributedNetworkObject::SerializeClassHeader(RakNet::BitStream *bitStream, char *classIdentifier, int action, bool localObject, unsigned char localObjectIndex)
 {
 	static const unsigned char packetId = ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT;
 
 	bitStream->Write(packetId);
 
 	// Construction to true means we are creating or updating this object.  Otherwise it means we are destroying this object.
-	bitStream->Write(construction);
+	bitStream->WriteBits((unsigned char*)&action, 2);
 
 	bitStream->Write(GetID());
 
-	if (construction)
+	if (action==2)
 	{
 		bitStream->Write(classIdentifier, classIdentifier[0]+1);
 	}
@@ -339,23 +369,39 @@
 	bitStream->Write(localObject);
 	if (localObject)
 		bitStream->Write(localObjectIndex);
+
+	if (action==2)
+	{
+		if (clientOwnerID==UNASSIGNED_PLAYER_ID)
+		{
+			bitStream->Write(false);
+		}
+		else
+		{
+			bitStream->Write(true);
+			bitStream->Write((char*)&clientOwnerID, sizeof(PlayerID));
+		}
+	}
+
 }
 
-bool DistributedNetworkObject::DeserializeClassHeader(BitStream *bitStream, bool &construction, ObjectID &objectId, char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH], bool &localObject, unsigned char &localObjectIndex)
+bool DistributedNetworkObject::DeserializeClassHeader(RakNet::BitStream *bitStream, int &action, ObjectID &objectId, char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH], bool &localObject, unsigned char &localObjectIndex, PlayerID &pid)
 {
 	unsigned char packetId;
+	bool hasClientOwnerID;
 	if (bitStream->Read(packetId)==false)
 		return false;
 
 	assert(packetId==ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT);
 
-	if (bitStream->Read(construction)==false)
+	action=0;
+	if (bitStream->ReadBits((unsigned char*)&action,2)==false)
 		return false;
 
 	if (bitStream->Read(objectId)==false)
 		return false;
 
-	if (construction)
+	if (action==2)
 	{
 		unsigned char classNameLength;
 		if (bitStream->Read(classNameLength)==false)
@@ -365,6 +411,8 @@
 
 		classIdentifier[0]=classNameLength;
 	}
+	else
+		classIdentifier=0;
 
 	bool isLocalObjectInpacket;
 	if (bitStream->Read(isLocalObjectInpacket)==false)
@@ -375,6 +423,19 @@
 			return false;
 	}
 
+	if (action==2)
+	{
+		if (bitStream->Read(hasClientOwnerID)==false)
+			return false;
+		if (hasClientOwnerID)
+		{
+			if (bitStream->Read((char*)&pid, sizeof(PlayerID))==false)
+				return false;
+		}
+		else
+			pid=UNASSIGNED_PLAYER_ID;
+	}	
+
 	return true;
 }
 
@@ -389,7 +450,6 @@
 
 bool DistributedNetworkObject::OnDistributedObjectCreation(PlayerID senderID)
 {
-	localObject=false;
 #ifdef _DEBUG
 	assert(GetID()!=UNASSIGNED_OBJECT_ID);
 #endif
@@ -430,3 +490,9 @@
 {
 	clientOwnerID=id;
 }
+
+void DistributedNetworkObject::SetLocalObject(bool b)
+{
+	localObject=b;
+}
+

Modified: branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObject.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObject.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObject.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -7,13 +7,13 @@
 
 // Refer to the appropriate license agreement for distribution, modification, and warranty rights.
 
+#ifndef __DISTRIBUTED_NETWORK_OBJECT
+#define __DISTRIBUTED_NETWORK_OBJECT
+
 #include "NetworkObject.h"
 #include "EncodeClassName.h"
-class BitStream;
+#include "BitStream.h"
 
-#ifndef __DISTRIBUTED_NETWORK_OBJECT
-#define __DISTRIBUTED_NETWORK_OBJECT
-
 class DistributedNetworkObject : public NetworkObject
 {
 public:
@@ -33,7 +33,6 @@
 	// If you wish to block deletion, override OnDistributedObjectDestruction
 	virtual void DestroyObjectOnNetwork(void);
 
-
 	// Server only function -
 	// By default, when a client creates an object only it can update the client authoritative members
 	// Of the class it creates.  You can also set this manually with SetClientOwnerID
@@ -55,7 +54,7 @@
 	
 	// Tags memory to be synchronized.  You can set the server or the client as the authority for this block.
 	// Only the authority will write this memory to the network when it is changed.
-	void SynchronizeMemory(unsigned char memoryBlockIndex, char* memoryBlock, int memoryBlockSize, bool serverAuthority);
+	void SynchronizeMemory(unsigned char memoryBlockIndex, char* memoryBlock, unsigned short memoryBlockSize, bool serverAuthority);
 
 	// Untags memory that was formerly synchronized.
 	void DesynchronizeMemory(unsigned char memoryBlockIndex);
@@ -73,7 +72,19 @@
 	// --------------------------------------------------------------------------
 	// Events
 	// --------------------------------------------------------------------------
+	// When object creation data is needed, WriteCreationData is called.
+	// This function is for you to write any data that is needed to create or initialize the object
+	// On remote systems
+	virtual void WriteCreationData(RakNet::BitStream *initialData);
 
+	// When an object is created, ReadCreationData is called immediately after a 
+	// successful call to OnDistributedObjectCreation
+	// This function is for you to read any data written from WriteCreationData
+	// on remote systems.  If the object is created by the client, this function is
+	// also called by the creator of the object when sent back from the server in case the
+	// server overrode any settings
+	virtual void ReadCreationData(RakNet::BitStream *initialData);
+
 	// When distributed data changes for an object, this function gets called.  Default behavior is to do nothing.
 	// Override it if you want to perform updates when data is changed
 	// On the server it is also important to override this to make sure the data the client just sent you is reasonable.
@@ -101,34 +112,37 @@
 
 	// You don't need to modify this
 	// Sends the bitstream to other systems
-	virtual void BroadcastSerializedClass(BitStream *bitStream);
+	virtual void BroadcastSerializedClass(RakNet::BitStream *bitStream);
 
 	// You don't need to modify this
 	// Writes the header identifying the class, objectID, and whether the object is being created or destroyed
-	virtual void SerializeClassHeader(BitStream *bitStream, char *classIdentifier, bool construction, bool localObject, unsigned char localObjectIndex);
-	static bool DeserializeClassHeader(BitStream *bitStream, bool &construction, ObjectID &objectId,char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH], bool &localObject, unsigned char &localObjectIndex);
+	// action of 0 means destruction, 1 means update, 2 means create
+	virtual void SerializeClassHeader(RakNet::BitStream *bitStream, char *classIdentifier, int action, bool localObject, unsigned char localObjectIndex);
+	static bool DeserializeClassHeader(RakNet::BitStream *bitStream, int &action, ObjectID &objectId,char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH], bool &localObject, unsigned char &localObjectIndex, PlayerID &pid);
 
 	// You don't need to modify this
 	// Returns true if this object was locally created, as opposed to created by the network
 	bool IsLocalObject(void) const;
+	void SetLocalObject(bool b);
 
 	// Writes to or reads from a bitstream for all distributed memory on the stack.  This function does not need to be modified by the end-user
 	// Returns true if any data was written
-	virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative);
+	virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative);
 
 	// Same as ProcessDistributedMemoryStack with isWrite to false, but for the heapNodeList.
 	// Returns true if data was written
-	bool WriteToBitstreamFromHeap(BitStream *bitStream, bool forceWrite);
+	bool WriteToBitstreamFromHeap(RakNet::BitStream *bitStream, bool forceWrite);
 
 	// Same as ProcessDistributedMemoryStack with isWrite to true, but for the heapNodeList.
-	void WriteToHeapFromBitstream(BitStream *bitStream);
+	void WriteToHeapFromBitstream(RakNet::BitStream *bitStream);
 
 	// You don't need to modify this
 	// Returns the identifier for an object that has not yet had SetID called on it
 	unsigned char GetLocalObjectIdentifier(void) const;
 
-	// Server only - select which client can update the client authoritative members of this object.
-	// UNASSIGNED_PLAYER_ID no client owns the object, so any client can update the object.
+	// This is set to who created this object.
+	// On the server, this also determines who can update the client authoritative members of this object.
+	// You can manually set it to UNASSIGNED_PLAYER_ID so no client owns the object, so any client can update the object.
 	PlayerID GetClientOwnerID(void) const;
 	void SetClientOwnerID(PlayerID id);
 

Modified: branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObjectHeader.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObjectHeader.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObjectHeader.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -49,7 +49,7 @@
 	BaseClass::DistributedMemoryInit(isServerAuthoritative);	\
 	SynchronizationMethod1##_INTERPOLATION_MEMORY_INIT(VariableName1)	\
 }	\
-virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -70,7 +70,7 @@
 \
 virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	if (distributedMemoryInitialized==false)	\
 		DistributedMemoryInit(isServerAuthoritative);	\
 	SynchronizationMethod1##_INTERPOLATION_CODE(AuthoritativeNetwork1, VariableName1)	\
@@ -132,7 +132,7 @@
 	DOM_CORE_EXPANDED(AuthoritativeNetwork,VariableType,VariableName, ReadCode, ReadDummyCode, WriteCode, VariableName!=VariableName##_LastKnownValue)	\
 	if (isWrite==false && dataChanged==true)	\
 	{	\
-		VariableName##_InterpolationStartTime=getTime();	\
+		VariableName##_InterpolationStartTime=RakNetGetTime();	\
 		VariableName##_InterpolationEndTime=VariableName##_InterpolationStartTime+maximumUpdateFrequency;	\
 		VariableName##_InitialValue=VariableName;	\
 		VariableName##_FinalValue=VariableName##_LastReadValue;	\
@@ -214,7 +214,7 @@
 	SynchronizationMethod1##_INTERPOLATION_MEMORY_INIT(VariableName1)	\
 	SynchronizationMethod2##_INTERPOLATION_MEMORY_INIT(VariableName2)	\
 }	\
-virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -234,7 +234,7 @@
 \
 virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 		DistributedMemoryInit(isServerAuthoritative);	\
@@ -260,7 +260,7 @@
 	SynchronizationMethod2##_INTERPOLATION_MEMORY_INIT(VariableName2)	\
 	SynchronizationMethod3##_INTERPOLATION_MEMORY_INIT(VariableName3)	\
 }	\
-virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -282,7 +282,7 @@
 \
 virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 		DistributedMemoryInit(isServerAuthoritative);	\
@@ -313,7 +313,7 @@
 	SynchronizationMethod3##_INTERPOLATION_MEMORY_INIT(VariableName3)	\
 	SynchronizationMethod4##_INTERPOLATION_MEMORY_INIT(VariableName4)	\
 }	\
-	virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+	virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -337,7 +337,7 @@
 	\
 	virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 	DistributedMemoryInit(isServerAuthoritative);	\
@@ -373,7 +373,7 @@
 	SynchronizationMethod4##_INTERPOLATION_MEMORY_INIT(VariableName4)	\
 	SynchronizationMethod5##_INTERPOLATION_MEMORY_INIT(VariableName5)	\
 }	\
-	virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+	virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -399,7 +399,7 @@
 	\
 	virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 	DistributedMemoryInit(isServerAuthoritative);	\
@@ -440,7 +440,7 @@
 	SynchronizationMethod5##_INTERPOLATION_MEMORY_INIT(VariableName5)	\
 	SynchronizationMethod6##_INTERPOLATION_MEMORY_INIT(VariableName6)	\
 }	\
-	virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+	virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -468,7 +468,7 @@
 	\
 	virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 	DistributedMemoryInit(isServerAuthoritative);	\

Modified: branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObjectManager.cpp
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObjectManager.cpp	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObjectManager.cpp	2004-10-08 21:41:59 UTC (rev 76)
@@ -90,9 +90,14 @@
 DistributedNetworkObject *DistributedNetworkObjectManager::GetClassInstanceByIdentifier(char *classIdentifier)
 {
 	unsigned i;
+
+	if (classIdentifier[0]==0)
+		return 0;
+
 	for (i=0; i < classList.size(); i++)
 	{
 		// Byte 0 of the class identifier holds the length of the remaining bytes
+		// The +1 is because we also compare the first byte
 		if (memcmp(classIdentifier, classList[i]->GetEncodedClassName(), classList[i]->GetEncodedClassName()[0]+1)==0)
 			return classList[i]->GetObject();
 	}
@@ -106,15 +111,17 @@
 	// Assert that the first byte of the packet is ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT
 
 	char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH];
-	BitStream bitStream(packet->data, packet->length, true);
+	RakNet::BitStream bitStream((char*)packet->data, packet->length, true);
 	ObjectID objectId;
 	DistributedNetworkObject* object=0;
-	bool construction;
+	int action;
+	PlayerID pid;
+	bool isLocalObject;
+	unsigned char localObjectIndex;
+	pid=UNASSIGNED_PLAYER_ID;
 
 
-	bool isLocalObject;
-	unsigned char localObjectIndex;
-	if (DistributedNetworkObject::DeserializeClassHeader(&bitStream, construction, objectId, classIdentifier,isLocalObject,localObjectIndex)==false)
+	if (DistributedNetworkObject::DeserializeClassHeader(&bitStream, action, objectId, classIdentifier,isLocalObject,localObjectIndex,pid)==false)
 		return 0; // Some kind of corrupted packet, or the server was active but not registered, or the client was active but not registered
 
 	bool serverProcess=true;
@@ -125,7 +132,7 @@
 			serverProcess=false;
 	}
 
-	if (construction)
+	if (action>=1)
 	{
 		if (objectId!=UNASSIGNED_OBJECT_ID)
 		{
@@ -146,7 +153,10 @@
 
 			if (object==0)
 			{
-				assert(0); // Unknown class identifier
+				// If this assert hits then one system tried to create a class that was
+				// not registered with REGISTER_DISTRIBUTED_NETWORK_OBJECT on this system.
+				// Byte 0 of 0 means no class identifier was encoded
+				assert(classIdentifier[0]==0);
 				return 0;
 			}
 
@@ -154,6 +164,9 @@
 				DistributedNetworkObjectManager::Instance()->GetRakServerInterface()==0)
 				object->SetID(objectId);
 
+			if (DistributedNetworkObjectManager::Instance()->GetRakClientInterface() && pid!=UNASSIGNED_PLAYER_ID)
+				object->SetClientOwnerID(pid); // So the client knows who is the owner of the object
+
 			object->ProcessDistributedMemoryStack(&bitStream, false, false, serverProcess);
 			object->WriteToHeapFromBitstream(&bitStream);
 
@@ -165,6 +178,11 @@
 					delete object;
 					object=0;
 				}
+				else
+				{
+					object->SetLocalObject(false);
+					object->ReadCreationData(&bitStream);
+				}
 			}
 			else if (DistributedNetworkObjectManager::Instance()->GetRakServerInterface() && DistributedNetworkObjectManager::Instance()->GetRakServerInterface()->IsActive())
 			{
@@ -176,7 +194,7 @@
 
 					// Tell the sender that the object creation was rejected
 					static const unsigned char objectRejectedID = ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_REJECTED;
-					BitStream rejectionBitStream;
+					RakNet::BitStream rejectionBitStream;
 					rejectionBitStream.Write(objectRejectedID);
 					rejectionBitStream.Write(localObjectIndex);
 
@@ -184,12 +202,16 @@
 				}
 				else
 				{
+					object->SetLocalObject(false);
+					object->ReadCreationData(&bitStream);
+
 					// Receipt of this packet will set the object ID for the client so future data packets can be processed
 					static const unsigned char objectAcceptedID = ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_ACCEPTED;
-					BitStream acceptanceBitStream;
+					RakNet::BitStream acceptanceBitStream;
 					acceptanceBitStream.Write(objectAcceptedID);
 					acceptanceBitStream.Write(localObjectIndex);
 					acceptanceBitStream.Write(object->GetID());
+					acceptanceBitStream.Write((char*)&packet->playerId, sizeof(PlayerID));
 
 					DistributedNetworkObjectManager::Instance()->GetRakServerInterface()->Send(&acceptanceBitStream, HIGH_PRIORITY, RELIABLE_ORDERED, 0, packet->playerId, false);
 
@@ -202,11 +224,11 @@
 					object->BroadcastSerializedClass(&bitStream);
 					*/
 
-					object->UpdateDistributedObject(classIdentifier, true);
-
 					// If the client creates the object, it is considered the owner
 					object->SetClientOwnerID(packet->playerId);
 
+					object->UpdateDistributedObject(classIdentifier, true);
+
 				}
 			}
 		}
@@ -234,7 +256,7 @@
 			if (DistributedNetworkObjectManager::Instance()->GetRakServerInterface() && DistributedNetworkObjectManager::Instance()->GetRakServerInterface()->IsActive())
 			{
 				bitStream.Reset();
-				object->SerializeClassHeader(&bitStream, classIdentifier, true, false, 0);
+				object->SerializeClassHeader(&bitStream, classIdentifier, action, false, 0);
 				object->ProcessDistributedMemoryStack(&bitStream, true, true,true);
 				object->WriteToBitstreamFromHeap(&bitStream, true);
 				object->BroadcastSerializedClass(&bitStream);
@@ -250,6 +272,17 @@
 			return 0;
 		}
 
+		// If this is the server and the client is trying to destroy it, make sure it is either the
+		// owner or no owner is set
+		if (serverProcess)
+		{
+			if (object->GetClientOwnerID()!=UNASSIGNED_PLAYER_ID &&
+				object->GetClientOwnerID()!=packet->playerId &&
+				object->AllowSpectatorUpdate(packet->playerId)==false)
+				// Client trying to update an object it does not own - and it was not allowed to
+				return 0;
+		}
+
 		object->OnDistributedObjectDestruction(packet->playerId);
 		object=0;
 	}
@@ -262,13 +295,16 @@
 	unsigned char localObjectIndex;
 	DistributedNetworkObject* object;
 	ObjectID objectID;
+	PlayerID pid;
 
-	BitStream bitStream(packet->data, packet->length, false);
+	RakNet::BitStream bitStream((char*)packet->data, packet->length, false);
 	bitStream.IgnoreBits(sizeof(unsigned char)*8); // Skip the packet identifier
 	if (bitStream.Read(localObjectIndex)==0)
 		return;
 	if (bitStream.Read(objectID)==0)
 		return;
+	if (bitStream.Read((char*)&pid, sizeof(PlayerID))==0)
+		return;
 
 	// Find the object with this index
 	object = GetObjectByLocalObjectIndex(localObjectIndex);
@@ -286,6 +322,12 @@
 		delete object;
 		object=0;
 	}
+	else
+	{
+		object->SetLocalObject(false);
+		object->SetClientOwnerID(pid);
+	}
+
 }
 
 void DistributedNetworkObjectManager::HandleDistributedNetworkObjectPacketCreationRejected(Packet *packet)
@@ -293,7 +335,7 @@
 	unsigned char localObjectIndex;
 	DistributedNetworkObject* object;
 
-	BitStream bitStream(packet->data, packet->length, false);
+	RakNet::BitStream bitStream((char*)packet->data, packet->length, false);
 	bitStream.IgnoreBits(sizeof(unsigned char)*8); // Skip the packet identifier
 	if (bitStream.Read(localObjectIndex)==0)
 		return;
@@ -336,12 +378,12 @@
 			}
 		}
 
-		BitStream bitStream;
+		RakNet::BitStream bitStream;
 		unsigned i;
 		for (i=0; i < distributedNetworkObjectInstanceRegistry.size(); i++)
 		{
 			bitStream.Reset();
-			distributedNetworkObjectInstanceRegistry[i]->object->SerializeClassHeader(&bitStream, distributedNetworkObjectInstanceRegistry[i]->classIdentifier, true, false, 255);
+			distributedNetworkObjectInstanceRegistry[i]->object->SerializeClassHeader(&bitStream, distributedNetworkObjectInstanceRegistry[i]->classIdentifier, 2, false, 255);
 
 			// Note to self - ProcessDistributedMemoryStack with write to true will update network memory.  During the next normal updates
 			// any changes that occured in the meantime won't be distributed.  Is this something to be concerned about?

Modified: branches/multiplayer-branch/source/libraries/raknet/EncodeClassName.cpp
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/EncodeClassName.cpp	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/EncodeClassName.cpp	2004-10-08 21:41:59 UTC (rev 76)
@@ -13,7 +13,7 @@
 
 void EncodeClassName(char *name, char *identifier)
 {
-	BitStream bitStream;
+	RakNet::BitStream bitStream;
 	int index=0;
 	unsigned char byte;
 	while (index < MAXIMUM_CLASS_IDENTIFIER_LENGTH-1)

Modified: branches/multiplayer-branch/source/libraries/raknet/GetTime.cpp
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/GetTime.cpp	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/GetTime.cpp	2004-10-08 21:41:59 UTC (rev 76)
@@ -9,28 +9,43 @@
 
 #include "GetTime.h"
 
-////#include "MemoryManager.h"
+#ifdef _WIN32
+#include <windows.h>
+#else
+#include <sys/time.h>
+#endif
 
-GetTime GetTime::instance;
-
-GetTime::GetTime()
+unsigned long RakNetGetTime(void)
 {
-// For some reason this fails in the constructor
-//	QueryPerformanceFrequency(&yo);
-//	counts = yo.QuadPart >> 10;
-	initialized=false;
-}
+#ifdef _WIN32
+	static LARGE_INTEGER yo;
+	static LONGLONG counts;
+#else
+	static timeval tp, initialTime;
+#endif
+	static bool initialized=false;
+	if (initialized==false)
+	{
+#ifdef _WIN32
+		QueryPerformanceFrequency(&yo);
+		// The original code shifted right 10 bits
+		//counts = yo.QuadPart >> 10;
+		// It gives the wrong value since 2^10 is not 1000
+		counts = yo.QuadPart / 1000;
+#else
+		gettimeofday(&initialTime, 0); 
+#endif
+		initialized=true; 
+	}
 
-void GetTime::Init(void)
-{
-	#ifdef _WIN32
-	QueryPerformanceFrequency(&yo);
-	// The original code shifted right 10 bits
-	//counts = yo.QuadPart >> 10;
-	// It gives the wrong value since 2^10 is not 1000
-	counts = yo.QuadPart / 1000;
-	#else
-	gettimeofday(&initialTime, 0); 
-	#endif
-	initialized=true; 
+#ifdef _WIN32
+	LARGE_INTEGER PerfVal;
+	QueryPerformanceCounter(&PerfVal);
+	return (unsigned long)(PerfVal.QuadPart/counts);
+#else
+	gettimeofday(&tp, 0);
+
+	// Seconds to ms and microseconds to ms
+	return (tp.tv_sec - initialTime.tv_sec) * 1000 + (tp.tv_usec - initialTime.tv_usec) / 1000;
+#endif
 }

Modified: branches/multiplayer-branch/source/libraries/raknet/GetTime.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/GetTime.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/GetTime.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -10,53 +10,7 @@
 #ifndef __GET_TIME_H
 #define __GET_TIME_H
 
-#ifdef _WIN32
-#include <windows.h>
-#else
-#include <sys/time.h>
-#endif
+extern unsigned long RakNetGetTime(void);
 
-// A utility class to get a more accurate time than timeGetTime()
-class GetTime
-{
-public:
-	// Call this before using the function.  It won't work in constructor calls though, so you have to call this in Winmain or main and
-	// not use the class in your constructors
-	void Init(void);
-
-	// Call this or use the #define getTime (below) to get the current time
-	inline unsigned long Time(void)
-	{
-		if (initialized==false) Init();
-
-		#ifdef _WIN32
-		LARGE_INTEGER PerfVal;
-		QueryPerformanceCounter(&PerfVal);
-		return (unsigned long)(PerfVal.QuadPart/counts);
-		#else
-		gettimeofday(&tp, 0);
-		// Seconds to ms and microseconds to ms
-		return (tp.tv_sec - initialTime.tv_sec) * 1000 + (tp.tv_usec - initialTime.tv_usec) / 1000;
-		#endif
-	}
-
-	~GetTime() {}
-	// static function because only static functions can access static members
-	static inline GetTime* Instance() {return &instance;}
-private:
-	static GetTime instance;
-	GetTime();
-    
-    	#ifdef _WIN32
-	LARGE_INTEGER yo;
-	LONGLONG counts;
-	#else
-	timeval tp, initialTime;
-	#endif
-	bool initialized;
-};
-
-#define getTime GetTime::Instance()->Time
-
 #endif
 

Modified: branches/multiplayer-branch/source/libraries/raknet/HuffmanEncodingTree.cpp
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/HuffmanEncodingTree.cpp	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/HuffmanEncodingTree.cpp	2004-10-08 21:41:59 UTC (rev 76)
@@ -109,7 +109,7 @@
 	bool tempPath[256]; // Maximum path length is 256
 	unsigned short tempPathLength;
 	HuffmanEncodingTreeNode *currentNode;
-	BitStream bitStream;
+	RakNet::BitStream bitStream;
 
 	// Generate the encryption table. From before, we have an array of pointers to all the leaves which contain pointers to their parents.
 	// This can be done more efficiently but this isn't bad and it's way easier to program and debug
@@ -148,7 +148,7 @@
 }
 
 // Pass an array of bytes to array and a preallocated BitStream to receive the output
-void HuffmanEncodingTree::EncodeArray(unsigned char *input, int sizeInBytes, BitStream* output)
+void HuffmanEncodingTree::EncodeArray(unsigned char *input, int sizeInBytes, RakNet::BitStream * output)
 {
 	if (sizeInBytes<=0)
 		return;
@@ -179,7 +179,7 @@
 	}
 }
 
-int HuffmanEncodingTree::DecodeArray(BitStream* input, int sizeInBits, int maxCharsToWrite, unsigned char *output)
+int HuffmanEncodingTree::DecodeArray(RakNet::BitStream * input, int sizeInBits, int maxCharsToWrite, unsigned char *output)
 {
 	HuffmanEncodingTreeNode *currentNode;
 
@@ -210,14 +210,14 @@
 }
 
 // Pass an array of encoded bytes to array and a preallocated BitStream to receive the output
-void HuffmanEncodingTree::DecodeArray(unsigned char *input, int sizeInBits, BitStream* output)
+void HuffmanEncodingTree::DecodeArray(unsigned char *input, int sizeInBits, RakNet::BitStream * output)
 {
 	HuffmanEncodingTreeNode *currentNode;
 
 	if (sizeInBits<=0)
 		return;
 
-	BitStream bitStream(BITS_TO_BYTES(sizeInBits));
+	RakNet::BitStream bitStream(BITS_TO_BYTES(sizeInBits));
 	bitStream.SetData(input, sizeInBits); // Put the data in the BitStream class to make it easier to use
 
 	currentNode=root;

Modified: branches/multiplayer-branch/source/libraries/raknet/HuffmanEncodingTree.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/HuffmanEncodingTree.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/HuffmanEncodingTree.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -11,8 +11,8 @@
 #define __HUFFMAN_ENCODING_TREE
 
 #include "HuffmanEncodingTreeNode.h"
+#include "BitStream.h"
 
-class BitStream;
 #include "LinkedList.h"
 
 // This generates special cases of the huffman encoding tree using 8 bit keys with the additional condition that unused combinations of 8 bits are treated as a frequency of 1
@@ -23,12 +23,12 @@
 	~HuffmanEncodingTree();
 
 	// Pass an array of bytes to array and a preallocated BitStream to receive the output
-	void EncodeArray(unsigned char *input, int sizeInBytes, BitStream* output);
+	void EncodeArray(unsigned char *input, int sizeInBytes, RakNet::BitStream * output);
 
 	// Two versions that perform the same operation.
 	// The second version also the number of bytes in the stream, which may be greater than the max chars to write
-	int DecodeArray(BitStream* input, int sizeInBits, int maxCharsToWrite, unsigned char *output);
-	void DecodeArray(unsigned char *input, int sizeInBits, BitStream* output);
+	int DecodeArray(RakNet::BitStream * input, int sizeInBits, int maxCharsToWrite, unsigned char *output);
+	void DecodeArray(unsigned char *input, int sizeInBits, RakNet::BitStream * output);
 
 	// Given a frequency table of 256 elements, all with a frequency of 1 or more, generate the tree
 	void GenerateFromFrequencyTable(unsigned long frequencyTable[256]);

Modified: branches/multiplayer-branch/source/libraries/raknet/InternalPacket.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/InternalPacket.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/InternalPacket.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -20,11 +20,10 @@
 {
 	bool isAcknowledgement; // True if this is an acknowledgement packet
 	PacketNumberType packetNumber; // The number of this packet, used as an identifier
-	char sha1Code[SHA1_LENGTH]; // The sha1Code, used to verify packet data integrity
 	PacketPriority priority; // The priority level of this packet
 	PacketReliability reliability; // What type of reliability algorithm to use with this packet
-	unsigned char orderingStream; // What ordering stream this packet is on, if the reliability type uses ordering streams
-	unsigned char orderingIndex; // The ID used as identification for ordering streams
+	unsigned char orderingChannel; // What ordering channel this packet is on, if the reliability type uses ordering channels
+	unsigned char orderingIndex; // The ID used as identification for ordering channels
 	unsigned long splitPacketId; // The ID of the split packet, if we have split packets
 	unsigned long splitPacketIndex; // If this is a split packet, the index into the array of split packets
 	unsigned long splitPacketCount; // The size of the array of split packets

Modified: branches/multiplayer-branch/source/libraries/raknet/InternalPacketPool.cpp
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/InternalPacketPool.cpp	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/InternalPacketPool.cpp	2004-10-08 21:41:59 UTC (rev 76)
@@ -15,6 +15,9 @@
 #ifdef _DEBUG
 	packetsReleased=0;
 #endif
+
+	// Speed things up by not reallocating at runtime when a mutex is locked.
+	pool.clearAndForceAllocation(1024);
 }
 
 InternalPacketPool::~InternalPacketPool()
@@ -49,6 +52,7 @@
 	poolMutex.Lock();
 	if (pool.size())
 		p=pool.pop();
+
 	poolMutex.Unlock();
 	if (p)
 		return p;

Modified: branches/multiplayer-branch/source/libraries/raknet/LinkedList.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/LinkedList.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/LinkedList.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -95,6 +95,7 @@
 	B++;
 	B.peek();  // Returns 30
 
+9/04 Giblet - updated code to work with new compilers adhering more closely to ISO standard
 
 */
 
@@ -176,15 +177,15 @@
 template <class CircularLinkedListType>
 inline void CircularLinkedList<CircularLinkedListType>::beginning(void)
 {
-	if (root)
-		position=root;
+	if (this->root)
+		this->position=this->root;
 }
 
 template <class CircularLinkedListType>
 inline void CircularLinkedList<CircularLinkedListType>::end(void)
 {
-	if (root)
-		position=root->previous;
+	if (this->root)
+		this->position=this->root->previous;
 }
 
 template <class LinkedListType>
@@ -195,71 +196,71 @@
 	if ((&original_copy) != this)
 	{
 	
-	clear();
+	this->clear();
 
 
 	if (original_copy.list_size==0L) 
 	{
-		root=0;
-		position=0;
-		list_size=0L;
+		this->root=0;
+		this->position=0;
+		this->list_size=0L;
 	}
 	else if (original_copy.list_size==1L)
 	{
-		root= new typename LinkedList::node;
+		this->root= new typename LinkedList::node;
 		// root->item = new LinkedListType;
-		root->next=root;
-		root->previous=root;
-		list_size=1L;
-		position=root;
+		this->root->next=this->root;
+		this->root->previous=this->root;
+		this->list_size=1L;
+		this->position=this->root;
 		// *(root->item)=*((original_copy.root)->item);
-		root->item = original_copy.root->item;
+		this->root->item = original_copy.root->item;
 	}
 	else
 	{
 		// Setup the first part of the root node
 		original_copy_pointer=original_copy.root;
-		root = new typename LinkedList::node;
+		this->root = new typename LinkedList::node;
 		// root->item = new LinkedListType;
-		position = root;
+		this->position = this->root;
 		// *(root->item)=*((original_copy.root)->item);
-		root->item = original_copy.root->item;
-		if (original_copy_pointer == original_copy.position) save_position=position;
+		this->root->item = original_copy.root->item;
+		if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 		do
 		{
 			
 
 			// Save the current element
-			last=position;
+			this->last=this->position;
 
 			// Point to the next node in the source list
 			original_copy_pointer=original_copy_pointer->next;
 
 			// Create a new node and point position to it
-			position = new typename LinkedList::node;
+			this->position = new typename LinkedList::node;
 			// position->item = new LinkedListType;
 
 			// Copy the item to the new node
 			// *(position->item)=*(original_copy_pointer->item);
-			position->item = original_copy_pointer->item;
-			if (original_copy_pointer == original_copy.position) save_position=position;
+			this->position->item = original_copy_pointer->item;
+			if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 
 			// Set the previous pointer for the new node
-			(position->previous) = last;
+			(this->position->previous) = this->last;
 
 			// Set the next pointer for the old node to the new node
-			(last->next) =position;
+			(this->last->next) =this->position;
 
 		} while ((original_copy_pointer->next) != (original_copy.root));
 
 		// Complete the circle.  Set the next pointer of the newest node to the root and the previous pointer of the root to the newest node
-		position->next=root;
-		root->previous=position;
+		this->position->next=this->root;
+		this->root->previous=this->position;
 
-		list_size=original_copy.list_size;
-		position=save_position;
+		this->list_size=original_copy.list_size;
+		this->position=save_position;
 	}
 }
 
@@ -270,21 +271,21 @@
 template <class CircularLinkedListType>
 CircularLinkedList<CircularLinkedListType>::CircularLinkedList()
 {
-	root=0;
-	position=0;
-	list_size=0L;
+	this->root=0;
+	this->position=0;
+	this->list_size=0L;
 }
 
 template <class CircularLinkedListType>
 CircularLinkedList<CircularLinkedListType>::~CircularLinkedList()
 {
-	clear();
+	this->clear();
 }
 
 template <class LinkedListType>
 LinkedList<LinkedListType>::~LinkedList()
 {
-	clear();
+	this->clear();
 }
 
 template <class LinkedListType>
@@ -294,64 +295,64 @@
 
 	if (original_copy.list_size==0L) 
 	{
-		root=0;
-		position=0;
-		list_size=0L;
+		this->root=0;
+		this->position=0;
+		this->list_size=0L;
 		return;
 	}
 	else if (original_copy.list_size==1L)
 	{
-		root= new typename LinkedList::node;
+		this->root= new typename LinkedList::node;
 		// root->item = new CircularLinkedListType;
-		root->next=root;
-		root->previous=root;
-		list_size=1L;
-		position=root;
+		this->root->next=this->root;
+		this->root->previous=this->root;
+		this->list_size=1L;
+		this->position=this->root;
 		// *(root->item) = *((original_copy.root)->item);
-		root->item = original_copy.root->item;
+		this->root->item = original_copy.root->item;
 	}
 	else
 	{
 		// Setup the first part of the root node
 		original_copy_pointer=original_copy.root;
-		root = new typename LinkedList::node;
+		this->root = new typename LinkedList::node;
 		// root->item = new CircularLinkedListType;
-		position = root;
+		this->position = this->root;
 		// *(root->item)=*((original_copy.root)->item);
-		root->item = original_copy.root->item;
-		if (original_copy_pointer == original_copy.position) save_position=position;
+		this->root->item = original_copy.root->item;
+		if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 		do
 		{
 			// Save the current element
-			last=position;
+			this->last=this->position;
 
 			// Point to the next node in the source list
 			original_copy_pointer=original_copy_pointer->next;
 
 			// Create a new node and point position to it
-			position = new typename LinkedList::node;
+			this->position = new typename LinkedList::node;
 			// position->item = new CircularLinkedListType;
 
 			// Copy the item to the new node
 			// *(position->item)=*(original_copy_pointer->item);
-			position->item = original_copy_pointer->item;
-			if (original_copy_pointer == original_copy.position) save_position=position;
+			this->position->item = original_copy_pointer->item;
+			if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 			// Set the previous pointer for the new node
-			(position->previous) = last;
+			(this->position->previous) = last;
 
 			// Set the next pointer for the old node to the new node
-			(last->next) =position;
+			(this->last->next) =this->position;
 
 		} while ((original_copy_pointer->next) != (original_copy.root));
 
 		// Complete the circle.  Set the next pointer of the newest node to the root and the previous pointer of the root to the newest node
-		position->next=root;
-		root->previous=position;
+		this->position->next=this->root;
+		this->root->previous=this->position;
 
-		list_size=original_copy.list_size;
-		position=save_position;
+		this->list_size=original_copy.list_size;
+		this->position=save_position;
 	}
 }
 
@@ -362,66 +363,66 @@
 
 	if (original_copy.list_size==0L) 
 	{
-		root=0;
-		position=0;
-		list_size=0L;
+		this->root=0;
+		this->position=0;
+		this->list_size=0L;
 		return;
 	}
 	else if (original_copy.list_size==1L)
 	{
-		root= new typename CircularLinkedList::node;
+		this->root= new typename CircularLinkedList::node;
 		// root->item = new CircularLinkedListType;
-		root->next=root;
-		root->previous=root;
-		list_size=1L;
-		position=root;
+		this->root->next=this->root;
+		this->root->previous=this->root;
+		this->list_size=1L;
+		this->position=this->root;
 		// *(root->item) = *((original_copy.root)->item);
-		root->item = original_copy.root->item;
+		this->root->item = original_copy.root->item;
 	}
 	else
 	{
 		// Setup the first part of the root node
 		original_copy_pointer=original_copy.root;
-		root = new typename CircularLinkedList::node;
+		this->root = new typename CircularLinkedList::node;
 		// root->item = new CircularLinkedListType;
-		position = root;
+		this->position = this->root;
 		// *(root->item)=*((original_copy.root)->item);
-		root->item = original_copy.root->item;
-		if (original_copy_pointer == original_copy.position) save_position=position;
+		this->root->item = original_copy.root->item;
+		if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 		do
 		{
 			
 
 			// Save the current element
-			last=position;
+			this->last=this->position;
 
 			// Point to the next node in the source list
 			original_copy_pointer=original_copy_pointer->next;
 
 			// Create a new node and point position to it
-			position = new typename CircularLinkedList::node;
+			this->position = new typename CircularLinkedList::node;
 			// position->item = new CircularLinkedListType;
 
 			// Copy the item to the new node
 			// *(position->item)=*(original_copy_pointer->item);
-			position->item = original_copy_pointer->item;
+			this->position->item = original_copy_pointer->item;
 			if (original_copy_pointer == original_copy.position) save_position=position;
 
 			// Set the previous pointer for the new node
-			(position->previous) = last;
+			(this->position->previous) = this->last;
 
 			// Set the next pointer for the old node to the new node
-			(last->next) =position;
+			(this->last->next) =this->position;
 
 		} while ((original_copy_pointer->next) != (original_copy.root));
 
 		// Complete the circle.  Set the next pointer of the newest node to the root and the previous pointer of the root to the newest node
-		position->next=root;
-		root->previous=position;
+		this->position->next=this->root;
+		this->root->previous=position;
 
-		list_size=original_copy.list_size;
-		position=save_position;
+		this->list_size=original_copy.list_size;
+		this->position=save_position;
 	}
 }
 
@@ -433,68 +434,68 @@
 	if ((&original_copy) != this)
 	{
 	
-	clear();
+	this->clear();
 
 
 	if (original_copy.list_size==0L) 
 	{
-		root=0;
-		position=0;
-		list_size=0L;
+		this->root=0;
+		this->position=0;
+		this->list_size=0L;
 	}
 	else if (original_copy.list_size==1L)
 	{
-		root= new typename CircularLinkedList::node;
+		this->root= new typename CircularLinkedList::node;
 		// root->item = new CircularLinkedListType;
-		root->next=root;
-		root->previous=root;
-		list_size=1L;
-		position=root;
+		this->root->next=this->root;
+		this->root->previous=this->root;
+		this->list_size=1L;
+		this->position=this->root;
 		// *(root->item)=*((original_copy.root)->item);
-		root->item = original_copy.root->item;
+		this->root->item = original_copy.root->item;
 	}
 	else
 	{
 		// Setup the first part of the root node
 		original_copy_pointer=original_copy.root;
-		root = new typename CircularLinkedList::node;
+		this->root = new typename CircularLinkedList::node;
 		// root->item = new CircularLinkedListType;
-		position = root;
+		this->position = this->root;
 		// *(root->item)=*((original_copy.root)->item);
-		root->item = original_copy.root->item;
-		if (original_copy_pointer == original_copy.position) save_position=position;
+		this->root->item = original_copy.root->item;
+		if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 		do
 		{
 			// Save the current element
-			last=position;
+			this->last=this->position;
 
 			// Point to the next node in the source list
 			original_copy_pointer=original_copy_pointer->next;
 
 			// Create a new node and point position to it
-			position = new typename CircularLinkedList::node;
+			this->position = new typename CircularLinkedList::node;
 			// position->item = new CircularLinkedListType;
 
 			// Copy the item to the new node
 			// *(position->item)=*(original_copy_pointer->item);
-			position->item = original_copy_pointer->item;
-			if (original_copy_pointer == original_copy.position) save_position=position;
+			this->position->item = original_copy_pointer->item;
+			if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 			// Set the previous pointer for the new node
-			(position->previous) = last;
+			(this->position->previous) = this->last;
 
 			// Set the next pointer for the old node to the new node
-			(last->next) =position;
+			(this->last->next) =this->position;
 
 		} while ((original_copy_pointer->next) != (original_copy.root));
 
 		// Complete the circle.  Set the next pointer of the newest node to the root and the previous pointer of the root to the newest node
-		position->next=root;
-		root->previous=position;
+		this->position->next=this->root;
+		this->root->previous=this->position;
 
-		list_size=original_copy.list_size;
-		position=save_position;
+		this->list_size=original_copy.list_size;
+		this->position=save_position;
 	}
 }
 
@@ -508,28 +509,28 @@
 
 	if (list_size==0L)
 	{
-		root= new typename CircularLinkedList::node;
+		this->root= new typename CircularLinkedList::node;
 		// root->item = new CircularLinkedListType;
 		//*(root->item)=input;
-		root->item = input;
-		root->next=root;
-		root->previous=root;
-		list_size=1L;
-		position=root;
+		this->root->item = input;
+		this->root->next=this->root;
+		this->root->previous=this->root;
+		this->list_size=1L;
+		this->position=this->root;
 	}
 
 	else if (list_size==1L)
 	{
-		position= new typename CircularLinkedList::node;
+		this->position= new typename CircularLinkedList::node;
 		// position->item = new CircularLinkedListType;
-		root->next=position;
-		root->previous=position;
-		position->previous=root;
-		position->next=root;
+		this->root->next=this->position;
+		this->root->previous=this->position;
+		this->position->previous=this->root;
+		this->position->next=this->root;
 		// *(position->item)=input;
-		position->item = input;
-		root=position;  // Since we're inserting into a 1 element list the old root is now the second item
-		list_size=2L;
+		this->position->item = input;
+		this->root=this->position;  // Since we're inserting into a 1 element list the old root is now the second item
+		this->list_size=2L;
 	}
 
 	else
@@ -553,22 +554,22 @@
 		new_node->item = input;
 
 		// Point next of A to B
-		(position->previous)->next=new_node;
+		(this->position->previous)->next=new_node;
 
 		// Point last of B to A
-		new_node->previous=position->previous;
+		new_node->previous=this->position->previous;
 
 		// Point last of C to B
-		position->previous=new_node;
+		this->position->previous=new_node;
 
 		// Point next of B to C
-		new_node->next=position;
+		new_node->next=this->position;
 
 		 // Since the root pointer is bound to a node rather than an index this moves it back if you insert an element at the root
-		if (position==root) {root=new_node; position=root;}
+		if (this->position==this->root) {this->root=new_node; this->position=this->root;}
 
 		// Increase the recorded size of the list by one
-		list_size++;
+		this->list_size++;
 	}
 }
 
@@ -577,34 +578,34 @@
 {
 	node *new_node;
 
-	if (list_size==0L)
+	if (this->list_size==0L)
 	{
-		root= new typename CircularLinkedList::node;
+		this->root= new typename CircularLinkedList::node;
 		// root->item = new CircularLinkedListType;
 		// *(root->item)=input;
-		root->item=input;
-		root->next=root;
-		root->previous=root;
-		list_size=1L;
-		position=root;
+		this->root->item=input;
+		this->root->next=this->root;
+		this->root->previous=this->root;
+		this->list_size=1L;
+		this->position=this->root;
 		// return *(position->item);
-		return position->item;
+		return this->position->item;
 	}
 
 	else if (list_size==1L)
 	{
-		position= new typename CircularLinkedList::node;
+		this->position= new typename CircularLinkedList::node;
 		// position->item = new CircularLinkedListType;
-		root->next=position;
-		root->previous=position;
-		position->previous=root;
-		position->next=root;
+		this->root->next=this->position;
+		this->root->previous=this->position;
+		this->position->previous=this->root;
+		this->position->next=this->root;
 		// *(position->item)=input;
-		position->item = input;
-		list_size=2L;
-		position=root;  // Don't move the position from the root
+		this->position->item = input;
+		this->list_size=2L;
+		this->position=this->root;  // Don't move the position from the root
 		// return *(position->item);
-		return position->item;
+		return this->position->item;
 	}
 
 	else
@@ -628,19 +629,19 @@
 		new_node->item=input;
 
 		// Point last of B to A
-		new_node->previous=position;
+		new_node->previous=this->position;
 
 		// Point next of B to C
-		new_node->next=(position->next);
+		new_node->next=(this->position->next);
 
 		// Point last of C to B
-		(position->next)->previous=new_node;
+		(this->position->next)->previous=new_node;
 
 		// Point next of A to B
-		(position->next)=new_node;
+		(this->position->next)=new_node;
 
 		// Increase the recorded size of the list by one
-		list_size++;
+		this->list_size++;
 		
 		// return *(new_node->item);
 		return new_node->item;
@@ -650,9 +651,9 @@
 template <class CircularLinkedListType>
 inline void CircularLinkedList<CircularLinkedListType>::replace(const CircularLinkedListType& input)
 {
-	if (list_size>0L)
+	if (this->list_size>0L)
 		// *(position->item)=input;
-		position->item=input;
+		this->position->item=input;
 }
 
 template <class CircularLinkedListType>
@@ -660,26 +661,26 @@
 {
 	node* new_position;
 
-	if (list_size==0L) return;
+	if (this->list_size==0L) return;
 
-	else if (list_size==1L)
+	else if (this->list_size==1L)
 	{
 		// delete root->item;
-		delete root;
-		root=position=0;
-		list_size=0L;
+		delete this->root;
+		this->root=this->position=0;
+		this->list_size=0L;
 	}
 
 	else
 	{
-		(position->previous)->next = position->next;
-		(position->next)->previous = position->previous;
-		new_position=position->next;
-		if (position==root) root=new_position;
+		(this->position->previous)->next = this->position->next;
+		(this->position->next)->previous = this->position->previous;
+		new_position=this->position->next;
+		if (this->position==this->root) this->root=new_position;
 		// delete position->item;
-		delete position;
-		position=new_position;
-		list_size--;
+		delete this->position;
+		this->position=new_position;
+		this->list_size--;
 	}
 }
 
@@ -688,10 +689,10 @@
 {
 	node *return_value,*old_position;
 	
-	old_position=position;
+	old_position=this->position;
  
 	return_value=find_pointer(input);
-	position=old_position;
+	this->position=old_position;
 
 	if (return_value!=0) return true;
 	else return false;	// Can't find the item don't do anything
@@ -704,7 +705,7 @@
  
 	return_value=find_pointer(input);
 
-	if (return_value!=0) {position=return_value; return true;}
+	if (return_value!=0) {this->position=return_value; return true;}
 	else return false;	// Can't find the item don't do anything
 }
 
@@ -713,8 +714,8 @@
 {
 	node* current;
 
-	if (list_size==0L) return 0;
-	current=root;
+	if (this->list_size==0L) return 0;
+	current=this->root;
 
 	// Search for the item starting from the root node and incrementing the pointer after every check
 	// If you wind up pointing at the root again you looped around the list so didn't find the item, in which case return 0
@@ -723,7 +724,7 @@
 		// if (*(current->item) == input) return current;
 		if (current->item == input) return current;
 		current=current->next;
-	} while (current != root);
+	} while (current != this->root);
 
 	return 0;
 	
@@ -732,14 +733,14 @@
 template <class CircularLinkedListType>
 inline unsigned long CircularLinkedList<CircularLinkedListType>::size(void)
 {
-	return list_size;
+	return this->list_size;
 }
 
 template <class CircularLinkedListType>
 inline CircularLinkedListType& CircularLinkedList<CircularLinkedListType>::peek(void)
 {
 	// return *(position->item);
-	return position->item;
+	return this->position->item;
 }
 
 template <class CircularLinkedListType>
@@ -755,7 +756,7 @@
 template <class CircularLinkedListType>
 CircularLinkedList<CircularLinkedListType>& CircularLinkedList<CircularLinkedListType>::operator++()
 {
-	if (list_size!=0L) position=position->next;
+	if (this->list_size!=0L) position=position->next;
 	return *this;
 }
 
@@ -774,14 +775,14 @@
 template <class CircularLinkedListType>
 CircularLinkedList<CircularLinkedListType>& CircularLinkedList<CircularLinkedListType>::operator++(int)
 {
-	return operator++();
+	return this->operator++();
 }
 
 // Prefix
 template <class CircularLinkedListType>
 CircularLinkedList<CircularLinkedListType>& CircularLinkedList<CircularLinkedListType>::operator--()
 {
-	if (list_size!=0L) position=position->previous;
+	if (this->list_size!=0L) this->position=this->position->previous;
 	return *this;
 }
 
@@ -800,21 +801,21 @@
 template <class CircularLinkedListType>
 CircularLinkedList<CircularLinkedListType>& CircularLinkedList<CircularLinkedListType>::operator--(int)
 {
-	return operator--();
+	return this->operator--();
 }
 
 template <class CircularLinkedListType>
 void CircularLinkedList<CircularLinkedListType>::clear(void)
 {
-	if (list_size==0L) return;
-	else if (list_size==1L)// {delete root->item; delete root;}
-		{delete root;}
+	if (this->list_size==0L) return;
+	else if (this->list_size==1L)// {delete root->item; delete root;}
+		{delete this->root;}
 	else
 	{
 		node* current;
 		node* temp;
 
-		current=root;
+		current=this->root;
 
 		do
 		{
@@ -822,12 +823,12 @@
 			current=current->next;
 		//	delete temp->item;
 			delete temp;
-		} while (current!=root);
+		} while (current!=this->root);
 	}
 
-	list_size=0L;
-	root=0;
-	position=0;
+	this->list_size=0L;
+	this->root=0;
+	this->position=0;
 }
 
 template <class CircularLinkedListType>
@@ -837,10 +838,10 @@
 	node* ptr;
 
 	if (L.list_size == 0L) return;
-	if (list_size == 0L) *this = L;
+	if (this->list_size == 0L) *this = L;
 
 	ptr = L.root;
-	position=root->previous;
+	this->position=this->root->previous;
 	
 	// Cycle through each element in L and add it to the current list
 	for (counter = 0; counter < L.list_size; counter++)
@@ -851,18 +852,18 @@
 
 		// Update pointers.  Moving ptr keeps the current pointer at the end of the list since the add function does not move the pointer
 		ptr=ptr->next;
-		position=position->next;
+		this->position=this->position->next;
 	}
 }
 
 template <class CircularLinkedListType>
 inline void CircularLinkedList<CircularLinkedListType>::sort(void)
 {
-	if (list_size<=1L) return;
+	if (this->list_size<=1L) return;
 
 	// Call equal operator to assign result of mergesort to current object
 	*this = mergesort(*this);
-	position=root;
+	this->position=this->root;
 }
 
 template <class CircularLinkedListType>
@@ -1015,7 +1016,7 @@
 template <class LinkedListType>
 LinkedList<LinkedListType>& LinkedList<LinkedListType>::operator++()
 {
-	if ((list_size!=0L) && (position->next!=root)) position=position->next;
+	if ((this->list_size!=0L) && (this->position->next!=this->root)) this->position=this->position->next;
 	return *this;
 }
 /*
@@ -1033,14 +1034,14 @@
 template <class LinkedListType>
 LinkedList<LinkedListType>& LinkedList<LinkedListType>::operator++(int)
 {
-	return operator++();
+	return this->operator++();
 }
 
 // Prefix
 template <class LinkedListType>
 LinkedList<LinkedListType>& LinkedList<LinkedListType>::operator--()
 {
-	if ((list_size!=0L) && (position!=root)) position=position->previous;
+	if ((this->list_size!=0L) && (this->position!=this->root)) this->position=this->position->previous;
 	return *this;
 }
 /*
@@ -1059,7 +1060,7 @@
 template <class LinkedListType>
 LinkedList<LinkedListType>& LinkedList<LinkedListType>::operator--(int)
 {
-	return operator--();
+	return this->operator--();
 }
 
 } // End namespace

Modified: branches/multiplayer-branch/source/libraries/raknet/Multiplayer.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/Multiplayer.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/Multiplayer.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -33,6 +33,7 @@
 	virtual void ReceiveRemoteConnectionLost(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveRemoteNewIncomingConnection(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveRemoteExistingConnection(Packet *packet,InterfaceType *interfaceType);
+	virtual void ReceiveRemoteStaticData(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveConnectionBanned(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveConnectionRequestAccepted(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveNewIncomingConnection(Packet *packet,InterfaceType *interfaceType);
@@ -133,6 +134,9 @@
 		case ID_REMOTE_EXISTING_CONNECTION:
 			ReceiveRemoteExistingConnection(p,interfaceType);
 		break;
+		case ID_REMOTE_STATIC_DATA:
+			ReceiveRemoteStaticData(p,interfaceType);
+		break;
 		case ID_CONNECTION_BANNED:
 			ReceiveConnectionBanned(p, interfaceType);
 		break;
@@ -276,6 +280,17 @@
 }
 
 template <class InterfaceType>
+void Multiplayer<InterfaceType>::ReceiveRemoteStaticData(Packet *packet,InterfaceType *interfaceType)
+{
+	// A client got the remote static data for another system
+	//  Client only.
+#ifdef _DEBUG
+	printf("ID_REMOTE_STATIC_DATA from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+	//	ProcessUnhandledPacket(packet, ID_REMOTE_EXISTING_CONNECTION,interfaceType);
+}
+
+template <class InterfaceType>
 void Multiplayer<InterfaceType>::ReceiveConnectionBanned(Packet *packet,InterfaceType *interfaceType)
 {
 	// We are banned from connecting to the system specified in packet->playerId

Modified: branches/multiplayer-branch/source/libraries/raknet/NetworkTypes.cpp
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/NetworkTypes.cpp	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/NetworkTypes.cpp	2004-10-08 21:41:59 UTC (rev 76)
@@ -27,4 +27,3 @@
 {
 	return left.binaryAddress<right.binaryAddress || left.port<right.port;
 }
-

Modified: branches/multiplayer-branch/source/libraries/raknet/NetworkTypes.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/NetworkTypes.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/NetworkTypes.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -12,6 +12,7 @@
 
 typedef unsigned short ObjectID;
 typedef unsigned char UniqueIDType;
+typedef unsigned short PlayerIndex;
 
 struct PlayerID
 {
@@ -24,6 +25,7 @@
 	friend int operator < (const PlayerID& left, const PlayerID& right);
 };
 
+
 struct RequestedConnectionStruct
 {
 	PlayerID playerId; // Who we wanted to connect to
@@ -35,38 +37,43 @@
 
 struct Packet
 {
+	PlayerIndex playerIndex; // Server only - this is the index into the player array that this playerId maps to
 	PlayerID playerId;
 	unsigned long length;
 	unsigned long bitSize; // Same as length but represents bits.  Length is obsolete and retained for backwards compatibility
-	char* data;
+	unsigned char* data;
 };
 
 #pragma pack(push,1)
-#pragma pack(1)
 struct ConnectionAcceptStruct
 {
 	unsigned char typeId;
 	unsigned short remotePort;
 	PlayerID externalID; // We tell the remote system its own IP / port this way
+	PlayerIndex playerIndex; // For internal use
 };
+#pragma pack(pop)
 
-#pragma pack(1)
+#pragma pack(push,1)
 struct PingStruct
 {
 	unsigned char typeId; // ID_PING or ID_PONG
 	unsigned long sendPingTime;
 	unsigned long sendPongTime;
 };
+#pragma pack(pop)
 
-#pragma pack(1)
+#pragma pack(push,1)
 struct UnconnectedPingStruct
 {
 	unsigned char typeId; // ID_PING or ID_PONG
 	unsigned long sendPingTime;
 };
+#pragma pack(pop)
 
 // Timestamp automatically used for this type of packet
-#pragma pack(1)
+
+#pragma pack(push,1)
 struct SetRandomNumberSeedStruct
 {
 	unsigned char ts; // ID_TIMESTAMP
@@ -75,16 +82,18 @@
 	unsigned long seed;
 	unsigned long nextSeed;
 };
+#pragma pack(pop)
 
-#pragma pack(1)
+#pragma pack(push,1)
 struct NewIncomingConnectionStruct
 {
 	unsigned char typeId; // ID_NEW_INCOMING_CONNECTION
 	PlayerID externalID; // We tell the remote system its own IP / port this way
 };
-
 #pragma pack(pop)
 
+
+const PlayerIndex UNASSIGNED_PLAYER_INDEX=65535;
 const PlayerID UNASSIGNED_PLAYER_ID={0xFFFFFFFF, 0xFFFF};
 const ObjectID UNASSIGNED_OBJECT_ID=65535;
 const int PING_TIMES_ARRAY_SIZE=5;

Modified: branches/multiplayer-branch/source/libraries/raknet/PacketEnumerations.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/PacketEnumerations.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/PacketEnumerations.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -18,12 +18,12 @@
 	// Ignore these:
 	ID_PING, // Ping (internal use only)
 	ID_PONG, // Pong.  Returned if we ping a system we are not connected so
+	ID_PING_OPEN_CONNECTIONS, // Only reply to the unconnected ping if we have open connections
 	ID_REQUEST_STATIC_DATA, // Someone asked for our static data (internal use only)
 	ID_CONNECTION_REQUEST, // Asking for a new connection (internal use only)
 	ID_SECURED_CONNECTION_RESPONSE, // Connecting to a secured server/peer
 	ID_SECURED_CONNECTION_CONFIRMATION, // Connecting to a secured server/peer
 	ID_RPC, // Remote procedure call (internal use only)
-	ID_RECEIVED_RELAYED_STATIC_DATA, // Server / Client only - Sending the static data for another system (internal use only)
 	ID_BROADCAST_PINGS, // Server / Client only - The server is broadcasting the pings of all players in the game (internal use only)
 	ID_SET_RANDOM_NUMBER_SEED, // Server / Client only - The server is broadcasting a random number seed (internal use only)
 	ID_RPC_WITH_TIMESTAMP, // Same as RPC, but treat the first 4 bytes as a timestamp
@@ -33,13 +33,14 @@
 	ID_REMOTE_CONNECTION_LOST, // [CLIENT] In a client/server enviroment, a client other than ourselves has been forcefully dropped.  Packet::playerID is modified to reflect the playerID of this client.
 	ID_REMOTE_NEW_INCOMING_CONNECTION, // [CLIENT] In a client/server enviroment, a client other than ourselves has connected.  Packet::playerID is modified to reflect the playerID of this client.
 	ID_REMOTE_EXISTING_CONNECTION, // [CLIENT] On our initial connection to the server, we are told of every other client in the game.  Packet::playerID is modified to reflect the playerID of this client.
+	ID_REMOTE_STATIC_DATA, // [CLIENT] - Got the data for another client
 	ID_CONNECTION_BANNED, // [PEER|CLIENT] We are banned from the system we attempted to connect to.
 	ID_CONNECTION_REQUEST_ACCEPTED, // [CLIENT] In a client/server enviroment, our connection request to the server has been accepted.
 	ID_NEW_INCOMING_CONNECTION, // [PEER|SERVER] A remote system has successfully connected.
 	ID_NO_FREE_INCOMING_CONNECTIONS, // [PEER|CLIENT] The system we attempted to connect to is not accepting new connections.
 	ID_DISCONNECTION_NOTIFICATION, // [PEER|SERVER|CLIENT] The system specified in Packet::playerID has disconnected from us.  For the client, this would mean the server has shutdown.
 	ID_CONNECTION_LOST, // [PEER|SERVER|CLIENT] Reliable packets cannot be delivered to the system specifed in Packet::playerID.  The connection to that system has been closed.
-	ID_TIMESTAMP, // [PEER|SERVER|CLIENT] The four bytes following this byte represent an unsigned long which is automatically modified by the difference in system times between the sender and the recipient.
+	ID_TIMESTAMP, // [PEER|SERVER|CLIENT] The four bytes following this byte represent an unsigned long which is automatically modified by the difference in system times between the sender and the recipient. Requires that you call StartOccasionalPing.
 	ID_RECEIVED_STATIC_DATA, // [PEER|SERVER|CLIENT] We got a bitstream containing static data.  You can now read this data.  This packet is transmitted automatically on connections, and can also be manually sent.
 	ID_INVALID_PASSWORD, // [PEER|CLIENT] The remote system is using a password and has refused our connection because we did not set the correct password.
 	ID_MODIFIED_PACKET, // [PEER|SERVER|CLIENT] A packet has been tampered with in transit.  The sender is contained in Packet::playerID.
@@ -57,7 +58,6 @@
 	ID_MASTER_SERVER_DELIST_SERVER, // [MASTERSERVER] Remove a game server from the master server.
 	ID_MASTER_SERVER_UPDATE_SERVER, // [MASTERSERVER|MASTERCLIENT] Add or update the information for a server.
 	ID_MASTER_SERVER_SET_SERVER, // [MASTERSERVER|MASTERCLIENT] Add or set the information for a server.
-	ID_RESERVED2, // For future versions
 	ID_RESERVED3, // For future versions
 	ID_RESERVED4, // For future versions
 	ID_RESERVED5, // For future versions
@@ -74,6 +74,7 @@
 	// In the unlikely event that you need more than 256 types, including the built-in types, then you'll need
 	// to request a special edition with larger identifiers, or change it yourself
 	//
+    ID_PRESENCE_CREATION,
 
 
 

Modified: branches/multiplayer-branch/source/libraries/raknet/PacketPriority.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/PacketPriority.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/PacketPriority.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -12,6 +12,7 @@
 
 enum PacketPriority
 {
+	SYSTEM_PRIORITY, // System priority is for system related messaging.  Don't use it.
 	HIGH_PRIORITY,
 	MEDIUM_PRIORITY,
 	LOW_PRIORITY,

Modified: branches/multiplayer-branch/source/libraries/raknet/Queue.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/Queue.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/Queue.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -29,6 +29,8 @@
 This function doubles the amount of memory allocated when the queue is filled
 This is better than the linked list version for a queue that doesn't go from one extreme to the other with size changes.
 
+9/04 Giblet - commented out body of compress() function, as it is invalid and breaks newer compilers
+
 */
 
 #ifndef __QUEUE_H
@@ -209,7 +211,7 @@
 		array = new queue_type [original_copy.size()+1];
 
 		for (unsigned long counter=0L; counter < original_copy.size(); ++counter)
-			array[counter] = original_copy.array[(original_copy.head + counter)%(orignal_copy.allocation_size)];
+			array[counter] = original_copy.array[(original_copy.head + counter)%(original_copy.allocation_size)];
 			
 		head=0L;
 		tail=original_copy.size();
@@ -255,7 +257,7 @@
 template <class queue_type>
 void Queue<queue_type>::compress (void)
 {
-		queue_type* new_array;
+		/*queue_type* new_array;
 
 		if (allocation_size==0) return;
 
@@ -273,7 +275,7 @@
 		
 		// Delete the old array and move the pointer to the new array
 		delete []array;
-		array=new_array;
+		array=new_array;*/
 }
 
 template <class queue_type>

Added: branches/multiplayer-branch/source/libraries/raknet/RSACrypt.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/RSACrypt.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/RSACrypt.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -0,0 +1,1095 @@
+/*
+	Performant RSA en/decryption with 256-bit to 16384-bit modulus
+
+	catid(cat02e at fsu.edu)
+
+	7/30/2004	Fixed VS6 compat
+	7/26/2004	Now internally generates private keys
+				simpleModExp() is faster for encryption than MontyModExp
+				CRT-MontyModExp is faster for decryption than CRT-SimpleModExp
+	7/25/2004	Implemented Montgomery modular exponentation
+				Implemented CRT modular exponentation optimization
+	7/21/2004	Did some pre-lim coding
+
+	Best performance on my 1.8 GHz P4 (mobile):
+		1024-bit generate key : 30 seconds
+		1024-bit set private key : 100 ms (pre-compute this step)
+		1024-bit encryption : 200 usec
+		1024-bit decryption : 400 ms
+
+	TODO
+		There's a bug in MonModExp() that restricts us to k-1 bits
+
+	Tabs: 4 spaces
+	Dist: public
+*/
+
+#ifndef RSACRYPT_H
+#define RSACRYPT_H
+
+#define RSASUPPORTGENPRIME
+
+// Can't go under 256 or you'll need to disable the USEASSEMBLY macro in bigtypes.h
+// That's because the assembly assumes at least 128-bit data to work on
+// #define RSA_BIT_SIZE big::u512
+#define RSA_BIT_SIZE big::u256
+
+#include "BigTypes.h"
+#include "Rand.h"	//Giblet - added missing include for randomMT()
+
+namespace big
+{
+	using namespace cat;
+
+	// r = x^y Mod n (fast for small y)
+	BIGONETYPE void simpleModExp(T &x0, T &y0, T &n0, T &r0)
+	{
+		BIGDOUBLESIZE(T, x);
+		BIGDOUBLESIZE(T, y);
+		BIGDOUBLESIZE(T, n);
+		BIGDOUBLESIZE(T, r);
+
+		usetlow(x, x0);
+		usetlow(y, y0);
+		usetlow(n, n0);
+		usetw(r, 1);
+
+		umodulo(x, n, x);
+
+		u32 squares = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			word y_i = y[ii];
+
+			u32 ctr = WORDBITS;
+
+			while (y_i)
+			{
+				if (y_i & 1)
+				{
+					if (squares) do
+					{
+						usquare(x);
+						umodulo(x, n, x);
+					} while (--squares);
+
+					umultiply(r, x, r);
+					umodulo(r, n, r);
+				}
+
+				y_i >>= 1;
+				++squares;
+				--ctr;
+			}
+
+			squares += ctr;
+		}
+
+		takelow(r0, r);
+	}
+
+	// computes Rn = 2^k (mod n), n < 2^k
+	BIGONETYPE void rModn(T &n, T &Rn)
+	{
+		BIGDOUBLESIZE(T, dR);
+		BIGDOUBLESIZE(T, dn);
+		BIGDOUBLESIZE(T, dRn);
+		T one;
+
+		// dR = 2^k
+		usetw(one, 1);
+		sethigh(dR, one);
+
+		// Rn = 2^k (mod n)
+		usetlow(dn, n);
+		umodulo(dR, dn, dRn);
+		takelow(Rn, dRn);
+	}
+
+	// computes c = GCD(a, b)
+	BIGONETYPE void GCD(T &a0, T &b0, T &c)
+	{
+		T a;
+
+		umodulo(a0, b0, c);
+
+		if (isZero(c))
+		{
+			set(c, b0);
+			return;
+		}
+
+		umodulo(b0, c, a);
+
+		if (isZero(a))
+			return;
+
+		while (true)
+		{
+			umodulo(c, a, c);
+
+			if (isZero(c))
+			{
+				set(c, a);
+				return;
+			}
+
+			umodulo(a, c, a);
+
+			if (isZero(a))
+				return;
+		}
+	}
+
+	// directly computes x = c - a * b (mod n) > 0, c < n
+	BIGONETYPE void SubMulMod(T &a, T &b, T &c, T &n, T &x)
+	{
+		BIGDOUBLESIZE(T, da);
+		BIGDOUBLESIZE(T, dn);
+		T y;
+
+		// y = a b (mod n)
+		usetlow(da, a);
+		umultiply(da, b);
+		usetlow(dn, n);
+		umodulo(da, dn, da);
+		takelow(y, da);
+
+		// x = (c - y) (mod n) > 0
+		set(x, c);
+		if (ugreater(c, y))
+		{
+			subtract(x, y);
+		}
+		else
+		{
+			subtract(x, y);
+			add(x, n);
+		}
+	}
+
+	/*
+		directly compute  a' s.t. a' a - b' b = 1
+
+		b = b0 = n0
+		rp = a'
+		a = 2^k
+		a > b > 0
+		GCD(a, b) = 1 (b odd)
+
+		Trying to keep everything positive
+	*/
+	BIGONETYPE void computeRinverse(T &n0, T &rp)
+	{
+		T x0, x1, x2, a, b, q;
+
+		//x[0] = 1
+		usetw(x0, 1);
+
+		// a = 2^k (mod b0)
+		rModn(n0, a);
+
+		// {q, b} = b0 / a
+		udivide(n0, a, q, b);
+
+		// if b = 0, return x[0]
+		if (isZero(b))
+		{
+			set(rp, x0);
+			return;
+		}
+
+		// x[1] = -q (mod b0) = b0 - q, q <= b0
+		set(x1, n0);
+		subtract(x1, q);
+
+		// {q, a} = a / b
+		udivide(a, b, q, a);
+
+		// if a = 0, return x[1]
+		if (isZero(a))
+		{
+			set(rp, x1);
+			return;
+		}
+
+		while (true)
+		{
+			// x[2] = x[0] - x[1] * q (mod b0)
+			SubMulMod(q, x1, x0, n0, x2);
+
+			// {q, b} = b / a
+			udivide(b, a, q, b);
+
+			// if b = 0, return x[2]
+			if (isZero(b))
+			{
+				set(rp, x2);
+				return;
+			}
+
+			// x[0] = x[1] - x[2] * q (mod b0)
+			SubMulMod(q, x2, x1, n0, x0);
+
+			// {q, a} = a / b
+			udivide(a, b, q, a);
+
+			// if a = 0, return x[0]
+			if (isZero(a))
+			{
+				set(rp, x0);
+				return;
+			}
+
+			// x[1] = x[2] - x[0] * q (mod b0)
+			SubMulMod(q, x0, x2, n0, x1);
+
+			// {q, b} = b / a
+			udivide(b, a, q, b);
+
+			// if b = 0, return x[1]
+			if (isZero(b))
+			{
+				set(rp, x1);
+				return;
+			}
+
+			// x[2] = x[0] - x[1] * q (mod b0)
+			SubMulMod(q, x1, x0, n0, x2);
+
+			// {q, a} = a / b
+			udivide(a, b, q, a);
+
+			// if a = 0, return x[2]
+			if (isZero(a))
+			{
+				set(rp, x2);
+				return;
+			}
+
+			// x[0] = x[1] - x[2] * q (mod b0)
+			SubMulMod(q, x2, x1, n0, x0);
+
+			// {q, b} = b / a
+			udivide(b, a, q, b);
+
+			// if b = 0, return x[0]
+			if (isZero(b))
+			{
+				set(rp, x0);
+				return;
+			}
+
+			// x[1] = x[2] - x[0] * q (mod b0)
+			SubMulMod(q, x0, x2, n0, x1);
+
+			// {q, a} = a / b
+			udivide(a, b, q, a);
+
+			// if a = 0, return x[1]
+			if (isZero(a))
+			{
+				set(rp, x1);
+				return;
+			}
+		}
+	}
+/*	BIGONETYPE void computeRinverse2(T &_n0, T &_rp)
+	{
+		//T x0, x1, x2, a, b, q;
+		BIGDOUBLESIZE(T, x0);
+		BIGDOUBLESIZE(T, x1);
+		BIGDOUBLESIZE(T, x2);
+		BIGDOUBLESIZE(T, a);
+		BIGDOUBLESIZE(T, b);
+		BIGDOUBLESIZE(T, q);
+		BIGDOUBLESIZE(T, n0);
+		BIGDOUBLESIZE(T, rp);
+
+		usetlow(n0, _n0);
+		usetlow(rp, _rp);
+
+std::string old;
+		//x[0] = 1
+		usetw(x0, 1);
+
+		T _a;
+		// a = 2^k (mod b0)
+		rModn(_n0, _a);
+RECORD("TEST") << "a=" << toString(a, false) << " = 2^k (mod " << toString(n0, false) << ")";
+		usetlow(a, _a);
+
+		// {q, b} = b0 / a
+		udivide(n0, a, q, b);
+RECORD("TEST") << "{q=" << toString(q, false) << ", b=" << toString(b, false) << "} = n0=" << toString(n0, false) << " / a=" << toString(a, false);
+
+		// if b = 0, return x[0]
+		if (isZero(b))
+		{
+RECORD("TEST") << "b == 0, Returning x[0]";
+			set(rp, x0);
+			takelow(_rp, rp);
+			return;
+		}
+
+		// x[1] = -q (mod b0)
+		negate(q);
+		smodulo(q, n0, x1);
+		if (BIGHIGHBIT(x1))
+			add(x1, n0); // q > 0
+RECORD("TEST") << "x1=" << toString(x1, false) << " = q=" << toString(q, false) << " (mod n0=" << toString(n0, false) << ")";
+
+		// {q, a} = a / b
+old = toString(a, false);
+		udivide(a, b, q, a);
+RECORD("TEST") << "{q=" << toString(q, false) << ", a=" << toString(a, false) << "} = a=" << old << " / b=" << toString(b);
+
+		// if a = 0, return x[1]
+		if (isZero(a))
+		{
+RECORD("TEST") << "a == 0, Returning x[1]";
+			set(rp, x1);
+			takelow(_rp, rp);
+			return;
+		}
+
+RECORD("TEST") << "Entering loop...";
+		while (true)
+		{
+			// x[2] = x[0] - x[1] * q (mod b0)
+			SubMulMod(q, x1, x0, n0, x2);
+RECORD("TEST") << "x[0] = " << toString(x0, false);
+RECORD("TEST") << "x[1] = " << toString(x1, false);
+RECORD("TEST") << "x[2] = " << toString(x2, false);
+
+			// {q, b} = b / a
+old = toString(b);
+			udivide(b, a, q, b);
+RECORD("TEST") << "{q=" << toString(q, false) << ", b=" << toString(b) << "} = b=" << old << " / a=" << toString(a, false);
+
+			// if b = 0, return x[2]
+			if (isZero(b))
+			{
+RECORD("TEST") << "b == 0, Returning x[2]";
+				set(rp, x2);
+				takelow(_rp, rp);
+				return;
+			}
+
+			// x[0] = x[1] - x[2] * q (mod b0)
+			SubMulMod(q, x2, x1, n0, x0);
+RECORD("TEST") << "x[0] = " << toString(x0, false);
+RECORD("TEST") << "x[1] = " << toString(x1, false);
+RECORD("TEST") << "x[2] = " << toString(x2, false);
+
+			// {q, a} = a / b
+old = toString(a, false);
+			udivide(a, b, q, a);
+RECORD("TEST") << "{q=" << toString(q, false) << ", a=" << toString(a, false) << "} = a=" << old << " / b=" << toString(b);
+
+			// if a = 0, return x[0]
+			if (isZero(a))
+			{
+RECORD("TEST") << "a == 0, Returning x[0]";
+				set(rp, x0);
+				takelow(_rp, rp);
+				return;
+			}
+
+			// x[1] = x[2] - x[0] * q (mod b0)
+			SubMulMod(q, x0, x2, n0, x1);
+RECORD("TEST") << "x[0] = " << toString(x0, false);
+RECORD("TEST") << "x[1] = " << toString(x1, false);
+RECORD("TEST") << "x[2] = " << toString(x2, false);
+
+			// {q, b} = b / a
+old = toString(b);
+			udivide(b, a, q, b);
+RECORD("TEST") << "{q=" << toString(q, false) << ", b=" << toString(b) << "} = b=" << old << " / a=" << toString(a, false);
+
+			// if b = 0, return x[1]
+			if (isZero(b))
+			{
+RECORD("TEST") << "b == 0, Returning x[1]";
+				set(rp, x1);
+				takelow(_rp, rp);
+				return;
+			}
+
+			// x[2] = x[0] - x[1] * q (mod b0)
+			SubMulMod(q, x1, x0, n0, x2);
+RECORD("TEST") << "x[0] = " << toString(x0, false);
+RECORD("TEST") << "x[1] = " << toString(x1, false);
+RECORD("TEST") << "x[2] = " << toString(x2, false);
+
+			// {q, a} = a / b
+old = toString(a, false);
+			udivide(a, b, q, a);
+RECORD("TEST") << "{q=" << toString(q, false) << ", a=" << toString(a, false) << "} = a=" << old << " / b=" << toString(b);
+
+			// if a = 0, return x[2]
+			if (isZero(a))
+			{
+RECORD("TEST") << "a == 0, Returning x[2]";
+				set(rp, x2);
+				takelow(_rp, rp);
+				return;
+			}
+
+			// x[0] = x[1] - x[2] * q (mod b0)
+			SubMulMod(q, x2, x1, n0, x0);
+RECORD("TEST") << "x[0] = " << toString(x0, false);
+RECORD("TEST") << "x[1] = " << toString(x1, false);
+RECORD("TEST") << "x[2] = " << toString(x2, false);
+
+			// {q, b} = b / a
+old = toString(b);
+			udivide(b, a, q, b);
+RECORD("TEST") << "{q=" << toString(q, false) << ", b=" << toString(b) << "} = b=" << old << " / a=" << toString(a, false);
+
+			// if b = 0, return x[0]
+			if (isZero(b))
+			{
+RECORD("TEST") << "b == 0, Returning x[0]";
+				set(rp, x0);
+				takelow(_rp, rp);
+				return;
+			}
+
+			// x[1] = x[2] - x[0] * q (mod b0)
+			SubMulMod(q, x0, x2, n0, x1);
+RECORD("TEST") << "x[0] = " << toString(x0, false);
+RECORD("TEST") << "x[1] = " << toString(x1, false);
+RECORD("TEST") << "x[2] = " << toString(x2, false);
+
+			// {q, a} = a / b
+old = toString(a, false);
+			udivide(a, b, q, a);
+RECORD("TEST") << "{q=" << toString(q, false) << ", a=" << toString(a, false) << "} = a=" << old << " / b=" << toString(b);
+
+			// if a = 0, return x[1]
+			if (isZero(a))
+			{
+RECORD("TEST") << "a == 0, Returning x[1]";
+				set(rp, x1);
+				takelow(_rp, rp);
+				return;
+			}
+		}
+	}
+*/
+	// directly compute a^-1 s.t. a^-1 a (mod b) = 1, a < b, GCD(a, b)
+	BIGONETYPE void computeModularInverse(T &a0, T &b0, T &ap)
+	{
+		T x0, x1, x2;
+		T a, b, q;
+
+		// x[2] = 1
+		usetw(x2, 1);
+
+		// {q, b} = b0 / a0
+		udivide(b0, a0, q, b);
+
+		// x[0] = -q (mod b0) = b0 - q, q <= b0
+		set(x0, b0);
+		subtract(x0, q);
+
+		set(a, a0);
+
+		while (true)
+		{
+			// {q, a} = a / b
+			udivide(a, b, q, a);
+
+			// if a = 0, return x[0]
+			if (isZero(a))
+			{
+				set(ap, x0);
+				return;
+			}
+
+			// x[1] = x[2] - x[0] * q (mod b0)
+			SubMulMod(x0, q, x2, b0, x1);
+
+			// {q, b} = b / a
+			udivide(b, a, q, b);
+
+			// if b = 0, return x[1]
+			if (isZero(b))
+			{
+				set(ap, x1);
+				return;
+			}
+
+			// x[2] = x[0] - x[1] * q (mod b0)
+			SubMulMod(x1, q, x0, b0, x2);
+
+			// {q, a} = a / b
+			udivide(a, b, q, a);
+
+			// if a = 0, return x[2]
+			if (isZero(a))
+			{
+				set(ap, x2);
+				return;
+			}
+
+			// x[0] = x[1] - x[2] * q (mod b0)
+			SubMulMod(x2, q, x1, b0, x0);
+
+			// {q, b} = b / a
+			udivide(b, a, q, b);
+
+			// if b = 0, return x[0]
+			if (isZero(b))
+			{
+				set(ap, x0);
+				return;
+			}
+
+			// x[1] = x[2] - x[0] * q (mod b0)
+			SubMulMod(x0, q, x2, b0, x1);
+
+			// {q, a} = a / b
+			udivide(a, b, q, a);
+
+			// if a = 0, return x[1]
+			if (isZero(a))
+			{
+				set(ap, x1);
+				return;
+			}
+
+			// x[2] = x[0] - x[1] * q (mod b0)
+			SubMulMod(x1, q, x0, b0, x2);
+
+			// {q, b} = b / a
+			udivide(b, a, q, b);
+
+			// if b = 0, return x[2]
+			if (isZero(b))
+			{
+				set(ap, x2);
+				return;
+			}
+
+			// x[0] = x[1] - x[2] * q (mod b0)
+			SubMulMod(x2, q, x1, b0, x0);
+		}
+	}
+
+	// indirectly computes  n' s.t. 1 = r' r - n' n = GCD(r, n)
+	BIGONETYPE void computeNRinverse(T &n0, T &np)
+	{
+		BIGDOUBLESIZE(T, r);
+		BIGDOUBLESIZE(T, n);
+
+		// r' = (1 + n' n) / r
+		computeRinverse(n0, np);
+
+		// n' = (r' r - 1) / n
+		sethigh(r, np); // special case of r = 2^k
+		decrement(r);
+		usetlow(n, n0);
+		udivide(r, n, n, r);
+		takelow(np, n);
+	}
+/*
+	// indirectly computes  n' s.t. 1 = r' r - n' n = GCD(r, n)
+	BIGONETYPE void computeNRinverse2(T &n0, T &np)
+	{
+		BIGDOUBLESIZE(T, r);
+		BIGDOUBLESIZE(T, n);
+
+		// r' = (1 + n' n) / r
+		computeRinverse2(n0, np);
+
+		// n' = (r' r - 1) / n
+		sethigh(r, np); // special case of r = 2^k
+		decrement(r);
+		usetlow(n, n0);
+		udivide(r, n, n, r);
+		takelow(np, n);
+	}
+*/
+	// Montgomery product u = a * b (mod n)
+	BIGONETYPE void MonPro(T &ap, T &bp, T &n, T &np, T &u_out)
+	{
+		BIGDOUBLESIZE(T, t);
+		BIGDOUBLESIZE(T, u);
+		T m;
+
+		// t = a' b'
+		umultiply(ap, bp, t);
+
+		// m = (low half of t)*np (mod r)
+		takelow(m, t);
+		umultiply(m, np);
+
+		// u = (t + m*n), u_out = u / r = high half of u
+		umultiply(m, n, u);
+		add(u, t);
+		takehigh(u_out, u);
+
+		// if u >= n, return u - n, else u
+		if (ugreaterOrEqual(u_out, n))
+			subtract(u_out, n);
+	}
+
+	// indirectly calculates x = M^e (mod n)
+	BIGONETYPE void MonModExp(T &x, T &M, T &e, T &n, T &np, T &xp0)
+	{
+		// x' = xp0
+		set(x, xp0);
+
+		// find M' = M r (mod n)
+		BIGDOUBLESIZE(T, dM);
+		BIGDOUBLESIZE(T, dn);
+		T Mp;
+		sethigh(dM, M); // dM = M r
+		usetlow(dn, n);
+		umodulo(dM, dn, dM); // dM = dM (mod n)
+		takelow(Mp, dM); // M' = M r (mod n)
+
+		/*
+			i may be wrong, but it seems to me that the squaring
+			results in a constant until we hit the first set bit
+			this could save a lot of time, but it needs to be proven
+		*/
+
+		s32 ii, bc;
+		word e_i;
+
+		// for i = k - 1 down to 0 do
+		for (ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+		{
+			e_i = e[ii];
+			bc = WORDBITS;
+
+			while (bc--)
+			{
+				// if e_i = 1, x = MonPro(M', x')
+				if (e_i & WORDHIGHBIT)
+					goto start_squaring;
+
+				e_i <<= 1;
+			}
+		}
+
+		for (; ii >= 0; --ii)
+		{
+			e_i = e[ii];
+			bc = WORDBITS;
+
+			while (bc--)
+			{
+				// x' = MonPro(x', x')
+				MonPro(x, x, n, np, x);
+
+				// if e_i = 1, x = MonPro(M', x')
+				if (e_i & WORDHIGHBIT)
+				{
+start_squaring:
+					MonPro(Mp, x, n, np, x);
+				}
+
+				e_i <<= 1;
+			}
+		}
+
+		// x = MonPro(x', 1)
+		T one;
+		usetw(one, 1);
+		MonPro(x, one, n, np, x);
+	}
+
+	// indirectly calculates x = C ^ d (mod n) using the Chinese Remainder Thm
+	BIGTWOTYPES void CRTModExp(Bigger &x, Bigger &C, Bigger &d, T &p, T &q, T &pInverse, T &pnp, T &pxp, T &qnp, T &qxp)
+	{
+		// d1 = d mod (p - 1)
+		Bigger dd1;
+		T d1;
+		usetlow(dd1, p);
+		decrement(dd1);
+		umodulo(d, dd1, dd1);
+		takelow(d1, dd1);
+
+		// M1 = C1^d1 (mod p)
+		Bigger dp, dC1;
+		T M1, C1;
+		usetlow(dp, p);
+		umodulo(C, dp, dC1);
+		takelow(C1, dC1);
+		simpleModExp(C1, d1, p, M1);
+		//MonModExp(M1, C1, d1, p, pnp, pxp);
+
+		// d2 = d mod (q - 1)
+		Bigger dd2;
+		T d2;
+		usetlow(dd2, q);
+		decrement(dd2);
+		umodulo(d, dd2, dd2);
+		takelow(d2, dd2);
+
+		// M2 = C2^d2 (mod q)
+		Bigger dq, dC2;
+		T M2, C2;
+		usetlow(dq, q);
+		umodulo(C, dq, dC2);
+		takelow(C2, dC2);
+		simpleModExp(C2, d2, q, M2);
+		//MonModExp(M2, C2, d2, q, qnp, qxp);
+
+		// x = M1 + p * ((M2 - M1)(p^-1 mod q) mod q)
+
+		if (ugreater(M2, M1))
+		{
+			subtract(M2, M1);
+		}
+		else
+		{
+			subtract(M2, M1);
+			add(M2, q);
+		}
+
+		// x = M1 + p * (( M2 )(p^-1 mod q) mod q)
+
+		umultiply(M2, pInverse, x);
+
+		// x = M1 + p * (( x ) mod q)
+
+		umodulo(x, dq, x);
+
+		// x = M1 + p * ( x )
+
+		umultiply(x, dp);
+
+		// x = M1 + ( x )
+
+		Bigger dM1;
+		usetlow(dM1, M1);
+
+		// x = ( dM1 ) + ( x )
+
+		add(x, dM1);
+	}
+
+	// generates a suitable public exponent s.t. 4 < e << phi, GCD(e, phi) = 1
+	BIGONETYPE void computePublicExponent(T &phi, T &e)
+	{
+		T r, one, two;
+		usetw(one, 1);
+		usetw(two, 2);
+		usetw(e, 65537 - 2);
+
+		if (ugreater(e, phi))
+			usetw(e, 5 - 2);
+
+		do
+		{
+			add(e, two);
+
+			GCD(phi, e, r);
+		} while (!equal(r, one));
+	}
+
+	// directly computes private exponent
+	BIGONETYPE void computePrivateExponent(T &e, T &phi, T &d)
+	{
+		// d = e^-1 (mod phi), 1 < e << phi
+		computeModularInverse(e, phi, d);
+	}
+
+#ifdef RSASUPPORTGENPRIME
+
+	static const u16 PRIME_TABLE[256] = {
+		   3,         5,         7,        11,        13,        17,        19,        23,
+		  29,        31,        37,        41,        43,        47,        53,        59,
+		  61,        67,        71,        73,        79,        83,        89,        97,
+		 101,       103,       107,       109,       113,       127,       131,       137,
+		 139,       149,       151,       157,       163,       167,       173,       179,
+		 181,       191,       193,       197,       199,       211,       223,       227,
+		 229,       233,       239,       241,       251,       257,       263,       269,
+		 271,       277,       281,       283,       293,       307,       311,       313,
+		 317,       331,       337,       347,       349,       353,       359,       367,
+		 373,       379,       383,       389,       397,       401,       409,       419,
+		 421,       431,       433,       439,       443,       449,       457,       461,
+		 463,       467,       479,       487,       491,       499,       503,       509,
+		 521,       523,       541,       547,       557,       563,       569,       571,
+		 577,       587,       593,       599,       601,       607,       613,       617,
+		 619,       631,       641,       643,       647,       653,       659,       661,
+		 673,       677,       683,       691,       701,       709,       719,       727,
+		 733,       739,       743,       751,       757,       761,       769,       773,
+		 787,       797,       809,       811,       821,       823,       827,       829,
+		 839,       853,       857,       859,       863,       877,       881,       883,
+		 887,       907,       911,       919,       929,       937,       941,       947,
+		 953,       967,       971,       977,       983,       991,       997,      1009,
+		1013,      1019,      1021,      1031,      1033,      1039,      1049,      1051,
+		1061,      1063,      1069,      1087,      1091,      1093,      1097,      1103,
+		1109,      1117,      1123,      1129,      1151,      1153,      1163,      1171,
+		1181,      1187,      1193,      1201,      1213,      1217,      1223,      1229,
+		1231,      1237,      1249,      1259,      1277,      1279,      1283,      1289,
+		1291,      1297,      1301,      1303,      1307,      1319,      1321,      1327,
+		1361,      1367,      1373,      1381,      1399,      1409,      1423,      1427,
+		1429,      1433,      1439,      1447,      1451,      1453,      1459,      1471,
+		1481,      1483,      1487,      1489,      1493,      1499,      1511,      1523,
+		1531,      1543,      1549,      1553,      1559,      1567,      1571,      1579,
+		1583,      1597,      1601,      1607,      1609,      1613,      1619,      1621
+	};
+
+	/*
+		modified Rabin-Miller primality test (added small primes)
+
+		When picking a value for insurance, note that the probability of failure
+		of the test to detect a composite number is at most 4^(-insurance), so:
+		insurance	max. probability of failure
+		3			1.56%
+		4			0.39%
+		5			0.098% <-- default
+		6			0.024%
+		...
+	*/
+	BIGONETYPE bool RabinMillerPrimalityTest(T &n, u32 insurance)
+	{
+		// check divisibility by small primes <= 1621 (speeds up computation)
+		T temp;
+		for (u32 ii = 0; ii < 256; ++ii)
+		{
+			usetw(temp, PRIME_TABLE[ii++]);
+
+			umodulo(n, temp, temp);
+
+			if (isZero(temp))
+				return false;
+		}
+
+		// n1 = n - 1
+		T n1;
+		set(n1, n);
+		decrement(n1);
+
+		// write r 2^s = n - 1, r is odd
+		T r;
+		u32 s = 0;
+		set(r, n1);
+		while (!(r[0] & 1))
+		{
+			ushiftRight1(r);
+			++s;
+		}
+
+		// one = 1
+		T one;
+		usetw(one, 1);
+
+		// cache n -> dn
+		BIGDOUBLESIZE(T, dy);
+		BIGDOUBLESIZE(T, dn);
+		usetlow(dn, n);
+
+		while (insurance--)
+		{
+		// choose random integer a s.t. 1 < a < n - 1
+			T a;
+			int index;
+			for (index=0; index < sizeof(a)/sizeof(a[0]); index++)
+				a[index]=randomMT();
+			umodulo(a, n1, a);
+
+			// compute y = a ^ r (mod n)
+			T y;
+			simpleModExp(a, r, n, y);
+
+			if (!equal(y, one) && !equal(y, n1))
+			{
+				u32 j = s;
+				while ((j-- > 1) && !equal(y, n1))
+				{
+					umultiply(y, y, dy);
+					umodulo(dy, dn, dy);
+					takelow(y, dy);
+
+					if (equal(y, one)) return false;
+				}
+
+				if (!equal(y, n1)) return false;
+			}
+		}
+
+		return true;
+	}
+
+	// generates a strong pseudo-prime
+	BIGONETYPE void generateStrongPseudoPrime(T &n)
+	{
+		do {
+			int index;
+			for (index=0; index < sizeof(n)/sizeof(n[0]); index++)
+				n[index]=randomMT();
+			n[BIGWORDCOUNT(T) - 1] |= WORDHIGHBIT;
+			//n[BIGWORDCOUNT(T) - 1] &= ~WORDHIGHBIT; n[BIGWORDCOUNT(T) - 1] |= WORDHIGHBIT >> 1;
+			n[0] |= 1;
+		} while (!RabinMillerPrimalityTest(n, 5));
+	}
+
+#endif // RSASUPPORTGENPRIME
+
+
+	//////// RSACrypt class ////////
+
+	BIGONETYPE class RSACrypt
+	{
+		// public key
+		T e, n;
+		T np, xp;
+
+		// private key
+		bool factorsAvailable;
+		T d, phi;
+		BIGHALFSIZE(T, p);
+		BIGHALFSIZE(T, pnp);
+		BIGHALFSIZE(T, pxp);
+		BIGHALFSIZE(T, q);
+		BIGHALFSIZE(T, qnp);
+		BIGHALFSIZE(T, qxp);
+		BIGHALFSIZE(T, pInverse);
+
+	public:
+		RSACrypt()
+		{
+			reset();
+		}
+		~RSACrypt()
+		{
+			reset();
+		}
+
+	public:
+		void reset()
+		{
+			zero(d);
+			zero(p);
+			zero(q);
+			zero(pInverse);
+			factorsAvailable = false;
+		}
+
+#ifdef RSASUPPORTGENPRIME
+
+		void generateKeys()
+		{
+			BIGHALFSIZE(T, p0);
+			BIGHALFSIZE(T, q0);
+
+			generateStrongPseudoPrime(p0);
+			generateStrongPseudoPrime(q0);
+
+			setPrivateKey(p0, q0);
+		}
+
+#endif // RSASUPPORTGENPRIME
+
+		BIGSMALLTYPE void setPrivateKey(Smaller &c_p, Smaller &c_q)
+		{
+			factorsAvailable = true;
+
+			// re-order factors s.t. q > p
+			if (ugreater(c_p, c_q))
+			{
+				set(q, c_p);
+				set(p, c_q);
+			}
+			else
+			{
+				set(p, c_p);
+				set(q, c_q);
+			}
+
+			// phi = (p - 1)(q - 1)
+			BIGHALFSIZE(T, p1);
+			BIGHALFSIZE(T, q1);
+			set(p1, p);
+			decrement(p1);
+			set(q1, q);
+			decrement(q1);
+			umultiply(p1, q1, phi);
+
+			// compute e
+			computePublicExponent(phi, e);
+
+			// compute d
+			computePrivateExponent(e, phi, d);
+
+			// compute p^-1 mod q
+			computeModularInverse(p, q, pInverse);
+
+			// compute n = pq
+			umultiply(p, q, n);
+
+			// find n'
+			computeNRinverse(n, np);
+
+			// x' = 1*r (mod n)
+			rModn(n, xp);
+
+			// find pn'
+			computeNRinverse(p, pnp);
+//			computeNRinverse2(p, pnp);
+
+			// px' = 1*r (mod p)
+			rModn(p, pxp);
+
+			// find qn'
+			computeNRinverse(q, qnp);
+
+			// qx' = 1*r (mod q)
+			rModn(q, qxp);
+		}
+		void setPublicKey(u32 c_e, T &c_n)
+		{
+			reset(); // in case we knew a private key
+
+			usetw(e, c_e);
+			set(n, c_n);
+
+			// find n'
+			computeNRinverse(n, np);
+
+			// x' = 1*r (mod n)
+			rModn(n, xp);
+		}
+
+	public:
+		void getPublicKey(u32 &c_e, T &c_n)
+		{
+			c_e = e[0];
+			set(c_n, n);
+		}
+		BIGSMALLTYPE void getPrivateKey(Smaller &c_p, Smaller &c_q)
+		{
+			set(c_p, p);
+			set(c_q, q);
+		}
+
+	public:
+		void encrypt(T &M, T &x)
+		{
+			if (factorsAvailable)
+				CRTModExp(x, M, e, p, q, pInverse, pnp, pxp, qnp, qxp);
+			else
+				simpleModExp(M, e, n, x);
+		}
+
+		void decrypt(T &C, T &x)
+		{
+			if (factorsAvailable)
+				CRTModExp(x, C, d, p, q, pInverse, pnp, pxp, qnp, qxp);
+		}
+	};
+}
+
+#endif // RSACRYPT_H
+
+
+

Modified: branches/multiplayer-branch/source/libraries/raknet/RakClient.cpp
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/RakClient.cpp	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/RakClient.cpp	2004-10-08 21:41:59 UTC (rev 76)
@@ -28,13 +28,12 @@
 {
 }
 
-bool RakClient::Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, bool highPriorityThreads)
+bool RakClient::Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, int threadSleepTimer)
 {
-	if (highPriorityThreads)
-		RakPeer::Initialize(1, clientPort,1);
-	else
-		RakPeer::Initialize(1, clientPort,0);
+	RakPeer::Disconnect(100L);
 
+	RakPeer::Initialize(1, clientPort,threadSleepTimer);
+
 	if (host[0] < '0' || host[0] > '2')
 	{
 		host = (char*) SocketLayer::Instance()->DomainNameToIP(host);
@@ -52,20 +51,27 @@
 	return RakPeer::Connect(host, serverPort, password, (int)strlen(password));
 }
 
-void RakClient::Disconnect(void)
+void RakClient::Disconnect(unsigned long blockDuration)
 {
-	RakPeer::Disconnect();
+	RakPeer::Disconnect(blockDuration);
 }
 
-void RakClient::InitializeSecurity(unsigned short numberOfBytes, char *RSAe, char *RSAn)
+void RakClient::InitializeSecurity(char *RSAe, char *RSAn)
 {
-	RakPeer::InitializeSecurity(numberOfBytes, 0, RSAe, RSAn);
+	RakPeer::InitializeSecurity(RSAe, RSAn,0,0);
 }
 
 void RakClient::SetPassword(char *_password)
 {
-	_password[19]=0; // Limit the password length
-	RakPeer::SetIncomingPassword(_password, (int)strlen(_password)+1);
+	if (_password)
+	{
+		_password[19]=0; // Limit the password length
+		RakPeer::SetIncomingPassword(_password, (int)strlen(_password)+1);
+	}
+	else
+	{
+		RakPeer::SetIncomingPassword(0, 0);
+	}
 }
 
 bool RakClient::HasPassword(void) const
@@ -73,18 +79,18 @@
 	return password[0]!=0;
 }
 
-bool RakClient::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream)
+bool RakClient::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel)
 {
 	if (remoteSystemList==0)
 		return false;
-	return RakPeer::Send(data, length, priority, reliability, orderingStream, remoteSystemList[0].playerId, false);
+	return RakPeer::Send(data, length, priority, reliability, orderingChannel, remoteSystemList[0].playerId, false);
 }
 
-bool RakClient::Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream)
+bool RakClient::Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel)
 {
 	if (remoteSystemList==0)
 		return false;
-	return RakPeer::Send(bitStream, priority, reliability, orderingStream, remoteSystemList[0].playerId, false);
+	return RakPeer::Send(bitStream, priority, reliability, orderingChannel, remoteSystemList[0].playerId, false);
 }
 
 Packet* RakClient::Receive(void)
@@ -94,10 +100,16 @@
 	// Intercept specific client / server feature packets
 	if (packet)
 	{
-		BitStream bitStream(packet->data, packet->length, false);
+		RakNet::BitStream bitStream((char*)packet->data, packet->length, false);
 		bitStream.IgnoreBits(8); // Ignore identifier
 		int i;
-		if (
+		if (packet->data[0]==ID_CONNECTION_REQUEST_ACCEPTED)
+		{
+			ConnectionAcceptStruct* cas = (ConnectionAcceptStruct*) packet->data;
+			localPlayerIndex = cas->playerIndex;
+			packet->playerIndex=cas->playerIndex;
+		}
+		else if (
 			packet->data[0]==ID_REMOTE_NEW_INCOMING_CONNECTION ||
 			packet->data[0]==ID_REMOTE_EXISTING_CONNECTION ||
 			packet->data[0]==ID_REMOTE_DISCONNECTION_NOTIFICATION ||
@@ -105,29 +117,36 @@
 		{
 			bitStream.Read(packet->playerId.binaryAddress);
 			bitStream.Read(packet->playerId.port);
+			if (bitStream.Read((unsigned short&)packet->playerIndex)==false)
+			{
+				DeallocatePacket(packet);
+				return 0;
+			}
 
-			i = GetOtherClientIndexByPlayerID(packet->playerId);
-			if (i>=0)
-				otherClients[i].isActive=false;
+
+			if (packet->data[0]==ID_REMOTE_DISCONNECTION_NOTIFICATION ||
+				packet->data[0]==ID_REMOTE_CONNECTION_LOST)
+			{
+				i = GetOtherClientIndexByPlayerID(packet->playerId);
+				if (i>=0)
+					otherClients[i].isActive=false;
+			}			
 		}
-		else if (packet->data[0]==ID_RECEIVED_RELAYED_STATIC_DATA)
+		else if (packet->data[0]==ID_REMOTE_STATIC_DATA)
 		{
-			PlayerID staticDataOriginator;
-			bitStream.Read(staticDataOriginator.binaryAddress);
-			bitStream.Read(staticDataOriginator.port);
+			bitStream.Read(packet->playerId.binaryAddress);
+			bitStream.Read(packet->playerId.port);
 
-			i = GetOtherClientIndexByPlayerID(staticDataOriginator);
+			i = GetOtherClientIndexByPlayerID(packet->playerId);
 			if (i < 0)
 				i=GetFreeOtherClientIndex();
 			if (i>=0)
 			{
-				otherClients[i].playerId=staticDataOriginator;
+				otherClients[i].playerId=packet->playerId;
 				otherClients[i].isActive=true;
 				otherClients[i].staticData.Reset();
 				// The static data is what is left over in the stream
 				otherClients[i].staticData.Write((char*)bitStream.GetData()+BITS_TO_BYTES(bitStream.GetReadOffset()), bitStream.GetNumberOfBytesUsed()-BITS_TO_BYTES(bitStream.GetReadOffset()));
-				DeallocatePacket(packet);
-				return 0;
 			}
 		}
 		else if (packet->data[0]==ID_BROADCAST_PINGS)
@@ -189,10 +208,10 @@
 	RakPeer::Ping(remoteSystemList[0].playerId);
 }
 
-void RakClient::PingServer(char* host, unsigned short serverPort, unsigned short clientPort)
+void RakClient::PingServer(char* host, unsigned short serverPort, unsigned short clientPort, bool onlyReplyOnAcceptingConnections)
 {
 	RakPeer::Initialize(1, clientPort,0);
-	RakPeer::Ping(host, serverPort);
+	RakPeer::Ping(host, serverPort, onlyReplyOnAcceptingConnections);
 }
 
 int RakClient::GetAveragePing(void)
@@ -245,7 +264,7 @@
 
 unsigned long RakClient::GetSynchronizedRandomInteger(void) const
 {
-	if (getTime() > nextSeedUpdate)
+	if (RakNetGetTime() > nextSeedUpdate)
 		return nextSeed;
 	else
 		return seed;
@@ -287,18 +306,18 @@
 	RakPeer::UnregisterAsRemoteProcedureCall(uniqueID);
 }
 
-bool RakClient::RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp)
+bool RakClient::RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp)
 {
 	if (remoteSystemList==0)
 		return false;
-	return RakPeer::RPC(uniqueID, data, bitLength, priority, reliability, orderingStream, remoteSystemList[0].playerId, false, shiftTimestamp);
+	return RakPeer::RPC(uniqueID, data, bitLength, priority, reliability, orderingChannel, remoteSystemList[0].playerId, false, shiftTimestamp);
 }
 
-bool RakClient::RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp)
+bool RakClient::RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp)
 {
 	if (remoteSystemList==0)
 		return false;
-	return RakPeer::RPC(uniqueID, parameters, priority, reliability, orderingStream, remoteSystemList[0].playerId, false, shiftTimestamp);
+	return RakPeer::RPC(uniqueID, parameters, priority, reliability, orderingChannel, remoteSystemList[0].playerId, false, shiftTimestamp);
 }
 
 /*
@@ -329,7 +348,7 @@
 	return RakPeer::GetDecompressionRatio();
 }
 
-BitStream* RakClient::GetStaticServerData(void)
+RakNet::BitStream * RakClient::GetStaticServerData(void)
 {
 	if (remoteSystemList==0)
 		return 0;
@@ -343,7 +362,7 @@
 	RakPeer::SetRemoteStaticData(remoteSystemList[0].playerId, data, length);
 }
 
-BitStream* RakClient::GetStaticClientData(PlayerID playerId)
+RakNet::BitStream * RakClient::GetStaticClientData(PlayerID playerId)
 {
 	int i;
 
@@ -433,71 +452,11 @@
 	return RakPeer::GetMTUSize();
 }
 
-double RakClient::GetPacketlossPercentile(void)
+RakNetStatisticsStruct* const RakClient::GetStatistics(void)
 {
-	return RakPeer::GetPacketlossPercentile();
+	return RakPeer::GetStatistics(remoteSystemList[0].playerId);
 }
 
-unsigned long RakClient::GetTransmittedPacketCount(void)
-{
-	return RakPeer::GetTransmittedPacketCount();
-}
-
-unsigned long RakClient::GetTransmittedFrameCount(void)
-{
-	return RakPeer::GetTransmittedFrameCount();
-}
-
-unsigned long RakClient::GetLostPacketCount(void)
-{
-	return RakPeer::GetLostPacketCount();
-}
-
-unsigned long RakClient::GetReceivedPacketCount(void)
-{
-	return RakPeer::GetReceivedPacketCount();
-}
-
-unsigned long RakClient::GetBytesSent(void)
-{
-	return RakPeer::GetBytesSent();
-}
-
-unsigned long RakClient::GetBytesReceived(void)
-{
-	return RakPeer::GetBytesReceived();
-}
-
-unsigned long RakClient::GetUnacknowledgedSentPacketListSize(void)
-{
-	return RakPeer::GetUnacknowledgedSentPacketListSize();
-}
-
-unsigned long RakClient::GetBytesSentPerSecond(void) const
-{
-	return RakPeer::GetBytesSentPerSecond();
-}
-
-unsigned long RakClient::GetBytesReceivedPerSecond(void) const
-{
-	return RakPeer::GetBytesReceivedPerSecond();
-}
-
-unsigned long RakClient::GetMaximumWindowSize(void)
-{
-	return RakPeer::GetMaximumWindowSize();
-}
-
-unsigned long RakClient::GetPacketOutputBufferSize(void)
-{
-	return RakPeer::GetPacketOutputBufferSize();
-}
-
-unsigned long RakClient::GetConnectionTime(void)
-{
-	return RakPeer::GetConnectionTime(RakPeer::GetInternalID());
-}
-
 int RakClient::GetOtherClientIndexByPlayerID(PlayerID playerId)
 {
 	unsigned i;
@@ -520,3 +479,7 @@
 	return -1;
 }
 
+PlayerIndex RakClient::GetPlayerIndex(void)
+{
+	return localPlayerIndex;
+}

Modified: branches/multiplayer-branch/source/libraries/raknet/RakClient.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/RakClient.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/RakClient.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -1,4 +1,4 @@
-// This file is part of RakNet Copyright 2003, 2004 Rakkarsoft LLC and Kevin Jenkins.
+// This file is part of RarkNet Copyright 2003, 2004 Rakkarsoft LLC and Kevin Jenkins.
 
 // Usage of Raknet is subject to the appropriate licence agreement.
 // "Shareware" Licensees with Rakkarsoft LLC are subject to the shareware license found at http://www.rakkarsoft.com/shareWareLicense.html which you agreed to upon purchase of a "Shareware license"
@@ -28,14 +28,15 @@
 	// serverPort is which port to connect to on the remote machine. clientPort is the port you want the client to use.
 	// Both ports must be open for UDP
 	// validationInteger is legacy and unused
-	// Set highPriorityThreads to true (recommended) for a real-time responsive client.  Set it to false
-	// for games where high pings don't matter, or if the network engine slows down the game too much
+	// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	// Returns true on successful initiation, false otherwise
-	bool Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, bool highPriorityThreads);
+	bool Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, int threadSleepTimer);
 
 	// Stops the client, stops synchronized data, and resets all internal data. 
 	// Does nothing if the client is not connected to begin with
-	void Disconnect(void);
+	// blockDuration is how long you should wait for all remaining packets to go out
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	void Disconnect(unsigned long blockDuration);
 
 	// Description:
 	// Can be called to use specific public RSA keys. (e and n)
@@ -43,10 +44,8 @@
 	// If a key has been altered.
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	void InitializeSecurity(unsigned short numberOfBytes, char *RSAe, char *RSAn);
+	// RSAe, RSAn - Public keys generated from the RSACrypt class.  See the Encryption sample.  Can be 0
+	void InitializeSecurity(char *RSAe, char *RSAn);
 
 	// Set the password to use when connecting to a server.  The password persists between connections.
 	// Pass 0 for no password.
@@ -57,13 +56,13 @@
 
 	// This function only works while the client is connected (Use the Connect function).  Returns false on failure, true on success
 	// Sends the data stream of length length
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
-	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream);
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
+	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel);
 
 	// This function only works while the client is connected (Use the Connect function).  Returns false on failure, true on success
 	// Sends the BitStream
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
-	bool Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream);
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
+	bool Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel);
 
 	// Call this to get a packet from the incoming packet queue. Use DeallocatePacket to deallocate the packet after you are done with it.
 	// Check the Packet struct at the top of CoreNetworkStructures.h for the format of the struct
@@ -84,7 +83,10 @@
 	// networking system if it is not already initialized.  You can stop the networking system
 	// by calling Disconnect()
 	// The final ping time will be encoded in the following 4 bytes (2-5) as an unsigned long
-	void PingServer(char* host, unsigned short serverPort, unsigned short clientPort);
+	// You can specify if the server should only reply if it has an open connection or not
+	// This must be true for LAN broadcast server discovery on "255.255.255.255"
+	// or you will get replies from clients as well.
+	void PingServer(char* host, unsigned short serverPort, unsigned short clientPort, bool onlyReplyOnAcceptingConnections);
 
 	// Returns the average of all ping times read
 	int GetAveragePing(void);
@@ -183,8 +185,8 @@
 	// If you want that function to return data you should call RPC from that system in the same way
 	// Returns true on a successful packet send (this does not indicate the recipient performed the call), false on failure
 	// The uniqueID must be composed of a string with only characters from a-z and is not case sensitive
-	bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp);
-	bool RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp);
+	bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp);
+	bool RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp);
 
 	// Handles an RPC packet.  If you get a packet with the ID ID_RPC you should pass it to this function
 	// This is already done in Multiplayer.cpp, so if you use the Multiplayer class it is handled for you.
@@ -218,12 +220,12 @@
 	// The data is entered as an array and stored and returned as a BitStream.  
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...->GetStaticServerData(...);
+	// RakNet::BitStream *copy = ...->GetStaticServerData(...);
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
 	// Note that the server may change at any time the
 	// data contents and/or its length!
-	BitStream* GetStaticServerData(void);
+	RakNet::BitStream * GetStaticServerData(void);
 	void SetStaticServerData(char *data, const long length);
 
 	// The client internally maintains a data struct that is automatically sent to the server on connection
@@ -235,10 +237,10 @@
 	// The data is entered as an array and stored and returned as a BitStream.
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...->GetStaticServerData(...);
+	// RakNet::BitStream *copy = ...->GetStaticServerData(...);
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
-	BitStream* GetStaticClientData(PlayerID playerId);
+	RakNet::BitStream * GetStaticClientData(PlayerID playerId);
 	void SetStaticClientData(PlayerID playerId, char *data, const long length);
 
 	// Send the static server data to the server
@@ -285,21 +287,17 @@
 	// Returns the current MTU size
 	int GetMTUSize(void) const;
 
-	// Network statistics.
-	double GetPacketlossPercentile(void); // The average outgoing packetloss percentile
-	unsigned long GetTransmittedPacketCount(void); // How many packets were sent
-	unsigned long GetTransmittedFrameCount(void); // How many frames were sent	
-	unsigned long GetLostPacketCount(void); // How many packets were lost
-	unsigned long GetReceivedPacketCount(void); // How many packets were received
-	unsigned long GetBytesSent(void); // How many bytes have been sent.
-	unsigned long GetBytesReceived(void); // How many bytes have been received.
-	unsigned long GetUnacknowledgedSentPacketListSize(void); // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	unsigned long GetBytesSentPerSecond(void) const;  // How many bytes were sent in the last histogram block.
-	unsigned long GetBytesReceivedPerSecond(void) const; // How many bytes were received in the last histogram block.
-	unsigned long GetMaximumWindowSize(void); // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	unsigned long GetPacketOutputBufferSize(void); // Returns the number of waiting packets on the send queue
-	unsigned long GetConnectionTime(void); // Returns the time elapsed since you connected
+	// Description:
+	// Returns a structure containing a large set of network statistics for the server/client connection
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	RakNetStatisticsStruct * const GetStatistics(void);
 
+	// For internal use
+	PlayerIndex GetPlayerIndex(void);
+
 	private:
 
 	int GetOtherClientIndexByPlayerID(PlayerID playerId);
@@ -310,11 +308,12 @@
 	{
 		PlayerID playerId;
 		short ping;
-		BitStream staticData;
+		RakNet::BitStream staticData;
 		bool isActive;
 	} otherClients[32];
 	// Synchronized random integer
 	unsigned long seed, nextSeed, nextSeedUpdate;
+	PlayerIndex localPlayerIndex;
 	PlayerID externalPlayerID; // This is your external ID (and also IP) (returned from the server)
 };
 

Modified: branches/multiplayer-branch/source/libraries/raknet/RakClientInterface.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/RakClientInterface.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/RakClientInterface.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -13,7 +13,8 @@
 #include "NetworkTypes.h"
 #include "PacketPriority.h"
 #include "RakPeerInterface.h"
-class BitStream;
+#include "BitStream.h"
+#include "RakNetStatistics.h"
 
 class RakClientInterface
 {
@@ -27,14 +28,15 @@
 	// serverPort is which port to connect to on the remote machine. clientPort is the port you want the client to use.
 	// Both ports must be open for UDP
 	// validationInteger is legacy and unused
-	// Set highPriorityThreads to true (recommended) for a real-time responsive client.  Set it to false
-	// for games where high pings don't matter, or if the network engine slows down the game too much
+	// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	// Returns true on successful initiation, false otherwise
-	virtual bool Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, bool highPriorityThreads)=0;
+	virtual bool Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, int threadSleepTimer)=0;
 
 	// Stops the client, stops synchronized data, and resets all internal data. 
 	// Does nothing if the client is not connected to begin with
-	virtual void Disconnect(void)=0;
+	// blockDuration is how long you should wait for all remaining packets to go out
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	virtual void Disconnect(unsigned long blockDuration)=0;
 
 	// Description:
 	// Can be called to use specific public RSA keys. (e and n)
@@ -42,10 +44,8 @@
 	// If a key has been altered.
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	virtual void InitializeSecurity(unsigned short numberOfBytes, char *RSAe, char *RSAn)=0;
+	// RSAe, RSAn - Public keys generated from the RSACrypt class.  See the Encryption sample.  Can be 0
+	virtual void InitializeSecurity(char *RSAe, char *RSAn)=0;
 
 	// Set the password to use when connecting to a server.  The password persists between connections.
 	// Pass 0 for no password.
@@ -56,13 +56,13 @@
 
 	// This function only works while the client is connected (Use the Connect function).  Returns false on failure, true on success
 	// Sends the data stream of length length
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
-	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream)=0;
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
+	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel)=0;
 
 	// This function only works while the client is connected (Use the Connect function).  Returns false on failure, true on success
 	// Sends the BitStream
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
-	virtual bool Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream)=0;
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
+	virtual bool Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel)=0;
 
 	// Call this to get a packet from the incoming packet queue. Use DeallocatePacket to deallocate the packet after you are done with it.
 	// Check the Packet struct at the top of CoreNetworkStructures.h for the format of the struct
@@ -83,7 +83,10 @@
 	// networking system if it is not already initialized.  You can stop the networking system
 	// by calling Disconnect()
 	// The final ping time will be encoded in the following 4 bytes (2-5) as an unsigned long
-	virtual void PingServer(char* host, unsigned short serverPort, unsigned short clientPort)=0;
+	// You can specify if the server should only reply if it has an open connection or not
+	// This must be true for LAN broadcast server discovery on "255.255.255.255"
+	// or you will get replies from clients as well.
+	virtual void PingServer(char* host, unsigned short serverPort, unsigned short clientPort, bool onlyReplyOnAcceptingConnections)=0;
 
 	// Returns the average of all ping times read
 	virtual int GetAveragePing(void)=0;
@@ -182,8 +185,8 @@
 	// If you want that function to return data you should call RPC from that system in the same way
 	// Returns true on a successful packet send (this does not indicate the recipient performed the call), false on failure
 	// The uniqueID must be composed of a string with only characters from a-z and is not case sensitive
-	virtual bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp)=0;
-	virtual bool RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp)=0;
 
 	// OBSOLETE - DONE AUTOMATICALLY
 	// Handles an RPC packet.  If you get a packet with the ID ID_RPC you should pass it to this function
@@ -218,12 +221,12 @@
 	// The data is entered as an array and stored and returned as a BitStream.  
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...->GetStaticServerData(...)=0;
+	// RakNet::BitStream *copy = ...->GetStaticServerData(...)=0;
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
 	// Note that the server may change at any time the
 	// data contents and/or its length!
-	virtual BitStream* GetStaticServerData(void)=0;
+	virtual RakNet::BitStream * GetStaticServerData(void)=0;
 	virtual void SetStaticServerData(char *data, const long length)=0;
 
 	// The client internally maintains a data struct that is automatically sent to the server on connection
@@ -235,10 +238,10 @@
 	// The data is entered as an array and stored and returned as a BitStream.
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...->GetStaticServerData(...)=0;
+	// RakNet::BitStream *copy = ...->GetStaticServerData(...)=0;
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
-	virtual BitStream* GetStaticClientData(PlayerID playerId)=0;
+	virtual RakNet::BitStream * GetStaticClientData(PlayerID playerId)=0;
 	virtual void SetStaticClientData(PlayerID playerId, char *data, const long length)=0;
 
 	// Send the static server data to the server
@@ -285,20 +288,16 @@
 	// Returns the current MTU size
 	virtual int GetMTUSize(void) const=0;
 
-	// Network statistics.
-	virtual double GetPacketlossPercentile(void)=0; // The average outgoing packetloss percentile
-	virtual unsigned long GetTransmittedPacketCount(void)=0; // How many packets were sent
-	virtual unsigned long GetTransmittedFrameCount(void)=0; // How many frames were sent	
-	virtual unsigned long GetLostPacketCount(void)=0; // How many packets were lost
-	virtual unsigned long GetReceivedPacketCount(void)=0; // How many packets were received
-	virtual unsigned long GetBytesSent(void)=0; // How many bytes have been sent.
-	virtual unsigned long GetBytesReceived(void)=0; // How many bytes have been received.
-	virtual unsigned long GetUnacknowledgedSentPacketListSize(void)=0; // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	virtual unsigned long GetBytesSentPerSecond(void) const=0;  // How many bytes were sent in the last histogram block.
-	virtual unsigned long GetBytesReceivedPerSecond(void) const=0; // How many bytes were received in the last histogram block.
-	virtual unsigned long GetMaximumWindowSize(void)=0; // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	virtual unsigned long GetPacketOutputBufferSize(void)=0; // Returns the number of waiting packets on the send queue
-	virtual unsigned long GetConnectionTime(void)=0; // Returns the time elapsed since you connected
+	// Description:
+	// Returns a structure containing a large set of network statistics for the server/client connection
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	virtual RakNetStatisticsStruct * const GetStatistics(void)=0;
+
+	// For internal use
+	virtual PlayerIndex GetPlayerIndex(void)=0;
 };
 
 #endif

Added: branches/multiplayer-branch/source/libraries/raknet/RakNetStatistics.cpp
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/RakNetStatistics.cpp	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/RakNetStatistics.cpp	2004-10-08 21:41:59 UTC (rev 76)
@@ -0,0 +1,135 @@
+#include "RakNetStatistics.h"
+#include <stdio.h> // sprintf
+#include "BitStream.h" // BITS_TO_BYTES
+
+// Verbosity level currently supports 0 (low), 1 (medium), 2 (high)
+// Buffer must be hold enough to hold the output string.  See the source to get an idea of how many bytes will be output
+void StatisticsToString(RakNetStatisticsStruct *s, char *buffer, int verbosityLevel)
+{
+	if (s==0)
+	{
+		sprintf(buffer, "stats is a NULL pointer in statsToString\n");
+		return;
+	}
+
+	if (verbosityLevel==0)
+	{
+		// Verbosity level 0
+		sprintf(buffer,
+"Total bytes sent: %u\n\
+Total bytes received: %u\n\
+Packetloss: %.1f%%\n",
+			BITS_TO_BYTES(s->totalBitsSent),
+			BITS_TO_BYTES(s->bitsReceived+s->bitsWithBadCRCReceived),
+			100.0f*(float)s->messagesTotalBitsResent/(float)s->totalBitsSent);
+	}
+	else if (verbosityLevel==1)
+	{
+		// Verbosity level 1
+		
+		sprintf(buffer,
+"Messages in Send buffer: %u\n\
+Messages sent: %u\n\
+Bytes sent: %u\n\
+Acks sent: %u\n\
+Acks in send buffer: %u\n\
+Messages waiting for ack: %u\n\
+Messages resent: %u\n\
+Bytes resent: %u\n\
+Packetloss: %.1f%%\n\
+Messages recieved: %u\n\
+Bytes recieved: %u\n\
+Acks recieved: %u\n\
+Duplicate acks recieved: %u\n\
+Window size: %u\n",
+			s->messageSendBuffer[SYSTEM_PRIORITY]+s->messageSendBuffer[HIGH_PRIORITY]+s->messageSendBuffer[MEDIUM_PRIORITY]+s->messageSendBuffer[LOW_PRIORITY],
+			s->messagesSent[SYSTEM_PRIORITY]+s->messagesSent[HIGH_PRIORITY]+s->messagesSent[MEDIUM_PRIORITY]+s->messagesSent[LOW_PRIORITY],
+			BITS_TO_BYTES(s->totalBitsSent),
+			s->acknowlegementsSent,
+			s->acknowlegementsPending,
+			s->messagesOnResendQueue,
+			s->messageResends,
+			BITS_TO_BYTES(s->messagesTotalBitsResent),
+			100.0f*(float)s->messagesTotalBitsResent/(float)s->totalBitsSent,
+			s->duplicateMessagesReceived+s->invalidMessagesReceived+s->messagesReceived,
+			BITS_TO_BYTES(s->bitsReceived+s->bitsWithBadCRCReceived),
+			s->acknowlegementsReceived,
+			s->duplicateAcknowlegementsReceived,
+			s->windowSize);
+	}
+	else
+	{
+		// Verbosity level 2.
+		sprintf(buffer,
+"Bytes sent:\t\t\t\t%u\n\
+Messages in send buffer:\t\tSP:%u HP:%u MP:%u LP:%u\n\
+Messages sent:\t\t\t\tSP:%u HP:%u MP:%u LP:%u\n\
+Message data bytes sent:\t\tSP:%u HP:%u MP:%u LP:%u\n\
+Message header bytes sent:\t\tSP:%u HP:%u MP:%u LP:%u\n\
+Message total bytes sent:\t\tSP:%u HP:%u MP:%u LP:%u\n\
+Bytes received:\t\t\t\tTtl:%u Good:%u Bad:%u\n\
+Packets received:\t\t\tTtl:%u Good:%u Bad:%u\n\
+Acks received:\t\t\t\tTtl:%u Good:%u Dup:%u\n\
+Messages received:\t\t\tTotal:%u Valid:%u Invalid:%u Dup:%u\n\
+Packetloss:\t\t\t\t%.1f%%\n\
+Packets sent:\t\t\t\t%u\n\
+Acks sent:\t\t\t\t%u\n\
+Acks in send buffer:\t\t\t%u\n\
+Messages waiting for ack:\t\t%u\n\
+Ack bytes sent:\t\t\t\t%u\n\
+Sent packets containing only acks:\t%u\n\
+Sent packets w/only acks and resends:\t%u\n\
+Reliable messages resent:\t\t%u\n\
+Reliable message data bytes resent:\t%u\n\
+Reliable message header bytes resent:\t%u\n\
+Reliable message total bytes resent:\t%u\n\
+Number of messages split:\t\t%u\n\
+Number of messages unsplit:\t\t%u\n\
+Message splits performed:\t\t%u\n\
+Additional encryption bytes:\t\t%u\n\
+Sequenced messages out of order:\t%u\n\
+Sequenced messages in order:\t\t%u\n\
+Ordered messages out of order:\t\t%u\n\
+Ordered messages in of order:\t\t%u\n\
+Split messages waiting for reassembly:\t%u\n\
+Messages in internal output queue:\t%u\n\
+Window size:\t\t\t\t%u\n\
+Lossy window size\t\t\t%u\n\
+Connection start time:\t\t\t%u\n",
+			BITS_TO_BYTES(s->totalBitsSent),
+			s->messageSendBuffer[SYSTEM_PRIORITY],s->messageSendBuffer[HIGH_PRIORITY], s->messageSendBuffer[MEDIUM_PRIORITY],s->messageSendBuffer[LOW_PRIORITY],
+			s->messagesSent[SYSTEM_PRIORITY], s->messagesSent[HIGH_PRIORITY], s->messagesSent[MEDIUM_PRIORITY],s->messagesSent[LOW_PRIORITY],
+			BITS_TO_BYTES(s->messageDataBitsSent[SYSTEM_PRIORITY]),BITS_TO_BYTES(s->messageDataBitsSent[HIGH_PRIORITY]), BITS_TO_BYTES(s->messageDataBitsSent[MEDIUM_PRIORITY]),BITS_TO_BYTES(s->messageDataBitsSent[LOW_PRIORITY]),
+			BITS_TO_BYTES(s->messageTotalBitsSent[SYSTEM_PRIORITY]-s->messageDataBitsSent[SYSTEM_PRIORITY]),BITS_TO_BYTES(s->messageTotalBitsSent[HIGH_PRIORITY]-s->messageDataBitsSent[HIGH_PRIORITY]), BITS_TO_BYTES(s->messageTotalBitsSent[MEDIUM_PRIORITY]-s->messageDataBitsSent[MEDIUM_PRIORITY]),BITS_TO_BYTES(s->messageTotalBitsSent[LOW_PRIORITY]-s->messageDataBitsSent[LOW_PRIORITY]),
+			BITS_TO_BYTES(s->messageTotalBitsSent[SYSTEM_PRIORITY]), BITS_TO_BYTES(s->messageTotalBitsSent[HIGH_PRIORITY]), BITS_TO_BYTES(s->messageTotalBitsSent[MEDIUM_PRIORITY]),BITS_TO_BYTES(s->messageTotalBitsSent[LOW_PRIORITY]),
+			BITS_TO_BYTES(s->bitsReceived+s->bitsWithBadCRCReceived),BITS_TO_BYTES(s->bitsReceived),BITS_TO_BYTES(s->bitsWithBadCRCReceived),
+			s->packetsReceived+s->packetsWithBadCRCRecieved,s->packetsReceived,s->packetsWithBadCRCRecieved,
+			s->acknowlegementsReceived+s->duplicateAcknowlegementsReceived, s->acknowlegementsReceived,s->duplicateAcknowlegementsReceived,
+			s->messagesReceived+s->invalidMessagesReceived+s->duplicateMessagesReceived, s->messagesReceived, s->invalidMessagesReceived, s->duplicateMessagesReceived,
+			100.0f*(float)s->messagesTotalBitsResent/(float)s->totalBitsSent,
+			s->packetsSent,
+			s->acknowlegementsSent,
+			s->acknowlegementsPending,
+			s->messagesOnResendQueue,
+			BITS_TO_BYTES(s->acknowlegementBitsSent),
+			s->packetsContainingOnlyAcknowlegements,
+			s->packetsContainingOnlyAcknowlegementsAndResends,
+			s->messageResends,
+			BITS_TO_BYTES(s->messageDataBitsResent),
+			BITS_TO_BYTES(s->messagesTotalBitsResent-s->messageDataBitsResent),
+			BITS_TO_BYTES(s->messagesTotalBitsResent),
+			s->numberOfSplitMessages,
+			s->numberOfUnsplitMessages,
+			s->totalSplits,
+			BITS_TO_BYTES(s->encryptionBitsSent),
+			s->sequencedMessagesOutOfOrder,
+			s->sequencedMessagesInOrder,
+			s->orderedMessagesOutOfOrder,
+			s->orderedMessagesInOrder,
+			s->messagesWaitingForReassembly,
+			s->internalOutputQueueSize,
+			s->windowSize,
+			s->lossySize,
+			s->connectionStartTime);
+	}
+}

Added: branches/multiplayer-branch/source/libraries/raknet/RakNetStatistics.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/RakNetStatistics.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/RakNetStatistics.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -0,0 +1,97 @@
+#ifndef __RAK_NET_STATISTICS_H
+#define __RAK_NET_STATISTICS_H
+
+#include "PacketPriority.h"
+
+struct RakNetStatisticsStruct
+{
+	//		Number of Messages in the send Buffer (high, medium, low priority)
+	unsigned messageSendBuffer[NUMBER_OF_PRIORITIES];
+	//		Number of messages sent (high, medium, low priority)
+	unsigned messagesSent[NUMBER_OF_PRIORITIES];
+	//		Number of data bits used for user messages
+	unsigned messageDataBitsSent[NUMBER_OF_PRIORITIES];
+	//		Number of total bits used for user messages, including headers
+	unsigned messageTotalBitsSent[NUMBER_OF_PRIORITIES];
+
+	//		Number of packets sent containing only acknowledgements
+	unsigned packetsContainingOnlyAcknowlegements;
+	//		Number of acknowledgements sent
+	unsigned acknowlegementsSent;
+	//		Number of acknowledgements waiting to be sent
+	unsigned acknowlegementsPending;
+	//		Number of acknowledgements bits sent
+	unsigned acknowlegementBitsSent;
+
+	//		Number of packets containing only acknowledgements and resends
+	unsigned packetsContainingOnlyAcknowlegementsAndResends;
+
+	//		Number of messages resent
+	unsigned messageResends;
+	//		Number of bits resent of actual data
+	unsigned messageDataBitsResent;
+	//		Total number of bits resent, including headers
+	unsigned messagesTotalBitsResent;
+	//		Number of messages waiting for ack
+	unsigned messagesOnResendQueue;
+
+	//		Number of messages not split for sending
+	unsigned numberOfUnsplitMessages;
+	//		Number of messages split for sending
+	unsigned numberOfSplitMessages;
+	//		Total number of splits done for sending
+	unsigned totalSplits;
+
+	//		Total packets sent
+	unsigned packetsSent;
+
+	//		Number of bits added by encryption
+	unsigned encryptionBitsSent;
+	//		total bits sent
+	unsigned totalBitsSent;
+
+	//		Number of sequenced messages arrived out of order
+	unsigned sequencedMessagesOutOfOrder;
+	//		Number of sequenced messages arrived in order
+	unsigned sequencedMessagesInOrder;
+
+	//		Number of ordered messages arrived out of order
+	unsigned orderedMessagesOutOfOrder;
+	//		Number of ordered messages arrived in order
+	unsigned orderedMessagesInOrder;
+
+	//		Packets with a good CRC received
+	unsigned packetsReceived;
+	//		Packets with a bad CRC received
+	unsigned packetsWithBadCRCRecieved;
+	//		Bits with a good CRC received
+	unsigned bitsReceived;
+	//		Bits with a bad CRC received
+	unsigned bitsWithBadCRCReceived;
+	//		Number of acknowledgement messages received for packets we are resending
+	unsigned acknowlegementsReceived;
+	//		Number of acknowledgement messages received for packets we are not resending
+	unsigned duplicateAcknowlegementsReceived;
+	//		Number of data messages (anything other than an ack) received that are valid and not duplicate
+	unsigned messagesReceived;
+	//		Number of data messages (anything other than an ack) received that are invalid
+	unsigned invalidMessagesReceived;
+	//		Number of data messages (anything other than an ack) received that are duplicate
+	unsigned duplicateMessagesReceived;
+	//		Number of messages waiting for reassembly
+	unsigned messagesWaitingForReassembly;
+	//		Number of messages in reliability output queue
+	unsigned internalOutputQueueSize;
+	//		Current window size
+	unsigned windowSize;
+	//		lossy window size
+	unsigned lossySize;
+	//		connection start time
+	unsigned long connectionStartTime;
+};
+
+
+// Verbosity level currently supports 0 (low), 1 (medium), 2 (high)
+void StatisticsToString(RakNetStatisticsStruct *s, char *buffer, int verbosityLevel);
+
+#endif

Modified: branches/multiplayer-branch/source/libraries/raknet/RakNetworkFactory.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/RakNetworkFactory.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/RakNetworkFactory.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -14,16 +14,16 @@
 class RakPeerInterface;
 
 #ifdef _WIN32
-#define EXPORT __declspec(dllexport)
+#define RAK_DLL_EXPORT __declspec(dllexport)
 #else
 // Unix needs no export, but for name mangling, keep the function name
 // clean. If you omit the 'extern "C"', the .so names will be
 // compiler dependent.
-#define EXPORT extern "C"
+#define RAK_DLL_EXPORT extern "C"
 #endif
 
 #if defined(DLL_EXPORTS) || defined(_USRDLL)
-class EXPORT RakNetworkFactory
+class RAK_DLL_EXPORT RakNetworkFactory
 #else
 //class __declspec( dllimport ) RakNetworkFactory
 class RakNetworkFactory

Modified: branches/multiplayer-branch/source/libraries/raknet/RakPeer.cpp
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/RakPeer.cpp	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/RakPeer.cpp	2004-10-08 21:41:59 UTC (rev 76)
@@ -27,20 +27,33 @@
 #include "PacketEnumerations.h"
 #include "HuffmanEncodingTree.h"
 #include "PacketPool.h"
-#include "RSA.h"
 #include "Rand.h"
 
+// alloca
+#ifdef _WIN32
+#include <malloc.h>
+#else
+#include <stdlib.h>
+#endif
+
 static const unsigned long SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION=5000;
 
+// UPDATE_THREAD_POLL_TIME is how often the update thread will poll to see
+// if receive wasn't called within UPDATE_THREAD_UPDATE_TIME.  If it wasn't called within that time,
+// the updating thread will activate and take over network communication until Receive is called again.
+//static const unsigned long UPDATE_THREAD_UPDATE_TIME=30;
+//static const unsigned long UPDATE_THREAD_POLL_TIME=30;
 
+//#define _TEST_AES
+
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 // Constructor
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 RakPeer::RakPeer()
 {
-	securedConnectionByteSize=0;
+	usingSecurity=false;
 	memset(frequencyTable, 0, sizeof(unsigned long) * 256);
-	rawBytesSent=rawBytesRecieved=compressedBytesSent=compressedBytesRecieved=0;
+	rawBytesSent=rawBytesReceived=compressedBytesSent=compressedBytesReceived=0;
 	outputTree=inputTree=0;
 	connectionSocket=INVALID_SOCKET;
 	MTUSize=DEFAULT_MTU_SIZE;
@@ -51,8 +64,8 @@
 	bytesSentPerSecond=bytesReceivedPerSecond=0;
 	endThreads=true;
 	isMainLoopThreadActive=false;
-	isRecvfromThreadActive=false;
-	occasionalPing=true;
+//	isRecvfromThreadActive=false;
+	occasionalPing=false;
 	connectionSocket=INVALID_SOCKET;
 	myPlayerId=UNASSIGNED_PLAYER_ID;
 }
@@ -64,7 +77,7 @@
 {
 	unsigned i;
 
-	Disconnect();
+	Disconnect(0L);
 
 	// Clear out the lists:
 	for (i=0; i < requestedConnectionsList.size(); i++)
@@ -86,12 +99,12 @@
 // - A pure client would set this to 1.  A pure server would set it to the number of allowed clients.
 // - A hybrid would set it to the sum of both types of connections
 // localPort: The port to listen for connections on.
-// _threadPriority: 0 for regular priority (0-8 players), 1 for high priority (High performance applications), and 2 for ultra-high priority (MMO server)
+// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 //
 // Returns:
 // False on failure (can't create socket or thread), true on success.
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-bool RakPeer::Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadPriority)
+bool RakPeer::Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadSleepTimer)
 {
 	unsigned i;
 
@@ -108,13 +121,15 @@
 
 	if (maximumNumberOfPeers==0)
 	{
-		rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
+		if (threadSleepTimer>=0)
+			rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
 		remoteSystemList = new RemoteSystemStruct[MaximumNumberOfPeers];
 		for (i=0; i < MaximumNumberOfPeers; i++)
 		{
 			remoteSystemList[i].playerId=UNASSIGNED_PLAYER_ID;
 		}
-		rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Unlock();
+		if (threadSleepTimer>=0)
+			rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Unlock();
 
 		// Don't allow more incoming connections than we have peers.
 		if (maximumIncomingConnections>MaximumNumberOfPeers)
@@ -123,108 +138,93 @@
 		maximumNumberOfPeers=MaximumNumberOfPeers;
 	}
 
+	// For histogram statistics
+//	nextReadBytesTime=0;
+//	lastSentBytes=lastReceivedBytes=0;
+
 	if (endThreads)
 	{
+		lastUserUpdateCycle=0;
+
 		// Reset the frequency table that we use to save outgoing data
 		memset(frequencyTable, 0, sizeof(unsigned long) * 256);
 
 		// Reset the statistical data
-		rawBytesSent=rawBytesRecieved=compressedBytesSent=compressedBytesRecieved=0;
+		rawBytesSent=rawBytesReceived=compressedBytesSent=compressedBytesReceived=0;
 
+		updateCycleIsRunning=false;
 		endThreads=false;
 		// Create the threads
-		threadPriority=_threadPriority;
+		threadSleepTimer=_threadSleepTimer;
 
 		char ipList[10][16];
 		SocketLayer::Instance()->GetMyIP(ipList);
 		myPlayerId.port=localPort;
 		myPlayerId.binaryAddress=inet_addr(ipList[0]);
 
+		if (threadSleepTimer >=0)
+		{
 #ifdef _WIN32
-		if (isMainLoopThreadActive==false)
-		{
-			unsigned ProcessPacketsThreadID=0;
-			processPacketsThreadHandle=(HANDLE)_beginthreadex(NULL, 0, UpdateNetworkLoop, this, 0, &ProcessPacketsThreadID);
-			if (threadPriority==2 && processPacketsThreadHandle)
-				SetThreadPriority(processPacketsThreadHandle, THREAD_PRIORITY_HIGHEST);
-			else if (processPacketsThreadHandle==0)
+			if (isMainLoopThreadActive==false)
 			{
-				Disconnect();
-				return false;
-			}
+				unsigned ProcessPacketsThreadID=0;
+				processPacketsThreadHandle=(HANDLE)_beginthreadex(NULL, 0, UpdateNetworkLoop, this, 0, &ProcessPacketsThreadID);
 
-			CloseHandle(processPacketsThreadHandle);
-			processPacketsThreadHandle=0;
+				if (processPacketsThreadHandle==0)
+				{
+					Disconnect(0L);
+					return false;
+				}
 
-		}
+				//	SetThreadPriority(processPacketsThreadHandle, THREAD_PRIORITY_HIGHEST);
 
-		if (isRecvfromThreadActive==false)
-		{
-			unsigned recvfromThreadID=0;
-			recvfromThreadHandle=(HANDLE)_beginthreadex(NULL, 0, RecvFromNetworkLoop, this, 0, &recvfromThreadID);
+				CloseHandle(processPacketsThreadHandle);
+				processPacketsThreadHandle=0;
 
-#ifndef __USE_IO_COMPLETION_PORTS
-			if (threadPriority==2 && recvfromThreadHandle)
-				SetThreadPriority(recvfromThreadHandle, THREAD_PRIORITY_HIGHEST);
-#endif
-
-			if (recvfromThreadHandle==0)
-			{
-				Disconnect();
-				return false;
 			}
 
-			CloseHandle(recvfromThreadHandle);
-			recvfromThreadHandle=0;
-		}
-
 #else
-		pthread_attr_t attr;
+			pthread_attr_t attr;
 
-		pthread_attr_init( &attr );
-		pthread_attr_setdetachstate( &attr, PTHREAD_CREATE_DETACHED );
-		if (threadPriority==2)
-		{
-			sched_param sp;
-			sp.sched_priority = sched_get_priority_max(SCHED_OTHER);
-			pthread_attr_setschedparam(&attr, &sp);
-		}
+			pthread_attr_init( &attr );
+			pthread_attr_setdetachstate( &attr, PTHREAD_CREATE_DETACHED );
 
-		int error;
+			//		sched_param sp;
+			//		sp.sched_priority = sched_get_priority_max(SCHED_OTHER);
+			//		pthread_attr_setschedparam(&attr, &sp);
 
-		if (isMainLoopThreadActive==false)
-		{
-			error = pthread_create( &processPacketsThreadHandle, &attr, &UpdateNetworkLoop, this );
-			if (error)
-			{
-				Disconnect();
-				return false;
-			}
-		}
+			int error;
 
-		if (	isRecvfromThreadActive==false)
-		{
-			error = pthread_create( &recvfromThreadHandle, &attr, &RecvFromNetworkLoop, this );
-			if (error)
+			if (isMainLoopThreadActive==false)
 			{
-				Disconnect();
-				return false;
+				error = pthread_create( &processPacketsThreadHandle, &attr, &UpdateNetworkLoop, this );
+				if (error)
+				{
+					Disconnect(0L);
+					return false;
+				}
 			}
-		}
-		pthread_attr_destroy( &attr );
 
-		processPacketsThreadHandle=0;
+			processPacketsThreadHandle=0;
 #endif
 
-		// Wait for the threads to activate.  When they are active they will set these variables to true
-		while (isRecvfromThreadActive==false || isMainLoopThreadActive==false)
+
+			// Wait for the threads to activate.  When they are active they will set these variables to true
+			while (/*isRecvfromThreadActive==false || */isMainLoopThreadActive==false)
 #ifdef _WIN32
-			Sleep(10);
+				Sleep(10);
 #else
-			usleep(10 * 1000);
+				usleep(10 * 1000);
 #endif
 
-	}
+		}
+		else
+		{
+#ifdef __USE_IO_COMPLETION_PORTS
+			AsynchronousFileIO::Instance()->IncreaseUserCount();
+#endif
+		}
+	}		
 
 	return true;
 }
@@ -240,57 +240,61 @@
 // If you accept connections, you must call this or else secure connections will not be enabled
 // for incoming connections.
 // If you are connecting to another system, you can call this with values for the
-// (e and n) public keys before connecting to prevent MitM
+// (e and p,q) public keys before connecting to prevent MitM
 //
 // Parameters:
-// numberOfBytes:  How many bytes to use for each of the RSA keys.
-// RSAd - A pointer to the private key of length numberOfBytes.
-// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
+// RSAe, RSAn - Public keys generated from the RSACrypt class.  See the Encryption sample
+// RSAp, RSAq - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+// If the private keys are 0, then a new key will be generated when this function is called
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-void RakPeer::InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn)
+void RakPeer::InitializeSecurity(char *RSAe, char *RSAn, char *RSAp, char *RSAq)
 {
 	if (endThreads==false)
 		return;
 
-	// You can specify e and n, d and e and n, or none.  Any other combination is invalid
-	if (!((RSAe && RSAn) || (RSAd==0 && RSAe==0 && RSAn==0)))
+	// Setting the client key is e,n,
+	// Setting the server key is p,q
+	// These are mutually exclusive
+	if ((RSAe && RSAn && (RSAp || RSAq)) ||
+		(RSAp && RSAq && (RSAe || RSAn)) ||
+		(RSAe && RSAn==0) ||
+		(RSAn && RSAe==0) ||
+		(RSAp && RSAq==0) ||
+		(RSAq && RSAp==0))
 	{
+		// Invalid parameters
 		assert(0);
-		return;
 	}
 
-	// For whatever reason the encoder / decoder fails randomly with data length 20 and bytes less than 32.
-	assert(numberOfBytes >= 32);
-	if (numberOfBytes < 32)
-	{
-		numberOfBytes=32;
-	}
+	seedMT(RakNetGetTime());
 
-	seedMT(getTime());
+	GenerateSYNCookieRandomNumber();
 
-	securedConnectionByteSize=numberOfBytes;
+	usingSecurity=true;
 
-	// Generate RSA keys
-	d.Init(numberOfBytes);
-	e.Init(numberOfBytes);
-	n.Init(numberOfBytes);
-
-	GenerateSYNCookieRandomNumber();
-
-	if (RSAd==0 && RSAe==0 && RSAn==0)
+	if (RSAe==0 && RSAn==0 &&RSAp==0 && RSAq==0)
 	{
 		keysLocallyGenerated=true;
-		GenerateKeys(d,e,n);
+		rsacrypt.generateKeys();
 	}
 	else
 	{
+		if (RSAe && RSAn)
+		{
+			// Save public keys
+			memcpy((char*)&publicKeyE, RSAe, sizeof(publicKeyE));
+			memcpy(publicKeyN, RSAn, sizeof(publicKeyN));
+		}
+		else if (RSAp && RSAq)
+		{
+			BIGHALFSIZE(RSA_BIT_SIZE, p);
+			BIGHALFSIZE(RSA_BIT_SIZE, q);
+			memcpy(p, RSAp, sizeof(p));
+			memcpy(q, RSAq, sizeof(q));
+			// Save private keys
+			rsacrypt.setPrivateKey(p, q);
+		}
 		keysLocallyGenerated=false;
-		if (RSAd)
-			memcpy(d.value, RSAd, numberOfBytes);
-		memcpy(e.value, RSAe, numberOfBytes);
-		memcpy(n.value, RSAn, numberOfBytes);
 	}
 }
 
@@ -304,7 +308,7 @@
 	if (endThreads==false)
 		return;
 
-	securedConnectionByteSize=0;
+	usingSecurity=false;
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -343,18 +347,20 @@
 void RakPeer::SetIncomingPassword(char* passwordData, int passwordDataLength)
 {
 	// Set the incoming password data
-	rakPeerMutexes[incomingPasswordBitStream_Mutex].Lock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[incomingPasswordBitStream_Mutex].Lock();
 	incomingPasswordBitStream.Reset();
 	if (passwordData && passwordDataLength>0)
 		incomingPasswordBitStream.Write(passwordData, passwordDataLength);
-	rakPeerMutexes[incomingPasswordBitStream_Mutex].Unlock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[incomingPasswordBitStream_Mutex].Unlock();
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 // Description:
 // Returns the password set by SetIncomingPassword in a BitStream
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-BitStream *RakPeer::GetIncomingPassword(void)
+RakNet::BitStream *RakPeer::GetIncomingPassword(void)
 {
 	return &incomingPasswordBitStream;
 }
@@ -364,7 +370,7 @@
 // Call this to connect to the specified host (ip or domain name) and server port.
 // Calling Connect and not calling SetMaximumIncomingConnections acts as a dedicated client.  Calling both acts as a true peer.
 // This is a non-blocking connection.  You know the connection is successful when IsConnected() returns true
-// or receive gets a packet with the type identifier ID_ENUMERATION_REPLY.  If the connection is not
+// or receive gets a packet with the type identifier ID_CONNECTION_ACCEPTED.  If the connection is not
 // successful, such as rejected connection or no response then neither of these things will happen.
 // Requires that you first call Initialize
 //
@@ -395,11 +401,13 @@
 		return false;
 
 	// Set the incoming password data
-	rakPeerMutexes[outgoingPasswordBitStream_Mutex].Lock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[outgoingPasswordBitStream_Mutex].Lock();
 	outgoingPasswordBitStream.Reset();
 	if (passwordData && passwordDataLength>0)
 		outgoingPasswordBitStream.Write(passwordData, passwordDataLength);
-	rakPeerMutexes[outgoingPasswordBitStream_Mutex].Unlock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[outgoingPasswordBitStream_Mutex].Unlock();
 
 	// If the host starts with something other than 0, 1, or 2 it's (probably) a domain name.
 	if (host[0] < '0' || host[0] > '2')
@@ -417,9 +425,10 @@
 			 Packet *p;
 			 p = PacketPool::Instance()->GetPointer();
 
-			 p->data = new char [1];
+			 p->data = new unsigned char [1];
 			 p->data[0]=(unsigned char)ID_NO_FREE_INCOMING_CONNECTIONS;
 			 p->playerId=myPlayerId;
+			 p->playerIndex=(PlayerIndex)GetIndexFromPlayerID(myPlayerId);
 			 p->length = 1;
 
 			#ifdef _DEBUG
@@ -455,7 +464,7 @@
 				 NewIncomingConnectionStruct newIncomingConnectionStruct;
 				 newIncomingConnectionStruct.typeId=ID_NEW_INCOMING_CONNECTION;
 				 newIncomingConnectionStruct.externalID=myPlayerId;
-				 Send((char*)&newIncomingConnectionStruct, sizeof(newIncomingConnectionStruct), HIGH_PRIORITY, RELIABLE, 0, myPlayerId, false);
+				 Send((char*)&newIncomingConnectionStruct, sizeof(newIncomingConnectionStruct), SYSTEM_PRIORITY, RELIABLE, 0, myPlayerId, false);
 
 				 return true;
 			 }
@@ -473,30 +482,47 @@
 // Description:
 // Stops the network threads and close all connections.  Multiple calls are ok.
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-void RakPeer::Disconnect(void)
+void RakPeer::Disconnect(unsigned long blockDuration)
 {
 	unsigned i;
-	unsigned short maxPeers=maximumNumberOfPeers;
+	unsigned short maxPeers=maximumNumberOfPeers; // This is done for threading reasons
 
 	// Call close connection in a loop for all open connections.
 	for (i=0; i < maxPeers; i++)
 	{
 		// CloseConnection uses maximumNumberOfPeers
-		CloseConnection(remoteSystemList[i].playerId, true);
+		CloseConnection(remoteSystemList[i].playerId, true, blockDuration);
+	
 	}
 
 	// Setting this to 0 allows remoteSystemList to be reallocated in Initialize and prevents threads from accessing the reliability layer
 	maximumNumberOfPeers=0;
 
-	// Stop the threads
-	endThreads=true;
+	if (endThreads==false)
+	{
+		// Stop the threads
+		endThreads=true;
 
-	while(isMainLoopThreadActive)
+		// Normally the thread will call DecreaseUserCount on termination but if we aren't using threads just do it
+		// manually
+#ifdef __USE_IO_COMPLETION_PORTS
+		if (threadSleepTimer<0)
+		{
+			AsynchronousFileIO::Instance()->DecreaseUserCount();
+		}
+#endif
+
+	}
+
+	if (threadSleepTimer>=0)
+	{
+		while(isMainLoopThreadActive)
 #ifdef _WIN32
-		Sleep(10);
+			Sleep(10);
 #else
-		usleep(10 * 1000);
+			usleep(10 * 1000);
 #endif
+	}
 
 	if (connectionSocket != INVALID_SOCKET)
 	{
@@ -511,14 +537,14 @@
 //		SocketLayer::Instance()->SendTo(connectionSocket, &c, 1, "127.0.0.1", myPlayerId.port);
 //	}
 
-	while(isRecvfromThreadActive)
-#ifdef _WIN32
-		Sleep(10);
-#else
-		usleep(10 * 1000);
-#endif
+//	while(isRecvfromThreadActive)
+//#ifdef _WIN32
+//		Sleep(10);
+//#else
+//		usleep(10 * 1000);
+//#endif
 
-	isSocketLayerBlocking=false;
+//	isSocketLayerBlocking=false;
 
 //	if (connectionSocket != INVALID_SOCKET)
 //	{
@@ -539,7 +565,15 @@
 
 	bytesSentPerSecond=bytesReceivedPerSecond=0;
 
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+	for (i=0; i < requestedConnectionsList.size(); i++)
+		delete requestedConnectionsList[i];
+	requestedConnectionsList.clear();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 
+
 	// Clear out the reliabilty layer list in case we want to reallocate it in a successive call to Init.
 	RemoteSystemStruct * temp = remoteSystemList;
 	remoteSystemList=0;
@@ -574,14 +608,25 @@
 		return false;
 	}
 
-	for (count=0, index=0; (remoteSystems==0 || count < *numberOfSystems) && index < maximumNumberOfPeers; ++index)
-		if (remoteSystemList[index].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			if (remoteSystems)
-				remoteSystems[count]=remoteSystemList[index].playerId;
-			++count;
-		}
+	// This is called a lot so unroll the loop
+	if (remoteSystems)
+	{
+		for (count=0, index=0; index < maximumNumberOfPeers; ++index)
+			if (remoteSystemList[index].playerId!=UNASSIGNED_PLAYER_ID)
+			{
+				if (count < *numberOfSystems)
+					remoteSystems[count]=remoteSystemList[index].playerId;
+				++count;
+			}
 
+	}
+	else
+	{
+		for (count=0, index=0; index < maximumNumberOfPeers; ++index)
+			if (remoteSystemList[index].playerId!=UNASSIGNED_PLAYER_ID)
+				++count;
+	}
+
 	*numberOfSystems=(unsigned short)count;
 
 	return 0;
@@ -598,25 +643,31 @@
 // bitStream: The bitstream to send
 // priority: What priority level to send on.
 // reliability: How reliability to send this data
-// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 // - Packets are only ordered relative to other packets on the same stream
 // playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 // broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 // Returns:
 // False if we are not connected to the specified recipient.  True otherwise
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-bool RakPeer::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)
+bool RakPeer::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)
 {
+#ifdef _DEBUG
+	assert(data && length>0);
+#endif
 	if (data==0 || length < 0)
 		return false;
 
-	BitStream temp(data, length, false);
-	return Send(&temp, priority, reliability, orderingStream, playerId, broadcast);
+	RakNet::BitStream temp(data, length, false);
+	return Send(&temp, priority, reliability, orderingChannel, playerId, broadcast);
 
 }
 
-bool RakPeer::Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)
+bool RakPeer::Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)
 {
+#ifdef _DEBUG
+	assert(bitStream->GetNumberOfBytesUsed()>0);
+#endif
 	if (bitStream->GetNumberOfBytesUsed()==0)
 		return false;
 	if (remoteSystemList==0 || endThreads==true)
@@ -648,13 +699,13 @@
 
 			if (outputTree)
 			{
-				BitStream bitStreamCopy(bitStream->GetNumberOfBytesUsed());
+				RakNet::BitStream bitStreamCopy(bitStream->GetNumberOfBytesUsed());
 				outputTree->EncodeArray(bitStream->GetData(),bitStream->GetNumberOfBytesUsed(), &bitStreamCopy);
 				compressedBytesSent+=bitStreamCopy.GetNumberOfBytesUsed();
-				remoteSystemList[remoteSystemIndex].reliabilityLayer.Send(&bitStreamCopy, priority,reliability,orderingStream, true, MTUSize);
+				remoteSystemList[remoteSystemIndex].reliabilityLayer.Send(&bitStreamCopy, priority,reliability,orderingChannel, true, MTUSize);
 			}
 			else
-				remoteSystemList[remoteSystemIndex].reliabilityLayer.Send(bitStream, priority,reliability,orderingStream, true, MTUSize);
+				remoteSystemList[remoteSystemIndex].reliabilityLayer.Send(bitStream, priority,reliability,orderingChannel, true, MTUSize);
 
 			if (broadcast==false)
 				return true;
@@ -677,8 +728,15 @@
 {
 	if (!(IsActive()))	return 0;
 
+	// Only one thread should call RunUpdateCycle at a time.  We don't need to delay calls so
+	// a mutex on the function is not necessary - only on the variable that indicates if the function is
+	// running
+//	lastUserUpdateCycle=RakNetGetTime();
+//	RunMutexedUpdateCycle();
+	
+
 	// Prepare to write out a bitstream containing all the synchronization data
-//	BitStream *bitStream=0;
+//	RakNet::BitStream *bitStream=0;
 /*
 	automaticVariableSynchronizationMutex.Lock();
 
@@ -759,7 +817,7 @@
 #endif
 
 		// Push the data into a bitstream for easy parsing
-		BitStream bitStream(data+1, length-1, false);
+		RakNet::BitStream bitStream(data+1, length-1, false);
 		UniqueIDType uniqueID;
 		bool hasSecondaryID;
 		ObjectID secondaryID;
@@ -828,18 +886,32 @@
 	Packet *val;
 	int offset;
 
-	incomingQueueMutex.Lock();
-	if (incomingPacketQueue.size() > 0)
+	while (1)
 	{
-		val = incomingPacketQueue.pop();
-	}
-	else
-	{
+		incomingQueueMutex.Lock();
+		if (incomingPacketQueue.size() > 0)
+		{
+			val = incomingPacketQueue.pop();
+		}
+		else
+		{
+			incomingQueueMutex.Unlock();
+			return 0;
+		}
+
 		incomingQueueMutex.Unlock();
-		return 0;
+
+		// Do RPC calls from the user thread, not the network update thread
+		if (val->data[0] == ID_RPC || val->data[0] == ID_RPC_WITH_TIMESTAMP)
+		{
+			HandleRPCPacket((char*)val->data, val->length, val->playerId);
+			DeallocatePacket(val);
+		}
+		else
+			break; // Send the packet to the user
 	}
-	incomingQueueMutex.Unlock();
 
+
 #ifdef _DEBUG
 	assert(val->data);
 #endif
@@ -848,7 +920,7 @@
 		((unsigned char)val->data[0] == ID_TIMESTAMP))
 	{
 		offset = sizeof(unsigned char);
-		ShiftIncomingTimestamp(val->data + offset, val->playerId);
+		ShiftIncomingTimestamp((char*)val->data + offset, val->playerId);
 	}
 
 	return val;
@@ -958,13 +1030,22 @@
 // bitStream: The bitstream to send
 // priority: What priority level to send on.
 // reliability: How reliability to send this data
-// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 // broadcast - Send this packet to everyone.
 // playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 // broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-bool RakPeer::RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)
+bool RakPeer::RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)
 {
+	RakNet::BitStream temp(data, BITS_TO_BYTES(bitLength), false);
+	if (data)
+		return RPC(uniqueID, &temp, priority, reliability, orderingChannel, playerId, broadcast, shiftTimestamp);
+	else
+		return RPC(uniqueID, 0, priority, reliability, orderingChannel, playerId, broadcast, shiftTimestamp);
+}
+
+bool RakPeer::RPC(char* uniqueID, RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)
+{
 #ifdef _DEBUG
 	assert(uniqueID && uniqueID[0]);
 #endif
@@ -976,13 +1057,13 @@
 		return false; // Unique ID is too long
 	}
 
-	if (shiftTimestamp && (data==0 || bitLength < 8 * sizeof(unsigned long)))
+	if (shiftTimestamp && bitStream && (bitStream->GetNumberOfBytesUsed() < sizeof(unsigned long)))
 	{
 		assert(0); // Not enough bits to shift!
 		return false;
 	}
 
-	BitStream outgoingBitStream;
+	RakNet::BitStream outgoingBitStream;
 	unsigned char uniqueIDLength, ch;
 	uniqueIDLength = (unsigned char)strlen(uniqueID);
 
@@ -995,9 +1076,9 @@
 	for (int counter=0; uniqueID[counter]; counter++)
 	{
 		ch = (unsigned char)toupper(uniqueID[counter]);
-// Dev-C++ doesn't support toupper.  How lame.
-    //  if (uniqueID[counter] > 'Z')
-  //      uniqueID[counter]-='a'-'A';
+		// Dev-C++ doesn't support toupper.  How lame.
+		//  if (uniqueID[counter] > 'Z')
+		//      uniqueID[counter]-='a'-'A';
 
 		if (ch < 'A' || ch > 'Z')
 		{
@@ -1009,27 +1090,22 @@
 
 		// Make the range of the char from 0 to 32
 		ch-='A';
-		outgoingBitStream.WriteBits((unsigned char*)&ch, 5, true); // Write the char with 5 bits
+		outgoingBitStream.WriteBits((unsigned char*)&ch, 5); // Write the char with 5 bits
 	}
 
-	if (data==0)
-		bitLength=0;
+	if (bitStream)
+		outgoingBitStream.WriteCompressed(bitStream->GetNumberOfBitsUsed());
+	else
+		outgoingBitStream.WriteCompressed((int)0);
 
-	outgoingBitStream.WriteCompressed(bitLength);
-
 	// False to write the raw data from another bitstream, rather than shifting from user data
-	if (bitLength > 0)
-		outgoingBitStream.WriteBits((unsigned char*)data, bitLength);
+	if (bitStream && bitStream->GetNumberOfBitsUsed() > 0)
+		outgoingBitStream.WriteBits(bitStream->GetData(), bitStream->GetNumberOfBitsUsed(), false);
 
-	return Send(&outgoingBitStream, priority, reliability, orderingStream,playerId,broadcast);
-}
+	// For testing
+	//	HandleRPCPacket((char*)outgoingBitStream.GetData(), outgoingBitStream.GetNumberOfBytesUsed(), UNASSIGNED_PLAYER_ID);
 
-bool RakPeer::RPC(char* uniqueID, BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)
-{
-	if (bitStream && bitStream->GetNumberOfBitsUsed()>0)
-		return RPC(uniqueID, (char*)bitStream->GetData(), bitStream->GetNumberOfBitsUsed(), priority, reliability, orderingStream, playerId, broadcast,shiftTimestamp);
-	else
-		return RPC(uniqueID, 0,0, priority, reliability, orderingStream, playerId, broadcast,shiftTimestamp);
+	return Send(&outgoingBitStream, priority, reliability, orderingChannel,playerId,broadcast);
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -1040,25 +1116,52 @@
 // target: Which connection to close
 // sendDisconnectionNotification: True to send ID_DISCONNECTION_NOTIFICATION to the recipient.  False to close it silently.
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-void RakPeer::CloseConnection(PlayerID target, bool sendDisconnectionNotification)
+void RakPeer::CloseConnection(PlayerID target, bool sendDisconnectionNotification, unsigned long blockDuration)
 {
+	unsigned i, stopWaitingTime;
 	if (remoteSystemList==0 || endThreads==true)
 		return;
 
 	if (sendDisconnectionNotification)
 	{
 		unsigned char c=ID_DISCONNECTION_NOTIFICATION;
-		Send((char*)&c, sizeof(c), HIGH_PRIORITY, UNRELIABLE, 0, target, false);
+		Send((char*)&c, sizeof(c), SYSTEM_PRIORITY, RELIABLE, 0, target, false);
+		lastUserUpdateCycle=RakNetGetTime();
+//		RunMutexedUpdateCycle();
 	}
-	
-	unsigned i;
-	rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
-	for (i=0; i < maximumNumberOfPeers; i++)
+
+	i=0;
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
+	for (; i < maximumNumberOfPeers; i++)
 		if (remoteSystemList[i].playerId==target)
 		{
-			// One last update so the disconnect or other packets can go out
-			remoteSystemList[i].reliabilityLayer.Update(connectionSocket, remoteSystemList[i].playerId, MTUSize);
+			// Send out any last packets
+			// Update isn't thread safe to call outside of the internal thread
+			// remoteSystemList[i].reliabilityLayer.Update(connectionSocket, remoteSystemList[i].playerId, MTUSize);
 
+			if (blockDuration>=0)
+			{
+				stopWaitingTime=RakNetGetTime() + blockDuration;
+
+				while (RakNetGetTime() < stopWaitingTime)
+				{
+					// If this system is out of packets to send, then stop waiting
+					if (remoteSystemList[i].reliabilityLayer.GetStatistics()->messageSendBuffer[SYSTEM_PRIORITY]==0)
+						break;
+
+					// This will probably cause the update thread to run which will probably
+					// send the disconnection notification
+#ifdef _WIN32
+					Sleep(0);
+#else
+					usleep(0 * 1000);
+#endif
+//					lastUserUpdateCycle=RakNetGetTime();
+//					RunMutexedUpdateCycle();
+				}
+			}
+
 			// Reserve this reliability layer for ourselves
 			remoteSystemList[i].playerId=UNASSIGNED_PLAYER_ID; // This one line causes future incoming packets to go through the reliability layer
 
@@ -1067,7 +1170,8 @@
 			break;
 		}
 
-	rakPeerMutexes[remoteSystemList_Mutex].Unlock();
+		if (threadSleepTimer>=0)
+			rakPeerMutexes[remoteSystemList_Mutex].Unlock();
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -1217,11 +1321,13 @@
 		return false;
 
 	banListIndex=0;
+	if (banList.size()==0)
+		return false; // Skip the mutex if possible
 	banListMutex.Lock();
 	for (; banListIndex < banList.size(); banListIndex++)
 	{
 		characterIndex=0;
-		while (1)
+		while (true)
 		{
 			if (banList[banListIndex][characterIndex]==IP[characterIndex])
 			{
@@ -1275,9 +1381,9 @@
 
 	PingStruct ping;
 	ping.typeId=ID_PING;
-	ping.sendPingTime=getTime();
+	ping.sendPingTime=RakNetGetTime();
 
-	Send((char*)&ping, sizeof(PingStruct), HIGH_PRIORITY, UNRELIABLE, 0, target, false);
+	Send((char*)&ping, sizeof(PingStruct), SYSTEM_PRIORITY, UNRELIABLE, 0, target, false);
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -1290,10 +1396,11 @@
 // The sender and recipient must already be started via a successful call to Initialize
 //
 // Parameters:
-// host: Either a dotted IP address or a domain name
+// host: Either a dotted IP address or a domain name.  Can be 255.255.255.255 for LAN broadcast.
 // remotePort: Which port to connect to on the remote machine.
+// onlyReplyOnAcceptingConnections: Only request a reply if the remote system has open connections
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-void RakPeer::Ping(char* host, unsigned short remotePort)
+void RakPeer::Ping(char* host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections)
 {
 	if (host==0)
 		return;
@@ -1305,8 +1412,11 @@
 	}
 
 	UnconnectedPingStruct s;
-	s.typeId=ID_PING;
-	s.sendPingTime=getTime();
+	if (onlyReplyOnAcceptingConnections)
+		s.typeId=ID_PING_OPEN_CONNECTIONS;
+	else
+		s.typeId=ID_PING;
+	s.sendPingTime=RakNetGetTime();
 
 	SocketLayer::Instance()->SendTo(connectionSocket, (char*)&s, sizeof(UnconnectedPingStruct), (char*)host, remotePort);
 }
@@ -1372,7 +1482,7 @@
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 // Description:
-// Ping the remote systems every so often.  This is on by default
+// Ping the remote systems every so often.  This is off by default
 // This will work anytime
 //
 // Parameters:
@@ -1557,7 +1667,7 @@
 // Returns:
 // The data passed to SetRemoteStaticData stored as a bitstream
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-BitStream* RakPeer::GetRemoteStaticData(PlayerID playerId)
+RakNet::BitStream * RakPeer::GetRemoteStaticData(PlayerID playerId)
 {
 	if (playerId==myPlayerId)
 		return &localStaticData;
@@ -1609,13 +1719,13 @@
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 void RakPeer::SendStaticData(PlayerID target)
 {
-	BitStream reply(sizeof(unsigned char) + localStaticData.GetNumberOfBytesUsed());
+	RakNet::BitStream reply(sizeof(unsigned char) + localStaticData.GetNumberOfBytesUsed());
 	reply.Write((unsigned char) ID_RECEIVED_STATIC_DATA);
 	reply.Write((char*)localStaticData.GetData(), localStaticData.GetNumberOfBytesUsed());
 	if (target==UNASSIGNED_PLAYER_ID)
-		Send(&reply, HIGH_PRIORITY, RELIABLE, 0, target, true);
+		Send(&reply, SYSTEM_PRIORITY, RELIABLE, 0, target, true);
 	else
-		Send(&reply, HIGH_PRIORITY, RELIABLE, 0, target, false);
+		Send(&reply, SYSTEM_PRIORITY, RELIABLE, 0, target, false);
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -1731,7 +1841,7 @@
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 const char* RakPeer::GetLocalIP(unsigned int index)
 {
-	char ipList[10][16];
+	static char ipList[10][16];
 	if (index >=10)
 		index=9;
 	memset(ipList, 0, sizeof(char) * 16 * 10);
@@ -1873,9 +1983,9 @@
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 float RakPeer::GetDecompressionRatio(void) const
 {
-	if (rawBytesRecieved>0L)
+	if (rawBytesReceived>0L)
 	{
-		return (float)compressedBytesRecieved / (float)rawBytesRecieved;
+		return (float)compressedBytesReceived / (float)rawBytesReceived;
 	}
 	else return 0.0f;
 }
@@ -1913,224 +2023,19 @@
 #ifdef _DEBUG
 		assert(packet->data);
 #endif
-		incomingPacketQueue.push(packet);
+		incomingPacketQueue.pushAtHead(packet);
 	}
 }
-
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-double RakPeer::GetPacketlossPercentile(void) const
+RakNetStatisticsStruct *  const RakPeer::GetStatistics(PlayerID playerId)
 {
-	unsigned i;
-	double value=0.0f;
-	int count=0;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0;
-
-	for (i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID && remoteSystemList[i].reliabilityLayer.GetBytesSent()>0)
-		{
-			count++;
-			value+=remoteSystemList[i].reliabilityLayer.GetPacketlossPercentile();
-		}
-	}
-
-	if (count>0)
-		return value/(double)count;
-	else return 0.0;
+	RemoteSystemStruct *rss;
+	rss=GetRemoteSystemFromPlayerID(playerId);
+	if (rss)
+		return rss->reliabilityLayer.GetStatistics();
+	return 0;
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetTransmittedPacketCount(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID &&remoteSystemList[i].reliabilityLayer.GetBytesSent()>0)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetTransmittedPacketCount();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetTransmittedFrameCount(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID && remoteSystemList[i].reliabilityLayer.GetBytesSent()>0)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetTransmittedFrameCount();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetLostPacketCount(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID && remoteSystemList[i].reliabilityLayer.GetBytesSent()>0)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetLostPacketCount();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetReceivedPacketCount(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID && remoteSystemList[i].reliabilityLayer.GetBytesSent()>0)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetReceivedPacketCount();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetBytesSent(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetBytesSent();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetBytesReceived(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetBytesReceived();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetUnacknowledgedSentPacketListSize(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetUnacknowledgedSentPacketListSize();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetBytesSentPerSecond(void) const
-{
-	return bytesSentPerSecond;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetBytesReceivedPerSecond(void) const
-{
-	return bytesReceivedPerSecond;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetMaximumWindowSize(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetMaximumWindowSize();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetPacketOutputBufferSize(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetPacketOutputBufferSize();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetConnectionTime(PlayerID playerId) const
-{
-	RemoteSystemStruct *remoteSystem = GetRemoteSystemFromPlayerID(playerId);
-	if (remoteSystem)
-		return getTime() - remoteSystem->connectionTime;
-	else
-		return 0;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 void RakPeer::RecordConnectionAttempt(const char* host, unsigned short remotePort)
 {
 	PlayerID playerId;
@@ -2138,20 +2043,23 @@
 	s = new RequestedConnectionStruct;
 	IPToPlayerID(host, remotePort, &playerId);
 	s->playerId=playerId;
-	s->time=getTime();
+	s->time=RakNetGetTime();
 	s->setAESKey=false;
 	s->nextRequestTime=s->time + 2000;
 
 	// Record that we tried to connect to this host
-	rakPeerMutexes[requestedConnections_MUTEX].Lock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[requestedConnections_MUTEX].Lock();
 	requestedConnectionsList.push(s);
-	rakPeerMutexes[requestedConnections_MUTEX].Unlock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[requestedConnections_MUTEX].Unlock();
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 void RakPeer::RemoveFromRequestedConnectionsList(PlayerID playerId)
 {
 	int i;
-	rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
 	for (i=0; i < (int)requestedConnectionsList.size();)
 	{
 		if (requestedConnectionsList[i]->playerId==playerId)
@@ -2161,7 +2069,8 @@
 			break;
 		}
 	}
-	rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 bool RakPeer::SendConnectionRequest(const char* host, unsigned short remotePort)
@@ -2169,7 +2078,7 @@
 	int j;
 
 	const unsigned char c=ID_CONNECTION_REQUEST;
-	BitStream temp(sizeof(unsigned char) + outgoingPasswordBitStream.GetNumberOfBytesUsed());
+	RakNet::BitStream temp(sizeof(unsigned char) + outgoingPasswordBitStream.GetNumberOfBytesUsed());
 	temp.Write(c);
 	if (outgoingPasswordBitStream.GetNumberOfBytesUsed()>0)
 		temp.Write((char*)outgoingPasswordBitStream.GetData(), outgoingPasswordBitStream.GetNumberOfBytesUsed());
@@ -2184,8 +2093,10 @@
 		temp.port=remotePort;
 		PushPortRefused(temp);
 		closesocket(connectionSocket);
-		rakPeerMutexes[requestedConnections_MUTEX].Lock();
+		if (threadSleepTimer>=0)
+			rakPeerMutexes[requestedConnections_MUTEX].Lock();
 		delete requestedConnectionsList.pop();
+		if (threadSleepTimer>=0)
 		rakPeerMutexes[requestedConnections_MUTEX].Unlock();
 	}
 #endif
@@ -2225,9 +2136,9 @@
 
 		if (remoteSystem==0)
 		{
-			// No reliability layer available
-			unsigned char c = ID_NO_FREE_INCOMING_CONNECTIONS;
-			SocketLayer::Instance()->SendTo(connectionSocket, (char*)&c, sizeof(char), playerId);
+			// Already connected.  Ignore duplicate connection requests
+		//	unsigned char c = ID_NO_FREE_INCOMING_CONNECTIONS;
+		//	SocketLayer::Instance()->SendTo(connectionSocket, (char*)&c, sizeof(char), playerId.binaryAddress, playerId.port);
 			return;
 		}
 
@@ -2255,19 +2166,20 @@
 		ds.remotePort = myPlayerId.port;
 		#endif
 		ds.externalID=playerId;
+		ds.playerIndex=(PlayerIndex)GetIndexFromPlayerID(playerId);
 		// Write using the new socket so the client knows what port to use
-		int result=SocketLayer::Instance()->SendTo(connectionSocket, (char*)&ds, sizeof(ds), playerId);
+		int result=SocketLayer::Instance()->SendTo(connectionSocket, (char*)&ds, sizeof(ds), playerId.binaryAddress, playerId.port);
 
 		if (result!=0)
 		{
-			CloseConnection(playerId, false);
+			CloseConnection(playerId, false,0L);
 			return;
 		}
 	}
 	else
 	{
 		unsigned char c = ID_NO_FREE_INCOMING_CONNECTIONS;
-		SocketLayer::Instance()->SendTo(connectionSocket, (char*)&c, sizeof(char), playerId);
+		SocketLayer::Instance()->SendTo(connectionSocket, (char*)&c, sizeof(char), playerId.binaryAddress, playerId.port);
 	}
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -2280,8 +2192,10 @@
 
 	numberOfIncomingConnections=0;
 	for (i=0; i < maximumNumberOfPeers; i++)
+	{
 		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID && remoteSystemList[i].weInitiatedTheConnection==false)
 			numberOfIncomingConnections++;
+	}
 
 	return numberOfIncomingConnections;
 }
@@ -2291,13 +2205,26 @@
 	RemoteSystemStruct *remoteSystem=0;
 	unsigned i;
 
-	rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
+	// If this guy is already connected, return 0.  This needs to be checked inside the mutex
+	// because threads may call the connection routine multiple times at the same time
 	for (i=0; i < maximumNumberOfPeers; i++)
+		if (remoteSystemList[i].playerId==playerId)
+		{
+			if (threadSleepTimer>=0)
+				rakPeerMutexes[remoteSystemList_Mutex].Unlock();
+			return 0;
+		}
+
+	for (i=0; i < maximumNumberOfPeers; i++)
 	{
 		if (remoteSystemList[i].playerId==UNASSIGNED_PLAYER_ID)
 		{
 			if (setAESKey)
 				(remoteSystemList[i]).reliabilityLayer.SetEncryptionKey(AESKey);
+			else
+				(remoteSystemList[i]).reliabilityLayer.SetEncryptionKey(0);
 			// Reserve this reliability layer for ourselves
 			(remoteSystemList[i]).playerId=playerId; // This one line causes future incoming packets to go through the reliability layer
 			remoteSystem=remoteSystemList+i;
@@ -2305,7 +2232,8 @@
 		}
 	}
 
-	rakPeerMutexes[remoteSystemList_Mutex].Unlock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[remoteSystemList_Mutex].Unlock();
 
 	return remoteSystem;
 }
@@ -2325,9 +2253,9 @@
 	remoteSystem->nextPingTime=0; // Ping immediately
 	remoteSystem->weInitiatedTheConnection=weInitiatedTheConnection;
 	remoteSystem->staticData.Reset();
-	remoteSystem->connectionTime=getTime();
+	remoteSystem->connectionTime=RakNetGetTime();
 	remoteSystem->myExternalPlayerId=UNASSIGNED_PLAYER_ID;
-//	remoteSystem->reliabilityLayer.Reset();
+	remoteSystem->reliabilityLayer.Reset();
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -2359,7 +2287,7 @@
 
 	for (counter=0; counter < PING_TIMES_ARRAY_SIZE; counter++)
 	{
-		if (remoteSystem->pingAndClockDifferential[0].pingTime==-1)
+		if (remoteSystem->pingAndClockDifferential[counter].pingTime==-1)
 			break;
 
 		if (remoteSystem->pingAndClockDifferential[counter].pingTime < lowestPingSoFar)
@@ -2392,11 +2320,12 @@
 	// Number of bits of the data (long)
 	// The data
 
-	BitStream incomingBitStream(data, length, false);
+	RakNet::BitStream incomingBitStream(data, length, false);
 	unsigned char uniqueIDLength, ch, packetID;
 	char uniqueIdentifier[256];
 	int counter;
-	long bitLength;
+	unsigned long bitLength;
+	char *userData;
 
 	if (incomingBitStream.Read(packetID)==false)
 	{
@@ -2480,17 +2409,18 @@
 		}
 
 		// We have to copy into a new data chunk because the user data might not be byte aligned.
-		char *userData = new char[BITS_TO_BYTES(incomingBitStream.GetNumberOfUnreadBits())];
+		//char *userData = new char[BITS_TO_BYTES(incomingBitStream.GetNumberOfUnreadBits())];
+		userData=(char*)alloca(BITS_TO_BYTES(incomingBitStream.GetNumberOfUnreadBits()));
 
 		// The false means read out the internal representation of the bitstream data rather than
-		// Aligning it as we normally would with user data.  This is so the end user can cast the data received
+		// aligning it as we normally would with user data.  This is so the end user can cast the data received
 		// into a bitstream for reading
 		if (incomingBitStream.ReadBits((unsigned char*)userData, bitLength, false)==false)
 		{
 #ifdef _DEBUG
 			assert(0);
 #endif
-			delete [] userData;
+		//	delete [] userData;
 			return false; // Not enough data to read
 		}
 
@@ -2499,7 +2429,7 @@
 		// Call the function callback
 		node->functionName(userData, bitLength, playerId);
 		// Free the memory
-		delete [] userData;
+//		delete [] userData;
 	}
 
 	return true;
@@ -2508,12 +2438,17 @@
 #ifdef __USE_IO_COMPLETION_PORTS
 bool RakPeer::SetupIOCompletionPortSocket(int index)
 {
-	SOCKET newSocket = SocketLayer::Instance()->CreateBoundSocket(myPlayerId.port+index+1, false);
-	SocketLayer::Instance()->Connect(newSocket, remoteSystemList[index].playerId); // port is the port of the client
+	SOCKET newSocket;
+
+	if (remoteSystemList[index].reliabilityLayer.GetSocket()!=INVALID_SOCKET)
+		closesocket(remoteSystemList[index].reliabilityLayer.GetSocket());
+
+	newSocket = SocketLayer::Instance()->CreateBoundSocket(myPlayerId.port+index+1, false);
+	SocketLayer::Instance()->Connect(newSocket, remoteSystemList[index].playerId.binaryAddress,remoteSystemList[index].playerId.port); // port is the port of the client
 	remoteSystemList[index].reliabilityLayer.SetSocket(newSocket);
 
 	// Associate our new socket with a completion port and do the first read
-	return SocketLayer::Instance()->AssociateSocketWithCompletionPortAndRead(newSocket, remoteSystemList[index].playerId, this);
+	return SocketLayer::Instance()->AssociateSocketWithCompletionPortAndRead(newSocket, remoteSystemList[index].playerId.binaryAddress,remoteSystemList[index].playerId.port, this);
 }
 #endif
 
@@ -2530,15 +2465,15 @@
 		memcpy(newRandomNumber+i, (char*)&number, sizeof(number));
 	}
 
-	randomNumberExpirationTime = getTime() + SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION;
+	randomNumberExpirationTime = RakNetGetTime() + SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION;
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 void RakPeer::SecuredConnectionResponse(PlayerID playerId)
 {
 	CSHA1 sha1;
-	unsigned char *connectionRequestResponse;
-	// 20 bytes for the SHA1 hash
-	connectionRequestResponse = new unsigned char [1+sizeof(securedConnectionByteSize)+securedConnectionByteSize*2 + 20];
+	RSA_BIT_SIZE n;
+	big::u32 e;
+	unsigned char connectionRequestResponse[1+sizeof(big::u32) + sizeof(RSA_BIT_SIZE) + 20];
 	connectionRequestResponse[0]=ID_SECURED_CONNECTION_RESPONSE;
 
 	// Hash the SYN-Cookie
@@ -2552,54 +2487,63 @@
 	// Write the cookie
 	memcpy(connectionRequestResponse+1, sha1.GetHash(), 20);
 
-	// Write the byte size
-	memcpy(connectionRequestResponse+1+20, (char*)&securedConnectionByteSize, securedConnectionByteSize);
-
 	// Write the public keys
-	memcpy(connectionRequestResponse+1+20+sizeof(securedConnectionByteSize), e.value, securedConnectionByteSize);
-	memcpy(connectionRequestResponse+1+20+sizeof(securedConnectionByteSize)+securedConnectionByteSize, n.value, securedConnectionByteSize);
+	rsacrypt.getPublicKey(e,n);
+	memcpy(connectionRequestResponse+1+20, (char*)&e, sizeof(big::u32));
+	memcpy(connectionRequestResponse+1+20+sizeof(big::u32), n, sizeof(RSA_BIT_SIZE));
 
 	// s2c public key, syn-cookie
-	SocketLayer::Instance()->SendTo(connectionSocket, (char*)connectionRequestResponse, 1+sizeof(securedConnectionByteSize)+securedConnectionByteSize*2 + 20, playerId);
-	delete [] connectionRequestResponse;
+	SocketLayer::Instance()->SendTo(connectionSocket, (char*)connectionRequestResponse, 1+sizeof(big::u32) + sizeof(RSA_BIT_SIZE) + 20, playerId.binaryAddress, playerId.port);
 }
-void RakPeer::SecuredConnectionConfirmation(PlayerID playerId, char* data, int length)
+void RakPeer::SecuredConnectionConfirmation(PlayerID playerId, char* data)
 {
 	int i,j;
 	unsigned char randomNumber[20];
 	unsigned long number;
-	unsigned short rsaByteSize;
 	bool doSend;
 	Packet *packet;
-	mpuint source,result,packetE, packetN;
+	big::u32 e;
+	RSA_BIT_SIZE n, message,encryptedMessage;
+	big::RSACrypt<RSA_BIT_SIZE> rsaEncrypt;
 
-	doSend=false;
-	rsaByteSize=0;
+	// Make sure that we still want to connect
+	bool requestedConnection=false;
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+	for (i=0; i < (int)requestedConnectionsList.size();i++)
+	{
+		if (requestedConnectionsList[i]->playerId==playerId)
+		{
+			// We did request this connection
+			requestedConnection=true;
+			break;
+		}
+	}
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 
-#ifdef _DEBUG
-	assert(sizeof(rsaByteSize)==sizeof(securedConnectionByteSize));
-#endif
+	if (requestedConnection==false)
+		return; // Don't want to connect
 
-	// Get the rsa byte size
-	memcpy((char*)&rsaByteSize, data+1+20, sizeof(rsaByteSize));
+	doSend=false;
 
-	// If the packet length is wrong for this byte size, return
-	if (length != (int)(1+20+sizeof(rsaByteSize)+rsaByteSize*2))
-		return;
+	// Copy out e and n
+	memcpy((char*)&e,data+1+20, sizeof(big::u32));
+	memcpy(n, data+1+20+sizeof(big::u32), sizeof(RSA_BIT_SIZE));
 
 	// If we preset a size and it doesn't match, or the keys do not match, then tell the user
-	if (securedConnectionByteSize > 0 && keysLocallyGenerated==false)
+	if (usingSecurity==true && keysLocallyGenerated==false)
 	{
-		if (securedConnectionByteSize != rsaByteSize ||
-			memcmp(data+1+20+sizeof(rsaByteSize), e.value, rsaByteSize)!=0 ||
-			memcmp(data+1+20+sizeof(rsaByteSize)+rsaByteSize, n.value, rsaByteSize)!=0)
+		if (memcmp((char*)&e, (char*)&publicKeyE, sizeof(big::u32))!=0 ||
+			memcmp(n, publicKeyN, sizeof(RSA_BIT_SIZE))!=0)
 		{
 			packet = PacketPool::Instance()->GetPointer();
-			packet->data = new char[1];
+			packet->data = new unsigned char[1];
 			packet->data[0]=ID_RSA_PUBLIC_KEY_MISMATCH;
 			packet->length=sizeof(char);
 			packet->bitSize=sizeof(char)*8;
 			packet->playerId=playerId;
+			packet->playerIndex=(PlayerIndex)GetIndexFromPlayerID(packet->playerId);
 			incomingQueueMutex.Lock();
 			incomingPacketQueue.push(packet);
 			incomingQueueMutex.Unlock();
@@ -2608,12 +2552,6 @@
 		}
 	}
 
-	// Copy the keys from the packet
-	packetE.Init(rsaByteSize);
-	packetN.Init(rsaByteSize);
-	memcpy(packetE.value,data+1+20+sizeof(rsaByteSize),rsaByteSize);
-	memcpy(packetN.value,data+1+20+sizeof(rsaByteSize)+rsaByteSize,rsaByteSize);
-
 	// Create a random number
 	for (i=0; i < sizeof(randomNumber); i+=sizeof(number))
 	{
@@ -2621,16 +2559,14 @@
 		memcpy(randomNumber+i, (char*)&number, sizeof(number));
 	}
 
-	// Encrypt the random number using RSA
-	source.Init(rsaByteSize);
-	result.Init(rsaByteSize);
+	memset(message, 0, sizeof(message));
+	assert(sizeof(message) >= sizeof(randomNumber));
+	memcpy(message, randomNumber, sizeof(randomNumber));
+	rsaEncrypt.setPublicKey(e,n);
+	rsaEncrypt.encrypt(message,encryptedMessage);
 
-	// This crummy rsa encoder doesn't work reliably with full blocks so WriteAndFill block doesn't work.
-	// source.WriteAndFillBlock((char*)randomNumber, 20);
-	memcpy(source.value, randomNumber, 20);
-	EncryptDecrypt(result, source, packetE, packetN);
-
-	rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
 	for (i=0; i < (int)requestedConnectionsList.size();)
 	{
 		if (requestedConnectionsList[i]->playerId==playerId)
@@ -2643,18 +2579,17 @@
 			break;
 		}
 	}
-	rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 
 	if (doSend)
 	{
-		char *reply;
-		reply = new char [1+20+rsaByteSize];
+		char reply[1+20+sizeof(RSA_BIT_SIZE)];
 		// c2s RSA(random number), same syn-cookie
 		reply[0]=ID_SECURED_CONNECTION_CONFIRMATION;
 		memcpy(reply+1, data+1, 20);  // Copy the syn-cookie
-		memcpy(reply+1+20, result.value, rsaByteSize); // Copy the encoded random number
-		SocketLayer::Instance()->SendTo(connectionSocket, reply, 1+20+rsaByteSize, playerId);
-		delete [] reply;
+		memcpy(reply+1+20, encryptedMessage, sizeof(RSA_BIT_SIZE)); // Copy the encoded random number
+		SocketLayer::Instance()->SendTo(connectionSocket, reply, 1+20+sizeof(RSA_BIT_SIZE), playerId.binaryAddress, playerId.port);
 	}
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -2663,10 +2598,11 @@
 	// Tell the game we can't connect to this host
 	Packet *p;
 	p = PacketPool::Instance()->GetPointer();
-	p->data=new char[1];
+	p->data=new unsigned char[1];
 	p->data[0]=ID_REMOTE_PORT_REFUSED;
 	p->length=sizeof(char);
 	p->playerId=target; // We don't know this!
+	p->playerIndex=(PlayerIndex)GetIndexFromPlayerID(p->playerId);
 
 	#ifdef _DEBUG
 	assert(p->data);
@@ -2678,6 +2614,7 @@
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+/*
 #ifdef _WIN32
 unsigned __stdcall RecvFromNetworkLoop(LPVOID arguments)
 #else
@@ -2739,7 +2676,7 @@
 #endif
 	return 0;
 }
-
+*/
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 #ifdef _WIN32
 void __stdcall ProcessNetworkPacket(unsigned long binaryAddress, unsigned short port, char *data, int length, RakPeer *rakPeer)
@@ -2756,18 +2693,31 @@
 	if (remoteSystem)
 	{
 		// Handle regular incoming data
+		// HandleSocketReceiveFromConnectedPlayer is only safe to be called from the same thread as Update,
+		// which is this thread
 		if (remoteSystem->reliabilityLayer.HandleSocketReceiveFromConnectedPlayer(data, length)==false)
 		{
-			// Cheater
-			Packet *packet = PacketPool::Instance()->GetPointer();
-			packet->data = new char[1];
-			packet->data[0]=ID_MODIFIED_PACKET;
-			packet->length=sizeof(char);
-			packet->bitSize=sizeof(char)*8;
-			packet->playerId=playerId;
-			rakPeer->incomingQueueMutex.Lock();
-			rakPeer->incomingPacketQueue.push(packet);
-			rakPeer->incomingQueueMutex.Unlock();
+			// These kinds of packets may have been duplicated and incorrectly determined to be
+			// cheat packets.  Anything else really is a cheat packet
+			if (!((unsigned char)(data)[0]==ID_CONNECTION_REQUEST ||
+				((unsigned char)(data)[0]==ID_PING && length==sizeof(UnconnectedPingStruct)) ||
+				((unsigned char)(data)[0]==ID_PONG && length==sizeof(UnconnectedPingStruct)) ||
+				((unsigned char)(data)[0]==ID_SECURED_CONNECTION_CONFIRMATION && length==1+20+sizeof(RSA_BIT_SIZE))
+				))
+			{
+				// Cheater
+				Packet *packet = PacketPool::Instance()->GetPointer();
+				packet->data = new unsigned char[1];
+				packet->data[0]=ID_MODIFIED_PACKET;
+				packet->length=sizeof(char);
+				packet->bitSize=sizeof(char)*8;
+				packet->playerId=playerId;
+				packet->playerIndex=(PlayerIndex)rakPeer->GetIndexFromPlayerID(playerId);
+				rakPeer->incomingQueueMutex.Lock();
+				rakPeer->incomingPacketQueue.push(packet);
+				rakPeer->incomingQueueMutex.Unlock();
+			}
+			
 		}
 	}
 	else
@@ -2778,45 +2728,50 @@
 			if (rakPeer->GetNumberOfIncomingConnections() >= rakPeer->GetMaximumIncomingConnections())
 			{
 				unsigned char c = ID_NO_FREE_INCOMING_CONNECTIONS;
-				SocketLayer::Instance()->SendTo(rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId);
+				SocketLayer::Instance()->SendTo(rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId.binaryAddress, playerId.port);
 			}
-			else if (rakPeer->securedConnectionByteSize==0)
+			char *password = data + sizeof(unsigned char);
+			int passwordLength = length - sizeof(unsigned char);
+			if (rakPeer->IsBanned(rakPeer->PlayerIDToDottedIP(playerId)))
 			{
-				char *password = data + sizeof(unsigned char);
-				int passwordLength = length - sizeof(unsigned char);
-				if (rakPeer->IsBanned(rakPeer->PlayerIDToDottedIP(playerId)))
+				// This one we only send once since we don't care if it arrives.
+				unsigned char c = ID_CONNECTION_BANNED;
+				SocketLayer::Instance()->SendTo(rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId.binaryAddress, playerId.port);
+			}
+			else if (rakPeer->incomingPasswordBitStream.GetNumberOfBytesUsed()==passwordLength &&
+				memcmp(password, rakPeer->incomingPasswordBitStream.GetData(), passwordLength)==0)
+			{
+				if (rakPeer->usingSecurity==false)
 				{
-					// This one we only send once since we don't care if it arrives.
-					unsigned char c = ID_CONNECTION_BANNED;
-					SocketLayer::Instance()->SendTo(rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId);
-				}
-				else if (rakPeer->incomingPasswordBitStream.GetNumberOfBytesUsed()==passwordLength &&
-					memcmp(password, rakPeer->incomingPasswordBitStream.GetData(), passwordLength)==0)
-				{
+#ifdef _TEST_AES
+					unsigned char AESKey[16];
+					// Save the AES key
+					for (i=0; i < 16; i++)
+						AESKey[i]=i;
+					rakPeer->HandleConnectionRequest(playerId, AESKey, true);
+#else
 					// Connect this player assuming we have open slots
 					rakPeer->HandleConnectionRequest(playerId, 0, false);
+#endif
 				}
 				else
-				{
-					// This one we only send once since we don't care if it arrives.
-					unsigned char c = ID_INVALID_PASSWORD;
-					SocketLayer::Instance()->SendTo(rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId);
-				}
+					rakPeer->SecuredConnectionResponse(playerId);
+				
 			}
 			else
 			{
-				rakPeer->SecuredConnectionResponse(playerId);
+				// This one we only send once since we don't care if it arrives.
+				unsigned char c = ID_INVALID_PASSWORD;
+				SocketLayer::Instance()->SendTo(rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId.binaryAddress, playerId.port);
 			}
 		}
 		else if ((unsigned char)(data)[0]== ID_SECURED_CONNECTION_RESPONSE &&
-			// 20 SHA1 + 1 packet header + 4 public key + sizeof(securedConnectionByteSize)
-			length >= 25 + sizeof(rakPeer->securedConnectionByteSize))
+			length==1+sizeof(big::u32) + sizeof(RSA_BIT_SIZE) + 20)
 		{
-			rakPeer->SecuredConnectionConfirmation(playerId, data, length);
+			rakPeer->SecuredConnectionConfirmation(playerId, data);
 		}
 		else if ((unsigned char)(data)[0]== ID_SECURED_CONNECTION_CONFIRMATION &&
-			// 20 Syn cookie + 1 packet header + 20 encoded random number
-			length >= 41)
+			length==1+20+sizeof(RSA_BIT_SIZE))
 		{
 			CSHA1 sha1;
 			bool confirmedHash, newRandomNumber;
@@ -2841,7 +2796,7 @@
 				confirmedHash=true;
 				newRandomNumber=true;
 			}
-			else if (rakPeer->randomNumberExpirationTime < getTime())
+			else if (rakPeer->randomNumberExpirationTime < RakNetGetTime())
 			{
 				sha1.Reset();
 				sha1.Update((unsigned char*)&playerId.binaryAddress, sizeof(playerId.binaryAddress));
@@ -2855,20 +2810,18 @@
 
 			if (confirmedHash)
 			{
-				mpuint source,result;
 				int i;
 				unsigned char AESKey[16];
+				RSA_BIT_SIZE message,encryptedMessage;
 
 				// On connection accept, AES key is c2s RSA_Decrypt(random number) XOR s2c syn-cookie
 				// Get the random number first
-				source.Init(rakPeer->securedConnectionByteSize);
-				result.Init(rakPeer->securedConnectionByteSize);
-				memcpy(source.value, data+1+20, rakPeer->securedConnectionByteSize);
-				EncryptDecrypt(result, source, rakPeer->d, rakPeer->n);
+				memcpy(encryptedMessage, data+1+20, sizeof(RSA_BIT_SIZE));
+				rakPeer->rsacrypt.decrypt(encryptedMessage, message);
 
 				// Save the AES key
 				for (i=0; i < 16; i++)
-					AESKey[i]=data[1+i] ^ ((unsigned char*)(result.value))[i];
+					AESKey[i]=data[1+i] ^ ((unsigned char*)(message))[i];
 
 				// Connect this player assuming we have open slots
 				rakPeer->HandleConnectionRequest(playerId,AESKey, true);
@@ -2882,12 +2835,13 @@
 		{
 			 // Make sure this connection accept is from someone we wanted to connect to
 			bool requestedConnection;
-//			unsigned long time = getTime();
+//			unsigned long time = RakNetGetTime();
 			unsigned char AESKey[16];
 			bool setAESKey;
 			setAESKey=false;
 			requestedConnection=false;
-			rakPeer->rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+			if (rakPeer->threadSleepTimer>=0)
+				rakPeer->rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
 			for (i=0; i < rakPeer->requestedConnectionsList.size();i++)
 			{
 				if (rakPeer->requestedConnectionsList[i]->playerId==playerId)
@@ -2902,14 +2856,23 @@
 					break;
 				}
 			}
-			rakPeer->rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+			if (rakPeer->threadSleepTimer>=0)
+				rakPeer->rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 
 			 if (requestedConnection)
 			 {
 				// Find a free remote system struct to use
 				ConnectionAcceptStruct* cas = (ConnectionAcceptStruct*) data;
 				playerId.port=cas->remotePort;
+
+#ifdef _TEST_AES
+				// Save the AES key
+				for (i=0; i < 16; i++)
+					AESKey[i]=i;
+				remoteSystem=rakPeer->AssignPlayerIDToRemoteSystemList(playerId, AESKey,true);
+#else
 				remoteSystem=rakPeer->AssignPlayerIDToRemoteSystemList(playerId, AESKey,setAESKey);
+#endif
 
 				if (remoteSystem!=0)
 				{
@@ -2923,9 +2886,9 @@
 					// Create a new nonblocking socket
 					remoteSystem->reliabilityLayer.SetSocket(SocketLayer::Instance()->CreateBoundSocket(rakPeer->myPlayerId.port, false));
 
-					SocketLayer::Instance()->Connect(remoteSystem->reliabilityLayer.GetSocket(), playerId);
+					SocketLayer::Instance()->Connect(remoteSystem->reliabilityLayer.GetSocket(), playerId.binaryAddress, playerId.port);
 					// Associate our new socket with a completion port and do the first read
-					b=SocketLayer::Instance()->AssociateSocketWithCompletionPortAndRead(remoteSystem->reliabilityLayer.GetSocket(), playerId, rakPeer);
+					b=SocketLayer::Instance()->AssociateSocketWithCompletionPortAndRead(remoteSystem->reliabilityLayer.GetSocket(), playerId.binaryAddress, playerId.port, rakPeer);
 					//client->//reliabilityLayerMutex.Unlock();
 
 					if (b==false) // Some damn completion port error... windows is so unreliable
@@ -2939,11 +2902,13 @@
 
 					// Send the connection request complete to the game
 					Packet *packet = PacketPool::Instance()->GetPointer();
-					packet->data = new char[1];
-					packet->data[0]=ID_CONNECTION_REQUEST_ACCEPTED;
-					packet->length=sizeof(char);
-					packet->bitSize=sizeof(char)*8;
+					packet->data = new unsigned char[sizeof(ConnectionAcceptStruct)];
+					memcpy(packet->data, data, sizeof(ConnectionAcceptStruct));
+					// packet->data[0]=ID_CONNECTION_REQUEST_ACCEPTED;
+					packet->length=sizeof(ConnectionAcceptStruct);
+					packet->bitSize=sizeof(ConnectionAcceptStruct)*8;
 					packet->playerId=playerId;
+					packet->playerIndex=(PlayerIndex)rakPeer->GetIndexFromPlayerID(playerId);
 
 					#ifdef _DEBUG
 					assert(packet->data);
@@ -2956,7 +2921,7 @@
 					newIncomingConnectionStruct.typeId=ID_NEW_INCOMING_CONNECTION;
 					newIncomingConnectionStruct.externalID=playerId;
 
-					rakPeer->Send((char*)&newIncomingConnectionStruct, sizeof(newIncomingConnectionStruct), HIGH_PRIORITY, RELIABLE, 0, playerId, false);
+					rakPeer->Send((char*)&newIncomingConnectionStruct, sizeof(newIncomingConnectionStruct), SYSTEM_PRIORITY, RELIABLE, 0, playerId, false);
 					rakPeer->Ping(playerId);
 					rakPeer->SendStaticData(playerId);
 				}
@@ -2964,7 +2929,7 @@
 				{
 					// Cancel the connection attempt
 					char c = ID_DISCONNECTION_NOTIFICATION;
-					SocketLayer::Instance()->SendTo( rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId);
+					SocketLayer::Instance()->SendTo( rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId.binaryAddress, playerId.port);
 				}
 			}
 			 else
@@ -2974,26 +2939,28 @@
 #endif
 			 }
 		 }
-		 else if ((unsigned char)(data)[0]== ID_PING && length==sizeof(UnconnectedPingStruct))
+		 else if (((unsigned char)(data)[0]== ID_PING  || (unsigned char)(data)[0]==ID_PING_OPEN_CONNECTIONS) && length==sizeof(UnconnectedPingStruct))
 		 {
+			 if ((unsigned char)(data)[0]==ID_PING_OPEN_CONNECTIONS && rakPeer->GetMaximumIncomingConnections()==0)
+				 return; // Sender wanted to get replies only for systems accepting connections
 			 data[0]=ID_PONG;
-			 SocketLayer::Instance()->SendTo( rakPeer->connectionSocket, data, sizeof(UnconnectedPingStruct), playerId);
+			 SocketLayer::Instance()->SendTo( rakPeer->connectionSocket, data, sizeof(UnconnectedPingStruct), playerId.binaryAddress, playerId.port);
 		 }
 		 else if ((unsigned char)(data)[0]== ID_PONG && length==sizeof(UnconnectedPingStruct))
 		 {
 			 Packet *packet = PacketPool::Instance()->GetPointer();
 
-			 packet->data = new char [sizeof(UnconnectedPingStruct)];
+			 packet->data = new unsigned char [sizeof(UnconnectedPingStruct)];
 			 unsigned long time;
 			 memcpy((char*)&time, data+sizeof(unsigned char), sizeof(unsigned long));
-			 time = getTime() - time;
+			 time = RakNetGetTime() - time;
 			 packet->data[0]=ID_PONG;
 			 memcpy(packet->data+sizeof(unsigned char), (char*)&time, sizeof(unsigned long));
 			 
 			 packet->length=sizeof(UnconnectedPingStruct);
 			 packet->bitSize=sizeof(UnconnectedPingStruct) * 8;
-
 			 packet->playerId=playerId;
+			 packet->playerIndex=(PlayerIndex)rakPeer->GetIndexFromPlayerID(playerId);
 
 			 rakPeer->incomingQueueMutex.Lock();
 			 (rakPeer->incomingPacketQueue).push(packet);
@@ -3002,7 +2969,7 @@
 		 else if ((unsigned char)(data)[0]==ID_NO_FREE_INCOMING_CONNECTIONS && length==sizeof(unsigned char))
 		 {
 			 Packet *packet = PacketPool::Instance()->GetPointer();
-			 packet->data = new char [1 * sizeof(unsigned char)];
+			 packet->data = new unsigned char [1 * sizeof(unsigned char)];
 			 packet->data[0]=ID_NO_FREE_INCOMING_CONNECTIONS;
 			 packet->length=1 * sizeof(unsigned char);
 			 packet->bitSize=8 * sizeof(unsigned char);
@@ -3013,7 +2980,7 @@
 		 else if ((unsigned char)(data)[0]==ID_CONNECTION_BANNED && length==sizeof(unsigned char))
 		 {
 			 Packet *packet = PacketPool::Instance()->GetPointer();
-			 packet->data = new char [1 * sizeof(unsigned char)];
+			 packet->data = new unsigned char [1 * sizeof(unsigned char)];
 			 packet->data[0]=ID_CONNECTION_BANNED;
 			 packet->length=1 * sizeof(unsigned char);
 			 packet->bitSize=8 * sizeof(unsigned char);
@@ -3024,380 +2991,457 @@
 	}
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-#ifdef _WIN32
-unsigned __stdcall UpdateNetworkLoop(LPVOID arguments)
-#else
-void*  UpdateNetworkLoop( void*  arguments )
-#endif
+bool RakPeer::RunUpdateCycle(void)
 {
-	RakPeer *rakPeer = (RakPeer *)arguments;
-	RakPeer::RemoteSystemStruct* remoteSystemList=rakPeer->remoteSystemList;
 	RakPeer::RemoteSystemStruct* remoteSystem;
 	unsigned remoteSystemIndex;
 	Packet *packet;
 	long ping, lastPing;
-	bool anyPeersActive;
-	int currentSentBytes,currentReceivedBytes,lastSentBytes,lastReceivedBytes;
-	unsigned long time,nextReadBytesTime;
+//	int currentSentBytes,currentReceivedBytes;
 	unsigned numberOfBytesUsed;
 	unsigned numberOfBitsUsed;
 	//PlayerID authoritativeClientPlayerId;
-	BitStream dataBitStream(MAXIMUM_MTU_SIZE);
 	int bitSize, byteSize;
 	char *data;
-	unsigned short maximumNumberOfPeers;
+	int errorCode;
+	bool gotData;
+	unsigned long time;
 
-	// For histogram statistics
-	lastSentBytes=lastReceivedBytes=0;
-	nextReadBytesTime=0;
+	do
+	{
+		// Read a packet
+		gotData=SocketLayer::Instance()->RecvFrom(connectionSocket, this, &errorCode);
 
-	maximumNumberOfPeers = rakPeer->maximumNumberOfPeers;
+		if (gotData==false)
+		{
 
-	rakPeer->isMainLoopThreadActive=true;
+#ifdef _WIN32
+			if (errorCode==WSAECONNRESET)
+			{
+				PushPortRefused(UNASSIGNED_PLAYER_ID);
+				//closesocket(peer->connectionSocket);
 
-	while(rakPeer->endThreads==false)
-	{
-		// We calculate this from the lowest numerical player ID
-		//authoritativeClientPlayerId=UNASSIGNED_PLAYER_ID;
+				//peer->connectionSocket = SocketLayer::Instance()->CreateBoundSocket(peer->myPlayerId.port, true);
+			}
+			else if (errorCode!=0 && endThreads==false)
+			{
+#ifdef _DEBUG
+				printf("Server RecvFrom critical failure!\n");
+#endif
+				// Some kind of critical error
+				//	peer->isRecvfromThreadActive=false;
+				endThreads=true;
+				Disconnect(0L);
+				return false;
+			}
+#else
+			if (errorCode==-1)
+			{
+				//	isRecvfromThreadActive=false;
+				endThreads=true;
+				Disconnect(0L);
+				return false;
+			}
+#endif
+		}
+		if (endThreads)
+			return false;
+	} while (gotData); // Read until there is nothing left
 
-		// Get the current system time
-		time = getTime();
+	time = RakNetGetTime();
 
-		anyPeersActive=false;
-
-		// Update the requested connection list.
-		if (rakPeer->requestedConnectionsList.size()>0)
+	// Update the requested connection list.
+	if (requestedConnectionsList.size()>0)
+	{
+		remoteSystemIndex=0;
+		if (threadSleepTimer>=0)
+			rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+		while (remoteSystemIndex < requestedConnectionsList.size())
 		{
-			remoteSystemIndex=0;
-			rakPeer->rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
-			while (remoteSystemIndex < rakPeer->requestedConnectionsList.size())
+			// After X seconds give up
+			if (time - requestedConnectionsList[remoteSystemIndex]->time > SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION*2)
 			{
-				// After X seconds give up
-				if (time - rakPeer->requestedConnectionsList[remoteSystemIndex]->time > SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION)
-				{
-                    delete rakPeer->requestedConnectionsList[remoteSystemIndex];
-					rakPeer->requestedConnectionsList.del(remoteSystemIndex);
-				}
-				else if (time > rakPeer->requestedConnectionsList[remoteSystemIndex]->nextRequestTime)
-				{
-					rakPeer->SendConnectionRequest(
-						rakPeer->PlayerIDToDottedIP(rakPeer->requestedConnectionsList[remoteSystemIndex]->playerId),
-						rakPeer->requestedConnectionsList[remoteSystemIndex]->playerId.port);
+				delete requestedConnectionsList[remoteSystemIndex];
+				requestedConnectionsList.del(remoteSystemIndex);
+			}
+			else if (time > requestedConnectionsList[remoteSystemIndex]->nextRequestTime)
+			{
+				SendConnectionRequest(
+					PlayerIDToDottedIP(requestedConnectionsList[remoteSystemIndex]->playerId),
+					requestedConnectionsList[remoteSystemIndex]->playerId.port);
 
-					// Send again 2 seconds later
-					rakPeer->requestedConnectionsList[remoteSystemIndex]->nextRequestTime=time + 2000;
-					remoteSystemIndex++;
-				}
-				else
-					remoteSystemIndex++;
+				// Send again 2 seconds later
+				requestedConnectionsList[remoteSystemIndex]->nextRequestTime=time + 2000;
+				remoteSystemIndex++;
 			}
-			rakPeer->rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+			else
+				remoteSystemIndex++;
 		}
+		if (threadSleepTimer>=0)
+			rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+	}
 
-		for (remoteSystemIndex=0; remoteSystemIndex < maximumNumberOfPeers; ++remoteSystemIndex)
+	for (remoteSystemIndex=0; remoteSystemIndex < maximumNumberOfPeers; ++remoteSystemIndex)
+	{
+		if (remoteSystemList[remoteSystemIndex].playerId!=UNASSIGNED_PLAYER_ID)
 		{
-			if (remoteSystemList[remoteSystemIndex].playerId!=UNASSIGNED_PLAYER_ID)
+			// Found an active remote system
+			remoteSystem = remoteSystemList+remoteSystemIndex;
+			// Update is only safe to call from the same thread that calls HandleSocketReceiveFromConnectedPlayer,
+			// which is this thread
+			remoteSystem->reliabilityLayer.Update(connectionSocket, remoteSystem->playerId, MTUSize, time);
+
+			// Was the reliability layer unable to deliver a reliable packet?
+			if (remoteSystem->reliabilityLayer.IsDeadConnection())
 			{
-				// Found an active remote system
-				remoteSystem = remoteSystemList+remoteSystemIndex;
-				remoteSystem->reliabilityLayer.Update(rakPeer->connectionSocket, remoteSystem->playerId, rakPeer->MTUSize);
+				packet = PacketPool::Instance()->GetPointer();
 
-				anyPeersActive=true;
+				packet->data = new unsigned char [sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed()];
+				packet->data[0]=ID_CONNECTION_LOST;
+				memcpy(packet->data+sizeof(char), remoteSystem->staticData.GetData(), remoteSystem->staticData.GetNumberOfBytesUsed());
 
-				// Was the reliability layer unable to deliver a reliable packet?
-				if (remoteSystem->reliabilityLayer.IsDeadConnection())
-				{
-					packet = PacketPool::Instance()->GetPointer();
+				packet->length=sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed();
+				packet->bitSize=(sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed()) * 8;
+				packet->playerId=remoteSystem->playerId;
+				packet->playerIndex=(PlayerIndex)remoteSystemIndex;
 
-					packet->data = new char [sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed()];
-					packet->data[0]=ID_CONNECTION_LOST;
-					memcpy(packet->data+sizeof(char), remoteSystem->staticData.GetData(), remoteSystem->staticData.GetNumberOfBytesUsed());
+				incomingQueueMutex.Lock();
+				(incomingPacketQueue).push(packet);
+				incomingQueueMutex.Unlock();
 
-					packet->length=sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed();
-					packet->bitSize=(sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed()) * 8;
+				CloseConnection(remoteSystem->playerId, false, 0L);
+				continue;
+			}
 
-					packet->playerId=remoteSystem->playerId;
+			// Did the reliability layer detect a modified packet?
+			if (remoteSystem->reliabilityLayer.IsCheater())
+			{
+				packet = PacketPool::Instance()->GetPointer();
+				packet->length=1;
+				packet->data = new unsigned char [1];
+				packet->data[0] = (unsigned char)ID_MODIFIED_PACKET;
+				packet->playerId=remoteSystem->playerId;
+				packet->playerIndex=(PlayerIndex)remoteSystemIndex;
 
-					rakPeer->incomingQueueMutex.Lock();
-					(rakPeer->incomingPacketQueue).push(packet);
-					rakPeer->incomingQueueMutex.Unlock();
+				incomingQueueMutex.Lock();
+				(incomingPacketQueue).push(packet);
+				incomingQueueMutex.Unlock();
 
-					rakPeer->CloseConnection(remoteSystem->playerId, false);
-					continue;
-				}
+				continue;
+			}
 
-				// Did the reliability layer detect a modified packet?
-				if (remoteSystem->reliabilityLayer.IsCheater())
-				{
-					packet = PacketPool::Instance()->GetPointer();
-					packet->length=1;
-					packet->data = new char [1];
-					packet->data[0] = (unsigned char)ID_MODIFIED_PACKET;
-					packet->playerId=remoteSystem->playerId;
+			// Ping this guy if it is time to do so
+			if (time > remoteSystem->nextPingTime && (occasionalPing || remoteSystem->lowestPing==-1))
+			{
+				remoteSystem->nextPingTime = time + 5000;
+				Ping(remoteSystem->playerId);
+			}
 
-					rakPeer->incomingQueueMutex.Lock();
-					(rakPeer->incomingPacketQueue).push(packet);
-					rakPeer->incomingQueueMutex.Unlock();
+			// Find whoever has the lowest player ID
+			//if (remoteSystem->playerId < authoritativeClientPlayerId)
+			//	authoritativeClientPlayerId=remoteSystem->playerId;
 
-					continue;
-				}
+			// Does the reliability layer have any packets waiting for us?
+			// To be thread safe, this has to be called in the same thread as HandleSocketReceiveFromConnectedPlayer
+			bitSize = remoteSystem->reliabilityLayer.Receive(&data);
 
-				if (rakPeer->occasionalPing)
+			while (bitSize > 0)
+			{
+				// Put the input through compression if necessary
+				if (inputTree)
 				{
-					// Ping this guy if it is time to do so
-					if (time > remoteSystem->nextPingTime)
+					RakNet::BitStream dataBitStream(MAXIMUM_MTU_SIZE);
+					// Since we are decompressing input, we need to copy to a bitstream, decompress, then copy back to a probably
+					// larger data block.  It's slow, but the user should have known that anyway
+					dataBitStream.Reset();
+					dataBitStream.WriteAlignedBytes((unsigned char*)data, BITS_TO_BYTES(bitSize));
+					numberOfBytesUsed = dataBitStream.GetNumberOfBytesUsed();
+					numberOfBitsUsed = dataBitStream.GetNumberOfBitsUsed();
+					rawBytesReceived+=numberOfBytesUsed;
+					// Decompress the input data.
+
+#ifdef _DEBUG
+					assert(numberOfBitsUsed>0);
+#endif
+					unsigned char *dataCopy = new unsigned char[numberOfBytesUsed];
+					memcpy(dataCopy, dataBitStream.GetData(), numberOfBytesUsed);
+					dataBitStream.Reset();
+					inputTree->DecodeArray(dataCopy,numberOfBitsUsed, &dataBitStream);
+					compressedBytesReceived+=dataBitStream.GetNumberOfBytesUsed();
+					delete [] dataCopy;
+
+					byteSize = dataBitStream.GetNumberOfBytesUsed();
+					if (byteSize > BITS_TO_BYTES(bitSize)) // Probably the case - otherwise why decompress?
 					{
-						remoteSystem->nextPingTime = time + 5000;
-						rakPeer->Ping(remoteSystem->playerId);
+						delete [] data;
+						data = new char [byteSize];
 					}
+					memcpy(data, dataBitStream.GetData(), byteSize);
 				}
+				else
+					// Fast and easy - just use the data that was returned
+					byteSize = BITS_TO_BYTES(bitSize);
 
-				// Find whoever has the lowest player ID
-				//if (remoteSystem->playerId < authoritativeClientPlayerId)
-				//	authoritativeClientPlayerId=remoteSystem->playerId;
+				// Read any system packets
+				if ((unsigned char)data[0]==ID_PONG && byteSize==sizeof(PingStruct))
+				{
+					// Copy into the ping times array the current time - the value returned
+					// First extract the sent ping
+					PingStruct *ps = (PingStruct *)data;
 
-				// Does the reliability layer have any packets waiting for us?
-				bitSize = remoteSystem->reliabilityLayer.Receive(&data);
+					ping=time - ps->sendPingTime;
+					lastPing = remoteSystem->pingAndClockDifferential[remoteSystem->pingAndClockDifferentialWriteIndex].pingTime;
 
-				while (bitSize > 0)
-				{
-					// Put the input through compression if necessary
-					if (rakPeer->inputTree)
+					// Ignore super high spikes in the average
+					if (lastPing <= 0 || (((int)ping < (lastPing * 3)) && ping < 1200))
 					{
-						// Since we are decompressing input, we need to copy to a bitstream, decompress, then copy back to a probably
-						// larger data block.  It's slow, but the user should have known that anyway
-						dataBitStream.Reset();
-						dataBitStream.WriteAlignedBytes((unsigned char*)data, BITS_TO_BYTES(bitSize));
-						numberOfBytesUsed = dataBitStream.GetNumberOfBytesUsed();
-						numberOfBitsUsed = dataBitStream.GetNumberOfBitsUsed();
-						rakPeer->rawBytesRecieved+=numberOfBytesUsed;
-						// Decompress the input data.
-						if (rakPeer->inputTree)
-						{
-#ifdef _DEBUG
-							assert(numberOfBitsUsed>0);
-#endif
-							unsigned char *dataCopy = new unsigned char[numberOfBytesUsed];
-							memcpy(dataCopy, dataBitStream.GetData(), numberOfBytesUsed);
-							dataBitStream.Reset();
-							rakPeer->inputTree->DecodeArray(dataCopy,numberOfBitsUsed, &dataBitStream);
-							rakPeer->compressedBytesRecieved+=dataBitStream.GetNumberOfBytesUsed();
-							delete [] dataCopy;
-						}
-						byteSize = dataBitStream.GetNumberOfBytesUsed();
-						if (byteSize > BITS_TO_BYTES(bitSize)) // Probably the case - otherwise why decompress?
-						{
-							delete [] data;
-							data = new char [byteSize];
-						}
-						memcpy(data, dataBitStream.GetData(), byteSize);
+						remoteSystem->pingAndClockDifferential[remoteSystem->pingAndClockDifferentialWriteIndex].pingTime=(short)ping;
+						// Thanks to Chris Taylor (cat02e at fsu.edu) for the improved timestamping algorithm
+						remoteSystem->pingAndClockDifferential[remoteSystem->pingAndClockDifferentialWriteIndex].clockDifferential=ps->sendPongTime - (time + ps->sendPingTime) / 2;
+						if (remoteSystem->lowestPing==-1 ||  remoteSystem->lowestPing > ping)
+							remoteSystem->lowestPing = ping;
+						// Most packets should arrive by the ping time.
+						remoteSystem->reliabilityLayer.SetLostPacketResendDelay(ping*2);
+
+						if (++(remoteSystem->pingAndClockDifferentialWriteIndex) == PING_TIMES_ARRAY_SIZE)
+							remoteSystem->pingAndClockDifferentialWriteIndex=0;
 					}
-					else
-						// Fast and easy - just use the data that was returned
-						byteSize = BITS_TO_BYTES(bitSize);
 
-					// Read any system packets
-					if ((unsigned char)data[0]==ID_PONG && byteSize==sizeof(PingStruct))
-					{
-						// Copy into the ping times array the current time - the value returned
-						// First extract the sent ping
-						PingStruct *ps = (PingStruct *)data;
+					delete [] data;
+				}
+				else if ((unsigned char)data[0]==ID_PING && byteSize==sizeof(PingStruct))
+				{
+					PingStruct *ps = (PingStruct*)data;
+					ps->typeId=ID_PONG;
+					ps->sendPongTime=RakNetGetTime();
 
-						ping=time - ps->sendPingTime;
-						lastPing = remoteSystem->pingAndClockDifferential[remoteSystem->pingAndClockDifferentialWriteIndex].pingTime;
+					Send(data,byteSize, SYSTEM_PRIORITY, UNRELIABLE, 0, remoteSystem->playerId, false);
+					delete [] data;
+				}
+				else if ((unsigned char)data[0]==ID_NEW_INCOMING_CONNECTION && byteSize==sizeof(NewIncomingConnectionStruct))
+				{
+					Ping(remoteSystem->playerId);
+					SendStaticData(remoteSystem->playerId);
 
-						// Ignore super high spikes in the average
-						if (lastPing <= 0 || (((int)ping < (lastPing * 3)) && ping < 1200))
-						{
-							remoteSystem->pingAndClockDifferential[remoteSystem->pingAndClockDifferentialWriteIndex].pingTime=(short)ping;
-							// Thanks to Chris Taylor (cat02e at fsu.edu) for the improved timestamping algorithm
-							remoteSystem->pingAndClockDifferential[remoteSystem->pingAndClockDifferentialWriteIndex].clockDifferential=ps->sendPongTime - (time + ps->sendPingTime) / 2;
-							if (remoteSystem->lowestPing==-1 ||  remoteSystem->lowestPing > ping)
-								remoteSystem->lowestPing = ping;
-							remoteSystem->reliabilityLayer.SetLostPacketResendDelay(ping * 6);
+					NewIncomingConnectionStruct *newIncomingConnectionStruct = (NewIncomingConnectionStruct *) data;
+					remoteSystem->myExternalPlayerId=newIncomingConnectionStruct->externalID;
 
-							if (++(remoteSystem->pingAndClockDifferentialWriteIndex) == PING_TIMES_ARRAY_SIZE)
-								remoteSystem->pingAndClockDifferentialWriteIndex=0;
-						}
+					// Send this info down to the game
+					packet = PacketPool::Instance()->GetPointer();
+					packet->data = (unsigned char*)data;
+					packet->length=byteSize;
+					packet->bitSize=bitSize;
+					packet->playerId=remoteSystem->playerId;
+					packet->playerIndex=(PlayerIndex)remoteSystemIndex;
 
-						delete [] data;
-					}
-					else if ((unsigned char)data[0]==ID_PING && byteSize==sizeof(PingStruct))
+#ifdef _DEBUG
+					assert(packet->data);
+#endif
+					incomingQueueMutex.Lock();
+					incomingPacketQueue.push(packet);
+					incomingQueueMutex.Unlock();
+				}
+				/*
+				else if ((unsigned char)data[0]==ID_SYNCHRONIZE_MEMORY)
+				{
+				if (byteSize>2)
+				{
+				packet = PacketPool::Instance()->GetPointer();
+				packet->data = data;
+				packet->length=byteSize;
+				packet->bitSize=bitSize;
+				packet->playerId=remoteSystem->playerId;
+
+				synchronizedMemoryQueueMutex.Lock();
+				synchronizedMemoryPacketQueue.push(packet);
+				synchronizedMemoryQueueMutex.Unlock();
+				}
+				else
+				delete [] data;
+				}
+				*/
+				else if ((unsigned char)data[0]==ID_DISCONNECTION_NOTIFICATION)
+				{
+					packet = PacketPool::Instance()->GetPointer();
+					if (remoteSystem->staticData.GetNumberOfBytesUsed()>0)
 					{
-						PingStruct *ps = (PingStruct*)data;
-						ps->typeId=ID_PONG;
-						ps->sendPongTime=getTime();
+						packet->data = new unsigned char [sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed()];
+						packet->data[0]=ID_DISCONNECTION_NOTIFICATION;
+						memcpy(packet->data+sizeof(char), remoteSystem->staticData.GetData(), remoteSystem->staticData.GetNumberOfBytesUsed());
 
-						rakPeer->Send(data,byteSize, HIGH_PRIORITY, UNRELIABLE, 0, remoteSystem->playerId, false);
+						packet->length=sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed();
+						packet->bitSize=sizeof(char)*8 + remoteSystem->staticData.GetNumberOfBitsUsed();
+
 						delete [] data;
 					}
-					else if ((unsigned char)data[0]==ID_NEW_INCOMING_CONNECTION && byteSize==sizeof(NewIncomingConnectionStruct))
+					else
 					{
-						rakPeer->Ping(remoteSystem->playerId);
-						rakPeer->SendStaticData(remoteSystem->playerId);
-
-						NewIncomingConnectionStruct *newIncomingConnectionStruct = (NewIncomingConnectionStruct *) data;
-						remoteSystem->myExternalPlayerId=newIncomingConnectionStruct->externalID;
-
-						// Send this info down to the game
-						packet = PacketPool::Instance()->GetPointer();
-						packet->data = data;
-						packet->length=byteSize;
+						packet->data=(unsigned char*)data;
 						packet->bitSize=bitSize;
-						packet->playerId=remoteSystem->playerId;
-
-#ifdef _DEBUG
-						assert(packet->data);
-#endif
-						rakPeer->incomingQueueMutex.Lock();
-						rakPeer->incomingPacketQueue.push(packet);
-						rakPeer->incomingQueueMutex.Unlock();
+						packet->length=1;
 					}
-					/*
-					else if ((unsigned char)data[0]==ID_SYNCHRONIZE_MEMORY)
-					{
-						if (byteSize>2)
-						{
-							packet = PacketPool::Instance()->GetPointer();
-							packet->data = data;
-							packet->length=byteSize;
-							packet->bitSize=bitSize;
-							packet->playerId=remoteSystem->playerId;
 
-							rakPeer->synchronizedMemoryQueueMutex.Lock();
-							rakPeer->synchronizedMemoryPacketQueue.push(packet);
-							rakPeer->synchronizedMemoryQueueMutex.Unlock();
-						}
-						else
-							delete [] data;
-					}
-					*/
-					else if ((unsigned char)data[0]==ID_DISCONNECTION_NOTIFICATION)
-					{
-						packet = PacketPool::Instance()->GetPointer();
-						if (remoteSystem->staticData.GetNumberOfBytesUsed()>0)
-						{
-							packet->data = new char [sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed()];
-							packet->data[0]=ID_DISCONNECTION_NOTIFICATION;
-							memcpy(packet->data+sizeof(char), remoteSystem->staticData.GetData(), remoteSystem->staticData.GetNumberOfBytesUsed());
+					packet->playerId=remoteSystem->playerId;
+					packet->playerIndex=(PlayerIndex)remoteSystemIndex;
 
-							packet->length=sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed();
-							packet->bitSize=sizeof(char)*8 + remoteSystem->staticData.GetNumberOfBitsUsed();
+					CloseConnection(remoteSystem->playerId, false, 0L);
 
-							delete [] data;
-						}
-						else
-						{
-							packet->data=data;
-							packet->bitSize=bitSize;
-							packet->length=1;
-						}
-
-						packet->playerId=remoteSystem->playerId;
-
-						rakPeer->CloseConnection(remoteSystem->playerId, false);
-
 #ifdef _DEBUG
-						assert(packet->data);
+					assert(packet->data);
 #endif
-						// Relay this message to the game
-						rakPeer->incomingQueueMutex.Lock();
-						rakPeer->incomingPacketQueue.push(packet);
-						rakPeer->incomingQueueMutex.Unlock();
+					// Relay this message to the game
+					incomingQueueMutex.Lock();
+					incomingPacketQueue.push(packet);
+					incomingQueueMutex.Unlock();
 
-					}
-					else if ((unsigned char)data[0]==ID_REQUEST_STATIC_DATA)
-					{
-						rakPeer->SendStaticData(remoteSystem->playerId);
-						delete [] data;
-					}
-					else if ((unsigned char)data[0] == ID_RECEIVED_STATIC_DATA)
-					{
-						remoteSystem->staticData.Reset();
-						remoteSystem->staticData.Write((char*)data+sizeof(unsigned char), byteSize-1);
+				}
+				else if ((unsigned char)data[0]==ID_REQUEST_STATIC_DATA)
+				{
+					SendStaticData(remoteSystem->playerId);
+					delete [] data;
+				}
+				else if ((unsigned char)data[0] == ID_RECEIVED_STATIC_DATA)
+				{
+					remoteSystem->staticData.Reset();
+					remoteSystem->staticData.Write((char*)data+sizeof(unsigned char), byteSize-1);
 
-						// Inform game server code that we got static data
-						packet = PacketPool::Instance()->GetPointer();
-						packet->data = data;
-						packet->length = byteSize;
-						packet->bitSize=bitSize;
-						packet->playerId = remoteSystem->playerId;
+					// Inform game server code that we got static data
+					packet = PacketPool::Instance()->GetPointer();
+					packet->data = (unsigned char*)data;
+					packet->length = byteSize;
+					packet->bitSize=bitSize;
+					packet->playerId = remoteSystem->playerId;
+					packet->playerIndex=(PlayerIndex)remoteSystemIndex;
 
 #ifdef _DEBUG
-						assert(packet->data);
+					assert(packet->data);
 #endif
-						rakPeer->incomingQueueMutex.Lock();
-						rakPeer->incomingPacketQueue.push(packet);
-						rakPeer->incomingQueueMutex.Unlock();
-					}
-					else if ((unsigned char)data[0] == ID_RPC || (unsigned char)data[0] == ID_RPC_WITH_TIMESTAMP)
-					{
-						rakPeer->HandleRPCPacket(data, byteSize, remoteSystem->playerId);
-						delete [] data;
-					}
-					else
-					{
-						packet = PacketPool::Instance()->GetPointer();
-						packet->data = data;
-						packet->length=byteSize;
-						packet->bitSize=bitSize;
-						packet->playerId=remoteSystem->playerId;
+					incomingQueueMutex.Lock();
+					incomingPacketQueue.push(packet);
+					incomingQueueMutex.Unlock();
+				}
+				else
+				{
+					packet = PacketPool::Instance()->GetPointer();
+					packet->data = (unsigned char*)data;
+					packet->length=byteSize;
+					packet->bitSize=bitSize;
+					packet->playerId=remoteSystem->playerId;
+					packet->playerIndex=(PlayerIndex)remoteSystemIndex;
 
 #ifdef _DEBUG
-						assert(packet->data);
+					assert(packet->data);
 #endif
-						rakPeer->incomingQueueMutex.Lock();
-						rakPeer->incomingPacketQueue.push(packet);
-						rakPeer->incomingQueueMutex.Unlock();
-					}
+					incomingQueueMutex.Lock();
+					incomingPacketQueue.push(packet);
+					incomingQueueMutex.Unlock();
+				}
 
-					// Does the reliability layer have any more packets waiting for us?
-					bitSize = remoteSystem->reliabilityLayer.Receive(&data);
-				}
+				// Does the reliability layer have any more packets waiting for us?
+				// To be thread safe, this has to be called in the same thread as HandleSocketReceiveFromConnectedPlayer
+				bitSize = remoteSystem->reliabilityLayer.Receive(&data);
 			}
 		}
+	}
 
 
-		// Statistics histogram
-		if (time > nextReadBytesTime)
+	/*
+	// Statistics histogram
+	if (time > nextReadBytesTime)
+	{
+		nextReadBytesTime = time + 1000L; // 1 second
+		for (remoteSystemIndex=0; remoteSystemIndex < maximumNumberOfPeers; ++remoteSystemIndex)
 		{
-			nextReadBytesTime = time + 1000L; // 1 second
-			currentSentBytes = rakPeer->GetBytesSent();
-			currentReceivedBytes = rakPeer->GetBytesReceived();
-			rakPeer->bytesSentPerSecond = currentSentBytes - lastSentBytes;
-			rakPeer->bytesReceivedPerSecond = currentReceivedBytes - lastReceivedBytes;
-			lastSentBytes=currentSentBytes;
-			lastReceivedBytes=currentReceivedBytes;
-		}
+		currentSentBytes = GetBytesSent();
+		currentReceivedBytes = GetBytesReceived();
+		bytesSentPerSecond = currentSentBytes - lastSentBytes;
+		bytesReceivedPerSecond = currentReceivedBytes - lastReceivedBytes;
+		lastSentBytes=currentSentBytes;
+		lastReceivedBytes=currentReceivedBytes;
+	}
+	*/
 
-		// Context switch so other threads can run
-		if (rakPeer->threadPriority==0)
+	return true;
+}
+// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+#ifdef _WIN32
+unsigned __stdcall UpdateNetworkLoop(LPVOID arguments)
+#else
+void*  UpdateNetworkLoop( void*  arguments )
+#endif
+{
+	RakPeer *rakPeer = (RakPeer *)arguments;
+//	unsigned long time;
+
+#ifdef __USE_IO_COMPLETION_PORTS
+	AsynchronousFileIO::Instance()->IncreaseUserCount();
+#endif
+
+	rakPeer->isMainLoopThreadActive=true;
+
+	while(rakPeer->endThreads==false)
+	{
+		/*
+		time=RakNetGetTime();
+
+		// Dynamic threading - how long we sleep and if we update
+		// depends on whether or not the user thread is updating
+		if (time > rakPeer->lastUserUpdateCycle && time - rakPeer->lastUserUpdateCycle > UPDATE_THREAD_UPDATE_TIME)
 		{
-			#ifdef _WIN32
-			Sleep(15);
-			#else
-			usleep(15 * 1000);
-			#endif
+			// Only one thread should call RunUpdateCycle at a time.  We don't need to delay calls so
+			// a mutex on the function is not necessary - only on the variable that indicates if the function is
+			// running
+			rakPeer->RunMutexedUpdateCycle();
+			
+
+			// User is not updating the network.  Sleep a short time
+#ifdef _WIN32
+				Sleep(rakPeer->threadSleepTimer);
+#else
+				usleep(rakPeer->threadSleepTimer * 1000);
+#endif
 		}
-		else if (rakPeer->threadPriority==1)
+		else
 		{
+			// User is actively updating the network.  Only occasionally poll
 #ifdef _WIN32
-			Sleep(0);
+			Sleep(UPDATE_THREAD_POLL_TIME);
 #else
-			usleep(0 * 1000);
+			usleep(UPDATE_THREAD_POLL_TIME * 1000);
 #endif
 		}
-
-		if (anyPeersActive==false)		
-		{
+		*/
+		rakPeer->RunUpdateCycle();
 #ifdef _WIN32
-			Sleep(30);
+		Sleep(rakPeer->threadSleepTimer);
 #else
-			usleep(30 * 1000);
+		usleep(rakPeer->threadSleepTimer * 1000);
 #endif
-		}
 	}
 	rakPeer->isMainLoopThreadActive=false;
 
+#ifdef __USE_IO_COMPLETION_PORTS
+	AsynchronousFileIO::Instance()->DecreaseUserCount();
+#endif
+
+
 	return 0;
 }
+
+/*
+void RakPeer::RunMutexedUpdateCycle(void)
+{
+	rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Lock();
+	if (updateCycleIsRunning==false)
+	{
+		updateCycleIsRunning=true;
+		rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Unlock();
+		RunUpdateCycle(); // Do one update per call to Receive
+		rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Lock();
+		updateCycleIsRunning=false;
+		rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Unlock();
+	}
+	else
+		rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Unlock();
+}
+*/

Modified: branches/multiplayer-branch/source/libraries/raknet/RakPeer.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/RakPeer.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/RakPeer.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -14,7 +14,8 @@
 #include "RakPeerInterface.h"
 #include "BinarySearchTree.h"
 #include "RPCNode.h"
-#include "MPUInt.h"
+#include "RSACrypt.h"
+#include "BitStream.h"
 
 class HuffmanEncodingTree;
 
@@ -42,11 +43,11 @@
 	// - A pure client would set this to 1.  A pure server would set it to the number of allowed clients.
 	// - A hybrid would set it to the sum of both types of connections
 	// localPort: The port to listen for connections on.
-	// _threadPriority: 0 for regular priority (0-8 players), 1 for high priority (High performance applications), and 2 for ultra-high priority (MMO server)
+	// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	//
 	// Returns:
 	// False on failure (can't create socket or thread), true on success.
-	bool Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadPriority);
+	bool Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadSleepTimer);
 
 	// Description:
 	// Must be called while offline
@@ -58,15 +59,13 @@
 	// If you accept connections, you must call this or else secure connections will not be enabled
 	// for incoming connections.
 	// If you are connecting to another system, you can call this with values for the
-	// (e and n) public keys before connecting to prevent MitM
+	// (e and p,q) public keys before connecting to prevent MitM
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAd - A pointer to the private key of length numberOfBytes.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
-	void InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn);
+	// RSAe, RSAn - Public keys generated from the RSACrypt class.  See the Encryption sample
+	// RSAp, RSAq - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+	// If the private keys are 0, then a new key will be generated when this function is called
+	void InitializeSecurity(char *RSAe, char *RSAn, char *RSAp, char *RSAq);
 
 	// Description
 	// Must be called while offline
@@ -98,13 +97,13 @@
 
 	// Description:
 	// Returns the password set by SetIncomingPassword in a BitStream
-	BitStream *GetIncomingPassword(void);
+	RakNet::BitStream *GetIncomingPassword(void);
 
 	// Description:
 	// Call this to connect to the specified host (ip or domain name) and server port.
 	// Calling Connect and not calling SetMaximumIncomingConnections acts as a dedicated client.  Calling both acts as a true peer.
 	// This is a non-blocking connection.  You know the connection is successful when IsConnected() returns true
-	// or receive gets a packet with the type identifier ID_ENUMERATION_REPLY.  If the connection is not
+	// or receive gets a packet with the type identifier ID_CONNECTION_ACCEPTED.  If the connection is not
 	// successful, such as rejected connection or no response then neither of these things will happen.
 	// Requires that you first call Initialize
 	//
@@ -120,7 +119,11 @@
 
 	// Description:
 	// Stops the network threads and close all connections.  Multiple calls are ok.
-	void Disconnect(void);
+	//
+	// Parameters:
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	void Disconnect(unsigned long blockDuration);
 
 	// Description:
 	// Returns true if the network threads are running
@@ -145,14 +148,14 @@
 	// bitStream: The bitstream to send
 	// priority: What priority level to send on.
 	// reliability: How reliability to send this data
-	// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+	// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 	// - Packets are only ordered relative to other packets on the same stream
 	// playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 	// broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 	// Returns:
 	// False if we are not connected to the specified recipient.  True otherwise
-	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast);
-	bool Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast);
+	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast);
+	bool Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast);
 
 	// Description:
 	// Gets a packet from the incoming packet queue. Use DeallocatePacket to deallocate the packet after you are done with it.
@@ -207,13 +210,13 @@
 	// bitStream: The bitstream to send
 	// priority: What priority level to send on.
 	// reliability: How reliability to send this data
-	// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+	// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 	// broadcast - Send this packet to everyone.
 	// playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 	// broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 	// shiftTimestamp: True to treat the first 4 bytes as a timestamp and make it system relative on arrival (Same as ID_TIMESTAMP for a packet enumeration type)
-	bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp);
-	bool RPC(char* uniqueID, BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp);
+	bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp);
+	bool RPC(char* uniqueID, RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp);
 
 	// --------------------------------------------------------------------------------------------
 	// Player Management Functions
@@ -224,7 +227,9 @@
 	// Parameters:
 	// target: Which connection to close
 	// sendDisconnectionNotification: True to send ID_DISCONNECTION_NOTIFICATION to the recipient.  False to close it silently.
-	void CloseConnection(PlayerID target, bool sendDisconnectionNotification);
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	void CloseConnection(PlayerID target, bool sendDisconnectionNotification, unsigned long blockDuration);
 
 	// Description:
 	// Given a playerID, returns an index from 0 to the maximum number of players allowed - 1.
@@ -297,9 +302,10 @@
 	// The sender and recipient must already be started via a successful call to Initialize
 	//
 	// Parameters:
-	// host: Either a dotted IP address or a domain name
+	// host: Either a dotted IP address or a domain name.  Can be 255.255.255.255 for LAN broadcast.
 	// remotePort: Which port to connect to on the remote machine.
-	void Ping(char* host, unsigned short remotePort);
+	// onlyReplyOnAcceptingConnections: Only request a reply if the remote system is accepting connections
+	void Ping(char* host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections);
 
 	// Description:
 	// Returns the average of all ping times read for a specified target
@@ -323,7 +329,7 @@
 	int GetLowestPing(PlayerID target) const;
 
 	// Description:
-	// Ping the remote systems every so often.  This is on by default
+	// Ping the remote systems every so often.  This is off by default
 	// This will work anytime
 	//
 	// Parameters:
@@ -383,7 +389,7 @@
 	//
 	// Returns:
 	// The data passed to SetRemoteStaticData stored as a bitstream
-	BitStream* GetRemoteStaticData(PlayerID playerId);
+	RakNet::BitStream * GetRemoteStaticData(PlayerID playerId);
 
 	// Description:
 	// All systems have a block of data associated with them, for user use.  This block of data can be used to easily
@@ -554,29 +560,25 @@
 	// Statistical Functions - Functions dealing with API performance
 	// --------------------------------------------------------------------------------------------
 
-	// Network statistics.
-	double GetPacketlossPercentile(void) const; // The average outgoing packetloss percentile
-	unsigned long GetTransmittedPacketCount(void) const; // How many packets were sent
-	unsigned long GetTransmittedFrameCount(void) const; // How many frames were sent	
-	unsigned long GetLostPacketCount(void) const; // How many packets were lost
-	unsigned long GetReceivedPacketCount(void) const; // How many packets were received
-	unsigned long GetBytesSent(void) const; // How many bytes have been sent.
-	unsigned long GetBytesReceived(void) const; // How many bytes have been received.
-	unsigned long GetUnacknowledgedSentPacketListSize(void) const; // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	unsigned long GetBytesSentPerSecond(void) const;  // How many bytes were sent in the last histogram block.
-	unsigned long GetBytesReceivedPerSecond(void) const; // How many bytes were received in the last histogram block.
-	unsigned long GetMaximumWindowSize(void) const; // Returns the size of the flow control window, in packets.  Smaller values correlate with higher throughput and less packetloss
-	unsigned long GetPacketOutputBufferSize(void) const; // Returns the number of waiting packets on the send queue
-	unsigned long GetConnectionTime(PlayerID playerId) const; // Returns the time elapsed since this player connected
+	// Description:
+	// Returns a structure containing a large set of network statistics for the specified system
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Parameters
+	// playerId: Which connected system to get statistics for
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	RakNetStatisticsStruct * const GetStatistics(PlayerID playerId);
 
 protected:
 
 #ifdef _WIN32
-	friend unsigned __stdcall RecvFromNetworkLoop(LPVOID arguments);
+//	friend unsigned __stdcall RecvFromNetworkLoop(LPVOID arguments);
 	friend void __stdcall ProcessNetworkPacket(unsigned long binaryAddress, unsigned short port, char *data, int length, RakPeer *rakPeer);
 	friend unsigned __stdcall UpdateNetworkLoop(LPVOID arguments);
 #else
-	friend void*  RecvFromNetworkLoop( void*  arguments );
+//	friend void*  RecvFromNetworkLoop( void*  arguments );
 	friend void ProcessNetworkPacket(unsigned long binaryAddress, unsigned short port, char *data, int length, RakPeer *rakPeer);
 	friend void*  UpdateNetworkLoop( void*  arguments );
 #endif
@@ -596,7 +598,7 @@
 		int pingAndClockDifferentialWriteIndex; // The index we are writing into the pingAndClockDifferential circular buffer
 		int lowestPing;
 		unsigned long nextPingTime; // When to next ping this player
-		BitStream staticData;
+		RakNet::BitStream staticData;
 		unsigned long connectionTime;
 	};
 
@@ -634,11 +636,12 @@
 	bool SetupIOCompletionPortSocket(int index);
 	#endif
 
-	bool endThreads, isMainLoopThreadActive, isRecvfromThreadActive; // Tracks thread states
+	bool endThreads, isMainLoopThreadActive;
+	// bool isRecvfromThreadActive; // Tracks thread states
 	bool occasionalPing; // Do we occasionally ping the other systems?
 	unsigned short maximumNumberOfPeers,maximumIncomingConnections;
 	// localStaticData necessary because we may not have a RemoteSystemStruct representing ourselves in the list
-	BitStream incomingPasswordBitStream, outgoingPasswordBitStream, localStaticData;
+	RakNet::BitStream incomingPasswordBitStream, outgoingPasswordBitStream, localStaticData;
 	PlayerID myPlayerId;
 
 	// This is an array of pointers to RemoteSystemStruct
@@ -654,17 +657,20 @@
 		incomingPasswordBitStream_Mutex,
 		outgoingPasswordBitStream_Mutex,
 		remoteSystemList_Mutex, // This mutex is a writer lock for reserving player IDs only
+//		updateCycleIsRunning_Mutex,
 		NUMBER_OF_RAKPEER_MUTEXES
 	};
 	SimpleMutex rakPeerMutexes[NUMBER_OF_RAKPEER_MUTEXES];
 
+	// RunUpdateCycle is not thread safe but we don't need to mutex calls.  Just skip calls if it is running already
+	bool updateCycleIsRunning;
 
 	// The list of people we have tried to connect to recently
 	BasicDataStructures::Queue<RequestedConnectionStruct*> requestedConnectionsList;
 
 	// Data that both the client and the server needs
 	unsigned long bytesSentPerSecond, bytesReceivedPerSecond;
-	bool isSocketLayerBlocking;
+//	bool isSocketLayerBlocking;
 	//bool continualPing,isRecvfromThreadActive,isMainLoopThreadActive, endThreads, isSocketLayerBlocking;
 	unsigned long validationInteger;
 #ifdef _WIN32
@@ -694,25 +700,37 @@
 	// Compression stuff
 	unsigned long frequencyTable[256];
 	HuffmanEncodingTree *inputTree, *outputTree;
-	unsigned long rawBytesSent, rawBytesRecieved, compressedBytesSent, compressedBytesRecieved;
-	//void DecompressInput(BitStream *bitStream);
-	//void UpdateOutgoingFrequencyTable(BitStream* bitStream);
+	unsigned long rawBytesSent, rawBytesReceived, compressedBytesSent, compressedBytesReceived;
+	//void DecompressInput(RakNet::BitStream *bitStream);
+	//void UpdateOutgoingFrequencyTable(RakNet::BitStream * bitStream);
 	void GenerateSYNCookieRandomNumber(void);
 	void SecuredConnectionResponse(PlayerID playerId);
-	void SecuredConnectionConfirmation(PlayerID playerId, char* data, int length);
+	void SecuredConnectionConfirmation(PlayerID playerId, char* data);
+	bool RunUpdateCycle(void);
+	//void RunMutexedUpdateCycle(void);
 
 	BasicDataStructures::AVLBalancedBinarySearchTree<RPCNode> rpcTree;
 	int MTUSize;
 	bool trackFrequencyTable;
-	int threadPriority;
+	int threadSleepTimer;
 
 	SOCKET connectionSocket;
 
-	mpuint d,e,n;
-	unsigned short securedConnectionByteSize;
-	bool keysLocallyGenerated;
+	// Histogram statistics
+	//unsigned long nextReadBytesTime;
+	//int lastSentBytes,lastReceivedBytes;
+
+	// Encryption and security
+	big::RSACrypt<RSA_BIT_SIZE> rsacrypt;
+	big::u32 publicKeyE;
+	RSA_BIT_SIZE publicKeyN;
+	bool keysLocallyGenerated, usingSecurity;
 	unsigned long randomNumberExpirationTime;
 	unsigned char newRandomNumber[20], oldRandomNumber[20];
+
+	// How long it has been since things were updated by a call to receive
+	// Update thread uses this to determine how long to sleep for
+	unsigned long lastUserUpdateCycle;
 };
 
 #endif

Modified: branches/multiplayer-branch/source/libraries/raknet/RakPeerInterface.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/RakPeerInterface.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/RakPeerInterface.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -10,9 +10,10 @@
 #ifndef __RAK_PEER_INTERFACE_H
 #define __RAK_PEER_INTERFACE_H
 
-class BitStream;
 #include "PacketPriority.h"
 #include "NetworkTypes.h"
+#include "BitStream.h"
+#include "RakNetStatistics.h"
 
 class RakPeerInterface
 {
@@ -36,11 +37,11 @@
 	// - A pure client would set this to 1.  A pure server would set it to the number of allowed clients.
 	// - A hybrid would set it to the sum of both types of connections
 	// localPort: The port to listen for connections on.
-	// _threadPriority: 0 for regular priority (0-8 players), 1 for high priority (High performance applications), and 2 for ultra-high priority (MMO server)
+	// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	//
 	// Returns:
 	// False on failure (can't create socket or thread), true on success.
-	virtual bool Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadPriority)=0;
+	virtual bool Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadSleepTimer)=0;
 
 	// Description:
 	// Must be called while offline
@@ -52,15 +53,13 @@
 	// If you accept connections, you must call this or else secure connections will not be enabled
 	// for incoming connections.
 	// If you are connecting to another system, you can call this with values for the
-	// (e and n) public keys before connecting to prevent MitM
+	// (e and p,q) public keys before connecting to prevent MitM
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.
-	// RSAd - A pointer to the private key of length numberOfBytes.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
-	virtual void InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn)=0;
+	// RSAe, RSAn - Public keys generated from the RSACrypt class.  See the Encryption sample
+	// RSAp, RSAq - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+	// If the private keys are 0, then a new key will be generated when this function is called
+	virtual void InitializeSecurity(char *RSAe, char *RSAn, char *RSAp, char *RSAq)=0;
 
 	// Description
 	// Must be called while offline
@@ -92,13 +91,13 @@
 
 	// Description:
 	// Returns the password set by SetIncomingPassword in a BitStream
-	BitStream *GetIncomingPassword(void);
+	RakNet::BitStream *GetIncomingPassword(void);
 
 	// Description:
 	// Call this to connect to the specified host (ip or domain name) and server port.
 	// Calling Connect and not calling SetMaximumIncomingConnections acts as a dedicated client.  Calling both acts as a true peer.
 	// This is a non-blocking connection.  You know the connection is successful when IsConnected() returns true
-	// or receive gets a packet with the type identifier ID_ENUMERATION_REPLY.  If the connection is not
+	// or receive gets a packet with the type identifier ID_CONNECTION_ACCEPTED.  If the connection is not
 	// successful, such as rejected connection or no response then neither of these things will happen.
 	// Requires that you first call Initialize
 	//
@@ -114,7 +113,11 @@
 
 	// Description:
 	// Stops the network threads and close all connections.  Multiple calls are ok.
-	virtual void Disconnect(void)=0;
+	//
+	// Parameters:
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	virtual void Disconnect(unsigned long blockDuration)=0;
 
 	// Description:
 	// Returns true if the network threads are running
@@ -138,14 +141,14 @@
 	// bitStream: The bitstream to send
 	// priority: What priority level to send on.
 	// reliability: How reliability to send this data
-	// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+	// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 	// - Packets are only ordered relative to other packets on the same stream
 	// playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 	// broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 	// Returns:
 	// False if we are not connected to the specified recipient.  True otherwise
-	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)=0;
-	virtual bool Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)=0;
+	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)=0;
+	virtual bool Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)=0;
 
 	// Description:
 	// Gets a packet from the incoming packet queue. Use DeallocatePacket to deallocate the packet after you are done with it.
@@ -200,13 +203,13 @@
 	// bitStream: The bitstream to send
 	// priority: What priority level to send on.
 	// reliability: How reliability to send this data
-	// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+	// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 	// broadcast - Send this packet to everyone.
 	// playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 	// broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 	// shiftTimestamp: True to treat the first 4 bytes as a timestamp and make it system relative on arrival (Same as ID_TIMESTAMP for a packet enumeration type)
-	virtual bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
-	virtual bool RPC(char* uniqueID, BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
 
 	// --------------------------------------------------------------------------------------------
 	// Player Management Functions
@@ -217,7 +220,9 @@
 	// Parameters:
 	// target: Which connection to close
 	// sendDisconnectionNotification: True to send ID_DISCONNECTION_NOTIFICATION to the recipient.  False to close it silently.
-	virtual void CloseConnection(PlayerID target, bool sendDisconnectionNotification)=0;
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	virtual void CloseConnection(PlayerID target, bool sendDisconnectionNotification, unsigned long blockDuration)=0;
 
 	// Description:
 	// Given a playerID, returns an index from 0 to the maximum number of players allowed - 1.
@@ -290,9 +295,10 @@
 	// The sender and recipient must already be started via a successful call to Initialize
 	//
 	// Parameters:
-	// host: Either a dotted IP address or a domain name
+	// host: Either a dotted IP address or a domain name.  Can be 255.255.255.255 for LAN broadcast.
 	// remotePort: Which port to connect to on the remote machine.
-	virtual void Ping(char* host, unsigned short remotePort)=0;
+	// onlyReplyOnAcceptingConnections: Only request a reply if the remote system is accepting connections
+	virtual void Ping(char* host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections)=0;
 
 	// Description:
 	// Returns the average of all ping times read for a specified target
@@ -316,7 +322,7 @@
 	virtual int GetLowestPing(PlayerID target) const=0;
 
 	// Description:
-	// Ping the remote systems every so often.  This is on by default
+	// Ping the remote systems every so often.  This is off by default
 	// This will work anytime
 	//
 	// Parameters:
@@ -375,7 +381,7 @@
 	//
 	// Returns:
 	// The data passed to SetRemoteStaticData stored as a bitstream
-	virtual BitStream* GetRemoteStaticData(PlayerID playerId)=0;
+	virtual RakNet::BitStream * GetRemoteStaticData(PlayerID playerId)=0;
 
 	// Description:
 	// All systems have a block of data associated with them, for user use.  This block of data can be used to easily
@@ -547,20 +553,16 @@
 	// Statistical Functions - Functions dealing with API performance
 	// --------------------------------------------------------------------------------------------
 
-	// Network statistics.
-	virtual double GetPacketlossPercentile(void) const=0; // The average outgoing packetloss percentile
-	virtual unsigned long GetTransmittedPacketCount(void) const=0; // How many packets were sent
-	virtual unsigned long GetTransmittedFrameCount(void) const=0; // How many frames were sent	
-	virtual unsigned long GetLostPacketCount(void) const=0; // How many packets were lost
-	virtual unsigned long GetReceivedPacketCount(void) const=0; // How many packets were received
-	virtual unsigned long GetBytesSent(void) const=0; // How many bytes have been sent.
-	virtual unsigned long GetBytesReceived(void) const=0; // How many bytes have been received.
-	virtual unsigned long GetUnacknowledgedSentPacketListSize(void) const=0; // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	virtual unsigned long GetBytesSentPerSecond(void) const=0;  // How many bytes were sent in the last histogram block.
-	virtual unsigned long GetBytesReceivedPerSecond(void) const=0; // How many bytes were received in the last histogram block.
-	virtual unsigned long GetMaximumWindowSize(void) const=0; // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	virtual unsigned long GetPacketOutputBufferSize(void) const=0; // Returns the number of waiting packets on the send queue
-	virtual unsigned long GetConnectionTime(PlayerID playerId) const=0; // Returns the time elapsed since this player connected
+	// Description:
+	// Returns a structure containing a large set of network statistics for the specified system
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Parameters
+	// playerId: Which connected system to get statistics for
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	virtual RakNetStatisticsStruct * const GetStatistics(PlayerID playerId)=0;
 };
 
 #endif

Modified: branches/multiplayer-branch/source/libraries/raknet/RakServer.cpp
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/RakServer.cpp	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/RakServer.cpp	2004-10-08 21:41:59 UTC (rev 76)
@@ -28,9 +28,9 @@
 {
 }
 
-void RakServer::InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn)
+void RakServer::InitializeSecurity(char *RSAp, char *RSAq)
 {
-	RakPeer::InitializeSecurity(numberOfBytes, RSAd, RSAe, RSAn);
+	RakPeer::InitializeSecurity(0,0, RSAp, RSAq);
 }
 
 void RakServer::DisableSecurity(void)
@@ -38,19 +38,17 @@
 	RakPeer::DisableSecurity();
 }
 
-bool RakServer::Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, bool highPriorityThreads, unsigned short port)
+bool RakServer::Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, int threadSleepTimer, unsigned short port)
 {
 	bool init;
 
-	if (highPriorityThreads)
-		init=RakPeer::Initialize(AllowedPlayers, port,1);
-	else
-		init=RakPeer::Initialize(AllowedPlayers, port,0);
+	RakPeer::Disconnect(30L);
 
+	init=RakPeer::Initialize(AllowedPlayers, port,threadSleepTimer);
 	RakPeer::SetMaximumIncomingConnections(AllowedPlayers);
 
 	// Random number seed
-	long time = getTime();
+	long time = RakNetGetTime();
 	seedMT(time);
 	seed=randomMT();
 	if (seed % 2 == 0) // Even
@@ -64,8 +62,15 @@
 
 void RakServer::SetPassword(char *_password)
 {
-	_password[19]=0; // Limit the password length
-	RakPeer::SetIncomingPassword(_password, (int)strlen(_password)+1);
+	if (_password)
+	{
+		_password[19]=0; // Limit the password length
+		RakPeer::SetIncomingPassword(_password, (int)strlen(_password)+1);
+	}
+	else
+	{
+		RakPeer::SetIncomingPassword(0, 0);
+	}
 }
 
 bool RakServer::HasPassword(void)
@@ -73,19 +78,19 @@
 	return GetIncomingPassword()->GetNumberOfBytesUsed() > 0;
 }
 
-void RakServer::Disconnect(void)
+void RakServer::Disconnect(unsigned long blockDuration)
 {
-	RakPeer::Disconnect();
+	RakPeer::Disconnect(blockDuration);
 }
 
-bool RakServer::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)
+bool RakServer::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)
 {
-	return RakPeer::Send(data, length, priority, reliability, orderingStream, playerId, broadcast);
+	return RakPeer::Send(data, length, priority, reliability, orderingChannel, playerId, broadcast);
 }
 
-bool RakServer::Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)
+bool RakServer::Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)
 {
-	return RakPeer::Send(bitStream, priority, reliability, orderingStream, playerId, broadcast);
+	return RakPeer::Send(bitStream, priority, reliability, orderingChannel, playerId, broadcast);
 }
 
 Packet* RakServer::Receive(void)
@@ -95,7 +100,7 @@
 	// This is just a regular time based update.  Nowhere else good to put it
 	if (RakPeer::IsActive() && occasionalPing)
 	{
-		unsigned long time = getTime();
+		unsigned long time = RakNetGetTime();
 		if (time > broadcastPingsTime || (packet && packet->data[0]==ID_RECEIVED_STATIC_DATA))
 		{
 			if (time > broadcastPingsTime)
@@ -103,7 +108,7 @@
 
 			unsigned i, count;
 			RemoteSystemStruct *remoteSystem;
-			BitStream bitStream((sizeof(PlayerID) + sizeof(short)) * 32 + sizeof(unsigned char));
+			RakNet::BitStream bitStream((sizeof(PlayerID) + sizeof(short)) * 32 + sizeof(unsigned char));
 			unsigned char typeId=ID_BROADCAST_PINGS;
 			bitStream.Write(typeId);
 			for (i=0, count=0; count < 32 && i < maximumNumberOfPeers; i++)
@@ -121,9 +126,9 @@
 			if (count>0) // If we wrote anything
 			{
 				if (packet && packet->data[0]==ID_NEW_INCOMING_CONNECTION) // If this was a new connection
-					Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, packet->playerId, false); // Send to the new connection
+					Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, packet->playerId, false); // Send to the new connection
 				else
-					Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true); // Send to everyone
+					Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true); // Send to everyone
 			}
 		}
 	}
@@ -131,7 +136,7 @@
 	// This is just a regular time based update.  Nowhere else good to put it
 	if (RakPeer::IsActive() && synchronizedRandomInteger)
 	{
-		unsigned long time = getTime();
+		unsigned long time = RakNetGetTime();
 		if (time > nextSeedUpdate || (packet && packet->data[0]==ID_NEW_INCOMING_CONNECTION))
 		{
 			if (time > nextSeedUpdate)
@@ -144,39 +149,39 @@
 
 			SetRandomNumberSeedStruct s;
 			s.ts=ID_TIMESTAMP;
-			s.timeStamp=getTime();
+			s.timeStamp=RakNetGetTime();
 			s.typeId=ID_SET_RANDOM_NUMBER_SEED;
 			s.seed=seed;
 			s.nextSeed=nextSeed;
 
 			if (packet && packet->data[0]==ID_NEW_INCOMING_CONNECTION)
-				Send((char*)&s, sizeof(SetRandomNumberSeedStruct),  HIGH_PRIORITY, RELIABLE, 0, packet->playerId, false);
+				Send((char*)&s, sizeof(SetRandomNumberSeedStruct),  SYSTEM_PRIORITY, RELIABLE, 0, packet->playerId, false);
 			else
-				Send((char*)&s, sizeof(SetRandomNumberSeedStruct),  HIGH_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true);
+				Send((char*)&s, sizeof(SetRandomNumberSeedStruct),  SYSTEM_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true);
 		}
 	}
 
 	if (packet)
-	{
+	{			
 		// Intercept specific client / server feature packets.  This will do an extra send and still pass on the data to the user
-		if (packet->data[0]==ID_RECEIVED_STATIC_DATA)
+		if (packet->data[0]==ID_REMOTE_STATIC_DATA)
 		{
 			if (relayStaticClientData)
 			{
 				// Relay static data to the other systems but the sender
-				BitStream bitStream(packet->length + sizeof(PlayerID));
-				unsigned char typeId=ID_RECEIVED_RELAYED_STATIC_DATA;
+				RakNet::BitStream bitStream(packet->length + sizeof(PlayerID));
+				unsigned char typeId=ID_REMOTE_STATIC_DATA;
 				bitStream.Write(typeId);
 				bitStream.Write(packet->playerId.binaryAddress);
 				bitStream.Write(packet->playerId.port);
-				bitStream.Write(packet->data+sizeof(unsigned char), packet->length-sizeof(unsigned char));
-				Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true);
+				bitStream.Write((char*)packet->data+sizeof(unsigned char), packet->length-sizeof(unsigned char));
+				Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true);
 			}			
 		}
 		else if (packet->data[0]==ID_DISCONNECTION_NOTIFICATION || packet->data[0]==ID_CONNECTION_LOST || packet->data[0]==ID_NEW_INCOMING_CONNECTION)
 		{
 			// Relay the disconnection
-			BitStream bitStream(packet->length + sizeof(PlayerID));
+			RakNet::BitStream bitStream(packet->length + sizeof(PlayerID));
 			unsigned char typeId;
 			if (packet->data[0]==ID_DISCONNECTION_NOTIFICATION)
 				typeId=ID_REMOTE_DISCONNECTION_NOTIFICATION;
@@ -187,7 +192,8 @@
 			bitStream.Write(typeId);
 			bitStream.Write(packet->playerId.binaryAddress);
 			bitStream.Write(packet->playerId.port);
-			Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, packet->playerId, true);
+			bitStream.Write((unsigned short&)packet->playerIndex);
+			Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, packet->playerId, true);
 
 			if (packet->data[0]==ID_NEW_INCOMING_CONNECTION)
 			{
@@ -201,19 +207,20 @@
 						bitStream.Write(typeId);
 						bitStream.Write(remoteSystemList[i].playerId.binaryAddress);
 						bitStream.Write(remoteSystemList[i].playerId.port);
+						bitStream.Write((unsigned short)i);
 						// One send to tell them of the connection
-						Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, packet->playerId, false);
+						Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, packet->playerId, false);
 
 						if (relayStaticClientData)
 						{
 							bitStream.Reset();
-							typeId=ID_RECEIVED_RELAYED_STATIC_DATA;
+							typeId=ID_REMOTE_STATIC_DATA;
 							bitStream.Write(typeId);
 							bitStream.Write(remoteSystemList[i].playerId.binaryAddress);
 							bitStream.Write(remoteSystemList[i].playerId.port);
 							bitStream.Write((char*)remoteSystemList[i].staticData.GetData(), remoteSystemList[i].staticData.GetNumberOfBytesUsed());
 							// Another send to tell them of the static data
-							Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, packet->playerId, false);
+							Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, packet->playerId, false);
 						}
 					}
 				}
@@ -226,7 +233,7 @@
 
 void RakServer::Kick(PlayerID playerId)
 {
-	RakPeer::CloseConnection(playerId, true);
+	RakPeer::CloseConnection(playerId, true, 0L);
 }
 
 void RakServer::DeallocatePacket(Packet *packet)
@@ -346,14 +353,14 @@
 	RakPeer::UnregisterAsRemoteProcedureCall(uniqueID);
 }
 
-bool RakServer::RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)
+bool RakServer::RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)
 {
-		return RakPeer::RPC(uniqueID, data, bitLength, priority, reliability, orderingStream, playerId, broadcast, shiftTimestamp);
+		return RakPeer::RPC(uniqueID, data, bitLength, priority, reliability, orderingChannel, playerId, broadcast, shiftTimestamp);
 }
 
-bool RakServer::RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)
+bool RakServer::RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)
 {
-	return RakPeer::RPC(uniqueID, parameters, priority, reliability, orderingStream, playerId, broadcast, shiftTimestamp);
+	return RakPeer::RPC(uniqueID, parameters, priority, reliability, orderingChannel, playerId, broadcast, shiftTimestamp);
 }
 
 /*
@@ -382,7 +389,7 @@
 	return RakPeer::GetDecompressionRatio();
 }
 
-BitStream* RakServer::GetStaticServerData(void)
+RakNet::BitStream * RakServer::GetStaticServerData(void)
 {
 	return RakPeer::GetRemoteStaticData(myPlayerId);
 }
@@ -402,7 +409,7 @@
 	RakPeer::SendStaticData(playerId);
 }
 
-BitStream* RakServer::GetStaticClientData(PlayerID playerId)
+RakNet::BitStream * RakServer::GetStaticClientData(PlayerID playerId)
 {
 	return RakPeer::GetRemoteStaticData(playerId);
 }
@@ -420,13 +427,13 @@
 		return; // No such playerChangedId
 
     // Relay static data to the other systems but the sender
-	BitStream bitStream(remoteSystem->staticData.GetNumberOfBytesUsed() + sizeof(PlayerID) + sizeof(unsigned char));
-	unsigned char typeId=ID_RECEIVED_RELAYED_STATIC_DATA;
+	RakNet::BitStream bitStream(remoteSystem->staticData.GetNumberOfBytesUsed() + sizeof(PlayerID) + sizeof(unsigned char));
+	unsigned char typeId=ID_REMOTE_STATIC_DATA;
 	bitStream.Write(typeId);
 	bitStream.Write(playerChangedId.binaryAddress);
 	bitStream.Write(playerChangedId.port);
 	bitStream.Write((char*)remoteSystem->staticData.GetData(), remoteSystem->staticData.GetNumberOfBytesUsed());
-	Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, playerToSendToId, true);
+	Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, playerToSendToId, true);
 }
 
 unsigned int RakServer::GetNumberOfAddresses(void)
@@ -488,69 +495,7 @@
 {
 	return RakPeer::GetMTUSize();
 }
-
-double RakServer::GetPacketlossPercentile(void)
+RakNetStatisticsStruct * const RakServer::GetStatistics(PlayerID playerId)
 {
-	return RakPeer::GetPacketlossPercentile();
+	return RakPeer::GetStatistics(playerId);
 }
-	
-unsigned long RakServer::GetTransmittedPacketCount(void)
-{
-	return RakPeer::GetTransmittedPacketCount();
-}
-
-unsigned long RakServer::GetTransmittedFrameCount(void)
-{
-	return RakPeer::GetTransmittedFrameCount();
-}
-
-unsigned long RakServer::GetLostPacketCount(void)
-{
-	return RakPeer::GetLostPacketCount();
-}
-
-unsigned long RakServer::GetReceivedPacketCount(void)
-{
-	return RakPeer::GetReceivedPacketCount();
-}
-
-unsigned long RakServer::GetBytesSent(void)
-{
-	return RakPeer::GetBytesSent();
-}
-
-unsigned long RakServer::GetBytesReceived(void)
-{
-	return RakPeer::GetBytesReceived();
-}
-
-unsigned long RakServer::GetUnacknowledgedSentPacketListSize(void)
-{
-	return RakPeer::GetUnacknowledgedSentPacketListSize();
-}
-
-unsigned long RakServer::GetBytesSentPerSecond(void) const
-{
-	return RakPeer::GetBytesSentPerSecond();
-}
-
-unsigned long RakServer::GetBytesReceivedPerSecond(void) const
-{
-	return RakPeer::GetBytesReceivedPerSecond();
-}
-
-unsigned long RakServer::GetMaximumWindowSize(void)
-{
-	return RakPeer::GetMaximumWindowSize();
-}
-
-unsigned long RakServer::GetPacketOutputBufferSize(void)
-{
-	return RakPeer::GetPacketOutputBufferSize();
-}
-
-unsigned long RakServer::GetConnectionTime(PlayerID playerId)
-{
-	return RakPeer::GetConnectionTime(playerId);
-}
-

Modified: branches/multiplayer-branch/source/libraries/raknet/RakServer.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/RakServer.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/RakServer.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -25,12 +25,11 @@
 	// Call this to initiate the server with the number of players you want to be allowed connected at once
 	// Current maximum number of allowed players is 65535
 	// connectionValidationInteger is for legacy purposes and is unused
-	// Set highPriorityThreads to true for a real-time responsive server.  Set it to false
-	// for games where high pings don't matter, or if the network engine slows down the game too much
+	// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	// Port is the port you want the server to read and write on
 	// Make sure this port is open for UDP
 	// Returns true on successful initiation, false otherwise
-	bool Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, bool highPriorityThreads, unsigned short port);
+	bool Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, int threadSleepTimer, unsigned short port);
 
 	// Description:
 	// Must be called while offline
@@ -43,12 +42,9 @@
 	// for incoming connections.
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAd - A pointer to the private key of length numberOfBytes.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
-	void InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn);
+	// RSAp, RSAq - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+	// If the private keys are 0, then a new key will be generated when this function is called
+	void InitializeSecurity(char *RSAp, char *RSAq);
 
 	// Description
 	// Must be called while offline
@@ -67,24 +63,28 @@
 	// since the server is stopped packet reliability is not enforced so the Kick network message may not actually
 	// arrive.  Those players will disconnect due to timeout. If you want to end the server more gracefully, you
 	// can manually Kick each player first. Does nothing if the server is not running to begin with
-	void Disconnect(void);
+	//
+	// Parameters:
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notifications probably won't arrive
+	void Disconnect(unsigned long blockDuration);
 
 	// This function only works while the server is active (Use the Start function).  Returns false on failure, true on success
 	// Send the data stream of length length to whichever playerId you specify.  Specify UNASSIGNED_PLAYER_ID for all players connected
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY, RELIABLE, 0 for ordering stream
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY, RELIABLE, 0 for ordering channel
 	// Set broadcast to true to broadcast to all connected clients EXCEPT the one specified in the playerId field.
 	// To broadcast to everyone specify UNASSIGNED_PLAYER_ID for the playerId field.
-	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast);
+	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast);
 
 	// This function only works while the server is active (Use the Start function).  Returns false on failure, true on success
 	// Send the bitstream to whichever playerId you specify.
 	// You can set the first byte to a packet identifier, however you will need to have TYPE_CHECKING undefined or the internal type checking
 	// will add extra data and make this not work.  If you want TYPE_CHECKING on, you will need to use BitStream::WriteBits to avoid the type checking.
 	// This interface will probably change to fix this in future versions.
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
 	// Set broadcast to true to broadcast to all connected clients EXCEPT the one specified in the playerId field.
 	// To broadcast to everyone specify UNASSIGNED_PLAYER_ID for the playerId field.
-	bool Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast);
+	bool Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast);
 
 	// Call this to get a packet from the incoming packet queue.  Use DeallocatePacket to deallocate the packet after you are done with it.
 	// Check the Packet struct at the top of CoreNetworkStructures.h for the format of the struct
@@ -222,8 +222,8 @@
 	// If you want that function to return data you should call RPC from that system in the same way
 	// Returns true on a successful packet send (this does not indicate the recipient performed the call), false on failure
 	// The uniqueID must be composed of a string with only characters from a-z and is not case sensitive
-	bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp);
-	bool RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp);
+	bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp);
+	bool RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp);
 
 	// Handles an RPC packet.  If you get a packet with the ID ID_RPC you should pass it to this function
 	// This is already done in Multiplayer.cpp, so if you use the Multiplayer class it is handled for you.
@@ -260,7 +260,7 @@
 	// The data is entered as an array and stored and returned as a BitStream.
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
-	BitStream* GetStaticServerData(void);
+	RakNet::BitStream * GetStaticServerData(void);
 	void SetStaticServerData(char *data, const long length);
 
 	// This sets to true or false whether we want to support relaying of static client data to other connected clients.
@@ -286,12 +286,12 @@
 	// The data is entered as an array and stored and returned as a BitStream.  
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...->GetStaticServerData(...);
+	// RakNet::BitStream *copy = ...->GetStaticServerData(...);
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
 	// Note that the client may change at any time the
 	// data contents and/or its length!
-	BitStream* GetStaticClientData(PlayerID playerId);
+	RakNet::BitStream * GetStaticClientData(PlayerID playerId);
 	void SetStaticClientData(PlayerID playerId, char *data, const long length);
 
 	// This function is used to update the information on connected clients when the server effects a change
@@ -382,20 +382,16 @@
 	// Returns the current MTU size
 	int GetMTUSize(void) const;
 
-	// Network statistics.
-	double GetPacketlossPercentile(void); // The average outgoing packetloss percentile among all connected clients
-	unsigned long GetTransmittedPacketCount(void); // How many packets were sent among all connected clients
-	unsigned long GetTransmittedFrameCount(void); // How many frames were sent	
-	unsigned long GetLostPacketCount(void); // How many packets were lost among all connected clients
-	unsigned long GetReceivedPacketCount(void); // How many packets were received among all connected clients
-	unsigned long GetBytesSent(void); // How many bytes have been sent among all connected clients.
-	unsigned long GetBytesReceived(void); // How many bytes have been received among all connected clients.
-	unsigned long GetUnacknowledgedSentPacketListSize(void); // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	unsigned long GetBytesSentPerSecond(void) const;  // How many bytes were sent in the last histogram block.
-	unsigned long GetBytesReceivedPerSecond(void) const; // How many bytes were received in the last histogram block.
-	unsigned long GetMaximumWindowSize(void); // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	unsigned long GetPacketOutputBufferSize(void); // Returns the number of waiting packets on the send queue
-	unsigned long GetConnectionTime(PlayerID playerId); // Returns when this client connected or 0 if not connected
+	// Description:
+	// Returns a structure containing a large set of network statistics for the specified system
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Parameters
+	// playerId: Which connected system to get statistics for
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	RakNetStatisticsStruct * const GetStatistics(PlayerID playerId);
 
 	private:
 

Modified: branches/multiplayer-branch/source/libraries/raknet/RakServerInterface.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/RakServerInterface.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/RakServerInterface.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -13,7 +13,8 @@
 #include "NetworkTypes.h"
 #include "PacketPriority.h"
 #include "RakPeerInterface.h"
-class BitStream;
+#include "BitStream.h"
+#include "RakNetStatistics.h"
 
 class RakServerInterface
 {
@@ -24,12 +25,11 @@
 	// Call this to initiate the server with the number of players you want to be allowed connected at once
 	// Current maximum number of allowed players is 65535
 	// connectionValidationInteger is for legacy purposes and is unused
-	// Set highPriorityThreads to true for a real-time responsive server.  Set it to false
-	// for games where high pings don't matter, or if the network engine slows down the game too much
+	// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	// Port is the port you want the server to read and write on
 	// Make sure this port is open for UDP
 	// Returns true on successful initiation, false otherwise
-	virtual bool Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, bool highPriorityThreads, unsigned short port)=0;
+	virtual bool Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, int threadSleepTimer, unsigned short port)=0;
 
 	// Description:
 	// Must be called while offline
@@ -42,12 +42,9 @@
 	// for incoming connections.
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAd - A pointer to the private key of length numberOfBytes.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
-	virtual void InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn)=0;
+	// RSAp, RSAq - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+	// If the private keys are 0, then a new key will be generated when this function is called
+	virtual void InitializeSecurity(char *RSAp, char *RSAq)=0;
 
 	// Description
 	// Must be called while offline
@@ -66,24 +63,28 @@
 	// since the server is stopped packet reliability is not enforced so the Kick network message may not actually
 	// arrive.  Those players will disconnect due to timeout. If you want to end the server more gracefully, you
 	// can manually Kick each player first. Does nothing if the server is not running to begin with
-	virtual void Disconnect(void)=0;
+	//
+	// Parameters:
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notifications probably won't arrive
+	virtual void Disconnect(unsigned long blockDuration)=0;
 
 	// This function only works while the server is active (Use the Start function).  Returns false on failure, true on success
 	// Send the data stream of length length to whichever playerId you specify.  Specify UNASSIGNED_PLAYER_ID for all players connected
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY, RELIABLE, 0 for ordering stream
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY, RELIABLE, 0 for ordering channel
 	// Set broadcast to true to broadcast to all connected clients EXCEPT the one specified in the playerId field.
 	// To broadcast to everyone specify UNASSIGNED_PLAYER_ID for the playerId field.
-	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)=0;
+	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)=0;
 
 	// This function only works while the server is active (Use the Start function).  Returns false on failure, true on success
 	// Send the bitstream to whichever playerId you specify.
 	// You can set the first byte to a packet identifier, however you will need to have TYPE_CHECKING undefined or the internal type checking
 	// will add extra data and make this not work.  If you want TYPE_CHECKING on, you will need to use BitStream::WriteBits to avoid the type checking.
 	// This interface will probably change to fix this in future versions.
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
 	// Set broadcast to true to broadcast to all connected clients EXCEPT the one specified in the playerId field.
 	// To broadcast to everyone specify UNASSIGNED_PLAYER_ID for the playerId field.
-	virtual bool Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)=0;
+	virtual bool Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)=0;
 
 	// Call this to get a packet from the incoming packet queue.  Use DeallocatePacket to deallocate the packet after you are done with it.
 	// Check the Packet struct at the top of CoreNetworkStructures.h for the format of the struct
@@ -221,8 +222,8 @@
 	// If you want that function to return data you should call RPC from that system in the same way
 	// Returns true on a successful packet send (this does not indicate the recipient performed the call), false on failure
 	// The uniqueID must be composed of a string with only characters from a-z and is not case sensitive
-	virtual bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
-	virtual bool RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
 
 	// OBSOLETE - DONE AUTOMATICALLY
 	// Handles an RPC packet.  If you get a packet with the ID ID_RPC you should pass it to this function
@@ -260,7 +261,7 @@
 	// The data is entered as an array and stored and returned as a BitStream.
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
-	virtual BitStream* GetStaticServerData(void)=0;
+	virtual RakNet::BitStream * GetStaticServerData(void)=0;
 	virtual void SetStaticServerData(char *data, const long length)=0;
 
 	// This sets to true or false whether we want to support relaying of static client data to other connected clients.
@@ -286,12 +287,12 @@
 	// The data is entered as an array and stored and returned as a BitStream.  
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...->GetStaticServerData(...)=0;
+	// RakNet::BitStream *copy = ...->GetStaticServerData(...)=0;
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
 	// Note that the client may change at any time the
 	// data contents and/or its length!
-	virtual BitStream* GetStaticClientData(PlayerID playerId)=0;
+	virtual RakNet::BitStream * GetStaticClientData(PlayerID playerId)=0;
 	virtual void SetStaticClientData(PlayerID playerId, char *data, const long length)=0;
 
 	// This function is used to update the information on connected clients when the server effects a change
@@ -382,20 +383,16 @@
 	// Returns the current MTU size
 	virtual int GetMTUSize(void) const=0;
 
-	// Network statistics.
-	virtual double GetPacketlossPercentile(void)=0; // The average outgoing packetloss percentile among all connected clients
-	virtual unsigned long GetTransmittedPacketCount(void)=0; // How many packets were sent among all connected clients
-	virtual unsigned long GetTransmittedFrameCount(void)=0; // How many frames were sent	
-	virtual unsigned long GetLostPacketCount(void)=0; // How many packets were lost among all connected clients
-	virtual unsigned long GetReceivedPacketCount(void)=0; // How many packets were received among all connected clients
-	virtual unsigned long GetBytesSent(void)=0; // How many bytes have been sent among all connected clients.
-	virtual unsigned long GetBytesReceived(void)=0; // How many bytes have been received among all connected clients.
-	virtual unsigned long GetUnacknowledgedSentPacketListSize(void)=0; // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	virtual unsigned long GetBytesSentPerSecond(void) const=0;  // How many bytes were sent in the last histogram block.
-	virtual unsigned long GetBytesReceivedPerSecond(void) const=0; // How many bytes were received in the last histogram block.
-	virtual unsigned long GetMaximumWindowSize(void)=0; // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	virtual unsigned long GetPacketOutputBufferSize(void)=0; // Returns the number of waiting packets on the send queue
-	virtual unsigned long GetConnectionTime(PlayerID playerId)=0; // Returns when this client connected or 0 if not connected
+	// Description:
+	// Returns a structure containing a large set of network statistics for the specified system
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Parameters
+	// playerId: Which connected system to get statistics for
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	virtual RakNetStatisticsStruct * const GetStatistics(PlayerID playerId)=0;
 };
 
 #endif

Modified: branches/multiplayer-branch/source/libraries/raknet/ReliabilityLayer.cpp
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/ReliabilityLayer.cpp	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/ReliabilityLayer.cpp	2004-10-08 21:41:59 UTC (rev 76)
@@ -11,6 +11,14 @@
 #include <assert.h>
 #include "GetTime.h"
 #include "SocketLayer.h"
+
+// alloca
+#ifdef _WIN32
+#include <malloc.h>
+#else
+#include <stdlib.h>
+#endif
+
 //#include "MemoryManager.h"
 
 // Defined in rand.cpp
@@ -19,18 +27,31 @@
 extern inline float frandomMT(void);
 
 static const int ACK_BIT_LENGTH=sizeof(PacketNumberType)*8+1;
-static const int MAXIMUM_WINDOW_SIZE=(DEFAULT_MTU_SIZE-UDP_HEADER_SIZE)*8/ACK_BIT_LENGTH; // Sanity check - the most ack packets that could ever (usually) fit into a frame
-static const int MINIMUM_WINDOW_SIZE=10; // how many packets can be sent unacknowledged before waiting for an ack
+static const int MAXIMUM_WINDOW_SIZE=(DEFAULT_MTU_SIZE-UDP_HEADER_SIZE)*8/ACK_BIT_LENGTH; // Sanity check - the most ack packets that could ever (usually) fit into a frame.
+static const int MINIMUM_WINDOW_SIZE=5; // how many packets can be sent unacknowledged before waiting for an ack
 
+#ifdef _INTERNET_SIMULATOR
+// Lag
+struct DataAndTime
+{
+	char data[2000];
+	int length;
+	unsigned long sendTime;
+};
+static BasicDataStructures::List<DataAndTime*> delayList;
+#endif
+
 //-------------------------------------------------------------------------------------------------------
 // Constructor
 //-------------------------------------------------------------------------------------------------------
 ReliabilityLayer::ReliabilityLayer() : updateBitStream(MAXIMUM_MTU_SIZE) // preallocate the update bitstream so we can avoid a lot of reallocs at runtime
 {
+	receivedPackets=0;
 	InitializeVariables();
 	#ifdef __USE_IO_COMPLETION_PORTS
 	readWriteSocket=INVALID_SOCKET;
 	#endif
+	freeThreadedMemoryOnNextUpdate=false;
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -38,7 +59,7 @@
 //-------------------------------------------------------------------------------------------------------
 ReliabilityLayer::~ReliabilityLayer()
 {
-	FreeMemory();
+	FreeMemory(true); // Free all memory immediately
 	#ifdef __USE_IO_COMPLETION_PORTS
 	if (readWriteSocket!=INVALID_SOCKET)
 		closesocket(readWriteSocket);
@@ -50,9 +71,8 @@
 //-------------------------------------------------------------------------------------------------------
 void ReliabilityLayer::Reset(void)
 {
-	FreeMemory();
+	FreeMemory(false); // False because Reset can be called by any thread
 	InitializeVariables();
-	encryptor.UnsetKey();
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -99,11 +119,13 @@
 	memset(waitingForSequencedPacketReadIndex, 0, NUMBER_OF_ORDERED_STREAMS);
 	memset(waitingForOrderedPacketWriteIndex, 0, NUMBER_OF_ORDERED_STREAMS);
 	memset(waitingForSequencedPacketWriteIndex, 0, NUMBER_OF_ORDERED_STREAMS);
-	memset(receivedPackets, 0, RECEIVED_PACKET_LOG_LENGTH * sizeof(unsigned long));
+	memset(&statistics, 0, sizeof(statistics));
+	statistics.connectionStartTime=RakNetGetTime();
+	lastPacketCounterResetTime=statistics.connectionStartTime;
 	splitPacketId=0L;
 	packetNumber=0;
-	lastPacketSendTime=retransmittedPackets=sentPackets=sentFrames=receivedPacketsCount=bytesSent=bytesReceived=0;
-	lostPacketResendDelay=1000L;
+//	lastPacketSendTime=retransmittedFrames=sentPackets=sentFrames=receivedPacketsCount=bytesSent=bytesReceived=0;
+	SetLostPacketResendDelay(1000L);
 	deadConnection=cheater=false;
 	lastAckTime=0;
 	blockWindowIncreaseUntilTime=0;
@@ -111,110 +133,146 @@
 	windowSize=MINIMUM_WINDOW_SIZE;
 	lossyWindowSize=MAXIMUM_WINDOW_SIZE+1; // Infinite
 	lastWindowIncreaseSizeTime=0;
-	lastPacketReceivedTime=0;
+//	lastPacketReceivedTime=0;
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Frees all allocated memory
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::FreeMemory(void)
+void ReliabilityLayer::FreeMemory(bool freeAllImmediately)
 {
-	unsigned i,j;
+	if (freeAllImmediately)
+	{
+		FreeThreadedMemory();
+		FreeThreadSafeMemory();		
+	}
+	else
+	{
+		FreeThreadSafeMemory();
+		freeThreadedMemoryOnNextUpdate=true;
+	}
+	
+}
+void ReliabilityLayer::FreeThreadedMemory(void)
+{
+	unsigned i;
 	InternalPacket *internalPacket;
 
-//	if (bytesSent > 0 || bytesReceived > 0)
-//	{
-		reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
-		for (i=0; i < splitPacketList.size(); i++)
-		{
-			delete [] splitPacketList[i]->data;
-			InternalPacketPool::Instance()->ReleasePointer(splitPacketList[i]);
-		}
-		splitPacketList.clear();
-		reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
-//	}
+	//	if (bytesSent > 0 || bytesReceived > 0)
+	//	{
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+	for (i=0; i < splitPacketList.size(); i++)
+	{
+		delete [] splitPacketList[i]->data;
+		InternalPacketPool::Instance()->ReleasePointer(splitPacketList[i]);
+	}
+	splitPacketList.clear();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+	//	}
 
-//	if (bytesSent > 0 || bytesReceived > 0)
-//	{
-		reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
-		for (i=0; i < NUMBER_OF_PRIORITIES; i++)
+
+	//	if (bytesSent > 0 || bytesReceived > 0)
+	//	{
+	//reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+	while (outputQueue.size()>0)
+	{
+		internalPacket= outputQueue.pop();
+		delete [] internalPacket->data;
+		InternalPacketPool::Instance()->ReleasePointer(internalPacket);
+	}
+	outputQueue.clearAndForceAllocation(512);
+	//reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+	//	}
+
+	//	if (bytesSent > 0 || bytesReceived > 0)
+	//	{
+	//reliabilityLayerMutexes[orderingList_MUTEX].Lock();
+	for (i=0; i < orderingList.size(); i++)
+	{
+		if (orderingList[i])
 		{
-			for (j=0; j < sendQueue[i].size(); j++)
-			{
-				delete [] (sendQueue[i])[j]->data;
-				InternalPacketPool::Instance()->ReleasePointer((sendQueue[i])[j]);
-			}
-			sendQueue[i].clearAndForceAllocation(512); // Preallocate the send lists so we don't do a bunch of reallocations unnecessarily
-		}
-		reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
-//	}
+			BasicDataStructures::LinkedList<InternalPacket*>* theList = orderingList[i];
 
-//	if (bytesSent > 0 || bytesReceived > 0)
-//	{
-		reliabilityLayerMutexes[orderingList_MUTEX].Lock();
-		for (i=0; i < orderingList.size(); i++)
-		{
-			if (orderingList[i])
+			if (theList)
 			{
-				BasicDataStructures::LinkedList<InternalPacket*>* theList = orderingList[i];
-
-				if (theList)
+				while (theList->size())
 				{
-					while (theList->size())
-					{
-						internalPacket = orderingList[i]->pop();
-						delete [] internalPacket->data;
-						InternalPacketPool::Instance()->ReleasePointer(internalPacket);
-					}
+					internalPacket = orderingList[i]->pop();
+					delete [] internalPacket->data;
+					InternalPacketPool::Instance()->ReleasePointer(internalPacket);
+				}
 
-					delete theList;
-				}
+				delete theList;
 			}
 		}
-		orderingList.clear();
-		reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
-//	}
+	}
+	orderingList.clear();
+	//reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
+	//	}
 
-//	if (bytesSent > 0 || bytesReceived > 0)
-//	{
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
-		while (acknowledgementQueue.size()>0)
-			InternalPacketPool::Instance()->ReleasePointer(acknowledgementQueue.pop());
-		acknowledgementQueue.clearAndForceAllocation(64);
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
-//	}
+	//	if (bytesSent > 0 || bytesReceived > 0)
+	//	{
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+	while (acknowledgementQueue.size()>0)
+		InternalPacketPool::Instance()->ReleasePointer(acknowledgementQueue.pop());
+	acknowledgementQueue.clearAndForceAllocation(64);
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+	//	}
 
-//	if (bytesSent > 0 || bytesReceived > 0)
-//	{
-		reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
-		while (outputQueue.size()>0)
+
+	//	if (bytesSent > 0 || bytesReceived > 0)
+	//	{
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+	while (resendQueue.size())
+	{
+		// The resend Queue can have NULL pointer holes.  This is so we can deallocate blocks without having to compress the array
+		internalPacket= resendQueue.pop();
+		if (internalPacket)
 		{
-			internalPacket= outputQueue.pop();
 			delete [] internalPacket->data;
 			InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 		}
-		outputQueue.clearAndForceAllocation(512);
-		reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
-//	}
+	}
+	resendQueue.clearAndForceAllocation(512);
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+	//	}
 
+	if (receivedPackets)
+	{
+		delete [] receivedPackets;
+		receivedPackets=0;
+	}
+}
+void ReliabilityLayer::FreeThreadSafeMemory(void)
+{
+	unsigned i,j;
+//	InternalPacket *internalPacket;
+
 //	if (bytesSent > 0 || bytesReceived > 0)
 //	{
-		reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-		while (resendQueue.size())
+		
+		for (i=0; i < NUMBER_OF_PRIORITIES; i++)
 		{
-			// The resend Queue can have NULL pointer holes.  This is so we can deallocate blocks without having to compress the array
-			internalPacket= resendQueue.pop();
-			if (internalPacket)
+			j=0;
+			reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Lock();
+			for (; j < sendQueue[i].size(); j++)
 			{
-				delete [] internalPacket->data;
-				InternalPacketPool::Instance()->ReleasePointer(internalPacket);
+				delete [] (sendQueue[i])[j]->data;
+				InternalPacketPool::Instance()->ReleasePointer((sendQueue[i])[j]);
 			}
+			sendQueue[i].clearAndForceAllocation(512); // Preallocate the send lists so we don't do a bunch of reallocations unnecessarily
+			reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Unlock();
 		}
-		resendQueue.clearAndForceAllocation(512);
-		reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+		
 //	}
 
-	InternalPacketPool::Instance()->ClearPool();
+
+#ifdef _INTERNET_SIMULATOR
+	for (i=0; i < delayList.size(); i++)
+		delete delayList[i];
+	delayList.clear();
+#endif
+
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -238,48 +296,59 @@
 	bool pushedPacket;
 	int count;
 
-	bytesReceived+=length + UDP_HEADER_SIZE;
+//	bytesReceived+=length + UDP_HEADER_SIZE;
+	
+	
 
 	// decode this whole chunk if the decoder is defined.
 	if (encryptor.IsKeySet())
 	{
 		if (encryptor.Decrypt((unsigned char*)buffer, length, (unsigned char*)buffer, &length)==false)
+		{
+			statistics.bitsWithBadCRCReceived+=length*8;
+			statistics.packetsWithBadCRCRecieved++;
 			return false;
+		}
 	}
 
-	BitStream socketData(buffer, length, false); // Convert the incoming data to a bitstream for easy parsing
+	statistics.bitsReceived+=length*8;
+	statistics.packetsReceived++;
 
-	time = lastPacketReceivedTime = getTime();
+	RakNet::BitStream socketData(buffer, length, false); // Convert the incoming data to a bitstream for easy parsing
 
+//	time = lastPacketReceivedTime = RakNetGetTime();
+	time=RakNetGetTime();
+
 	//printf("In HandleSocketReceiveFromConnectedPlayer %i bytes\n",length);
 	//for (int ass=0; ass < length && ass < 10; ass++)
 	//	printf("%i ", ((char*)(socketData.GetData()))[ass]);
 	//printf("\n\n");
 
 	// Parse the bitstream to create an internal packet
-	InternalPacket* internalPacket = CreateInternalPacketFromBitStream(&socketData);
+	InternalPacket* internalPacket = CreateInternalPacketFromBitStream(&socketData,time);
 
-
 	while (internalPacket)
 	{
 		if (internalPacket->isAcknowledgement)
 		{
+		//	printf("Got ack at %i\n", RakNetGetTime());
+
 			numberOfAcksInFrame++;
-			reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 			if (resendQueue.size()==0)
 			{
-				reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();				
-				reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();				
+				//reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
 				lastAckTime=0;  // Not resending anything so clear this var so we don't drop the connection on not getting any more acks
-				reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
+				//reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
 			}
 			else
 			{
-				reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
-				reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
+				//reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
 				lastAckTime=time; // Just got an ack.  Record when we got it so we know the connection is alive
-				reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
+				//reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
 			}
 
 			// SHOW - ack received
@@ -290,11 +359,11 @@
 		}
 		else
 		{
-			receivedPacketsCount++;
+//			receivedPacketsCount++;
 
 			if (internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED || internalPacket->reliability==RELIABLE)
 			{
-				SendAcknowledgementPacket(internalPacket->packetNumber);
+				SendAcknowledgementPacket(internalPacket->packetNumber, time);
 			}
 
 			// If this packet number was recently used then it has already been received.
@@ -303,8 +372,11 @@
 			// make it through within NUMBER_OF_TRIES tries. If the last time this packet 
 			// number was used is older than that
 			// then it must be a different packet
+			/*
 			if (internalPacket->packetNumber >= RECEIVED_PACKET_LOG_LENGTH)
 			{
+				statistics.invalidMessagesReceived++;
+
 				delete [] internalPacket->data;
 				InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 				#ifdef _DEBUG
@@ -312,36 +384,66 @@
 				#endif
 				return true;
 			}
-			if (receivedPackets[internalPacket->packetNumber] > time - TIMEOUT_TIME) 
+			*/
+
+			// testing
+	//		if (internalPacket->reliability==UNRELIABLE)
+	//			printf("Got unreliable packet number %i\n", internalPacket->packetNumber);
+	//		else if (internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED || internalPacket->reliability==RELIABLE)
+	//			printf("Got reliable packet number %i\n", internalPacket->packetNumber);
+
+			if (receivedPackets==0)
+			{
+				receivedPackets=new unsigned long[65536];// Range of PacketNumberType
+				memset(receivedPackets, 0, 65536 * sizeof(unsigned long));
+			}
+			else if (receivedPackets[internalPacket->packetNumber] > time - TIMEOUT_TIME) 
 				// I can receive RECEIVED_PACKET_LOG_LENGTH packets per TIMEOUT_TIME seconds before overrun on timestamps
 			{
 				// SHOW - duplicate packets
-				//printf("Warning - got duplicate packet (%i).  Did RECEIVED_PACKET_LOG_LENGTH overrun?\n",internalPacket->packetNumber);
+#ifdef _DEBUG
+				// printf("Warning - got duplicate packet (%i).  Did RECEIVED_PACKET_LOG_LENGTH overrun?\n",internalPacket->packetNumber);
+				// testing
+				//printf("Got duplicate packet\n");
+#endif
 
+				statistics.duplicateMessagesReceived++;
+
 				// Duplicate packet
 				delete [] internalPacket->data;
 				InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 				goto CONTINUE_SOCKET_DATA_PARSE_LOOP;
 			}
 
+
+			statistics.messagesReceived++;
+
 			// Record that this particular packet was received at this time
 			receivedPackets[internalPacket->packetNumber]=time;
 
+			// Keep on top of deleting old unreliable split packets so they don't clog the list.
+			if (internalPacket->splitPacketCount>0)
+				DeleteOldUnreliableSplitPackets(time);
+
 			if (internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==UNRELIABLE_SEQUENCED)
 			{
 				#ifdef _DEBUG
-				assert(internalPacket->orderingStream < NUMBER_OF_ORDERED_STREAMS);
+				assert(internalPacket->orderingChannel < NUMBER_OF_ORDERED_STREAMS);
 				#endif
-				if (internalPacket->orderingStream >= NUMBER_OF_ORDERED_STREAMS)
+				if (internalPacket->orderingChannel >= NUMBER_OF_ORDERED_STREAMS)
 				{
 					// Invalid packet
+#ifdef _DEBUG
+					printf("Got invalid packet\n");
+#endif
 					delete [] internalPacket->data;
 					InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 					goto CONTINUE_SOCKET_DATA_PARSE_LOOP;
 				}
 
-				if (IsOlderOrderedPacket(internalPacket->orderingIndex, waitingForSequencedPacketReadIndex[internalPacket->orderingStream])==false)
+				if (IsOlderOrderedPacket(internalPacket->orderingIndex, waitingForSequencedPacketReadIndex[internalPacket->orderingChannel])==false)
 				{
+					statistics.sequencedMessagesInOrder++;
 
 					// Check for older packets in the output list.  Delete any found
 					// UPDATE:
@@ -351,12 +453,12 @@
 					// don't need the older ones because the odds are they will still arrive in order
 					/*
 					reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
-					DeleteSequencedPacketsInList(internalPacket->orderingStream, outputQueue);
+					DeleteSequencedPacketsInList(internalPacket->orderingChannel, outputQueue);
 					reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 
 					// Check for older packets in the split packet list.  Delete any found
 					reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
-					DeleteSequencedPacketsInList(internalPacket->orderingStream, splitPacketList, internalPacket->splitPacketId);
+					DeleteSequencedPacketsInList(internalPacket->orderingChannel, splitPacketList, internalPacket->splitPacketId);
 					reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 */
 					// Is this a split packet?
@@ -368,43 +470,42 @@
 						assert(internalPacket->splitPacketIndex < internalPacket->splitPacketCount);
 						assert(internalPacket->dataBitLength < MAXIMUM_MTU_SIZE*8);
 
-						reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+						//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 						// Make sure this is not a duplicate insertion.  If this assert hits then splitPacketId overflowed into existing waiting split packets (i.e. more than rangeof(splitPacketId) waiting) 
 						for (unsigned cnt=0; cnt < splitPacketList.size(); cnt++)
 							assert (!(splitPacketList[cnt]->splitPacketIndex==internalPacket->splitPacketIndex && splitPacketList[cnt]->splitPacketId==splitPacketId));
 						int splitPacketListSize = splitPacketList.size()+1;
-						reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+						//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 						#endif
 
 						// Check for a rebuilt packet
 						InsertIntoSplitPacketList(internalPacket);
 
 						// Sequenced
-						internalPacket = BuildPacketFromSplitPacketList(internalPacket->splitPacketId);
+						internalPacket = BuildPacketFromSplitPacketList(internalPacket->splitPacketId,time);
 
 						if (internalPacket)
 						{
 #ifdef _DEBUG
-							reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+							//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 							assert(splitPacketList.size() == splitPacketListSize-internalPacket->splitPacketCount );
-							reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+							//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 #endif
 							// Update our index to the newest packet
-							waitingForSequencedPacketReadIndex[internalPacket->orderingStream]=internalPacket->orderingIndex+1;
+							waitingForSequencedPacketReadIndex[internalPacket->orderingChannel]=internalPacket->orderingIndex+1;
 
 							// If there is a rebuilt packet, add it to the output queue
-							reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
-
+//							reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 							outputQueue.push(internalPacket);
-							reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//							reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 							internalPacket=0;
 						}
 #ifdef _DEBUG
 						else
 						{
-							reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+							//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 							assert(splitPacketList.size() == splitPacketListSize );
-							reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+							//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 						}
 #endif
 						// else don't have all the parts yet
@@ -412,18 +513,19 @@
 					else
 					{
 						// Update our index to the newest packet
-						waitingForSequencedPacketReadIndex[internalPacket->orderingStream]=internalPacket->orderingIndex+1;
+						waitingForSequencedPacketReadIndex[internalPacket->orderingChannel]=internalPacket->orderingIndex+1;
 
 						// Not a split packet. Add the packet to the output queue
-						reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
-
+//						reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 						outputQueue.push(internalPacket);
-						reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//						reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 						internalPacket=0;
 					}
 				}
 				else
 				{
+					statistics.sequencedMessagesOutOfOrder++;
+					
 					// Older sequenced packet.  Discard it
 					delete [] internalPacket->data;
 					InternalPacketPool::Instance()->ReleasePointer(internalPacket);
@@ -445,26 +547,26 @@
 
 				// Check for a rebuilt packet
 				if (internalPacket->reliability!=RELIABLE_ORDERED)
-					internalPacket->orderingStream=255; // Use 255 to designate not sequenced and not ordered
+					internalPacket->orderingChannel=255; // Use 255 to designate not sequenced and not ordered
 
 #ifdef _DEBUG
-				reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+				//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 				// Make sure this is not a duplicate insertion.  If this assert hits then splitPacketId overflowed into existing waiting split packets (i.e. more than rangeof(splitPacketId) waiting) 
 				for (unsigned cnt=0; cnt < splitPacketList.size(); cnt++)
 					assert (!(splitPacketList[cnt]->splitPacketIndex==internalPacket->splitPacketIndex && splitPacketList[cnt]->splitPacketId==internalPacket->splitPacketId));
 				int splitPacketListSize = splitPacketList.size()+1;
-				reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+				//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 #endif
 				InsertIntoSplitPacketList(internalPacket);
 
-				internalPacket = BuildPacketFromSplitPacketList(internalPacket->splitPacketId);
+				internalPacket = BuildPacketFromSplitPacketList(internalPacket->splitPacketId,time);
 
 				if (internalPacket==0)
 				{
 					#ifdef _DEBUG
-					reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+					//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 					assert(splitPacketList.size() == splitPacketListSize );
-					reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+					//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 					#endif
 
 					// Don't have all the parts yet
@@ -473,9 +575,9 @@
 				#ifdef _DEBUG
 				else
 				{
-					reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+					//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 					assert(splitPacketList.size() == splitPacketListSize-internalPacket->splitPacketCount );
-					reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+					//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 				}
 				#endif
 				// else continue down to handle RELIABLE_ORDERED
@@ -484,9 +586,9 @@
 			if (internalPacket->reliability==RELIABLE_ORDERED)
 			{
 				#ifdef _DEBUG
-				assert(internalPacket->orderingStream < NUMBER_OF_ORDERED_STREAMS);
+				assert(internalPacket->orderingChannel < NUMBER_OF_ORDERED_STREAMS);
 				#endif
-				if (internalPacket->orderingStream >= NUMBER_OF_ORDERED_STREAMS)
+				if (internalPacket->orderingChannel >= NUMBER_OF_ORDERED_STREAMS)
 				{
 					// Invalid packet
 					delete [] internalPacket->data;
@@ -494,27 +596,29 @@
 					goto CONTINUE_SOCKET_DATA_PARSE_LOOP;
 				}
 
-				if (waitingForOrderedPacketReadIndex[internalPacket->orderingStream]==internalPacket->orderingIndex)
+				if (waitingForOrderedPacketReadIndex[internalPacket->orderingChannel]==internalPacket->orderingIndex)
 				{
 					// Get the list to hold ordered packets for this stream
 					BasicDataStructures::LinkedList<InternalPacket*> *orderingListAtOrderingStream;
-					unsigned char orderingStreamCopy=internalPacket->orderingStream;
+					unsigned char orderingChannelCopy=internalPacket->orderingChannel;
 
+					statistics.orderedMessagesInOrder++;
+
 					// Push the packet for the user to read
-					reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+//					reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 					outputQueue.push(internalPacket);
-					reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//					reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 					internalPacket=0; // Don't reference this any longer since other threads access it
 
 					// Wait for the next ordered packet in sequence
-					waitingForOrderedPacketReadIndex[orderingStreamCopy]++; // This wraps at 255
+					waitingForOrderedPacketReadIndex[orderingChannelCopy]++; // This wraps at 255
 
-					reliabilityLayerMutexes[orderingList_MUTEX].Lock();
-					orderingListAtOrderingStream = GetOrderingListAtOrderingStream(orderingStreamCopy);
+					//reliabilityLayerMutexes[orderingList_MUTEX].Lock();
+					orderingListAtOrderingStream = GetOrderingListAtOrderingStream(orderingChannelCopy);
 
 					if (orderingListAtOrderingStream!=0)
 					{
-						// There is a list for this ordering stream that may contain waiting packets.  Pop them in order
+						// There is a list for this ordering channel that may contain waiting packets.  Pop them in order
 
 						// Scan the list and pop packets that were delayed due to ordering in order
 						while (orderingListAtOrderingStream->size()>0)
@@ -524,18 +628,18 @@
 							pushedPacket=false;
 							while (count!=0)
 							{
-								if (orderingListAtOrderingStream->peek()->orderingIndex == waitingForOrderedPacketReadIndex[orderingStreamCopy])
+								if (orderingListAtOrderingStream->peek()->orderingIndex == waitingForOrderedPacketReadIndex[orderingChannelCopy])
 								{
 									// A packet was waiting, so output it in order.
 									// This is already mutexed above
 
 									// Push the packet for the user to read
-									reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+//									reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 									outputQueue.push(orderingListAtOrderingStream->pop());
-									reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//									reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 
 									// Wait for the next ordered packet in sequence
-									waitingForOrderedPacketReadIndex[orderingStreamCopy]++; // This wraps at 255
+									waitingForOrderedPacketReadIndex[orderingChannelCopy]++; // This wraps at 255
 
 									pushedPacket=true;
 
@@ -553,12 +657,14 @@
 						}
 
 					}
-					reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
+					//reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
 
 					internalPacket=0;
 				}
 				else
 				{
+					statistics.orderedMessagesOutOfOrder++;
+
 					// This is a newer ordered packet than we are waiting for.  Store it for future use
 					AddToOrderingList(internalPacket);
 				}
@@ -567,13 +673,13 @@
 			}
 
 			// Nothing special about this packet.  Add it to the output queue
-			reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+//			reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 			outputQueue.push(internalPacket); 
-			reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//			reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 
 			// Output queue fill rate test
 //			if (outputQueue.size()%50==0)
-//				printf("outputQueue.size()=%i Time=%i\n", outputQueue.size(), getTime());
+//				printf("outputQueue.size()=%i Time=%i\n", outputQueue.size(), RakNetGetTime());
 
 			internalPacket=0;
 		}
@@ -581,12 +687,15 @@
 		// Used for a goto to jump to the next packet immediately
 		CONTINUE_SOCKET_DATA_PARSE_LOOP:
 		// Parse the bitstream to create an internal packet
-		internalPacket = CreateInternalPacketFromBitStream(&socketData);
+		internalPacket = CreateInternalPacketFromBitStream(&socketData,time);
 	}
 
-	reliabilityLayerMutexes[windowSize_MUTEX].Lock();
-	if (numberOfAcksInFrame>=windowSize && sendQueue[HIGH_PRIORITY].size()>0)
+
+	// numberOfAcksInFrame>=windowSize is almost never true
+	if (numberOfAcksInFrame>=windowSize && (sendQueue[SYSTEM_PRIORITY].size()>0 || sendQueue[HIGH_PRIORITY].size()>0 || sendQueue[MEDIUM_PRIORITY].size()>0))
 	{
+
+	//	reliabilityLayerMutexes[windowSize_MUTEX].Lock();
 		if (windowSize < lossyWindowSize || time - lastWindowIncreaseSizeTime > lostPacketResendDelay*2) // Increases the window size slowly, testing for packetloss
 		{
 			// If we get a frame which clears out the resend queue after handling one or more acks, and we have packets waiting to go out,
@@ -607,8 +716,8 @@
 			if (windowSize==MAXIMUM_WINDOW_SIZE || windowSize - lossyWindowSize > 5)
 				lossyWindowSize++;
 		}
+	//	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
 	}
-	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
 
 	return true;
 }
@@ -620,14 +729,14 @@
 {
 	InternalPacket* internalPacket;
 
-	reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+//	reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 	if (outputQueue.size()>0)
 	{
-//		#ifdef _DEBUG
-//		assert(bitStream->GetNumberOfBitsUsed()==0);
-//		#endif
+		//		#ifdef _DEBUG
+		//		assert(bitStream->GetNumberOfBitsUsed()==0);
+		//		#endif
 		internalPacket = outputQueue.pop();
-		reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//		reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 
 		//printf("In Receive %i bytes\n",(internalPacket->dataBitLength-1)/8+1);
 		//for (int ass=0; ass < (internalPacket->dataBitLength-1)/8+1 && ass < 10; ass++)
@@ -644,9 +753,10 @@
 	}
 	else
 	{
-		reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+	//	reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 		return 0;
 	}
+	
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -654,14 +764,14 @@
 // bitStream contains the data to send
 // priority is what priority to send the data at
 // reliability is what reliability to use
-// ordering stream is from 0 to 255 and specifies what stream to use
+// ordering channel is from 0 to 255 and specifies what stream to use
 //-------------------------------------------------------------------------------------------------------
-bool ReliabilityLayer::Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, unsigned char orderingStream, bool makeDataCopy, int MTUSize)
+bool ReliabilityLayer::Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, unsigned char orderingChannel, bool makeDataCopy, int MTUSize)
 {
 	#ifdef _DEBUG
 	assert(!(reliability > RELIABLE_SEQUENCED || reliability < 0));
 	assert(!(priority > NUMBER_OF_PRIORITIES || priority < 0));
-	assert(!(orderingStream < 0 || orderingStream >= NUMBER_OF_ORDERED_STREAMS));
+	assert(!(orderingChannel < 0 || orderingChannel >= NUMBER_OF_ORDERED_STREAMS));
 	assert(bitStream->GetNumberOfBytesUsed()>0);
 	#endif
 
@@ -677,8 +787,8 @@
 	if (priority > NUMBER_OF_PRIORITIES || priority < 0)
 		priority = HIGH_PRIORITY;
 
-	if (orderingStream >= NUMBER_OF_ORDERED_STREAMS)
-		orderingStream=0;
+	if (orderingChannel >= NUMBER_OF_ORDERED_STREAMS)
+		orderingChannel=0;
 
 	if (bitStream->GetNumberOfBytesUsed()==0)
 	{
@@ -694,7 +804,7 @@
 	memset(internalPacket, 255, sizeof(InternalPacket));
 #endif
 
-	internalPacket->creationTime=getTime();
+	internalPacket->creationTime=RakNetGetTime();
 	if (makeDataCopy)
 	{
 		internalPacket->data = new char [bitStream->GetNumberOfBytesUsed()];
@@ -722,33 +832,27 @@
 
 	// If a split packet, we might have to upgrade the reliability
 	if (splitPacket)
-	{
-		// Split packets must be sent reliably.  Otherwise not all the parts might arrive
-		if (internalPacket->reliability==UNRELIABLE)
-			internalPacket->reliability=RELIABLE;
-		else if (internalPacket->reliability==UNRELIABLE_SEQUENCED)
-			internalPacket->reliability=RELIABLE_SEQUENCED;
-	}
+		statistics.numberOfSplitMessages++;
+	else
+		statistics.numberOfUnsplitMessages++;
 
 	// Increment the cyclical receivedPacketsIndex for use by the next packet.
 	// This variable is used as the identifier of the packet on the remote machine.
 	// When it cycles it will reuse older numbers but that is ok because by the time it
 	// cycles those older packets will be pretty much guaranteed to arrive by then
-	reliabilityLayerMutexes[packetNumber_MUTEX].Lock();
-	if (++packetNumber==RECEIVED_PACKET_LOG_LENGTH)
-		packetNumber=0;
-	reliabilityLayerMutexes[packetNumber_MUTEX].Unlock();
-
+	
+	IncrementPacketNumber(internalPacket->creationTime);
+	
 	if (internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==UNRELIABLE_SEQUENCED)
 	{
 		// Assign the sequence stream and index
-		internalPacket->orderingStream=orderingStream;
+		internalPacket->orderingChannel=orderingChannel;
 		reliabilityLayerMutexes[waitingForSequencedPacketWriteIndex_MUTEX].Lock();
-		internalPacket->orderingIndex=waitingForSequencedPacketWriteIndex[orderingStream]++;
+		internalPacket->orderingIndex=waitingForSequencedPacketWriteIndex[orderingChannel]++;
 		reliabilityLayerMutexes[waitingForSequencedPacketWriteIndex_MUTEX].Unlock();
 
-		// This packet supercedes all other sequenced packets on the same ordering stream
-		// Delete all packets in all send lists that are sequenced and on the same ordering stream
+		// This packet supercedes all other sequenced packets on the same ordering channel
+		// Delete all packets in all send lists that are sequenced and on the same ordering channel
 		// UPDATE:
 		// Disabled.  We don't have enough info to consistently do this.  Sometimes newer data does supercede
 		// older data such as with constantly declining health, but not in all cases.
@@ -758,30 +862,30 @@
 		for (int i=0; i < NUMBER_OF_PRIORITIES; i++)
 		{
 			reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
-			DeleteSequencedPacketsInList(orderingStream, sendQueue[i]);
+			DeleteSequencedPacketsInList(orderingChannel, sendQueue[i]);
 			reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
 		}
 		*/
 	}
 	else if (internalPacket->reliability==RELIABLE_ORDERED)
 	{
-		// Assign the ordering stream and index
-		internalPacket->orderingStream=orderingStream;
+		// Assign the ordering channel and index
+		internalPacket->orderingChannel=orderingChannel;
 		reliabilityLayerMutexes[waitingForOrderedPacketWriteIndex_MUTEX].Lock();
-		internalPacket->orderingIndex=waitingForOrderedPacketWriteIndex[orderingStream]++;
+		internalPacket->orderingIndex=waitingForOrderedPacketWriteIndex[orderingChannel]++;
 		reliabilityLayerMutexes[waitingForOrderedPacketWriteIndex_MUTEX].Unlock();
 	}
 
 	if (splitPacket) // If it uses a secure header it will be generated here
 	{
 		// Must split the packet.  This will also generate the SHA1 if it is required.  It also adds it to the send list.
-		SplitPacketAndDeleteOriginal(internalPacket, MTUSize);
+		SplitPacketAndDeleteOriginal(internalPacket, MTUSize, internalPacket->creationTime);
 		return true;
 	}
 	
-	reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+	reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+internalPacket->priority].Lock();
     sendQueue[internalPacket->priority].push(internalPacket);
-	reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
+	reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+internalPacket->priority].Unlock();
 
 	return true;
 }
@@ -789,27 +893,35 @@
 //-------------------------------------------------------------------------------------------------------
 // Run this once per game cycle.  Handles internal lists and actually does the send
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::Update(SOCKET s, PlayerID playerId, int MTUSize)
+void ReliabilityLayer::Update(SOCKET s, PlayerID playerId, int MTUSize, unsigned long time)
 {
 #ifdef __USE_IO_COMPLETION_PORTS
 	if (readWriteSocket==INVALID_SOCKET)
 		return;
 #endif
-//	unsigned resendQueueSize;
+	//	unsigned resendQueueSize;
 	bool reliableDataSent;
 	unsigned long lastAck;
 
+	if (freeThreadedMemoryOnNextUpdate)
+	{
+		freeThreadedMemoryOnNextUpdate=false;
+		FreeThreadedMemory();
+	}
+
 	// Accuracy isn't important on this value, and since this is called so often the mutex is sometimes causing deadlock problems.
 	// So it is presently disabled
 //	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 //	resendQueueSize=resendQueue.size();
 //	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
-	reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
+//	reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
 	lastAck=lastAckTime;
-	reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
+//	reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
 
-	if (resendQueue.size()>0 && lastAck && getTime() - lastAck > TIMEOUT_TIME)
+	// Due to thread vagarities and the way I store the time to avoid slow calls to RakNetGetTime
+	// time may be less than lastAck
+	if (resendQueue.size()>0 && time > lastAck && lastAck && time - lastAck > TIMEOUT_TIME)
 	{
 		// SHOW - dead connection
 		// printf("The connection has been lost.\n");
@@ -818,7 +930,7 @@
 		return;
 	}
 
-	//if (outputWindowFullTime && getTime() > TIMEOUT_TIME + outputWindowFullTime)
+	//if (outputWindowFullTime && RakNetGetTime() > TIMEOUT_TIME + outputWindowFullTime)
 	//{
 	//	// We've waited a long time with no data from the other system.  Assume the connection is lost
 	//	deadConnection=true;
@@ -827,29 +939,60 @@
 
 	// Not a frame but a packet actually.
 	// However, in a sense it is a frame because we are filling multiple logical packets into one datagram
-	if (IsFrameReady())
+	//reliabilityLayerMutexes[updateBitStream_MUTEX].Lock();
+
+	// Keep sending to available bandwidth
+	while (IsFrameReady(time))
 	{
-		reliabilityLayerMutexes[updateBitStream_MUTEX].Lock();
+		updateBitStream.Reset();
+		GenerateFrame(&updateBitStream, MTUSize, &reliableDataSent,time);
+		if (updateBitStream.GetNumberOfBitsUsed()>0)
+		{
+#ifndef _INTERNET_SIMULATOR
+			SendBitStream(s, playerId, &updateBitStream);
+#else
+			// Delay the send to simulate lag
+			DataAndTime *dt;
+			dt=new DataAndTime;
+			memcpy(dt->data, updateBitStream.GetData(), updateBitStream.GetNumberOfBytesUsed());
+			dt->length=updateBitStream.GetNumberOfBytesUsed();
+			dt->sendTime=time+100+(randomMT()%100);
+			delayList.insert(dt);
+#endif
+		}
+		else
+			break;
+	}
+	
 
-		do
+#ifdef _INTERNET_SIMULATOR
+	// Do any lagged sends
+	unsigned i=0;
+	while (i < delayList.size())
+	{
+		if (delayList[i]->sendTime<time)
 		{
 			updateBitStream.Reset();
-			GenerateFrame(&updateBitStream, MTUSize, &reliableDataSent);
-			if (updateBitStream.GetNumberOfBitsUsed()>0)
-			{
-				SendBitStream(s, playerId, &updateBitStream);
-			}
+			updateBitStream.Write(delayList[i]->data, delayList[i]->length);
+			// Send it now
+			SendBitStream(s, playerId, &updateBitStream);
 
-		} while (updateBitStream.GetNumberOfBitsUsed()>0 && IsFrameReady());
+			delete delayList[i];
+			delayList[i]=delayList[delayList.size()-1];
+			delayList.del();
+		}
+		else
+			i++;
+	}
+#endif
 
-		reliabilityLayerMutexes[updateBitStream_MUTEX].Unlock();
-	}
+	//reliabilityLayerMutexes[updateBitStream_MUTEX].Unlock();
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Writes a bitstream to the socket
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::SendBitStream(SOCKET s, PlayerID playerId, BitStream *bitStream)
+void ReliabilityLayer::SendBitStream(SOCKET s, PlayerID playerId, RakNet::BitStream *bitStream)
 {
  // SHOW - showing reliable flow
 //	if (bitStream->GetNumberOfBytesUsed()>50)
@@ -857,15 +1000,19 @@
 
 	int oldLength, length;
 
-	sentFrames++;
+//	sentFrames++;
 
 #ifdef _INTERNET_SIMULATOR
+
+	/*
 	// packetloss
-	if (randomMT() %100 <=10)
+	if (windowSize>MINIMUM_WINDOW_SIZE && frandomMT() <= (float)(windowSize-MINIMUM_WINDOW_SIZE)/(float)(MAXIMUM_WINDOW_SIZE-MINIMUM_WINDOW_SIZE))
 	{
-		lastPacketSendTime=getTime();
+		// printf("Frame %i lost\n", sentFrames);
+		lastPacketSendTime=RakNetGetTime();
 		return;
 	}
+	*/
 #endif
 
 
@@ -874,64 +1021,68 @@
 	{
 		length = bitStream->GetNumberOfBytesUsed();
 		oldLength = length;
+
 		encryptor.Encrypt((unsigned char*)bitStream->GetData(), length, (unsigned char*)bitStream->GetData(), &length);
+		statistics.encryptionBitsSent=(length-oldLength)*8;
 
-		if (encryptor.IsKeySet())
-			bytesSent+=length - oldLength;
+		// TODO - put back in
+		assert((length % 16 )== 0);
 	}
 	else
 	{
 		length = bitStream->GetNumberOfBytesUsed();
 	}
 
-
 #ifdef __USE_IO_COMPLETION_PORTS
 	if (readWriteSocket==INVALID_SOCKET)
 	{
-		assert(0);
-		return;
+		assert(0);	return;
 	}
+	statistics.packetsSent++;
+	statistics.totalBitsSent+=length*8;
 	SocketLayer::Instance()->Write(readWriteSocket, (const char*)bitStream->GetData(), length);
 #else
-    SocketLayer::Instance()->SendTo(s, (char*)bitStream->GetData(), length, playerId);
-#endif
+	statistics.packetsSent++;
+	statistics.totalBitsSent+=length*8;
+	//printf("total bits=%i length=%i\n", BITS_TO_BYTES(statistics.totalBitsSent), length);
+    SocketLayer::Instance()->SendTo(s, (char*)bitStream->GetData(), length, playerId.binaryAddress, playerId.port);
+#endif // __USE_IO_COMPLETION_PORTS
 
-	lastPacketSendTime=getTime();
+//	lastPacketSendTime=time;
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Returns true if we can or should send a frame.  False if we should not
 //-------------------------------------------------------------------------------------------------------
-bool ReliabilityLayer::IsFrameReady(void)
+bool ReliabilityLayer::IsFrameReady(unsigned long time)
 {
 	if (IsSendThrottled()==false)
 		return true;
 
-	unsigned long time = getTime();
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
 
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
-
 	// Any acknowledgement packets waiting?  We will send these even if the send is throttled.
 	// Otherwise the throttle may never end
-	if (acknowledgementQueue.size()>0 &&
-		(acknowledgementQueue.size() >= MINIMUM_WINDOW_SIZE ||
-		acknowledgementQueue.peek()->nextActionTime < time))
+	if (acknowledgementQueue.size() >= MINIMUM_WINDOW_SIZE
+		// Try not waiting to send acks - will take more bandwidth but maybe less packetloss
+		// || acknowledgementQueue.peek()->nextActionTime < time
+		)
 	{
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+		//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 		return true;
 	}
 	
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+//	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 
 	// Does the oldest packet need to be resent?  If so, send it.
 	// Otherwise the throttle may never end
-	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+//	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 	if (resendQueue.size()>0 && resendQueue.peek() && resendQueue.peek()->nextActionTime < time)
 	{
-		reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+//		reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 		return true;
 	}
-	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+//	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
 	// Send is throttled.  Don't send.
 	return false;
@@ -940,13 +1091,13 @@
 //-------------------------------------------------------------------------------------------------------
 // Generates a frame (coalesced packets)
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::GenerateFrame(BitStream *output, int MTUSize, bool *reliableDataSent)
+
+void ReliabilityLayer::GenerateFrame(RakNet::BitStream *output, int MTUSize, bool *reliableDataSent,unsigned long time)
 {
 	InternalPacket *internalPacket;
 	int maxDataBitSize;
 	int reliableBits=0;
 	int nextPacketBitLength;
-	unsigned long time;
 	unsigned i;
 	bool isReliable,onlySendUnreliable;
 	bool acknowledgementPacketsSent;
@@ -959,11 +1110,11 @@
 
 	acknowledgementPacketsSent=false;
 
-	time = getTime();
 	*reliableDataSent=false;
+	
 
 	// Packet acknowledgements always go out first if they are overdue or if there are a lot of them
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
 	//	reliabilityLayerMutexes[remoteFramesAwaitingAck_MUTEX].Lock();
 	if (acknowledgementQueue.size()>0 &&
 		(acknowledgementQueue.size() >=MINIMUM_WINDOW_SIZE ||
@@ -971,110 +1122,114 @@
 	{
 		do
 		{
-
 			//	reliabilityLayerMutexes[remoteFramesAwaitingAck_MUTEX].Unlock();
 			internalPacket = acknowledgementQueue.pop();
-			reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+			//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 
 			// Write the acknowledgement to the output bitstream
-			WriteToBitStreamFromInternalPacket(output, internalPacket);
+			statistics.acknowlegementsSent++;
+			statistics.acknowlegementBitsSent+=WriteToBitStreamFromInternalPacket(output, internalPacket);
 			acknowledgementPacketsSent=true;
 
 			// Delete the acknowledgement
 			InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 
-			if (	output->GetNumberOfBitsUsed() + ACK_BIT_LENGTH > maxDataBitSize)
+			if (output->GetNumberOfBitsUsed() + ACK_BIT_LENGTH > maxDataBitSize)
 			{
-
 				// SHOW - show ack
-		//		printf("Sending FULL ack (%i) at time %i. acknowledgementQueue.size()=%i\n", output->GetNumberOfBytesUsed(), getTime(),acknowledgementQueue.size());
+				//printf("Sending FULL ack (%i) at time %i. acknowledgementQueue.size()=%i\n", output->GetNumberOfBytesUsed(), RakNetGetTime(),acknowledgementQueue.size());
 
+				statistics.packetsContainingOnlyAcknowlegements++;
 				goto END_OF_GENERATE_FRAME;
 			}
 
-			reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+	//		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
 		} while(acknowledgementQueue.size() > 0);
 	}
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 
+	
+
 	// SHOW - show ack
 	//if (output->GetNumberOfBitsUsed()>0)
-		//printf("Sending ack (%i) at time %i. acknowledgementQueue.size()=%i\n", output->GetNumberOfBytesUsed(), getTime(),acknowledgementQueue.size());
+	//	printf("Sending ack (%i) at time %i. acknowledgementQueue.size()=%i\n", output->GetNumberOfBytesUsed(), RakNetGetTime(),acknowledgementQueue.size());
 
-	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 
 	// The resend Queue can have NULL pointer holes.  This is so we can deallocate blocks without having to compress the array
-	while (resendQueue.size() > 0 && (resendQueue.peek()==0 || resendQueue.peek()->nextActionTime < time))
+	while (resendQueue.size() > 0)
 	{
-		// Copy the first packet out of the resend list
-		internalPacket = resendQueue.pop();
-
-		if (internalPacket==0)
+		if (resendQueue.peek()==0)
+		{
+			resendQueue.pop();
 			continue; // This was a hole
+		}
 
-		reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+		if (resendQueue.peek()->nextActionTime < time)
+		{
+			internalPacket = resendQueue.pop();
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+			// Testing
+			//printf("Resending %i. queue size = %i\n", internalPacket->packetNumber, resendQueue.size());
 
-		nextPacketBitLength = GetBitStreamHeaderLength(internalPacket) + internalPacket->dataBitLength;
+			nextPacketBitLength = GetBitStreamHeaderLength(internalPacket) + internalPacket->dataBitLength;
 
-		if (	output->GetNumberOfBitsUsed() + nextPacketBitLength > maxDataBitSize)
-		{
-			reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-			resendQueue.pushAtHead(internalPacket); // Not enough room to use this packet after all!
-			reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+			if (output->GetNumberOfBitsUsed() + nextPacketBitLength > maxDataBitSize)
+			{
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+				resendQueue.pushAtHead(internalPacket); // Not enough room to use this packet after all!
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
-			if (anyPacketsLost)
-			{
-				// The window size will decrease everytime we have to retransmit a frame
-				reliabilityLayerMutexes[windowSize_MUTEX].Lock();
-				if (--windowSize < MINIMUM_WINDOW_SIZE)
-					windowSize=MINIMUM_WINDOW_SIZE;
-				reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
-				lossyWindowSize=windowSize;
-				lastWindowIncreaseSizeTime=time;  // This will block the window size from increasing immediately
-				// SHOW - windowing
-				//printf("Frame lost.  New window size = %i.  Lossy window size = %i\n", windowSize, lossyWindowSize);
+				if (anyPacketsLost)
+				{
+					UpdatePacketloss(time);
+				}
+
+				goto END_OF_GENERATE_FRAME;
 			}
 
-			goto END_OF_GENERATE_FRAME;
-		}
+#ifdef _DEBUG
+			assert(internalPacket->priority>=0);
+			assert(internalPacket->reliability>=0);
+#endif
 
-		#ifdef _DEBUG
-		assert(internalPacket->priority>=0);
-		assert(internalPacket->reliability>=0);
-		#endif
+			// SHOW - show resends
+			//printf("Resending packet. resendQueue.size()=%i. Data=%s\n",resendQueue.size(), internalPacket->data);
 
-		// SHOW - show resends
-		//printf("Resending packet. resendQueue.size()=%i. Data=%s\n",resendQueue.size(), internalPacket->data);
+			// Write to the output bitstream
+//			sentPackets++;
+			statistics.messageResends++;
+			statistics.messageDataBitsResent+=internalPacket->dataBitLength;
 
-		// Write to the output bitstream
-		sentPackets++;
-		WriteToBitStreamFromInternalPacket(output, internalPacket);
-		*reliableDataSent=true;
+			statistics.messagesTotalBitsResent+=WriteToBitStreamFromInternalPacket(output, internalPacket);
+			*reliableDataSent=true;
 
-		// Update packetloss
-		UpdatePacketloss();
-		anyPacketsLost=true;
+			//		if (output->GetNumberOfBitsUsed() + ACK_BIT_LENGTH > maxDataBitSize)
+			//			printf("Frame full of just acks and resends at time %i.\n", RakNetGetTime());
 
-		reliableBits+=internalPacket->dataBitLength;
-		internalPacket->nextActionTime = time + lostPacketResendDelay;
+			statistics.packetsContainingOnlyAcknowlegementsAndResends++;
 
-		// Put the packet back into the resend list at the correct spot
-		InsertPacketIntoResendQueue(internalPacket);
-		reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+			anyPacketsLost=true;
+			internalPacket->nextActionTime = time + lostPacketResendDelay;
+
+			// Put the packet back into the resend list at the correct spot
+			InsertPacketIntoResendQueue(internalPacket, time);
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+
+		}
+		else
+		{
+			break;
+		}
 	}
-	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
+	
+
 	if (anyPacketsLost)
 	{
-		// The window size will decrease everytime we have to retransmit a frame
-		reliabilityLayerMutexes[windowSize_MUTEX].Lock();
-		if (--windowSize < MINIMUM_WINDOW_SIZE)
-			windowSize=MINIMUM_WINDOW_SIZE;
-		reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
-		lossyWindowSize=windowSize;
-		lastWindowIncreaseSizeTime=time; // This will block the window size from increasing immediately
-		// SHOW - windowing
-		//printf("Frame lost.  New window size = %i.  Lossy window size = %i\n", windowSize, lossyWindowSize);
+		// Update packetloss
+		UpdatePacketloss(time);
 	}
 
 	onlySendUnreliable=false;
@@ -1085,18 +1240,27 @@
 	// From highest to lowest priority, fill up the output bitstream from the send lists
 	for (i=0; i < NUMBER_OF_PRIORITIES; i++)
 	{
-		reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+	//	if (i==LOW_PRIORITY && sendQueue[LOW_PRIORITY].size() > 0 && (sendQueue[LOW_PRIORITY].size()%100)==0)
+	//	{
+	//		printf("%i\n", sendQueue[LOW_PRIORITY].size());
+	//	}
+
+		// Not mutexed - may give a wrong value if another thread is inserting something but it's ok
+		// Because we can avoid a slow mutex call a lot of the time
+		if (sendQueue[i].size()==0)
+			continue;
+		reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Lock();
 		while (sendQueue[i].size())
 		{
 			internalPacket = sendQueue[i].pop();
-			reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
+			reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Unlock();
 
 			nextPacketBitLength = GetBitStreamHeaderLength(internalPacket) + internalPacket->dataBitLength;
 
-			if (	output->GetNumberOfBitsUsed() + nextPacketBitLength > maxDataBitSize)
+			if (output->GetNumberOfBitsUsed() + nextPacketBitLength > maxDataBitSize)
 			{
 				// This output won't fit.
-				reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+				reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Lock();
 				sendQueue[i].pushAtHead(internalPacket); // Push this back at the head so it is the next thing to go out
 				break;
 			}
@@ -1107,14 +1271,17 @@
 				isReliable=false;
 
 			// Write to the output bitstream
-			sentPackets++;
-			WriteToBitStreamFromInternalPacket(output, internalPacket);
+//			sentPackets++;
+			statistics.messagesSent[i]++;
+			statistics.messageDataBitsSent[i]+=internalPacket->dataBitLength;
+			statistics.messageTotalBitsSent[i]+=WriteToBitStreamFromInternalPacket(output, internalPacket);
 			if (isReliable)
 			{
 				// Reliable packets are saved to resend later
 				reliableBits+=internalPacket->dataBitLength;
 				internalPacket->nextActionTime = time + lostPacketResendDelay;
-				InsertPacketIntoResendQueue(internalPacket);
+				//printf("Resending at %i\n", internalPacket->nextActionTime);
+				InsertPacketIntoResendQueue(internalPacket, time);
 
 				*reliableDataSent=true;
 			}
@@ -1125,44 +1292,48 @@
 				InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 			}
 
-			reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+			reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Lock();
 		}
 
-		reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
+		reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Unlock();
 
 	}
 
 	// Optimization - if we sent data but didn't send an acknowledgement packet previously then send them now
 	if (acknowledgementPacketsSent==false && output->GetNumberOfBitsUsed()>0)
 	{
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
-		while(output->GetNumberOfBitsUsed() + ACK_BIT_LENGTH < maxDataBitSize && acknowledgementQueue.size() > 0)
+		if (acknowledgementQueue.size() > 0)
 		{
-			internalPacket = acknowledgementQueue.pop();
-			reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+			//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+			while(output->GetNumberOfBitsUsed() + ACK_BIT_LENGTH < maxDataBitSize && acknowledgementQueue.size() > 0)
+			{
+				internalPacket = acknowledgementQueue.pop();
+				//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 
-			// Write the acknowledgement to the output bitstream
-			WriteToBitStreamFromInternalPacket(output, internalPacket);
+				// Write the acknowledgement to the output bitstream
+				WriteToBitStreamFromInternalPacket(output, internalPacket);
 
-			// Delete the acknowledgement
-			InternalPacketPool::Instance()->ReleasePointer(internalPacket);
+				// Delete the acknowledgement
+				InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 
-			reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
-		} 
+				//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+			} 
 
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+			//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+		}
 	}
 
 END_OF_GENERATE_FRAME:
+;
 
-
-	if (output->GetNumberOfBitsUsed()>0)
-	{
+//	if (output->GetNumberOfBitsUsed()>0)
+//	{
 		// Update the throttle with the header
-		bytesSent+=output->GetNumberOfBytesUsed() + UDP_HEADER_SIZE;
-	}
+//		bytesSent+=output->GetNumberOfBytesUsed() + UDP_HEADER_SIZE;
+	//}
 }
 
+
 //-------------------------------------------------------------------------------------------------------
 // This will return true if we should not send at this time
 //-------------------------------------------------------------------------------------------------------
@@ -1170,9 +1341,9 @@
 {
 	int win;
 
-	reliabilityLayerMutexes[windowSize_MUTEX].Lock();
+//	reliabilityLayerMutexes[windowSize_MUTEX].Lock();
 	win = windowSize;
-	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
+//	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
 
 	return (int)resendQueue.size() >=win;
 }
@@ -1180,9 +1351,9 @@
 //-------------------------------------------------------------------------------------------------------
 // We lost a packet
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::UpdatePacketloss(void)
+void ReliabilityLayer::UpdatePacketloss(unsigned long time)
 {
-//	unsigned long time = getTime();
+//	unsigned long time = RakNetGetTime();
 	/*
 	maximumWindowSize = (unsigned int)((double)maximumWindowSize * DECREASE_THROUGHPUT_DELTA);
 	if (maximumWindowSize < MINIMUM_THROUGHPUT)
@@ -1197,7 +1368,18 @@
 
 
 //	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
-	retransmittedPackets++;
+//	retransmittedFrames++;
+
+	// The window size will decrease everytime we have to retransmit a frame
+	//reliabilityLayerMutexes[windowSize_MUTEX].Lock();
+	if (--windowSize < MINIMUM_WINDOW_SIZE)
+		windowSize=MINIMUM_WINDOW_SIZE;
+	//reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
+	lossyWindowSize=windowSize;
+	lastWindowIncreaseSizeTime=time; // This will block the window size from increasing immediately
+	// SHOW - windowing
+//	if (resendQueue.size()>0)
+//		printf("Frame lost.  New window size = %i.  Lossy window size = %i. Time=%i. Next send time=%i\n", windowSize, lossyWindowSize, RakNetGetTime(),resendQueue.peek()->nextActionTime);
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1207,46 +1389,52 @@
 {
 	InternalPacket *internalPacket;
 	PacketReliability reliability; // What type of reliability algorithm to use with this packet
-	unsigned char orderingStream; // What ordering stream this packet is on, if the reliability type uses ordering streams
-	unsigned char orderingIndex; // The ID used as identification for ordering streams
+	unsigned char orderingChannel; // What ordering channel this packet is on, if the reliability type uses ordering channels
+	unsigned char orderingIndex; // The ID used as identification for ordering channels
 
-	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+//	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 
 	for (unsigned i=0; i < resendQueue.size(); i ++)
 	{
 		if (resendQueue[i] && packetNumber==resendQueue[i]->packetNumber)
 		{
+			// Found what we wanted to ack
+			statistics.acknowlegementsReceived++;
+
 			if (i==0)
 				internalPacket=resendQueue.pop();
 			else
 			{
+				
 				// Generate a hole
 				internalPacket = resendQueue[i];
+				// testing
+			//	printf("Removing packet %i from resend\n", internalPacket->packetNumber);
 				resendQueue[i]=0;
 			}
 
-			reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
 			// Save some of the data of the packet
 			reliability=internalPacket->reliability;
-			orderingStream=internalPacket->orderingStream;
+			orderingChannel=internalPacket->orderingChannel;
 			orderingIndex=internalPacket->orderingIndex;
 
 			// Delete the packet
 			delete [] internalPacket->data;
 			InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 
-			// If the deleted packet was reliable sequenced, also delete all older reliable sequenced resends on the same ordering stream.
+			// If the deleted packet was reliable sequenced, also delete all older reliable sequenced resends on the same ordering channel.
 			// This is because we no longer need to send these.
 			if (reliability==RELIABLE_SEQUENCED)
 			{
 				unsigned j=0;
 
-				reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 				while (j < resendQueue.size())
 				{
 					internalPacket = resendQueue[j];
-					if (internalPacket && internalPacket->reliability==RELIABLE_SEQUENCED && internalPacket->orderingStream==orderingStream && IsOlderOrderedPacket(internalPacket->orderingIndex, orderingIndex))
+					if (internalPacket && internalPacket->reliability==RELIABLE_SEQUENCED && internalPacket->orderingChannel==orderingChannel && IsOlderOrderedPacket(internalPacket->orderingIndex, orderingIndex))
 					{
 						// Delete the packet
 						delete [] internalPacket->data;
@@ -1256,21 +1444,24 @@
 
 					j++;
 				}
-				reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+//				reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 			}
 
-			reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-			break;
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+			return;
 		}
 	}
 
-	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+
+	// Didn't find what we wanted to ack
+	statistics.duplicateAcknowlegementsReceived++;
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Acknowledge receipt of the packet with the specified packetNumber
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::SendAcknowledgementPacket(PacketNumberType packetNumber)
+void ReliabilityLayer::SendAcknowledgementPacket(PacketNumberType packetNumber, unsigned long time)
 {
 	InternalPacket *internalPacket;
 
@@ -1303,16 +1494,16 @@
 	internalPacket->packetNumber=packetNumber;
 	internalPacket->isAcknowledgement=true;
 
-	internalPacket->creationTime = getTime();
+	internalPacket->creationTime = time;
 	// We send this acknowledgement no later than 1/4 the time the remote 
 	//machine would send the original packet again
 	// DEBUG
-	internalPacket->nextActionTime = internalPacket->creationTime + lostPacketResendDelay/4;
+	internalPacket->nextActionTime = internalPacket->creationTime + (lostPacketResendDelay>>2);
 	//internalPacket->nextActionTime = internalPacket->creationTime;
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
 	acknowledgementQueue.push(internalPacket);
-//	printf("<Server>Adding ack at time %i. acknowledgementQueue.size=%i\n",getTime(), acknowledgementQueue.size());
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+//	printf("<Server>Adding ack at time %i. acknowledgementQueue.size=%i\n",RakNetGetTime(), acknowledgementQueue.size());
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1338,11 +1529,11 @@
 	//bitStream->WriteBits((unsigned char*)&(internalPacket->reliability), 3, true);
 	bitLength+=3;
 
-	// If the reliability requires an ordering stream and ordering index, we Write those.
+	// If the reliability requires an ordering channel and ordering index, we Write those.
 	if (internalPacket->reliability==UNRELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED)
 	{
-		// ordering stream encoded in 5 bits (from 0 to 31)
-		//bitStream->WriteBits((unsigned char*)&(internalPacket->orderingStream), 5, true);
+		// ordering channel encoded in 5 bits (from 0 to 31)
+		//bitStream->WriteBits((unsigned char*)&(internalPacket->orderingChannel), 5, true);
 		// -- bitLength+=5;
 
 		// ordering index is one byte
@@ -1381,14 +1572,22 @@
 //-------------------------------------------------------------------------------------------------------
 // Parse an internalPacket and create a bitstream to represent this data
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::WriteToBitStreamFromInternalPacket(BitStream *bitStream, const InternalPacket *const internalPacket)
+int ReliabilityLayer::WriteToBitStreamFromInternalPacket(RakNet::BitStream *bitStream, const InternalPacket *const internalPacket)
 {
 	#ifdef _DEBUG
 	assert(bitStream && internalPacket);
 	#endif
 
-	bitStream->AlignWriteToByteBoundary();
+	int start=bitStream->GetNumberOfBitsUsed();
 
+// testing
+//	if (internalPacket->reliability==UNRELIABLE)
+//		printf("Sending unreliable packet %i\n", internalPacket->packetNumber);
+//	else if (internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED || internalPacket->reliability==RELIABLE)
+//		printf("Sending reliable packet number %i\n", internalPacket->packetNumber);
+
+	//bitStream->AlignWriteToByteBoundary();
+
 	// Write the packet number (2 bytes)
 	bitStream->Write(internalPacket->packetNumber);
 
@@ -1396,7 +1595,9 @@
 	bitStream->Write(internalPacket->isAcknowledgement);
 	// Acknowledgement packets have no more data than the packetnumber and whether it is an acknowledgement
 	if (internalPacket->isAcknowledgement)
-		return;
+	{
+		return bitStream->GetNumberOfBitsUsed()-start;
+	}
 
 	#ifdef _DEBUG
 	assert(internalPacket->dataBitLength>0);
@@ -1406,11 +1607,11 @@
 	unsigned char reliability = (unsigned char)internalPacket->reliability;
 	bitStream->WriteBits((unsigned char*)(&(reliability)), 3, true);
 
-	// If the reliability requires an ordering stream and ordering index, we Write those.
+	// If the reliability requires an ordering channel and ordering index, we Write those.
 	if (internalPacket->reliability==UNRELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED)
 	{
-		// ordering stream encoded in 5 bits (from 0 to 31)
-		bitStream->WriteBits((unsigned char*)&(internalPacket->orderingStream), 5, true);
+		// ordering channel encoded in 5 bits (from 0 to 31)
+		bitStream->WriteBits((unsigned char*)&(internalPacket->orderingChannel), 5, true);
 
 		// ordering index is one byte
 		bitStream->Write(internalPacket->orderingIndex);
@@ -1433,30 +1634,35 @@
 	#endif
 	unsigned short length = (unsigned short) internalPacket->dataBitLength; // Ignore the 2 high bytes for WriteBits
 
-	bitStream->Write(length);
+	bitStream->WriteCompressed(length);
 
 	// Write the actual data.
 	bitStream->WriteAlignedBytes((unsigned char*)internalPacket->data, BITS_TO_BYTES(internalPacket->dataBitLength));
+	//bitStream->WriteBits((unsigned char*)internalPacket->data, internalPacket->dataBitLength);
+
+	return bitStream->GetNumberOfBitsUsed()-start;
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Parse a bitstream and create an internal packet to represent this data
 //-------------------------------------------------------------------------------------------------------
-InternalPacket* ReliabilityLayer::CreateInternalPacketFromBitStream(BitStream *bitStream)
+InternalPacket* ReliabilityLayer::CreateInternalPacketFromBitStream(RakNet::BitStream *bitStream, unsigned long time)
 {
-	if (bitStream->GetNumberOfUnreadBits() < 8)
+	bool bitStreamSucceeded;
+	InternalPacket* internalPacket;
+
+	if (bitStream->GetNumberOfUnreadBits() < sizeof(internalPacket->packetNumber)*8)
 		return 0; // leftover bits
-
-	bool bitStreamSucceeded;
-	InternalPacket* internalPacket = InternalPacketPool::Instance()->GetPointer();
+	
+	internalPacket = InternalPacketPool::Instance()->GetPointer();
 #ifdef _DEBUG
 	// Remove boundschecker accessing undefined memory error
 	memset(internalPacket, 255, sizeof(InternalPacket));
 #endif
 
-	internalPacket->creationTime=getTime();
+	internalPacket->creationTime=time;
 
-	bitStream->AlignReadToByteBoundary();
+	//bitStream->AlignReadToByteBoundary();
 
 	// Read the packet number (2 bytes)
 	bitStreamSucceeded = bitStream->Read(internalPacket->packetNumber);
@@ -1484,11 +1690,11 @@
 #endif
 	if (bitStreamSucceeded==false) {InternalPacketPool::Instance()->ReleasePointer(internalPacket); return 0;}
 
-	// If the reliability requires an ordering stream and ordering index, we read those.
+	// If the reliability requires an ordering channel and ordering index, we read those.
 	if (internalPacket->reliability==UNRELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED)
 	{
-		// ordering stream encoded in 5 bits (from 0 to 31)
-		bitStreamSucceeded = bitStream->ReadBits((unsigned char*)&(internalPacket->orderingStream), 5);
+		// ordering channel encoded in 5 bits (from 0 to 31)
+		bitStreamSucceeded = bitStream->ReadBits((unsigned char*)&(internalPacket->orderingChannel), 5);
 #ifdef _DEBUG
 		assert(bitStreamSucceeded);
 #endif
@@ -1511,7 +1717,7 @@
 	if (bitStreamSucceeded==false) {InternalPacketPool::Instance()->ReleasePointer(internalPacket); return 0;}
 	if (isSplitPacket)
 	{
-		// split packet indices are one byte (so one packet can be split up to 65535 times - maximum packet size would be about 500 * 65535)
+		// split packet indices are one byte (so one packet can be split ufp to 65535 times - maximum packet size would be about 500 * 65535)
 		bitStreamSucceeded = bitStream->Read(internalPacket->splitPacketId);
 #ifdef _DEBUG
 		assert(bitStreamSucceeded);
@@ -1538,7 +1744,7 @@
 
 	
 	unsigned short length;
-	bitStreamSucceeded = bitStream->Read(length);
+	bitStreamSucceeded = bitStream->ReadCompressed(length);
 	// Read into an unsigned short.  Otherwise the data would be offset too high by two bytes
 #ifdef _DEBUG
 	assert(bitStreamSucceeded);
@@ -1556,6 +1762,7 @@
 	internalPacket->data[BITS_TO_BYTES(internalPacket->dataBitLength)-1]=0;
 	// Read the data the packet holds
 	bitStreamSucceeded = bitStream->ReadAlignedBytes((unsigned char*)internalPacket->data, BITS_TO_BYTES(internalPacket->dataBitLength));
+	//bitStreamSucceeded = bitStream->ReadBits((unsigned char*)internalPacket->data, internalPacket->dataBitLength);
 	#ifdef _DEBUG
 	assert(bitStreamSucceeded);	if (bitStreamSucceeded==false) {delete [] internalPacket->data; InternalPacketPool::Instance()->ReleasePointer(internalPacket); return 0;}
 	#endif
@@ -1601,14 +1808,14 @@
 // Search the specified list for sequenced packets on the specified ordering 
 // stream, optionally skipping those with splitPacketId, and delete them
 //-------------------------------------------------------------------------------------------------------
-void  ReliabilityLayer::DeleteSequencedPacketsInList(unsigned char orderingStream, BasicDataStructures::List<InternalPacket*>&theList, int splitPacketId)
+void  ReliabilityLayer::DeleteSequencedPacketsInList(unsigned char orderingChannel, BasicDataStructures::List<InternalPacket*>&theList, int splitPacketId)
 {
 	unsigned i=0;
 
 	while (i < theList.size())
 	{
 		if ((theList[i]->reliability==RELIABLE_SEQUENCED || theList[i]->reliability==UNRELIABLE_SEQUENCED) &&
-			theList[i]->orderingStream==orderingStream && (splitPacketId==-1 || theList[i]->splitPacketId!=splitPacketId))
+			theList[i]->orderingChannel==orderingChannel && (splitPacketId==-1 || theList[i]->splitPacketId!=splitPacketId))
 		{
 			InternalPacket *internalPacket = theList[i];
 			theList.del(i);
@@ -1624,7 +1831,7 @@
 // Search the specified list for sequenced packets with a value less than orderingIndex and delete them
 // Note - I added functionality so you can use the Queue as a list (in this case for searching) but it is less efficient to do so than a regular list
 //-------------------------------------------------------------------------------------------------------
-void  ReliabilityLayer::DeleteSequencedPacketsInList(unsigned char orderingStream, BasicDataStructures::Queue<InternalPacket*>&theList)
+void  ReliabilityLayer::DeleteSequencedPacketsInList(unsigned char orderingChannel, BasicDataStructures::Queue<InternalPacket*>&theList)
 {
 	InternalPacket *internalPacket;
 	int listSize=theList.size();
@@ -1632,7 +1839,7 @@
 
 	while (i < listSize)
 	{
-		if ((theList[i]->reliability==RELIABLE_SEQUENCED || theList[i]->reliability==UNRELIABLE_SEQUENCED) &&	theList[i]->orderingStream==orderingStream)
+		if ((theList[i]->reliability==RELIABLE_SEQUENCED || theList[i]->reliability==UNRELIABLE_SEQUENCED) &&	theList[i]->orderingChannel==orderingChannel)
 		{
 			internalPacket = theList[i];
 			theList.del(i);
@@ -1674,7 +1881,7 @@
 // Split the passed packet into chunks under MTU_SIZEbytes (including headers) and save those new chunks
 // Optimized version
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::SplitPacketAndDeleteOriginal(InternalPacket *internalPacket, int MTUSize)
+void ReliabilityLayer::SplitPacketAndDeleteOriginal(InternalPacket *internalPacket, int MTUSize, unsigned long time)
 {
 	// Doing all sizes in bytes in this function so I don't write partial bytes with split packets
 	internalPacket->splitPacketCount=1; // This causes GetBitStreamHeaderLength to account for the split packet header
@@ -1690,7 +1897,6 @@
 	if (encryptor.IsKeySet())
 		maxDataSize-=16; // Extra data for the encryptor
 
-
 	#ifdef _DEBUG
 	// Make sure we need to split the packet to begin with
 	assert(dataByteLength > maxDataSize - headerLength);
@@ -1705,8 +1911,11 @@
 	// Calculate how many packets we need to create
 	internalPacket->splitPacketCount = (unsigned short)((dataByteLength-1) / (maximumSendBlock) + 1);
 
+	statistics.totalSplits+=internalPacket->splitPacketCount;
+
 	// Optimization
-	internalPacketArray = new InternalPacket*[internalPacket->splitPacketCount];
+	// internalPacketArray = new InternalPacket*[internalPacket->splitPacketCount];
+	internalPacketArray = (InternalPacket**)alloca(sizeof(InternalPacket*)*internalPacket->splitPacketCount);
 	for (i=0; i < (int)internalPacket->splitPacketCount; i++)
 	{
 		internalPacketArray[i]=InternalPacketPool::Instance()->GetPointer();
@@ -1739,11 +1948,7 @@
 		{
 			// For every further packet we use a new packetNumber.
 			// Note that all split packets are reliable
-			reliabilityLayerMutexes[packetNumber_MUTEX].Lock();
-			internalPacketArray[splitPacketIndex]->packetNumber=packetNumber;
-			if (++packetNumber==RECEIVED_PACKET_LOG_LENGTH)
-				packetNumber=0;
-			reliabilityLayerMutexes[packetNumber_MUTEX].Unlock();
+			IncrementPacketNumber(time);
 		}
 
 		// Add the new packet to send list at the correct priority
@@ -1759,16 +1964,16 @@
 	splitPacketId++; // It's ok if this wraps to 0
 
 	// Copy all the new packets into the split packet list
-	reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+	reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+internalPacket->priority].Lock();
 	for (i=0; i < (int)internalPacket->splitPacketCount; i++)
 		sendQueue[internalPacket->priority].push(internalPacketArray[i]);
-	reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
+	reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+internalPacket->priority].Unlock();
 
 	// Delete the original
 	delete [] internalPacket->data;
 	InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 
-	delete [] internalPacketArray;
+	//delete [] internalPacketArray;
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1776,9 +1981,9 @@
 //-------------------------------------------------------------------------------------------------------
 void ReliabilityLayer::InsertIntoSplitPacketList(InternalPacket * internalPacket)
 {
-	reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 	splitPacketList.insert(internalPacket);
-	reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1786,7 +1991,7 @@
 //reconstruct a packet.  If we can, allocate and return it.  Otherwise return 0
 // Optimized version
 //-------------------------------------------------------------------------------------------------------
-InternalPacket * ReliabilityLayer::BuildPacketFromSplitPacketList(unsigned long splitPacketId)
+InternalPacket * ReliabilityLayer::BuildPacketFromSplitPacketList(unsigned long splitPacketId,unsigned long time)
 {
 	int i,j,size;
 	// How much data all blocks but the last hold
@@ -1796,7 +2001,7 @@
 	int *indexList;
 	int indexListIndex;
 
-	reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 	size = splitPacketList.size();
 
 	for (i=0; i < size; i++)
@@ -1806,19 +2011,21 @@
 			// Is there enough elements in the list to have all the parts?
 			if (splitPacketList[i]->splitPacketCount > splitPacketList.size() - i)
 			{
-				if (splitPacketList.size() % 100 == 0)
-					printf("%i\n", splitPacketList.size());
-				reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+	//			if (splitPacketList.size() % 100 == 0 || splitPacketList[i]->splitPacketCount-splitPacketList.size()<100)
+	//				printf("%i out of %i\n", splitPacketList.size(), splitPacketList[i]->splitPacketCount);
+				//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 				return 0;
 			}
 
+	//		printf("%i out of %i\n", splitPacketList.size(), splitPacketList[i]->splitPacketCount);
 			// Keep track of the indices of the elements through our first scan so we don't have to rescan to find them
 			indexListIndex=0;
 
 			numParts=1;
 			bitlength=splitPacketList[i]->dataBitLength;
 
-			indexList = new int[splitPacketList[i]->splitPacketCount];
+			// indexList = new int[splitPacketList[i]->splitPacketCount];
+			indexList = (int*) alloca(sizeof(int)*splitPacketList[i]->splitPacketCount);
 			indexList[indexListIndex++]=i;
 
 			maxDataSize=BITS_TO_BYTES(splitPacketList[i]->dataBitLength);
@@ -1838,7 +2045,7 @@
 			if (numParts==splitPacketList[i]->splitPacketCount)
 			{
 				// All the parts are here
-				InternalPacket *internalPacket=CreateInternalPacketCopy(splitPacketList[i],0,0);
+				InternalPacket *internalPacket=CreateInternalPacketCopy(splitPacketList[i],0,0,time);
 				internalPacket->data=new char[BITS_TO_BYTES(bitlength)];
 #ifdef _DEBUG
 				internalPacket->splitPacketCount = splitPacketList[i]->splitPacketCount;
@@ -1898,28 +2105,74 @@
 					else
 						j++;
 
-				reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+				//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 
-				delete [] indexList;
+			//	delete [] indexList;
 
 				return internalPacket;
 			}
 
-			delete [] indexList;
+		//	delete [] indexList;
 			break;
 		}
 	}
 
-	reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 
 	return 0;
 }
 
+// Delete any unreliable split packets that have long since expired
+void ReliabilityLayer::DeleteOldUnreliableSplitPackets(unsigned long time)
+{
+	unsigned size,i,orderingIndexToDelete;
+	unsigned long newestUnreliableSplitPacket;
+	bool found;
+	InternalPacket *temp;
+
+	// Scan through the list for split packets that were sent unreliably.
+	// If the newest unreliable split packet for a particular ID is more than 3000 ms old, then
+	// delete all of them of that id
+
+	size = splitPacketList.size();
+	newestUnreliableSplitPacket=0L;
+	found=false;
+
+	for (i=0; i < size; i++)
+	{
+		if ((splitPacketList[i]->reliability==UNRELIABLE || splitPacketList[i]->reliability==UNRELIABLE_SEQUENCED) &&
+			splitPacketList[i]->creationTime >= newestUnreliableSplitPacket)
+		{
+			orderingIndexToDelete=splitPacketList[i]->orderingIndex;
+			newestUnreliableSplitPacket=splitPacketList[i]->creationTime;
+			found=true;
+		}
+	}
+
+	if (found && time-newestUnreliableSplitPacket > 5000)
+	{
+		// Delete all split packets that use orderingIndexToDelete
+		i=0;
+		while (i < splitPacketList.size())
+		{
+			if (splitPacketList[i]->orderingIndex==orderingIndexToDelete)
+			{
+				temp=splitPacketList[i];
+				splitPacketList[i]=splitPacketList[splitPacketList.size()-1];
+				splitPacketList.del(); // Removes the last element
+				InternalPacketPool::Instance()->ReleasePointer(temp);
+			}
+			else
+				i++;
+		}
+	}
+}
+
 //-------------------------------------------------------------------------------------------------------
 // Creates a copy of the specified internal packet with data copied from the original starting at dataByteOffset for dataByteLength bytes.
 // Does not copy any split data parameters as that information is always generated does not have any reason to be copied
 //-------------------------------------------------------------------------------------------------------
-InternalPacket * ReliabilityLayer::CreateInternalPacketCopy(InternalPacket *original, int dataByteOffset, int dataByteLength)
+InternalPacket * ReliabilityLayer::CreateInternalPacketCopy(InternalPacket *original, int dataByteOffset, int dataByteLength, unsigned long time)
 {
 	InternalPacket *copy = InternalPacketPool::Instance()->GetPointer();
 #ifdef _DEBUG
@@ -1936,11 +2189,11 @@
 		copy->data=0;
 
 	copy->dataBitLength=dataByteLength<<3;
-	copy->creationTime = getTime();
+	copy->creationTime = time;
 	copy->isAcknowledgement=original->isAcknowledgement;
 	copy->nextActionTime=0;
 	copy->orderingIndex=original->orderingIndex;
-	copy->orderingStream=original->orderingStream;
+	copy->orderingChannel=original->orderingChannel;
 	copy->packetNumber=original->packetNumber;
 	copy->priority=original->priority;
 	copy->reliability=original->reliability;
@@ -1952,12 +2205,12 @@
 // Get the specified ordering list
 // LOCK THIS WHOLE BLOCK WITH reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
 //-------------------------------------------------------------------------------------------------------
-BasicDataStructures::LinkedList<InternalPacket*> *ReliabilityLayer::GetOrderingListAtOrderingStream(unsigned char orderingStream)
+BasicDataStructures::LinkedList<InternalPacket*> *ReliabilityLayer::GetOrderingListAtOrderingStream(unsigned char orderingChannel)
 {
-	if (orderingStream >= orderingList.size())
+	if (orderingChannel >= orderingList.size())
 		return 0;
 
-	return orderingList[orderingStream];
+	return orderingList[orderingChannel];
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1966,37 +2219,37 @@
 void ReliabilityLayer::AddToOrderingList(InternalPacket * internalPacket)
 {
 	#ifdef _DEBUG
-	assert(internalPacket->orderingStream< NUMBER_OF_ORDERED_STREAMS);
+	assert(internalPacket->orderingChannel< NUMBER_OF_ORDERED_STREAMS);
 	#endif
-	if (internalPacket->orderingStream >= NUMBER_OF_ORDERED_STREAMS)	
+	if (internalPacket->orderingChannel >= NUMBER_OF_ORDERED_STREAMS)	
 		return;
 
-	reliabilityLayerMutexes[orderingList_MUTEX].Lock();
-	if (internalPacket->orderingStream >= orderingList.size() || orderingList[internalPacket->orderingStream]==0)
+	//reliabilityLayerMutexes[orderingList_MUTEX].Lock();
+	if (internalPacket->orderingChannel >= orderingList.size() || orderingList[internalPacket->orderingChannel]==0)
 	{
 		// Need a linked list in this index
-		orderingList.replace(new BasicDataStructures::LinkedList<InternalPacket*>, 0, internalPacket->orderingStream);
-		(orderingList[internalPacket->orderingStream])->add(internalPacket);
-		reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
+		orderingList.replace(new BasicDataStructures::LinkedList<InternalPacket*>, 0, internalPacket->orderingChannel);
+		(orderingList[internalPacket->orderingChannel])->add(internalPacket);
+		//reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
 		return;
 	}
 	else
 	{
 		// Have a linked list in this index
-		if (orderingList[internalPacket->orderingStream]->size()==0)
+		if (orderingList[internalPacket->orderingChannel]->size()==0)
 		{
 			// The linked list is empty
-			(orderingList[internalPacket->orderingStream])->add(internalPacket);
+			(orderingList[internalPacket->orderingChannel])->add(internalPacket);
 		}
 		else
 		{
 			BasicDataStructures::LinkedList<InternalPacket*> *theList;
-			theList = GetOrderingListAtOrderingStream(internalPacket->orderingStream);
+			theList = GetOrderingListAtOrderingStream(internalPacket->orderingChannel);
 			// Add this packet in no particular order
 			theList->beginning();
 			theList->insert(internalPacket);
 		}
-		reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
+		//reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
 	}
 }
 
@@ -2005,17 +2258,16 @@
 // THIS WHOLE FUNCTION SHOULD BE LOCKED WITH
 // reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::InsertPacketIntoResendQueue(InternalPacket *internalPacket)
+void ReliabilityLayer::InsertPacketIntoResendQueue(InternalPacket *internalPacket, unsigned long time)
 {
-	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-
-	reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
+	//reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
 	if (lastAckTime==0 || resendQueue.size()==0)
-		lastAckTime=getTime(); // Start the timer for the ack of this packet if we aren't already waiting for an ack
-	reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
+		lastAckTime=time; // Start the timer for the ack of this packet if we aren't already waiting for an ack
+	//reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
 
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 	resendQueue.push(internalPacket);
-	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -2031,36 +2283,40 @@
 //-------------------------------------------------------------------------------------------------------
 // How long to wait between packet resends
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::SetLostPacketResendDelay(unsigned long i) {if (i > 0) lostPacketResendDelay=i; if (lostPacketResendDelay<1000) lostPacketResendDelay=1000;}
+void ReliabilityLayer::SetLostPacketResendDelay(unsigned long i)
+{
+	if (i > 0) lostPacketResendDelay=i;
+	if (lostPacketResendDelay<150) // To avoid unnecessary packetloss, this value should be UPDATE_THREAD_UPDATE_TIME + UPDATE_THREAD_POLL_TIME at a minimum
+		lostPacketResendDelay=150;
+}
 
 //-------------------------------------------------------------------------------------------------------
 // Statistics
 //-------------------------------------------------------------------------------------------------------
-double ReliabilityLayer::GetPacketlossPercentile(void) const {if 
-(sentPackets>0) return (double)retransmittedPackets / (double)sentPackets; 
-else return 0.0;}
-unsigned long ReliabilityLayer::GetTransmittedPacketCount(void) const 
-{return sentPackets;}
-unsigned long ReliabilityLayer::GetTransmittedFrameCount(void) const 
-{return sentFrames;}
-unsigned long ReliabilityLayer::GetLostPacketCount(void) const {return 
-retransmittedPackets;}
-unsigned long ReliabilityLayer::GetReceivedPacketCount(void) const {return 
-receivedPacketsCount;}
-unsigned long ReliabilityLayer::GetBytesSent(void) const {return bytesSent;}
-unsigned long ReliabilityLayer::GetBytesReceived(void) const {return 
-bytesReceived;}
-unsigned long ReliabilityLayer::GetUnacknowledgedSentPacketListSize(void) 
-{return resendQueue.size();}
-unsigned long ReliabilityLayer::GetPacketOutputBufferSize(void)
+RakNetStatisticsStruct * const ReliabilityLayer::GetStatistics(void)
 {
-	int val=0; 
-	reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
-	for (int count=0; count<NUMBER_OF_PRIORITIES; count++)
-		val+= sendQueue[count].size();
-	reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
-	return val;
+	int i;
+	for (i=0; i < NUMBER_OF_PRIORITIES; i++)
+	{
+		statistics.messageSendBuffer[i]=sendQueue[i].size();
+	}
+
+	statistics.acknowlegementsPending=acknowledgementQueue.size();
+	statistics.messagesWaitingForReassembly=splitPacketList.size();
+	statistics.internalOutputQueueSize=outputQueue.size();
+	statistics.windowSize=windowSize;
+	statistics.lossySize=lossyWindowSize==MAXIMUM_WINDOW_SIZE+1 ? 0 : lossyWindowSize;
+	statistics.messagesOnResendQueue=resendQueue.size();
+
+	return &statistics;
 }
-unsigned long ReliabilityLayer::GetMaximumWindowSize(void) const {return windowSize;}
-unsigned long ReliabilityLayer::GetLastPacketReceivedTime(void) const {return lastPacketReceivedTime;}
 
+//-------------------------------------------------------------------------------------------------------
+// Update the current packet number for sends
+//-------------------------------------------------------------------------------------------------------
+void ReliabilityLayer::IncrementPacketNumber(unsigned long time)
+{
+	reliabilityLayerMutexes[packetNumber_MUTEX].Lock();
+	++packetNumber;
+	reliabilityLayerMutexes[packetNumber_MUTEX].Unlock();
+}
\ No newline at end of file

Modified: branches/multiplayer-branch/source/libraries/raknet/ReliabilityLayer.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/ReliabilityLayer.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/ReliabilityLayer.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -21,23 +21,14 @@
 #include "InternalPacket.h"
 #include "InternalPacketPool.h"
 #include "DataBlockEncryptor.h"
+#include "RakNetStatistics.h"
 
 #define UDP_HEADER_SIZE 28
 #define NUMBER_OF_ORDERED_STREAMS 32 // 2^5
 
-const unsigned long TIMEOUT_TIME = 20000; // If no response to a reliable packet for this long kill the connection
-// -----------------------------------------------------------------------------------------------------------------
-// If you change MAX_AVERAGE_PACKETS_PER_SECOND or TIMEOUT_TIME,
-// you must make sure RECEIVED_PACKET_LOG_LENGTH < the range of PacketNumberType (held in InternalPacket.h)
-// -----------------------------------------------------------------------------------------------------------------
- // *** Pay attention to the value of RECEIVED_PACKET_LOG_LENGTH when changing this! ***
-const int MAX_AVERAGE_PACKETS_PER_SECOND=400;
- 
-// *** This value must be less than the range of PacketNumberType. PacketNumberType is in InternalPacket.h  ***
-const int RECEIVED_PACKET_LOG_LENGTH=(TIMEOUT_TIME/1000)*MAX_AVERAGE_PACKETS_PER_SECOND;
-// -----------------------------------------------------------------------------------------------------------------
+const unsigned long TIMEOUT_TIME = 10000; // If no response to a reliable packet for this long kill the connection
 
-class BitStream;
+#include "BitStream.h"
 
 class ReliabilityLayer
 {
@@ -48,18 +39,23 @@
 	// Destructor
 	~ReliabilityLayer();
 
-	// Resets the layer for reuse
+	// Resets the layer for reuse.
+	// Callable from multiple threads
 	void Reset(void);
 
 	// Sets up encryption
+	// Callable from multiple threads
 	void SetEncryptionKey(const unsigned char *key);
 
 	// Assign a socket for the reliability layer to use for writing
+	// Callable from multiple threads
 	void SetSocket(SOCKET s);
 
 	// Get the socket held by the reliability layer
+	// Callable from multiple threads
 	SOCKET GetSocket(void);
 
+	// Must be called by the same thread as update
 	// Packets are read directly from the socket layer and skip the reliability layer  because unconnected players do not use the reliability layer
 	// This function takes packet data after a player has been confirmed as connected.  The game should not use that data directly
 	// because some data is used internally, such as packet acknowledgement and split packets
@@ -67,17 +63,20 @@
 	bool HandleSocketReceiveFromConnectedPlayer(char *buffer, int length);
 
 	// This gets an end-user packet already parsed out. Returns number of BITS put into the buffer
+	// Callable from multiple threads
 	int Receive(char**data);
 
 	// Puts data on the send queue
 	// bitStream contains the data to send
 	// priority is what priority to send the data at
 	// reliability is what reliability to use
-	// ordering stream is from 0 to 31 and specifies what stream to use
-	bool Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, unsigned char orderingStream, bool makeDataCopy, int MTUSize);
+	// ordering channel is from 0 to 31 and specifies what stream to use
+	// Callable from multiple threads
+	bool Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, unsigned char orderingChannel, bool makeDataCopy, int MTUSize);
 
 	// Run this once per game cycle.  Handles internal lists and actually does the send
-	void Update(SOCKET s, PlayerID playerId, int MTUSize);
+	// Must be called by the same thread as HandleSocketReceiveFromConnectedPlayer
+	void Update(SOCKET s, PlayerID playerId, int MTUSize, unsigned long time);
 
 	// If Read returns -1 and this returns true then a modified packet was detected
 	bool IsCheater(void) const;
@@ -89,44 +88,36 @@
 	void SetLostPacketResendDelay(unsigned long i);
 
 	// Statistics
-	double GetPacketlossPercentile(void) const;
-	unsigned long GetTransmittedPacketCount(void) const;
-	unsigned long GetTransmittedFrameCount(void) const;
-	unsigned long GetLostPacketCount(void) const;
-	unsigned long GetReceivedPacketCount(void) const;
-	unsigned long GetBytesSent(void) const;
-	unsigned long GetBytesReceived(void) const;
-	unsigned long GetUnacknowledgedSentPacketListSize(void);
-	unsigned long GetPacketOutputBufferSize(void);
-	unsigned long GetMaximumWindowSize(void) const;
-	unsigned long GetLastPacketReceivedTime(void) const;
+	RakNetStatisticsStruct * const GetStatistics(void);
+
 private:
 	// Returns true if we can or should send a frame.  False if we should not
-	bool IsFrameReady(void);
+	bool IsFrameReady(unsigned long time);
 
 	// Generates a frame (coalesced packets)
-	void GenerateFrame(BitStream *output, int MTUSize, bool *reliableDataSent);
+	void GenerateFrame(RakNet::BitStream *output, int MTUSize, bool *reliableDataSent,unsigned long time);
 
 	// Writes a bitstream to the socket
-	void SendBitStream(SOCKET s, PlayerID playerId, BitStream *bitStream);
+	void SendBitStream(SOCKET s, PlayerID playerId, RakNet::BitStream *bitStream);
 
 	// Parse an internalPacket and create a bitstream to represent this data
-	void WriteToBitStreamFromInternalPacket(BitStream *bitStream, const InternalPacket *const internalPacket);
+	// Returns number of bits used
+	int WriteToBitStreamFromInternalPacket(RakNet::BitStream *bitStream, const InternalPacket *const internalPacket);
 
 	// Parse a bitstream and create an internal packet to represent this data
-	InternalPacket* CreateInternalPacketFromBitStream(BitStream *bitStream);
+	InternalPacket* CreateInternalPacketFromBitStream(RakNet::BitStream *bitStream, unsigned long time);
 
 	// Does what the function name says
 	void RemovePacketFromResendQueueAndDeleteOlderReliableSequenced(PacketNumberType packetNumber);
 
 	// Acknowledge receipt of the packet with the specified packetNumber
-	void SendAcknowledgementPacket(PacketNumberType packetNumber);
+	void SendAcknowledgementPacket(PacketNumberType packetNumber, unsigned long time);
 
 	// This will return true if we should not send at this time
 	bool IsSendThrottled(void);
 
 	// We lost a packet
-	void UpdatePacketloss(void);
+	void UpdatePacketloss(unsigned long time);
 
 	// Parse an internalPacket and figure out how many header bits would be written.  Returns that number
 	int GetBitStreamHeaderLength(const InternalPacket *const internalPacket);
@@ -137,30 +128,33 @@
 	// Check the SHA1 code
 	bool CheckSHA1(char code[SHA1_LENGTH], unsigned char * const buffer, unsigned long nbytes);
 
-	// Search the specified list for sequenced packets on the specified ordering stream, optionally skipping those with splitPacketId, and delete them
-	void  DeleteSequencedPacketsInList(unsigned char orderingStream, BasicDataStructures::List<InternalPacket*>&theList, int splitPacketId=-1);
+	// Search the specified list for sequenced packets on the specified ordering channel, optionally skipping those with splitPacketId, and delete them
+	void  DeleteSequencedPacketsInList(unsigned char orderingChannel, BasicDataStructures::List<InternalPacket*>&theList, int splitPacketId=-1);
 	// Search the specified list for sequenced packets with a value less than orderingIndex and delete them
-	void DeleteSequencedPacketsInList(unsigned char orderingStream, BasicDataStructures::Queue<InternalPacket*>&theList);
+	void DeleteSequencedPacketsInList(unsigned char orderingChannel, BasicDataStructures::Queue<InternalPacket*>&theList);
 
 	// Returns true if newPacketOrderingIndex is older than the waitingForPacketOrderingIndex
 	bool IsOlderOrderedPacket(unsigned char newPacketOrderingIndex, unsigned char waitingForPacketOrderingIndex);
 
 	// Split the passed packet into chunks under MTU_SIZE bytes (including headers) and save those new chunks
-	void SplitPacketAndDeleteOriginal(InternalPacket *internalPacket, int MTUSize);
+	void SplitPacketAndDeleteOriginal(InternalPacket *internalPacket, int MTUSize, unsigned long time);
 
 	// Insert a packet into the split packet list
 	void InsertIntoSplitPacketList(InternalPacket * internalPacket);
 
 	// Take all split chunks with the specified splitPacketId and try to reconstruct a packet.  If we can, allocate and return it.  Otherwise return 0
-	InternalPacket * BuildPacketFromSplitPacketList(unsigned long splitPacketId);
+	InternalPacket * BuildPacketFromSplitPacketList(unsigned long splitPacketId,unsigned long time);
 
+	// Delete any unreliable split packets that have long since expired
+	void DeleteOldUnreliableSplitPackets(unsigned long time);
+
 	// Creates a copy of the specified internal packet with data copied from the original starting at dataByteOffset for dataByteLength bytes.
 	// Does not copy any split data parameters as that information is always generated does not have any reason to be copied
-	InternalPacket * CreateInternalPacketCopy(InternalPacket *original, int dataByteOffset, int dataByteLength);
+	InternalPacket * CreateInternalPacketCopy(InternalPacket *original, int dataByteOffset, int dataByteLength, unsigned long time);
 
 	// Get the specified ordering list
 	// LOCK THIS WHOLE BLOCK WITH reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
-	BasicDataStructures::LinkedList<InternalPacket*> *GetOrderingListAtOrderingStream(unsigned char orderingStream);
+	BasicDataStructures::LinkedList<InternalPacket*> *GetOrderingListAtOrderingStream(unsigned char orderingChannel);
 
 	// Add the internal packet to the ordering list in order based on order index
 	void AddToOrderingList(InternalPacket * internalPacket);
@@ -168,27 +162,35 @@
 	// Inserts a packet into the resend list in order
 	// THIS WHOLE FUNCTION SHOULD BE LOCKED WITH
 	// reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-	void InsertPacketIntoResendQueue(InternalPacket *internalPacket);
+	void InsertPacketIntoResendQueue(InternalPacket *internalPacket, unsigned long time);
 
-	// Frees all allocated memory
-	void FreeMemory(void);
+	// Memory handling
+	void FreeMemory(bool freeAllImmediately);
+	void FreeThreadedMemory(void);
+	void FreeThreadSafeMemory(void);
 	
 	// Initialize the variables
 	void InitializeVariables(void);
 
+	// Update the current packet number for sends
+	void IncrementPacketNumber(unsigned long time);
+
 	// STUFF TO MUTEX HERE
 	enum
 	{
-		splitPacketList_MUTEX,
-		sendQueue_MUTEX,
-		resendQueue_MUTEX,
-		orderingList_MUTEX,
-		acknowledgementQueue_MUTEX,
-		outputQueue_MUTEX,
+		// splitPacketList_MUTEX, // We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		sendQueueSystemPriority_MUTEX,
+		sendQueueHighPriority_MUTEX,
+		sendQueueMediumPriority_MUTEX,
+		sendQueueLowPriority_MUTEX,
+		//resendQueue_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		//orderingList_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		//acknowledgementQueue_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		// outputQueue_MUTEX,// We don't have to mutex this as long as Recieve and HandleSocketReceiveFromConnectedPlayer are called by the same thread
 		packetNumber_MUTEX,
-		windowSize_MUTEX,
-		lastAckTime_MUTEX,
-		updateBitStream_MUTEX,
+		// windowSize_MUTEX, // Causes long delays for some reason
+		//lastAckTime_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		//updateBitStream_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
 		waitingForOrderedPacketWriteIndex_MUTEX,
 		waitingForSequencedPacketWriteIndex_MUTEX,
 		NUMBER_OF_RELIABILITY_LAYER_MUTEXES
@@ -202,7 +204,7 @@
 	PacketNumberType packetNumber;
 	//unsigned long windowSize;
 	unsigned long lastAckTime;
-	BitStream updateBitStream;
+	RakNet::BitStream updateBitStream;
 	unsigned char waitingForOrderedPacketWriteIndex[NUMBER_OF_ORDERED_STREAMS], waitingForSequencedPacketWriteIndex[NUMBER_OF_ORDERED_STREAMS];
 	// Used for flow control (changed to regular TCP sliding window)
 	//	unsigned long maximumWindowSize, bytesSentSinceAck;
@@ -211,11 +213,13 @@
 	// STUFF TO NOT MUTEX HERE (called from non-conflicting threads, or value is not important)
 	unsigned char waitingForOrderedPacketReadIndex[NUMBER_OF_ORDERED_STREAMS],waitingForSequencedPacketReadIndex[NUMBER_OF_ORDERED_STREAMS];
 	bool deadConnection, cheater;
-	unsigned long lastPacketSendTime,retransmittedPackets, sentPackets, sentFrames, receivedPacketsCount, bytesSent, bytesReceived,lastPacketReceivedTime;
+//	unsigned long lastPacketSendTime,retransmittedFrames, sentPackets, sentFrames, receivedPacketsCount, bytesSent, bytesReceived,lastPacketReceivedTime;
 	unsigned long lostPacketResendDelay;
 	unsigned long splitPacketId;
-	unsigned long receivedPackets[RECEIVED_PACKET_LOG_LENGTH];
+	unsigned long *receivedPackets;
 	unsigned long blockWindowIncreaseUntilTime;
+	RakNetStatisticsStruct statistics;
+	unsigned long lastPacketCounterResetTime;
 
 	// Windowing algorithm:
 	// Start at a minimum size
@@ -231,6 +235,8 @@
 	#ifdef __USE_IO_COMPLETION_PORTS
 	SOCKET readWriteSocket;
 	#endif
+
+	bool freeThreadedMemoryOnNextUpdate; // This variable is so that free memory can be called by only the update thread so we don't have to mutex things so much
 };
 
 #endif

Modified: branches/multiplayer-branch/source/libraries/raknet/SHA1.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/SHA1.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/SHA1.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -21,11 +21,8 @@
 #include <stdio.h> // Needed for file access
 #include <memory.h> // Needed for memset and memcpy
 #include <string.h> // Needed for strcat and strcpy
+#include "Types.h"
 
-#ifdef _WINDOWS
-#define LITTLE_ENDIAN
-#endif
-
 #define MAX_FILE_READ_BUFFER 8000
 #define SHA1_LENGTH 20
 
@@ -33,7 +30,7 @@
 {
 public:
 	// Rotate x bits to the left
-	#define ROL32(value, bits) (((value)<<(bits))|((value)>>(32-(bits))))
+//	#define ROL32(value, bits) (((value)<<(bits))|((value)>>(32-(bits))))
 
 	#ifdef LITTLE_ENDIAN
 		#define SHABLK0(i) (block->l[i] = (ROL32(block->l[i],24) & 0xFF00FF00) \

Modified: branches/multiplayer-branch/source/libraries/raknet/SocketLayer.cpp
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/SocketLayer.cpp	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/SocketLayer.cpp	2004-10-08 21:41:59 UTC (rev 76)
@@ -17,6 +17,7 @@
 #else
 #include <string.h> // memcpy
 #include <unistd.h>
+#include <fcntl.h>
 #endif
 
 #include "ExtendedOverlappedPool.h"
@@ -75,14 +76,14 @@
 	}
 }
 
-SOCKET SocketLayer::Connect(SOCKET writeSocket, PlayerID playerId)
+SOCKET SocketLayer::Connect(SOCKET writeSocket, unsigned long binaryAddress, unsigned short port)
 {
 	assert(writeSocket!=INVALID_SOCKET);
 	sockaddr_in connectSocketAddress;
 
 	connectSocketAddress.sin_family = AF_INET;
-	connectSocketAddress.sin_port = htons(playerId.port);
-	connectSocketAddress.sin_addr.s_addr = playerId.binaryAddress;
+	connectSocketAddress.sin_port = htons(port);
+	connectSocketAddress.sin_addr.s_addr = binaryAddress;
 
 	if (connect(writeSocket, (struct sockaddr *)&connectSocketAddress, sizeof(struct sockaddr)) != 0)
 	{
@@ -147,6 +148,38 @@
 		#endif
 	}
 
+	//Set non-blocking
+#ifdef _WIN32
+	unsigned long nonblocking = 1;
+	if (ioctlsocket(listenSocket, FIONBIO, &nonblocking)!=0)
+	{
+		assert(0);
+		return INVALID_SOCKET;
+	}
+#else
+	if (fcntl(listenSocket, F_SETFL, O_NONBLOCK)!=0)
+	{
+		assert(0);
+		return INVALID_SOCKET;
+	}
+#endif
+
+	// Set broadcast capable
+	if ( setsockopt(listenSocket, SOL_SOCKET, SO_BROADCAST,(char *)&sock_opt, sizeof(sock_opt)) == -1)
+	{
+#if defined(_WIN32) && defined(_DEBUG)
+		DWORD dwIOError = GetLastError();
+		LPVOID messageBuffer;
+		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 	  FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 
+			NULL, dwIOError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),// Default language
+			(LPTSTR) &messageBuffer, 0, NULL); 
+		// something has gone wrong here... 
+		printf("setsockopt(SO_BROADCAST) failed:Error code - %d\n%s",dwIOError, messageBuffer ); 
+		//Free the buffer. 
+		LocalFree(messageBuffer ); 
+#endif
+	}
+
 	// Listen on our designated Port#
 	listenerSocketAddress.sin_port = htons(port);
 
@@ -209,7 +242,7 @@
 }
 
 // Start an asynchronous read using the specified socket.
-bool SocketLayer::AssociateSocketWithCompletionPortAndRead(SOCKET readSocket, PlayerID playerId, RakPeer *rakPeer)
+bool SocketLayer::AssociateSocketWithCompletionPortAndRead(SOCKET readSocket, unsigned long binaryAddress, unsigned short port, RakPeer *rakPeer)
 {
 	#ifdef __USE_IO_COMPLETION_PORTS
 	assert(readSocket!=INVALID_SOCKET);
@@ -219,7 +252,8 @@
 
 	ExtendedOverlappedStruct* eos = ExtendedOverlappedPool::Instance()->GetPointer();
 	memset(&(eos->overlapped), 0, sizeof(OVERLAPPED));
-	eos->playerId=playerId;
+	eos->binaryAddress=binaryAddress;
+	eos->port=port;
 	eos->rakPeer=rakPeer;
 	eos->length=MAXIMUM_MTU_SIZE;
 
@@ -239,13 +273,8 @@
 	return true;
 }
 
-int SocketLayer::RecvFrom(SOCKET s, RakPeer *rakPeer)
+bool SocketLayer::RecvFrom(SOCKET s, RakPeer *rakPeer, int *errorCode)
 {
-	if (s==INVALID_SOCKET)
-	{
-		return SOCKET_ERROR;
-	}
-
 	int len;
 	char data[MAXIMUM_MTU_SIZE];
 	sockaddr_in sa;
@@ -260,6 +289,12 @@
 	sa.sin_addr.s_addr=0;
 #endif
 
+	if (s==INVALID_SOCKET)
+	{
+		*errorCode=SOCKET_ERROR;
+		return false;
+	}
+
 	len = recvfrom(s, data, MAXIMUM_MTU_SIZE, 0, (sockaddr*)&sa, (socklen_t*)&len2);
 
 //	if (len>0)
@@ -269,9 +304,10 @@
 	{
 #ifdef _DEBUG
 		printf("Error: recvfrom returned 0 on a connectionless blocking call\non port %i.  This is a bug with Zone Alarm.  Please turn off Zone Alarm.\n",ntohs(sa.sin_port));
-#endif
 		assert(0);
-		return 0;
+#endif		
+		*errorCode=SOCKET_ERROR;
+		return false;
 	}
 
 	if (len!=SOCKET_ERROR)
@@ -282,13 +318,20 @@
 		//	strcpy(ip, "127.0.0.1");
         ProcessNetworkPacket(sa.sin_addr.s_addr, portnum,data, len, rakPeer);
 
-		return 0;
+		return true;
 	}
 	else
 	{
 
-#if defined(_WIN32)
+		*errorCode=0;
+
+#if defined(_WIN32) && defined(_DEBUG)
 		DWORD dwIOError = WSAGetLastError();
+		
+		if (dwIOError == WSAEWOULDBLOCK)
+		{
+			return false;
+		}
 
 		if (dwIOError==WSAECONNRESET)
 		{
@@ -296,7 +339,8 @@
 			printf("A previous send operation resulted in an ICMP Port Unreachable message.\n");
 			#endif
 
-			return dwIOError;
+			*errorCode=dwIOError;
+			return false;
 		}
 		else
 		{
@@ -319,10 +363,10 @@
 #endif
 	}
 
-	return 0;
+	return false;
 }
 
-int SocketLayer::SendTo(SOCKET s, char *data, int length, PlayerID playerId)
+int SocketLayer::SendTo(SOCKET s, char *data, int length, unsigned long binaryAddress, unsigned short port)
 {
 	if (s==INVALID_SOCKET)
 	{
@@ -331,8 +375,8 @@
 
 	int len;
 	sockaddr_in sa;
-	sa.sin_port = htons(playerId.port);
-	sa.sin_addr.s_addr = playerId.binaryAddress;
+	sa.sin_port = htons(port);
+	sa.sin_addr.s_addr = binaryAddress;
 	sa.sin_family = AF_INET;
 	do {
 		len = sendto(s, data, length, 0, (const sockaddr*)&sa, sizeof(struct sockaddr_in));
@@ -374,10 +418,9 @@
 
 int SocketLayer::SendTo(SOCKET s, char *data, int length, char ip[16], unsigned short port)
 {
-	PlayerID temp;
-	temp.binaryAddress=inet_addr(ip);
-	temp.port=port;
-	return SendTo(s,data,length,temp);
+	unsigned long binaryAddress;
+	binaryAddress=inet_addr(ip);
+	return SendTo(s,data,length,binaryAddress,port);
 }
 
 void SocketLayer::GetMyIP(char ipList[10][16])

Modified: branches/multiplayer-branch/source/libraries/raknet/SocketLayer.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/SocketLayer.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/SocketLayer.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -37,21 +37,20 @@
 	SocketLayer();
 	~SocketLayer();
 	static inline SocketLayer* Instance() {return &I;}
-	SOCKET Connect(SOCKET writeSocket, PlayerID playerId);
+	SOCKET Connect(SOCKET writeSocket, unsigned long binaryAddress, unsigned short port);
 	SOCKET CreateBoundSocket(unsigned short port, bool blockingSocket); // Creates a socket to listen for incoming connections on the specified port
 	const char* DomainNameToIP(const char *domainName);
 	#ifdef __USE_IO_COMPLETION_PORTS
 	void AssociateSocketWithCompletionPort(SOCKET socket, ClientContextStruct* completionKey);
 #endif
 	// Start an asynchronous read using the specified socket.  The callback will use the specified PlayerID (associated with this socket) and call either the client or the server callback (one or the other should be 0)
-	bool AssociateSocketWithCompletionPortAndRead(SOCKET readSocket, PlayerID playerId, RakPeer* rakPeer);
+	bool AssociateSocketWithCompletionPortAndRead(SOCKET readSocket, unsigned long binaryAddress, unsigned short port, RakPeer* rakPeer);
 	void Write(SOCKET writeSocket, const char* data, int length);
-	// Given a listen socket and an event object triggered when a new connection occurs, return the new socket of the new connection along with the IP and port of the caller
-	// Returns the error code on failure, 0 on success
-	int RecvFrom(SOCKET s, RakPeer *rakPeer);
+	// Returns true if you successfully read data
+	bool RecvFrom(SOCKET s, RakPeer *rakPeer, int *errorCode);
 	void GetMyIP(char ipList[10][16]);
 	int SendTo(SOCKET s, char *data, int length, char ip[16], unsigned short port);
-	int SendTo(SOCKET s, char *data, int length, PlayerID playerId);
+	int SendTo(SOCKET s, char *data, int length, unsigned long binaryAddress, unsigned short port);
 	
 	private:
 	static bool socketLayerStarted;

Modified: branches/multiplayer-branch/source/libraries/raknet/StringCompressor.cpp
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/StringCompressor.cpp	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/StringCompressor.cpp	2004-10-08 21:41:59 UTC (rev 76)
@@ -3,10 +3,12 @@
 #include "BitStream.h"
 #include <assert.h>
 #include <string.h>
+#include <memory.h>
 
 StringCompressor StringCompressor::instance;
 
-unsigned long englishCharacterFrequencies[] =
+// Generated from various chat logs on the internet.
+unsigned long englishCharacterFrequencies[256] =
 {
 0,
 0,
@@ -18,9 +20,10 @@
 0,
 0,
 0,
-5655,
+722,
 0,
 0,
+2,
 0,
 0,
 0,
@@ -39,101 +42,101 @@
 0,
 0,
 0,
+11084,
+58,
+63,
+1,
 0,
-64995,
-2,
-515,
-3,
-3,
-5,
-13,
-125,
-289,
-294,
+31,
 0,
+317,
+64,
+64,
+44,
 0,
-1968,
-558,
-4849,
-91,
-244,
-795,
-459,
-323,
-379,
-210,
-155,
-138,
-280,
-590,
-150,
-46,
-4,
-3,
-4,
+695,
+62,
+980,
+266,
 69,
-28,
-595,
-161,
-950,
-364,
-430,
-326,
-221,
-308,
-712,
-189,
+67,
 56,
-181,
-318,
-426,
-256,
-676,
+7,
+73,
+3,
 14,
-458,
-1247,
-853,
-253,
-105,
-297,
-53,
-81,
 2,
-235,
-0,
-235,
-0,
+69,
+1,
+167,
+9,
+1,
 2,
+25,
+94,
 0,
-11400,
-2156,
-6665,
-5543,
-19692,
-3186,
-2759,
-5614,
-12742,
+195,
+139,
+34,
+96,
+48,
+103,
+56,
+125,
+653,
+21,
+5,
+23,
+64,
+85,
+44,
+34,
+7,
+92,
+76,
+147,
+12,
+14,
 57,
-1191,
-6009,
-4271,
-11288,
-13376,
-3619,
-106,
-10492,
-12069,
-14885,
-5462,
-1664,
-1850,
-265,
-3591,
-169,
+15,
+39,
+15,
+1,
+1,
+1,
+2,
+3,
 0,
+3611,
+845,
+1077,
+1884,
+5870,
+841,
+1057,
+2501,
+3212,
+164,
+531,
+2019,
+1330,
+3056,
+4037,
+848,
+47,
+2586,
+2919,
+4771,
+1707,
+535,
+1106,
+152,
+1243,
+100,
 0,
+2,
 0,
+10,
 0,
 0,
 0,
@@ -262,12 +265,12 @@
 0,
 0,
 0,
-0,
 0
 };
 
 StringCompressor::StringCompressor()
 {
+	huffmanEncodingTree=0;
 }
 
 void StringCompressor::GenerateHuffmanEncodingTree(void)
@@ -275,18 +278,41 @@
 	huffmanEncodingTree = new HuffmanEncodingTree;
 	huffmanEncodingTree->GenerateFromFrequencyTable(englishCharacterFrequencies);
 }
+void StringCompressor::GenerateTreeFromStrings(unsigned char *input, unsigned inputLength)
+{
+	unsigned index;
+	unsigned long frequencyTable[256];
+
+	if (inputLength==0)
+		return;
+
+	// Zero out the frequency table
+	memset(frequencyTable, 0, sizeof(frequencyTable));
+
+	// Generate the frequency table from the strings
+	for (index=0; index < inputLength; index++);
+		frequencyTable[input[index]]++;
+
+	// Delete the old tree, if there is done
+	if (huffmanEncodingTree)
+		delete huffmanEncodingTree;
+
+	// Build the tree
+	huffmanEncodingTree = new HuffmanEncodingTree;
+	huffmanEncodingTree->GenerateFromFrequencyTable(frequencyTable);
+}
 StringCompressor::~StringCompressor()
 {
 	if (huffmanEncodingTree)
 		delete huffmanEncodingTree;
 }
 
-void StringCompressor::EncodeString(char *input, int maxCharsToWrite, BitStream *output)
+void StringCompressor::EncodeString(char *input, int maxCharsToWrite, RakNet::BitStream *output)
 {
 	if (input==0)
 		return;
 
-	BitStream encodedBitStream;
+	RakNet::BitStream encodedBitStream;
 	unsigned short stringBitLength;
 	int charsToWrite;
 
@@ -300,12 +326,12 @@
 
 	huffmanEncodingTree->EncodeArray((unsigned char*) input, charsToWrite, &encodedBitStream);
 
-	stringBitLength = encodedBitStream.GetNumberOfBitsUsed();
+	stringBitLength = (unsigned short)encodedBitStream.GetNumberOfBitsUsed();
 	output->WriteCompressed(stringBitLength);
 	output->WriteBits(encodedBitStream.GetData(), stringBitLength);
 }
 
-void StringCompressor::DecodeString(char *output, int maxCharsToWrite, BitStream *input)
+bool StringCompressor::DecodeString(char *output, int maxCharsToWrite, RakNet::BitStream *input)
 {
 	unsigned short stringBitLength;
 	int bytesInStream;
@@ -315,14 +341,18 @@
 
 	output[0]=0;
 
-	
 	if (input->ReadCompressed(stringBitLength)==false)
-		return;
+		return false;
 
+	if (input->GetNumberOfUnreadBits() < stringBitLength)
+		return false;
+
 	bytesInStream=huffmanEncodingTree->DecodeArray(input, stringBitLength, maxCharsToWrite, (unsigned char*) output);
 	if (bytesInStream < maxCharsToWrite)
 		output[bytesInStream]=0;
 	else
 		output[maxCharsToWrite-1]=0;
+
+	return true;
 }
 

Modified: branches/multiplayer-branch/source/libraries/raknet/StringCompressor.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/StringCompressor.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/StringCompressor.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -3,8 +3,8 @@
 #ifndef __STRING_COMPRESSOR_H
 #define __STRING_COMPRESSOR_H
 
+#include "BitStream.h"
 class HuffmanEncodingTree;
-class BitStream;
 
 class StringCompressor
 {
@@ -14,12 +14,17 @@
 	// static function because only static functions can access static members
 	static inline StringCompressor* Instance() {return &instance;}
 
+	// Given an array of strings, such as a chat log, generate the optimal encoding tree for it.
+	// This function is optional and if it is not called a default tree will be used instead.
+	void GenerateTreeFromStrings(unsigned char *input, unsigned inputLength);
+
 	// Writes input to output, compressed.  Takes care of the null terminator for you
-	void EncodeString(char *input, int maxCharsToWrite, BitStream *output);
+	void EncodeString(char *input, int maxCharsToWrite, RakNet::BitStream *output);
 
 	// Writes input to output, uncompressed.  Takes care of the null terminator for you.
 	// maxCharsToWrite should be the allocated size of output
-	void DecodeString(char *output, int maxCharsToWrite, BitStream *input);
+	bool DecodeString(char *output, int maxCharsToWrite, RakNet::BitStream *input);
+
 private:
 	void GenerateHuffmanEncodingTree(void);
 	StringCompressor();

Added: branches/multiplayer-branch/source/libraries/raknet/Types.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/Types.h	2004-10-06 21:22:23 UTC (rev 75)
+++ branches/multiplayer-branch/source/libraries/raknet/Types.h	2004-10-08 21:41:59 UTC (rev 76)
@@ -0,0 +1,486 @@
+/*
+	Fundamental tools & types
+
+	Catid(cat02e at fsu.edu)
+
+	8/9/2004	Added SINGLE/ARRAY_RELEASE
+	8/5/2004	Added COMPILER_ preprocessors
+				class NoCopies
+	8/1/2004	Removed mask stuff
+	7/29/2004	Added swapLE, swapBE, getLE, getBE
+	7/28/2004	Automatic and AutoArray now compile in dev-c++
+				Added pre-processor conditions to support other compilers
+				Removed GETWORD and GETDWORD
+	7/15/2004	Now using COM_RELEASE throughout CatGL3
+	6/22/2004	Removed triple and pair
+	6/12/2004	AutoDeallocate -> Automatic, AutoArray
+	6/9/2004	OBJCLR
+	5/2/2004	class AutoDeallocate
+	5/1/2004	IS_POWER_OF_2, next_highest_power_of_2
+	4/30/2004	Merged character manip macros
+	2/23/2004	CEIL*
+				Removed MEMCOPY32 and MEMCLEAR32,
+				memcpy and memset are now faster
+				MAKE_MASK
+	2/10/2004	LITTLE_ENDIAN
+				COUNT1BITS32
+				AT_LEAST_2_BITS
+				LEAST_SIGNIFICANT_BIT
+	X-mas/2003	[u/s]int?? -> [u/s]??
+	7/3/2003	Added template triple, point->pair
+	6/15/2003	Added template rect, point
+	3/30/2003	Added RO?8, RO?16 and ?int64
+				Added MEMCOPY32 and MEMCLEAR32
+	3/12/2003	Added GETWORD and GETDWORD
+	1/16/2003	Formalized this library.
+
+	Tabs: 4 spaces
+	Dist: public
+*/
+
+#ifndef TYPES_H
+#define TYPES_H
+
+namespace cat
+{
+////// Compilers //////
+
+/*
+	Things to consider for each compiler:
+
+	BIG_ENDIAN / LITTLE_ENDIAN
+	MULTITHREADED
+	DEBUG
+	HASINT64
+	Basic types {u8-u64, s8-s64, f32, f64}
+	WIN32
+	ASSEMBLY_INTEL_SYNTAX / ASSEMBLY_ATT_SYNTAX, ASSEMBLY_BLOCK
+	INLINE
+	NO_TEMPLATE_INLINE_ASSEMBLY
+	Fixes
+
+	Set depending which compiler is being used:
+
+	COMPILER_MSVC
+	COMPILER_GCC
+	COMPILER_BORLANDC
+*/
+
+
+//// endian-ness (ignoring NUXI) ////
+
+#if defined(__sparc) || defined(__sparc__) || defined(__powerpc__) || \
+	defined(__ppc__) || defined(__hppa) || defined(_MIPSEB) || defined(_POWER) || \
+	defined(_M_PPC) || defined(_M_MPPC) || defined(_M_MRX000) || \
+	defined(__POWERPC) || defined(m68k) || defined(powerpc) || \
+	defined(sel) || defined(pyr) || defined(mc68000) || defined(is68k) || \
+	defined(tahoe) || defined(ibm032) || defined(ibm370) || defined(MIPSEB) || \
+	defined(__convex__) || defined(DGUX) || defined(hppa) || defined(apollo) || \
+	defined(_CRAY) || defined(__hp9000) || defined(__hp9000s300) || defined(_AIX) || \
+	defined(__AIX) || defined(__pyr__) || defined(hp9000s700) || defined(_IBMR2)
+
+#	define BIG_ENDIAN
+
+#elif defined(__i386__) || defined(i386) || defined(intel) || defined(_M_IX86) || \
+	  defined(__alpha__) || defined(__alpha) || defined(__ia64) || defined(__ia64__) || \
+	  defined(_M_ALPHA) || defined(ns32000) || defined(__ns32000__) || defined(sequent) || \
+	  defined(MIPSEL) || defined(_MIPSEL) || defined(sun386) || defined(__sun386__)
+
+#	define LITTLE_ENDIAN
+
+#else
+
+#	error "I can't tell what endian-ness to use for your architecture."
+
+#endif
+
+
+//// compiler-specific ////
+
+#if defined(__COMO__) // Comeau C++
+
+#	error "Comeau C++ : I don't know your compiler"
+
+#elif defined(__DMC__) // Digital Mars C++
+
+#	error "Digital Mars C++ : I don't know your compiler"
+
+#elif defined(__INTEL_COMPILER) || defined(__ICL) || defined(__ICC) || defined(__ECC) // Intel
+
+#	error "Intel : I don't know your compiler"
+
+#elif defined(__GNUC__) // GNU C++
+
+#define COMPILER_GCC
+
+#	if defined(_MT)
+#		define MULTITHREADED
+#	endif
+
+#	if defined(_DEBUG)
+#		define DEBUG
+#	endif
+
+#	define INLINE inline
+#	define HASINT64
+
+#	define ASSEMBLY_ATT_SYNTAX
+#	define ASSEMBLY_BLOCK asm
+
+#elif defined(__DJGPP__) // DJGPP
+
+#	error "DJGPP : I don't know your compiler"
+
+#	define ASSEMBLY_ATT_SYNTAX
+
+#elif defined(__WATCOMC__) // WatcomC
+
+#	error "WatcomC : I don't know your compiler"
+
+#elif defined(__KCC) // Kai C++
+
+#	error "Kai C++ : I don't know your compiler"
+
+#elif defined(__sgi) // SGI MIPSpro C++
+
+#	error "SGI MIPSpro C++ : I don't know your compiler"
+
+#elif defined(__SUNPRO_CC) // Sun Workshop Compiler C++
+
+#	error "Sun Workshop Compiler C++ : I don't know your compiler"
+
+#elif defined(__HP_aCC) // HP aCC
+
+#	error "HP aCC : I don't know your compiler"
+
+#elif defined(__DECCXX) // Compaq Tru64 Unix cxx
+
+#	error "Compaq Tru64 Unix cxx : I don't know your compiler"
+
+#elif defined(__ghs) // Greenhills C++
+
+#	error "Greenhills C++ : I don't know your compiler"
+
+#elif defined(__BORLANDC__) // Borland
+
+#	if (__BORLANDC__ >= 0x561)
+#		define HASINT64
+#	endif
+
+#define COMPILER_BORLANDC
+
+#	if defined(__MT__)
+#		define MULTITHREADED
+#	endif
+
+#	if defined(__DEBUG)
+#		define DEBUG
+#	endif
+
+#	define INLINE inline
+#	define ASSEMBLY_INTEL_SYNTAX
+#	define ASSEMBLY_BLOCK _asm
+#	define NO_TEMPLATE_INLINE_ASSEMBLY
+
+#elif defined(__MWERKS__) // Metrowerks CodeWarrior
+
+#	error "Metrowerks CodeWarrior : I don't know your compiler"
+
+#elif defined(__MRC__) || defined(__SC__) // MPW MrCpp or SCpp
+
+#	error "MPW MrCpp or SCpp : I don't know your compiler"
+
+#elif defined(__IBMCPP__) // IBM Visual Age
+
+#	error "IBM Visual Age : I don't know your compiler"
+
+#elif defined(_MSC_VER) // Microsoft VC++
+	// must be last because many other compilers define this also
+
+#define COMPILER_MSVC
+
+#	if (_MSC_VER >= 1200) /* 1200 == VC++ 6.0 */
+#		define HASINT64
+#		define INLINE __forceinline
+#	endif
+
+#	if defined(_MT)
+#		define MULTITHREADED
+#	endif
+
+#	if defined(__DEBUG)
+#		define DEBUG
+#	endif
+
+#	define BASIC_TYPES_ALREADY_DEFINED
+	typedef unsigned __int8		u8;
+	typedef signed __int8		s8;
+	typedef unsigned __int16	u16;
+	typedef signed __int16		s16;
+	typedef unsigned __int32	u32;
+	typedef signed __int32		s32;
+	typedef float				f32;
+	typedef double				f64;
+#	if defined(HASINT64)
+		typedef unsigned __int64	u64;
+		typedef signed __int64		s64;
+#	endif
+
+#	define ASSEMBLY_INTEL_SYNTAX
+#	define ASSEMBLY_BLOCK __asm
+
+#	if (_MSC_VER <= 1200)
+#		pragma warning(disable : 4786) // truncation to 255 chars
+#	endif
+
+#else
+
+#	error "Unknown : I don't know your compiler"
+
+#endif // compilers
+
+
+	// Generic basic types
+#if !defined(BASIC_TYPES_ALREADY_DEFINED)
+	typedef unsigned char		u8;
+	typedef signed char			s8;
+	typedef unsigned short		u16;
+	typedef signed short		s16;
+	typedef unsigned int		u32;
+	typedef signed int			s32;
+	typedef float				f32;
+	typedef double				f64;
+#	if defined(HASINT64)
+	typedef unsigned long long	u64;
+	typedef signed long long	s64;
+#	endif
+#endif
+
+	// Fixed-point types
+	typedef s32 sfp22_10; // hi-Siiiiiiiiiiiiiiiiiiiii-lo | hi-ffffffffff-lo
+	typedef u32 ufp22_10; // hi-iiiiiiiiiiiiiiiiiiiiii-lo | hi-ffffffffff-lo
+	typedef s32 sfp16_16; // hi-Siiiiiiiiiiiiiii-lo | hi-ffffffffffffffff-lo
+	typedef u32 ufp16_16; // hi-iiiiiiiiiiiiiiii-lo | hi-ffffffffffffffff-lo
+
+/*
+	COMmy macros
+*/
+
+#define COM_RELEASE(ref) if (ref) { (ref)->Release(); (ref) = 0; }
+#define SINGLE_RELEASE(ref) if (ref) { delete (ref); (ref) = 0; }
+#define ARRAY_RELEASE(ref) if (ref) { delete [](ref); (ref) = 0; }
+
+	template<class T> class rect
+	{
+	public:
+		rect() : x(0), y(0), w(0), h(0) {}
+		rect(T xx, T yy, T ww, T hh) : x(xx), y(yy), w(ww), h(hh) {}
+
+		T x, y, w, h;
+	};
+
+	template<class T> class AutoArray
+	{
+		T *ptr;
+
+	public:
+		AutoArray(T *c_ptr)
+		{
+			ptr = c_ptr;
+		}
+		~AutoArray()
+		{
+			ARRAY_RELEASE(ptr);
+		}
+
+		INLINE void cancel()
+		{
+			ptr = 0;
+		}
+	};
+
+	template<class T> class Automatic
+	{
+		T *ptr;
+
+	public:
+		Automatic(T *c_ptr)
+		{
+			ptr = c_ptr;
+		}
+		~Automatic()
+		{
+			SINGLE_RELEASE(ptr);
+		}
+
+		INLINE void cancel()
+		{
+			ptr = 0;
+		}
+	};
+
+	// Derive from NoCopies to disallow copies of derived class
+	class NoCopies
+	{
+	protected:
+		NoCopies() {}
+		~NoCopies() {}
+
+	private:
+		NoCopies(const NoCopies &cp);
+		NoCopies &operator=(const NoCopies &cp);
+	};
+
+
+	// Byte-order swapping
+#define BOSWAP32(n) ( ((n) << 24) | (((n) & 0x00ff0000) >> 8) | (((n) & 0x0000ff00) << 8) | ((n) >> 24) ) /* only works for u32 */
+#define BOSWAP16(n) ( ((n) << 8) | ((n) >> 8) ) /* only works for u16 */
+
+#ifdef LITTLE_ENDIAN
+#	define swapLE(n)
+#	define getLE(n) (n)
+	INLINE void swapBE(u32 &n) { n = BOSWAP32(n); }
+	INLINE void swapBE(u16 &n) { n = BOSWAP16(n); }
+	INLINE u32 getBE(u32 n) { return BOSWAP32(n); }
+	INLINE u16 getBE(u16 n) { return BOSWAP16(n); }
+	INLINE void swapBE(s32 &n) { n = BOSWAP32((u32)n); }
+	INLINE void swapBE(s16 &n) { n = BOSWAP16((u16)n); }
+	INLINE s32 getBE(s32 n) { return BOSWAP32((u32)n); }
+	INLINE s16 getBE(s16 n) { return BOSWAP16((u16)n); }
+#else
+#	define swapBE(n)
+#	define getBE(n) (n)
+	INLINE void swapLE(u32 &n) { n = BOSWAP32(n); }
+	INLINE void swapLE(u16 &n) { n = BOSWAP16(n); }
+	INLINE u32 getLE(u32 n) { return BOSWAP32(n); }
+	INLINE u16 getLE(u16 n) { return BOSWAP16(n); }
+	INLINE void swapLE(s32 &n) { n = BOSWAP32((u32)n); }
+	INLINE void swapLE(s16 &n) { n = BOSWAP16((u16)n); }
+	INLINE s32 getLE(s32 n) { return BOSWAP32((u32)n); }
+	INLINE s16 getLE(s16 n) { return BOSWAP16((u16)n); }
+#endif
+
+} // namespace cat
+
+
+// Rotation
+#define ROL8(n, r)  ( ((n) << (r)) | ((n) >> ( 8 - (r))) ) /* only works for u8 */
+#define ROR8(n, r)  ( ((n) >> (r)) | ((n) << ( 8 - (r))) ) /* only works for u8 */
+#define ROL16(n, r) ( ((n) << (r)) | ((n) >> (16 - (r))) ) /* only works for u16 */
+#define ROR16(n, r) ( ((n) >> (r)) | ((n) << (16 - (r))) ) /* only works for u16 */
+#define ROL32(n, r) ( ((n) << (r)) | ((n) >> (32 - (r))) ) /* only works for u32 */
+#define ROR32(n, r) ( ((n) >> (r)) | ((n) << (32 - (r))) ) /* only works for u32 */
+
+/*
+	Add memory that is allocated on a 32-bit boundary
+	and has at least one block.
+*/
+#define MEMADD32(ptr, len, val) { \
+	register u32 *__data = (u32*)(ptr); /* pointer to data to clear */ \
+	register s32 __length = (len); /* number of 32-bit blocks */ \
+\
+	switch (__length % 8) \
+	{ \
+	case 0:	do {	*__data++ += (val); \
+	case 7:			*__data++ += (val); \
+	case 6:			*__data++ += (val); \
+	case 5:			*__data++ += (val); \
+	case 4:			*__data++ += (val); \
+	case 3:			*__data++ += (val); \
+	case 2:			*__data++ += (val); \
+	case 1:			*__data++ += (val); \
+					__length -= 8; \
+			} while(__length > 0); \
+	} \
+}
+
+/*
+	Safe null-terminated string -> char buffer copy
+*/
+#define STRNCPY(dest, src, size) { \
+	strncpy(dest, src, size); \
+	dest[size-1] = 0; \
+}
+
+/*
+	Because memory clearing is a frequent operation
+*/
+#define MEMCLR(dest, size) memset(dest, 0, size)
+
+// Works for arrays, also
+#define OBJCLR(object) memset(&(object), 0, sizeof(object))
+
+/*
+	Fast binary method of counting bits
+
+	MIT Hackmem from X11
+
+	Only works for 32-bit integers
+*/
+#define _C1B_INTERMED(n) ( (n) - (((n) >> 1) & 033333333333) - (((n) >> 2) & 011111111111) )
+#define COUNT1BITS32(n) ( ((_C1B_INTERMED(n) + (_C1B_INTERMED(n) >> 3)) & 030707070707) % 63 )
+
+/*
+	Consider N an ordered set of 1/0 values.
+
+	LESSTHAN2BITS(n) := there are less than 2 bits in set N
+
+	Proof:
+
+	(N - 1) will clear the least significant of the bits in N.
+
+	Three cases exist concerning (N-1):
+
+	N contains 0 bits
+		An intersection with N would be trivially null.
+	N contains 1 bit
+		The least only existing bit was cleared,
+			thus an intersection with the original
+			set WOULD be null.
+	N contains more than 1 bit
+		A more significant bit remains in the set,
+			thus an intersection with the original
+			set WOULD NOT be null.
+*/
+#define AT_LEAST_2_BITS(n) ( (n) & ((n) - 1) )
+
+#define LEAST_SIGNIFICANT_BIT(n) ( (n) & -(n) )
+
+#define IS_POWER_OF_2(n) ( n && !AT_LEAST_2_BITS(n) )
+
+INLINE cat::u32 next_highest_power_of_2(cat::u32 n)
+{
+	if (IS_POWER_OF_2(n)) return n;
+
+	cat::u16 b = 2;
+
+	while (n >>= 1) b <<= 1;
+
+	return b;
+}
+
+/*
+	CEIL*
+
+	Bump 'n' to the next unit of 'width'.
+*/
+#define CEIL_UNIT(n, width) ( ( (n) + (width) - 1 ) / (width) )
+#define CEIL(n, width) ( CEIL_UNIT(n, width) * (width) )
+
+/*
+	Quick character manipulation
+*/
+#define IS_ALPHA(ch) ( (((u8)(ch) & 0xc0) == 0x40) && ((((u8)(ch) - 1) & 0x1f) <= 0x19) )
+
+#define IS_NUM(ch) ( ((u8)(ch) - 0x30) < 10 )
+
+#define IS_ALPHANUM(ch) ( IS_ALPHA(ch) || IS_NUM(ch) )
+
+#define TO_LOWER(ch) (char)( (ch) | 0x20 ) /* must be upper/lower-case alpha */
+#define TO_UPPER(ch) (char)( (ch) & (~0x20) ) /* must be upper/lower-case alpha */
+
+
+#endif // TYPES_H
+
+
+



From yurand at sheep.berlios.de  Sat Oct  9 07:50:58 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 9 Oct 2004 07:50:58 +0200
Subject: [Tw-light-svn] r77 - in trunk: . web
Message-ID: <200410090550.i995owgA000516@sheep.berlios.de>

Author: yurand
Date: 2004-10-09 07:50:56 +0200 (Sat, 09 Oct 2004)
New Revision: 77

Modified:
   trunk/makefile
   trunk/web/info.html
   trunk/web/links.html
   trunk/web/team.html
   trunk/web/update.sh
Log:
Fixed issue #14 make install deletes gamedata directory and contents 


Modified: trunk/makefile
===================================================================
--- trunk/makefile	2004-10-08 21:41:59 UTC (rev 76)
+++ trunk/makefile	2004-10-09 05:50:56 UTC (rev 77)
@@ -203,8 +203,8 @@
 	find source -name '*.cpp'|grep -v 'libraries'|grep -v 'errors.cpp'|grep -v 'utils.cpp'|xargs ./Util/addStackTrace.pl 
 
 install:
-	./install-sh $(NAME) $(EXECPATH)/$(NAME)
-	./install-sh gamedata $(DATAPATH)
+	./install-sh -c -m 755 $(NAME) $(EXECPATH)/$(NAME)
+	CPPROG="cp -r" ./install-sh -c -m 644 gamedata $(DATAPATH)
 
 uninstall:
 	$(RM) $(EXECPATH)/$(NAME)

Modified: trunk/web/info.html
===================================================================
--- trunk/web/info.html	2004-10-08 21:41:59 UTC (rev 76)
+++ trunk/web/info.html	2004-10-09 05:50:56 UTC (rev 77)
@@ -104,7 +104,7 @@
 </p>
 <p class="indented">
 You can support the project by posting bugreports and patches in 
-<a href="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">TW-Light Bugzilla</a>
+<a href="http://tw-light.berlios.de/mantis/">TW-Light Mantis</a>
 </p>
 
 <p class="indented">

Modified: trunk/web/links.html
===================================================================
--- trunk/web/links.html	2004-10-08 21:41:59 UTC (rev 76)
+++ trunk/web/links.html	2004-10-09 05:50:56 UTC (rev 77)
@@ -27,7 +27,7 @@
   <h3>TW-Light resources</h3>
   <ul>
     <li><a href="http://developer.berlios.de/projects/tw-light/">BerliOS: TW-Light Project Info</a></li>
-    <li><a href="http://tw-light.berlios.de/mantis/">TW-Light Bugzilla</a> </li>
+    <li><a href="http://tw-light.berlios.de/mantis/">TW-Light Mantis</a> </li>
     <li><a href="http://timewarp.sourceforge.net/forum/index.php">TimeWarp Forum (official)</a> </li>
 </ul>
 

Modified: trunk/web/team.html
===================================================================
--- trunk/web/team.html	2004-10-08 21:41:59 UTC (rev 76)
+++ trunk/web/team.html	2004-10-09 05:50:56 UTC (rev 77)
@@ -49,7 +49,7 @@
   
   <h4>Music</h>
   <ul>
-    <li>Robeter Productions <a href=http://www.robeterproductions.com>(www.robeterproductions.com)<img style="float:right" src=www.robeterproductions.com.jpg></a></li>
+    <li>Robeter Productions <a href=http://www.robeterproductions.com>(www.robeterproductions.com)</a></li>
     <li>Mark Forest (Abe Froman)</li>
   </ul>
   

Modified: trunk/web/update.sh
===================================================================
--- trunk/web/update.sh	2004-10-08 21:41:59 UTC (rev 76)
+++ trunk/web/update.sh	2004-10-09 05:50:56 UTC (rev 77)
@@ -1,2 +1,2 @@
 #!/bin/bash
-pscp info.html downloads.html index.html links.html team.html yurand at shell.berlios.de:/home/groups/tw-light/htdocs
\ No newline at end of file
+pscp info.html links.html yurand at shell.berlios.de:/home/groups/tw-light/htdocs
\ No newline at end of file



From yurand at sheep.berlios.de  Sat Oct  9 07:57:32 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 9 Oct 2004 07:57:32 +0200
Subject: [Tw-light-svn] r78 - trunk
Message-ID: <200410090557.i995vWQw000728@sheep.berlios.de>

Author: yurand
Date: 2004-10-09 07:57:31 +0200 (Sat, 09 Oct 2004)
New Revision: 78

Modified:
   trunk/makefile
Log:
issue  0000014: make install deletes gamedata directory and contents


Modified: trunk/makefile
===================================================================
--- trunk/makefile	2004-10-09 05:50:56 UTC (rev 77)
+++ trunk/makefile	2004-10-09 05:57:31 UTC (rev 78)
@@ -204,7 +204,7 @@
 
 install:
 	./install-sh -c -m 755 $(NAME) $(EXECPATH)/$(NAME)
-	CPPROG="cp -r" ./install-sh -c -m 644 gamedata $(DATAPATH)
+	CPPROG="cp -r" ./install-sh -c gamedata $(DATAPATH)
 
 uninstall:
 	$(RM) $(EXECPATH)/$(NAME)



From youbastrd at sheep.berlios.de  Fri Oct 15 21:46:05 2004
From: youbastrd at sheep.berlios.de (Paul Forest at BerliOS)
Date: Fri, 15 Oct 2004 21:46:05 +0200
Subject: [Tw-light-svn] r79 - in trunk/source: games melee
Message-ID: <200410151946.i9FJk5C3030566@sheep.berlios.de>

Author: youbastrd
Date: 2004-10-15 21:46:04 +0200 (Fri, 15 Oct 2004)
New Revision: 79

Modified:
   trunk/source/games/gdefender.cpp
   trunk/source/games/ggob.cpp
   trunk/source/games/ggob.h
   trunk/source/melee/mgame.cpp
   trunk/source/melee/mgame.h
   trunk/source/melee/mmain.cpp
   trunk/source/melee/mmain.h
Log:
adding victory conditions again.  Adding for NormalGame (ie Melee), Gob and Defender

Modified: trunk/source/games/gdefender.cpp
===================================================================
--- trunk/source/games/gdefender.cpp	2004-10-09 05:57:31 UTC (rev 78)
+++ trunk/source/games/gdefender.cpp	2004-10-15 19:46:04 UTC (rev 79)
@@ -66,6 +66,9 @@
 
   /// here we check to see if the player lost the game and we add new enemies if it's time for that
   virtual void calculate ( ) ;
+  
+  virtual bool isGameDone();
+  
   /// this is used to display the starbases current health
   virtual void fps();
 	
@@ -79,6 +82,9 @@
   int time_for_next_attack;
   /// phase of enemy ships spawning
   int time_between_attacks;
+  
+protected:
+	bool lostGame;
 
 };
 
@@ -143,7 +149,8 @@
       starbase = NULL;
       char buffy[1024];
       sprintf(buffy, "You lost after %d seconds", game_time/1000);
-      message.print(9999000, 15, buffy);
+      lostGame = true;
+      message.print(10000, 15, buffy);
     }
   else if (game_time >= time_for_next_attack) 
     {
@@ -157,12 +164,27 @@
   return;
 }
 
+bool DefenderGame::isGameDone() {
+	if (lostGame || 
+	    defendergame->player->ship == NULL || 
+	    !defendergame->player->ship->exists()) 
+	{
+		game_done = true;
+		char buffy[500] = "";
+		sprintf(buffy, "Game Over!\n\nYou Defended the base for %d seconds.", game_time/1000);
+		tw_alert(buffy, "Ok!");
+	}
+	return Game::isGameDone();
+}
+
 void DefenderGame::preinit() 
 {
   Game::preinit();
   //because the desctructor deals with stationsprite, we have to initialize it here
   //just in case the normal init() function doesn't get called
   stationsprite = NULL;
+  
+  lostGame = false;
 }
 
 DefenderGame::~DefenderGame() 

Modified: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2004-10-09 05:57:31 UTC (rev 78)
+++ trunk/source/games/ggob.cpp	2004-10-15 19:46:04 UTC (rev 79)
@@ -101,6 +101,19 @@
   defenderSprite = NULL;
 }
 
+bool GobGame::isGameDone() {
+	bool done = true;
+	for (int i = 0; i < gobplayers; i += 1) {
+		if (gobplayer[i]->ship != NULL)
+			done = false;
+	}
+	if (done) {
+		game_done = true;
+		tw_alert("Game Over!\n\nYour ship and its contents are lost!", "Ok");
+    }
+	return Game::isGameDone();
+}
+
 void GobGame::add_gobplayer(Control *control) 
 {
   STACKTRACE;

Modified: trunk/source/games/ggob.h
===================================================================
--- trunk/source/games/ggob.h	2004-10-09 05:57:31 UTC (rev 78)
+++ trunk/source/games/ggob.h	2004-10-15 19:46:04 UTC (rev 79)
@@ -87,6 +87,7 @@
   TeamCode enemy_team;
 
   virtual void calculate();
+  virtual bool isGameDone();
   virtual void ship_died(Ship *who, SpaceLocation *source);
   virtual void preinit();
   virtual void init (Log *log);

Modified: trunk/source/melee/mgame.cpp
===================================================================
--- trunk/source/melee/mgame.cpp	2004-10-09 05:57:31 UTC (rev 78)
+++ trunk/source/melee/mgame.cpp	2004-10-15 19:46:04 UTC (rev 79)
@@ -193,7 +193,7 @@
     {
     case Event::VIDEO: 
       {
-	if (game_done)
+	if (isGameDone())
 	  return;
 	if (e->subtype == VideoEvent::REDRAW)
 	  this->redraw();
@@ -665,7 +665,7 @@
   try 
     {
       play_music();
-      while(!game_done) 
+      while(!isGameDone()) 
 	{
 	  if(!tw_sound->playing_music())
 	    play_music();
@@ -1153,7 +1153,8 @@
     case KEY_F1: 
       {// help
 	pause();
-	show_file(data_full_path("ingame.txt"));
+	showHelpText();
+	//show_file(data_full_path("ingame.txt"));
 	unpause();
 	return true;
       }
@@ -1289,3 +1290,14 @@
   game_done = true;
 }
 
+bool Game::isGameDone() { 
+    return game_done;
+}
+
+void Game::setGameDone(const bool done)
+{ 
+    game_done = done; 
+}
+
+
+

Modified: trunk/source/melee/mgame.h
===================================================================
--- trunk/source/melee/mgame.h	2004-10-09 05:57:31 UTC (rev 78)
+++ trunk/source/melee/mgame.h	2004-10-15 19:46:04 UTC (rev 79)
@@ -157,9 +157,13 @@
   bool game_done;
 
 public:
-  virtual void setGameDone(const bool done) { game_done = done; }
-  virtual bool isGameDone() { return game_done; }
-	
+  /// sets whether the game is done, according to the rules for the
+  /// gametype.
+  virtual void setGameDone(const bool done);
+  
+  /// gets if the game is done.  Will wait a few seconds for dramatic effect.
+  virtual bool isGameDone();
+  
   virtual void quit(const char *message);
     
   int hiccup_margin;

Modified: trunk/source/melee/mmain.cpp
===================================================================
--- trunk/source/melee/mmain.cpp	2004-10-09 05:57:31 UTC (rev 78)
+++ trunk/source/melee/mmain.cpp	2004-10-15 19:46:04 UTC (rev 79)
@@ -223,9 +223,6 @@
 	num_kills = 0;
 	kills = NULL;
 	num_players = 0;
-	
-	gameEnding = false;
-	gameEndingTime = DefaultEndingTime;
 	}
 void NormalGame::init(Log *_log) {
   STACKTRACE;
@@ -567,20 +564,15 @@
 bool NormalGame::isGameDone() 
 {
   STACKTRACE;
+  enum {MAX_VICTORY_MESSAGE=500};
+  enum {MAX_VICTORY_ACKNOWLEDGE_TEXT=50};
+  char victoryMessage[MAX_VICTORY_MESSAGE] = "";
+  char victoryAcknowledgeText[MAX_VICTORY_ACKNOWLEDGE_TEXT] = "Ok";
+  
   /*! we'll only check this every now and again, to avoid bogging down the engine.  */  
-  enum { IterationsToSkip = 30 };
+  enum { IterationsToSkip = 30 };  
   static long iterationsToSkip = IterationsToSkip;
   
-  /*! */
-  if (gameEnding) {
-    /*! how long do we wait after a victory before exiting the game? */
-    if (--gameEndingTime > 0)
-      return Game::isGameDone();
-    else {
-      game_done = true;
-    }
-  }
-  
   if (iterationsToSkip-- <=0 ) {
     iterationsToSkip = IterationsToSkip;
     
@@ -608,9 +600,8 @@
     
     //either there's one team left standing, or none. :)
     // either way, the game is over.
-    //we delay ending the game a few seconds for dramatic effect
     if (numAliveTeams <= 1) {
-      gameEnding = true;
+      game_done = true;
       if (numAliveTeams==1) {
 	for (int i=0; i<num_players; i++) {
 	  if ( ( player_fleet[i] && 
@@ -619,20 +610,34 @@
 	       (player_control[i] &&
 		player_control[i]->ship) )
 	    {
-	      if (player_control[i]->isHuman())
-		message.print(8000,15,"%s won the match!", player_name[i]);
-	      else
-		message.print(8000,15,"%s won the match!", control_name[ player_control[i]->getControlType() ]);
-	    				break;
+	      if (player_control[i]->isHuman()) {
+			message.print(8000,15,"%s won the match!", player_name[i]);
+			sprintf(victoryMessage, "%s won the match!", player_name[i]);
+			sprintf(victoryAcknowledgeText, "Woohoo!");
+	      } else {
+			message.print(8000,15,"%s won the match!", control_name[ player_control[i]->getControlType() ]);
+			sprintf(victoryMessage, "%s won the match!", control_name[ player_control[i]->getControlType() ]);
+			sprintf(victoryAcknowledgeText, "Awww...");
+		  }
+	      break;
 	    }
 	}
       } else {
-	message.print(8000,15,"Match ends in a draw!");
+	     message.print(8000,15,"Match ends in a draw!");
+	     sprintf(victoryMessage, "Match ends in a draw!");
+	     sprintf(victoryAcknowledgeText, "Darn, maybe next time!");
       }
     }
     free(teams);
   }
-  return Game::isGameDone();
+  
+  bool done = Game::isGameDone();
+  
+  if (done && strlen(victoryMessage)>0) {
+  	  tw_alert(victoryMessage, victoryAcknowledgeText);
+  }
+
+  return done;
 }
 
 // this should be places elsewhere I think ...
@@ -719,5 +724,4 @@
 }
 
 
-
 REGISTER_GAME(NormalGame, "Melee")

Modified: trunk/source/melee/mmain.h
===================================================================
--- trunk/source/melee/mmain.h	2004-10-09 05:57:31 UTC (rev 78)
+++ trunk/source/melee/mmain.h	2004-10-15 19:46:04 UTC (rev 79)
@@ -21,7 +21,6 @@
 #include "melee.h"
 #include "mgame.h"
 
-enum { DefaultEndingTime = 1000 };
 
 class NormalGame : public Game {
 	public:
@@ -71,9 +70,6 @@
 	
 	virtual void showHelpText();
 	
-	bool gameEnding;
-	long gameEndingTime;
-
 	int next_choose_new_ships_time;
 	virtual void choose_new_ships() ;
 



From yurand at sheep.berlios.de  Sat Oct 16 11:01:12 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 16 Oct 2004 11:01:12 +0200
Subject: [Tw-light-svn] r80 - trunk/source/ships
Message-ID: <200410160901.i9G91Cr3015233@sheep.berlios.de>

Author: yurand
Date: 2004-10-16 11:01:11 +0200 (Sat, 16 Oct 2004)
New Revision: 80

Modified:
   trunk/source/ships/shpforsh.cpp
   trunk/source/ships/shpgarty.cpp
Log:
fixed issue #10 Ga'Rath Tyrant primary hit itself 


Modified: trunk/source/ships/shpforsh.cpp
===================================================================
--- trunk/source/ships/shpforsh.cpp	2004-10-15 19:46:04 UTC (rev 79)
+++ trunk/source/ships/shpforsh.cpp	2004-10-16 09:01:11 UTC (rev 80)
@@ -20,73 +20,78 @@
 #include "ship.h"
 
 class ForevianShocker : public Ship
-{	double		weaponRange, weaponVelocity;
-	int			weaponDamage, weaponArmour;
-	int			weapon_type;
-	int			weapon_frame_size;
+{
+  double weaponRange, weaponVelocity;
+  int	weaponDamage, weaponArmour;
+  int	weapon_type;
+  int	weapon_frame_size;
 
-	double		specialRange, specialVelocity;
-	int			specialDamage, specialArmour;
-	int			specialFrames;
-	int			shockingFrames;
-	int			shockVar;
-	int			specialLoss;
+  double specialRange, specialVelocity;
+  int	specialDamage, specialArmour;
+  int	specialFrames;
+  int	shockingFrames;
+  int	shockVar;
+  int	specialLoss;
 
-	bool		new_special;
-	int			special_frame_size, special_frame_num;
+  bool new_special;
+  int special_frame_size, special_frame_num;
 
-	SpaceSprite *special_sprite;
-
+  SpaceSprite *special_sprite;
+  
 public:
-	ForevianShocker(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code);
+  ForevianShocker(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code);
 
 protected:
-	virtual int activate_weapon();
-	virtual int activate_special();
-	virtual void calculate();
+  virtual int activate_weapon();
+  virtual int activate_special();
+  virtual void calculate();
 };
 
 class ForevianShockwave : public AnimatedShot
 {
-	SpaceObject *last_hit;	int loss;
+  SpaceObject *last_hit;	int loss;
 
 public:
-	ForevianShockwave(double ox, double oy, double oangle, double ov, int odamage, double orange, int oarmour, Ship *oship, SpaceLocation *opos, SpaceSprite *osprite, int ofcount, int ofsize, int ol);
-	virtual void inflict_damage(SpaceObject *other);
+  ForevianShockwave(double ox, double oy, double oangle, double ov, int odamage, double orange, int oarmour, Ship *oship, SpaceLocation *opos, SpaceSprite *osprite, int ofcount, int ofsize, int ol);
+  virtual void inflict_damage(SpaceObject *other);
 };
 
 ForevianShocker::ForevianShocker(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code) :
-	Ship(opos, shipAngle, shipData, code)
+  Ship(opos, shipAngle, shipData, code)
 {
   STACKTRACE;
-	weaponRange		= scale_range(get_config_float("Weapon", "Range", 0)); 
-	weaponVelocity	= scale_velocity(get_config_float("Weapon", "Velocity", 0));
-	weaponDamage	= get_config_int("Weapon", "Damage", 0); 
-	weaponArmour	= get_config_int("Weapon", "Armour", 0); 
-	weapon_type		= get_config_int("Weapon", "Type", 0);
-	
-	specialRange	= scale_range(get_config_float("Special", "Range", 0)); 
-	specialVelocity	= scale_velocity(get_config_float("Special", "Velocity", 0)); 
-	specialDamage	= get_config_int("Special", "Damage", 0); 
-	specialArmour	= get_config_int("Special", "Armour", 0); 
-	specialFrames	= get_config_int("Special", "Frames", 0); 
+  weaponRange	= scale_range(get_config_float("Weapon", "Range", 0)); 
+  weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 0));
+  weaponDamage	= get_config_int("Weapon", "Damage", 0); 
+  weaponArmour	= get_config_int("Weapon", "Armour", 0); 
+  weapon_type	= get_config_int("Weapon", "Type", 0);
+  
+  specialRange	= scale_range(get_config_float("Special", "Range", 0)); 
+  specialVelocity = scale_velocity(get_config_float("Special", "Velocity", 0)); 
+  specialDamage	= get_config_int("Special", "Damage", 0); 
+  specialArmour	= get_config_int("Special", "Armour", 0); 
+  specialFrames	= get_config_int("Special", "Frames", 0); 
+  
+  specialLoss = get_config_int("Special", "Loss", 0); 
+  
+  shockingFrames = 0;
+  shockVar = 0; 
+  
+  new_special = (get_config_int("Special", "NewGFX", 0) != 0);
+  weapon_frame_size = iround(weaponRange/weaponVelocity/32);
 
-	specialLoss		= get_config_int("Special", "Loss", 0); 
-	
-	shockingFrames	= 0;
-	shockVar		= 0; 
-	
-	new_special		= (get_config_int("Special", "NewGFX", 0) != 0);
-	weapon_frame_size	= iround(weaponRange/weaponVelocity/32);
-
-	if (new_special) {
-		special_sprite= data->spriteExtraExplosion;
-		special_frame_size = iround(specialRange/specialVelocity/32);	
-		special_frame_num = 32; }	
-	else {	
-		special_sprite = data->spriteSpecial;	
-		special_frame_size = 50;	
-		special_frame_num = 2; }
+  if (new_special) 
+    {
+      special_sprite= data->spriteExtraExplosion;
+      special_frame_size = iround(specialRange/specialVelocity/32);	
+      special_frame_num = 32; 
+    }	
+  else 
+    {	
+      special_sprite = data->spriteSpecial;	
+      special_frame_size = 50;	
+      special_frame_num = 2; 
+    }
 }
 
 int ForevianShocker::activate_weapon()

Modified: trunk/source/ships/shpgarty.cpp
===================================================================
--- trunk/source/ships/shpgarty.cpp	2004-10-15 19:46:04 UTC (rev 79)
+++ trunk/source/ships/shpgarty.cpp	2004-10-16 09:01:11 UTC (rev 80)
@@ -1,7 +1,6 @@
-/* $Id: shpgarty.cpp,v 1.1.1.1 2004/08/01 10:21:25 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -17,46 +16,51 @@
 
 #include "ship.h"
 
-class GarashTyrant : public Ship {
+
+/// Garash Tyrant ship
+
+class GarashTyrant : public Ship 
+{
   double       weaponVelocity;
   int          weaponDamage;
   int          weaponArmour;
   int          weaponChargeIncrement;
   double       weaponRange;
-	int					 weaponChargeSpeed;
-	double       weaponChargingDistance;
-	int          weaponChargingDistanceDamage;
+  int          weaponChargeSpeed;
+  double       weaponChargingDistance;
+  int          weaponChargingDistanceDamage;
   SpaceObject *weaponObject;
 
   double       specialDamage;
   double       specialRange;
   int          specialRepulse;
-	int					 specialStunFrames;
-	int          panelDelay;
-	int					 panelFrame;
-	int					 origPanelDelay;
+  int          specialStunFrames;
+  int          panelDelay;
+  int	       panelFrame;
+  int	       origPanelDelay;
 
-	bool         repulse;
+  bool         repulse;
 
-	int					 weaponMinTimeLimit;
-	int					 weaponMaxTimeLimit;
+  int					 weaponMinTimeLimit;
+  int					 weaponMaxTimeLimit;
 
   public:
   GarashTyrant(Vector2 opos, double shipAngle,
-    ShipData *shipData, unsigned int code);
-	friend class GarashShot;
-
-	virtual void calculate_fire_weapon();
-
+	       ShipData *shipData, unsigned int code);
+  friend class GarashShot;
+  
+  virtual void calculate_fire_weapon();
+  
   virtual int  activate_weapon();
   virtual int  activate_special();
-
+  
   virtual void calculate();
-	virtual void stun_ship(SpaceObject *other);
-
+  virtual void stun_ship(SpaceObject *other);
+  
 };
 
-class GarashShot : public Shot {
+class GarashShot : public Shot 
+{
   double v;
   int  frame;
   int  frame_step;
@@ -65,33 +69,32 @@
   int  charge_frame;
   int  charge_phase;
   int  released;
-	bool ship_hit;
-	bool done_once;
+  bool ship_hit;
+  bool done_once;
+  
+  int		 Timer;
+  int		 MinTL;
+  int		 MaxTL;
+  int		 Charge;
+  
+  Vector2		StartC;
+  double CD;
+  int    CDD;
 
-	int		 Timer;
-	int		 MinTL;
-	int		 MaxTL;
-	int		 Charge;
-
-	Vector2		StartC;
-	double CD;
-	int    CDD;
-
-
-
-  public:
+  
+  
+public:
   GarashShot(Vector2 opos, double oangle, double ov, int odamage, double 
-orange,
-    int oarmour, Ship *oship, SpaceSprite *osprite, int ofsize, int ofcount,
-		int oCI, int oMinTL, int oMaxTL, double oChargeDistance, int 
-oChargingDistanceDamage);
-
+	     orange,
+	     int oarmour, Ship *oship, SpaceSprite *osprite, int ofsize, int ofcount,
+	     int oCI, int oMinTL, int oMaxTL, double oChargeDistance, int 
+	     oChargingDistanceDamage);
+  
   virtual void calculate();
   virtual void animateExplosion();
   virtual void inflict_damage(SpaceObject *other);
   virtual int handle_damage(SpaceLocation *source, double normal, double 
-direct);
-	virtual int  canCollide(SpaceLocation *other);
+			    direct);
 };
 
 class GarashRepulsarStun: public SpaceObject {
@@ -103,10 +106,10 @@
   int   frame_count;
   int   targetIsDead;
 
-  public:
+public:
   GarashRepulsarStun(Ship *oship, SpaceSprite *osprite, int ofcount,
-    int ofsize, int disableFrames);
-
+		     int ofsize, int disableFrames);
+  
   virtual void calculate();
 };
 
@@ -117,29 +120,29 @@
 	Ship(opos, shipAngle, shipData, code)
 {
   STACKTRACE;
+  
+  weaponDamage = get_config_int("Weapon", "Damage", 8);
+  weaponArmour = get_config_int("Weapon", "Armour", 8);
+  weaponChargeIncrement	= get_config_int("Weapon", "ChargeIncrement", 3);
+  weaponVelocity = scale_velocity(get_config_float("Weapon", "Velocity", 200));
+  weaponRange  = scale_range(get_config_float("Weapon", "Range", 54));
+  weaponChargeSpeed = scale_frames(get_config_int("Weapon", "ChargeSpeed",2));
+  weaponMinTimeLimit = scale_frames(get_config_int("Weapon","MinTimeLimit",152));
+  weaponMaxTimeLimit = scale_frames(get_config_int("Weapon","MaxTimeLimit",430));
+  weaponChargingDistance = scale_range(get_config_float("Weapon", "ChargingDistance", 9));
+  weaponChargingDistanceDamage = get_config_int("Weapon", "ChargingDistanceDamage", 0);
 
-	weaponDamage					 = get_config_int("Weapon", "Damage", 8);
-	weaponArmour					 = get_config_int("Weapon", "Armour", 8);
-	weaponChargeIncrement	 = get_config_int("Weapon", "ChargeIncrement", 3);
-	weaponVelocity				 = scale_velocity(get_config_float("Weapon", "Velocity", 200));
-	weaponRange						 = scale_range(get_config_float("Weapon", "Range", 54));
-	weaponChargeSpeed      = scale_frames(get_config_int("Weapon", "ChargeSpeed",2));
-	weaponMinTimeLimit		 = scale_frames(get_config_int("Weapon","MinTimeLimit",152));
-	weaponMaxTimeLimit		 = scale_frames(get_config_int("Weapon","MaxTimeLimit",430));
-	weaponChargingDistance = scale_range(get_config_float("Weapon", "ChargingDistance", 9));
-	weaponChargingDistanceDamage = get_config_int("Weapon", "ChargingDistanceDamage", 0);
-
-	specialDamage			= get_config_int("Special", "Damage", 4);
-	specialRange			= scale_range(get_config_int("Special", "Range", 9));
-	specialRepulse		= get_config_int("Special","Repulse",80);
-	//specialStunFrames = scale_frames(get_config_int("Special","StunFrames",24));
+  specialDamage	= get_config_int("Special", "Damage", 4);
+  specialRange = scale_range(get_config_int("Special", "Range", 9));
+  specialRepulse = get_config_int("Special","Repulse",80);
+  //specialStunFrames = scale_frames(get_config_int("Special","StunFrames",24));
   specialStunFrames = scale_frames(get_config_int("Special","StunTime",24));
-	repulse						= FALSE;
+  repulse = FALSE;
 
-	weaponObject			= NULL;
-	origPanelDelay		= scale_frames(get_config_int("Extra","PanelDelay",0));
-	panelDelay        = origPanelDelay;
-	panelFrame				= 0;
+  weaponObject = NULL;
+  origPanelDelay = scale_frames(get_config_int("Extra","PanelDelay",0));
+  panelDelay = origPanelDelay;
+  panelFrame = 0;
 
 
 }
@@ -148,68 +151,65 @@
 {
   STACKTRACE;
 
-if (!fire_weapon  &&
-		!fire_special &&
-		!turn_left    &&
-		!turn_right   &&
-		!thrust)
-		{
-		panelDelay -= frame_time;
-		if (panelDelay==0)
-			{
-			BITMAP *b=spritePanel->get_bitmap(1);
-			switch (panelFrame) {
-				case 0:
-					ship->spritePanel->overlay(1, 1, b);
-					break;
-				case 1:
-					ship->spritePanel->overlay(1, 2, b);
-					break;
-				case 2:
-					ship->spritePanel->overlay(1, 5, b);
-					break;
-				case 3:
-					ship->spritePanel->overlay(1, 6, b);
-					break;
-				}
-		  blit(b,spritePanel->get_bitmap(1), 0, 0, 0, 70, 55, 30);
-			ship->update_panel = TRUE;
-
-			panelFrame++;
-			if (panelFrame > 3)
-				panelFrame = 0;
-			panelDelay = origPanelDelay;
-			}
-		}
-
-if (repulse)
+  if (!fire_weapon  &&
+      !fire_special &&
+      !turn_left    &&
+      !turn_right   &&
+      !thrust)
+    {
+      panelDelay -= frame_time;
+      if (panelDelay==0)
 	{
+	  BITMAP *b=spritePanel->get_bitmap(1);
+	  switch (panelFrame) 
+	    {
+	    case 0:
+	      ship->spritePanel->overlay(1, 1, b);
+	      break;
+	    case 1:
+	      ship->spritePanel->overlay(1, 2, b);
+	      break;
+	    case 2:
+	      ship->spritePanel->overlay(1, 5, b);
+	      break;
+	    case 3:
+	      ship->spritePanel->overlay(1, 6, b);
+	      break;
+	    }
+	  blit(b,spritePanel->get_bitmap(1), 0, 0, 0, 70, 55, 30);
+	  ship->update_panel = TRUE;
+	  
+	  panelFrame++;
+	  if (panelFrame > 3)
+	    panelFrame = 0;
+	  panelDelay = origPanelDelay;
+	}
+    }
+  
+  if (repulse)
+    {
+      Query q;
+      for (q.begin(this, OBJECT_LAYERS, specialRange); q.currento; q.next()) {
+	
+	// bugfix Geo
+	// Space-locations have mass, but can be included in this search. So, add an extra
+	// check for that. Otherwise the "mass" has a "value" that's not defined (its the value
+	// of some other variable).
+	
+	stun_ship(q.currento);
 
-		Query q;
-		for (q.begin(this, OBJECT_LAYERS, specialRange); q.currento; q.next()) {
+	if (q.currento->isObject())
+	  {
+	    if (q.currento->mass)
+	      q.currento->accelerate (q.currento, trajectory_angle(q.currento), 
+				      specialRepulse / q.currento->mass, MAX_SPEED);
+	    
+	    damage(q.currento, 0, specialDamage);
+	  }
 
-			// bugfix Geo
-			// Space-locations have mass, but can be included in this search. So, add an extra
-			// check for that. Otherwise the "mass" has a "value" that's not defined (its the value
-			// of some other variable).
-
-			stun_ship(q.currento);
-
-			if (q.currento->isObject())
-			{
-				if (q.currento->mass)
-					q.currento->accelerate (q.currento, trajectory_angle(q.currento), 
-					specialRepulse / q.currento->mass, MAX_SPEED);
-
-				damage(q.currento, 0, specialDamage);
 			}
+      add(new FixedAnimation(this,this, data->spriteSpecial, 0, 7, 70, LAYER_EXPLOSIONS));
 
-
-
-
-			}
-		add(new FixedAnimation(this,this, data->spriteSpecial, 0, 7, 70, LAYER_EXPLOSIONS));
-
 		damage(this, 0);
 
 		repulse=false;
@@ -303,44 +303,55 @@
   sprite_index = 0;
 }
 
-void GarashRepulsarStun::calculate() {
+void GarashRepulsarStun::calculate() 
+{
   STACKTRACE;
-  if(!ship) targetIsDead = TRUE;
-  else {
-    if(!ship->exists()) targetIsDead = TRUE;
-    else {
-      if(ship->crew<1) targetIsDead = TRUE;
-      if(ship->state==0) targetIsDead = TRUE;
+  if(!ship) 
+    targetIsDead = TRUE;
+  else 
+    {
+      if(!ship->exists()) 
+	targetIsDead = TRUE;
+      else 
+	{
+	  if(ship->crew<1) 
+	    targetIsDead = TRUE;
+	  if(ship->state==0) 
+	    targetIsDead = TRUE;
+	}
     }
-  }
   //should prevent bad pointer crashes.
-  if(!targetIsDead) {
-    this->pos = ship->pos;
-    this->vel = ship->vel;
-  }
+  if(!targetIsDead) 
+    {
+      this->pos = ship->pos;
+      this->vel = ship->vel;
+    }
   //may crash if target dies while the stun is in place.
   //targetIsDead SHOULD prevent this from happening.
-	frame_step+= frame_time;
-	while (frame_step >= frame_size) {
-		frame_step -= frame_size;
-		sprite_index++;
-		if(sprite_index == frame_count)
-			sprite_index = 0;
-		}
-	if(!(ship && ship->exists()))
-	{
-		ship = 0;
-		state = 0;
-		return;
-		}
+  frame_step+= frame_time;
+  while (frame_step >= frame_size) 
+    {
+      frame_step -= frame_size;
+      sprite_index++;
+      if(sprite_index == frame_count)
+	sprite_index = 0;
+    }
+  if(!(ship && ship->exists()))
+    {
+      ship = 0;
+      state = 0;
+      return;
+    }
 
   ship->nextkeys &= ~(keyflag::left | keyflag::right | keyflag::thrust | keyflag::special);
 
   stunframe += frame_time;
-  if (stunframe >= stunframe_count) state = 0;
-  if(targetIsDead) this->state=0;
-	SpaceObject::calculate();
-	}
+  if (stunframe >= stunframe_count) 
+    state = 0;
+  if(targetIsDead) 
+    this->state=0;
+  SpaceObject::calculate();
+}
 
 
 
@@ -357,22 +368,22 @@
   charge_frame(0),
   charge_phase(0),
   released(FALSE),
-	ship_hit(FALSE),
-	done_once(FALSE),
-	StartC(opos),
-	CD(oChargingDistance),
-	CDD(oChargingDistanceDamage)
+  ship_hit(FALSE),
+  done_once(FALSE),
+  StartC(opos),
+  CD(oChargingDistance),
+  CDD(oChargingDistanceDamage)
 {
   STACKTRACE;
-	  vel = ship->get_vel();
+  vel = ship->get_vel();
 
-	Timer  = 0;
-	MinTL  = oMinTL;
-	MaxTL  = oMaxTL;
-	Charge = oCI;
+  Timer  = 0;
+  MinTL  = oMinTL;
+  MaxTL  = oMaxTL;
+  Charge = oCI;
 
   collide_flag_anyone   = (ALL_LAYERS);
-	collide_flag_sameship = 0;
+  collide_flag_sameship = 0;
 
   explosionSprite     = data->spriteWeaponExplosion;
   explosionFrameCount = 7;
@@ -385,7 +396,8 @@
   STACKTRACE;
   if(released) 
     Shot::calculate();
-  else SpaceObject::calculate();
+  else 
+    SpaceObject::calculate();
   
   if (!exists()) 
     return;
@@ -450,7 +462,8 @@
 	  sprite_index = (get_index(ship->get_angle()) +
 			  (sprite_phase * 64));
 	}
-      else released = TRUE;
+      else 
+	released = TRUE;
       
       Timer += frame_time;
     } 
@@ -529,10 +542,6 @@
   return 0;
 }
 
-int GarashShot::canCollide(SpaceLocation *other)
-{
-  STACKTRACE;
-  return(TRUE);
-}
 REGISTER_SHIP(GarashTyrant)
+
   



From youbastrd at sheep.berlios.de  Sat Oct 16 23:23:28 2004
From: youbastrd at sheep.berlios.de (Paul Forest at BerliOS)
Date: Sat, 16 Oct 2004 23:23:28 +0200
Subject: [Tw-light-svn] r81 - branches/multiplayer-branch/source
Message-ID: <200410162123.i9GLNSjX021122@sheep.berlios.de>

Author: youbastrd
Date: 2004-10-16 23:23:27 +0200 (Sat, 16 Oct 2004)
New Revision: 81

Removed:
   branches/multiplayer-branch/source/twgui/
Log:
Removing unused TWGui stuff.  Sorry Geo!



From youbastrd at sheep.berlios.de  Mon Oct 18 22:03:45 2004
From: youbastrd at sheep.berlios.de (Paul Forest at BerliOS)
Date: Mon, 18 Oct 2004 22:03:45 +0200
Subject: [Tw-light-svn] r82 - trunk/web
Message-ID: <200410182003.i9IK3jhG009446@sheep.berlios.de>

Author: youbastrd
Date: 2004-10-18 22:03:43 +0200 (Mon, 18 Oct 2004)
New Revision: 82

Modified:
   trunk/web/team.html
   trunk/web/www.robeterproductions.com.jpg
Log:
Re-adding RobeterProductions logo, reduced in size

Modified: trunk/web/team.html
===================================================================
--- trunk/web/team.html	2004-10-16 21:23:27 UTC (rev 81)
+++ trunk/web/team.html	2004-10-18 20:03:43 UTC (rev 82)
@@ -49,7 +49,7 @@
   
   <h4>Music</h>
   <ul>
-    <li>Robeter Productions <a href=http://www.robeterproductions.com>(www.robeterproductions.com)</a></li>
+    <li>Robeter Productions <a href=http://www.robeterproductions.com>(www.robeterproductions.com)<img alt="www.robeterproductions.com Music for Film, Television, Media, Video Games.  Recording Artists, Remixes." style="float:right" src=www.robeterproductions.com.jpg /></a></li>
     <li>Mark Forest (Abe Froman)</li>
   </ul>
   
@@ -61,7 +61,6 @@
     <li>Captain Maim</li>
     <li>Jumping Peppers</li>
   </ul>
-
 </div>
 
 <p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>

Modified: trunk/web/www.robeterproductions.com.jpg
===================================================================
(Binary files differ)



From youbastrd at sheep.berlios.de  Tue Oct 19 23:59:10 2004
From: youbastrd at sheep.berlios.de (Paul Forest at BerliOS)
Date: Tue, 19 Oct 2004 23:59:10 +0200
Subject: [Tw-light-svn] r83 - trunk/web
Message-ID: <200410192159.i9JLxAw1027195@sheep.berlios.de>

Author: youbastrd
Date: 2004-10-19 23:59:09 +0200 (Tue, 19 Oct 2004)
New Revision: 83

Modified:
   trunk/web/team.html
Log:
Moving RP logo lower on Team webpage

Modified: trunk/web/team.html
===================================================================
--- trunk/web/team.html	2004-10-18 20:03:43 UTC (rev 82)
+++ trunk/web/team.html	2004-10-19 21:59:09 UTC (rev 83)
@@ -49,7 +49,7 @@
   
   <h4>Music</h>
   <ul>
-    <li>Robeter Productions <a href=http://www.robeterproductions.com>(www.robeterproductions.com)<img alt="www.robeterproductions.com Music for Film, Television, Media, Video Games.  Recording Artists, Remixes." style="float:right" src=www.robeterproductions.com.jpg /></a></li>
+    <li>Robeter Productions <a href=http://www.robeterproductions.com>(www.robeterproductions.com)</a></li>
     <li>Mark Forest (Abe Froman)</li>
   </ul>
   
@@ -60,10 +60,13 @@
     <li>Officer Flubbo</li>
     <li>Captain Maim</li>
     <li>Jumping Peppers</li>
+    <li><a href=http://www.robeterproductions.com>Robeter Productions</a></li>
   </ul>
+  <a href=http://www.robeterproductions.com><img alt="www.robeterproductions.com Music for Film, Television, Media, Video Games.  Recording Artists, Remixes." style="" src=www.robeterproductions.com.jpg /></a>
+  
 </div>
 
-<p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
+<p align="left"><font size="3"><strong>This page is hosted by</strong></font></p>
 <table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
 </td></tr></table>



From youbastrd at sheep.berlios.de  Wed Oct 20 10:05:49 2004
From: youbastrd at sheep.berlios.de (Paul Forest at BerliOS)
Date: Wed, 20 Oct 2004 10:05:49 +0200
Subject: [Tw-light-svn] r84 - in branches/multiplayer-branch: . doc source source/ais source/games source/libraries/raknet source/melee source/other source/sc1ships source/sc2ships source/ships
Message-ID: <200410200805.i9K85nQG008325@sheep.berlios.de>

Author: youbastrd
Date: 2004-10-20 10:05:48 +0200 (Wed, 20 Oct 2004)
New Revision: 84

Added:
   branches/multiplayer-branch/source/games/gup.cpp
   branches/multiplayer-branch/source/games/gup.h
   branches/multiplayer-branch/source/melee/MultiplayerTypes.h
   branches/multiplayer-branch/source/melee/PresenceRegistry.cpp
   branches/multiplayer-branch/source/melee/PresenceRegistry.h
   branches/multiplayer-branch/source/sc1ships/sc1ships.h
   branches/multiplayer-branch/source/sc2ships/sc2ships.h
Removed:
   branches/multiplayer-branch/source/other/gup.cpp
   branches/multiplayer-branch/source/other/gup.h
   branches/multiplayer-branch/source/sc1ships.h
   branches/multiplayer-branch/source/sc2ships.h
Modified:
   branches/multiplayer-branch/doc/Doxyfile
   branches/multiplayer-branch/makefile
   branches/multiplayer-branch/source/ais.h
   branches/multiplayer-branch/source/ais/c_wussie.cpp
   branches/multiplayer-branch/source/frame.cpp
   branches/multiplayer-branch/source/frame.h
   branches/multiplayer-branch/source/games/MultiplayerGame.cpp
   branches/multiplayer-branch/source/games/MultiplayerGame.h
   branches/multiplayer-branch/source/games/gflmelee.h
   branches/multiplayer-branch/source/games/ggob.cpp
   branches/multiplayer-branch/source/games/gmelee.cpp
   branches/multiplayer-branch/source/games/gmelee.h
   branches/multiplayer-branch/source/gui.cpp
   branches/multiplayer-branch/source/gui.h
   branches/multiplayer-branch/source/id.h
   branches/multiplayer-branch/source/input.cpp
   branches/multiplayer-branch/source/input.h
   branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObjectHeader.h
   branches/multiplayer-branch/source/melee.h
   branches/multiplayer-branch/source/melee/manim.cpp
   branches/multiplayer-branch/source/melee/manim.h
   branches/multiplayer-branch/source/melee/mcbodies.cpp
   branches/multiplayer-branch/source/melee/mcbodies.h
   branches/multiplayer-branch/source/melee/mcontrol.cpp
   branches/multiplayer-branch/source/melee/mcontrol.h
   branches/multiplayer-branch/source/melee/mfleet.cpp
   branches/multiplayer-branch/source/melee/mfleet.h
   branches/multiplayer-branch/source/melee/mframe.cpp
   branches/multiplayer-branch/source/melee/mframe.h
   branches/multiplayer-branch/source/melee/mgame.h
   branches/multiplayer-branch/source/melee/mhelpers.cpp
   branches/multiplayer-branch/source/melee/mitems.cpp
   branches/multiplayer-branch/source/melee/mitems.h
   branches/multiplayer-branch/source/melee/mlog.cpp
   branches/multiplayer-branch/source/melee/mlog.h
   branches/multiplayer-branch/source/melee/mmath.cpp
   branches/multiplayer-branch/source/melee/mnet1.cpp
   branches/multiplayer-branch/source/melee/mnet1.h
   branches/multiplayer-branch/source/melee/moptions.cpp
   branches/multiplayer-branch/source/melee/moptions.h
   branches/multiplayer-branch/source/melee/mship.cpp
   branches/multiplayer-branch/source/melee/mship.h
   branches/multiplayer-branch/source/melee/mshot.cpp
   branches/multiplayer-branch/source/melee/mshot.h
   branches/multiplayer-branch/source/melee/mshpdata.cpp
   branches/multiplayer-branch/source/melee/mshppan.cpp
   branches/multiplayer-branch/source/melee/mshppan.h
   branches/multiplayer-branch/source/melee/msprite.cpp
   branches/multiplayer-branch/source/melee/mtarget.cpp
   branches/multiplayer-branch/source/melee/mtarget.h
   branches/multiplayer-branch/source/melee/mview.cpp
   branches/multiplayer-branch/source/melee/mview.h
   branches/multiplayer-branch/source/other/configrw.cpp
   branches/multiplayer-branch/source/other/configrw.h
   branches/multiplayer-branch/source/other/dialogs.cpp
   branches/multiplayer-branch/source/other/dialogs.h
   branches/multiplayer-branch/source/other/fontmorph.cpp
   branches/multiplayer-branch/source/other/fontmorph.h
   branches/multiplayer-branch/source/other/nullphas.cpp
   branches/multiplayer-branch/source/other/nullphas.h
   branches/multiplayer-branch/source/other/objanim.cpp
   branches/multiplayer-branch/source/other/objanim.h
   branches/multiplayer-branch/source/other/orbit.cpp
   branches/multiplayer-branch/source/other/orbit.h
   branches/multiplayer-branch/source/other/planet3d.cpp
   branches/multiplayer-branch/source/other/planet3d.h
   branches/multiplayer-branch/source/other/radar.cpp
   branches/multiplayer-branch/source/other/radar.h
   branches/multiplayer-branch/source/other/shippart.cpp
   branches/multiplayer-branch/source/other/shippart.h
   branches/multiplayer-branch/source/other/twconfig.cpp
   branches/multiplayer-branch/source/other/twconfig.h
   branches/multiplayer-branch/source/other/vbodies.cpp
   branches/multiplayer-branch/source/other/vbodies.h
   branches/multiplayer-branch/source/other/vtarget.cpp
   branches/multiplayer-branch/source/other/vtarget.h
   branches/multiplayer-branch/source/sc1ships/shpandgu.cpp
   branches/multiplayer-branch/source/sc1ships/shparisk.cpp
   branches/multiplayer-branch/source/sc1ships/shpchebr.cpp
   branches/multiplayer-branch/source/sc1ships/shpearcr.cpp
   branches/multiplayer-branch/source/sc1ships/shpilwav.cpp
   branches/multiplayer-branch/source/sc1ships/shpkzedr.cpp
   branches/multiplayer-branch/source/sc1ships/shpmmrxf.cpp
   branches/multiplayer-branch/source/sc1ships/shpmycpo.cpp
   branches/multiplayer-branch/source/sc1ships/shpshosc.cpp
   branches/multiplayer-branch/source/sc1ships/shpspael.cpp
   branches/multiplayer-branch/source/sc1ships/shpsyrpe.cpp
   branches/multiplayer-branch/source/sc1ships/shpumgdr.cpp
   branches/multiplayer-branch/source/sc1ships/shpvuxin.cpp
   branches/multiplayer-branch/source/sc1ships/shpyehte.cpp
   branches/multiplayer-branch/source/sc2ships/shpchmav.cpp
   branches/multiplayer-branch/source/sc2ships/shpdruma.cpp
   branches/multiplayer-branch/source/sc2ships/shpkohma.cpp
   branches/multiplayer-branch/source/sc2ships/shpmeltr.cpp
   branches/multiplayer-branch/source/sc2ships/shporzne.cpp
   branches/multiplayer-branch/source/sc2ships/shppkufu.cpp
   branches/multiplayer-branch/source/sc2ships/shpslypr.cpp
   branches/multiplayer-branch/source/sc2ships/shpsupbl.cpp
   branches/multiplayer-branch/source/sc2ships/shpthrto.cpp
   branches/multiplayer-branch/source/sc2ships/shputwju.cpp
   branches/multiplayer-branch/source/sc2ships/shpzfpst.cpp
   branches/multiplayer-branch/source/scp.cpp
   branches/multiplayer-branch/source/scp.h
   branches/multiplayer-branch/source/ship.h
   branches/multiplayer-branch/source/ships/shpaktgu.cpp
   branches/multiplayer-branch/source/ships/shpalabc.cpp
   branches/multiplayer-branch/source/ships/shpbahbu.cpp
   branches/multiplayer-branch/source/ships/shpbipka.cpp
   branches/multiplayer-branch/source/ships/shpbogce.cpp
   branches/multiplayer-branch/source/ships/shpchoex.cpp
   branches/multiplayer-branch/source/ships/shpconca.cpp
   branches/multiplayer-branch/source/ships/shpconho.cpp
   branches/multiplayer-branch/source/ships/shpdragr.cpp
   branches/multiplayer-branch/source/ships/shpearc3.cpp
   branches/multiplayer-branch/source/ships/shpforsh.cpp
   branches/multiplayer-branch/source/ships/shpgarty.cpp
   branches/multiplayer-branch/source/ships/shpilwsp.cpp
   branches/multiplayer-branch/source/ships/shpilwsp.h
   branches/multiplayer-branch/source/ships/shpkahbo.cpp
   branches/multiplayer-branch/source/ships/shprogsq.cpp
   branches/multiplayer-branch/source/ships/shpstaba.cpp
   branches/multiplayer-branch/source/ships/shptauar.cpp
   branches/multiplayer-branch/source/ships/shptauda.cpp
   branches/multiplayer-branch/source/ships/shptaume.cpp
   branches/multiplayer-branch/source/ships/shptausl.cpp
   branches/multiplayer-branch/source/ships/shptaust.cpp
   branches/multiplayer-branch/source/ships/shptauto.cpp
   branches/multiplayer-branch/source/ships/shpwolmi.cpp
   branches/multiplayer-branch/source/ships/shpyusra.cpp
   branches/multiplayer-branch/source/ships/shpzeksh.cpp
   branches/multiplayer-branch/sources.lst
Log:
many, many changes: added PresenceRegistry class, forced many subclasses of Presence to register themselves with a macro.  Renamed a few files.  Updated the header of many files to point to tw-light's webpage, rather than timewarp's webpage.  Forced the source.lst file to be a subset of all files to avoid unnecessary complications (the only ship that's available is the Yehat Terminator).  A few bug fixes involving pointers... and probably introduced many more. :( Many no-arg constructors are presently unstable.  Added makefile target "run-multiplayer", which starts up a server, and creates a client which connects locally.  

When this branch is stable, I'll break up the changes into more meaningful and atomic revisions when adding to the trunk.  

This revision is barely able to compile, let alone run properly.  It's a very rough work in progress.  

Modified: branches/multiplayer-branch/doc/Doxyfile
===================================================================
--- branches/multiplayer-branch/doc/Doxyfile	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/doc/Doxyfile	2004-10-20 08:05:48 UTC (rev 84)
@@ -166,7 +166,7 @@
 INCLUDE_FILE_PATTERNS  = 
 PREDEFINED             = 
 EXPAND_AS_DEFINED      = 
-SKIP_FUNCTION_MACROS   = YES
+SKIP_FUNCTION_MACROS   = NO
 #---------------------------------------------------------------------------
 # Configuration::addtions related to external references   
 #---------------------------------------------------------------------------

Modified: branches/multiplayer-branch/makefile
===================================================================
--- branches/multiplayer-branch/makefile	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/makefile	2004-10-20 08:05:48 UTC (rev 84)
@@ -29,6 +29,7 @@
 CX = g++
 RC = windres
 LD = g++
+GDB = gdb
 
 CFLAGS = -fsigned-char -Wall -Wno-deprecated-declarations
 OBJDIR = obj
@@ -150,6 +151,9 @@
 OBJS += $(OBJDIR)/winicon.o
 endif
 
+ifdef DEBUG
+NAME = $(addprefix $(NAME)/,$(GDB))
+endif
 
 ##############################################################################
 
@@ -202,6 +206,12 @@
 add_stacktrace:
 	find source -name '*.cpp'|grep -v 'libraries'|grep -v 'errors.cpp'|grep -v 'utils.cpp'|xargs ./Util/addStackTrace.pl 
 
+run: all
+	$(NAME)
+
+run-multiplayer: all
+	$(NAME) -play game MultiplayerGameServer & sleep 3 && $(NAME) -play game MultiplayerGameClient
+
 install:
 	./install-sh $(NAME) $(EXECPATH)/$(NAME)
 	./install-sh gamedata $(DATAPATH)

Modified: branches/multiplayer-branch/source/ais/c_wussie.cpp
===================================================================
--- branches/multiplayer-branch/source/ais/c_wussie.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ais/c_wussie.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,6 +1,6 @@
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ais.h
===================================================================
--- branches/multiplayer-branch/source/ais.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ais.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: ais.h,v 1.1.1.1 2004/08/01 10:21:18 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/frame.cpp
===================================================================
--- branches/multiplayer-branch/source/frame.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/frame.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: frame.cpp,v 1.1.1.1 2004/08/01 10:21:18 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/frame.h
===================================================================
--- branches/multiplayer-branch/source/frame.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/frame.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: frame.h,v 1.1.1.1 2004/08/01 10:21:18 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -18,6 +18,8 @@
 #ifndef __FRAME_H__
 #define __FRAME_H__
 
+#include "melee.h"
+    
 typedef struct DirtyItem {
   int x, y, a, b;
 

Modified: branches/multiplayer-branch/source/games/MultiplayerGame.cpp
===================================================================
--- branches/multiplayer-branch/source/games/MultiplayerGame.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/games/MultiplayerGame.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,6 @@
-/* $Id: melee.h,v 1.3 2004/08/08 17:36:03 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -20,7 +19,8 @@
 
 #include "libraries/raknet/RakClientInterface.h"
 #include "libraries/raknet/RakServerInterface.h"
-//#include "Raknet/RakNetworkFactory.h"	
+#include "Raknet/RakNetworkFactory.h"	
+#include "melee/PresenceRegistry.h"
 
 // If you don't want to use distributed network objects, delete this include
 #include "../libraries/raknet/DistributedNetworkObjectManager.h"
@@ -29,143 +29,164 @@
 #include <assert.h>
 #include <stdio.h>
 #include "../libraries/raknet/GetTime.h"
-	
+#include <iostream>	
 
-//#ifdef DEBUG
+#ifdef DEBUGMODE
+    #define _DEBUG
+#endif
+#ifdef DEBUG
 	#define _DEBUG
-//#endif
+#endif
 
 #ifdef _DEBUG
 #include <memory.h>
 #endif
 
+
 template <class InterfaceType>
 MultiplayerGameTemplate<InterfaceType>::MultiplayerGameTemplate() :
-	_isServer(false)
+    server(RakNetworkFactory::GetRakServerInterface()),
+    client(RakNetworkFactory::GetRakClientInterface()),
+    networkInterface(NULL),
+    _isServer(false)
 {
     message.print(5000,15,"Game on!");
+    cout << "gametype constructor:" << endl;
+    PresenceRegistry::GetInstance()->toString();
 }
 
 template <class InterfaceType>
 MultiplayerGameTemplate<InterfaceType>::~MultiplayerGameTemplate()
 {
+    RakNetworkFactory::DestroyRakServerInterface(server);
+    RakNetworkFactory::DestroyRakClientInterface(client);
 }
 
+
 template <class InterfaceType>
-void MultiplayerGameTemplate<InterfaceType>::ProcessPackets(InterfaceType *interfaceType)
-{
-	Packet* p;
-	unsigned char packetIdentifier;
+void MultiplayerGameTemplate<InterfaceType>::init(Log *log) { 
+    Game::init(log); 
+    prepare();
+    
+    asteroid = new Asteroid();
+    add(asteroid);
 
-	p = interfaceType->Receive();
+    stars = new Stars();
+    add( stars );
+    
+    yehat = new YehatTerminator(Vector2(0,0), 0, );
+    add( yehat );
+    
+    if (isServer()) {
+    	//printf("server:init");
+    	//PresenceRegistry::GetInstance()->toString();        	
+    	//Stars * stars = new Stars();
+    	//printf("server:init: adding stars with (%s:%d)\n", stars->GetClassName(), stars->GetClassID());
+    	//PresenceRegistry::GetInstance()->toString();
+	    //add( stars );
+	    //add(new Asteroid());
+	    
+        
+		/*
+        add(new Asteroid());
+        add(new Asteroid());*/
+    }
+}
 
-	while (p)
-	{
-		if ((unsigned char)p->data[0] == ID_TIMESTAMP)
-		{
-			if (p->length > sizeof(unsigned char) + sizeof(unsigned long))
-				packetIdentifier = (unsigned char) p->data[sizeof(unsigned char) + sizeof(unsigned long)];
-			else
-				break;
-		}
-		else
-			packetIdentifier = (unsigned char) p->data[0];
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::calculate() { 
+	Game::calculate(); 
+	ProcessPackets(networkInterface);
+}
 
-		// Check if this is a native packet
-		switch (packetIdentifier)
-		{
-		case ID_REMOTE_DISCONNECTION_NOTIFICATION:
-			ReceiveRemoteDisconnectionNotification(p,interfaceType);
-		    message.print(5000,15,"client : told to bugger off");
-		break;
-		case ID_REMOTE_CONNECTION_LOST:
-			ReceiveRemoteConnectionLost(p,interfaceType);
-		    message.print(5000,15,"client lost connection");
-		break;
-		case ID_REMOTE_NEW_INCOMING_CONNECTION:
-			ReceiveRemoteNewIncomingConnection(p,interfaceType);
-			message.print(5000,15,"Got a new connection!");
-		break;
-		case ID_REMOTE_EXISTING_CONNECTION:
-			ReceiveRemoteExistingConnection(p,interfaceType);
-		    message.print(5000,15,"Player leaving");
-		break;
-		case ID_CONNECTION_BANNED:
-			ReceiveConnectionBanned(p, interfaceType);
-		break;
-		case ID_CONNECTION_REQUEST_ACCEPTED:
-			ReceiveConnectionRequestAccepted(p,interfaceType);
-		    message.print(5000,15,"We're allowed to connect!!");
-			break;
-		case ID_NEW_INCOMING_CONNECTION:
-			ReceiveNewIncomingConnection(p,interfaceType);
-			break;
-		case ID_NO_FREE_INCOMING_CONNECTIONS:
-			ReceiveNoFreeIncomingConnections(p,interfaceType);
-			break;
-		case ID_DISCONNECTION_NOTIFICATION:
-			ReceiveDisconnectionNotification(p,interfaceType);
-			break;
-		case ID_CONNECTION_LOST:
-			ReceiveConnectionLost(p,interfaceType);
-			break;
-		case ID_RECEIVED_STATIC_DATA:
-			ReceivedStaticData(p,interfaceType);
-			break;
-		case ID_INVALID_PASSWORD:
-			ReceiveInvalidPassword(p,interfaceType);
-			break;
-		case ID_MODIFIED_PACKET:
-			ReceiveModifiedPacket(p,interfaceType);
-			break;
-		case ID_REMOTE_PORT_REFUSED:
-			ReceiveRemotePortRefused(p,interfaceType);
-			break;
-		case ID_VOICE_PACKET:
-			ReceiveVoicePacket(p,interfaceType);
-			break;
-		case ID_PONG:
-			ReceivePong(p,interfaceType);
-			break;
-		case ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT:
-			ReceiveDistributedNetworkObject(p,interfaceType);
-			break;
-		case ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_ACCEPTED:
-			ReceiveDistributedNetworkObjectCreationAccepted(p,interfaceType);
-			break;
-		case ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_REJECTED:
-			ReceiveDistributedNetworkObjectCreationRejected(p,interfaceType);
-			break;
-		case ID_AUTOPATCHER_REQUEST_FILE_LIST:
-			ReceiveAutopatcherRequestFileList(p,interfaceType);
-			break;
-		case ID_AUTOPATCHER_FILE_LIST:
-			ReceiveAutopatcherFileList(p,interfaceType);
-			break;
-		case ID_AUTOPATCHER_REQUEST_FILES:
-			ReceiveAutopatcherRequestFiles(p,interfaceType);
-			break;
-		case ID_AUTOPATCHER_SET_DOWNLOAD_LIST:
-			ReceiveAutopatcherSetDownloadList(p,interfaceType);
-			break;
-		case ID_AUTOPATCHER_WRITE_FILE:
-			ReceiveAutopatcherWriteFile(p,interfaceType);
-			break;
-		default:
-			// If not a native packet send it to ProcessUnhandledPacket which should have been written by the user
-			ProcessUnhandledPacket(p, packetIdentifier,interfaceType);
-			break;
-		}
 
-		interfaceType->DeallocatePacket(p);
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::add(SpaceLocation *p)
+{
+    Game::add(p);
+    _add(p);
+}
+    
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::add(Presence *p) 
+{
+    Game::add(p);   
+    _add(p);
+}
 
-		p = interfaceType->Receive();
-	}
+template <class InterfaceType>
+void MultiplayerGameTemplate<InterfaceType>::_add(Presence *p) 
+{
+    if (isServer()) {
+    	printf("adding: (%s:%d) ObjectID=%d ", p->GetClassName(), p->GetClassID(), p->GetObjectID());
+        PresenceCreationDescription pc( p->GetObjectID(), p->GetClassID() );
+        printf("as (%s:%d)\n", 
+        	PresenceRegistry::GetInstance()->getClassName(pc.presenceType),
+        	pc.presenceType);
+        
+        bool b = server->Send((char*)&pc, sizeof(PresenceCreationDescription), HIGH_PRIORITY, RELIABLE_ORDERED, 0, UNASSIGNED_PLAYER_ID, true);
+        if (!b)
+        	tw_error("couldn't send packet in MPGame::_add()");
+    }
 }
 
+
 template <class InterfaceType>
 void MultiplayerGameTemplate<InterfaceType>::ProcessUnhandledPacket(Packet *p, unsigned char packetIdentifier, InterfaceType *interfaceType)
 {
+	printf("got an unhandled packet packetIdentifier=%d", packetIdentifier);
+    switch (packetIdentifier) {
+        case ID_PRESENCE_CREATION:
+        {
+            //if (isServer())
+            //    return;
+            printf(" (presence creation)");
+            PresenceCreationDescription * pc = (PresenceCreationDescription*) p->data;
+        
+            assert(p->length == sizeof(PresenceCreationDescription));
+            if (p->length != sizeof(PresenceCreationDescription)) {
+                tw_error("Got a PresenceCreationDescription request that was the wrong size.");
+                return;
+            }
+            
+            assert(GET_OBJECT_FROM_ID(pc->objectId) == NULL);
+            if (GET_OBJECT_FROM_ID(pc->objectId) != NULL) {
+                tw_error("Got a PresenceCreationDescription request for an object that already exists.");
+                return;
+            }
+            
+            message.print(15000,15,"Got a presence creation packet, it's a %s", PresenceRegistry::GetInstance()->getClassName(pc->presenceType));
+            printf("Got a presence creation packet, it's a %s", PresenceRegistry::GetInstance()->getClassName(pc->presenceType));
+            
+            //Presence * presence = PresenceRegistry::GetInstance()->createPresenceFromNetworkDescription(pc);
+            Presence * presence = PresenceRegistry::GetInstance()->GetPresenceClassDefaultInstance(pc->presenceType);
+            Game::add(presence);
+            
+//            switch (pc->presenceType) {
+//                case PT_ASTEROID:
+//                    add(new Asteroid());
+//                    break;*/
+//                
+//                case PT_YEHAT_TERMINATOR:
+//                   {TeamCode human = new_team();
+//                    Control *c = create_control(channel_server, "Human");
+//                    Ship *s = create_ship("yehte", c, Vector2(size.x/2,size.y/2), 0, human);
+//                    add(s->get_ship_phaser());
+//                    add_focus(s);}
+//                    break;
+//                
+//                case PT_UNKNOWN:
+//                default:
+//                    message.print(10000,15,"Tried to add unknown object: %s", p->data);
+//                    ;
+//            };
+        }
+        break;
+        
+        default:
+            message.print(5000,15,"Unknown data: %s", p->data);
+    };
+    
 	// Remove the annoying warnings
 	//packetIdentifier;
 	//interfaceType;
@@ -180,24 +201,25 @@
 //	message.print(5000,15,"MultiplayerGameTemplate::ProcessUnhandledPacket (%i) (%i): ", packetNumber++, p->length);
 //	for (i=0; i < p->length; i++)
 //	message.print(5000,15,"%i ",p->data[i]);
-//	message.print(5000,15,"\n");
+//	message.print(5000,15,"");
 	
 
 	// Uncomment this to show output as a string
 	
 	// Raw output (string)
-	message.print(5000,15,"%s\n", p->data);
+
 	
 #endif
+	printf("\n");
 }
 
 template <class InterfaceType>
 void MultiplayerGameTemplate<InterfaceType>::ReceiveRemoteDisconnectionNotification(Packet *packet,InterfaceType *interfaceType)
 {
 	// Another system has disconnected.  Client only.
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_REMOTE_DISCONNECTION_NOTIFICATION from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_REMOTE_DISCONNECTION_NOTIFICATION from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 //	ProcessUnhandledPacket(packet, ID_REMOTE_DISCONNECTION_NOTIFICATION,interfaceType);
 }
 
@@ -205,9 +227,9 @@
 void MultiplayerGameTemplate<InterfaceType>::ReceiveRemoteConnectionLost(Packet *packet,InterfaceType *interfaceType)
 {
 	// Another system has been dropped by the server.  Client only.
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_REMOTE_CONNECTION_LOST from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_REMOTE_CONNECTION_LOST from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 //	ProcessUnhandledPacket(packet, ID_REMOTE_CONNECTION_LOST,interfaceType);
 }
 
@@ -215,9 +237,9 @@
 void MultiplayerGameTemplate<InterfaceType>::ReceiveRemoteNewIncomingConnection(Packet *packet,InterfaceType *interfaceType)
 {
 	// Another system has connected.  Client only.
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_REMOTE_NEW_INCOMING_CONNECTION from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_REMOTE_NEW_INCOMING_CONNECTION from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 //	ProcessUnhandledPacket(packet, ID_REMOTE_NEW_INCOMING_CONNECTION,interfaceType);
 }
 
@@ -227,9 +249,9 @@
 	// We just connected to the server and are getting a list of players already connected
 	// Note due to thread timing you might get both this and ID_REMOTE_NEW_INCOMING_CONNECTION when first connecting.
 	//  Client only.
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_REMOTE_EXISTING_CONNECTION from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_REMOTE_EXISTING_CONNECTION from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 	//	ProcessUnhandledPacket(packet, ID_REMOTE_EXISTING_CONNECTION,interfaceType);
 }
 
@@ -238,9 +260,9 @@
 {
 	// We are banned from connecting to the system specified in packet->playerId
 	// Peer or client
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_CONNECTION_BANNED from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_CONNECTION_BANNED from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 	//	ProcessUnhandledPacket(packet, ID_REMOTE_EXISTING_CONNECTION,interfaceType);
 }
 
@@ -250,9 +272,9 @@
 {
     message.print(5000,15,"We're accepted to connect");
 	// Our request to connect to another system has been accepted.  Client only.
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_CONNECTION_REQUEST_ACCEPTED from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_CONNECTION_REQUEST_ACCEPTED from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 //	ProcessUnhandledPacket(packet, ID_CONNECTION_REQUEST_ACCEPTED,interfaceType);
 }
 
@@ -260,9 +282,17 @@
 void MultiplayerGameTemplate<InterfaceType>::ReceiveNewIncomingConnection(Packet *packet, InterfaceType *interfaceType)
 {
 	// Another system has requested to connect to us, which we have accepted.  Server or peer only.
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_NEW_INCOMING_CONNECTION from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+    message.print(10000,15,"%s has connected", ((StaticClientDataStruct*)(server->GetStaticClientData(packet->playerId))->GetData())->name);
+    
+    TeamCode human = new_team();
+    Control *c = create_control(channel_server, "Human");
+    Ship *s = create_ship("yehte", c, Vector2(size.x/2,size.y/2), 0, human);
+    add(s->get_ship_phaser());
+    add_focus(s);
+  
+#ifdef _DEBUG
+	message.print(5000,15,"ID_NEW_INCOMING_CONNECTION from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 //	ProcessUnhandledPacket(packet, ID_NEW_INCOMING_CONNECTION,interfaceType);
 
 	// This will send all existing distributed objects to the new player
@@ -275,9 +305,9 @@
 void MultiplayerGameTemplate<InterfaceType>::ReceiveConnectionResumption(Packet *packet, InterfaceType *interfaceType)
 {
 	// Someone who was already connected to us connected again.  Server or peer only.
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_CONNECTION_RESUMPTION from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_CONNECTION_RESUMPTION from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 //	ProcessUnhandledPacket(packet, ID_CONNECTION_RESUMPTION,interfaceType);
 }
 
@@ -287,9 +317,9 @@
 	// The system we connected to has no free slots to connect to
 	// Set free slots by calling SetMaximumIncomingConnections
 	// Client or peer only.
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_NO_FREE_INCOMING_CONNECTIONS from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_NO_FREE_INCOMING_CONNECTIONS from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 //	ProcessUnhandledPacket(packet, ID_NO_FREE_INCOMING_CONNECTIONS,interfaceType);
 }
 
@@ -297,9 +327,9 @@
 void MultiplayerGameTemplate<InterfaceType>::ReceiveDisconnectionNotification(Packet *packet, InterfaceType *interfaceType)
 {
 	// A remote system terminated the connection.  packet->playerId specifies which remote system
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_DISCONNECTION_NOTIFICATION from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_DISCONNECTION_NOTIFICATION from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 //	ProcessUnhandledPacket(packet, ID_DISCONNECTION_NOTIFICATION,interfaceType);
 }
 
@@ -307,9 +337,9 @@
 void MultiplayerGameTemplate<InterfaceType>::ReceiveConnectionLost(Packet *packet, InterfaceType *interfaceType)
 {
 	// The network cannot send reliable packets so has terminated the connection. packet->playerId specifies which remote system
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_CONNECTION_LOST from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_CONNECTION_LOST from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 //	ProcessUnhandledPacket(packet, ID_CONNECTION_LOST,interfaceType);
 }
 
@@ -317,9 +347,9 @@
 void MultiplayerGameTemplate<InterfaceType>::ReceivedStaticData(Packet *packet, InterfaceType *interfaceType)
 {
 	// Another system has just sent their static data to us (which we recorded automatically)
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_RECEIVED_STATIC_DATA from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_RECEIVED_STATIC_DATA from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 //	ProcessUnhandledPacket(packet, ID_RECEIVED_STATIC_DATA,interfaceType);
 }
 
@@ -327,9 +357,9 @@
 void MultiplayerGameTemplate<InterfaceType>::ReceiveInvalidPassword(Packet *packet, InterfaceType *interfaceType)
 {
 	// Our connection to another system was refused because the passwords do not match
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_INVALID_PASSWORD from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_INVALID_PASSWORD from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 //	ProcessUnhandledPacket(packet, ID_INVALID_PASSWORD,interfaceType);
 }
 
@@ -338,9 +368,9 @@
 {
 	// The network layer has detected packet tampering
 	// This does NOT automatically close the connection
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_MODIFIED_PACKET from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_MODIFIED_PACKET from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 //	ProcessUnhandledPacket(packet, ID_MODIFIED_PACKET,interfaceType);
 }
 
@@ -348,9 +378,9 @@
 void MultiplayerGameTemplate<InterfaceType>::ReceiveRemotePortRefused(Packet *packet, InterfaceType *interfaceType)
 {
 	// The remote system has responded with ICMP_PORT_UNREACHABLE
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_REMOTE_PORT_REFUSED from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_REMOTE_PORT_REFUSED from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 //	ProcessUnhandledPacket(packet, ID_REMOTE_PORT_REFUSED,interfaceType);
 }
 
@@ -358,9 +388,9 @@
 void MultiplayerGameTemplate<InterfaceType>::ReceiveVoicePacket(Packet *packet, InterfaceType *interfaceType)
 {
 	// We got a voice packet
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_VOICE_PACKET from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_VOICE_PACKET from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 //	ProcessUnhandledPacket(packet, ID_VOICE_PACKET,interfaceType);
 }
 
@@ -371,7 +401,7 @@
 //#ifdef _DEBUG
 	unsigned long time;
 	memcpy((char*)&time, packet->data+sizeof(unsigned char), sizeof(unsigned long));
-	message.print(5000,15,"ID_PONG from PlayerID:%u:%u on %p. Value is %i\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType, time);
+	message.print(5000,15,"ID_PONG from PlayerID:%u:%u on %p. Value is %i",packet->playerId.binaryAddress, packet->playerId.port, interfaceType, time);
 //#endif
 	//	ProcessUnhandledPacket(packet, ID_PONG,interfaceType);
 }
@@ -380,9 +410,9 @@
 void MultiplayerGameTemplate<InterfaceType>::ReceiveDistributedNetworkObject(Packet *packet,InterfaceType *interfaceType)
 {
 	// Packet to create a distributed network object
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 
 	#ifdef __DISTRIBUTED_NETWORK_OBJECT_MANAGER_H
 
@@ -401,9 +431,9 @@
 void MultiplayerGameTemplate<InterfaceType>::ReceiveDistributedNetworkObjectCreationAccepted(Packet *packet,InterfaceType *interfaceType)
 {
 	// Client only - creation of a distributed network object was accepted
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_ACCEPTED from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_ACCEPTED from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 
 #ifdef __DISTRIBUTED_NETWORK_OBJECT_MANAGER_H
 	// This packet is only valid if the client was registered with the DistributedNetworkObjectManager
@@ -418,9 +448,9 @@
 void MultiplayerGameTemplate<InterfaceType>::ReceiveDistributedNetworkObjectCreationRejected(Packet *packet,InterfaceType *interfaceType)
 {
 	// Client only - creation of a distributed network object was accepted
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_REJECTED from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_REJECTED from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 
 #ifdef __DISTRIBUTED_NETWORK_OBJECT_MANAGER_H
 	// This packet is only valid if the client was registered with the DistributedNetworkObjectManager
@@ -436,9 +466,9 @@
 {
 	// Request for a list of files served by the autopatcher.
 	// Send to Autopatcher::SendDownloadableFileList(packet->playerId)
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_AUTOPATCHER_REQUEST_FILE_LIST from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_AUTOPATCHER_REQUEST_FILE_LIST from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 	// ProcessUnhandledPacket(packet, ID_AUTOPATCHER_REQUEST_FILE_LIST,interfaceType);
 }
 
@@ -447,9 +477,9 @@
 {
 	// Got a list of files served by a remote autopatcher
 	// Send to Autopatcher::OnAutopatcherFileList(packet, bool);
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_AUTOPATCHER_FILE_LIST from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_AUTOPATCHER_FILE_LIST from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 	// ProcessUnhandledPacket(packet, ID_AUTOPATCHER_FILE_LIST,interfaceType);
 }
 
@@ -458,9 +488,9 @@
 {
 	// Got a request for a set of files from our autopatcher
 	// Send to Autopatcher::OnAutopatcherRequestFiles(packet);
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_AUTOPATCHER_REQUEST_FILES from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_AUTOPATCHER_REQUEST_FILES from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 	// ProcessUnhandledPacket(packet, ID_AUTOPATCHER_REQUEST_FILES,interfaceType);
 }
 
@@ -469,9 +499,9 @@
 {
 	// Got confirmation of what files we are about to get from the remote autopatcher
 	// Send to Autopatcher::OnAutopatcherSetDownloadList(packet);
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_AUTOPATCHER_SET_DOWNLOAD_LIST from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_AUTOPATCHER_SET_DOWNLOAD_LIST from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 	// ProcessUnhandledPacket(packet, ID_AUTOPATCHER_SET_DOWNLOAD_LIST,interfaceType);
 }
 
@@ -480,28 +510,28 @@
 {
 	// Got a file from a remote autopatcher
 	// Send to Autopatcher::OnAutopatcherWriteFile(packet);
-//#ifdef _DEBUG
-	message.print(5000,15,"ID_AUTOPATCHER_WRITE_FILE from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
-//#endif
+#ifdef _DEBUG
+	message.print(5000,15,"ID_AUTOPATCHER_WRITE_FILE from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
 	// ProcessUnhandledPacket(packet, ID_AUTOPATCHER_WRITE_FILE,interfaceType);
 };
 
 // Copied from Multiplayer.cpp
 // If the first byte is ID_TIMESTAMP, then we want the 5th byte
 // Otherwise we want the 1st byte
-unsigned char GetPacketIdentifier(Packet *p)
-{
-	if (p==0)
-		return 255;
+//unsigned char GetPacketIdentifier(Packet *p)
+//{
+//	if (p==0)
+//		return 255;
+//
+//	if ((unsigned char)p->data[0] == ID_TIMESTAMP)
+//	{
+//		assert(p->length > sizeof(unsigned char) + sizeof(unsigned long));
+//		return (unsigned char) p->data[sizeof(unsigned char) + sizeof(unsigned long)];
+//	}
+//	else
+//		return (unsigned char) p->data[0];
+//}
 
-	if ((unsigned char)p->data[0] == ID_TIMESTAMP)
-	{
-		assert(p->length > sizeof(unsigned char) + sizeof(unsigned long));
-		return (unsigned char) p->data[sizeof(unsigned char) + sizeof(unsigned long)];
-	}
-	else
-		return (unsigned char) p->data[0];
-}
-
 REGISTER_GAME(MultiplayerGameClient, "MultiplayerGameClient")
 REGISTER_GAME(MultiplayerGameServer, "MultiplayerGameServer")

Modified: branches/multiplayer-branch/source/games/MultiplayerGame.h
===================================================================
--- branches/multiplayer-branch/source/games/MultiplayerGame.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/games/MultiplayerGame.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,6 @@
-/* $Id: melee.h,v 1.3 2004/08/08 17:36:03 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -24,19 +23,9 @@
 #include "frame.h"
 #include "melee/mgame.h"
 #include "melee/mview.h"
-
-//#include "games/gmelee.h"
-//#include "melee/mview.h"
-//#include "melee/mcontrol.h"
-//#include "other/planet3d.h"
-////#include "mshppan.h"
-//#include "melee/mship.h"
-//#include "melee/mlog.h"
-////#include "mnet1.h"
-//#include "melee/mitems.h"
-//#include "melee/mfleet.h"
-
-
+#include "melee/mship.h"
+#include "melee/mcbodies.h"
+#include "melee/MultiplayerTypes.h"
 #include "../libraries/raknet/PacketEnumerations.h"
 #include "../libraries/raknet/RakNetworkFactory.h"
 #include "../libraries/raknet/RakClientInterface.h"
@@ -44,6 +33,7 @@
 #include "../libraries/raknet/NetworkTypes.h"
 #include "../libraries/raknet/BitStream.h"
 #include "../libraries/raknet/Multiplayer.h"
+#include "sc1ships/sc1ships.h"
 	
 #include <stdlib.h>
 #include <string.h>
@@ -52,29 +42,19 @@
 //#include <allegro.h>
 
 
-//! 
-unsigned char GetPacketIdentifier(Packet *p);
+//#include "games/gmelee.h"
+//#include "melee/mview.h"
+//#include "melee/mcontrol.h"
+//#include "other/planet3d.h"
+////#include "mshppan.h"
+//#include "melee/mlog.h"
+////#include "mnet1.h"
+//#include "melee/mitems.h"
+//#include "melee/mfleet.h"
 
-// Holds enumeration data
-const int MOTD_MAXIMUM_LENGTH=50; // Characters allocated for the message of the day, used for enumerations
-const int SERVER_NAME_MAXIMUM_LENGTH=40; // Characters allocated for the server name
 
-//! data on the server which changes infrequently.  This information is transmitted to all joining clients.
-struct StaticServerDataStruct
-{
-	char MOTD[MOTD_MAXIMUM_LENGTH];  // (Message of the day) Optional, replace with whatever and/or add more fields
-	char serverName[SERVER_NAME_MAXIMUM_LENGTH];
-};
 
-const int SCDS_MAXIMUM_NAME_LENGTH=40;
 
-//! data on the client, which is automatically transmitted to the server and all other clients.  
-struct StaticClientDataStruct
-{
-	unsigned char typeId;  // ID_SET_CLIENT_DATA
-	char name[SCDS_MAXIMUM_NAME_LENGTH];
-};
-
 //! A class to implement Multiplayer Games with.  You should subclass this, rather than using it directly.
 //! You should also create a server and client class that can be used to start a game in the GUI and from the
 //! commandline (see MultiplayerGameServer for more explaination on how to do this).
@@ -99,6 +79,7 @@
 //! @see MultiplayerGameClient
 //! @see FleetSelectionPolicy
 //! @see SpawnTimeShipSelectionPolicy
+
 template <class InterfaceType>
 class MultiplayerGameTemplate : 
 	public Multiplayer<InterfaceType>,
@@ -112,13 +93,16 @@
     //!
 	~MultiplayerGameTemplate();
 	
+	YehatTerminator * yehat;
+
+	
 	// Methods and data stuctures from class Game /////////////////////////////////////////////////
 	
 	//! pre-initialization (enough so that the destructor won't crash)
 	virtual void preinit() { Game::preinit(); }	
 	
     //! initialization (loading data, creating a few game objects, whatever)
-    virtual void init(Log *log) { Game::init(log); }
+    virtual void init(Log *log);
     
     //! changes the view.  That is, the method that the screen is drawn for the user is selected.
     //! @param new_view the View data structure to use.
@@ -132,10 +116,7 @@
     virtual void prepare() { Game::prepare(); }
     
     //! called once per game loop.  Performs all game logic.
-    virtual void calculate() { 
-    	Game::calculate(); 
-    	ProcessPackets(networkInterface);
-    }
+    virtual void calculate();
     
     //! called once per game execution.  This contains the game loop itself.
     virtual void play() { Game::play(); }
@@ -162,13 +143,26 @@
 	//! Determines if the game has loaded/prepared all its data structures and ready to start.
     //! @return true if the game is ready to start, false otherwise.
 	virtual bool game_ready() {return Game::game_ready(); }
+    
+    /// add space location to universe
+    /// @see SpaceLocation
+    virtual void add(SpaceLocation *p);
+    
+    /// add presence from universe
+    /// @see Presence
+    virtual void add(Presence *p);
+
+protected:
+    ///
+    virtual void _add(Presence * p);
+    
+public: 
 	
-	
 	// Methods and data stuctures from class Multiplayer ///////////////////////////////////////////
 		
 	//! Automagically processes all incoming packets, and calls appropriate handlers.  This method
     //! must be called every frame, and this is done by default inside calculate().
-	void ProcessPackets(InterfaceType *interfaceType);
+	//void ProcessPackets(InterfaceType *interfaceType);
 	virtual void ProcessUnhandledPacket(Packet *p, unsigned char packetIdentifier, InterfaceType *interfaceType);
 	virtual void ReceiveRemoteDisconnectionNotification(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveRemoteConnectionLost(Packet *packet,InterfaceType *interfaceType);
@@ -200,6 +194,9 @@
 	virtual bool isServer() { return _isServer; }
 	
 protected:
+    RakServerInterface * server;
+    RakClientInterface * client;
+
 	//! this is the object which is used in all interactions with the RakNet API.  Note that the actual type
 	//! of this variable depends on the type of InterfaceType.  This means if this templated class is used as a client,
 	//! this variable is a RakClientInterface.  
@@ -208,9 +205,14 @@
 	//! - using MultiplayerGameTemplate<RakServerInterface> means this variable is a RakServerInterface
 	//! - using MultiplayerGameTemplate<RakPeerInterface> means this variable is a RakPeerInterface
 	InterfaceType * networkInterface;
+    
 
 protected:
 	bool _isServer;
+    PlayerList players;
+    
+    Asteroid * asteroid;
+    Stars * stars;
 };
 
 //! This class is exposed to the list of available games.  Note that this class is
@@ -244,15 +246,20 @@
 	MultiplayerGameServer()
     { 
         _isServer = true;
-		networkInterface = RakNetworkFactory::GetRakServerInterface(); 
-        networkInterface->SetStaticServerData((char*)&staticServerData, sizeof(staticServerData));
-        bool b = networkInterface->Start(2, 0, true, 15515);
+		networkInterface = server;
+        server->SetStaticServerData((char*)&staticServerData, sizeof(staticServerData));
+        bool b = server->Start(2, 0, true, 15515);
         if (!b)
             throw "Can't start server!";
-        message.print(5000,15,"Started server!");
+        message.print(60000,15,"Started server!");
 	}
-	~MultiplayerGameServer() { RakNetworkFactory::DestroyRakServerInterface(networkInterface); }
+	~MultiplayerGameServer() { }
     
+    virtual void calculate() {
+        MultiplayerGameTemplate<RakServerInterface>::calculate();
+    }
+    
+protected:
     StaticServerDataStruct staticServerData;
 };
 
@@ -261,18 +268,18 @@
 public:
 	MultiplayerGameClient()
     { 
-      networkInterface = RakNetworkFactory::GetRakClientInterface(); 
-      networkInterface->SetStaticClientData(UNASSIGNED_PLAYER_ID, (char*)&staticClientData, sizeof(StaticClientDataStruct));
+      networkInterface = client;
+      client->SetStaticClientData(UNASSIGNED_PLAYER_ID, (char*)&staticClientData, sizeof(StaticClientDataStruct));
       bool b = false;
       while (!b) {
-        b = networkInterface->Connect("127.0.0.1", 15515, 15516, 0, true);
+        b = client->Connect("127.0.0.1", 15515, 15516, 0, true);
         if (!b)
             message.out("Couldn't connect, retrying...");
       }
-      message.out("Connected to server!");
+      message.print(60000,15,"Connected to server!");
       
     }
-	~MultiplayerGameClient() { RakNetworkFactory::DestroyRakClientInterface(networkInterface);  }
+	~MultiplayerGameClient() { }
     StaticClientDataStruct staticClientData;
 };
 

Modified: branches/multiplayer-branch/source/games/gflmelee.h
===================================================================
--- branches/multiplayer-branch/source/games/gflmelee.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/games/gflmelee.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: gflmelee.h,v 1.1.1.1 2004/08/01 10:21:21 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/games/ggob.cpp
===================================================================
--- branches/multiplayer-branch/source/games/ggob.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/games/ggob.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -40,10 +40,10 @@
 #include "util/aastr.h"
 
 #include "ggob.h"
-#include "sc1ships.h"
-#include "sc2ships.h"
+#include "sc1ships/sc1ships.h"
+#include "sc2ships/sc2ships.h"
 
-#include "other/gup.h"
+#include "games/gup.h"
 #include "other/dialogs.h"
 #include "other/twconfig.h"
 

Modified: branches/multiplayer-branch/source/games/gmelee.cpp
===================================================================
--- branches/multiplayer-branch/source/games/gmelee.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/games/gmelee.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id$ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -36,6 +36,7 @@
 //#include "mnet1.h"
 #include "melee/mitems.h"
 #include "melee/mfleet.h"
+#include "melee/PresenceRegistry.h"
 
 #include "gflmelee.h"
 
@@ -455,6 +456,9 @@
 	int		*indtoggle;
 	Ship	*mother;
 	TeamIndicator(Ship *creator, int *toggle);
+	TeamIndicator() : indtoggle(NULL), mother(NULL) { }
+	virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
 
 	virtual void calculate();
 	virtual void animate(Frame *space);
@@ -462,6 +466,7 @@
 
 
 
+
 void MeleeGame::choose_new_ships() 
 {
   STACKTRACE;
@@ -720,4 +725,5 @@
 
 
 
-REGISTER_GAME(MeleeGame, "Melee")
+REGISTER_GAME(MeleeGame, "Melee");
+REGISTER_PRESENCE_CLASS(TeamIndicator);

Modified: branches/multiplayer-branch/source/games/gmelee.h
===================================================================
--- branches/multiplayer-branch/source/games/gmelee.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/games/gmelee.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $$ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -19,6 +19,7 @@
 #define __MMAIN_H__
 
 #include "melee.h"
+#include "melee/mship.h"
 #include "melee/mgame.h"
 
 enum { DefaultEndingTime = 1000 };

Copied: branches/multiplayer-branch/source/games/gup.cpp (from rev 81, branches/multiplayer-branch/source/other/gup.cpp)
===================================================================
--- branches/multiplayer-branch/source/other/gup.cpp	2004-10-16 21:23:27 UTC (rev 81)
+++ branches/multiplayer-branch/source/games/gup.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -0,0 +1,716 @@
+#include <string.h>
+#include <allegro.h>
+#include "melee.h"
+
+#include "melee/mframe.h"
+#include "melee/mship.h"
+#include "melee/mcbodies.h"
+#include "melee/mview.h"
+#include "frame.h"
+#include "sc1ships/sc1ships.h"
+#include "sc2ships/sc2ships.h"
+#include "games/ggob.h"
+#include "games/gup.h"
+#include "melee/PresenceRegistry.h"
+
+/* this file contains the ship upgrades used by Gob */
+
+/*
+Generic Upgrades
+*/
+
+/*
+NOTE that execute() is called BEFORE charge(), so 
+num is not yet incremented when execute() is running
+*/
+void Upgrade::clear(Ship *oship, Ship *nship, GobPlayer *gs) {
+  STACKTRACE;
+	if (oship) gs->total -= num;
+	num = 0;
+	return;
+	}
+void Upgrade::charge(GobPlayer *gs) {
+  STACKTRACE; //called AFTER execute
+	gs->total += 1;
+	num += 1;
+	gs->value_starbucks += this->starbucks;
+	gs->value_buckazoids += this->buckazoids;
+	return;
+	}
+
+#define UPGRADE(a) virtual Upgrade *duplicate() {return new a();}
+class UpCrewpod : public Upgrade {
+	UPGRADE(UpCrewpod)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Add Crewpod";
+		if (ship->crew_max >= 42) return false;
+		starbucks = 2;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship->crew_max += 4;
+		if (ship->crew_max > 42) ship->crew_max = 42;
+		ship->crew += 4;
+		if (ship->crew > 42) ship->crew = 42;
+		}
+	} crewpod;
+
+class UpBattery : public Upgrade {
+	UPGRADE(UpBattery)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Add Battery";
+		if (ship->batt_max >= 42) return false;
+		starbucks = 1;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship->batt_max += 8;
+		if (ship->batt_max > 42) ship->batt_max = 42;
+		ship->batt += 8;
+		if (ship->batt > 42) ship->batt = 42;
+		}
+	} battery;
+
+class UpThrusters : public Upgrade {
+	UPGRADE(UpThrusters)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Thrusters";
+		starbucks = 3 + num * 3;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship->speed_max *=  1 + .3  / (.25*num + 1);
+		ship->accel_rate *= 1 + .18 / (.12*num + 1);
+		}
+	} thrusters;
+
+class UpControlJets : public Upgrade {
+	UPGRADE(UpControlJets)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Control Jets";
+		starbucks = 2 + num * 2;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship->turn_rate  *=  1 + .3  / (num + 1);
+		ship->accel_rate *=  1 + .1  / (.0*num + 1);
+		}
+	} controljets;
+
+class UpDynamo : public Upgrade {
+	UPGRADE(UpDynamo)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Dynamo";
+		starbucks = 16 / (1 + ship->recharge_amount-num) + num;
+		if (ship->recharge_amount == 0) starbucks *= 6;
+		if (ship->weapon_rate < 100) starbucks /= 2;
+		if (ship->special_drain > 16) starbucks *= 2;
+		if (!strcmp("supbl", ship->type->id)) starbucks /= 2;
+		buckazoids = gs->total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship->recharge_amount += 1;
+	}
+} dynamo;
+
+/*
+Supox Upgrades
+*/
+
+class UpSupoxRange : public Upgrade {
+	UPGRADE(UpSupoxRange)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Glob Hurler (Supox)";
+		if (strcmp("supbl", ship->type->id)) return false;
+		starbucks = 2 + num;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((SupoxBlade*)ship)->weaponRange *= 1 + .25 / (1 + num*.1);
+		((SupoxBlade*)ship)->weaponVelocity *= 1.15;
+		}
+	} supoxrange;
+
+class UpSupoxDamage : public Upgrade {
+	UPGRADE(UpSupoxDamage)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Glob Former (Supox)";
+		if (strcmp("supbl", ship->type->id)) return false;
+		if (gs->ship->recharge_amount < (1<<num)) return false;
+		if (num > 7) return false;
+		starbucks = 5;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((SupoxBlade*)ship)->weaponDamage += 1;
+		((SupoxBlade*)ship)->weaponArmour += 1;
+		((SupoxBlade*)ship)->weapon_drain += num + 1;
+		if (num > 1) ((SupoxBlade*)ship)->recharge_amount += 1;
+		}
+	} supoxdamage;
+
+class UpSupoxBLADE : public Upgrade {
+	UPGRADE(UpSupoxBLADE)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Add B.L.A.D.E. (Supox)";
+		if (strcmp("supbl", ship->type->id)) return false;
+		starbucks = 2 + num;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((SupoxBlade*)ship)->damage_factor += 3;
+		}
+	} supoxblade;
+
+/*
+Orz Upgrades
+*/
+
+class UpOrzMissile : public Upgrade {
+	UPGRADE(UpOrzMissile)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Missiles (ORZ)";
+		if (strcmp("orzne", ship->type->id)) return false;
+		starbucks = 6;
+		buckazoids = gs->total / 2 + 2;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((OrzNemesis*)ship)->weaponDamage += 1;
+		((OrzNemesis*)ship)->weaponArmour += 1;
+		((OrzNemesis*)ship)->weaponRange *= 1.15;
+		((OrzNemesis*)ship)->weapon_drain += 1;
+		}
+	} orzmissile;
+
+class UpOrzMarineSpeed : public Upgrade {
+	UPGRADE(UpOrzMarineSpeed)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Marine Suits (ORZ)";
+		if (strcmp("orzne", ship->type->id)) return false;
+		starbucks = 3 + num * 2;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((OrzNemesis*)ship)->specialArmour += 1;
+		((OrzNemesis*)ship)->specialSpeedMax *= 1 + .2 / (.2*num+1);
+		((OrzNemesis*)ship)->specialAccelRate *= 1.15;
+		}
+	} orzmarinespeed;
+
+class UpOrzAbsorbtion : public Upgrade {
+	UPGRADE(UpOrzAbsorbtion)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Absorbtion (ORZ)";
+		if (strcmp("orzne", ship->type->id)) return false;
+		if (num) return false;
+		starbucks = 15;
+		buckazoids = gs->total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((OrzNemesis*)ship)->absorption = 256 / 3;
+	}
+	void charge(GobPlayer *gs) {
+		Upgrade::charge(gs);
+		gs->total += 2;
+	}
+} orzabsorption;
+
+/*
+Kohr-Ah Upgrades
+*/
+
+class UpKohrAhBladeDamage : public Upgrade {
+	UPGRADE(UpKohrAhBladeDamage)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Increase Shuriken Sharpness (Kohr-Ah)";
+		if (strcmp("kohma", ship->type->id)) return false;
+		starbucks = 2 + num;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((KohrAhMarauder*)ship)->weaponDamage += 1;
+		((KohrAhMarauder*)ship)->weaponArmour += 1;
+		((KohrAhMarauder*)ship)->weapon_drain += 1;
+		}
+	} kohrahbladedamage;
+
+class UpKohrAhBladeSpeed : public Upgrade {
+	UPGRADE(UpKohrAhBladeSpeed)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		if (strcmp("kohma", ship->type->id)) return false;
+		name = "Increase Shuriken Velocity (Kohr-Ah)";
+		starbucks = 2 + num * 2;
+		buckazoids = gs->total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((KohrAhMarauder*)ship)->weaponVelocity *= 1.2;
+	}
+} kohrahbladespeed;
+
+class UpKohrAhFireRange : public Upgrade {
+	UPGRADE(UpKohrAhFireRange)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "double F.R.I.E.D. range (Kohr-Ah)";
+		if (strcmp("kohma", ship->type->id)) return false;
+		if (num) return false;
+		starbucks = 30;
+		buckazoids = gs->total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((KohrAhMarauder*)ship)->specialRange *= 2;
+		((KohrAhMarauder*)ship)->specialVelocity *= 1.4;
+		((KohrAhMarauder*)ship)->special_drain += 12;
+		}
+	} kohrahfirerange;
+
+class UpKohrAhFireDamage : public Upgrade {
+	UPGRADE(UpKohrAhFireDamage)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "double F.R.I.E.D. damage (Kohr-Ah)";
+		if (strcmp("kohma", ship->type->id)) return false;
+		if (num) return false;
+		starbucks = 13;
+		buckazoids = gs->total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((KohrAhMarauder*)ship)->specialDamage *= 2;
+		((KohrAhMarauder*)ship)->special_drain += 6;
+	}
+} kohrahfiredamage;
+
+/*
+Utwig Upgrades
+*/
+
+class UpUtwigJuggerRange : public Upgrade {
+	UPGRADE(UpUtwigJuggerRange)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Bolt Regulator (Utwig)";
+		if (strcmp("utwju", ship->type->id)) return false;
+		starbucks = 3;
+		buckazoids = gs->total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((UtwigJugger*)ship)->weaponRange += 100;
+	}
+} utwigrange;
+class UpUtwigJuggerDamage : public Upgrade {
+	UPGRADE(UpUtwigJuggerDamage)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Bolt Charger (Utwig)";
+		if (strcmp("utwju", ship->type->id)) return false;
+		starbucks = (num + 3) * 5;
+		buckazoids = gs->total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((UtwigJugger*)ship)->weaponDamage += 1;
+		ship->weapon_rate += 250;
+	}
+} utwigdamage;
+class UpUtwigJuggerROF : public Upgrade {
+	UPGRADE(UpUtwigJuggerROF)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Upgrade Bolt Generator (Utwig)";
+		if (strcmp("utwju", ship->type->id)) return false;
+		if (ship->weapon_rate < 425) return false;
+		starbucks = num / 2 + 2;
+		buckazoids = gs->total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship->weapon_rate -= 50;
+	}
+} utwigrof;
+class UpUtwigJuggerMaskOfHonestDemeanor : public Upgrade {
+	UPGRADE(UpUtwigJuggerMaskOfHonestDemeanor)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Mask of Honest Demeanor (max 1 mask)";
+		if (strcmp("utwju", ship->type->id)) return false;
+		if ((num + gs->upgrade_list[UpgradeIndex::utwigmask2]->num) == 1) return false;
+		starbucks = 99;
+		buckazoids = 0;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		gs->value_starbucks += 251;
+		gs->value_buckazoids += 250;
+	}
+} utwigmask1;
+class UpUtwigJuggerMaskOfElephantineFortitude : public Upgrade {
+	UPGRADE(UpUtwigJuggerMaskOfElephantineFortitude)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Mask of Elephantine Fortitude (max 1 mask)";
+		if (strcmp("utwju", ship->type->id)) return false;
+		if ((num + gs->upgrade_list[UpgradeIndex::utwigmask1]->num) == 1) return false;
+		starbucks = 99;
+		buckazoids = 0;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((UtwigJugger*)ship)->fortitude = 1;
+	}
+} utwigmask2;
+
+/*
+Special Upgrades
+*/
+
+class UpDivineFavor : public Upgrade {
+	UPGRADE(UpDivineFavor)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Divine Favor (unique)";
+		if (strcmp(station->build_type, "orzne")) return false;
+		if (num) return false;
+		starbucks = 150;
+		buckazoids = 0;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		}
+	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
+		if (!oship) num = 0;
+		return;
+		}
+	void charge(GobPlayer *gs) {
+		num += 1;
+		}
+	} divinefavor;
+
+class UpUnholyAura : public Upgrade {
+	UPGRADE(UpUnholyAura)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "the Devil protects his own...";
+		starbucks = 6;
+		buckazoids = 66;
+		//if (strcmp(station->build_type, "orzne")) return false;
+		if (num) return false;
+		if (((game->game_time / 1000) % 1000) == 666) return true;
+		if (((game->game_time / 1000) % 666) == 0) return true;
+		//666, 1332, 1666, 1998, etc.
+		return false;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		game->add ( new UnholyAura ( ship ) );
+		}
+	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
+		if (!oship) num = 0;
+		else if (num) {
+			game->add ( new UnholyAura ( nship ) );
+		}
+		return;
+		}
+	void charge(GobPlayer *gs) {
+		num += 1;
+		}
+	} unholyaura;
+
+
+class UpDefender : public Upgrade {
+	UPGRADE(UpDefender)
+	GobDefender *def[6];
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "External Defense System";
+		if (strcmp(station->build_type, "kohma")) return false;
+		if (num >= 6) return false;
+		starbucks = 5 + 5 * (num+1) * num;
+		buckazoids = 12;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		def[num] = new GobDefender(ship);
+		int i;
+		for (i = 0; i <= num; i += 1) def[i]->base_phase = i * PI2 / (num+1);
+		gobgame->add (def[num]);
+	}
+	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
+		if (!oship) num = 0;
+		if (oship) {
+			for (int i = 0; i < num; i += 1) {
+				def[i]->die();
+				def[i] = new GobDefender(nship);
+				def[i]->base_phase = i * PI2 / num;
+				game->add(def[i]);
+			}
+		}
+		//Upgrade::clear(oship, nship, gs);
+		return;
+	}
+	void charge(GobPlayer *gs) {
+		gs->total += 1;
+		num += 1;
+	}
+} defender;
+
+class UpPlanetLocater : public Upgrade {
+	UPGRADE(UpPlanetLocater)
+	Presence **locater;
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Planet Locater";
+		if (strcmp(station->build_type, "supbl")) return false;
+		if (num) return false;
+		starbucks = 4;
+		buckazoids = 5;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		locater = new Presence *[gobgame->num_planets];
+		for (int i = 0; i < gobgame->num_planets; i += 1) {
+			locater[i] = new WedgeIndicator ( gobgame->planet[i], 80, 2 );
+			gobgame->add (locater[i] );
+		}
+	}
+	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
+		Upgrade::clear(oship, nship, gs);
+		if (oship && locater) for (int i = 0; i < gobgame->num_planets; i += 1) {
+			locater[i]->die();
+		}
+		locater = NULL;
+		return;
+	}
+} planetlocater;
+
+class UpHyperDynamo : public Upgrade {
+	UPGRADE(UpHyperDynamo)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Hyper Dynamo (ancient artifact)";
+		if (game->game_time / 1000 < 21 * 60) return false;
+		starbucks = 720 / (game->game_time / (1000*60*10) - 1);
+		//unavailable before 20 minutes
+		//720 starbucks at 20 minutes
+		//360 starbucks at 30 minutes
+		//240 starbucks at 40 minutes
+		//180 starbucks at 50 minutes
+		//144 starbucks at 60 minutes
+		//120 starbucks at 70 minutes
+		//102 starbucks at 80 minutes
+		//90 starbucks at 90 minutes
+		buckazoids = starbucks/2 + gs->total / 3;
+		if (gs->starbucks < starbucks / 4) return false;
+		if (ship->recharge_amount == 0) return false;
+		if (num) return false;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship->recharge_rate /= 2;
+	}
+} hyperdynamo;
+
+/*class UpRoswellDevice : public Upgrade {
+	UPGRADE(UpUnholyAura)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = "Roswell Device";
+		if (((game->game_time / 1000) % 1000) < 700) return false;
+		starbucks = 99;
+		buckazoids = 9;
+		if (strcmp(station->build_type, "utwju")) return false;
+		if (num) return false;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		game->add ( new RoswellDevice ( ship ) );
+	}
+	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
+		if (!oship) num = 0;
+		else if (num) {
+			game->add ( new RoswellDevice ( nship ) );
+		}
+		return;
+	}
+	void charge(GobPlayer *gs) {
+		num += 1;
+	}
+} roswelldevice;*/
+
+/*
+note to future coders:
+in order for an upgrade to show up, it must be added to this list
+anything added to this list MUST be added, in the same order, to 
+the enum in gup.h
+*/
+static Upgrade *_upgrade_list[] = {
+	&crewpod,
+	&battery,
+	&thrusters,
+	&controljets,
+	&dynamo,
+	&supoxrange,
+	&supoxdamage,
+	&supoxblade,
+	&orzmissile,
+	&orzmarinespeed,
+	&orzabsorption,
+	&kohrahbladedamage,
+	&kohrahbladespeed,
+	&kohrahfirerange,
+	&kohrahfiredamage,
+	&utwigrange,
+	&utwigdamage,
+	&utwigrof,
+	&utwigmask1,
+	&utwigmask2,
+	&divinefavor,
+	&unholyaura,
+	&defender,
+	&planetlocater,
+	&hyperdynamo,
+//	&roswelldevice,
+	NULL
+	};
+
+Upgrade **upgrade_list = _upgrade_list;
+
+UnholyAura::UnholyAura ( SpaceLocation * ship ) {
+	focus = ship;
+	angle = 0;
+}
+void UnholyAura::animate (Frame *frame) {
+	Vector2 p = corner(focus->normal_pos());
+	const int speed = 1500;
+	int color = game->game_time % speed;
+	if (color > speed/2) color = speed - color;
+	color = tw_color ( color * 255 * 2 / speed, 0, 0);
+	Vector2 r;
+	r.y = space_zoom * 240;
+	r.x = r.y * 1.5;
+	double a = angle;
+	line (frame->surface, 
+		p + r *(unit_vector(a +   0 * ANGLE_RATIO)), 
+		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
+		color);
+	a += 72 * ANGLE_RATIO;
+	line (frame->surface, 
+		p + r * (unit_vector(a +   0 * ANGLE_RATIO)), 
+		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
+		color);
+	a += 72 * ANGLE_RATIO;
+	line (frame->surface, 
+		p + r * (unit_vector(a +   0 * ANGLE_RATIO)), 
+		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
+		color);
+	a += 72 * ANGLE_RATIO;
+	line (frame->surface, 
+		p + r * (unit_vector(a +   0 * ANGLE_RATIO)), 
+		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
+		color);
+	a += 72 * ANGLE_RATIO;
+	line (frame->surface, 
+		p + r * (unit_vector(a +   0 * ANGLE_RATIO)), 
+		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
+		color);
+	frame->add_box(iround(p.x - r.x-1), iround(p.y - r.y-1), iround(r.x*2+3), iround(r.y*2+3));
+}
+void UnholyAura::calculate () {
+	if (!focus->exists()) die();
+	angle -= frame_time / 10.0;
+	if (angle < 0) angle += 360;
+	if (random(1700) < frame_time) {
+		Query q;
+		q.begin(focus, OBJECT_LAYERS, 666);
+		for (;q.current; q.next() ) {
+			if (!(focus->sameTeam(q.current))) q.current->handle_damage(focus, 0, random() % 6);
+		}
+	}
+}
+/*
+void GobRadar::animate_item ( SpaceLocation *item ) {
+	int type = 0;
+	int color = 0;
+	double angle = 0;
+	double radius = 0;
+	double x, y;
+	x = normalize(item->normal_x() - gx + X_MAX/2, X_MAX) - X_MAX/200+gx/2;
+	x *= window->w / gw;
+	y = normalize(item->normal_y() - gy + Y_MAX/2, Y_MAX) - Y_MAX/200+gy/2;
+	y *= window->h / gh;
+	TeamCode t = item->get_team();
+	if (t == 0) color = palette_color[6];
+	else if (t == team) color = palette_color[7];
+	else color = palette_color[4];
+	color = palette_color[7];
+	if (item->isObject()) {
+		SpaceSprite *sprite = ((SpaceObject*)item)->get_sprite();
+		if (sprite) radius = 
+			sqrt(sprite->width() * sprite->width() + sprite->height() * sprite->height()) / 2 / gw;
+		else return;
+		if (radius < 5) radius = sqrt(radius * 5);
+	}
+	else if (item->isLine()) {
+		type = 1;
+		radius = (((SpaceLine*)item)->get_length()) / gw;
+		angle = (((SpaceLine*)item)->get_angle());
+	}
+
+
+	if (type == 0) {
+		circlefill ( window->surface, 
+			window->x + x, 
+			window->y + y, 
+			radius,
+			color
+		);
+	}
+	else if (type == 1) {
+		line (  window->surface,
+			window->x + x, 
+			window->y + y,
+			window->x + x + cos(angle) * radius,
+			window->y + y + sin(angle) * radius,
+			color
+		);
+	}
+}
+
+void GobRadar::animate ( Frame * frame ) {
+	Query q;
+	if (!window->surface) return;
+
+	window->lock();
+
+	rectfill(window->surface, 
+		window->x, window->y, 
+		window->x + window->w,
+		window->y + window->h,
+		0
+		);
+	for (q.begin(0, 0, ALL_LAYERS, 999999999999);q.current;q.next()) {
+		if (!q.current->exists()) continue;
+		if (q.current->isInvisible())
+			continue;
+		animate_item(q.current);
+	}
+	q.end();
+
+	window->unlock();
+}
+
+GobRadar::GobRadar() {
+  STACKTRACE;
+	attributes &= ~ATTRIB_SYNCHED;
+	team = 0;
+	gx = 0;
+	gy = 0;
+	gw = X_MAX;
+	gh = Y_MAX;
+	window = new VideoWindow();
+	window->preinit();
+}
+*/
+
+REGISTER_PRESENCE_CLASS(UnholyAura)

Copied: branches/multiplayer-branch/source/games/gup.h (from rev 81, branches/multiplayer-branch/source/other/gup.h)
===================================================================
--- branches/multiplayer-branch/source/other/gup.h	2004-10-16 21:23:27 UTC (rev 81)
+++ branches/multiplayer-branch/source/games/gup.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -0,0 +1,77 @@
+class Upgrade;
+extern Upgrade **upgrade_list;
+
+class UpgradeIndex {
+public:
+	enum {
+		crewpod,
+		battery,
+		thrusters,
+		controljets,
+		dynamo,
+		supoxrange,
+		supoxdamage,
+		supoxblade,
+		orzmissile,
+		orzmarinespeed,
+		orzabsorption,
+		kohrahbladedamage,
+		kohrahbladespeed,
+		kohrahfirerange,
+		kohrahfiredamage,
+		utwigrange,
+		utwigdamage,
+		utwigrof,
+		utwigmask1,
+		utwigmask2,
+		divinefavor,
+		unholyaura,
+		defender,
+		planetlocater,
+		hyperdynamo,
+		//gobradar,
+		//roswelldevice,
+		NULL_UPGRADE
+	};
+};
+
+class GobDefender : public SpaceObject {
+	public:
+	GobDefender ( Ship *ship);
+	double base_phase;
+	virtual void calculate();
+	int next_shoot_time;
+};
+
+/*class RoswellDevice : public Presence {
+	public:
+	RoswellDevice ( Ship *ship, double angle );
+	virtual void calculate();
+	int next_shoot_time;
+	double phase;
+};*/
+
+class UnholyAura : public Presence {
+public:
+	SpaceLocation *focus;
+	double angle;
+	virtual void calculate ();
+	virtual void animate ( Frame * frame);
+	UnholyAura ( SpaceLocation *ship );
+	UnholyAura() : focus(NULL) { } 
+	virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
+};
+
+/*
+class GobRadar : public Presence {
+public:
+	TeamCode team;
+	double gx, gy, gw, gh;
+	VideoWindow *window;
+	//virtual void calculate ();
+	virtual void animate ( Frame * frame );
+	virtual void animate_item ( SpaceLocation *item);
+	GobRadar();
+};*/
+

Modified: branches/multiplayer-branch/source/gui.cpp
===================================================================
--- branches/multiplayer-branch/source/gui.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/gui.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: gui.cpp,v 1.2 2004/08/03 11:37:22 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/gui.h
===================================================================
--- branches/multiplayer-branch/source/gui.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/gui.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: gui.h,v 1.1.1.1 2004/08/01 10:21:18 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/id.h
===================================================================
--- branches/multiplayer-branch/source/id.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/id.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: id.h,v 1.1.1.1 2004/08/01 10:21:18 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/input.cpp
===================================================================
--- branches/multiplayer-branch/source/input.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/input.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: input.cpp,v 1.1.1.1 2004/08/01 10:21:19 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/input.h
===================================================================
--- branches/multiplayer-branch/source/input.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/input.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: input.h,v 1.1.1.1 2004/08/01 10:21:18 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObjectHeader.h
===================================================================
--- branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObjectHeader.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/libraries/raknet/DistributedNetworkObjectHeader.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -480,4 +480,4 @@
 	SynchronizationMethod6##_INTERPOLATION_CODE(AuthoritativeNetwork6, VariableName6)	\
 }
 
-// Extend this pattern as many times as necessary.  If anyone figures out a way to automate a way to do that with the preprocessor let me know
\ No newline at end of file
+// Extend this pattern as many times as necessary.  If anyone figures out a way to automate a way to do that with the preprocessor let me know

Added: branches/multiplayer-branch/source/melee/MultiplayerTypes.h
===================================================================
--- branches/multiplayer-branch/source/melee/MultiplayerTypes.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/MultiplayerTypes.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -0,0 +1,73 @@
+/*
+This file is part of "TW-Light" 
+                    http://tw-light.berlios.de/
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+#ifndef MULTIPLAYER_TYPES_HEADER
+#define MULTIPLAYER_TYPES_HEADER
+
+#include "frame.h"
+#include "../libraries/raknet/NetworkTypes.h"
+// this header contains the catagories of network messages, usually of the form ID_*
+// if you're looking for them, there they be.  
+#include "../libraries/raknet/PacketEnumerations.h"
+
+#include <vector>
+using namespace std;
+
+// Holds enumeration data
+enum { MOTD_MAXIMUM_LENGTH=50 }; // Characters allocated for the message of the day, used for enumerations
+enum { SERVER_NAME_MAXIMUM_LENGTH=40 }; // Characters allocated for the server name
+
+/// Data on the server which is transmitted to all joining clients.  This data should change infrequently 
+/// (ie once per map/match, or when the game settings are changed)
+struct StaticServerDataStruct
+{
+	char MOTD[MOTD_MAXIMUM_LENGTH];  // (Message of the day) Optional, replace with whatever and/or add more fields
+	char serverName[SERVER_NAME_MAXIMUM_LENGTH];
+};
+
+enum{ SCDS_MAXIMUM_NAME_LENGTH=40 };
+
+/// Data on the client, which is automatically transmitted to the server and all other clients.  
+struct StaticClientDataStruct
+{
+	unsigned char typeId;  // ID_SET_CLIENT_DATA
+	char name[SCDS_MAXIMUM_NAME_LENGTH];
+};
+
+typedef vector<PlayerID> PlayerList;
+typedef PlayerList::iterator PlayerListIterator;
+
+enum {PT_UNKNOWN=0};
+
+#pragma pack(1)
+struct PresenceCreationDescription
+{
+    PresenceCreationDescription(ObjectID ObjectID, unsigned PresenceType) :
+       networkMessageTypeID(ID_PRESENCE_CREATION), 
+       objectId(ObjectID),
+       presenceType(PresenceType)
+    {
+    }
+    unsigned char useTimeStamp; // Assign this to ID_TIMESTAMP
+    unsigned long timeStamp; // Put the system time in here returned by timeGetTime() or some other method that returns a similar value
+    unsigned char networkMessageTypeID; 
+    ObjectID objectId;
+    
+    /// This is the type of Presence subclass which we are referring to.  
+    /// @see PresenceRegistry
+    unsigned presenceType;
+};
+
+#endif

Added: branches/multiplayer-branch/source/melee/PresenceRegistry.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/PresenceRegistry.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/PresenceRegistry.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -0,0 +1,166 @@
+/*
+This file is part of "TW-Light" 
+                    http://tw-light.berlios.de/
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#include <iostream> 
+#include "melee/mframe.h"
+#include "melee/MultiplayerTypes.h"
+#include <vector>
+using namespace std;
+
+#include "melee/PresenceRegistry.h"
+
+PresenceRegistry presenceRegistry;
+
+PresenceRegistry::PresenceRegistry() : boo(0) {
+   cout << "PR Constructor" << endl;
+   cout.flush();
+   boo ++;
+}
+
+void PresenceRegistry::registerPresenceClass (const char * className, Presence * (*GetPresenceClassInstance)()) {
+	//cout << "register boo="<<presenceRegistry.boo<<endl;
+	
+    //Check to see if this class has already been added.
+    //If so, don't do anything.
+    vector <PresenceClassDescription>::iterator iter;
+    vector <PresenceClassDescription>::iterator iterEnd = presenceRegistry.presenceClassDescriptionList.end();
+    for (iter = presenceRegistry.presenceClassDescriptionList.begin();
+         iter != iterEnd;
+         ++iter)
+    {
+        if (strcmp(iter->className, className)==0)
+            return;
+    }
+    unsigned id = presenceRegistry.presenceClassDescriptionList.size() + 1;
+    PresenceClassDescription pcd(className,
+        id,
+        GetPresenceClassInstance);
+    presenceRegistry.presenceClassDescriptionList.push_back(pcd);
+    
+//    cout << "registering PresenceClass ( " << className << "," 
+//    	 << id << ") as (" << presenceRegistry.getClassName(id) << "," << presenceRegistry.getClassID(className) <<")"<< endl;
+//    cout.flush();
+}
+
+///
+Presence * PresenceRegistry::GetPresenceClassDefaultInstance(const unsigned classID) {
+    PresenceClassDescription * desc = presenceRegistry.getPresenceItem(classID);
+    if (desc)
+    	return desc->getPresenceClassInstance();
+    
+    return NULL;
+}
+
+///
+Presence * PresenceRegistry::GetPresenceClassDefaultInstance(const char * className) { 
+	PresenceClassDescription * pcd = presenceRegistry.getPresenceItem(className);
+	if (pcd)
+	   return pcd->getPresenceClassInstance();
+	return NULL;
+}
+
+
+/*Presence * PresenceRegistry::createPresenceFromNetworkDescription(PresenceCreationDescription * info) 
+{
+	assert(info);
+	if (info==NULL) {
+		tw_error("PresenceRegistry::createPresenceFromNetworkDescription got a NULL pointer");
+		return NULL;
+	}
+	
+	PresenceClassDescription * pcd = getPresenceItem(info->presenceType);
+	if (pcd) {
+		Presence * presence = pcd->getPresenceClassInstance();
+		presence->updatePresenceObjectFromNetworkDescription(info);
+		return presence;
+	}
+    return NULL;
+}*/
+
+const unsigned PresenceRegistry::getClassID(const char * className) {
+	PresenceClassDescription * pcd = presenceRegistry.getPresenceItem(className);
+	if (pcd)
+		return pcd->classID;
+	return 0;	
+}
+
+const char * PresenceRegistry::getClassName( const unsigned classID ) {
+	PresenceClassDescription * pcd = presenceRegistry.getPresenceItem(classID);
+	if (pcd)
+		return pcd->className;
+	return "";
+}
+
+PresenceClassDescription * PresenceRegistry::getPresenceItem(const unsigned classID) 
+{
+//	cout << "checking for ClassID " << classID << " list.size" << presenceClassDescriptionList.size();
+    vector <PresenceClassDescription>::iterator iter = presenceRegistry.presenceClassDescriptionList.begin();
+    vector <PresenceClassDescription>::iterator iterEnd = presenceRegistry.presenceClassDescriptionList.end();
+    for ( ;
+         iter != iterEnd;
+         ++iter)
+    {
+        if (iter->classID == classID) {
+//        	cout << " found as " << iter->classID <<endl;
+        	cout.flush();
+            return &(*iter);
+        }
+    }
+//    cout << "not found!" <<endl;
+//    cout.flush();
+    return NULL;
+}
+
+PresenceClassDescription * PresenceRegistry::getPresenceItem(const char * className) 
+{
+//	cout << "checking for Classname " << className << " list.size=" << presenceClassDescriptionList.size();
+    vector <PresenceClassDescription>::iterator iter = presenceRegistry.presenceClassDescriptionList.begin();
+    vector <PresenceClassDescription>::iterator iterEnd = presenceRegistry.presenceClassDescriptionList.end();
+    for ( ;
+         iter != iterEnd;
+         ++iter)
+    {
+        if (strcmp(iter->className, className)==0) {
+//        	cout << " found as " << iter->classID << endl;
+//        	cout.flush();
+            return &(*iter);
+        }
+    }
+//    cout << "not found!" << endl;
+    //cout.flush();
+    return NULL;
+}
+
+PresenceRegistry * PresenceRegistry::GetInstance() { 
+	//cout << "GetInstance:list size=" << presenceRegistry.presenceClassDescriptionList.size() << endl;
+	cout.flush();
+    return (PresenceRegistry *)&presenceRegistry; 
+}
+
+void PresenceRegistry::toString() {
+//	cout << "to string  boo(PR)="<<presenceRegistry.boo<< " boo(this)="<<boo <<endl;
+
+	//printf("PresenceRegistry:size=%d\n", presenceRegistry->presenceClassDescriptionList.size());
+	
+}
+
+//static void testtesttest(void) {
+//	cout << "in testtesttest" << endl;
+//	cout.flush();
+//	presenceRegistry = new PresenceRegistry();
+//	//PresenceRegistry::GetInstance()->toString();
+//}
+//CALL_BEFORE_MAIN(testtesttest);

Added: branches/multiplayer-branch/source/melee/PresenceRegistry.h
===================================================================
--- branches/multiplayer-branch/source/melee/PresenceRegistry.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/PresenceRegistry.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -0,0 +1,168 @@
+/*
+This file is part of "TW-Light" 
+                    http://tw-light.berlios.de/
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#ifndef PRESENCE_REGISTRY_HEADER
+#define PRESENCE_REGISTRY_HEADER
+
+#include "melee/mframe.h"
+#include "melee/MultiplayerTypes.h"
+#include <vector>
+#include <string>
+using namespace std;
+
+class Presence;
+
+class PresenceRegistry;
+
+/// global instance
+extern PresenceRegistry presenceRegistry;
+
+/// Describes a Presence subclass.  Contains a class name, and classID,
+/// which is set at compile-time.  Each Presence subclass must have a unique 
+/// classID
+struct PresenceClassDescription {
+    PresenceClassDescription(const char * ClassName, 
+                             unsigned classID, 
+                             Presence * GetPresenceClassInstance()) :
+        className(ClassName),
+        classID(classID),
+        getPresenceClassInstance(GetPresenceClassInstance)
+    { 
+    }
+    const char * className;
+    unsigned classID;
+    Presence * (*getPresenceClassInstance)();
+};
+
+    
+///Every Presence subclass must register using this class, so that the Presence
+///class can created and syncronized across the network.  You should use the macro
+///REGISTER_PRESENCE_CLASS( class )
+///exactly once to make the Presence subclass available on the network.  Like so:
+///
+///#include "melee/PresenceRegistry.h"
+///...
+///class MyPresenceClass : public Presence {
+///  ...
+///}
+///...
+///REGISTER_PRESENCE_CLASS(MyPresenceClass);
+///
+/// @see registerPresenceClass
+class PresenceRegistry {
+public:
+    PresenceRegistry();
+    ~PresenceRegistry() { }
+    
+    ///Registers a Presence subclass.  
+    /// @param className the name of the class to register.
+    static void registerPresenceClass (const char * className, Presence * (*GetPresenceClassInstance)());
+    
+    ///
+    Presence * GetPresenceClassDefaultInstance(const unsigned ClassID);
+    
+    ///
+    Presence * GetPresenceClassDefaultInstance(const char * className);
+    
+    ///
+    ///    
+    //Presence * createPresenceFromNetworkDescription(PresenceCreationDescription * info);
+    
+    ///Returns the class ID associated with this Presence subclass.
+    /// @param className the class name to check up on.
+    /// @return 0 if the class has not been registered, otherwise returns unique, positive class ID
+    //unsigned _getclassID(const char * className);
+    
+    ///Returns the class ID associated with this Presence subclass.
+    /// @param className the class name to check up on.
+    /// @return 0 if the class has not been registered, otherwise returns unique, positive class ID
+    const unsigned getClassID(const char * className);
+    
+    ///
+    const char * getClassName( const unsigned classID );
+    
+    ///
+    static PresenceRegistry * GetInstance();
+    void toString();
+
+protected:
+	///
+	PresenceClassDescription * getPresenceItem(const unsigned classID);
+	///
+    PresenceClassDescription * getPresenceItem(const char * className);
+private:
+    ///
+    vector <PresenceClassDescription> presenceClassDescriptionList;
+    int boo;
+    
+};
+
+///This macro must be called once for every subclass of Presence.  It make the
+///subclass available in network code.  Note that the subclass has two requirements:
+///- it must have a no-argument constructor
+///- it must declare, but not implement, 
+/// virtual char * MyPresenceClass::GetClassName(void) const;
+///
+///Call this macro like this:
+///
+/// (in your header file)
+///
+///class MyPresenceClass : public Presence {
+///public:
+///  MyPresenceClass() {...}
+///  virtual char * PRESENCE_CLASS::GetClassName(void) const;
+///  ...
+///}
+///
+/// (at the end of your .cpp file)
+///
+///REGISTER_PRESENCE_CLASS(MyPresenceClass);
+/// @param PRESENCE_CLASS the class to register.
+///
+#define REGISTER_PRESENCE_CLASS(PRESENCE_CLASS) \
+char * PRESENCE_CLASS::GetClassName(void) const { return # PRESENCE_CLASS ; } \
+unsigned PRESENCE_CLASS::GetClassID(void) const { return PresenceRegistry::GetInstance()->getClassID(# PRESENCE_CLASS) ; } \
+static Presence * GetDefaultInstance ## PRESENCE_CLASS () { return new PRESENCE_CLASS(); } \
+static void registerBeforeMain ## PRESENCE_CLASS (void) { \
+  PresenceRegistry::GetInstance()->registerPresenceClass( # PRESENCE_CLASS ,  GetDefaultInstance ## PRESENCE_CLASS ); \
+  REGISTER_DISTRIBUTED_CLASS(PRESENCE_CLASS); \
+} \
+CALL_BEFORE_MAIN(registerBeforeMain ## PRESENCE_CLASS );
+
+///
+///
+#define REGISTER_PRESENCE_CLASS_NO_NETWORK(PRESENCE_CLASS) \
+char * PRESENCE_CLASS::GetClassName(void) const { return # PRESENCE_CLASS ; } \
+unsigned PRESENCE_CLASS::GetClassID(void) const { return PresenceRegistry::GetInstance()->getClassID(# PRESENCE_CLASS) ; } \
+static void registerBeforeMainNoNetwork ## PRESENCE_CLASS (void) { \
+  PresenceRegistry::GetInstance()->registerPresenceClass( # PRESENCE_CLASS ); \
+} \
+CALL_BEFORE_MAIN(registerBeforeMainNoNetwork ## PRESENCE_CLASS );
+
+
+
+
+
+
+
+/*
+void register_shipclass (const char *name, const char *source_name, Ship *(*getShip)(Vector2 pos, double a, ShipData *data, unsigned int code));
+#define REGISTER_SHIP_EX(ship,func) static void __register_ship_ex ## ship ## _ ## func () { register_ship( ship, __FILE__, func);} CALL_BEFORE_MAIN(__register_shipclass_ex ## ship ## _ ## func);
+#define REGISTER_SHIP(ship) static Ship *get_shipclass_ ## ship (Vector2 pos, double a, ShipData *d, unsigned int c){return(new ship(pos,a,d,c));} static void __register_shipclass_ ## ship () {register_shipclass(#ship, __FILE__, &get_shipclass_ ## ship);} CALL_BEFORE_MAIN(__register_shipclass_ ## ship);
+*/
+
+
+#endif

Modified: branches/multiplayer-branch/source/melee/manim.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/manim.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/manim.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: manim.cpp,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/manim.h
===================================================================
--- branches/multiplayer-branch/source/melee/manim.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/manim.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: manim.h,v 1.2 2004/08/07 12:33:53 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/mcbodies.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mcbodies.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mcbodies.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mcbodies.cpp,v 1.2 2004/08/07 12:33:53 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -467,3 +467,7 @@
     }
   return;
 }
+
+REGISTER_PRESENCE_CLASS(Stars);
+REGISTER_PRESENCE_CLASS(Planet);
+REGISTER_PRESENCE_CLASS(Asteroid);

Modified: branches/multiplayer-branch/source/melee/mcbodies.h
===================================================================
--- branches/multiplayer-branch/source/melee/mcbodies.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mcbodies.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mcbodies.h,v 1.2 2004/08/07 12:33:53 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -20,6 +20,7 @@
 
 #include "melee.h"
 #include "mframe.h"
+#include "melee/PresenceRegistry.h"
 
 /// \brief Asteroid space object
 class Asteroid : public SpaceObject {
@@ -32,6 +33,8 @@
 	public:
 	/// \brief init various stuff, pic, speed etc
 	Asteroid();
+	virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
 
 	/// \brief rotate
 	virtual void calculate();
@@ -55,6 +58,9 @@
 	/// Set collide flag, set layer, set mass to very huge, 
 	/// read from server.ini planet attributes
 	Planet(Vector2 location, SpaceSprite *sprite, int index);
+	Planet() { }
+	virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
 	
 	/// \brief inflict damage when collide
 	///
@@ -68,9 +74,12 @@
 /// \brief Background stars
 class Stars : public Presence {
 	virtual void _event( Event *e);
-	public:
+public:
 	Stars();
 	~Stars();
+	virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
+	
 	SpaceSprite **pic;
 	double width;
 	double height;
@@ -84,6 +93,9 @@
 	void animate(Frame *space);
 	void select_view( View **view);
 	View **v;
+	
+	REGISTER_1_DISTRIBUTED_OBJECT_MEMBERS(Presence,
+		DOM_COPY_COMPRESSED, DOM_CLIENT_AUTHORITATIVE, int, num_stars)
 };
 
 /// \brief helpers for drawing your own starfields

Modified: branches/multiplayer-branch/source/melee/mcontrol.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mcontrol.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mcontrol.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mcontrol.cpp,v 1.2 2004/08/03 11:37:22 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -375,3 +375,4 @@
   animate_target(space, target, (i%3)*2-2, ((i/3)%3)*2-2, 140 + i, pallete_color[col]);
 }
 
+//REGISTER_PRESENCE_CLASS_NO_NETWORK(Control);

Modified: branches/multiplayer-branch/source/melee/mcontrol.h
===================================================================
--- branches/multiplayer-branch/source/melee/mcontrol.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mcontrol.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mcontrol.h,v 1.2 2004/08/03 11:37:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -37,6 +37,9 @@
 
 class Control : public Presence {	
 	public:
+		Control() { }
+		virtual char * GetClassName(void) const { return "Control"; }
+		virtual unsigned GetClassID(void) const { return 0; }
 
   /*! \brief  controls CANNOT arbitrarily be killed off, because the deal with networking directly */
   virtual bool die(); 

Modified: branches/multiplayer-branch/source/melee/mfleet.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mfleet.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mfleet.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mfleet.cpp,v 1.3 2004/08/08 17:36:05 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/mfleet.h
===================================================================
--- branches/multiplayer-branch/source/melee/mfleet.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mfleet.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mfleet.h,v 1.1.1.1 2004/08/01 10:21:22 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/mframe.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mframe.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mframe.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mframe.cpp,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -39,9 +39,16 @@
 #include "util/pmask.h"
 #include "other/twconfig.h"
 #include "scp.h"
+    
+#include "melee/MultiplayerTypes.h"
+#include "melee/PresenceRegistry.h"
 
+#include <iostream>
+	
 int total_presences;
 
+
+
 #define DEATH_FRAMES 4
 //setting this too low will cause crashes
 //setting it too high will waste CPU power and RAM
@@ -73,6 +80,7 @@
 double MAX_SPEED = 0;
 
 
+
 void Query::begin (SpaceLocation *qtarget, int qlayers, double qrange) {STACKTRACE
 	if (qrange < 0) {tw_error("Query::begin - negative range");}
 	layers = qlayers;
@@ -300,7 +308,8 @@
 	}
 
 
-Presence::Presence() {
+Presence::Presence()
+{
   STACKTRACE;
 	total_presences += 1;
 	attributes = 0;
@@ -309,6 +318,8 @@
 	id = 0;
 	_depth = 0;
 	set_depth(DEPTH_PRESENCE);
+    
+    presenceType = PT_UNKNOWN;
 	}
 
 void Presence::animate(Frame *space) {
@@ -319,6 +330,9 @@
 void Presence::calculate() 
 {
   STACKTRACE;
+  //cout << "Presence::Calcuate: my class name is (" << this->GetClassName() << ":"<<this->GetClassID()<<")"<< endl;
+  //cout.flush();
+  this->UpdateDistributedObject(this->GetClassName());
 }
 bool Presence::die() 
 {
@@ -1389,3 +1403,9 @@
       ship_died((Ship*)who, source);
     }
 }
+
+REGISTER_PRESENCE_CLASS(SpaceLocation);
+REGISTER_PRESENCE_CLASS(SpaceObject);
+REGISTER_PRESENCE_CLASS(SpaceLine);
+
+

Modified: branches/multiplayer-branch/source/melee/mframe.h
===================================================================
--- branches/multiplayer-branch/source/melee/mframe.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mframe.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mframe.h,v 1.2 2004/08/07 12:33:53 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -21,6 +21,22 @@
 #include <list>
 #include <vector>
 
+#include "libraries/raknet/DistributedNetworkObjectHeader.h"
+#include "libraries/raknet/NetworkObject.h"
+#include "libraries/raknet/RakServerInterface.h"
+#include "libraries/raknet/RakClientInterface.h"
+#include "libraries/raknet/RakNetworkFactory.h"
+#include "libraries/raknet/BitStream.h"
+
+#include "melee/MultiplayerTypes.h"
+#include "melee/PresenceRegistry.h"
+//#include "melee/mview.h" // for message
+
+
+#include <vector>
+using namespace std;
+    
+    
 //debuging purposes only:
 extern int total_presences;
 
@@ -64,7 +80,7 @@
 };
 
 /// \brief melee universe
-class Physics : public BaseClass 
+class Physics : public BaseClass
 {
  public:
   
@@ -76,13 +92,13 @@
   std::list<Presence*> presence;
   
   /// add space location to universe
-  void add(SpaceLocation *p);
+  virtual void add(SpaceLocation *p);
   /// add presence from universe
-  void add(Presence *p);
+  virtual void add(Presence *p);
   /// remove space location to universe
-  bool remove(SpaceLocation *o);
+  virtual bool remove(SpaceLocation *o);
   /// remove presence from universe
-  bool remove(Presence *p) ;
+  virtual bool remove(Presence *p) ;
   
   TeamCode last_team;
   unsigned int last_ship;
@@ -94,7 +110,7 @@
  public:
   virtual unsigned int new_ship();
   virtual TeamCode new_team();
-  unsigned int get_code(unsigned int ship, TeamCode team) ;
+  virtual unsigned int get_code(unsigned int ship, TeamCode team) ;
   /// \brief causes team1 and team2 to be the same team (changes members of team2 to 
   /// being members of team1 instead)
   virtual void merge_teams ( TeamCode team1, TeamCode team2) ; 
@@ -134,7 +150,7 @@
 };
 
 /// \brief Any item in the game
-class Presence : public BaseClass 
+class Presence : public BaseClass, public DistributedNetworkObject
 { 
   friend class Physics;
  public:
@@ -171,14 +187,106 @@
   bool isShip() const ;      ///< returns true if it is the specified engine-defined type
   bool isShot() const;       ///< returns true if it is the specified engine-defined type
   bool isSynched() const;    ///< returns true if it is the specified engine-defined type
+
+  /// Gets the ID to refer to this object.  Used by the Raknet API to refer to objects
+  /// across multiple computers.
+  // @return the assigned ID.
+  virtual unsigned short GetObjectID(void) const { return NetworkObject::GetID(); }
   
+  /// Sets the ID to refer to this object.  Used by the Raknet API to refer to objects
+  /// Only the server code should call this!
+  /// @param id the ID to use.
+  virtual void SetObjectID(unsigned short id) { NetworkObject::SetID(id); }
+
+  /// Gets the ID to refer to this class.  
+  // @return the assigned class ID.
+  virtual unsigned GetClassID(void) const = 0;
+  
+  /// Gets the class name to refer to this class.  
+  // @return the assigned class ID.
+  virtual char * GetClassName(void) const = 0;
+  
+  
+  //Creates and returns an instance of this class.
+  //There's no need to code this yourself, instead, use the 
+  //REGISTER_PRESENCE_CLASS( yourClassName ) macro, which is defined in
+  //PresenceRegistry.
+  //@return an instance of this class, with default values
+  //@see PresenceRegistry
+  //static Presence * GetDefaultInstance(void);
+  
+  // Overload this to show a message
+  /*bool OnDistributedObjectCreation(PlayerID senderID)
+  {
+  	//message.print(5000,15,"Object Created\n");
+  	return true; // Allow object creation by returning true
+  }
+
+  // Overload this to show a message
+  void OnDistributedObjectDestruction(PlayerID senderID)
+  {
+  	//message.print(5000,15,"Object Destroyed\n");
+  	delete this;
+  }*/
+  
+  
+  /// Sets the ID to refer to this object.  Used by the Raknet API to refer to objects
+  /// Only the server code should call this!
+  /// @param id the ID to use.
+  //virtual void SetObjectID(unsigned short id) { NetworkObject::SetID(id); }
+
+  /// Gets a complete description of this Presence object, suitable for creating the object
+  /// over the network.  This is not used to duplicate an object, rather it's to create 
+  /// one from scratch.  Every conceivable variable to create the object should appear within 
+  /// this description object.
+  /// @param pcd The PresenceCreationDescription object to populate with data which exactly
+  /// coresponds to the data from this Presence object.  It's passed-by-reference.
+  
+  
+  ///
+//  virtual PresenceCreationDescription * getNetworkDescription() {
+//      PresenceCreationDescription * pcd = new PresenceCreationDescription(
+//          GetObjectID(),
+//          GetClassID()
+//      );
+//      printf("getNetworkDescription: objectID=%d ClassID=%d", GetObjectID(), GetClassID());
+//      
+//      return pcd;
+//  }
+//  
+//  virtual void updatePresenceObjectFromNetworkDescription(PresenceCreationDescription * info) {
+//      
+//  }
+  
+protected:
+  unsigned presenceType;
+  
+//  struct ClassName {
+//  	  char name[50];
+//  };
+  
+//  ClassName className;
+//  static char * typename;
+
+	REGISTER_1_DISTRIBUTED_OBJECT_MEMBERS(DistributedNetworkObject,
+		DOM_COPY_COMPRESSED, DOM_CLIENT_AUTHORITATIVE, unsigned, presenceType)
+
+public:		
 };
+//REGISTER_PRESENCE_CLASS(Presence);
 
+
+
+
 /// \brief any item in the game that has a location, base class for all items in game
 class SpaceLocation : public Presence 
 { 
   friend class Physics;
   friend struct Query;
+public: 
+  SpaceLocation() { }
+  virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
 
  protected: public: 
   //aught to be protected, but we're lazy
@@ -291,12 +399,21 @@
   virtual void animate(Frame *space); 
   /// advance the item frame_time milliseconds in time
   virtual void calculate(); 
+  
+  REGISTER_2_DISTRIBUTED_OBJECT_MEMBERS(Presence,
+  	DOM_COPY_UNCOMPRESSED, DOM_CLIENT_AUTHORITATIVE, Vector2, vel,
+  	DOM_COPY_COMPRESSED, DOM_CLIENT_AUTHORITATIVE, double, angle)
 };
 
+
+
 /// \brief any item with a sprite (only SpaceObjects can bounce)
 class SpaceObject : public SpaceLocation 
 {
  public:
+  SpaceObject() { }
+  virtual char * GetClassName(void) const;
+  virtual unsigned GetClassID(void) const;
   Vector2 size; ///< size of sprite
   double  mass; ///< mass of object
   bool isblockingweapons; ///< this object blocks weaponry (shots)
@@ -322,11 +439,18 @@
   virtual void inflict_damage(SpaceObject *other);
   
   virtual void set_sprite ( SpaceSprite *sprite );
+  
 };
 
+
 /// an item that appears as a line.  these can only collide with SpaceObjects, but not other lines.  
 class SpaceLine : public SpaceLocation 
 {
+ public:
+  SpaceLine(){ }
+  virtual char * GetClassName(void) const;
+  virtual unsigned GetClassID(void) const;
+  
  protected:
   double length;
   int    color;
@@ -343,8 +467,10 @@
   virtual void animate(Frame *space);
   virtual void collide(SpaceObject *o);
   virtual void inflict_damage(SpaceObject *other);
+  
 };
 
+
 struct Query 
 {
   private:

Modified: branches/multiplayer-branch/source/melee/mgame.h
===================================================================
--- branches/multiplayer-branch/source/melee/mgame.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mgame.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mgame.h,v 1.1.1.1 2004/08/01 10:21:22 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/mhelpers.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mhelpers.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mhelpers.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mhelpers.cpp,v 1.2 2004/08/03 11:37:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/mitems.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mitems.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mitems.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mitems.cpp,v 1.1.1.1 2004/08/01 10:21:22 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -265,3 +265,10 @@
 	vel.y = va * sin(angle) - vb * cos(angle);
 	return;
 	}
+
+//REGISTER_PRESENCE_CLASS(Indicator);
+REGISTER_PRESENCE_CLASS(HealthBar);
+REGISTER_PRESENCE_CLASS(BlinkyIndicator);
+REGISTER_PRESENCE_CLASS(WedgeIndicator);
+REGISTER_PRESENCE_CLASS(Orbiter);
+

Modified: branches/multiplayer-branch/source/melee/mitems.h
===================================================================
--- branches/multiplayer-branch/source/melee/mitems.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mitems.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mitems.h,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -23,6 +23,9 @@
 	Ship	*mother;
 
 	HealthBar(Ship *creator, int *toggle);
+	HealthBar() { }
+	virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
 	void calculate();
 	void animate(Frame *space );
 
@@ -32,6 +35,8 @@
 class Indicator : public Presence {
 	public:
 	Indicator();
+	virtual char * GetClassName(void) const { return "Indicator"; }
+	virtual unsigned GetClassID(void) const { return 0; }
 	bool coords(Frame *space, SpaceLocation *l, Vector2 *pos, Vector2 *apos = NULL) ;
 	void animate(Frame *space) = 0;
 	};
@@ -41,6 +46,9 @@
 	SpaceObject *target;
 	int color;
 	BlinkyIndicator(SpaceObject *target, int color = -1);
+	BlinkyIndicator(): target(NULL), color(-1) { }
+	virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
 	virtual void animate(Frame *space);
 	virtual void calculate();
 	};
@@ -51,6 +59,9 @@
 	int color;
 	int length;
 	WedgeIndicator(SpaceLocation *target, int length, int color);
+	WedgeIndicator() : target(NULL), color(15), length(0) { }
+	virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
 	virtual void animate(Frame *space);
 	virtual void calculate();
 	};
@@ -61,4 +72,7 @@
 	double radius;
 	virtual void calculate();
 	Orbiter ( SpaceSprite *sprite, SpaceLocation *orbit, double distance);
+	Orbiter () : center(NULL), radius(0) { }
+	virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
 };

Modified: branches/multiplayer-branch/source/melee/mlog.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mlog.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mlog.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mlog.cpp,v 1.2 2004/08/03 07:08:55 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/mlog.h
===================================================================
--- branches/multiplayer-branch/source/melee/mlog.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mlog.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mlog.h,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/mmath.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mmath.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mmath.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mmath.cpp,v 1.2 2004/08/05 21:06:38 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/mnet1.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mnet1.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mnet1.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mnet1.cpp,v 1.2 2004/08/03 07:08:55 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/mnet1.h
===================================================================
--- branches/multiplayer-branch/source/melee/mnet1.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mnet1.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mnet1.h,v 1.2 2004/08/03 07:08:55 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/moptions.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/moptions.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/moptions.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: moptions.cpp,v 1.3 2004/08/03 11:37:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/moptions.h
===================================================================
--- branches/multiplayer-branch/source/melee/moptions.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/moptions.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: moptions.h,v 1.1 2004/08/03 22:17:54 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/mship.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mship.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mship.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -403,7 +403,10 @@
 
 Ship::~Ship() 
 {
-  delete spritePanel;
+  if (spritePanel) {
+     delete spritePanel;
+     spritePanel = NULL;
+  }
 }
 
 double Ship::getCrew()
@@ -988,3 +991,11 @@
 		PHASE_DELAY, PHASE_MAX, PHASE_DELAY
 	);
 }
+
+REGISTER_PRESENCE_CLASS(Ship)
+REGISTER_PRESENCE_CLASS(Shot)
+REGISTER_PRESENCE_CLASS(AnimatedShot)
+REGISTER_PRESENCE_CLASS(Missile)
+REGISTER_PRESENCE_CLASS(HomingMissile)
+REGISTER_PRESENCE_CLASS(Laser)
+REGISTER_PRESENCE_CLASS(PointLaser)

Modified: branches/multiplayer-branch/source/melee/mship.h
===================================================================
--- branches/multiplayer-branch/source/melee/mship.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mship.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mship.h,v 1.2 2004/08/07 12:33:54 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -80,6 +80,11 @@
 /// \brief Exactly what is sounds like
 class Ship : public SpaceObject 
 {
+public:
+	Ship() { }
+	virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
+	
  protected:
   
   int hotspot_frame;

Modified: branches/multiplayer-branch/source/melee/mshot.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mshot.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mshot.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mshot.cpp,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/mshot.h
===================================================================
--- branches/multiplayer-branch/source/melee/mshot.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mshot.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mshot.h,v 1.2 2004/08/07 12:33:54 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -35,8 +35,11 @@
   int          explosionFrameCount;
   int          explosionFrameSize;
   
+  Shot() { }
   Shot(SpaceLocation *creator, Vector2 rpos, double oangle, double ov, double odamage,
        double orange, double oarmour, SpaceLocation *opos, SpaceSprite *osprite, double relativity = game->shot_relativity);
+  virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
   
   virtual void animate(Frame *space);
   
@@ -67,6 +70,9 @@
   AnimatedShot(SpaceLocation *creator, Vector2 rpos, double oangle, 
 	       double ov, double odamage, double orange, double oarmour, SpaceLocation *opos,
 	       SpaceSprite *osprite, int ofcount, int ofsize, double relativity = game->shot_relativity);
+  AnimatedShot() { }
+  virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
   
   virtual void calculate();
 };
@@ -74,9 +80,12 @@
 /// \brief A shot that uses an image depending upon which angle it's pointing
 class Missile : public Shot {
 	public:
+	Missile() {}
 	Missile(SpaceLocation *creator, Vector2 rpos, double oangle, double ov, double odamage,
 			double orange, double oarmour, SpaceLocation *opos,
 			SpaceSprite *osprite, double relativity = game->shot_relativity);
+	virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
 
 	virtual void changeDirection(double oangle);
 	};
@@ -88,9 +97,12 @@
 	double turn_step;
 
 	public:
+	HomingMissile() { }
 	HomingMissile(SpaceLocation *creator, Vector2 rpos, double oangle, double ov, double odamage,
 			double orange, double oarmour, double otrate, SpaceLocation *opos,
 			SpaceSprite *osprite, SpaceObject *target);
+	virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
 
 	virtual void animate(Frame *space);
 	virtual void calculate();
@@ -109,6 +121,9 @@
 	public:
 	Laser(SpaceLocation *creator, double langle, int lcolor, double lrange, double ldamage, int lfcount,
 		SpaceLocation *opos, Vector2 rpos = Vector2(0,0), bool osinc_angle=false);
+	Laser() { }
+	virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
 
 	void calculate();
 };
@@ -119,8 +134,11 @@
   SpaceObject *target;
 
   public:
+  	PointLaser() { }
 	PointLaser(SpaceLocation *creator, int lcolor, double ldamage, int lfcount, 
 		SpaceLocation *lsource, SpaceObject *ltarget, Vector2 rel_pos = Vector2(0,0)) ;
+	virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
 
   void calculate();
   int canCollide(SpaceObject *other);

Modified: branches/multiplayer-branch/source/melee/mshpdata.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mshpdata.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mshpdata.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mshpdata.cpp,v 1.3 2004/08/07 07:48:50 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/mshppan.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mshppan.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mshppan.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mshppan.cpp,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -75,8 +75,10 @@
 
 ShipPanel::~ShipPanel()
 {STACKTRACE
-  destroy_bitmap(captain);
-  destroy_bitmap(panel);
+  if (captain)
+  	destroy_bitmap(captain);
+  if (panel) 
+  	destroy_bitmap(panel);
   window->deinit();
   delete window;
 }
@@ -385,3 +387,4 @@
 	return;
 }
 
+REGISTER_PRESENCE_CLASS(ShipPanel);

Modified: branches/multiplayer-branch/source/melee/mshppan.h
===================================================================
--- branches/multiplayer-branch/source/melee/mshppan.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mshppan.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mshppan.h,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -59,7 +59,10 @@
 	int always_redraw;
 
 	ShipPanel(Ship *oship);
+	ShipPanel() : ship(NULL) { }
 	virtual ~ShipPanel();
+	virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
 
 	virtual void draw_stuff(int x, int y, int w, int h, int dx, int dy, int m, int value, int max, int color, int bcolor);
 	//used for drawing crew & battery bars

Modified: branches/multiplayer-branch/source/melee/msprite.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/msprite.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/msprite.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: msprite.cpp,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/mtarget.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mtarget.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mtarget.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mtarget.cpp,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/mtarget.h
===================================================================
--- branches/multiplayer-branch/source/melee/mtarget.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mtarget.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mtarget.h,v 1.1.1.1 2004/08/01 10:21:22 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/mview.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mview.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mview.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mview.cpp,v 1.1.1.1 2004/08/01 10:21:22 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee/mview.h
===================================================================
--- branches/multiplayer-branch/source/melee/mview.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee/mview.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: mview.h,v 1.2 2004/08/08 17:36:06 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/melee.h
===================================================================
--- branches/multiplayer-branch/source/melee.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/melee.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: melee.h,v 1.3 2004/08/08 17:36:03 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/other/configrw.cpp
===================================================================
--- branches/multiplayer-branch/source/other/configrw.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/configrw.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: configrw.cpp,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/other/configrw.h
===================================================================
--- branches/multiplayer-branch/source/other/configrw.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/configrw.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: configrw.h,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/other/dialogs.cpp
===================================================================
--- branches/multiplayer-branch/source/other/dialogs.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/dialogs.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: dialogs.cpp,v 1.2 2004/08/03 21:05:00 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/other/dialogs.h
===================================================================
--- branches/multiplayer-branch/source/other/dialogs.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/dialogs.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: dialogs.h,v 1.1 2004/08/03 12:02:26 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/other/fontmorph.cpp
===================================================================
--- branches/multiplayer-branch/source/other/fontmorph.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/fontmorph.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: fontmorph.cpp,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/other/fontmorph.h
===================================================================
--- branches/multiplayer-branch/source/other/fontmorph.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/fontmorph.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: fontmorph.h,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Deleted: branches/multiplayer-branch/source/other/gup.cpp
===================================================================
--- branches/multiplayer-branch/source/other/gup.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/gup.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,713 +0,0 @@
-#include <string.h>
-#include <allegro.h>
-#include "melee.h"
-
-#include "melee/mframe.h"
-#include "melee/mship.h"
-#include "melee/mcbodies.h"
-#include "melee/mview.h"
-#include "frame.h"
-#include "sc1ships.h"
-#include "sc2ships.h"
-#include "games/ggob.h"
-#include "gup.h"
-
-/* this file contains the ship upgrades used by Gob */
-
-/*
-Generic Upgrades
-*/
-
-/*
-NOTE that execute() is called BEFORE charge(), so 
-num is not yet incremented when execute() is running
-*/
-void Upgrade::clear(Ship *oship, Ship *nship, GobPlayer *gs) {
-  STACKTRACE;
-	if (oship) gs->total -= num;
-	num = 0;
-	return;
-	}
-void Upgrade::charge(GobPlayer *gs) {
-  STACKTRACE; //called AFTER execute
-	gs->total += 1;
-	num += 1;
-	gs->value_starbucks += this->starbucks;
-	gs->value_buckazoids += this->buckazoids;
-	return;
-	}
-
-#define UPGRADE(a) virtual Upgrade *duplicate() {return new a();}
-class UpCrewpod : public Upgrade {
-	UPGRADE(UpCrewpod)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Add Crewpod";
-		if (ship->crew_max >= 42) return false;
-		starbucks = 2;
-		buckazoids = gs->total / 3;
-		return true;
-		}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		ship->crew_max += 4;
-		if (ship->crew_max > 42) ship->crew_max = 42;
-		ship->crew += 4;
-		if (ship->crew > 42) ship->crew = 42;
-		}
-	} crewpod;
-
-class UpBattery : public Upgrade {
-	UPGRADE(UpBattery)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Add Battery";
-		if (ship->batt_max >= 42) return false;
-		starbucks = 1;
-		buckazoids = gs->total / 3;
-		return true;
-		}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		ship->batt_max += 8;
-		if (ship->batt_max > 42) ship->batt_max = 42;
-		ship->batt += 8;
-		if (ship->batt > 42) ship->batt = 42;
-		}
-	} battery;
-
-class UpThrusters : public Upgrade {
-	UPGRADE(UpThrusters)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Upgrade Thrusters";
-		starbucks = 3 + num * 3;
-		buckazoids = gs->total / 3;
-		return true;
-		}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		ship->speed_max *=  1 + .3  / (.25*num + 1);
-		ship->accel_rate *= 1 + .18 / (.12*num + 1);
-		}
-	} thrusters;
-
-class UpControlJets : public Upgrade {
-	UPGRADE(UpControlJets)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Upgrade Control Jets";
-		starbucks = 2 + num * 2;
-		buckazoids = gs->total / 3;
-		return true;
-		}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		ship->turn_rate  *=  1 + .3  / (num + 1);
-		ship->accel_rate *=  1 + .1  / (.0*num + 1);
-		}
-	} controljets;
-
-class UpDynamo : public Upgrade {
-	UPGRADE(UpDynamo)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Upgrade Dynamo";
-		starbucks = 16 / (1 + ship->recharge_amount-num) + num;
-		if (ship->recharge_amount == 0) starbucks *= 6;
-		if (ship->weapon_rate < 100) starbucks /= 2;
-		if (ship->special_drain > 16) starbucks *= 2;
-		if (!strcmp("supbl", ship->type->id)) starbucks /= 2;
-		buckazoids = gs->total / 3;
-		return true;
-	}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		ship->recharge_amount += 1;
-	}
-} dynamo;
-
-/*
-Supox Upgrades
-*/
-
-class UpSupoxRange : public Upgrade {
-	UPGRADE(UpSupoxRange)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Upgrade Glob Hurler (Supox)";
-		if (strcmp("supbl", ship->type->id)) return false;
-		starbucks = 2 + num;
-		buckazoids = gs->total / 3;
-		return true;
-		}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		((SupoxBlade*)ship)->weaponRange *= 1 + .25 / (1 + num*.1);
-		((SupoxBlade*)ship)->weaponVelocity *= 1.15;
-		}
-	} supoxrange;
-
-class UpSupoxDamage : public Upgrade {
-	UPGRADE(UpSupoxDamage)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Upgrade Glob Former (Supox)";
-		if (strcmp("supbl", ship->type->id)) return false;
-		if (gs->ship->recharge_amount < (1<<num)) return false;
-		if (num > 7) return false;
-		starbucks = 5;
-		buckazoids = gs->total / 3;
-		return true;
-		}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		((SupoxBlade*)ship)->weaponDamage += 1;
-		((SupoxBlade*)ship)->weaponArmour += 1;
-		((SupoxBlade*)ship)->weapon_drain += num + 1;
-		if (num > 1) ((SupoxBlade*)ship)->recharge_amount += 1;
-		}
-	} supoxdamage;
-
-class UpSupoxBLADE : public Upgrade {
-	UPGRADE(UpSupoxBLADE)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Add B.L.A.D.E. (Supox)";
-		if (strcmp("supbl", ship->type->id)) return false;
-		starbucks = 2 + num;
-		buckazoids = gs->total / 3;
-		return true;
-		}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		((SupoxBlade*)ship)->damage_factor += 3;
-		}
-	} supoxblade;
-
-/*
-Orz Upgrades
-*/
-
-class UpOrzMissile : public Upgrade {
-	UPGRADE(UpOrzMissile)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Upgrade Missiles (ORZ)";
-		if (strcmp("orzne", ship->type->id)) return false;
-		starbucks = 6;
-		buckazoids = gs->total / 2 + 2;
-		return true;
-		}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		((OrzNemesis*)ship)->weaponDamage += 1;
-		((OrzNemesis*)ship)->weaponArmour += 1;
-		((OrzNemesis*)ship)->weaponRange *= 1.15;
-		((OrzNemesis*)ship)->weapon_drain += 1;
-		}
-	} orzmissile;
-
-class UpOrzMarineSpeed : public Upgrade {
-	UPGRADE(UpOrzMarineSpeed)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Upgrade Marine Suits (ORZ)";
-		if (strcmp("orzne", ship->type->id)) return false;
-		starbucks = 3 + num * 2;
-		buckazoids = gs->total / 3;
-		return true;
-		}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		((OrzNemesis*)ship)->specialArmour += 1;
-		((OrzNemesis*)ship)->specialSpeedMax *= 1 + .2 / (.2*num+1);
-		((OrzNemesis*)ship)->specialAccelRate *= 1.15;
-		}
-	} orzmarinespeed;
-
-class UpOrzAbsorbtion : public Upgrade {
-	UPGRADE(UpOrzAbsorbtion)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Absorbtion (ORZ)";
-		if (strcmp("orzne", ship->type->id)) return false;
-		if (num) return false;
-		starbucks = 15;
-		buckazoids = gs->total / 3;
-		return true;
-	}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		((OrzNemesis*)ship)->absorption = 256 / 3;
-	}
-	void charge(GobPlayer *gs) {
-		Upgrade::charge(gs);
-		gs->total += 2;
-	}
-} orzabsorption;
-
-/*
-Kohr-Ah Upgrades
-*/
-
-class UpKohrAhBladeDamage : public Upgrade {
-	UPGRADE(UpKohrAhBladeDamage)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Increase Shuriken Sharpness (Kohr-Ah)";
-		if (strcmp("kohma", ship->type->id)) return false;
-		starbucks = 2 + num;
-		buckazoids = gs->total / 3;
-		return true;
-		}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		((KohrAhMarauder*)ship)->weaponDamage += 1;
-		((KohrAhMarauder*)ship)->weaponArmour += 1;
-		((KohrAhMarauder*)ship)->weapon_drain += 1;
-		}
-	} kohrahbladedamage;
-
-class UpKohrAhBladeSpeed : public Upgrade {
-	UPGRADE(UpKohrAhBladeSpeed)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		if (strcmp("kohma", ship->type->id)) return false;
-		name = "Increase Shuriken Velocity (Kohr-Ah)";
-		starbucks = 2 + num * 2;
-		buckazoids = gs->total / 3;
-		return true;
-	}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		((KohrAhMarauder*)ship)->weaponVelocity *= 1.2;
-	}
-} kohrahbladespeed;
-
-class UpKohrAhFireRange : public Upgrade {
-	UPGRADE(UpKohrAhFireRange)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "double F.R.I.E.D. range (Kohr-Ah)";
-		if (strcmp("kohma", ship->type->id)) return false;
-		if (num) return false;
-		starbucks = 30;
-		buckazoids = gs->total / 3;
-		return true;
-		}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		((KohrAhMarauder*)ship)->specialRange *= 2;
-		((KohrAhMarauder*)ship)->specialVelocity *= 1.4;
-		((KohrAhMarauder*)ship)->special_drain += 12;
-		}
-	} kohrahfirerange;
-
-class UpKohrAhFireDamage : public Upgrade {
-	UPGRADE(UpKohrAhFireDamage)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "double F.R.I.E.D. damage (Kohr-Ah)";
-		if (strcmp("kohma", ship->type->id)) return false;
-		if (num) return false;
-		starbucks = 13;
-		buckazoids = gs->total / 3;
-		return true;
-	}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		((KohrAhMarauder*)ship)->specialDamage *= 2;
-		((KohrAhMarauder*)ship)->special_drain += 6;
-	}
-} kohrahfiredamage;
-
-/*
-Utwig Upgrades
-*/
-
-class UpUtwigJuggerRange : public Upgrade {
-	UPGRADE(UpUtwigJuggerRange)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Upgrade Bolt Regulator (Utwig)";
-		if (strcmp("utwju", ship->type->id)) return false;
-		starbucks = 3;
-		buckazoids = gs->total / 3;
-		return true;
-	}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		((UtwigJugger*)ship)->weaponRange += 100;
-	}
-} utwigrange;
-class UpUtwigJuggerDamage : public Upgrade {
-	UPGRADE(UpUtwigJuggerDamage)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Upgrade Bolt Charger (Utwig)";
-		if (strcmp("utwju", ship->type->id)) return false;
-		starbucks = (num + 3) * 5;
-		buckazoids = gs->total / 3;
-		return true;
-	}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		((UtwigJugger*)ship)->weaponDamage += 1;
-		ship->weapon_rate += 250;
-	}
-} utwigdamage;
-class UpUtwigJuggerROF : public Upgrade {
-	UPGRADE(UpUtwigJuggerROF)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Upgrade Bolt Generator (Utwig)";
-		if (strcmp("utwju", ship->type->id)) return false;
-		if (ship->weapon_rate < 425) return false;
-		starbucks = num / 2 + 2;
-		buckazoids = gs->total / 3;
-		return true;
-	}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		ship->weapon_rate -= 50;
-	}
-} utwigrof;
-class UpUtwigJuggerMaskOfHonestDemeanor : public Upgrade {
-	UPGRADE(UpUtwigJuggerMaskOfHonestDemeanor)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Mask of Honest Demeanor (max 1 mask)";
-		if (strcmp("utwju", ship->type->id)) return false;
-		if ((num + gs->upgrade_list[UpgradeIndex::utwigmask2]->num) == 1) return false;
-		starbucks = 99;
-		buckazoids = 0;
-		return true;
-	}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		gs->value_starbucks += 251;
-		gs->value_buckazoids += 250;
-	}
-} utwigmask1;
-class UpUtwigJuggerMaskOfElephantineFortitude : public Upgrade {
-	UPGRADE(UpUtwigJuggerMaskOfElephantineFortitude)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Mask of Elephantine Fortitude (max 1 mask)";
-		if (strcmp("utwju", ship->type->id)) return false;
-		if ((num + gs->upgrade_list[UpgradeIndex::utwigmask1]->num) == 1) return false;
-		starbucks = 99;
-		buckazoids = 0;
-		return true;
-	}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		((UtwigJugger*)ship)->fortitude = 1;
-	}
-} utwigmask2;
-
-/*
-Special Upgrades
-*/
-
-class UpDivineFavor : public Upgrade {
-	UPGRADE(UpDivineFavor)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Divine Favor (unique)";
-		if (strcmp(station->build_type, "orzne")) return false;
-		if (num) return false;
-		starbucks = 150;
-		buckazoids = 0;
-		return true;
-		}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		}
-	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
-		if (!oship) num = 0;
-		return;
-		}
-	void charge(GobPlayer *gs) {
-		num += 1;
-		}
-	} divinefavor;
-
-class UpUnholyAura : public Upgrade {
-	UPGRADE(UpUnholyAura)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "the Devil protects his own...";
-		starbucks = 6;
-		buckazoids = 66;
-		//if (strcmp(station->build_type, "orzne")) return false;
-		if (num) return false;
-		if (((game->game_time / 1000) % 1000) == 666) return true;
-		if (((game->game_time / 1000) % 666) == 0) return true;
-		//666, 1332, 1666, 1998, etc.
-		return false;
-		}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		game->add ( new UnholyAura ( ship ) );
-		}
-	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
-		if (!oship) num = 0;
-		else if (num) {
-			game->add ( new UnholyAura ( nship ) );
-		}
-		return;
-		}
-	void charge(GobPlayer *gs) {
-		num += 1;
-		}
-	} unholyaura;
-
-
-class UpDefender : public Upgrade {
-	UPGRADE(UpDefender)
-	GobDefender *def[6];
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "External Defense System";
-		if (strcmp(station->build_type, "kohma")) return false;
-		if (num >= 6) return false;
-		starbucks = 5 + 5 * (num+1) * num;
-		buckazoids = 12;
-		return true;
-	}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		def[num] = new GobDefender(ship);
-		int i;
-		for (i = 0; i <= num; i += 1) def[i]->base_phase = i * PI2 / (num+1);
-		gobgame->add (def[num]);
-	}
-	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
-		if (!oship) num = 0;
-		if (oship) {
-			for (int i = 0; i < num; i += 1) {
-				def[i]->die();
-				def[i] = new GobDefender(nship);
-				def[i]->base_phase = i * PI2 / num;
-				game->add(def[i]);
-			}
-		}
-		//Upgrade::clear(oship, nship, gs);
-		return;
-	}
-	void charge(GobPlayer *gs) {
-		gs->total += 1;
-		num += 1;
-	}
-} defender;
-
-class UpPlanetLocater : public Upgrade {
-	UPGRADE(UpPlanetLocater)
-	Presence **locater;
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Planet Locater";
-		if (strcmp(station->build_type, "supbl")) return false;
-		if (num) return false;
-		starbucks = 4;
-		buckazoids = 5;
-		return true;
-	}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		locater = new Presence *[gobgame->num_planets];
-		for (int i = 0; i < gobgame->num_planets; i += 1) {
-			locater[i] = new WedgeIndicator ( gobgame->planet[i], 80, 2 );
-			gobgame->add (locater[i] );
-		}
-	}
-	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
-		Upgrade::clear(oship, nship, gs);
-		if (oship && locater) for (int i = 0; i < gobgame->num_planets; i += 1) {
-			locater[i]->die();
-		}
-		locater = NULL;
-		return;
-	}
-} planetlocater;
-
-class UpHyperDynamo : public Upgrade {
-	UPGRADE(UpHyperDynamo)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Hyper Dynamo (ancient artifact)";
-		if (game->game_time / 1000 < 21 * 60) return false;
-		starbucks = 720 / (game->game_time / (1000*60*10) - 1);
-		//unavailable before 20 minutes
-		//720 starbucks at 20 minutes
-		//360 starbucks at 30 minutes
-		//240 starbucks at 40 minutes
-		//180 starbucks at 50 minutes
-		//144 starbucks at 60 minutes
-		//120 starbucks at 70 minutes
-		//102 starbucks at 80 minutes
-		//90 starbucks at 90 minutes
-		buckazoids = starbucks/2 + gs->total / 3;
-		if (gs->starbucks < starbucks / 4) return false;
-		if (ship->recharge_amount == 0) return false;
-		if (num) return false;
-		return true;
-	}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		ship->recharge_rate /= 2;
-	}
-} hyperdynamo;
-
-/*class UpRoswellDevice : public Upgrade {
-	UPGRADE(UpUnholyAura)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Roswell Device";
-		if (((game->game_time / 1000) % 1000) < 700) return false;
-		starbucks = 99;
-		buckazoids = 9;
-		if (strcmp(station->build_type, "utwju")) return false;
-		if (num) return false;
-		return true;
-	}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		game->add ( new RoswellDevice ( ship ) );
-	}
-	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
-		if (!oship) num = 0;
-		else if (num) {
-			game->add ( new RoswellDevice ( nship ) );
-		}
-		return;
-	}
-	void charge(GobPlayer *gs) {
-		num += 1;
-	}
-} roswelldevice;*/
-
-/*
-note to future coders:
-in order for an upgrade to show up, it must be added to this list
-anything added to this list MUST be added, in the same order, to 
-the enum in gup.h
-*/
-static Upgrade *_upgrade_list[] = {
-	&crewpod,
-	&battery,
-	&thrusters,
-	&controljets,
-	&dynamo,
-	&supoxrange,
-	&supoxdamage,
-	&supoxblade,
-	&orzmissile,
-	&orzmarinespeed,
-	&orzabsorption,
-	&kohrahbladedamage,
-	&kohrahbladespeed,
-	&kohrahfirerange,
-	&kohrahfiredamage,
-	&utwigrange,
-	&utwigdamage,
-	&utwigrof,
-	&utwigmask1,
-	&utwigmask2,
-	&divinefavor,
-	&unholyaura,
-	&defender,
-	&planetlocater,
-	&hyperdynamo,
-//	&roswelldevice,
-	NULL
-	};
-
-Upgrade **upgrade_list = _upgrade_list;
-
-UnholyAura::UnholyAura ( SpaceLocation * ship ) {
-	focus = ship;
-	angle = 0;
-}
-void UnholyAura::animate (Frame *frame) {
-	Vector2 p = corner(focus->normal_pos());
-	const int speed = 1500;
-	int color = game->game_time % speed;
-	if (color > speed/2) color = speed - color;
-	color = tw_color ( color * 255 * 2 / speed, 0, 0);
-	Vector2 r;
-	r.y = space_zoom * 240;
-	r.x = r.y * 1.5;
-	double a = angle;
-	line (frame->surface, 
-		p + r *(unit_vector(a +   0 * ANGLE_RATIO)), 
-		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
-		color);
-	a += 72 * ANGLE_RATIO;
-	line (frame->surface, 
-		p + r * (unit_vector(a +   0 * ANGLE_RATIO)), 
-		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
-		color);
-	a += 72 * ANGLE_RATIO;
-	line (frame->surface, 
-		p + r * (unit_vector(a +   0 * ANGLE_RATIO)), 
-		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
-		color);
-	a += 72 * ANGLE_RATIO;
-	line (frame->surface, 
-		p + r * (unit_vector(a +   0 * ANGLE_RATIO)), 
-		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
-		color);
-	a += 72 * ANGLE_RATIO;
-	line (frame->surface, 
-		p + r * (unit_vector(a +   0 * ANGLE_RATIO)), 
-		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
-		color);
-	frame->add_box(iround(p.x - r.x-1), iround(p.y - r.y-1), iround(r.x*2+3), iround(r.y*2+3));
-}
-void UnholyAura::calculate () {
-	if (!focus->exists()) die();
-	angle -= frame_time / 10.0;
-	if (angle < 0) angle += 360;
-	if (random(1700) < frame_time) {
-		Query q;
-		q.begin(focus, OBJECT_LAYERS, 666);
-		for (;q.current; q.next() ) {
-			if (!(focus->sameTeam(q.current))) q.current->handle_damage(focus, 0, random() % 6);
-		}
-	}
-}
-/*
-void GobRadar::animate_item ( SpaceLocation *item ) {
-	int type = 0;
-	int color = 0;
-	double angle = 0;
-	double radius = 0;
-	double x, y;
-	x = normalize(item->normal_x() - gx + X_MAX/2, X_MAX) - X_MAX/200+gx/2;
-	x *= window->w / gw;
-	y = normalize(item->normal_y() - gy + Y_MAX/2, Y_MAX) - Y_MAX/200+gy/2;
-	y *= window->h / gh;
-	TeamCode t = item->get_team();
-	if (t == 0) color = palette_color[6];
-	else if (t == team) color = palette_color[7];
-	else color = palette_color[4];
-	color = palette_color[7];
-	if (item->isObject()) {
-		SpaceSprite *sprite = ((SpaceObject*)item)->get_sprite();
-		if (sprite) radius = 
-			sqrt(sprite->width() * sprite->width() + sprite->height() * sprite->height()) / 2 / gw;
-		else return;
-		if (radius < 5) radius = sqrt(radius * 5);
-	}
-	else if (item->isLine()) {
-		type = 1;
-		radius = (((SpaceLine*)item)->get_length()) / gw;
-		angle = (((SpaceLine*)item)->get_angle());
-	}
-
-
-	if (type == 0) {
-		circlefill ( window->surface, 
-			window->x + x, 
-			window->y + y, 
-			radius,
-			color
-		);
-	}
-	else if (type == 1) {
-		line (  window->surface,
-			window->x + x, 
-			window->y + y,
-			window->x + x + cos(angle) * radius,
-			window->y + y + sin(angle) * radius,
-			color
-		);
-	}
-}
-
-void GobRadar::animate ( Frame * frame ) {
-	Query q;
-	if (!window->surface) return;
-
-	window->lock();
-
-	rectfill(window->surface, 
-		window->x, window->y, 
-		window->x + window->w,
-		window->y + window->h,
-		0
-		);
-	for (q.begin(0, 0, ALL_LAYERS, 999999999999);q.current;q.next()) {
-		if (!q.current->exists()) continue;
-		if (q.current->isInvisible())
-			continue;
-		animate_item(q.current);
-	}
-	q.end();
-
-	window->unlock();
-}
-
-GobRadar::GobRadar() {
-  STACKTRACE;
-	attributes &= ~ATTRIB_SYNCHED;
-	team = 0;
-	gx = 0;
-	gy = 0;
-	gw = X_MAX;
-	gh = Y_MAX;
-	window = new VideoWindow();
-	window->preinit();
-}
-*/

Deleted: branches/multiplayer-branch/source/other/gup.h
===================================================================
--- branches/multiplayer-branch/source/other/gup.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/gup.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,74 +0,0 @@
-class Upgrade;
-extern Upgrade **upgrade_list;
-
-class UpgradeIndex {
-public:
-	enum {
-		crewpod,
-		battery,
-		thrusters,
-		controljets,
-		dynamo,
-		supoxrange,
-		supoxdamage,
-		supoxblade,
-		orzmissile,
-		orzmarinespeed,
-		orzabsorption,
-		kohrahbladedamage,
-		kohrahbladespeed,
-		kohrahfirerange,
-		kohrahfiredamage,
-		utwigrange,
-		utwigdamage,
-		utwigrof,
-		utwigmask1,
-		utwigmask2,
-		divinefavor,
-		unholyaura,
-		defender,
-		planetlocater,
-		hyperdynamo,
-		//gobradar,
-		//roswelldevice,
-		NULL_UPGRADE
-	};
-};
-
-class GobDefender : public SpaceObject {
-	public:
-	GobDefender ( Ship *ship);
-	double base_phase;
-	virtual void calculate();
-	int next_shoot_time;
-};
-
-/*class RoswellDevice : public Presence {
-	public:
-	RoswellDevice ( Ship *ship, double angle );
-	virtual void calculate();
-	int next_shoot_time;
-	double phase;
-};*/
-
-class UnholyAura : public Presence {
-public:
-	SpaceLocation *focus;
-	double angle;
-	virtual void calculate ();
-	virtual void animate ( Frame * frame);
-	UnholyAura ( SpaceLocation *ship );
-};
-
-/*
-class GobRadar : public Presence {
-public:
-	TeamCode team;
-	double gx, gy, gw, gh;
-	VideoWindow *window;
-	//virtual void calculate ();
-	virtual void animate ( Frame * frame );
-	virtual void animate_item ( SpaceLocation *item);
-	GobRadar();
-};*/
-

Modified: branches/multiplayer-branch/source/other/nullphas.cpp
===================================================================
--- branches/multiplayer-branch/source/other/nullphas.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/nullphas.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: nullphas.cpp,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -40,3 +40,5 @@
   }
 }
 
+
+

Modified: branches/multiplayer-branch/source/other/nullphas.h
===================================================================
--- branches/multiplayer-branch/source/other/nullphas.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/nullphas.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: nullphas.h,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/other/objanim.cpp
===================================================================
--- branches/multiplayer-branch/source/other/objanim.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/objanim.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: objanim.cpp,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/other/objanim.h
===================================================================
--- branches/multiplayer-branch/source/other/objanim.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/objanim.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: objanim.h,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/other/orbit.cpp
===================================================================
--- branches/multiplayer-branch/source/other/orbit.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/orbit.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: orbit.cpp,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -21,13 +21,14 @@
 #include "id.h"
 #include "scp.h"
 #include "frame.h"
-#include "ship.h"
+#include "melee/mship.h"
 
 #include "melee/mgame.h"
 #include "melee/mview.h"
 #include "melee/mcbodies.h"
 #include "melee/manim.h"
 #include "melee/mship.h"
+#include "melee/mshot.h"
 
 #include "orbit.h"
 

Modified: branches/multiplayer-branch/source/other/orbit.h
===================================================================
--- branches/multiplayer-branch/source/other/orbit.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/orbit.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: orbit.h,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/other/planet3d.cpp
===================================================================
--- branches/multiplayer-branch/source/other/planet3d.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/planet3d.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: planet3d.cpp,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -16,8 +16,10 @@
 */
 
 
-#include "ship.h"
+#include "melee.h"
+#include "melee/mship.h"
 #include "melee/mview.h"
+#include "melee/mgame.h"
 
 #include "util/pmask.h"
 #include "util/aastr.h"

Modified: branches/multiplayer-branch/source/other/planet3d.h
===================================================================
--- branches/multiplayer-branch/source/other/planet3d.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/planet3d.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: planet3d.h,v 1.2 2004/08/07 12:33:54 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -18,7 +18,8 @@
 #ifndef __PLANET_3D__
 #define __PLANET_3D__
 
-
+#include "melee.h"
+#include "melee/mship.h"
 #include "melee/mcbodies.h"
 
 Planet *create_planet( Vector2 position = map_size/2 );//remove me!

Modified: branches/multiplayer-branch/source/other/radar.cpp
===================================================================
--- branches/multiplayer-branch/source/other/radar.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/radar.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: radar.cpp,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -20,7 +20,7 @@
 #include "id.h"
 #include "scp.h"
 #include "frame.h"
-#include "ship.h"
+#include "melee/mship.h"
 
 #include "melee/mgame.h"
 #include "melee/mview.h"

Modified: branches/multiplayer-branch/source/other/radar.h
===================================================================
--- branches/multiplayer-branch/source/other/radar.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/radar.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: radar.h,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/other/shippart.cpp
===================================================================
--- branches/multiplayer-branch/source/other/shippart.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/shippart.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shippart.cpp,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -16,8 +16,10 @@
 */
 
 
-#include "ship.h"
+#include "melee.h"
+#include "melee/mship.h"
 #include "melee/mview.h"
+#include "melee/mtarget.h"
 
 #include <stdio.h>
 

Modified: branches/multiplayer-branch/source/other/shippart.h
===================================================================
--- branches/multiplayer-branch/source/other/shippart.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/shippart.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shippart.h,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -18,7 +18,7 @@
 #ifndef __SHIPPART__
 #define __SHIPPART__
 
-#include "ship.h"
+#include "melee/mship.h"
 
 
 //void removefromtargetlist(SpaceObject *o);

Modified: branches/multiplayer-branch/source/other/twconfig.cpp
===================================================================
--- branches/multiplayer-branch/source/other/twconfig.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/twconfig.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: twconfig.cpp,v 1.2 2004/08/08 17:36:04 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/other/twconfig.h
===================================================================
--- branches/multiplayer-branch/source/other/twconfig.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/twconfig.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: twconfig.h,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/other/vbodies.cpp
===================================================================
--- branches/multiplayer-branch/source/other/vbodies.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/vbodies.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: vbodies.cpp,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/other/vbodies.h
===================================================================
--- branches/multiplayer-branch/source/other/vbodies.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/vbodies.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: vbodies.h,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/other/vtarget.cpp
===================================================================
--- branches/multiplayer-branch/source/other/vtarget.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/vtarget.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: vtarget.cpp,v 1.2 2004/08/08 17:36:04 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -25,7 +25,7 @@
 #include "melee/mview.h"
 #include "melee/mship.h"
 #include "melee/mcbodies.h"
-#include "ship.h"
+#include "melee/mship.h"
 #include "frame.h"
 #include "vtarget.h"
 

Modified: branches/multiplayer-branch/source/other/vtarget.h
===================================================================
--- branches/multiplayer-branch/source/other/vtarget.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/other/vtarget.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: vtarget.h,v 1.2 2004/08/08 17:36:04 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Copied: branches/multiplayer-branch/source/sc1ships/sc1ships.h (from rev 81, branches/multiplayer-branch/source/sc1ships.h)
===================================================================
--- branches/multiplayer-branch/source/sc1ships.h	2004-10-16 21:23:27 UTC (rev 81)
+++ branches/multiplayer-branch/source/sc1ships/sc1ships.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -0,0 +1,363 @@
+/* $Id: sc1ships.h,v 1.4 2004/03/24 23:51:34 yurand Exp $ */ 
+
+#ifndef SC1_SHIP_HEADER
+#define SC1_SHIP_HEADER
+
+#include "melee/mship.h"
+	
+class AndrosynthGuardian : public Ship {
+public:
+	double       weaponRange;
+	double       weaponVelocity;
+	int          weaponDamage;
+	int          weaponArmour;
+
+	int bounce_status;
+
+	SpaceSprite *specialSprite;
+	SpaceSprite *shipSprite;
+	double       specialVelocity;
+	double       specialTurnRate;
+	int          specialDamage;
+	int          specialBounceDistance;
+	int          specialBounceTime;
+	int          specialActive;
+	double       shipTurnRate;
+	int          shipRechargeAmount;
+	double specialMass;
+	double normalMass;
+
+	public:
+	AndrosynthGuardian(Vector2 opos, double angle, ShipData *data, unsigned int code);
+	AndrosynthGuardian() { }
+	virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
+	
+	virtual void calculate();
+	virtual void calculate_thrust();
+	virtual void calculate_hotspots();
+
+	virtual void inflict_damage(SpaceObject *other);
+
+	virtual int activate_weapon();
+	virtual int activate_special();
+};
+
+
+
+class ArilouSkiff : public Ship {
+public:
+	int    weaponColor;
+	double weaponRange;
+	int    weaponFrames;
+	int    weaponDamage;
+
+	int just_teleported;
+
+	SpaceSprite *specialSprite;
+	double       specialFrames;
+
+	public:
+	ArilouSkiff(Vector2 opos, double angle, ShipData *data, unsigned int code);
+
+	protected:
+	virtual void inflict_damage(SpaceObject *other);
+	virtual int activate_weapon();
+	virtual int activate_special();
+	virtual void calculate();
+	virtual void calculate_gravity();
+	virtual int accelerate(SpaceLocation *source, double angle, double velocity, 
+			double max_speed);
+	virtual int accelerate_gravwhip(SpaceLocation *source, double angle, double velocity, 
+			double max_speed);
+	};
+
+
+class ChenjesuDOGI ;
+class ChenjesuBroodhome : public Ship
+{
+protected:
+	double		weaponVelocity, shardRange;
+	double		shardDamage, shardArmour;
+	double		shardRelativity;
+	double		weaponDamage, weaponArmour;
+	int			shardRotation;
+	int			weaponFired;
+	Shot		*weaponObject;
+
+	double		specialVelocity;
+	double		specialFuelSap;
+	double		specialArmour;
+	double		specialAccelRate;
+	double		specialMass;
+	double		specialAvoidanceAngle;
+	double		specialAvoidanceFactor;
+	int			specialNumDOGIs;
+
+public:
+	ChenjesuBroodhome(Vector2 opos, double angle, ShipData *data, unsigned int code);
+	virtual int activate_weapon();
+	virtual int activate_special();
+	virtual void calculate();
+};
+
+
+class EarthlingCruiser : public Ship {
+public:
+  double       weaponRange;
+  double       weaponVelocity;
+  int          weaponDamage;
+  int          weaponArmour;
+  double       weaponTurnRate;
+
+  int    specialColor;
+  double specialRange;
+  int    specialFrames;
+  int    specialDamage;
+
+  public:
+  EarthlingCruiser(Vector2 opos, double angle, ShipData *data, unsigned int code);
+
+  protected:
+  virtual int activate_weapon();
+  virtual int activate_special();
+};
+
+
+class IlwrathAvenger : public Ship {
+public:
+	double       weaponRange;
+	double       weaponVelocity;
+	int          weaponDamage;
+	int          weaponArmour;
+
+	int cloak;
+	int cloak_frame;
+
+	public:
+	static int cloak_color[3];
+	IlwrathAvenger(Vector2 opos, double angle, ShipData *data, unsigned int code);
+
+	virtual double isInvisible() const;
+	virtual int activate_weapon();
+	virtual void calculate_fire_special();
+	virtual void calculate_hotspots();
+	virtual void calculate();
+	virtual void animate(Frame *space);
+};
+
+
+class KzerZaDreadnought : public Ship {
+public:
+	double weaponRange;
+	double weaponVelocity;
+	int    weaponDamage;
+	int    weaponArmour;
+
+	int    specialFrames;
+	int    specialLaserDamage;
+	int    specialLaserColor;
+	double specialLaserRange;
+	int    specialLaserFrames;
+	int    specialLaserDrain;
+	double specialVelocity;
+	double specialRange;
+	int    specialArmour;
+
+	public:
+	KzerZaDreadnought(Vector2 opos, double angle, ShipData *data, unsigned int code);
+
+	int activate_weapon();
+	int activate_special();
+	};
+
+
+class MmrnmhrmXForm : public Ship {
+public:
+	struct {
+		public:
+		double       speed_max;
+		double       accel_rate;
+		double       turn_rate;
+		int          recharge_amount;
+		int          recharge_rate;
+		int          weapon_drain;
+		int          weapon_rate;
+		int          hotspot_rate;
+		SpaceSprite *sprite;
+	} form_data[2];
+
+	int form;
+
+	int        laserColor;
+	double     laserRange;
+	double     laserAngle;
+	int        laserDamage;
+	SpaceLine *laser1;
+	SpaceLine *laser2;
+	int        laserSpark;
+
+	double missileRange;
+	double missileVelocity;
+	int    missileDamage;
+	int    missileArmour;
+	double missileTurnRate;
+
+	public:
+	MmrnmhrmXForm(Vector2 opos, double shipAngle, 
+		ShipData *shipData, unsigned int code);
+
+	void calculate();
+	double handle_speed_loss(SpaceLocation *source, double normal);
+
+	int activate_weapon();
+	int activate_special();
+};
+
+
+class MyconPodship : public Ship {
+public:
+	double       weaponRange;
+	double       weaponVelocity;
+	int          weaponDamage;
+	double       weaponHome;
+	int          specialRepair;
+
+	public:
+	MyconPodship(Vector2 opos, double angle, ShipData *data, unsigned int code);
+
+	virtual int activate_weapon();
+	virtual int activate_special();
+};
+
+class ShofixtiScout : public Ship {
+	public:
+	double       weaponRange;
+	double       weaponVelocity;
+	int          weaponDamage;
+	int          weaponArmour;
+
+	double       specialRange;
+	double       specialScale;
+	int          specialFrames;
+	int          specialDamage;
+	int          flipSwitch;
+	int          glory;
+
+	ShofixtiScout(Vector2 opos, double angle, ShipData *data, unsigned int code);
+
+	virtual int activate_weapon();
+	virtual void calculate_fire_special();
+};
+
+
+class SpathiEluder : public Ship {
+public:
+	double       weaponRange;
+	double       weaponVelocity;
+	int          weaponDamage;
+	int          weaponArmour;
+
+	double       specialRange;
+	double       specialVelocity;
+	int          specialDamage;
+	int          specialArmour;
+	double       specialTurnRate;
+
+	public:
+	SpathiEluder(Vector2 opos, double angle, ShipData *data, unsigned int code);
+
+	virtual int activate_weapon();
+	virtual int activate_special();
+};
+
+
+class SyreenPenetrator : public Ship {
+public:
+	double       weaponRange;
+	double       weaponVelocity;
+	int          weaponDamage;
+	int          weaponArmour;
+
+	double       specialRange;
+	double       specialVelocity;
+	int          specialDamage;
+	int          specialFrames;
+
+	public:
+	SyreenPenetrator(Vector2 opos, double angle, ShipData *data, unsigned int code);
+
+	virtual int activate_weapon();
+	virtual int activate_special();
+};
+
+
+class UmgahDrone : public Ship {
+public:
+	int          weaponDamage;
+	int          weaponCone;
+	int          specialRate;
+
+	public:
+
+	int          firing;
+	int          damage_type;
+
+	UmgahDrone(Vector2 opos, double angle, ShipData *data, unsigned int code);
+
+	virtual int activate_weapon();
+	virtual int activate_special();
+	virtual void calculate_thrust();
+	virtual void calculate();
+};
+
+
+class VuxIntruder : public Ship {
+public:
+	int    weaponColor;
+	double weaponRange;
+	int    weaponDamage;
+
+	double specialRange;
+	double specialVelocity;
+	double specialSlowdown;
+	int    specialArmour;
+
+	public:
+	VuxIntruder(Vector2 opos, double angle, ShipData *data, unsigned int code);
+
+	virtual int activate_weapon();
+	virtual int activate_special();
+	virtual SpaceLocation *get_ship_phaser() ;
+	void relocate() ;
+  virtual void animate(Frame *space);
+};
+
+
+class YehatTerminator : public Ship {
+public:
+	double       weaponRange;
+	double       weaponVelocity;
+	int          weaponDamage;
+	int          weaponArmour;
+
+	int          specialFrames;
+	int          shieldFrames;
+
+	public:
+	YehatTerminator(Vector2 opos, double angle, ShipData *data, unsigned int code);
+	YehatTerminator() { }
+	virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
+
+	virtual double isProtected() const;
+
+	protected:
+	virtual int activate_weapon();
+	virtual int activate_special();
+	virtual void calculate();
+	virtual void animate(Frame *space);
+	virtual int handle_damage(SpaceLocation *source, double normal, double direct);
+};
+
+#endif

Modified: branches/multiplayer-branch/source/sc1ships/shpandgu.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpandgu.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc1ships/shpandgu.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id$ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -18,10 +18,14 @@
 #include "util/sound.h"
 #include "ship.h"
 
-#include "sc1ships.h"
+#include "sc1ships/sc1ships.h"
 #include "scp.h"
 
 class AndrosynthBubble : public AnimatedShot {
+  AndrosynthBubble () {}
+  virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
+  
   int courseFrames;
 
   public:
@@ -249,4 +253,5 @@
 
 
 REGISTER_SHIP(AndrosynthGuardian)
+REGISTER_PRESENCE_CLASS(AndrosynthBubble);
 

Modified: branches/multiplayer-branch/source/sc1ships/shparisk.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shparisk.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc1ships/shparisk.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id$ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -17,7 +17,7 @@
 
 #include "ship.h"
 
-#include "sc1ships.h"
+#include "sc1ships/sc1ships.h"
 
 ArilouSkiff::ArilouSkiff(Vector2 opos, double angle, ShipData *data, unsigned int code) 
 	:

Modified: branches/multiplayer-branch/source/sc1ships/shpchebr.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpchebr.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc1ships/shpchebr.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id$ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -17,7 +17,7 @@
 
 #include "ship.h"
 
-#include "sc1ships.h"
+#include "sc1ships/sc1ships.h"
 
 #define MAX_DOGIS 4
 

Modified: branches/multiplayer-branch/source/sc1ships/shpearcr.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpearcr.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc1ships/shpearcr.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id$ */
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -18,7 +18,7 @@
 #include "util/sound.h" 
 #include "ship.h"
 
-#include "sc1ships.h"
+#include "sc1ships/sc1ships.h"
 #include "scp.h"
 
 class EarthlingMissile : public HomingMissile {

Modified: branches/multiplayer-branch/source/sc1ships/shpilwav.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpilwav.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc1ships/shpilwav.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id$ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -17,7 +17,7 @@
 
 #include "ship.h"
 
-#include "sc1ships.h"
+#include "sc1ships/sc1ships.h"
 
 int IlwrathAvenger::cloak_color[3] = { 15, 11, 9 };
 

Modified: branches/multiplayer-branch/source/sc1ships/shpkzedr.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpkzedr.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc1ships/shpkzedr.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id$ */
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -18,7 +18,7 @@
 #include "ship.h"
 #include "melee/mview.h"
 
-#include "sc1ships.h"
+#include "sc1ships/sc1ships.h"
 
 class KzerZaMissile : public Missile {
 	public:

Modified: branches/multiplayer-branch/source/sc1ships/shpmmrxf.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpmmrxf.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc1ships/shpmmrxf.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id$ */
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -20,7 +20,7 @@
 #define T_FORM 0
 #define Y_FORM 1
 
-#include "sc1ships.h"
+#include "sc1ships/sc1ships.h"
 
 MmrnmhrmXForm::MmrnmhrmXForm(Vector2 opos, double shipAngle,
 	ShipData *shipData, unsigned int code) 

Modified: branches/multiplayer-branch/source/sc1ships/shpmycpo.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpmycpo.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc1ships/shpmycpo.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id$ */
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -17,7 +17,7 @@
  
 #include "ship.h"
 
-#include "sc1ships.h"
+#include "sc1ships/sc1ships.h"
 
 class MyconPlasma : public HomingMissile {
 	//double v;

Modified: branches/multiplayer-branch/source/sc1ships/shpshosc.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpshosc.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc1ships/shpshosc.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id$ */
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -17,7 +17,7 @@
  
 #include "ship.h"
 
-#include "sc1ships.h"
+#include "sc1ships/sc1ships.h"
 
 ShofixtiScout::ShofixtiScout(Vector2 opos, double angle, ShipData *data, unsigned int code) 
 	:

Modified: branches/multiplayer-branch/source/sc1ships/shpspael.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpspael.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc1ships/shpspael.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id$ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -17,7 +17,7 @@
 
 #include "ship.h"
 
-#include "sc1ships.h"
+#include "sc1ships/sc1ships.h"
 
 SpathiEluder::SpathiEluder(Vector2 opos, double angle, ShipData *data, unsigned int code) 
 	:

Modified: branches/multiplayer-branch/source/sc1ships/shpsyrpe.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpsyrpe.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc1ships/shpsyrpe.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id$*/ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -17,7 +17,7 @@
 
 #include "ship.h"
 
-#include "sc1ships.h"
+#include "sc1ships/sc1ships.h"
 
 class CrewPod : public SpaceObject {
 	int frame_count;

Modified: branches/multiplayer-branch/source/sc1ships/shpumgdr.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpumgdr.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc1ships/shpumgdr.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id$ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -17,7 +17,7 @@
 
 #include "ship.h"
 
-#include "sc1ships.h"
+#include "sc1ships/sc1ships.h"
 
 class UmgahCone : public SpaceObject {
   double dist;

Modified: branches/multiplayer-branch/source/sc1ships/shpvuxin.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpvuxin.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc1ships/shpvuxin.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id$ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -17,7 +17,7 @@
 
 #include "ship.h"
 
-#include "sc1ships.h"
+#include "sc1ships/sc1ships.h"
 
 class VuxLimpet : public AnimatedShot {
   double slowdown_factor;

Modified: branches/multiplayer-branch/source/sc1ships/shpyehte.cpp
===================================================================
--- branches/multiplayer-branch/source/sc1ships/shpyehte.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc1ships/shpyehte.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id$ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -16,11 +16,9 @@
 */
 
 #include "ship.h"
-
 #include "frame.h"
+#include "sc1ships/sc1ships.h"
 
-#include "sc1ships.h"
-
 YehatTerminator::YehatTerminator(Vector2 opos, double angle, ShipData *data, unsigned int code) 
 	:
 	Ship(opos, angle, data, code)
@@ -83,5 +81,5 @@
   return (shieldFrames > 0);
 }
 
-
+REGISTER_PRESENCE_CLASS(YehatTerminator)
 REGISTER_SHIP (YehatTerminator)

Deleted: branches/multiplayer-branch/source/sc1ships.h
===================================================================
--- branches/multiplayer-branch/source/sc1ships.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc1ships.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,349 +0,0 @@
-/* $Id: sc1ships.h,v 1.4 2004/03/24 23:51:34 yurand Exp $ */ 
-class AndrosynthGuardian : public Ship {
-public:
-	double       weaponRange;
-	double       weaponVelocity;
-	int          weaponDamage;
-	int          weaponArmour;
-
-	int bounce_status;
-
-	SpaceSprite *specialSprite;
-	SpaceSprite *shipSprite;
-	double       specialVelocity;
-	double       specialTurnRate;
-	int          specialDamage;
-	int          specialBounceDistance;
-	int          specialBounceTime;
-	int          specialActive;
-	double       shipTurnRate;
-	int          shipRechargeAmount;
-	double specialMass;
-	double normalMass;
-
-	public:
-	AndrosynthGuardian(Vector2 opos, double angle, ShipData *data, unsigned int code);
-
-	virtual void calculate();
-	virtual void calculate_thrust();
-	virtual void calculate_hotspots();
-
-	virtual void inflict_damage(SpaceObject *other);
-
-	virtual int activate_weapon();
-	virtual int activate_special();
-};
-
-
-
-class ArilouSkiff : public Ship {
-public:
-	int    weaponColor;
-	double weaponRange;
-	int    weaponFrames;
-	int    weaponDamage;
-
-	int just_teleported;
-
-	SpaceSprite *specialSprite;
-	double       specialFrames;
-
-	public:
-	ArilouSkiff(Vector2 opos, double angle, ShipData *data, unsigned int code);
-
-	protected:
-	virtual void inflict_damage(SpaceObject *other);
-	virtual int activate_weapon();
-	virtual int activate_special();
-	virtual void calculate();
-	virtual void calculate_gravity();
-	virtual int accelerate(SpaceLocation *source, double angle, double velocity, 
-			double max_speed);
-	virtual int accelerate_gravwhip(SpaceLocation *source, double angle, double velocity, 
-			double max_speed);
-	};
-
-
-class ChenjesuDOGI ;
-class ChenjesuBroodhome : public Ship
-{
-protected:
-	double		weaponVelocity, shardRange;
-	double		shardDamage, shardArmour;
-	double		shardRelativity;
-	double		weaponDamage, weaponArmour;
-	int			shardRotation;
-	int			weaponFired;
-	Shot		*weaponObject;
-
-	double		specialVelocity;
-	double		specialFuelSap;
-	double		specialArmour;
-	double		specialAccelRate;
-	double		specialMass;
-	double		specialAvoidanceAngle;
-	double		specialAvoidanceFactor;
-	int			specialNumDOGIs;
-
-public:
-	ChenjesuBroodhome(Vector2 opos, double angle, ShipData *data, unsigned int code);
-	virtual int activate_weapon();
-	virtual int activate_special();
-	virtual void calculate();
-};
-
-
-class EarthlingCruiser : public Ship {
-public:
-  double       weaponRange;
-  double       weaponVelocity;
-  int          weaponDamage;
-  int          weaponArmour;
-  double       weaponTurnRate;
-
-  int    specialColor;
-  double specialRange;
-  int    specialFrames;
-  int    specialDamage;
-
-  public:
-  EarthlingCruiser(Vector2 opos, double angle, ShipData *data, unsigned int code);
-
-  protected:
-  virtual int activate_weapon();
-  virtual int activate_special();
-};
-
-
-class IlwrathAvenger : public Ship {
-public:
-	double       weaponRange;
-	double       weaponVelocity;
-	int          weaponDamage;
-	int          weaponArmour;
-
-	int cloak;
-	int cloak_frame;
-
-	public:
-	static int cloak_color[3];
-	IlwrathAvenger(Vector2 opos, double angle, ShipData *data, unsigned int code);
-
-	virtual double isInvisible() const;
-	virtual int activate_weapon();
-	virtual void calculate_fire_special();
-	virtual void calculate_hotspots();
-	virtual void calculate();
-	virtual void animate(Frame *space);
-};
-
-
-class KzerZaDreadnought : public Ship {
-public:
-	double weaponRange;
-	double weaponVelocity;
-	int    weaponDamage;
-	int    weaponArmour;
-
-	int    specialFrames;
-	int    specialLaserDamage;
-	int    specialLaserColor;
-	double specialLaserRange;
-	int    specialLaserFrames;
-	int    specialLaserDrain;
-	double specialVelocity;
-	double specialRange;
-	int    specialArmour;
-
-	public:
-	KzerZaDreadnought(Vector2 opos, double angle, ShipData *data, unsigned int code);
-
-	int activate_weapon();
-	int activate_special();
-	};
-
-
-class MmrnmhrmXForm : public Ship {
-public:
-	struct {
-		public:
-		double       speed_max;
-		double       accel_rate;
-		double       turn_rate;
-		int          recharge_amount;
-		int          recharge_rate;
-		int          weapon_drain;
-		int          weapon_rate;
-		int          hotspot_rate;
-		SpaceSprite *sprite;
-	} form_data[2];
-
-	int form;
-
-	int        laserColor;
-	double     laserRange;
-	double     laserAngle;
-	int        laserDamage;
-	SpaceLine *laser1;
-	SpaceLine *laser2;
-	int        laserSpark;
-
-	double missileRange;
-	double missileVelocity;
-	int    missileDamage;
-	int    missileArmour;
-	double missileTurnRate;
-
-	public:
-	MmrnmhrmXForm(Vector2 opos, double shipAngle, 
-		ShipData *shipData, unsigned int code);
-
-	void calculate();
-	double handle_speed_loss(SpaceLocation *source, double normal);
-
-	int activate_weapon();
-	int activate_special();
-};
-
-
-class MyconPodship : public Ship {
-public:
-	double       weaponRange;
-	double       weaponVelocity;
-	int          weaponDamage;
-	double       weaponHome;
-	int          specialRepair;
-
-	public:
-	MyconPodship(Vector2 opos, double angle, ShipData *data, unsigned int code);
-
-	virtual int activate_weapon();
-	virtual int activate_special();
-};
-
-class ShofixtiScout : public Ship {
-	public:
-	double       weaponRange;
-	double       weaponVelocity;
-	int          weaponDamage;
-	int          weaponArmour;
-
-	double       specialRange;
-	double       specialScale;
-	int          specialFrames;
-	int          specialDamage;
-	int          flipSwitch;
-	int          glory;
-
-	ShofixtiScout(Vector2 opos, double angle, ShipData *data, unsigned int code);
-
-	virtual int activate_weapon();
-	virtual void calculate_fire_special();
-};
-
-
-class SpathiEluder : public Ship {
-public:
-	double       weaponRange;
-	double       weaponVelocity;
-	int          weaponDamage;
-	int          weaponArmour;
-
-	double       specialRange;
-	double       specialVelocity;
-	int          specialDamage;
-	int          specialArmour;
-	double       specialTurnRate;
-
-	public:
-	SpathiEluder(Vector2 opos, double angle, ShipData *data, unsigned int code);
-
-	virtual int activate_weapon();
-	virtual int activate_special();
-};
-
-
-class SyreenPenetrator : public Ship {
-public:
-	double       weaponRange;
-	double       weaponVelocity;
-	int          weaponDamage;
-	int          weaponArmour;
-
-	double       specialRange;
-	double       specialVelocity;
-	int          specialDamage;
-	int          specialFrames;
-
-	public:
-	SyreenPenetrator(Vector2 opos, double angle, ShipData *data, unsigned int code);
-
-	virtual int activate_weapon();
-	virtual int activate_special();
-};
-
-
-class UmgahDrone : public Ship {
-public:
-	int          weaponDamage;
-	int          weaponCone;
-	int          specialRate;
-
-	public:
-
-	int          firing;
-	int          damage_type;
-
-	UmgahDrone(Vector2 opos, double angle, ShipData *data, unsigned int code);
-
-	virtual int activate_weapon();
-	virtual int activate_special();
-	virtual void calculate_thrust();
-	virtual void calculate();
-};
-
-
-class VuxIntruder : public Ship {
-public:
-	int    weaponColor;
-	double weaponRange;
-	int    weaponDamage;
-
-	double specialRange;
-	double specialVelocity;
-	double specialSlowdown;
-	int    specialArmour;
-
-	public:
-	VuxIntruder(Vector2 opos, double angle, ShipData *data, unsigned int code);
-
-	virtual int activate_weapon();
-	virtual int activate_special();
-	virtual SpaceLocation *get_ship_phaser() ;
-	void relocate() ;
-  virtual void animate(Frame *space);
-};
-
-
-class YehatTerminator : public Ship {
-public:
-	double       weaponRange;
-	double       weaponVelocity;
-	int          weaponDamage;
-	int          weaponArmour;
-
-	int          specialFrames;
-	int          shieldFrames;
-
-	public:
-	YehatTerminator(Vector2 opos, double angle, ShipData *data, unsigned int code);
-	virtual double isProtected() const;
-
-	protected:
-	virtual int activate_weapon();
-	virtual int activate_special();
-	virtual void calculate();
-	virtual void animate(Frame *space);
-	virtual int handle_damage(SpaceLocation *source, double normal, double direct);
-};
-

Copied: branches/multiplayer-branch/source/sc2ships/sc2ships.h (from rev 81, branches/multiplayer-branch/source/sc2ships.h)
===================================================================
--- branches/multiplayer-branch/source/sc2ships.h	2004-10-16 21:23:27 UTC (rev 81)
+++ branches/multiplayer-branch/source/sc2ships/sc2ships.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -0,0 +1,297 @@
+/* $Id: sc2ships.h,v 1.7 2004/03/24 23:51:34 yurand Exp $ */ 
+
+#ifndef SC2_SHIP_HEADER
+#define SC1_SHIP_HEADER
+	
+#include "melee/mship.h"
+	
+class ChmmrAvatar : public Ship {
+public:
+  double weaponRange;
+  int    weaponDamage;
+
+  double       specialForce;
+  double       specialRange;
+
+  double extraRange;
+  int    extraDamage;
+  int    extraFrames;
+  int    extraRechargeRate;
+  int    extraColor;
+  int    extraArmour;
+
+  bool   uninterrupted_fire;
+
+  public:
+  ChmmrAvatar(Vector2 opos, double shipAngle, 
+    ShipData *shipData, unsigned int code);
+
+  virtual int activate_weapon();
+  virtual int activate_special();
+  virtual void calculate();
+  virtual void materialize();
+};
+
+class DruugeMauler : public Ship {
+public:
+  double       weaponRange;
+  double       weaponVelocity;
+  int          weaponDamage;
+  int          weaponArmour;
+  double       weaponDriftVelocity;
+
+  public:
+  DruugeMauler(Vector2 opos, double shipAngle,
+    ShipData *shipData, unsigned int code);
+
+  protected:
+  virtual int activate_weapon();
+  virtual void calculate_fire_special();
+};
+
+
+class KohrAhBlade;
+class KohrAhMarauder : public Ship
+{
+  public:
+  double       weaponRange;
+  double       weaponVelocity;
+  int          weaponDamage;
+  int          weaponArmour;
+  int          weaponFired;
+  KohrAhBlade **weaponObject;
+  bool         bladesPersist;
+
+  double       specialVelocity;
+  int          specialDamage;
+  int          specialArmour;
+  double       specialRange;
+
+
+  KohrAhMarauder(Vector2 opos, double shipAngle,
+    ShipData *shipData, unsigned int code);
+
+  virtual int activate_weapon();
+  virtual int activate_special();
+  virtual void calculate();
+
+  int numblades;
+  int maxblades;
+};
+
+
+class MelnormeTrader : public Ship {
+public:
+  double       weaponRange;
+	double       weaponRangeUp;
+  double       weaponVelocity;
+  int          weaponDamage;
+  int          weaponArmour;
+  SpaceObject *weaponObject;
+
+  double       specialRange;
+  double       specialVelocity;
+  int          specialFrames;
+  int          specialArmour;
+
+  public:
+  MelnormeTrader(Vector2 opos, double shipAngle,
+    ShipData *shipData, unsigned int code);
+
+  virtual void calculate();
+
+  virtual int activate_weapon();
+  virtual int activate_special();
+};
+
+
+
+
+#define MAX_MARINES 8
+
+class OrzNemesis;
+class OrzMissile;
+class OrzMarine;
+
+class OrzNemesis : public Ship {
+	public:
+
+	double absorption; //added for gob
+
+        double       turret_turn_step;
+
+	double       weaponRange;
+	double       weaponVelocity;
+	int          weaponDamage;
+	int          weaponArmour;
+
+	double       specialAccelRate;
+	double       specialSpeedMax;
+	int          specialHotspotRate;
+	int          specialArmour;
+	OrzMarine   *marine[MAX_MARINES];
+
+	double       turretAngle;
+
+	int          recoil;
+	int          recoil_rate;
+	int          recoil_range;
+	double       turret_turn_rate;
+
+	OrzNemesis(Vector2 opos, double shipAngle,
+    ShipData *shipData, unsigned int code);
+
+	virtual void calculate();
+	virtual void animate(Frame *space);
+
+	virtual void calculate_turn_left();
+	virtual void calculate_turn_right();
+
+	virtual int activate_weapon();
+	virtual int activate_special();
+	};
+
+
+
+class PkunkFury : public Ship {
+public:
+  int reborn;
+
+  double       weaponRange;
+  double       weaponVelocity;
+  int          weaponDamage;
+  int          weaponArmour;
+
+  public:
+  PkunkFury(Vector2 opos, double shipAngle,
+    ShipData *shipData, unsigned int code);
+
+  virtual int handle_damage(SpaceLocation *source, double normal, double direct);
+  virtual int activate_weapon();
+  virtual void calculate_fire_special();
+};
+
+
+
+class	SlylandroLaserNew;
+
+class SlylandroProbe : public Ship {
+public:
+	int frame;
+	int thrustActive;
+	int thrustForward;
+	int segments;
+	int segment_length, segment_dispersion;
+	int rnd_angle, aiming, dispersion;
+
+	SlylandroLaserNew	*SlyLaser;
+
+	double realturnstep;
+
+	int sprite_index2;
+
+	int last_turn_left, last_turn_right;
+
+public:
+	SlylandroProbe(Vector2 opos, double shipAngle,
+		ShipData *shipData, unsigned int code);
+
+	RGB crewPanelColor(int k = 0);
+
+	virtual void calculate_thrust();
+	virtual void calculate_turn_left();
+	virtual void calculate_turn_right();
+	virtual void calculate_fire_special();
+	virtual void calculate_hotspots();
+	virtual int activate_weapon();
+	virtual void calculate();
+	virtual int accelerate_gravwhip(SpaceLocation *source, double angle, double velocity, double max_speed);
+
+};
+
+
+
+class SupoxBlade : public Ship {
+  public:
+  double       weaponRange;
+  double       weaponVelocity;
+  int          weaponDamage;
+  int          weaponArmour;
+
+  SupoxBlade(Vector2 opos, double shipAngle,
+    ShipData *shipData, unsigned int code);
+
+  virtual void calculate_thrust();
+  virtual void calculate_turn_left();
+  virtual void calculate_turn_right();
+  virtual void calculate_hotspots();
+
+  virtual int activate_weapon();
+  virtual void calculate_fire_special();
+};
+
+
+
+class ThraddashTorch : public Ship {
+public:
+  double       weaponRange;
+  double       weaponVelocity;
+  int          weaponDamage;
+  int          weaponArmour;
+
+  double       specialThrust;
+  int          specialDamage;
+  int          specialArmour;
+
+  public:
+  ThraddashTorch(Vector2 opos, double shipAngle,
+    ShipData *shipData, unsigned int code);
+
+  virtual int activate_weapon();
+  virtual int activate_special();
+  virtual void calculate_thrust();
+};
+
+
+
+class UtwigJugger : public Ship {
+  public:
+
+	int fortitude; //added for gob
+
+  double       weaponRange;
+  double       weaponVelocity;
+  int          weaponDamage;
+  int          weaponArmour;
+
+  UtwigJugger(Vector2 opos, double shipAngle,
+    ShipData *shipData, unsigned int code);
+  virtual void calculate();
+  virtual double isProtected() const;
+
+  protected:
+  virtual void calculate_fire_weapon();
+  virtual void animate(Frame *space);
+  virtual int handle_damage(SpaceLocation *source, double normal, double direct);
+};
+
+
+
+class ZoqFotPikStinger : public Ship {
+  public:
+  double       weaponRange;
+  double       weaponVelocity;
+  int          weaponDamage;
+  int          weaponArmour;
+
+  int          specialDamage;
+
+
+  ZoqFotPikStinger(Vector2 opos, double shipAngle,
+    ShipData *shipData, unsigned int code);
+
+  virtual int activate_weapon();
+  virtual int activate_special();
+};
+
+#endif

Modified: branches/multiplayer-branch/source/sc2ships/shpchmav.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shpchmav.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc2ships/shpchmav.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpchmav.cpp,v 1.14 2004/03/24 23:51:44 yurand Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -18,7 +18,7 @@
 #include "ship.h"
 
 #include "util/aastr.h"
-#include "sc2ships.h"
+#include "sc2ships/sc2ships.h"
 
 
 class ChmmrLaser : public Laser {

Modified: branches/multiplayer-branch/source/sc2ships/shpdruma.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shpdruma.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc2ships/shpdruma.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpdruma.cpp,v 1.9 2004/03/24 23:51:44 yurand Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -18,7 +18,7 @@
 #include "ship.h"
 
 
-#include "sc2ships.h"
+#include "sc2ships/sc2ships.h"
 
 class DruugeMissile : public Missile {
   public:

Modified: branches/multiplayer-branch/source/sc2ships/shpkohma.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shpkohma.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc2ships/shpkohma.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpkohma.cpp,v 1.8 2004/03/24 23:51:44 yurand Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -18,7 +18,7 @@
 #include "ship.h"
 
 
-#include "sc2ships.h"
+#include "sc2ships/sc2ships.h"
 
 class KohrAhBlade : public AnimatedShot {
 	bool persist;

Modified: branches/multiplayer-branch/source/sc2ships/shpmeltr.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shpmeltr.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc2ships/shpmeltr.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpmeltr.cpp,v 1.11 2004/03/24 23:51:44 yurand Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -18,7 +18,7 @@
 #include "ship.h"
 
 
-#include "sc2ships.h"
+#include "sc2ships/sc2ships.h"
 
 class MelnormeShot : public Shot {
   double v;

Modified: branches/multiplayer-branch/source/sc2ships/shporzne.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shporzne.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc2ships/shporzne.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shporzne.cpp,v 1.16 2004/03/24 23:51:44 yurand Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -20,7 +20,7 @@
 #include "melee/mview.h"
 #include "melee/mcbodies.h"
 
-#include "sc2ships.h"
+#include "sc2ships/sc2ships.h"
 
 class OrzMissile : public Missile {
   public:

Modified: branches/multiplayer-branch/source/sc2ships/shppkufu.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shppkufu.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc2ships/shppkufu.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shppkufu.cpp,v 1.13 2004/03/24 23:51:44 yurand Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -18,7 +18,7 @@
 #include "ship.h"
 #include "melee/mcbodies.h"
 
-#include "sc2ships.h"
+#include "sc2ships/sc2ships.h"
 
 #include "melee/mshppan.h"
 #include "melee/mitems.h"

Modified: branches/multiplayer-branch/source/sc2ships/shpslypr.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shpslypr.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc2ships/shpslypr.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpslypr.cpp,v 1.15 2004/03/24 23:51:44 yurand Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -18,7 +18,7 @@
 
 #include "ship.h"
 
-#include "sc2ships.h"
+#include "sc2ships/sc2ships.h"
 #include "frame.h"
 
 static const int Ndirections = 16;

Modified: branches/multiplayer-branch/source/sc2ships/shpsupbl.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shpsupbl.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc2ships/shpsupbl.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpsupbl.cpp,v 1.7 2004/03/24 23:51:44 yurand Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -17,7 +17,7 @@
 
 #include "ship.h"
 
-#include "sc2ships.h"
+#include "sc2ships/sc2ships.h"
 
 SupoxBlade::SupoxBlade(Vector2 opos, double shipAngle,
 	ShipData *shipData, unsigned int code)

Modified: branches/multiplayer-branch/source/sc2ships/shpthrto.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shpthrto.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc2ships/shpthrto.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpthrto.cpp,v 1.13 2004/03/24 23:51:44 yurand Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -17,7 +17,7 @@
 
 #include "ship.h"
 
-#include "sc2ships.h"
+#include "sc2ships/sc2ships.h"
 
 class ThraddashFlame : public Animation {
   int armour;

Modified: branches/multiplayer-branch/source/sc2ships/shputwju.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shputwju.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc2ships/shputwju.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shputwju.cpp,v 1.7 2004/03/24 23:51:44 yurand Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -19,7 +19,7 @@
 
 #include "frame.h"
 
-#include "sc2ships.h"
+#include "sc2ships/sc2ships.h"
 
 UtwigJugger::UtwigJugger(Vector2 opos, double shipAngle,
 	ShipData *shipData, unsigned int code)

Modified: branches/multiplayer-branch/source/sc2ships/shpzfpst.cpp
===================================================================
--- branches/multiplayer-branch/source/sc2ships/shpzfpst.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc2ships/shpzfpst.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpzfpst.cpp,v 1.11 2004/03/24 23:51:44 yurand Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -19,7 +19,7 @@
 
 #include <math.h>
 
-#include "sc2ships.h"
+#include "sc2ships/sc2ships.h"
 
 class ZoqFotPikShot : public Shot {
   int frame_count;

Deleted: branches/multiplayer-branch/source/sc2ships.h
===================================================================
--- branches/multiplayer-branch/source/sc2ships.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/sc2ships.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,290 +0,0 @@
-/* $Id: sc2ships.h,v 1.7 2004/03/24 23:51:34 yurand Exp $ */ 
-class ChmmrAvatar : public Ship {
-public:
-  double weaponRange;
-  int    weaponDamage;
-
-  double       specialForce;
-  double       specialRange;
-
-  double extraRange;
-  int    extraDamage;
-  int    extraFrames;
-  int    extraRechargeRate;
-  int    extraColor;
-  int    extraArmour;
-
-  bool   uninterrupted_fire;
-
-  public:
-  ChmmrAvatar(Vector2 opos, double shipAngle, 
-    ShipData *shipData, unsigned int code);
-
-  virtual int activate_weapon();
-  virtual int activate_special();
-  virtual void calculate();
-  virtual void materialize();
-};
-
-class DruugeMauler : public Ship {
-public:
-  double       weaponRange;
-  double       weaponVelocity;
-  int          weaponDamage;
-  int          weaponArmour;
-  double       weaponDriftVelocity;
-
-  public:
-  DruugeMauler(Vector2 opos, double shipAngle,
-    ShipData *shipData, unsigned int code);
-
-  protected:
-  virtual int activate_weapon();
-  virtual void calculate_fire_special();
-};
-
-
-class KohrAhBlade;
-class KohrAhMarauder : public Ship
-{
-  public:
-  double       weaponRange;
-  double       weaponVelocity;
-  int          weaponDamage;
-  int          weaponArmour;
-  int          weaponFired;
-  KohrAhBlade **weaponObject;
-  bool         bladesPersist;
-
-  double       specialVelocity;
-  int          specialDamage;
-  int          specialArmour;
-  double       specialRange;
-
-
-  KohrAhMarauder(Vector2 opos, double shipAngle,
-    ShipData *shipData, unsigned int code);
-
-  virtual int activate_weapon();
-  virtual int activate_special();
-  virtual void calculate();
-
-  int numblades;
-  int maxblades;
-};
-
-
-class MelnormeTrader : public Ship {
-public:
-  double       weaponRange;
-	double       weaponRangeUp;
-  double       weaponVelocity;
-  int          weaponDamage;
-  int          weaponArmour;
-  SpaceObject *weaponObject;
-
-  double       specialRange;
-  double       specialVelocity;
-  int          specialFrames;
-  int          specialArmour;
-
-  public:
-  MelnormeTrader(Vector2 opos, double shipAngle,
-    ShipData *shipData, unsigned int code);
-
-  virtual void calculate();
-
-  virtual int activate_weapon();
-  virtual int activate_special();
-};
-
-
-
-
-#define MAX_MARINES 8
-
-class OrzNemesis;
-class OrzMissile;
-class OrzMarine;
-
-class OrzNemesis : public Ship {
-	public:
-
-	double absorption; //added for gob
-
-        double       turret_turn_step;
-
-	double       weaponRange;
-	double       weaponVelocity;
-	int          weaponDamage;
-	int          weaponArmour;
-
-	double       specialAccelRate;
-	double       specialSpeedMax;
-	int          specialHotspotRate;
-	int          specialArmour;
-	OrzMarine   *marine[MAX_MARINES];
-
-	double       turretAngle;
-
-	int          recoil;
-	int          recoil_rate;
-	int          recoil_range;
-	double       turret_turn_rate;
-
-	OrzNemesis(Vector2 opos, double shipAngle,
-    ShipData *shipData, unsigned int code);
-
-	virtual void calculate();
-	virtual void animate(Frame *space);
-
-	virtual void calculate_turn_left();
-	virtual void calculate_turn_right();
-
-	virtual int activate_weapon();
-	virtual int activate_special();
-	};
-
-
-
-class PkunkFury : public Ship {
-public:
-  int reborn;
-
-  double       weaponRange;
-  double       weaponVelocity;
-  int          weaponDamage;
-  int          weaponArmour;
-
-  public:
-  PkunkFury(Vector2 opos, double shipAngle,
-    ShipData *shipData, unsigned int code);
-
-  virtual int handle_damage(SpaceLocation *source, double normal, double direct);
-  virtual int activate_weapon();
-  virtual void calculate_fire_special();
-};
-
-
-
-class	SlylandroLaserNew;
-
-class SlylandroProbe : public Ship {
-public:
-	int frame;
-	int thrustActive;
-	int thrustForward;
-	int segments;
-	int segment_length, segment_dispersion;
-	int rnd_angle, aiming, dispersion;
-
-	SlylandroLaserNew	*SlyLaser;
-
-	double realturnstep;
-
-	int sprite_index2;
-
-	int last_turn_left, last_turn_right;
-
-public:
-	SlylandroProbe(Vector2 opos, double shipAngle,
-		ShipData *shipData, unsigned int code);
-
-	RGB crewPanelColor(int k = 0);
-
-	virtual void calculate_thrust();
-	virtual void calculate_turn_left();
-	virtual void calculate_turn_right();
-	virtual void calculate_fire_special();
-	virtual void calculate_hotspots();
-	virtual int activate_weapon();
-	virtual void calculate();
-	virtual int accelerate_gravwhip(SpaceLocation *source, double angle, double velocity, double max_speed);
-
-};
-
-
-
-class SupoxBlade : public Ship {
-  public:
-  double       weaponRange;
-  double       weaponVelocity;
-  int          weaponDamage;
-  int          weaponArmour;
-
-  SupoxBlade(Vector2 opos, double shipAngle,
-    ShipData *shipData, unsigned int code);
-
-  virtual void calculate_thrust();
-  virtual void calculate_turn_left();
-  virtual void calculate_turn_right();
-  virtual void calculate_hotspots();
-
-  virtual int activate_weapon();
-  virtual void calculate_fire_special();
-};
-
-
-
-class ThraddashTorch : public Ship {
-public:
-  double       weaponRange;
-  double       weaponVelocity;
-  int          weaponDamage;
-  int          weaponArmour;
-
-  double       specialThrust;
-  int          specialDamage;
-  int          specialArmour;
-
-  public:
-  ThraddashTorch(Vector2 opos, double shipAngle,
-    ShipData *shipData, unsigned int code);
-
-  virtual int activate_weapon();
-  virtual int activate_special();
-  virtual void calculate_thrust();
-};
-
-
-
-class UtwigJugger : public Ship {
-  public:
-
-	int fortitude; //added for gob
-
-  double       weaponRange;
-  double       weaponVelocity;
-  int          weaponDamage;
-  int          weaponArmour;
-
-  UtwigJugger(Vector2 opos, double shipAngle,
-    ShipData *shipData, unsigned int code);
-  virtual void calculate();
-  virtual double isProtected() const;
-
-  protected:
-  virtual void calculate_fire_weapon();
-  virtual void animate(Frame *space);
-  virtual int handle_damage(SpaceLocation *source, double normal, double direct);
-};
-
-
-
-class ZoqFotPikStinger : public Ship {
-  public:
-  double       weaponRange;
-  double       weaponVelocity;
-  int          weaponDamage;
-  int          weaponArmour;
-
-  int          specialDamage;
-
-
-  ZoqFotPikStinger(Vector2 opos, double shipAngle,
-    ShipData *shipData, unsigned int code);
-
-  virtual int activate_weapon();
-  virtual int activate_special();
-};
-

Modified: branches/multiplayer-branch/source/scp.cpp
===================================================================
--- branches/multiplayer-branch/source/scp.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/scp.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -520,7 +520,7 @@
 int main(int argc, char *argv[]) {
 	int r;
 	r = tw_main(argc, argv);
-	return r;
+	return 0;
 }
 END_OF_MAIN();
 #endif

Modified: branches/multiplayer-branch/source/scp.h
===================================================================
--- branches/multiplayer-branch/source/scp.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/scp.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: scp.h,v 1.4 2004/08/08 17:36:03 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ship.h
===================================================================
--- branches/multiplayer-branch/source/ship.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ship.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: ship.h,v 1.1.1.1 2004/08/01 10:21:18 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpaktgu.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpaktgu.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpaktgu.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpaktgu.cpp,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpalabc.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpalabc.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpalabc.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpalabc.cpp,v 1.1.1.1 2004/08/01 10:21:25 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpbahbu.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpbahbu.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpbahbu.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpbahbu.cpp,v 1.1.1.1 2004/08/01 10:21:26 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpbipka.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpbipka.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpbipka.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpbipka.cpp,v 1.1.1.1 2004/08/01 10:21:26 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpbogce.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpbogce.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpbogce.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpbogce.cpp,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpchoex.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpchoex.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpchoex.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpchoex.cpp,v 1.1.1.1 2004/08/01 10:21:25 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpconca.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpconca.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpconca.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpconca.cpp,v 1.1.1.1 2004/08/01 10:21:25 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpconho.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpconho.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpconho.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpconho.cpp,v 1.1.1.1 2004/08/01 10:21:25 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpdragr.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpdragr.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpdragr.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpdragr.cpp,v 1.1.1.1 2004/08/01 10:21:25 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpearc3.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpearc3.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpearc3.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpearc3.cpp,v 1.1.1.1 2004/08/01 10:21:26 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpforsh.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpforsh.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpforsh.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpforsh.cpp,v 1.1.1.1 2004/08/01 10:21:25 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpgarty.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpgarty.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpgarty.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpgarty.cpp,v 1.1.1.1 2004/08/01 10:21:25 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpilwsp.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpilwsp.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpilwsp.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpilwsp.cpp,v 1.1.1.1 2004/08/01 10:21:25 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpilwsp.h
===================================================================
--- branches/multiplayer-branch/source/ships/shpilwsp.h	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpilwsp.h	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpilwsp.h,v 1.1.1.1 2004/08/01 10:21:25 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpkahbo.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpkahbo.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpkahbo.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpkahbo.cpp,v 1.1.1.1 2004/08/01 10:21:26 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shprogsq.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shprogsq.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shprogsq.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shprogsq.cpp,v 1.1.1.1 2004/08/01 10:21:25 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpstaba.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpstaba.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpstaba.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpstaba.cpp,v 1.1.1.1 2004/08/01 10:21:26 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shptauar.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shptauar.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shptauar.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shptauar.cpp,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shptauda.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shptauda.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shptauda.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shptauda.cpp,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shptaume.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shptaume.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shptaume.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shptaume.cpp,v 1.1.1.1 2004/08/01 10:21:25 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shptausl.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shptausl.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shptausl.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shptausl.cpp,v 1.1.1.1 2004/08/01 10:21:25 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shptaust.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shptaust.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shptaust.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shptaust.cpp,v 1.1.1.1 2004/08/01 10:21:25 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shptauto.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shptauto.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shptauto.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shptauto.cpp,v 1.1.1.1 2004/08/01 10:21:25 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpwolmi.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpwolmi.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpwolmi.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpwolmi.cpp,v 1.1.1.1 2004/08/01 10:21:26 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpyusra.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpyusra.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpyusra.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpyusra.cpp,v 1.1.1.1 2004/08/01 10:21:25 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/source/ships/shpzeksh.cpp
===================================================================
--- branches/multiplayer-branch/source/ships/shpzeksh.cpp	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/source/ships/shpzeksh.cpp	2004-10-20 08:05:48 UTC (rev 84)
@@ -1,7 +1,7 @@
 /* $Id: shpzeksh.cpp,v 1.1.1.1 2004/08/01 10:21:25 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: branches/multiplayer-branch/sources.lst
===================================================================
--- branches/multiplayer-branch/sources.lst	2004-10-19 21:59:09 UTC (rev 83)
+++ branches/multiplayer-branch/sources.lst	2004-10-20 08:05:48 UTC (rev 84)
@@ -7,6 +7,7 @@
 source/games/gflmelee.cpp
 source/games/ggob.cpp
 source/games/gmelee.cpp
+source/games/gup.cpp
 source/games/MultiplayerGame.cpp
 source/gui.cpp
 source/input.cpp
@@ -71,6 +72,7 @@
 source/libraries/raknet/NetworkTypes.cpp
 source/libraries/raknet/PacketPool.cpp
 source/libraries/raknet/RakClient.cpp
+source/libraries/raknet/RakNetStatistics.cpp
 source/libraries/raknet/RakNetworkFactory.cpp
 source/libraries/raknet/RakPeer.cpp
 source/libraries/raknet/RakServer.cpp
@@ -101,10 +103,10 @@
 source/melee/msprite.cpp
 source/melee/mtarget.cpp
 source/melee/mview.cpp
+source/melee/PresenceRegistry.cpp
 source/other/configrw.cpp
 source/other/dialogs.cpp
 source/other/fontmorph.cpp
-source/other/gup.cpp
 source/other/nullphas.cpp
 source/other/objanim.cpp
 source/other/orbit.cpp
@@ -114,67 +116,10 @@
 source/other/twconfig.cpp
 source/other/vbodies.cpp
 source/other/vtarget.cpp
-source/sc1ships/shpandgu.cpp
-source/sc1ships/shparisk.cpp
-source/sc1ships/shpchebr.cpp
-source/sc1ships/shpearcr.cpp
-source/sc1ships/shpilwav.cpp
-source/sc1ships/shpkzedr.cpp
-source/sc1ships/shpmmrxf.cpp
-source/sc1ships/shpmycpo.cpp
-source/sc1ships/shpshosc.cpp
-source/sc1ships/shpspael.cpp
-source/sc1ships/shpsyrpe.cpp
-source/sc1ships/shpumgdr.cpp
-source/sc1ships/shpvuxin.cpp
 source/sc1ships/shpyehte.cpp
-source/sc2ships/shpchmav.cpp
-source/sc2ships/shpdruma.cpp
-source/sc2ships/shpkohma.cpp
-source/sc2ships/shpmeltr.cpp
-source/sc2ships/shporzne.cpp
-source/sc2ships/shppkufu.cpp
-source/sc2ships/shpslypr.cpp
-source/sc2ships/shpsupbl.cpp
-source/sc2ships/shpthrto.cpp
-source/sc2ships/shputwju.cpp
-source/sc2ships/shpzfpst.cpp
 source/scp.cpp
-source/ships/shpaktgu.cpp
-source/ships/shpalabc.cpp
-source/ships/shpbahbu.cpp
-source/ships/shpbipka.cpp
-source/ships/shpbogce.cpp
-source/ships/shpchoex.cpp
-source/ships/shpconca.cpp
-source/ships/shpconho.cpp
-source/ships/shpdragr.cpp
-source/ships/shpearc3.cpp
-source/ships/shpforsh.cpp
-source/ships/shpgarty.cpp
-source/ships/shpilwsp.cpp
-source/ships/shpkahbo.cpp
-source/ships/shprogsq.cpp
-source/ships/shpstaba.cpp
-source/ships/shptauar.cpp
-source/ships/shptauda.cpp
-source/ships/shptaume.cpp
-source/ships/shptausl.cpp
-source/ships/shptaust.cpp
-source/ships/shptauto.cpp
-source/ships/shpwolmi.cpp
-source/ships/shpyusra.cpp
-source/ships/shpzeksh.cpp
 source/tests/testdatapath.cpp
 source/tests/testmain.cpp
-source/twgui/twbutton.cpp
-source/twgui/twbuttontypes.cpp
-source/twgui/twgui.cpp
-source/twgui/twhelpers.cpp
-source/twgui/twmenuexamples.cpp
-source/twgui/twpopup.cpp
-source/twgui/twwindow.cpp
-source/twgui/utils.cpp
 source/util/aarot.c
 source/util/aastr.c
 source/util/aautil.c



From yurand at sheep.berlios.de  Thu Oct 21 22:48:47 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Thu, 21 Oct 2004 22:48:47 +0200
Subject: [Tw-light-svn] r85 - trunk/web
Message-ID: <200410212048.i9LKmld2028863@sheep.berlios.de>

Author: yurand
Date: 2004-10-21 22:48:46 +0200 (Thu, 21 Oct 2004)
New Revision: 85

Added:
   trunk/web/downloads.php
   trunk/web/index.php
   trunk/web/info.php
   trunk/web/links.php
   trunk/web/team.php
Removed:
   trunk/web/downloads.html
   trunk/web/index.html
   trunk/web/info.html
   trunk/web/links.html
   trunk/web/team.html
Modified:
   trunk/web/background.jpg
   trunk/web/style.css
   trunk/web/update.sh
Log:
Add site


Modified: trunk/web/background.jpg
===================================================================
(Binary files differ)

Deleted: trunk/web/downloads.html
===================================================================
--- trunk/web/downloads.html	2004-10-20 08:05:48 UTC (rev 84)
+++ trunk/web/downloads.html	2004-10-21 20:48:46 UTC (rev 85)
@@ -1,56 +0,0 @@
-<html>
-
-<head>
-<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
-<meta http-equiv="content-type" content="text/html; charset=windows-1251">
-<meta name="description" content="Homepage of TW-Light.">
-<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
-<title>TW-Light</title>
-</head>
-
-<body>
-
-<div class="navbar">
-  <table class="navlinks" summary="navigation bar">
-    <tr>
-      <td>
-        <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
-      </td>
-      <td>
-      <a href="./index.html">News</a> | <a href="./info.html">Info</a> | <a href="./team.html">Team</a> | <a  id="curpagelink" href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://tw-light.berlios.de/mantis/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a href="./links.html">Links</a>
-      </td>
-    </tr>
-  </table>
-</div>
-
-<div class="main">
-  <h2>Downloads</h2>
-  
-<p class="indented">
-The latest version is <b>0.3r69</b>. You can download it <a href="http://developer.berlios.de/project/showfiles.php?group_id=2082&release_id=3480">here.</a>
-
-<p class="indented">
-To successfully compile the sources and play the game on Linux/Unix you first need 
-<a href="http://www.allegro.cc/files/index.html">Allegro</a>, SDL 1.2.5 (or newer),
-SDL_mixer with ogg support installed. See makefile after unpacking for more instructions.
-	<!--	
-	 and <a href="http://www.lua.org">Lua</a>
-	View <a href="">ChangeLog</a> to see the list of the latest changes.<br>
-	-->
-</p>
-<p class="indented">
-If you want to contribute TW-Light by writting good dialogs, download and use 
-our dialog editor. The latest version is <b>73</b>. You can download Windows binaries 
-<a href="./dialog-editor-win32-73.zip">here</a>. This 
-<a href="./tutorial.zip">tutorial</a> contains few instruction about how to use it.
-
-</p>
-</div>
-
-<p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
-<table border="0" cellpadding="0" cellspacing="0" width="100%">
-<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
-</td></tr></table>	
-
-</body>
-</html>
\ No newline at end of file

Added: trunk/web/downloads.php
===================================================================
--- trunk/web/downloads.php	2004-10-20 08:05:48 UTC (rev 84)
+++ trunk/web/downloads.php	2004-10-21 20:48:46 UTC (rev 85)
@@ -0,0 +1,53 @@
+<html>
+
+<head>
+<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
+<meta http-equiv="content-type" content="text/html; charset=windows-1251">
+<meta name="description" content="Homepage of TW-Light.">
+<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
+<title>TW-Light</title>
+</head>
+
+<body>
+
+<table border="2" class="main" width="100%">
+<tr valign="top">
+<td width="200">
+<?php include("./menu.inc") ?>
+</td>
+<td width="*">
+<p/>
+<h2>Downloads</h2>
+  
+<p class="indented">
+The latest version is <b>0.3r69</b>. You can download it <a href="http://developer.berlios.de/project/showfiles.php?group_id=2082&release_id=3480">here.</a>
+
+<p class="indented">
+To successfully compile the sources and play the game on Linux/Unix you first need 
+<a href="http://www.allegro.cc/files/index.html">Allegro</a>, SDL 1.2.5 (or newer),
+SDL_mixer with ogg support installed. See makefile after unpacking for more instructions.
+	<!--	
+	 and <a href="http://www.lua.org">Lua</a>
+	View <a href="">ChangeLog</a> to see the list of the latest changes.<br>
+	-->
+</p>
+<p class="indented">
+If you want to contribute TW-Light by writting good dialogs, download and use 
+our dialog editor. The latest version is <b>73</b>. You can download Windows binaries 
+<a href="./dialog-editor-win32-73.zip">here</a>. This 
+<a href="./tutorial.zip">tutorial</a> contains few instruction about how to use it.
+
+</p>
+
+</td>
+</tr>
+</table>
+
+
+<p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
+<table border="0" cellpadding="0" cellspacing="0" width="100%">
+<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
+</td></tr></table>	
+
+</body>
+</html>
\ No newline at end of file

Deleted: trunk/web/index.html
===================================================================
--- trunk/web/index.html	2004-10-20 08:05:48 UTC (rev 84)
+++ trunk/web/index.html	2004-10-21 20:48:46 UTC (rev 85)
@@ -1,84 +0,0 @@
-<html>
-
-<head>
-<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
-<meta http-equiv="content-type" content="text/html; charset=windows-1251">
-<meta name="description" content="Homepage of TW-Light.">
-<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
-<title>TW-Light</title>
-</head>
-
-<body>
-
-<div class="navbar">
-  <table class="navlinks" summary="navigation bar">
-    <tr>
-      <td>
-        <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
-      </td>
-      <td>
-      <a id="curpagelink" href="./index.html">News</a> | <a href="./info.html">Info</a> | <a href="./team.html">Team</a> | <a  href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://tw-light.berlios.de/mantis/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a href="./links.html">Links</a>
-      </td>
-    </tr>
-  </table>
-</div>
-
-<div class="main">
-  <h3 class="important">TW-Light</h3>
-<p class="indented">
-  TW-Light is an open source clone/sequel to the epic cross-genre game
- Star Control II. Currently it includes only a combat portion, although
- epic adventure part that is called TW:Legacies is actively developed
- now. TW-Light is derivative work from <a href="http://timewarp.sourceforge.net/">Star Control: Timewarp</a>
-</p>
-
-<p class="indented">
-TW-Light is written in portable C++ and is known to compile and run on <b>Linux</b>  
-and <b>Windows</b> (with the exception that it is still not 64-bit clean as nobody of 
-us has access to such hardware)
-</p>
-
-<p class="indented">
-Subscribe to our <a href="https://developer.berlios.de/mail/?group_id=2082">mailing lists</a> if you want to always know the latest news about TW-Light.
-</p>
-
-<br />
-
-<h2>News</h2>
-
-<!--
-<h3>Announcing the Ultronomicon<span class="date">(Friday, September 3 2004)</span></h3>
-<p class="indented">
-    The <a href="http://uqm.stack.nl/wiki/">Ultronomicon</a>, our new wiki
-    database, is now officially open.
-    We've chosen the <a href="http://creativecommons.org/licenses/by/2.0/">
-    Creative Commons Attribution 2.0</a> license for all its text.
-</p>
-
-<p class="indented">
-    The goal is to make it a complete reference work for everything relating
-    to The Ur-Quan Masters, including the Star Control universe, gameplay,
-    technical tips, and developer info.
-</p>
-
-<p class="indented">
-    I encourage everyone to write a bit about their favourite Ur-Quan Masters
-    subject, so that we will have something to show soon.
-</p>
--->
-  
-</div>
-	
-<!--
-<br>
-<br>
-Subscribe to our <a href="http://sourceforge.net/mail/?group_id=13354">mailing lists</a> if you want to always know the latest news about TW-Light.
--->
-
-<p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
-<table border="0" cellpadding="0" cellspacing="0" width="100%">
-<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
-</td></tr></table>
-	
-</body>
-</html>
\ No newline at end of file

Added: trunk/web/index.php
===================================================================
--- trunk/web/index.php	2004-10-20 08:05:48 UTC (rev 84)
+++ trunk/web/index.php	2004-10-21 20:48:46 UTC (rev 85)
@@ -0,0 +1,52 @@
+<html>
+
+<head>
+<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
+<meta http-equiv="content-type" content="text/html; charset=windows-1251">
+<meta name="description" content="Homepage of TW-Light.">
+<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
+<title>TW-Light</title>
+</head>
+
+<body>
+
+<table border="2" class="main">
+<tr valign="top">
+<td>
+<?php include("./menu.inc") ?>
+</td>
+
+<td>
+<p/>
+  <h1 class="title" align="center">TW-Light</h1>
+
+<p class="indented">
+  TW-Light is an open source clone/sequel to the epic cross-genre game
+ Star Control II. Currently it includes only a combat portion, although
+ epic adventure part that is called TW:Legacies is actively developed
+ now. TW-Light is derivative work from <a href="http://timewarp.sourceforge.net/">Star Control: Timewarp</a>
+</p>
+
+<p class="indented">
+TW-Light is written in portable C++ and is known to compile and run on <b>Linux</b>  
+and <b>Windows</b> (with the exception that it is still not 64-bit clean as nobody of 
+us has access to such hardware)
+</p>
+
+<p class="indented">
+Subscribe to our <a href="https://developer.berlios.de/mail/?group_id=2082">mailing lists</a> if you want to always know the latest news about TW-Light.
+</p>
+
+  
+</td>
+</tr>
+</table>
+
+
+<p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
+<table border="0" cellpadding="0" cellspacing="0" width="100%">
+<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
+</td></tr></table>
+	
+</body>
+</html>
\ No newline at end of file

Deleted: trunk/web/info.html
===================================================================
--- trunk/web/info.html	2004-10-20 08:05:48 UTC (rev 84)
+++ trunk/web/info.html	2004-10-21 20:48:46 UTC (rev 85)
@@ -1,122 +0,0 @@
-<html>
-<head>
-<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
-<meta http-equiv="content-type" content="text/html; charset=windows-1251">
-<meta name="description" content="Homepage of TW-Light.">
-<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
-<title>TW-Light</title>
-</head>
-
-<body>
-
-<div class="navbar">
-  <table class="navlinks" summary="navigation bar">
-    <tr>
-      <td>
-        <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
-      </td>
-      <td>
-      <a href="./index.html">News</a> | <a id="curpagelink" href="./info.html">Info</a> | <a href="./team.html">Team</a> | <a  href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://tw-light.berlios.de/mantis/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a href="./links.html">Links</a>
-      </td>
-    </tr>
-  </table>
-</div>
-
-<div class="main">
-  <h2>Game Info</h2>
-  <h3 class="important">Story Info</h3>
-  
-  <p class="indented">
-  The Ur-quan are defeated - the destruction of the Sa-matra threw them into chaos, 
-  making them easy prey for the New Alliance of Free Stars. Within weeks the NAFS 
-  forces managed to destroy most of the fleets of the two races who terrorized the 
-  galaxy for the past 20,000 years!
-  </p>
-  
-  <p class="indented">
-  Thanks to you, hope is given to the entire galaxy, and especially to the human race. 
-  Now free from their prison under a Slaveshield it's Humanity's time to rebuild.
-  </p>
-  
-  <p class="indented">
-  However, it seems there are more troubles ahead, according to a vision of 
-  the Pkunk Queen.
-  </p>
-  
-  <p class="indented">
-  It is up to you to save the galaxy again. It's a dirty job, but someone got to do it!
-  </p>
-  
-  <p class="indented">
-  And you must do it with nothing more then a mighty alliance of races 
-  and a bunch of powerful friends at your side! Or so you believe...
-  </p>
-  <p class="indented">
-  TW:Legacies will start right after StarControl II.
-  </p>
-  
-  <p class="indented">
-  The player is back into the shoes of the famous captain from the last game and 
-  will be continuing his adventures.
-  </p>
-  
-  <p class="indented">Game Features:</p>
-
-<blockquote>
-  <p class="indented">1) All the races from SCII.</p>
-  <p class="indented">&nbsp;2) Bigger and expended Starmap.</p>
-  <p class="indented">3) 13 completly new alien races.</p>
-  <p class="indented">4) Development of the Arilou, Orz and Precursor mysteries.</p>
-  <p class="indented">5) New interesting quests, mysteries and quesions.</p>
-  <p class="indented">6) The MarkII.</p>
-
-  <p class="indented">7) The origin of the Mmrnmhrm.</p>
-  <p class="indented">8) Dangerous Space Monsters. </p>
-  <p class="indented">9) Many special missions and boss fights.</p>
-  <p class="indented">10) Modular flagship (like SCII) and Precursor upgrades for normal ships.</p>
-  <p class="indented">11) Bonus quests and hidden surprises.</p>
-  <p class="indented">12) New characters that help the player during the game. </p>
-
-  <p class="indented">13) Your chance to develop your relations with the beautiful Talana to the next level! </p>
-  <p class="indented">14) And so much more...</p>
-</blockquote>
-  
-  <h3>development</h3>
-  
-<p class="indented">
-TW-Light is developed by a group of Star Control fans. Though the game is quite playable 
-now, it is far from being complete. The development of this game is still going 
-on. Please note, that this is a <b>real project</b>, not just a collection of 
-plans, ideas and dreams like in some other places in the net.
-</p>
-<p class="indented">
-Things may seem to change slow, but there is real progress and every new version 
-is (we hope ;-) better than previous one. Anyway it is better to have a working 
-game than lots of ideas, but no code at all. All the work is done in our spare 
-time, so don't expect that your nice suggestion will be implemented in a short 
-time. If you are badly missing some feature and think that you can make it 
-youself, your patch will be welcome (if it does not break all the rest ;-)
-</p>
-<p class="indented">
-You can support the project by participating discussion in 
-<a href="http://timewarp.sourceforge.net/forum/index.php">TimeWarp forum</a>, 
-where you can post suggestions for future development or just any questions about TW-Light.
-</p>
-<p class="indented">
-You can support the project by posting bugreports and patches in 
-<a href="http://tw-light.berlios.de/mantis/">TW-Light Mantis</a>
-</p>
-
-<p class="indented">
-<a href="http://svn.berlios.de/viewcvs/tw-light/">TW-Light SVN repository</a> 
-</p>
-
-</div>
-
-<p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
-<table border="0" cellpadding="0" cellspacing="0" width="100%">
-<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
-</td></tr></table>
-	
-</body>
-</html>
\ No newline at end of file

Added: trunk/web/info.php
===================================================================
--- trunk/web/info.php	2004-10-20 08:05:48 UTC (rev 84)
+++ trunk/web/info.php	2004-10-21 20:48:46 UTC (rev 85)
@@ -0,0 +1,120 @@
+<html>
+<head>
+<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
+<meta http-equiv="content-type" content="text/html; charset=windows-1251">
+<meta name="description" content="Homepage of TW-Light.">
+<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
+<title>TW-Light</title>
+</head>
+
+<body>
+
+<table border="2" class="main" width="100%">
+<tr valign="top">
+<td width="200">
+<?php include("./menu.inc") ?>
+</td>
+
+<td width="*">
+<p/>
+  <h2>Game Info</h2>
+  <h3 class="important">Story Info</h3>
+  
+  <p class="indented">
+  The Ur-quan are defeated - the destruction of the Sa-matra threw them into chaos, 
+  making them easy prey for the New Alliance of Free Stars. Within weeks the NAFS 
+  forces managed to destroy most of the fleets of the two races who terrorized the 
+  galaxy for the past 20,000 years!
+  </p>
+  
+  <p class="indented">
+  Thanks to you, hope is given to the entire galaxy, and especially to the human race. 
+  Now free from their prison under a Slaveshield it's Humanity's time to rebuild.
+  </p>
+  
+  <p class="indented">
+  However, it seems there are more troubles ahead, according to a vision of 
+  the Pkunk Queen.
+  </p>
+  
+  <p class="indented">
+  It is up to you to save the galaxy again. It's a dirty job, but someone got to do it!
+  </p>
+  
+  <p class="indented">
+  And you must do it with nothing more then a mighty alliance of races 
+  and a bunch of powerful friends at your side! Or so you believe...
+  </p>
+  <p class="indented">
+  TW:Legacies will start right after StarControl II.
+  </p>
+  
+  <p class="indented">
+  The player is back into the shoes of the famous captain from the last game and 
+  will be continuing his adventures.
+  </p>
+  
+  <p class="indented">Game Features:</p>
+
+<blockquote>
+  <p class="indented">1) All the races from SCII.</p>
+  <p class="indented">&nbsp;2) Bigger and expended Starmap.</p>
+  <p class="indented">3) 13 completly new alien races.</p>
+  <p class="indented">4) Development of the Arilou, Orz and Precursor mysteries.</p>
+  <p class="indented">5) New interesting quests, mysteries and quesions.</p>
+  <p class="indented">6) The MarkII.</p>
+
+  <p class="indented">7) The origin of the Mmrnmhrm.</p>
+  <p class="indented">8) Dangerous Space Monsters. </p>
+  <p class="indented">9) Many special missions and boss fights.</p>
+  <p class="indented">10) Modular flagship (like SCII) and Precursor upgrades for normal ships.</p>
+  <p class="indented">11) Bonus quests and hidden surprises.</p>
+  <p class="indented">12) New characters that help the player during the game. </p>
+
+  <p class="indented">13) Your chance to develop your relations with the beautiful Talana to the next level! </p>
+  <p class="indented">14) And so much more...</p>
+</blockquote>
+  
+  <h3>development</h3>
+  
+<p class="indented">
+TW-Light is developed by a group of Star Control fans. Though the game is quite playable 
+now, it is far from being complete. The development of this game is still going 
+on. Please note, that this is a <b>real project</b>, not just a collection of 
+plans, ideas and dreams like in some other places in the net.
+</p>
+<p class="indented">
+Things may seem to change slow, but there is real progress and every new version 
+is (we hope ;-) better than previous one. Anyway it is better to have a working 
+game than lots of ideas, but no code at all. All the work is done in our spare 
+time, so don't expect that your nice suggestion will be implemented in a short 
+time. If you are badly missing some feature and think that you can make it 
+youself, your patch will be welcome (if it does not break all the rest ;-)
+</p>
+<p class="indented">
+You can support the project by participating discussion in 
+<a href="http://timewarp.sourceforge.net/forum/index.php">TimeWarp forum</a>, 
+where you can post suggestions for future development or just any questions about TW-Light.
+</p>
+<p class="indented">
+You can support the project by posting bugreports and patches in 
+<a href="http://tw-light.berlios.de/mantis/">TW-Light Mantis</a>
+</p>
+
+<p class="indented">
+<a href="http://svn.berlios.de/viewcvs/tw-light/">TW-Light SVN repository</a> 
+</p>
+
+  
+</td>
+</tr>
+</table>
+
+
+<p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
+<table border="0" cellpadding="0" cellspacing="0" width="100%">
+<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
+</td></tr></table>
+	
+</body>
+-</html>
\ No newline at end of file

Deleted: trunk/web/links.html
===================================================================
--- trunk/web/links.html	2004-10-20 08:05:48 UTC (rev 84)
+++ trunk/web/links.html	2004-10-21 20:48:46 UTC (rev 85)
@@ -1,54 +0,0 @@
-<html>
-
-<head>
-<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
-<meta http-equiv="content-type" content="text/html; charset=windows-1251">
-<meta name="description" content="Homepage of TW-Light.">
-<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
-<title>TW-Light</title>
-</head>
-
-<body>
-
-<div class="navbar">
-  <table class="navlinks" summary="navigation bar">
-    <tr>
-      <td>
-        <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
-      </td>
-      <td>
-      <a href="./index.html">News</a> | <a href="./info.html">Info</a> | <a href="./team.html">Team</a> | <a href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://tw-light.berlios.de/mantis/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a id="curpagelink" href="./links.html">Links</a>
-      </td>
-    </tr>
-  </table>
-</div>
-
-<div class="main">
-  <h3>TW-Light resources</h3>
-  <ul>
-    <li><a href="http://developer.berlios.de/projects/tw-light/">BerliOS: TW-Light Project Info</a></li>
-    <li><a href="http://tw-light.berlios.de/mantis/">TW-Light Mantis</a> </li>
-    <li><a href="http://timewarp.sourceforge.net/forum/index.php">TimeWarp Forum (official)</a> </li>
-</ul>
-
-<h3>Other Star Control inspired game projects in development</h3>
-<ul>
-    <li><a href="http://timewarp.sourceforge.net">TimeWarp</a> </li>
-    <li><a href="http://sc2.sourceforge.net">The Ur-quan Masters</a> </li>
-    <li><a href="http://twx.sourceforge.net">TWX</a> </li>
-</ul>
-
-<h3>Other links</h3>
-<ul>
-    <li><a href="http://www.classicgaming.com/starcontrol/">The Pages of Now and Forever</a></li>
-    <li><a href="http://s93020567.onlinehome.us/scrpg2k3_play.htm">StarConRPG</a></li>
-</ul>
-</div>
-
-<p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
-<table border="0" cellpadding="0" cellspacing="0" width="100%">
-<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
-</td></tr></table>
-
-</body>
-</html>
\ No newline at end of file

Added: trunk/web/links.php
===================================================================
--- trunk/web/links.php	2004-10-20 08:05:48 UTC (rev 84)
+++ trunk/web/links.php	2004-10-21 20:48:46 UTC (rev 85)
@@ -0,0 +1,51 @@
+<html>
+
+<head>
+<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
+<meta http-equiv="content-type" content="text/html; charset=windows-1251">
+<meta name="description" content="Homepage of TW-Light.">
+<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
+<title>TW-Light</title>
+</head>
+
+<body>
+
+<table border="2" class="main" width="100%">
+<tr valign="top">
+<td width="200">
+<?php include("./menu.inc") ?>
+</td>
+<td width="*">
+<p/>
+  <h3>TW-Light resources</h3>
+  <ul>
+    <li><a href="http://developer.berlios.de/projects/tw-light/">BerliOS: TW-Light Project Info</a></li>
+    <li><a href="http://tw-light.berlios.de/mantis/">TW-Light Mantis</a> </li>
+    <li><a href="http://timewarp.sourceforge.net/forum/index.php">TimeWarp Forum (official)</a> </li>
+</ul>
+
+<h3>Other Star Control inspired game projects in development</h3>
+<ul>
+    <li><a href="http://timewarp.sourceforge.net">TimeWarp</a> </li>
+    <li><a href="http://sc2.sourceforge.net">The Ur-quan Masters</a> </li>
+    <li><a href="http://twx.sourceforge.net">TWX</a> </li>
+</ul>
+
+<h3>Other links</h3>
+<ul>
+    <li><a href="http://www.classicgaming.com/starcontrol/">The Pages of Now and Forever</a></li>
+    <li><a href="http://s93020567.onlinehome.us/scrpg2k3_play.htm">StarConRPG</a></li>
+</ul>
+
+</td>
+</tr>
+</table>
+
+
+<p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
+<table border="0" cellpadding="0" cellspacing="0" width="100%">
+<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
+</td></tr></table>
+
+</body>
+</html>
\ No newline at end of file

Modified: trunk/web/style.css
===================================================================
--- trunk/web/style.css	2004-10-20 08:05:48 UTC (rev 84)
+++ trunk/web/style.css	2004-10-21 20:48:46 UTC (rev 85)
@@ -1,179 +1,70 @@
 body {
-  color: white;
+  color: #C0C0C0; 
+/*  background-color: #202850; */
   background-color: black;
   font-family: arial, sans-serif, verdana;
 }
 
-h2 {
-  color: white;
-  background-color: #661166;
-  border-top: 2px solid #994499;
-  border-left: 2px solid #994499;
-  border-right: 2px solid #994499;
-  border-bottom: 2px solid #994499;    
-  padding: 0px 0px 0px 2px;
-}
-
-h3 {
-  color: white;
-  background-color: #661166;
-  border-top: 2px solid #994499;
-  border-left: 2px solid #994499;
-  border-right: 2px solid #994499;
-  border-bottom: 2px solid #994499;    
-  padding: 0px 0px 0px 2px;
-
-}
-
-h4 {
-  color: white;
-  background-color: transparent;  
-  padding: 0px 0px 0px 2px;
-}
-
-
 p {
   padding: 0px 0px 0px 2px;
 }
 
-p.indented {
+div.indented {
   padding: 0px 0px 0px 2em;
 }
 
-a:link img {
-  border-style: none;
-}
-
-a:visited img {
-  border-style: none;
-}
-
 a:link {
-  color: #bde8f6;
+  color: #00C000;
   background-color: transparent;
 }
 
 a:visited {
-  color: #7da8b6;
+  color: #00C000;
   background-color: transparent;
 }
 
 a:hover {
-  color: white;
-  background-color: #8db8c6;
+  color: #00FF00;
+  background-color: transparent;
 }
 
-/* top navigation bar */
-.navbar {
-  color: #ffffff;
-  background-color: #001133;
-  background-image: url(background.jpg);
-  margin-left: 1em;
-  margin-right: 1em;
-  margin-top: 1em;
-  margin-bottom: 1em;  
-  border-top: 2px solid #004477;
-  border-left: 2px solid #004477;
-  border-right: 2px solid #002255;
-  border-bottom: 2px solid #002255;
-  font-weight: bold;
+.title {
+  color: #C0C0C0;
+  align: center;
+  background-color: #001C36;
+  border-top: 1px solid gray;
+  border-left: 1px solid gray;
+  border-right: 1px solid gray;
+  border-bottom: 1px solid gray;
 }
 
-/* navbar links */
-.navlinks {
-  font-size: 110%;
-  text-align: center;
-}
-
-/* navbar links table settings */
-table.navlinks td {
-  padding: 0px 10px 0px 0px;
-  margin-left: 1em;
-}
-
-/* current page in navbar links */
-#curpagelink {
-  color: white;
-  background-color: transparent;
-  text-decoration: none;
-}
-/* back linking (mainly for screenshot pages) */
-.backlink {
-  font-size: 80%;
-}
-
-/* main content */
 .main {
-  color: #ffffff;
-  background-color: #001133;
-/*  background-image: url(./bluepurplenebula2.jpg);*/
-  margin-left: 1em;
-  margin-right: 1em;
-  margin-top: 1em;
-  margin-bottom: 1em;
-  border-top: 2px solid #004477;
-  border-left: 2px solid #004477;
-  border-right: 2px solid #002255;
-  border-bottom: 2px solid #002255;
-  padding: 0em 20px 0px 20px;  
+	background-color: #202850;
 }
 
-/* date (mainly for news) */
-.date {
-  font-size: 75%;
-  font-weight: normal;
-  padding: 0px 0px 0px 15px;
-}
-
-/* md5sums in download page */
-.md5 {
-  font-size: 70%;
-  color: #ddffef;
-  background-color: transparent;
-}
-
-/* bottom info (webmaster, validations) */
-.bottominfo {
-  font-size: 70%;
-  text-align: right;
-  margin-right: 5em;
-}
-
-/* quick navigation links */
-.quicklinks {
+h2 {
   color: white;
-  background-color: #002255;
-  border-top: 2px solid #006699;
-  border-left: 2px solid #006699;
-  border-right: 2px solid #006699;
-  border-bottom: 2px solid #006699;
-  margin-left: 0em;
-  margin-right: 0em;
-  margin-top: 0em;
-  margin-bottom: 0em;
-  padding: 0px 0px 0px 0px;  
-  width: 50%;
+  background-color: gray;
+  border-top: 2px solid gray;
+  border-left: 2px solid gray;
+  border-right: 2px solid gray;
+  border-bottom: 2px solid gray;    
+  padding: 0px 0px 0px 2px;
 }
 
-/* quick navigation links, <h3> */
-h3.quicklinks {
+h3 {
   color: white;
-  background-color: #800000;
-  border-top: 2px solid #bb0000;
-  border-left: 2px solid #bb0000;
-  border-right: 2px solid #bb0000;
-  border-bottom: 2px solid #bb0000;
-  width: 100%;
+  background-color: #001C36; 
+  border-top: 2px solid gray;
+  border-left: 2px solid gray;
+  border-right: 2px solid gray;
+  border-bottom: 2px solid gray;    
+  padding: 0px 0px 0px 2px;
+
 }
 
-
-/* important (red) <h3> */
-h3.important {
+h4 {
   color: white;
-  background-color: #800000;
-  border-top: 2px solid #bb0000;
-  border-left: 2px solid #bb0000;
-  border-right: 2px solid #bb0000;
-  border-bottom: 2px solid #bb0000;
+  background-color: transparent;  
   padding: 0px 0px 0px 2px;
-}
\ No newline at end of file
+}

Deleted: trunk/web/team.html
===================================================================
--- trunk/web/team.html	2004-10-20 08:05:48 UTC (rev 84)
+++ trunk/web/team.html	2004-10-21 20:48:46 UTC (rev 85)
@@ -1,75 +0,0 @@
-<html>
-<head>
-<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
-<meta http-equiv="content-type" content="text/html; charset=windows-1251">
-<meta name="description" content="Homepage of TW-Light.">
-<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
-<title>TW-Light</title>
-</head>
-
-<body>
-
-<div class="navbar">
-  <table class="navlinks" summary="navigation bar">
-    <tr>
-      <td>
-        <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
-      </td>
-      <td>
-      <a href="./index.html">News</a> | <a href="./info.html">Info</a> | <a id="curpagelink" href="./team.html">Team</a> | <a  href="./downloads.html">Downloads</a> | <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> | <a href="http://tw-light.berlios.de/mantis/">Bug Database</a> | <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a> | <a href="./links.html">Links</a>
-      </td>
-    </tr>
-  </table>
-</div>
-
-<div class="main">
-  <h2>Team</h2>
-  <h4><span id="core">Programmers:</span></h4>
-  <ul>
-    <li>Yura Semashko <a href="mailto:yurand at land.ru">(Yurand)</a></li>
-    <li>Paul Forest <a href="mailto:youbastrd at users.sourceforge.net">(youBastrd)</a></li>
-  </ul>
-
-  <h4>Content and Plot manager:</h4>
-
-  <ul>
-    <li>Asaf Hamtzany <a href="mailto:uaf at users.berlios.de">(UAF)</a></li>
-  </ul>
-  
-  <h4>Dialog Writers</h4>
-  
-  <ul>
-    <li>Pelorki</li>
-  </ul>
-  
-  <h4>Graphic Designers</h>
-  <ul>
-    <li>Rick Bushie <a href="mailto:firehazurd at yahoo.com">(Firehazurd)</a></li>
-  </ul>
-  
-  <h4>Music</h>
-  <ul>
-    <li>Robeter Productions <a href=http://www.robeterproductions.com>(www.robeterproductions.com)</a></li>
-    <li>Mark Forest (Abe Froman)</li>
-  </ul>
-  
-  <h4>Special Thanks:</h4>
-  <ul>
-    <li>Tau</li>
-    <li>GeomanNL</li>
-    <li>Officer Flubbo</li>
-    <li>Captain Maim</li>
-    <li>Jumping Peppers</li>
-    <li><a href=http://www.robeterproductions.com>Robeter Productions</a></li>
-  </ul>
-  <a href=http://www.robeterproductions.com><img alt="www.robeterproductions.com Music for Film, Television, Media, Video Games.  Recording Artists, Remixes." style="" src=www.robeterproductions.com.jpg /></a>
-  
-</div>
-
-<p align="left"><font size="3"><strong>This page is hosted by</strong></font></p>
-<table border="0" cellpadding="0" cellspacing="0" width="100%">
-<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
-</td></tr></table>
-	
-</body>
-</html>
\ No newline at end of file

Added: trunk/web/team.php
===================================================================
--- trunk/web/team.php	2004-10-20 08:05:48 UTC (rev 84)
+++ trunk/web/team.php	2004-10-21 20:48:46 UTC (rev 85)
@@ -0,0 +1,72 @@
+<html>
+<head>
+<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
+<meta http-equiv="content-type" content="text/html; charset=windows-1251">
+<meta name="description" content="Homepage of TW-Light.">
+<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
+<title>TW-Light</title>
+</head>
+
+<body>
+
+<table border="2" class="main" width="100%">
+<tr valign="top">
+<td width="200">
+<?php include("./menu.inc") ?>
+</td>
+<td width="*">
+<p/>
+
+  <h2>Team</h2>
+  <h4><span id="core">Programmers:</span></h4>
+  <ul>
+    <li>Yura Semashko <a href="mailto:yurand at land.ru">(Yurand)</a></li>
+    <li>Paul Forest <a href="mailto:youbastrd at users.sourceforge.net">(youBastrd)</a></li>
+  </ul>
+
+  <h4>Content and Plot manager:</h4>
+
+  <ul>
+    <li>Asaf Hamtzany <a href="mailto:uaf at users.berlios.de">(UAF)</a></li>
+  </ul>
+  
+  <h4>Dialog Writers</h4>
+  
+  <ul>
+    <li>Pelorki</li>
+  </ul>
+  
+  <h4>Graphic Designers</h>
+  <ul>
+    <li>Rick Bushie <a href="mailto:firehazurd at yahoo.com">(Firehazurd)</a></li>
+  </ul>
+  
+  <h4>Music</h>
+  <ul>
+    <li>Robeter Productions <a href=http://www.robeterproductions.com>(www.robeterproductions.com)</a></li>
+    <li>Mark Forest (Abe Froman)</li>
+  </ul>
+  
+  <h4>Special Thanks:</h4>
+  <ul>
+    <li>Tau</li>
+    <li>GeomanNL</li>
+    <li>Officer Flubbo</li>
+    <li>Captain Maim</li>
+    <li>Jumping Peppers</li>
+    <li><a href=http://www.robeterproductions.com>Robeter Productions</a></li>
+  </ul>
+  <a href=http://www.robeterproductions.com><img alt="www.robeterproductions.com Music for Film, Television, Media, Video Games.  Recording Artists, Remixes." style="" src=www.robeterproductions.com.jpg /></a>
+  
+</td>
+</tr>
+</table>
+
+
+<p align="left"><font size="3"><strong>This page is hosted by</strong></font></p>
+<table border="0" cellpadding="0" cellspacing="0" width="100%">
+<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
+</td></tr></table>
+	
+</body>
+</html>
\ No newline at end of file

Modified: trunk/web/update.sh
===================================================================
--- trunk/web/update.sh	2004-10-20 08:05:48 UTC (rev 84)
+++ trunk/web/update.sh	2004-10-21 20:48:46 UTC (rev 85)
@@ -1,2 +1,2 @@
 #!/bin/bash
-pscp info.html links.html yurand at shell.berlios.de:/home/groups/tw-light/htdocs
\ No newline at end of file
+pscp menu.inc yurand at shell.berlios.de:/home/groups/tw-light/htdocs
\ No newline at end of file



From yurand at sheep.berlios.de  Thu Oct 21 22:49:37 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Thu, 21 Oct 2004 22:49:37 +0200
Subject: [Tw-light-svn] r86 - trunk/web
Message-ID: <200410212049.i9LKnbvm028893@sheep.berlios.de>

Author: yurand
Date: 2004-10-21 22:49:37 +0200 (Thu, 21 Oct 2004)
New Revision: 86

Added:
   trunk/web/menu.inc
Log:
Add site


Added: trunk/web/menu.inc
===================================================================
--- trunk/web/menu.inc	2004-10-21 20:48:46 UTC (rev 85)
+++ trunk/web/menu.inc	2004-10-21 20:49:37 UTC (rev 86)
@@ -0,0 +1,50 @@
+<div class="navbar"> 
+  <table class="navlinks" summary="navigation bar">
+    <tr>
+      <td>
+        <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
+      </td>
+    </tr>
+	<tr>
+	  <td>
+      	<a href="./index.php">About</a>
+	  </td>
+	</tr>
+	<tr>
+	  <td>
+        <a href="./info.php">Info</a>
+	  </td>
+	</tr>
+	<tr>
+	  <td>
+        <a href="./team.php">Team</a>
+	  </td>
+	</tr>
+	<tr>
+	  <td>
+        <a  href="./downloads.php">Downloads</a>
+	  </td>
+	</tr>
+	<tr>
+	  <td>
+        <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> 
+	  </td>
+	</tr>
+	<tr>
+	  <td>
+        <a href="http://tw-light.berlios.de/mantis/">Bug Database</a>
+	  </td>
+	</tr>
+	<tr>
+	  <td>
+        <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a>
+	  </td>
+	</tr>
+	<tr>
+	  <td>
+        <a href="./links.php">Links</a>
+	  </td>
+	</tr>
+  </table>
+</div> 
+



From youbastrd at sheep.berlios.de  Sat Oct 23 00:20:30 2004
From: youbastrd at sheep.berlios.de (Paul Forest at BerliOS)
Date: Sat, 23 Oct 2004 00:20:30 +0200
Subject: [Tw-light-svn] r87 - in branches/multiplayer-branch/source: games melee
Message-ID: <200410222220.i9MMKUAY014790@sheep.berlios.de>

Author: youbastrd
Date: 2004-10-23 00:20:29 +0200 (Sat, 23 Oct 2004)
New Revision: 87

Modified:
   branches/multiplayer-branch/source/games/MultiplayerGame.cpp
   branches/multiplayer-branch/source/games/MultiplayerGame.h
   branches/multiplayer-branch/source/melee/PresenceRegistry.cpp
   branches/multiplayer-branch/source/melee/PresenceRegistry.h
   branches/multiplayer-branch/source/melee/mship.cpp
   branches/multiplayer-branch/source/melee/mship.h
Log:
finally fixing bug with PresenceRegistry's constructor's behaviour.  CALL_BEFORE_MAIN functions were called before the constructor was!

Modified: branches/multiplayer-branch/source/games/MultiplayerGame.cpp
===================================================================
--- branches/multiplayer-branch/source/games/MultiplayerGame.cpp	2004-10-21 20:49:37 UTC (rev 86)
+++ branches/multiplayer-branch/source/games/MultiplayerGame.cpp	2004-10-22 22:20:29 UTC (rev 87)
@@ -51,8 +51,8 @@
     _isServer(false)
 {
     message.print(5000,15,"Game on!");
-    cout << "gametype constructor:" << endl;
-    PresenceRegistry::GetInstance()->toString();
+//    cout << "gametype constructor:" << endl;
+//    PresenceRegistry::GetInstance()->toString();
 }
 
 template <class InterfaceType>
@@ -74,8 +74,10 @@
     stars = new Stars();
     add( stars );
     
-    yehat = new YehatTerminator(Vector2(0,0), 0, );
-    add( yehat );
+    humanTeam = new_team();
+    yehat = (YehatTerminator*)create_ship(channel_server, "yehte", "WussieBot", random(size), random(PI2), humanTeam);
+    add( yehat->get_ship_phaser() );
+    add_focus(yehat);
     
     if (isServer()) {
     	//printf("server:init");
@@ -118,6 +120,11 @@
 void MultiplayerGameTemplate<InterfaceType>::_add(Presence *p) 
 {
     if (isServer()) {
+    	if (p->GetClassID() == 0) {
+    		cout <<"Skipping adding a " << p->GetClassName() << endl;
+    		cout.flush();
+    		return;
+    	}
     	printf("adding: (%s:%d) ObjectID=%d ", p->GetClassName(), p->GetClassID(), p->GetObjectID());
         PresenceCreationDescription pc( p->GetObjectID(), p->GetClassID() );
         printf("as (%s:%d)\n", 
@@ -284,11 +291,11 @@
 	// Another system has requested to connect to us, which we have accepted.  Server or peer only.
     message.print(10000,15,"%s has connected", ((StaticClientDataStruct*)(server->GetStaticClientData(packet->playerId))->GetData())->name);
     
-    TeamCode human = new_team();
-    Control *c = create_control(channel_server, "Human");
-    Ship *s = create_ship("yehte", c, Vector2(size.x/2,size.y/2), 0, human);
-    add(s->get_ship_phaser());
-    add_focus(s);
+    //TeamCode human = new_team();
+    //Control *c = create_control(channel_server, "Human");
+    //Ship *s = create_ship("yehte", c, Vector2(size.x/2,size.y/2), 0, human);
+    //add(s->get_ship_phaser());
+    //add_focus(s);
   
 #ifdef _DEBUG
 	message.print(5000,15,"ID_NEW_INCOMING_CONNECTION from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);

Modified: branches/multiplayer-branch/source/games/MultiplayerGame.h
===================================================================
--- branches/multiplayer-branch/source/games/MultiplayerGame.h	2004-10-21 20:49:37 UTC (rev 86)
+++ branches/multiplayer-branch/source/games/MultiplayerGame.h	2004-10-22 22:20:29 UTC (rev 87)
@@ -94,6 +94,7 @@
 	~MultiplayerGameTemplate();
 	
 	YehatTerminator * yehat;
+	TeamCode humanTeam;
 
 	
 	// Methods and data stuctures from class Game /////////////////////////////////////////////////

Modified: branches/multiplayer-branch/source/melee/PresenceRegistry.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/PresenceRegistry.cpp	2004-10-21 20:49:37 UTC (rev 86)
+++ branches/multiplayer-branch/source/melee/PresenceRegistry.cpp	2004-10-22 22:20:29 UTC (rev 87)
@@ -22,42 +22,40 @@
 
 #include "melee/PresenceRegistry.h"
 
-PresenceRegistry presenceRegistry;
+PresenceRegistry * presenceRegistry = NULL;
+int presenceClassCount = 0;
 
-PresenceRegistry::PresenceRegistry() : boo(0) {
-   cout << "PR Constructor" << endl;
-   cout.flush();
-   boo ++;
+PresenceRegistry::PresenceRegistry(){
 }
 
-void PresenceRegistry::registerPresenceClass (const char * className, Presence * (*GetPresenceClassInstance)()) {
-	//cout << "register boo="<<presenceRegistry.boo<<endl;
+void PresenceRegistry::registerPresenceClass (const char * className, Presence * (*GetPresenceClassInstance)(), unsigned classID) {
+	//cout << "register boo="<<presenceRegistry->boo<<endl;
 	
     //Check to see if this class has already been added.
     //If so, don't do anything.
     vector <PresenceClassDescription>::iterator iter;
-    vector <PresenceClassDescription>::iterator iterEnd = presenceRegistry.presenceClassDescriptionList.end();
-    for (iter = presenceRegistry.presenceClassDescriptionList.begin();
+    vector <PresenceClassDescription>::iterator iterEnd = presenceRegistry->presenceClassDescriptionList.end();
+    for (iter = presenceRegistry->presenceClassDescriptionList.begin();
          iter != iterEnd;
          ++iter)
     {
         if (strcmp(iter->className, className)==0)
             return;
     }
-    unsigned id = presenceRegistry.presenceClassDescriptionList.size() + 1;
+    unsigned id = classID;//presenceRegistry->presenceClassDescriptionList.size() + 1;
     PresenceClassDescription pcd(className,
         id,
         GetPresenceClassInstance);
-    presenceRegistry.presenceClassDescriptionList.push_back(pcd);
+    presenceRegistry->presenceClassDescriptionList.push_back(pcd);
     
-//    cout << "registering PresenceClass ( " << className << "," 
-//    	 << id << ") as (" << presenceRegistry.getClassName(id) << "," << presenceRegistry.getClassID(className) <<")"<< endl;
+//    cout << "registering PresenceClass (" << className << "," 
+//    	 << id << ") as (" << presenceRegistry->getClassName(id) << "," << presenceRegistry->getClassID(className) <<")"<< endl;
 //    cout.flush();
 }
 
 ///
 Presence * PresenceRegistry::GetPresenceClassDefaultInstance(const unsigned classID) {
-    PresenceClassDescription * desc = presenceRegistry.getPresenceItem(classID);
+    PresenceClassDescription * desc = presenceRegistry->getPresenceItem(classID);
     if (desc)
     	return desc->getPresenceClassInstance();
     
@@ -66,7 +64,7 @@
 
 ///
 Presence * PresenceRegistry::GetPresenceClassDefaultInstance(const char * className) { 
-	PresenceClassDescription * pcd = presenceRegistry.getPresenceItem(className);
+	PresenceClassDescription * pcd = presenceRegistry->getPresenceItem(className);
 	if (pcd)
 	   return pcd->getPresenceClassInstance();
 	return NULL;
@@ -91,14 +89,14 @@
 }*/
 
 const unsigned PresenceRegistry::getClassID(const char * className) {
-	PresenceClassDescription * pcd = presenceRegistry.getPresenceItem(className);
+	PresenceClassDescription * pcd = presenceRegistry->getPresenceItem(className);
 	if (pcd)
 		return pcd->classID;
 	return 0;	
 }
 
 const char * PresenceRegistry::getClassName( const unsigned classID ) {
-	PresenceClassDescription * pcd = presenceRegistry.getPresenceItem(classID);
+	PresenceClassDescription * pcd = presenceRegistry->getPresenceItem(classID);
 	if (pcd)
 		return pcd->className;
 	return "";
@@ -107,8 +105,8 @@
 PresenceClassDescription * PresenceRegistry::getPresenceItem(const unsigned classID) 
 {
 //	cout << "checking for ClassID " << classID << " list.size" << presenceClassDescriptionList.size();
-    vector <PresenceClassDescription>::iterator iter = presenceRegistry.presenceClassDescriptionList.begin();
-    vector <PresenceClassDescription>::iterator iterEnd = presenceRegistry.presenceClassDescriptionList.end();
+    vector <PresenceClassDescription>::iterator iter = presenceRegistry->presenceClassDescriptionList.begin();
+    vector <PresenceClassDescription>::iterator iterEnd = presenceRegistry->presenceClassDescriptionList.end();
     for ( ;
          iter != iterEnd;
          ++iter)
@@ -127,8 +125,8 @@
 PresenceClassDescription * PresenceRegistry::getPresenceItem(const char * className) 
 {
 //	cout << "checking for Classname " << className << " list.size=" << presenceClassDescriptionList.size();
-    vector <PresenceClassDescription>::iterator iter = presenceRegistry.presenceClassDescriptionList.begin();
-    vector <PresenceClassDescription>::iterator iterEnd = presenceRegistry.presenceClassDescriptionList.end();
+    vector <PresenceClassDescription>::iterator iter = presenceRegistry->presenceClassDescriptionList.begin();
+    vector <PresenceClassDescription>::iterator iterEnd = presenceRegistry->presenceClassDescriptionList.end();
     for ( ;
          iter != iterEnd;
          ++iter)
@@ -145,13 +143,22 @@
 }
 
 PresenceRegistry * PresenceRegistry::GetInstance() { 
-	//cout << "GetInstance:list size=" << presenceRegistry.presenceClassDescriptionList.size() << endl;
+	//cout << "GetInstance:list size=" << presenceRegistry->presenceClassDescriptionList.size() << endl;
 	cout.flush();
     return (PresenceRegistry *)&presenceRegistry; 
 }
 
 void PresenceRegistry::toString() {
-//	cout << "to string  boo(PR)="<<presenceRegistry.boo<< " boo(this)="<<boo <<endl;
+	cout << "PR::to string(): size="<<presenceRegistry->presenceClassDescriptionList.size()<< " ";
+    vector <PresenceClassDescription>::iterator iter = presenceRegistry->presenceClassDescriptionList.begin();
+    vector <PresenceClassDescription>::iterator iterEnd = presenceRegistry->presenceClassDescriptionList.end();
+    for ( ;
+         iter != iterEnd;
+         ++iter)
+    {
+    	cout << " (" << iter->className <<":"<<iter->classID<<")"<< endl;
+    }
+    cout.flush();
 
 	//printf("PresenceRegistry:size=%d\n", presenceRegistry->presenceClassDescriptionList.size());
 	

Modified: branches/multiplayer-branch/source/melee/PresenceRegistry.h
===================================================================
--- branches/multiplayer-branch/source/melee/PresenceRegistry.h	2004-10-21 20:49:37 UTC (rev 86)
+++ branches/multiplayer-branch/source/melee/PresenceRegistry.h	2004-10-22 22:20:29 UTC (rev 87)
@@ -28,8 +28,11 @@
 class PresenceRegistry;
 
 /// global instance
-extern PresenceRegistry presenceRegistry;
+extern PresenceRegistry * presenceRegistry;
 
+/// temporary workaround... does CALL_BEFORE_MAIN execute before constructor calls?
+extern int presenceClassCount;
+
 /// Describes a Presence subclass.  Contains a class name, and classID,
 /// which is set at compile-time.  Each Presence subclass must have a unique 
 /// classID
@@ -69,7 +72,7 @@
     
     ///Registers a Presence subclass.  
     /// @param className the name of the class to register.
-    static void registerPresenceClass (const char * className, Presence * (*GetPresenceClassInstance)());
+    static void registerPresenceClass (const char * className, Presence * (*GetPresenceClassInstance)(), unsigned classID);
     
     ///
     Presence * GetPresenceClassDefaultInstance(const unsigned ClassID);
@@ -110,11 +113,14 @@
     
 };
 
+//#define getpresenceClassCount() (presenceClassCount)
+
 ///This macro must be called once for every subclass of Presence.  It make the
 ///subclass available in network code.  Note that the subclass has two requirements:
 ///- it must have a no-argument constructor
-///- it must declare, but not implement, 
+///- it must declare, but not implement, these two public methods:
 /// virtual char * MyPresenceClass::GetClassName(void) const;
+/// virtual unsigned MyPresenceClass::GetClassID(void) const;
 ///
 ///Call this macro like this:
 ///
@@ -123,9 +129,10 @@
 ///class MyPresenceClass : public Presence {
 ///public:
 ///  MyPresenceClass() {...}
-///  virtual char * PRESENCE_CLASS::GetClassName(void) const;
+///  virtual char * GetClassName(void) const;
+///  virtual unsigned GetClassID(void) const;
 ///  ...
-///}
+///};
 ///
 /// (at the end of your .cpp file)
 ///
@@ -133,15 +140,19 @@
 /// @param PRESENCE_CLASS the class to register.
 ///
 #define REGISTER_PRESENCE_CLASS(PRESENCE_CLASS) \
-char * PRESENCE_CLASS::GetClassName(void) const { return # PRESENCE_CLASS ; } \
-unsigned PRESENCE_CLASS::GetClassID(void) const { return PresenceRegistry::GetInstance()->getClassID(# PRESENCE_CLASS) ; } \
+char * PRESENCE_CLASS::GetClassName(void) const { return #PRESENCE_CLASS ; } \
+unsigned PRESENCE_CLASS::GetClassID(void) const { return PresenceRegistry::GetInstance()->getClassID(#PRESENCE_CLASS) ; } \
 static Presence * GetDefaultInstance ## PRESENCE_CLASS () { return new PRESENCE_CLASS(); } \
 static void registerBeforeMain ## PRESENCE_CLASS (void) { \
-  PresenceRegistry::GetInstance()->registerPresenceClass( # PRESENCE_CLASS ,  GetDefaultInstance ## PRESENCE_CLASS ); \
+  if (presenceRegistry == NULL) presenceRegistry = new PresenceRegistry(); \
+  presenceClassCount++; \
+  PresenceRegistry::GetInstance()->registerPresenceClass( #PRESENCE_CLASS ,  GetDefaultInstance ## PRESENCE_CLASS , presenceClassCount ); \
   REGISTER_DISTRIBUTED_CLASS(PRESENCE_CLASS); \
 } \
 CALL_BEFORE_MAIN(registerBeforeMain ## PRESENCE_CLASS );
 
+
+
 ///
 ///
 #define REGISTER_PRESENCE_CLASS_NO_NETWORK(PRESENCE_CLASS) \

Modified: branches/multiplayer-branch/source/melee/mship.cpp
===================================================================
--- branches/multiplayer-branch/source/melee/mship.cpp	2004-10-21 20:49:37 UTC (rev 86)
+++ branches/multiplayer-branch/source/melee/mship.cpp	2004-10-22 22:20:29 UTC (rev 87)
@@ -999,3 +999,5 @@
 REGISTER_PRESENCE_CLASS(HomingMissile)
 REGISTER_PRESENCE_CLASS(Laser)
 REGISTER_PRESENCE_CLASS(PointLaser)
+REGISTER_PRESENCE_CLASS(Phaser)
+

Modified: branches/multiplayer-branch/source/melee/mship.h
===================================================================
--- branches/multiplayer-branch/source/melee/mship.h	2004-10-21 20:49:37 UTC (rev 86)
+++ branches/multiplayer-branch/source/melee/mship.h	2004-10-22 22:20:29 UTC (rev 87)
@@ -64,6 +64,9 @@
   Phaser::Phaser(SpaceLocation *creator, Vector2 pos, Vector2 rel_pos, 
 		 Ship *ship, SpaceSprite *sprite, int osprite_index, int *ocolors, 
 		 int onum_colors, int ofsize, int steps, int step_time) ;
+	Phaser::Phaser() { }
+	virtual char * GetClassName(void) const;
+	virtual unsigned GetClassID(void) const;
   
   virtual void animate(Frame *space);
   virtual void calculate();



From yurand at sheep.berlios.de  Sat Oct 23 00:40:37 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 23 Oct 2004 00:40:37 +0200
Subject: [Tw-light-svn] r88 - trunk/web
Message-ID: <200410222240.i9MMebr8011623@sheep.berlios.de>

Author: yurand
Date: 2004-10-23 00:40:35 +0200 (Sat, 23 Oct 2004)
New Revision: 88

Added:
   trunk/web/footer.inc
   trunk/web/header.inc
Removed:
   trunk/web/menu.inc
Modified:
   trunk/web/downloads.php
   trunk/web/index.php
   trunk/web/info.php
   trunk/web/links.php
   trunk/web/team.php
   trunk/web/update.sh
Log:
little site update


Modified: trunk/web/downloads.php
===================================================================
--- trunk/web/downloads.php	2004-10-22 22:20:29 UTC (rev 87)
+++ trunk/web/downloads.php	2004-10-22 22:40:35 UTC (rev 88)
@@ -1,22 +1,4 @@
-<html>
-
-<head>
-<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
-<meta http-equiv="content-type" content="text/html; charset=windows-1251">
-<meta name="description" content="Homepage of TW-Light.">
-<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
-<title>TW-Light</title>
-</head>
-
-<body>
-
-<table border="2" class="main" width="100%">
-<tr valign="top">
-<td width="200">
-<?php include("./menu.inc") ?>
-</td>
-<td width="*">
-<p/>
+<?php include("./header.inc") ?>
 <h2>Downloads</h2>
   
 <p class="indented">
@@ -39,15 +21,4 @@
 
 </p>
 
-</td>
-</tr>
-</table>
-
-
-<p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
-<table border="0" cellpadding="0" cellspacing="0" width="100%">
-<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
-</td></tr></table>	
-
-</body>
-</html>
\ No newline at end of file
+<?php include("./footer.inc") ?>

Added: trunk/web/footer.inc
===================================================================
--- trunk/web/footer.inc	2004-10-22 22:20:29 UTC (rev 87)
+++ trunk/web/footer.inc	2004-10-22 22:40:35 UTC (rev 88)
@@ -0,0 +1,13 @@
+  
+</td>
+</tr>
+</table>
+
+
+<p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
+<table border="0" cellpadding="0" cellspacing="0" width="100%">
+<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
+</td></tr></table>
+	
+</body>
+</html>
\ No newline at end of file

Added: trunk/web/header.inc
===================================================================
--- trunk/web/header.inc	2004-10-22 22:20:29 UTC (rev 87)
+++ trunk/web/header.inc	2004-10-22 22:40:35 UTC (rev 88)
@@ -0,0 +1,69 @@
+<html>
+
+<head>
+<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
+<meta http-equiv="content-type" content="text/html; charset=windows-1251">
+<meta name="description" content="Homepage of TW-Light.">
+<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
+<title>TW-Light</title>
+</head>
+
+<body>
+
+<table border="2" class="main" width="100%">
+<tr valign="top">
+<td width="200">
+<div class="navbar"> 
+  <table class="navlinks" summary="navigation bar">
+    <tr>
+      <td>
+        <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
+      </td>
+    </tr>
+	<tr>
+	  <td>
+      	<a href="./index.php">About</a>
+	  </td>
+	</tr>
+	<tr>
+	  <td>
+        <a href="./info.php">Info</a>
+	  </td>
+	</tr>
+	<tr>
+	  <td>
+        <a href="./team.php">Team</a>
+	  </td>
+	</tr>
+	<tr>
+	  <td>
+        <a  href="./downloads.php">Downloads</a>
+	  </td>
+	</tr>
+	<tr>
+	  <td>
+        <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> 
+	  </td>
+	</tr>
+	<tr>
+	  <td>
+        <a href="http://tw-light.berlios.de/mantis/">Bug Database</a>
+	  </td>
+	</tr>
+	<tr>
+	  <td>
+        <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a>
+	  </td>
+	</tr>
+	<tr>
+	  <td>
+        <a href="./links.php">Links</a>
+	  </td>
+	</tr>
+  </table>
+</div> 
+
+</td>
+
+<td width="*">
+<p/>

Modified: trunk/web/index.php
===================================================================
--- trunk/web/index.php	2004-10-22 22:20:29 UTC (rev 87)
+++ trunk/web/index.php	2004-10-22 22:40:35 UTC (rev 88)
@@ -1,23 +1,4 @@
-<html>
-
-<head>
-<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
-<meta http-equiv="content-type" content="text/html; charset=windows-1251">
-<meta name="description" content="Homepage of TW-Light.">
-<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
-<title>TW-Light</title>
-</head>
-
-<body>
-
-<table border="2" class="main">
-<tr valign="top">
-<td>
-<?php include("./menu.inc") ?>
-</td>
-
-<td>
-<p/>
+<?php include("./header.inc") ?>
   <h1 class="title" align="center">TW-Light</h1>
 
 <p class="indented">
@@ -37,16 +18,4 @@
 Subscribe to our <a href="https://developer.berlios.de/mail/?group_id=2082">mailing lists</a> if you want to always know the latest news about TW-Light.
 </p>
 
-  
-</td>
-</tr>
-</table>
-
-
-<p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
-<table border="0" cellpadding="0" cellspacing="0" width="100%">
-<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
-</td></tr></table>
-	
-</body>
-</html>
\ No newline at end of file
+<?php include("./footer.inc") ?>
\ No newline at end of file

Modified: trunk/web/info.php
===================================================================
--- trunk/web/info.php	2004-10-22 22:20:29 UTC (rev 87)
+++ trunk/web/info.php	2004-10-22 22:40:35 UTC (rev 88)
@@ -1,22 +1,4 @@
-<html>
-<head>
-<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
-<meta http-equiv="content-type" content="text/html; charset=windows-1251">
-<meta name="description" content="Homepage of TW-Light.">
-<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
-<title>TW-Light</title>
-</head>
-
-<body>
-
-<table border="2" class="main" width="100%">
-<tr valign="top">
-<td width="200">
-<?php include("./menu.inc") ?>
-</td>
-
-<td width="*">
-<p/>
+<?php include("./header.inc") ?>
   <h2>Game Info</h2>
   <h3 class="important">Story Info</h3>
   
@@ -105,16 +87,4 @@
 <a href="http://svn.berlios.de/viewcvs/tw-light/">TW-Light SVN repository</a> 
 </p>
 
-  
-</td>
-</tr>
-</table>
-
-
-<p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
-<table border="0" cellpadding="0" cellspacing="0" width="100%">
-<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
-</td></tr></table>
-	
-</body>
--</html>
\ No newline at end of file
+<?php include("./footer.inc") ?>

Modified: trunk/web/links.php
===================================================================
--- trunk/web/links.php	2004-10-22 22:20:29 UTC (rev 87)
+++ trunk/web/links.php	2004-10-22 22:40:35 UTC (rev 88)
@@ -1,22 +1,4 @@
-<html>
-
-<head>
-<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
-<meta http-equiv="content-type" content="text/html; charset=windows-1251">
-<meta name="description" content="Homepage of TW-Light.">
-<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
-<title>TW-Light</title>
-</head>
-
-<body>
-
-<table border="2" class="main" width="100%">
-<tr valign="top">
-<td width="200">
-<?php include("./menu.inc") ?>
-</td>
-<td width="*">
-<p/>
+<?php include("./header.inc") ?>
   <h3>TW-Light resources</h3>
   <ul>
     <li><a href="http://developer.berlios.de/projects/tw-light/">BerliOS: TW-Light Project Info</a></li>
@@ -37,15 +19,4 @@
     <li><a href="http://s93020567.onlinehome.us/scrpg2k3_play.htm">StarConRPG</a></li>
 </ul>
 
-</td>
-</tr>
-</table>
-
-
-<p align="left"><font size="3"><strong>this page is hosted by</strong></font></p>
-<table border="0" cellpadding="0" cellspacing="0" width="100%">
-<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
-</td></tr></table>
-
-</body>
-</html>
\ No newline at end of file
+<?php include("./footer.inc") ?>

Deleted: trunk/web/menu.inc
===================================================================
--- trunk/web/menu.inc	2004-10-22 22:20:29 UTC (rev 87)
+++ trunk/web/menu.inc	2004-10-22 22:40:35 UTC (rev 88)
@@ -1,50 +0,0 @@
-<div class="navbar"> 
-  <table class="navlinks" summary="navigation bar">
-    <tr>
-      <td>
-        <img src="./3dlogo.jpg" alt="" width="200" height="120" /> 
-      </td>
-    </tr>
-	<tr>
-	  <td>
-      	<a href="./index.php">About</a>
-	  </td>
-	</tr>
-	<tr>
-	  <td>
-        <a href="./info.php">Info</a>
-	  </td>
-	</tr>
-	<tr>
-	  <td>
-        <a href="./team.php">Team</a>
-	  </td>
-	</tr>
-	<tr>
-	  <td>
-        <a  href="./downloads.php">Downloads</a>
-	  </td>
-	</tr>
-	<tr>
-	  <td>
-        <a href="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">Wiki</a> 
-	  </td>
-	</tr>
-	<tr>
-	  <td>
-        <a href="http://tw-light.berlios.de/mantis/">Bug Database</a>
-	  </td>
-	</tr>
-	<tr>
-	  <td>
-        <a href="http://timewarp.sourceforge.net/forum/index.php">Forum</a>
-	  </td>
-	</tr>
-	<tr>
-	  <td>
-        <a href="./links.php">Links</a>
-	  </td>
-	</tr>
-  </table>
-</div> 
-

Modified: trunk/web/team.php
===================================================================
--- trunk/web/team.php	2004-10-22 22:20:29 UTC (rev 87)
+++ trunk/web/team.php	2004-10-22 22:40:35 UTC (rev 88)
@@ -1,22 +1,5 @@
-<html>
-<head>
-<link href="style.css" rel="stylesheet" type="text/css" title="default"/>
-<meta http-equiv="content-type" content="text/html; charset=windows-1251">
-<meta name="description" content="Homepage of TW-Light.">
-<meta name="keywords" content="TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW">
-<title>TW-Light</title>
-</head>
+<?php include("./header.inc") ?>
 
-<body>
-
-<table border="2" class="main" width="100%">
-<tr valign="top">
-<td width="200">
-<?php include("./menu.inc") ?>
-</td>
-<td width="*">
-<p/>
-
   <h2>Team</h2>
   <h4><span id="core">Programmers:</span></h4>
   <ul>
@@ -57,16 +40,5 @@
     <li><a href=http://www.robeterproductions.com>Robeter Productions</a></li>
   </ul>
   <a href=http://www.robeterproductions.com><img alt="www.robeterproductions.com Music for Film, Television, Media, Video Games.  Recording Artists, Remixes." style="" src=www.robeterproductions.com.jpg /></a>
-  
-</td>
-</tr>
-</table>
 
-
-<p align="left"><font size="3"><strong>This page is hosted by</strong></font></p>
-<table border="0" cellpadding="0" cellspacing="0" width="100%">
-<tr><td align="left"><a href="http://developer.berlios.de" title="BerliOS Developer"> <img src="http://developer.berlios.de/bslogo.php?group_id=2082" width="124px" height="32px" border="0" alt="BerliOS Developer Logo"></a>
-</td></tr></table>
-	
-</body>
-</html>
\ No newline at end of file
+<?php include("./footer.inc") ?>  

Modified: trunk/web/update.sh
===================================================================
--- trunk/web/update.sh	2004-10-22 22:20:29 UTC (rev 87)
+++ trunk/web/update.sh	2004-10-22 22:40:35 UTC (rev 88)
@@ -1,2 +1,2 @@
 #!/bin/bash
-pscp menu.inc yurand at shell.berlios.de:/home/groups/tw-light/htdocs
\ No newline at end of file
+pscp header.inc footer.inc *.php yurand at shell.berlios.de:/home/groups/tw-light/htdocs
\ No newline at end of file



From yurand at sheep.berlios.de  Sat Oct 23 12:00:30 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 23 Oct 2004 12:00:30 +0200
Subject: [Tw-light-svn] r89 - in trunk: . source source/ais source/games
Message-ID: <200410231000.i9NA0U2n013588@sheep.berlios.de>

Author: yurand
Date: 2004-10-23 12:00:29 +0200 (Sat, 23 Oct 2004)
New Revision: 89

Removed:
   trunk/source/twgui/
Modified:
   trunk/source/ais.h
   trunk/source/ais/c_input.cpp
   trunk/source/ais/c_other.cpp
   trunk/source/ais/c_wussie.cpp
   trunk/source/frame.cpp
   trunk/source/frame.h
   trunk/source/games/gdefender.cpp
   trunk/source/games/gflmelee.cpp
   trunk/source/games/gflmelee.h
   trunk/source/games/ggob.cpp
   trunk/sources.lst
Log:
Removed twgui, little formating


Modified: trunk/source/ais/c_input.cpp
===================================================================
--- trunk/source/ais/c_input.cpp	2004-10-22 22:40:35 UTC (rev 88)
+++ trunk/source/ais/c_input.cpp	2004-10-23 10:00:29 UTC (rev 89)
@@ -28,15 +28,14 @@
 #include "other/dialogs.h"
 
 #include "other/twconfig.h"
-#include "../melee/mfleet.h" //for Fleet class
-#include "../scp.h" //for ship_view_dialog()
+#include "melee/mfleet.h" //for Fleet class
+#include "scp.h" //for ship_view_dialog()
 
-char selectShipPrompt[100] = "";
-char selectPlayer[18] = "";
+char selectShipPrompt[100]  = "";
+char selectPlayer[18]       = "";
 char selectTitleString[100] = "";
 
 
-
 int my_bitmap_proc( int msg, DIALOG* d, int c )
 {
   if( msg == MSG_END && d->dp )
@@ -60,7 +59,7 @@
       ShipType* type = fleet->getShipType(d->d1);
       
       ASSERT(type != NULL);
-
+      
       selectDialog[SELECT_DIALOG_TITLE].flags |= D_DIRTY;
       sprintf(selectTitleString, "%s\n%s\n%d of %d points", 
 	      selectShipPrompt,
@@ -124,23 +123,23 @@
 	}	
       else
 	sprintf (dialog_string[0], "De-Calibrate");
-    
+      
       char buffy[1024];
       char *d = buffy;
-    
+      
       d += sprintf(d, "Joystick %d\n\n", which_joystick);
-    
+      
       for (i = 0; i < ::joy[which_joystick].num_sticks; i += 1) 
 	{
 	  d += sprintf(d, "%s %d\n", ::joy[which_joystick].stick[i].name, i);
 	}
-    
+      
       d += sprintf(d, "\nBUTTONS\n");
       for (i = 0; i < ::joy[which_joystick].num_buttons; i += 1) 
 	{
 	  d += sprintf(d, " %s", ::joy[which_joystick].button[i].name);
 	}
-    
+      
       joyDialog[JOY_DIALOG_DESCRIPTION].dp = buffy;
       i = tw_popup_dialog(NULL,joyDialog, 1);
       if (i == -1)
@@ -177,6 +176,7 @@
 */
 void ControlHuman::load (const char *inifile, const char *inisection) 
 {
+  STACKTRACE;
   tw_set_config_file (inifile);
   thrust  = get_config_int(inisection, "Thrust",      0);
   back    = get_config_int(inisection, "Backwards",   0);
@@ -203,6 +203,7 @@
  */
 void ControlHuman::save (const char *inifile, const char *inisection) 
 {
+  STACKTRACE;
   tw_set_config_file (inifile);
   set_config_int(inisection, "Thrust",         thrust);
   set_config_int(inisection, "Backwards",      back);
@@ -259,54 +260,62 @@
   STACKTRACE;
 };
 
-int ControlHuman::choose_ship(VideoWindow *window, char * prompt, Fleet *fleet) {
+int ControlHuman::choose_ship(VideoWindow *window, char * prompt, Fleet *fleet) 
+{
   STACKTRACE;
-	int ret = -1, slot = 0;
-	if (fleet->getSize() == 0) {tw_error ("Empty fleet! (prompt:%s)", prompt);}
-	selectDialog[SELECT_DIALOG_LIST].dp3 = fleet;
+  int ret = -1, slot = 0;
+  if (fleet->getSize() == 0) 
+    {
+      tw_error ("Empty fleet! (prompt:%s)", prompt);
+    }
+  selectDialog[SELECT_DIALOG_LIST].dp3 = fleet;
 
-    strcpy(selectShipPrompt,prompt);
+  strcpy(selectShipPrompt,prompt);
 
+  slot = -1;
+  while (!always_random) 
+    {
+      while (key[KEY_ENTER] || key[KEY_SPACE]) 
+	poll_keyboard();
 
-	slot = -1;
-	while (!always_random) {
-		while (key[KEY_ENTER] || key[KEY_SPACE]) poll_keyboard();
-
-
-		ret = tw_do_dialog(window, selectDialog, SELECT_DIALOG_LIST);
-		if (ret == SELECT_DIALOG_INFO) {
-			ship_view_dialog(
-				selectDialog[SELECT_DIALOG_LIST].d1, 
-				fleet 
-			);
-			continue;
-		}
-		break;
+      ret = tw_do_dialog(window, selectDialog, SELECT_DIALOG_LIST);
+      if (ret == SELECT_DIALOG_INFO) 
+	{
+	  ship_view_dialog(
+			   selectDialog[SELECT_DIALOG_LIST].d1, 
+			   fleet 
+			   );
+	  continue;
 	}
-	if ((ret == SELECT_DIALOG_SHIP) || (ret == SELECT_DIALOG_LIST))
-		slot = selectDialog[SELECT_DIALOG_LIST].d1;
-	if ((ret == SELECT_DIALOG_ARANDOM) || (ret == -1)) always_random = 1;
-	return(slot);
+      break;
+    }
+  if ((ret == SELECT_DIALOG_SHIP) || (ret == SELECT_DIALOG_LIST))
+    slot = selectDialog[SELECT_DIALOG_LIST].d1;
+  if ((ret == SELECT_DIALOG_ARANDOM) || (ret == -1)) 
+    always_random = 1;
+  return(slot);
 }
 
 /*! returns help text for this controller ie keys to use this controller*/
-void ControlHuman::getHelpText(char * text) {
+void ControlHuman::getHelpText(char * text) 
+{
   STACKTRACE;
-	char line[80] = "";
-	char desc[80] = "";
-
-	sprintf(line, "Player Controls:\n"); strcat(text, line);
-
-	key_to_description(left, desc);	sprintf ( line, "  Left: %s\n", desc);strcat(text, line);
-	key_to_description(right, desc);	sprintf ( line, "  Right: %s\n", desc);strcat(text, line);
-	key_to_description(thrust, desc);	sprintf ( line, "  Thrust: %s\n", desc);strcat(text, line);
-	key_to_description(fire, desc);	sprintf ( line, "  Fire: %s\n", desc);strcat(text, line);
-	key_to_description(special, desc);	sprintf ( line, "  Special: %s\n", desc);strcat(text, line);
-	key_to_description(altfire, desc);	sprintf ( line, "  Altfire: %s\n", desc);strcat(text, line);
-	key_to_description(next, desc);	sprintf ( line, "  Next Target: %s\n", desc);strcat(text, line);
-	key_to_description(prev, desc);	sprintf ( line, "  Previous Target: %s\n", desc);strcat(text, line);
-	key_to_description(closest, desc);	sprintf ( line, "  Closest: %s\n", desc);strcat(text, line);
-	key_to_description(suicide, desc);	sprintf ( line, "  Suicide: %s\n", desc);strcat(text, line);
+  char line[80] = "";
+  char desc[80] = "";
+  
+  sprintf(line, "Player Controls:\n"); 
+  strcat(text, line);
+  
+  key_to_description(left, desc);   sprintf ( line, "  Left: %s\n", desc);strcat(text, line);
+  key_to_description(right, desc);  sprintf ( line, "  Right: %s\n", desc);strcat(text, line);
+  key_to_description(thrust, desc); sprintf ( line, "  Thrust: %s\n", desc);strcat(text, line);
+  key_to_description(fire, desc);   sprintf ( line, "  Fire: %s\n", desc);strcat(text, line);
+  key_to_description(special, desc);sprintf ( line, "  Special: %s\n", desc);strcat(text, line);
+  key_to_description(altfire, desc);sprintf ( line, "  Altfire: %s\n", desc);strcat(text, line);
+  key_to_description(next, desc);   sprintf ( line, "  Next Target: %s\n", desc);strcat(text, line);
+  key_to_description(prev, desc);   sprintf ( line, "  Previous Target: %s\n", desc);strcat(text, line);
+  key_to_description(closest, desc);sprintf ( line, "  Closest: %s\n", desc);strcat(text, line);
+  key_to_description(suicide, desc);sprintf ( line, "  Suicide: %s\n", desc);strcat(text, line);
 }
 
 /*! \brief setap players keys */
@@ -380,7 +389,8 @@
       for (i = 1; i < KEY_DIALOG_OK; i += 1) 
 	{
 	  int t = strlen(dialog_string[i]);
-	  if (maxlen < t) maxlen = t;
+	  if (maxlen < t) 
+	    maxlen = t;
 	}
       for (i = 1; i < KEY_DIALOG_OK; i += 1) 
 	{
@@ -389,9 +399,11 @@
 	  memset(dialog_string[i]+t, ' ', maxlen-t);
 	}
       clear_keybuf();
-      if (last < KEY_DIALOG_OK) last += 1;
+      if (last < KEY_DIALOG_OK) 
+	last += 1;
       i = tw_do_dialog(NULL, keyDialog, last);
-      if (i == -1) return;
+      if (i == -1) 
+	return;
       if (i < KEY_DIALOG_OK) 
 	{
 	  t = get_key();

Modified: trunk/source/ais/c_other.cpp
===================================================================
--- trunk/source/ais/c_other.cpp	2004-10-22 22:40:35 UTC (rev 88)
+++ trunk/source/ais/c_other.cpp	2004-10-23 10:00:29 UTC (rev 89)
@@ -46,61 +46,57 @@
 {
 }
 
+/// Get name
 const char *ControlMoron::getTypeName() 
 {
   STACKTRACE;
   return "MoronBot";
 }
 
-/*! \brief Simple AI 
-  \param ship with this stupid AI
-*/
-int stupid_bot(Ship *ship) 
+/*! \brief Morron bot AI */
+int ControlMoron::think()
 {
   STACKTRACE;
-    
-  int r = 0;
-  double a;
-  if (!ship->target) return 0;
-  if (!ship->target->exists()) 
+  if (ship)
     {
-      ship->target = NULL;
-      return 0;
-    }
-  a = ship->trajectory_angle(ship->target) - ship->get_angle();
-  a = fmod(a + PI2, PI2);
-  if (a < PI) 
-    {
-      r |= keyflag::right;
-    }
-  else 
-    {
-      r |= keyflag::left;
+      int r = 0;
+      double a;
+      if (!ship->target) 
+	return 0;
+      if (!ship->target->exists()) 
+	{
+	  ship->target = NULL;
+	  return 0;
+	}
+      a = ship->trajectory_angle(ship->target) - ship->get_angle();
+      a = fmod(a + PI2, PI2);
+      if (a < PI) 
+	{
+	  r |= keyflag::right;
+	}
+      else 
+	{
+	  r |= keyflag::left;
+	  return r;
+	}
+      a = int(ship->distance(ship->target));
+      if (a > 2000) 
+	{
+	  r |= keyflag::thrust;
+	}
+      else 
+	{
+	  r |= keyflag::thrust;
+	  r |= keyflag::fire;
+	}
       return r;
     }
-  a = int(ship->distance(ship->target));
-  if (a > 2000) 
+  else
     {
-      r |= keyflag::thrust;
+      return 0;
     }
-  else 
-    {
-      r |= keyflag::thrust;
-      r |= keyflag::fire;
-    }
-  return r;
 }
 
-/*! \brief Summon stupid_bot() */
-int ControlMoron::think()
-{
-  STACKTRACE;
-  if (ship)
-    return stupid_bot(ship);
-  else
-    return 0;
-}
-
 ControlMoron::ControlMoron(const char *name, int channel) : Control(name, channel, ai_index_moron) 
 {
   STACKTRACE;

Modified: trunk/source/ais/c_wussie.cpp
===================================================================
--- trunk/source/ais/c_wussie.cpp	2004-10-22 22:40:35 UTC (rev 88)
+++ trunk/source/ais/c_wussie.cpp	2004-10-23 10:00:29 UTC (rev 89)
@@ -1,6 +1,6 @@
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -29,40 +29,49 @@
 #include "melee/mship.h"
 #include "melee/mmain.h"
 
-#define OPTION_UNKNOWN 0
-#define OPTION_NONE 1
-#define OPTION_FRONT 2
-#define OPTION_NO_FRONT 3
-#define OPTION_SIDES 4
-#define OPTION_BACK 5
-#define OPTION_FEILD 6
-#define OPTION_NARROW 7
-#define OPTION_HOMING 8
-#define OPTION_PROXIMITY 9
-#define OPTION_NO_PROXIMITY 10
-#define OPTION_NO_RANGE 11
-#define OPTION_HOLD 12
-#define OPTION_PRECEDENCE 13
-#define OPTION_DEFENSE 14
-#define OPTION_CLOAK 15
-#define OPTION_MAX_BATT 16
-#define OPTION_BATTERY 17
-#define OPTION_RESERVE_BATT 18
-#define OPTION_PLUS_FIRE 19
-#define OPTION_PLUS_SPECIAL 20
-#define OPTION_LAUNCHED 21
-#define OPTION_NEXT_STATE 22
-#define OPTION_RESET_STATE 23
-#define OPTION_ALWAYS_WHEN_FULL 24
-#define OPTION_MINE 25
+enum 
+  {
+    OPTION_UNKNOWN = 0,
+    OPTION_NONE,
+    OPTION_FRONT,
+    OPTION_NO_FRONT,
+    OPTION_SIDES,
+    OPTION_BACK,
+    OPTION_FEILD,
+    OPTION_NARROW,
+    OPTION_HOMING,
+    OPTION_PROXIMITY,
+    OPTION_NO_PROXIMITY,
+    OPTION_NO_RANGE,
+    OPTION_HOLD,
+    OPTION_PRECEDENCE,
+    OPTION_DEFENSE,
+    OPTION_CLOAK,
+    OPTION_MAX_BATT,
+    OPTION_BATTERY,
+    OPTION_RESERVE_BATT,
+    OPTION_PLUS_FIRE,
+    OPTION_PLUS_SPECIAL,
+    OPTION_LAUNCHED,
+    OPTION_NEXT_STATE,
+    OPTION_RESET_STATE,
+    OPTION_ALWAYS_WHEN_FULL,
+    OPTION_MINE,
+  };
 
-#define STATE_TOO_CLOSE 0
-#define STATE_TOO_FAR 1
+enum
+  {
+    STATE_TOO_CLOSE = 0,
+    STATE_TOO_FAR,
+  };
 
-#define TACTIC_UNKNOWN 1
-#define TACTIC_INDIRECT_INTERCEPT 2
-#define TACTIC_DIRECT_INTERCEPT 3
-#define TACTIC_RANGE 4
+enum
+  {
+    TACTIC_UNKNOWN = 1,
+    TACTIC_INDIRECT_INTERCEPT,
+    TACTIC_DIRECT_INTERCEPT,
+    TACTIC_RANGE,
+  };
 
 /*! \brief Check danger
   \return Max damage ship can get from his enemies
@@ -175,6 +184,7 @@
   return dodgeangle;
 }
 
+/// Wussie bot AI
 int ControlWussie::think ()
 {
   STACKTRACE;

Modified: trunk/source/ais.h
===================================================================
--- trunk/source/ais.h	2004-10-22 22:40:35 UTC (rev 88)
+++ trunk/source/ais.h	2004-10-23 10:00:29 UTC (rev 89)
@@ -1,7 +1,6 @@
-/* $Id: ais.h,v 1.1.1.1 2004/08/01 10:21:18 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -27,7 +26,8 @@
 
 //ais/c_input.cpp
 /*! \brief Human Ship Control */
-class ControlHuman : public Control {	
+class ControlHuman : public Control 
+{	
  private:
   int thrust;
   int left;
@@ -53,11 +53,9 @@
   friend class NormalGame;
 };
 
-//ais/c_other.cpp
-int stupid_bot(Ship *ship) ;
-
 /*! \brief AI with no brain */
-class ControlVegetable : public Control {	
+class ControlVegetable : public Control 
+{	
  public:
   virtual const char *getTypeName();
   virtual int think();
@@ -66,7 +64,8 @@
 };
 
 /*! \brief Simple AI */
-class ControlMoron : public Control {	
+class ControlMoron : public Control 
+{	
  public:
   virtual const char *getTypeName();
   virtual int think();
@@ -77,7 +76,8 @@
 
 //ais/c_wussie.cpp
 /*! \brief Complex AI */
-class ControlWussie : public Control {
+class ControlWussie : public Control 
+{
  public:
   virtual const char *getTypeName();
   virtual int think();
@@ -112,8 +112,9 @@
 };
 
 /*! \brief Is Key pressed */
-class KeyState {
-  public:
+class KeyState 
+{
+ public:
   bool thrust;
   bool turn_left;
   bool turn_right;

Modified: trunk/source/frame.cpp
===================================================================
--- trunk/source/frame.cpp	2004-10-22 22:40:35 UTC (rev 88)
+++ trunk/source/frame.cpp	2004-10-23 10:00:29 UTC (rev 89)
@@ -1,7 +1,6 @@
-/* $Id: frame.cpp,v 1.1.1.1 2004/08/01 10:21:18 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -411,7 +410,6 @@
       release_bitmap(tmp);
       destroy_bitmap(tmp);
       
-      //drawn_items = item_count;
       old_item_count = 0;
     }
   return;

Modified: trunk/source/frame.h
===================================================================
--- trunk/source/frame.h	2004-10-22 22:40:35 UTC (rev 88)
+++ trunk/source/frame.h	2004-10-23 10:00:29 UTC (rev 89)
@@ -1,7 +1,6 @@
-/* $Id: frame.h,v 1.1.1.1 2004/08/01 10:21:18 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -18,9 +17,10 @@
 #ifndef __FRAME_H__
 #define __FRAME_H__
 
-typedef struct DirtyItem {
+typedef struct DirtyItem 
+{
   int x, y, a, b;
-
+  
   void (*erase_item)(DirtyItem *item, BITMAP *frame);
   void (*draw_item)(DirtyItem *item, BITMAP *frame, BITMAP *child);
 } DirtyItem;

Modified: trunk/source/games/gdefender.cpp
===================================================================
--- trunk/source/games/gdefender.cpp	2004-10-22 22:40:35 UTC (rev 88)
+++ trunk/source/games/gdefender.cpp	2004-10-23 10:00:29 UTC (rev 89)
@@ -1,5 +1,20 @@
+/*
+This file is part of "TW-Light" 
+                    http://tw-light.berlios.de/
+Copyright (C) 2001-2004  TimeWarp development team
 
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
 
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+
 #include <stdio.h>   //standard io libary (needed for sprintf)
 #include <allegro.h> //allegro library header
 

Modified: trunk/source/games/gflmelee.cpp
===================================================================
--- trunk/source/games/gflmelee.cpp	2004-10-22 22:40:35 UTC (rev 88)
+++ trunk/source/games/gflmelee.cpp	2004-10-23 10:00:29 UTC (rev 89)
@@ -1,4 +1,3 @@
-/* $Id: gflmelee.cpp,v 1.1.1.1 2004/08/01 10:21:21 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
                     http://tw-light.berlios.de/

Modified: trunk/source/games/gflmelee.h
===================================================================
--- trunk/source/games/gflmelee.h	2004-10-22 22:40:35 UTC (rev 88)
+++ trunk/source/games/gflmelee.h	2004-10-23 10:00:29 UTC (rev 89)
@@ -1,7 +1,6 @@
-/* $Id: gflmelee.h,v 1.1.1.1 2004/08/01 10:21:21 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -22,14 +21,14 @@
 class ShipPanelBmp : public Presence 
 {
  public:
-  BITMAP *panel;		// this is the whole panel, including the captain pic.
+  BITMAP *panel;		///< this is the whole panel, including the captain pic.
   BITMAP *captain;
   
   int crew_old;
   int batt_old;
   char batt_light;
   
-  char old_thrust;         // previous keypresses for ship
+  char old_thrust;         ///< previous keypresses for ship
   char old_turn_left;
   char old_turn_right;
   char old_fire_weapon;
@@ -41,12 +40,12 @@
   
   ShipPanelBmp(Ship *oship);
   virtual ~ShipPanelBmp();
-  
+ 
+  ///used for drawing crew & battery bars 
   virtual void draw_stuff(int x, int y, int w, int h, int dx, int dy, int m, int value, int max, int color, int bcolor);
-  //used for drawing crew & battery bars
+ 
   
   virtual void animate_panel(); 
-  //the parameter "space" is not used
 };
 
 #endif //__GFLMELEE_H__

Modified: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2004-10-22 22:40:35 UTC (rev 88)
+++ trunk/source/games/ggob.cpp	2004-10-23 10:00:29 UTC (rev 89)
@@ -101,17 +101,20 @@
   defenderSprite = NULL;
 }
 
-bool GobGame::isGameDone() {
-	bool done = true;
-	for (int i = 0; i < gobplayers; i += 1) {
-		if (gobplayer[i]->ship != NULL)
-			done = false;
-	}
-	if (done) {
-		game_done = true;
-		tw_alert("Game Over!\n\nYour ship and its contents are lost!", "Ok");
+bool GobGame::isGameDone() 
+{
+  bool done = true;
+  for (int i = 0; i < gobplayers; i += 1) 
+    {
+      if (gobplayer[i]->ship != NULL)
+	done = false;
     }
-	return Game::isGameDone();
+  if (done) 
+    {
+      game_done = true;
+      tw_alert("Game Over!\n\nYour ship and its contents are lost!", "Ok");
+    }
+  return Game::isGameDone();
 }
 
 void GobGame::add_gobplayer(Control *control) 
@@ -211,62 +214,62 @@
 
   add(new Stars());
 	
-	num_planets = 0;
-	i = 0;
-	add_planet_and_station(meleedata.planetSprite, i, 
-			       stationSprite[i], station_build_name[i], station_pic_name[i]);
-	i = 1;
-	add_planet_and_station(meleedata.planetSprite, i, stationSprite[i], station_build_name[i], station_pic_name[i]);
-	i = 2;
-	add_planet_and_station(meleedata.planetSprite, i, stationSprite[i], station_build_name[i], station_pic_name[i]);
-	i = random() % 3;
-	add_planet_and_station(meleedata.planetSprite, i, stationSprite[i], "utwju", station_pic_name[i]);
+  num_planets = 0;
+  i = 0;
+  add_planet_and_station(meleedata.planetSprite, i, 
+			 stationSprite[i], station_build_name[i], station_pic_name[i]);
+  i = 1;
+  add_planet_and_station(meleedata.planetSprite, i, stationSprite[i], station_build_name[i], station_pic_name[i]);
+  i = 2;
+  add_planet_and_station(meleedata.planetSprite, i, stationSprite[i], station_build_name[i], station_pic_name[i]);
+  i = random() % 3;
+  add_planet_and_station(meleedata.planetSprite, i, stationSprite[i], "utwju", station_pic_name[i]);
+  
+  for (i = 0; i < 19; i += 1) add(new GobAsteroid());
 
-	for (i = 0; i < 19; i += 1) add(new GobAsteroid());
-
-
-
-	int server_players, client_players;
-	tw_set_config_file("client.ini");
-	server_players = client_players = get_config_int("Gob", "NumPlayers", 1);
-	if (!lag_frames) client_players = 0;
-	log_int(channel_server, server_players);
-	log_int(channel_client, client_players);
-	for (i = 0; i < server_players; i += 1) {
-		char buffy[256];
-		sprintf(buffy, "Config%d", i);
-		add_gobplayer(create_control(channel_server, "Human", buffy));
-		gobplayer[i]->new_ship(shiptype("supbl"));
-		Ship *s = gobplayer[i]->ship;
-		s->translate(size/2-s->normal_pos());
-		double angle = PI2 * i / (client_players + server_players);
-		s->translate(rotate(Vector2(260, 120), angle));
-		s->accelerate(s, PI2/3 + angle, 0.17, MAX_SPEED);
-	}
-	for (i = server_players; i < client_players + server_players; i += 1) {
-		char buffy[256];
-		sprintf(buffy, "Config%d", i - server_players);
-		add_gobplayer(create_control(channel_client, "Human", buffy));
-		gobplayer[i]->new_ship(shiptype("supbl"));
-		Ship *s = gobplayer[i]->ship;
-		s->translate(size/2-s->normal_pos());
-		double angle = PI2 * i / (client_players + server_players);
-		s->translate(rotate(Vector2(260, 120), angle));
-		s->accelerate(s, PI2/3 + angle, 0.17, MAX_SPEED);
-	}
-
-	for (i = 0; i < gobplayers; i += 1) add ( new RainbowRift() );
-
-	next_add_new_enemy_time = 1000;
-	add_new_enemy();
-	this->change_view("Hero");
-	view->window->locate(
-		0,0,
-		0,0,
-		0,0.9,
-		0,1
-		);
-	return;
+  int server_players, client_players;
+  tw_set_config_file("client.ini");
+  server_players = client_players = get_config_int("Gob", "NumPlayers", 1);
+  if (!lag_frames) client_players = 0;
+  log_int(channel_server, server_players);
+  log_int(channel_client, client_players);
+  for (i = 0; i < server_players; i += 1) 
+    {
+      char buffy[256];
+      sprintf(buffy, "Config%d", i);
+      add_gobplayer(create_control(channel_server, "Human", buffy));
+      gobplayer[i]->new_ship(shiptype("supbl"));
+      Ship *s = gobplayer[i]->ship;
+      s->translate(size/2-s->normal_pos());
+      double angle = PI2 * i / (client_players + server_players);
+      s->translate(rotate(Vector2(260, 120), angle));
+      s->accelerate(s, PI2/3 + angle, 0.17, MAX_SPEED);
+    }
+  for (i = server_players; i < client_players + server_players; i += 1) 
+    {
+      char buffy[256];
+      sprintf(buffy, "Config%d", i - server_players);
+      add_gobplayer(create_control(channel_client, "Human", buffy));
+      gobplayer[i]->new_ship(shiptype("supbl"));
+      Ship *s = gobplayer[i]->ship;
+      s->translate(size/2-s->normal_pos());
+      double angle = PI2 * i / (client_players + server_players);
+      s->translate(rotate(Vector2(260, 120), angle));
+      s->accelerate(s, PI2/3 + angle, 0.17, MAX_SPEED);
+    }
+  
+  for (i = 0; i < gobplayers; i += 1) add ( new RainbowRift() );
+  
+  next_add_new_enemy_time = 1000;
+  add_new_enemy();
+  this->change_view("Hero");
+  view->window->locate(
+		       0,0,
+		       0,0,
+		       0,0.9,
+		       0,1
+		       );
+  return;
 }
 GobGame::~GobGame() {
   delete stationSprite[0];
@@ -296,7 +299,8 @@
     {
       SpaceLocation *n;
       n = p->nearest_planet();
-      if (!n || (p->distance(n) > 1500)) break;
+      if (!n || (p->distance(n) > 1500)) 
+	break;
       p->translate(random(size));
     }
   add ( p );
@@ -326,11 +330,12 @@
       if (!is_local(gobplayer[i]->channel)) 
 	continue;
       
-      if (gobplayer[i]->ship) {
-	message.print((int)msecs_per_fps, 15-i, "coordinates: %d x %d", 
-		      iround(gobplayer[i]->ship->normal_pos().x), 
-		      iround(gobplayer[i]->ship->normal_pos().y));
-      }
+      if (gobplayer[i]->ship) 
+	{
+	  message.print((int)msecs_per_fps, 15-i, "coordinates: %d x %d", 
+			iround(gobplayer[i]->ship->normal_pos().x), 
+			iround(gobplayer[i]->ship->normal_pos().y));
+	}
       message.print((int)msecs_per_fps, 15-i, "starbucks: %d", gobplayer[i]->starbucks);
       message.print((int)msecs_per_fps, 15-i, "buckazoids: %d", gobplayer[i]->buckazoids);
       message.print((int)msecs_per_fps, 15-i, "kills: %d", gobplayer[i]->kills);
@@ -342,21 +347,27 @@
 {
   STACKTRACE;
   
-
-  if (next_add_new_enemy_time <= game_time) {
-    next_add_new_enemy_time = game_time;
-    int t = 28;
-    if ((random() % t) < 4) add_new_enemy();
-    int e = gobenemies;
-    e -= random() % (1 + game_time / (250 * 1000));
-    if (0) ;
-    else if (e >=12) next_add_new_enemy_time += 15000;
-    else if (e >= 7) next_add_new_enemy_time += 7000;
-    else if (e >= 4) next_add_new_enemy_time += 5000;
-    else if (e >= 2) next_add_new_enemy_time += 3000;
-    else if (e >= 1) next_add_new_enemy_time += 2000;
-    else next_add_new_enemy_time += 1000;
-  }
+  if (next_add_new_enemy_time <= game_time) 
+    {
+      next_add_new_enemy_time = game_time;
+      int t = 28;
+      if ((random() % t) < 4) add_new_enemy();
+      int e = gobenemies;
+      e -= random() % (1 + game_time / (250 * 1000));
+      if (0) ;
+      else if (e >=12) 
+	next_add_new_enemy_time += 15000;
+      else if (e >= 7) 
+	next_add_new_enemy_time += 7000;
+      else if (e >= 4) 
+	next_add_new_enemy_time += 5000;
+      else if (e >= 2) 
+	next_add_new_enemy_time += 3000;
+      else if (e >= 1) 
+	next_add_new_enemy_time += 2000;
+      else 
+	next_add_new_enemy_time += 1000;
+    }
   Game::calculate();
   return;
 }
@@ -379,42 +390,51 @@
   STACKTRACE;
   
   GobPlayer *p = this->get_player(who);
-  if (p && (p->ship == who)) { //Player died
-    p->died(source);
-  }
-	int i = get_enemy_index(who);
-	if ((i != -1) && (gobenemy[i]->ship == who)) {
-		GobEnemy *e = gobenemy[i];
-		e->died(source);
-		gobenemies -= 1;
-		GobEnemy *tmp = gobenemy[gobenemies];
-		gobenemy[i] = tmp;
-		p = get_player(source);
-	}
+  if (p && (p->ship == who)) 
+    { //Player died
+      p->died(source);
+    }
+  int i = get_enemy_index(who);
+  if ((i != -1) && (gobenemy[i]->ship == who)) 
+    {
+      GobEnemy *e = gobenemy[i];
+      e->died(source);
+      gobenemies -= 1;
+      GobEnemy *tmp = gobenemy[gobenemies];
+      gobenemy[i] = tmp;
+      p = get_player(source);
+    }
 
-	Game::ship_died(who, source);
-	return;
+  Game::ship_died(who, source);
+  return;
 }
-GobPlayer *GobGame::get_player(SpaceLocation *what) {
+
+GobPlayer *GobGame::get_player(SpaceLocation *what) 
+{
   STACKTRACE;
-	int i;
-	for (i = 0; i < gobplayers; i += 1) {		
-		if (what->get_team() == gobplayer[i]->team) return gobplayer[i];
-	}
-	return NULL;
+  int i;
+  for (i = 0; i < gobplayers; i += 1) 
+    {		
+      if (what->get_team() == gobplayer[i]->team) 
+	return gobplayer[i];
+    }
+  return NULL;
 }
+
 void GobGame::add_new_enemy() 
 {
   STACKTRACE;
   
-  static char *enemy_types[] = {
-		"thrto", "zfpst", "shosc", "dragr", 
-		"kahbo", "ilwsp", 
-		"syrpe", "kzedr", "mmrxf", 
-		"druma", "earcr", 
-		"yehte", "chmav" 
-		};
+  static char *enemy_types[] = 
+    {
+      "thrto", "zfpst", "shosc", "dragr", 
+      "kahbo", "ilwsp", 
+      "syrpe", "kzedr", "mmrxf", 
+      "druma", "earcr", 
+      "yehte", "chmav" 
+    };
   const int num_enemy_types = sizeof(enemy_types)/sizeof(enemy_types[0]);
+
   if (gobenemies == max_enemies) 
     return;
   GobEnemy *ge = new GobEnemy();
@@ -450,53 +470,73 @@
     //if (e > num_enemy_types * 2) e = e % num_enemy_types;
     e = e;
   }
-  Ship *ship = create_ship(channel_server, enemy_types[e], "WussieBot", random(size), random(PI2), enemy_team);
-  if (!strcmp(enemy_types[e], "shosc")) ((ShofixtiScout*)ship)->specialDamage /= 4;
-  if (!strcmp(enemy_types[e], "zfpst")) ((ZoqFotPikStinger*)ship)->specialDamage /= 2;
-  if (!strcmp(enemy_types[e], "syrpe")) ((SyreenPenetrator*)ship)->specialDamage /= 2;
-  if (!strcmp(enemy_types[e], "dragr")) ship->special_drain *= 2;
-  if (!strcmp(enemy_types[e], "chmav")) {
-    ((ChmmrAvatar*)ship)->weaponDamage += 1;
-    ((ChmmrAvatar*)ship)->weaponDamage /= 2;
-    ((ChmmrAvatar*)ship)->specialForce *= 2;
-    ((ChmmrAvatar*)ship)->specialRange *= 2;
-  }
+  Ship *ship = create_ship(channel_server, enemy_types[e], "WussieBot", 
+			   random(size), random(PI2), enemy_team);
+  /*
+  if (!strcmp(enemy_types[e], "shosc")) 
+    ((ShofixtiScout*)ship)->specialDamage /= 4;
+  if (!strcmp(enemy_types[e], "zfpst")) 
+    ((ZoqFotPikStinger*)ship)->specialDamage /= 2;
+  if (!strcmp(enemy_types[e], "syrpe")) 
+    ((SyreenPenetrator*)ship)->specialDamage /= 2;
+  if (!strcmp(enemy_types[e], "dragr")) 
+    ship->special_drain *= 2;
+  if (!strcmp(enemy_types[e], "chmav")) 
+    {
+      ((ChmmrAvatar*)ship)->weaponDamage += 1;
+      ((ChmmrAvatar*)ship)->weaponDamage /= 2;
+      ((ChmmrAvatar*)ship)->specialForce *= 2;
+      ((ChmmrAvatar*)ship)->specialRange *= 2;
+    }
+  */
+
   int sb, bz;
   sb = 1 + e / 4;
-  if (sb > 2) sb -= 1;
+  if (sb > 2) 
+    sb -= 1;
   bz = (e - 9) / 2;
-  if (bz > 1) bz -= 1;
-  if (sb < 0) sb = 0;
-	if (bz < 0) bz = 0;
-	ge->init(ship, sb, bz);
-	add(ship->get_ship_phaser());
-	//add(ship);
-	return;
+  if (bz > 1) 
+    bz -= 1;
+  if (sb < 0) 
+    sb = 0;
+  if (bz < 0) 
+    bz = 0;
+  ge->init(ship, sb, bz);
+  add(ship->get_ship_phaser());
+  
+  return;
 }
 
-void GobEnemy::init(Ship *ship, int kill_starbucks, int kill_buckazoids) {
+void GobEnemy::init(Ship *ship, int kill_starbucks, int kill_buckazoids) 
+{
   STACKTRACE;
-	this->ship = ship;
-	this->starbucks = kill_starbucks;
-	this->buckazoids = kill_buckazoids;
-	return;
-	}
-void GobEnemy::died(SpaceLocation *what) {
+  this->ship = ship;
+  this->starbucks = kill_starbucks;
+  this->buckazoids = kill_buckazoids;
+  return;
+}
+
+void GobEnemy::died(SpaceLocation *what) 
+{
   STACKTRACE;
-	GobPlayer *p = gobgame->get_player(what);
-	if (p) {
-		p->starbucks += starbucks;
-		p->buckazoids += buckazoids;
-		p->kills += 1;
-	}
-	return;
+  GobPlayer *p = gobgame->get_player(what);
+  if (p) 
+    {
+      p->starbucks += starbucks;
+      p->buckazoids += buckazoids;
+      p->kills += 1;
+    }
+  return;
 }
 
 
-GobPlayer::~GobPlayer() {
-	free (pair_list);
+GobPlayer::~GobPlayer() 
+{
+  free (pair_list);
 }
-void GobPlayer::init(Control *c, TeamCode team) {
+
+void GobPlayer::init(Control *c, TeamCode team) 
+{
   STACKTRACE;
   channel = c->channel;
   starbucks = 0;
@@ -515,23 +555,30 @@
   for (i = 0; ::upgrade_list[i]; i += 1) ::upgrade_list[i]->index = i;
   upgrade_list = new Upgrade*[i+1];
   upgrade_list[i] = NULL;
-  for (j = 0; j < i; j += 1) {
-    upgrade_list[j] = ::upgrade_list[j]->duplicate();
-    upgrade_list[j]->clear(NULL, NULL, this);
-  }
+  for (j = 0; j < i; j += 1) 
+    {
+      upgrade_list[j] = ::upgrade_list[j]->duplicate();
+      upgrade_list[j]->clear(NULL, NULL, this);
+    }
   return;
 }
-GobPlayer::pair *GobPlayer::_get_pair(const char *id) {
+
+GobPlayer::pair *GobPlayer::_get_pair(const char *id) 
+{
   STACKTRACE;
-  if (!pair_list) return NULL;
+  if (!pair_list) 
+    return NULL;
   int i;
-  for (i = 0; i < num_pairs; i += 1) {
-    if (!strcmp(pair_list[i].id, id)) 
-			return &pair_list[i];
-  }
+  for (i = 0; i < num_pairs; i += 1) 
+    {
+      if (!strcmp(pair_list[i].id, id)) 
+	return &pair_list[i];
+    }
   return NULL;
 }
-void GobPlayer::_add_pair(const char *id, int value) {
+
+void GobPlayer::_add_pair(const char *id, int value) 
+{
   STACKTRACE;
   if (_get_pair(id)) 
     {
@@ -545,125 +592,149 @@
   return;
 }
 
-int GobPlayer::read_pair(const char *id) {
+int GobPlayer::read_pair(const char *id) 
+{
   STACKTRACE;
   pair *p = _get_pair(id);
-  if (p) return p->value;
+  if (p) 
+    return p->value;
   return -1;
 }
 
-void GobPlayer::write_pair(const char *id, int value) {
+void GobPlayer::write_pair(const char *id, int value) 
+{
   STACKTRACE;
   pair *p = _get_pair(id);
-  if (p) p->value = value;
-  else _add_pair(id, value);
+  if (p) 
+    p->value = value;
+  else 
+    _add_pair(id, value);
   return;
 }
-int GobPlayer::charge (char *name, int price_starbucks, int price_buckazoids) {
+
+int GobPlayer::charge (char *name, int price_starbucks, int price_buckazoids) 
+{
   char buffy1[512];
   sprintf(buffy1, "Price: %d starbucks plus %d buckazoids", price_starbucks, price_buckazoids);
-  if ((starbucks < price_starbucks) || (buckazoids < price_buckazoids)) {
-    if (game->is_local(channel)) 
-      alert("You don't have enough.", name, buffy1, "Cancel", NULL, 0, 0);
-    return 0;
-  }
+  if ((starbucks < price_starbucks) || (buckazoids < price_buckazoids)) 
+    {
+      if (game->is_local(channel)) 
+	alert("You don't have enough.", name, buffy1, "Cancel", NULL, 0, 0);
+      return 0;
+    }
   int r = 0;
   if (game->is_local(channel)) 
     r = alert ("Do you wish to make this purchase?", name, buffy1, "&No", "&Yes", 'n', 'y');
   game->log_int(channel, r);
-  if (r == 2) {
-    starbucks -= price_starbucks;
-    buckazoids -= price_buckazoids;
-    return 1;
-  }
+  if (r == 2) 
+    {
+      starbucks -= price_starbucks;
+      buckazoids -= price_buckazoids;
+      return 1;
+    }
   return 0;
 }
-void GobPlayer::new_ship(ShipType *type) {
+
+void GobPlayer::new_ship(ShipType *type) 
+{
   STACKTRACE;
   Ship *old = ship;
   Vector2 pos = 0;
   double a = 0;
   int i;
-  if (old) {
-    pos = old->normal_pos();
-    a = old->get_angle();
-  }
+  if (old) 
+    {
+      pos = old->normal_pos();
+      a = old->get_angle();
+    }
   
   ship = game->create_ship ( type->id, control, pos, a, team);
   
   
-  if (panel) panel->die();
-	panel = NULL;
-	panel = new ShipPanel(ship);
-	panel->always_redraw = true;
-	panel->window->init(game->window);
-	if (game->is_local(control->channel)) {
-		panel->window->locate(
-			0,0.9,
-			0,0,
-			0,0.1,
-			0,0.25
-		);
-	}
-	else {
-		panel->window->locate(
-			0,0.9,
-			0,0.25,
-			0,0.1,
-			0,0.25
-		);
-	}
-	panel->set_depth(10);
-	game->add(panel);
+  if (panel) 
+    panel->die();
+  panel = NULL;
+  panel = new ShipPanel(ship);
+  panel->always_redraw = true;
+  panel->window->init(game->window);
+  if (game->is_local(control->channel)) 
+    {
+      panel->window->locate(
+			    0,0.9,
+			    0,0,
+			    0,0.1,
+			    0,0.25
+			    );
+    }
+  else 
+    {
+      panel->window->locate(
+			    0,0.9,
+			    0,0.25,
+			    0,0.1,
+			    0,0.25
+			    );
+    }
+  panel->set_depth(10);
+  game->add(panel);
+  
+  for (i = 0; upgrade_list[i]; i += 1) 
+    {
+      upgrade_list[i]->clear(old, ship, this);
+    }
+  if (old) 
+    {
+      old->die();
+      game->add(ship);
+    }
+  else 
+    game->add(ship->get_ship_phaser());
+  return;
+}
 
-	for (i = 0; upgrade_list[i]; i += 1) {
-		upgrade_list[i]->clear(old, ship, this);
-		}
-	if (old) {
-		old->die();
-		game->add(ship);
-		}
-	else game->add(ship->get_ship_phaser());
-	return;
-	}
-
-void GobStation::buy_new_ship_menu(GobPlayer *s) {
+void GobStation::buy_new_ship_menu(GobPlayer *s) 
+{
   STACKTRACE;
 
   char buffy1[512], buffy2[512];
   ShipType *otype = s->ship->type;
   ShipType *ntype = shiptype(build_type);
-  if (otype == ntype) {
-    sprintf (buffy1, "You already have a %s", ntype->name);
-    if (game->is_local(s->channel)) 
-      alert(buffy1, NULL, NULL, "&Cancel", NULL, 'c', 0);
-    return;
-  }
+  if (otype == ntype) 
+    {
+      sprintf (buffy1, "You already have a %s", ntype->name);
+      if (game->is_local(s->channel)) 
+	alert(buffy1, NULL, NULL, "&Cancel", NULL, 'c', 0);
+      return;
+    }
   int ossb = (s->value_starbucks*3) / 4 + (s->ship->type->cost*1)/1;
   int osbz = (s->value_buckazoids*3) / 4 + (s->ship->type->cost*1)/1;
   int nssb = ntype->cost;
   int nsbz = ntype->cost;
   sprintf (buffy1, "You have a %s worth %d s$ / %d b$", otype->name, ossb, osbz);
   sprintf (buffy2, "A %s costs %d s$ / %d b$", ntype->name, nssb, nsbz);
-  if ((nssb <= (ossb + s->starbucks)) && (nsbz <= (osbz + s->buckazoids))) {
-    int i = 0;
-    if (game->is_local(s->channel))
-      i = alert(buffy1, buffy2, "Do you wish to buy it?", "Yeah!", "No", 'y', 'n');
-    game->log_int(s->channel, i);
-    if (i == 1) {
-      s->starbucks -= nssb - ossb;
-      s->buckazoids -= nsbz - osbz;
-      s->new_ship(ntype);
+  if ((nssb <= (ossb + s->starbucks)) && (nsbz <= (osbz + s->buckazoids))) 
+    {
+      int i = 0;
+      if (game->is_local(s->channel))
+	i = alert(buffy1, buffy2, "Do you wish to buy it?", "Yeah!", "No", 'y', 'n');
+      game->log_int(s->channel, i);
+      if (i == 1) 
+	{
+	  s->starbucks -= nssb - ossb;
+	  s->buckazoids -= nsbz - osbz;
+	  s->new_ship(ntype);
+	}
     }
-  }
-  else {
-    if (game->is_local(s->channel)) 
-      alert (buffy1, buffy2, "You don't have enough to buy it", "Cancel", NULL, 0, 0);
-  }
+  else 
+    {
+      if (game->is_local(s->channel)) 
+	alert (buffy1, buffy2, "You don't have enough to buy it", "Cancel", NULL, 0, 0);
+    }
   return;
 }
 
-GobStation::GobStation ( SpaceSprite *pic, SpaceLocation *orbit_me, const char *ship, const char *background) : 
+GobStation::GobStation ( SpaceSprite *pic, SpaceLocation *orbit_me, const char *ship, 
+			 const char *background) : 
   Orbiter(pic, orbit_me, random() % 200 + 500) 
 {
   build_type = ship;

Modified: trunk/sources.lst
===================================================================
--- trunk/sources.lst	2004-10-22 22:40:35 UTC (rev 88)
+++ trunk/sources.lst	2004-10-23 10:00:29 UTC (rev 89)
@@ -80,14 +80,6 @@
 source/ships/shpstaba.cpp
 source/tests/testmain.cpp
 source/tests/testdatapath.cpp
-source/twgui/twgui.cpp
-source/twgui/twhelpers.cpp
-source/twgui/twbuttontypes.cpp
-source/twgui/twbutton.cpp
-source/twgui/twmenuexamples.cpp
-source/twgui/twpopup.cpp
-source/twgui/twwindow.cpp
-source/twgui/utils.cpp
 source/libraries/lua/lib/ldblib.c
 source/libraries/lua/lib/lauxlib.c
 source/libraries/lua/lib/lbaselib.c



From youbastrd at sheep.berlios.de  Tue Oct 26 07:35:41 2004
From: youbastrd at sheep.berlios.de (Paul Forest at BerliOS)
Date: Tue, 26 Oct 2004 07:35:41 +0200
Subject: [Tw-light-svn] r90 - branches/multiplayer-branch
Message-ID: <200410260535.i9Q5Zfdh022629@sheep.berlios.de>

Author: youbastrd
Date: 2004-10-26 07:35:40 +0200 (Tue, 26 Oct 2004)
New Revision: 90

Added:
   branches/multiplayer-branch/TW-Light.dev
Log:
(MP branch) adding rudementary Dev C++ IDE support.  It's really just a front end to the makefile.

Added: branches/multiplayer-branch/TW-Light.dev
===================================================================
--- branches/multiplayer-branch/TW-Light.dev	2004-10-23 10:00:29 UTC (rev 89)
+++ branches/multiplayer-branch/TW-Light.dev	2004-10-26 05:35:40 UTC (rev 90)
@@ -0,0 +1,3329 @@
+[Project]
+FileName=TW-Light.dev
+Name=TW-Light
+UnitCount=328
+Type=1
+Ver=1
+ObjFiles=
+Includes=C:\projects\devcpp-tw-light\branches\multiplayer-branch\mingw-libs\include;C:\projects\devcpp-tw-light\branches\multiplayer-branch\mingw-libs\include\SDL;C:\projects\devcpp-tw-light\branches\multiplayer-branch\source;C:\projects\devcpp-tw-light\branches\multiplayer-branch\source\libraries;C:\projects\devcpp-tw-light\branches\multiplayer-branch\source\libraries\lua
+Libs=C:\projects\devcpp-tw-light\branches\multiplayer-branch\mingw-libs\lib
+PrivateResource=
+ResourceIncludes=
+MakeIncludes=makefile.mak
+Compiler=debug=1_@@_
+CppCompiler=-DTW_MAJOR_VERSION=\"$(PRODUCTVERSION)\" -DTW_SVNVERSION=\"$(SVNVERSION)\" debug=1_@@_
+Linker=-L mingw-libs/lib -lalleg -lwinmm -lws2_32 -lSDL -lSDLmain -lSDL_mixer_@@_
+IsCpp=1
+Icon=
+ExeOutput=
+ObjectOutput=
+OverrideOutput=0
+OverrideOutputName=TW-Light.exe
+HostApplication=
+Folders=ais,games,libraries,libraries/agup,libraries/jpgalleg,libraries/lua,libraries/lua/lib,libraries/raknet,melee,other,sc1ships,sc2ships,ships,tests,util
+CommandLine=
+UseCustomMakefile=1
+CustomMakefile=makefile
+IncludeVersionInfo=0
+SupportXPThemes=0
+CompilerSet=0
+CompilerSettings=0000010000000001000000
+
+[Unit1]
+FileName=source\ais.h
+CompileCpp=1
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit2]
+FileName=source\frame.h
+CompileCpp=1
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit3]
+FileName=source\gui.h
+CompileCpp=1
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit4]
+FileName=source\id.h
+CompileCpp=1
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit5]
+FileName=source\input.h
+CompileCpp=1
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit6]
+FileName=source\melee.h
+CompileCpp=1
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit7]
+FileName=source\scp.h
+CompileCpp=1
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit8]
+FileName=source\ship.h
+CompileCpp=1
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit9]
+FileName=source\doxygen.cpp
+CompileCpp=1
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit10]
+FileName=source\frame.cpp
+CompileCpp=1
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit11]
+FileName=source\gui.cpp
+CompileCpp=1
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit12]
+FileName=source\input.cpp
+CompileCpp=1
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit13]
+FileName=source\scp.cpp
+CompileCpp=1
+Folder=
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit14]
+FileName=source\ais\c_input.cpp
+CompileCpp=1
+Folder=ais
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit15]
+FileName=source\ais\c_other.cpp
+CompileCpp=1
+Folder=ais
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit16]
+FileName=source\ais\c_wussie.cpp
+CompileCpp=1
+Folder=ais
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit17]
+FileName=source\games\MultiplayerGame.cpp
+CompileCpp=1
+Folder=games
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit18]
+FileName=source\games\gflmelee.h
+CompileCpp=1
+Folder=games
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit19]
+FileName=source\games\ggob.h
+CompileCpp=1
+Folder=games
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit20]
+FileName=source\games\gmelee.h
+CompileCpp=1
+Folder=games
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit21]
+FileName=source\games\gup.h
+CompileCpp=1
+Folder=games
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit22]
+FileName=source\games\MultiplayerGame.h
+CompileCpp=1
+Folder=games
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit23]
+FileName=source\games\gdefender.cpp
+CompileCpp=1
+Folder=games
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit24]
+FileName=source\games\gflmelee.cpp
+CompileCpp=1
+Folder=games
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit25]
+FileName=source\games\ggob.cpp
+CompileCpp=1
+Folder=games
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit26]
+FileName=source\games\gmelee.cpp
+CompileCpp=1
+Folder=games
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit27]
+FileName=source\games\gup.cpp
+CompileCpp=1
+Folder=games
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit28]
+FileName=source\libraries\agup\awin95.h
+CompileCpp=1
+Folder=libraries/agup
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit29]
+FileName=source\libraries\agup\aalg.c
+CompileCpp=1
+Folder=libraries/agup
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit30]
+FileName=source\libraries\agup\aase.c
+CompileCpp=1
+Folder=libraries/agup
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit31]
+FileName=source\libraries\agup\abeos.c
+CompileCpp=1
+Folder=libraries/agup
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit32]
+FileName=source\libraries\agup\agtk.c
+CompileCpp=1
+Folder=libraries/agup
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit33]
+FileName=source\libraries\agup\agup.c
+CompileCpp=1
+Folder=libraries/agup
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit34]
+FileName=source\libraries\agup\ans.c
+CompileCpp=1
+Folder=libraries/agup
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit35]
+FileName=source\libraries\agup\aphoton.c
+CompileCpp=1
+Folder=libraries/agup
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit36]
+FileName=source\libraries\agup\awin95.c
+CompileCpp=1
+Folder=libraries/agup
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit37]
+FileName=source\libraries\agup\aalg.h
+CompileCpp=1
+Folder=libraries/agup
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit38]
+FileName=source\libraries\agup\aase.h
+CompileCpp=1
+Folder=libraries/agup
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit39]
+FileName=source\libraries\agup\abeos.h
+CompileCpp=1
+Folder=libraries/agup
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit40]
+FileName=source\libraries\agup\agtk.h
+CompileCpp=1
+Folder=libraries/agup
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit41]
+FileName=source\libraries\agup\agup.h
+CompileCpp=1
+Folder=libraries/agup
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit42]
+FileName=source\libraries\agup\agupitrn.h
+CompileCpp=1
+Folder=libraries/agup
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit43]
+FileName=source\libraries\agup\ans.h
+CompileCpp=1
+Folder=libraries/agup
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit44]
+FileName=source\libraries\agup\aphoton.h
+CompileCpp=1
+Folder=libraries/agup
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit45]
+FileName=source\libraries\jpgalleg\jpgalleg.h
+CompileCpp=1
+Folder=libraries/jpgalleg
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit46]
+FileName=source\libraries\jpgalleg\decode.c
+CompileCpp=1
+Folder=libraries/jpgalleg
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit47]
+FileName=source\libraries\jpgalleg\encode.c
+CompileCpp=1
+Folder=libraries/jpgalleg
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit48]
+FileName=source\libraries\jpgalleg\io.c
+CompileCpp=1
+Folder=libraries/jpgalleg
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit49]
+FileName=source\libraries\jpgalleg\jpgalleg.c
+CompileCpp=1
+Folder=libraries/jpgalleg
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit50]
+FileName=source\libraries\jpgalleg\internal.h
+CompileCpp=1
+Folder=libraries/jpgalleg
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit51]
+FileName=source\libraries\lua\lzio.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit52]
+FileName=source\libraries\lua\lapi.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit53]
+FileName=source\libraries\lua\lcode.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit54]
+FileName=source\libraries\lua\ldebug.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit55]
+FileName=source\libraries\lua\ldo.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit56]
+FileName=source\libraries\lua\ldump.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit57]
+FileName=source\libraries\lua\lfunc.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit58]
+FileName=source\libraries\lua\lgc.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit59]
+FileName=source\libraries\lua\llex.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit60]
+FileName=source\libraries\lua\lmem.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit61]
+FileName=source\libraries\lua\lobject.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit62]
+FileName=source\libraries\lua\lopcodes.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit63]
+FileName=source\libraries\lua\lparser.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit64]
+FileName=source\libraries\lua\lstate.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit65]
+FileName=source\libraries\lua\lstring.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit66]
+FileName=source\libraries\lua\ltable.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit67]
+FileName=source\libraries\lua\ltests.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit68]
+FileName=source\libraries\lua\ltm.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit69]
+FileName=source\libraries\lua\lundump.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit70]
+FileName=source\libraries\lua\lvm.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit71]
+FileName=source\libraries\lua\lzio.c
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit72]
+FileName=source\libraries\lua\lapi.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit73]
+FileName=source\libraries\lua\lauxlib.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit74]
+FileName=source\libraries\lua\lcode.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit75]
+FileName=source\libraries\lua\ldebug.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit76]
+FileName=source\libraries\lua\ldo.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit77]
+FileName=source\libraries\lua\lfunc.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit78]
+FileName=source\libraries\lua\lgc.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit79]
+FileName=source\libraries\lua\llex.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit80]
+FileName=source\libraries\lua\llimits.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit81]
+FileName=source\libraries\lua\lmem.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit82]
+FileName=source\libraries\lua\lobject.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit83]
+FileName=source\libraries\lua\lopcodes.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit84]
+FileName=source\libraries\lua\lparser.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit85]
+FileName=source\libraries\lua\lstate.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit86]
+FileName=source\libraries\lua\lstring.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit87]
+FileName=source\libraries\lua\ltable.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit88]
+FileName=source\libraries\lua\ltm.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit89]
+FileName=source\libraries\lua\lua.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit90]
+FileName=source\libraries\lua\lualib.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit91]
+FileName=source\libraries\lua\lundump.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit92]
+FileName=source\libraries\lua\lvm.h
+CompileCpp=1
+Folder=libraries/lua
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit93]
+FileName=source\libraries\lua\lib\ltablib.c
+CompileCpp=1
+Folder=libraries/lua/lib
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit94]
+FileName=source\libraries\lua\lib\lauxlib.c
+CompileCpp=1
+Folder=libraries/lua/lib
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit95]
+FileName=source\libraries\lua\lib\lbaselib.c
+CompileCpp=1
+Folder=libraries/lua/lib
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit96]
+FileName=source\libraries\lua\lib\ldblib.c
+CompileCpp=1
+Folder=libraries/lua/lib
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit97]
+FileName=source\libraries\lua\lib\liolib.c
+CompileCpp=1
+Folder=libraries/lua/lib
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit98]
+FileName=source\libraries\lua\lib\lmathlib.c
+CompileCpp=1
+Folder=libraries/lua/lib
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit99]
+FileName=source\libraries\lua\lib\loadlib.c
+CompileCpp=1
+Folder=libraries/lua/lib
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit100]
+FileName=source\libraries\lua\lib\lstrlib.c
+CompileCpp=1
+Folder=libraries/lua/lib
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit101]
+FileName=source\libraries\raknet\AES128.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit102]
+FileName=source\libraries\raknet\StringCompressor.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit103]
+FileName=source\libraries\raknet\ArrayList.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit104]
+FileName=source\libraries\raknet\AsynchronousFileIO.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit105]
+FileName=source\libraries\raknet\BigTypes.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit106]
+FileName=source\libraries\raknet\BinarySearchTree.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit107]
+FileName=source\libraries\raknet\BitStream.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit108]
+FileName=source\libraries\raknet\CheckSum.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit109]
+FileName=source\libraries\raknet\ClientContextStruct.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit110]
+FileName=source\libraries\raknet\DataBlockEncryptor.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit111]
+FileName=source\libraries\raknet\DistributedNetworkObject.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit112]
+FileName=source\libraries\raknet\DistributedNetworkObjectHeader.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit113]
+FileName=source\libraries\raknet\DistributedNetworkObjectManager.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit114]
+FileName=source\libraries\raknet\DistributedNetworkObjectStub.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit115]
+FileName=source\libraries\raknet\EncodeClassName.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit116]
+FileName=source\libraries\raknet\Euclid.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit117]
+FileName=source\libraries\raknet\ExtendedOverlappedPool.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit118]
+FileName=source\libraries\raknet\GetTime.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit119]
+FileName=source\libraries\raknet\HuffmanEncodingTree.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit120]
+FileName=source\libraries\raknet\HuffmanEncodingTreeFactory.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit121]
+FileName=source\libraries\raknet\HuffmanEncodingTreeNode.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit122]
+FileName=source\libraries\raknet\InternalPacket.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit123]
+FileName=source\libraries\raknet\InternalPacketPool.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit124]
+FileName=source\libraries\raknet\LinkedList.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit125]
+FileName=source\libraries\raknet\MPUInt.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit126]
+FileName=source\libraries\raknet\MTUSize.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit127]
+FileName=source\libraries\raknet\Multiplayer.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit128]
+FileName=source\libraries\raknet\NetworkObject.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit129]
+FileName=source\libraries\raknet\NetworkTypes.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit130]
+FileName=source\libraries\raknet\PacketEnumerations.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit131]
+FileName=source\libraries\raknet\PacketPool.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit132]
+FileName=source\libraries\raknet\PacketPriority.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit133]
+FileName=source\libraries\raknet\Queue.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit134]
+FileName=source\libraries\raknet\QueueLinkedList.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit135]
+FileName=source\libraries\raknet\RakClient.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit136]
+FileName=source\libraries\raknet\RakClientInterface.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit137]
+FileName=source\libraries\raknet\RakNetStatistics.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit138]
+FileName=source\libraries\raknet\RakNetworkFactory.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit139]
+FileName=source\libraries\raknet\RakPeer.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit140]
+FileName=source\libraries\raknet\RakPeerInterface.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit141]
+FileName=source\libraries\raknet\RakServer.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit142]
+FileName=source\libraries\raknet\RakServerInterface.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit143]
+FileName=source\libraries\raknet\Rand.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit144]
+FileName=source\libraries\raknet\ReliabilityLayer.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit145]
+FileName=source\libraries\raknet\RPCNode.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit146]
+FileName=source\libraries\raknet\RSA.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit147]
+FileName=source\libraries\raknet\RSACrypt.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit148]
+FileName=source\libraries\raknet\SHA1.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit149]
+FileName=source\libraries\raknet\SimpleMutex.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit150]
+FileName=source\libraries\raknet\SocketLayer.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit151]
+FileName=source\libraries\raknet\StringCompressor.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit152]
+FileName=source\libraries\raknet\Types.h
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit153]
+FileName=source\libraries\raknet\AES128.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit154]
+FileName=source\libraries\raknet\AsynchronousFileIO.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit155]
+FileName=source\libraries\raknet\BitStream.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit156]
+FileName=source\libraries\raknet\CheckSum.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit157]
+FileName=source\libraries\raknet\DataBlockEncryptor.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit158]
+FileName=source\libraries\raknet\DistributedNetworkObject.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit159]
+FileName=source\libraries\raknet\DistributedNetworkObjectManager.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit160]
+FileName=source\libraries\raknet\DistributedNetworkObjectStub.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit161]
+FileName=source\libraries\raknet\EncodeClassName.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit162]
+FileName=source\libraries\raknet\Euclid.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit163]
+FileName=source\libraries\raknet\ExtendedOverlappedPool.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit164]
+FileName=source\libraries\raknet\GetTime.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit165]
+FileName=source\libraries\raknet\HuffmanEncodingTree.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit166]
+FileName=source\libraries\raknet\HuffmanEncodingTreeFactory.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit167]
+FileName=source\libraries\raknet\InternalPacketPool.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit168]
+FileName=source\libraries\raknet\MPUInt.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit169]
+FileName=source\libraries\raknet\NetworkObject.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit170]
+FileName=source\libraries\raknet\NetworkTypes.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit171]
+FileName=source\libraries\raknet\PacketPool.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit172]
+FileName=source\libraries\raknet\RakClient.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit173]
+FileName=source\libraries\raknet\RakNetStatistics.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit174]
+FileName=source\libraries\raknet\RakNetworkFactory.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit175]
+FileName=source\libraries\raknet\RakPeer.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit176]
+FileName=source\libraries\raknet\RakServer.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit177]
+FileName=source\libraries\raknet\rand.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit178]
+FileName=source\libraries\raknet\ReliabilityLayer.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit179]
+FileName=source\libraries\raknet\RPCNode.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit180]
+FileName=source\libraries\raknet\RSA.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit181]
+FileName=source\libraries\raknet\SHA1.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit182]
+FileName=source\libraries\raknet\SimpleMutex.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit183]
+FileName=source\libraries\raknet\SocketLayer.cpp
+CompileCpp=1
+Folder=libraries/raknet
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit184]
+FileName=source\melee\PresenceRegistry.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit185]
+FileName=source\melee\manim.h
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit186]
+FileName=source\melee\mcbodies.h
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit187]
+FileName=source\melee\mcontrol.h
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit188]
+FileName=source\melee\mfleet.h
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit189]
+FileName=source\melee\mframe.h
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit190]
+FileName=source\melee\mgame.h
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit191]
+FileName=source\melee\mitems.h
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit192]
+FileName=source\melee\mlog.h
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit193]
+FileName=source\melee\mnet1.h
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit194]
+FileName=source\melee\moptions.h
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit195]
+FileName=source\melee\mship.h
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit196]
+FileName=source\melee\mshot.h
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit197]
+FileName=source\melee\mshppan.h
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit198]
+FileName=source\melee\mtarget.h
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit199]
+FileName=source\melee\MultiplayerTypes.h
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit200]
+FileName=source\melee\mview.h
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit201]
+FileName=source\melee\PresenceRegistry.h
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit202]
+FileName=source\melee\manim.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit203]
+FileName=source\melee\mcbodies.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit204]
+FileName=source\melee\mcontrol.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit205]
+FileName=source\melee\mfleet.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit206]
+FileName=source\melee\mframe.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit207]
+FileName=source\melee\mgame.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit208]
+FileName=source\melee\mhelpers.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit209]
+FileName=source\melee\mitems.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit210]
+FileName=source\melee\mlog.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit211]
+FileName=source\melee\mmath.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit212]
+FileName=source\melee\mnet1.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit213]
+FileName=source\melee\moptions.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit214]
+FileName=source\melee\mship.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit215]
+FileName=source\melee\mshot.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit216]
+FileName=source\melee\mshpdata.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit217]
+FileName=source\melee\mshppan.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit218]
+FileName=source\melee\msprite.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit219]
+FileName=source\melee\mtarget.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit220]
+FileName=source\melee\mview.cpp
+CompileCpp=1
+Folder=melee
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit221]
+FileName=source\other\vtarget.cpp
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit222]
+FileName=source\other\configrw.h
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit223]
+FileName=source\other\dialogs.h
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit224]
+FileName=source\other\fontmorph.h
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit225]
+FileName=source\other\nullphas.h
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit226]
+FileName=source\other\objanim.h
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit227]
+FileName=source\other\orbit.h
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit228]
+FileName=source\other\planet3d.h
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit229]
+FileName=source\other\radar.h
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit230]
+FileName=source\other\shippart.h
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit231]
+FileName=source\other\twconfig.h
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit232]
+FileName=source\other\vbodies.h
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit233]
+FileName=source\other\vtarget.h
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit234]
+FileName=source\other\configrw.cpp
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit235]
+FileName=source\other\dialogs.cpp
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit236]
+FileName=source\other\fontmorph.cpp
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit237]
+FileName=source\other\nullphas.cpp
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit238]
+FileName=source\other\objanim.cpp
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit239]
+FileName=source\other\orbit.cpp
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit240]
+FileName=source\other\planet3d.cpp
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit241]
+FileName=source\other\radar.cpp
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit242]
+FileName=source\other\shippart.cpp
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit243]
+FileName=source\other\twconfig.cpp
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit244]
+FileName=source\other\vbodies.cpp
+CompileCpp=1
+Folder=other
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit245]
+FileName=source\sc1ships\shpyehte.cpp
+CompileCpp=1
+Folder=sc1ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit246]
+FileName=source\sc1ships\sc1ships.h
+CompileCpp=1
+Folder=sc1ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit247]
+FileName=source\sc1ships\shpandgu.cpp
+CompileCpp=1
+Folder=sc1ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit248]
+FileName=source\sc1ships\shparisk.cpp
+CompileCpp=1
+Folder=sc1ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit249]
+FileName=source\sc1ships\shpchebr.cpp
+CompileCpp=1
+Folder=sc1ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit250]
+FileName=source\sc1ships\shpearcr.cpp
+CompileCpp=1
+Folder=sc1ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit251]
+FileName=source\sc1ships\shpilwav.cpp
+CompileCpp=1
+Folder=sc1ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit252]
+FileName=source\sc1ships\shpkzedr.cpp
+CompileCpp=1
+Folder=sc1ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit253]
+FileName=source\sc1ships\shpmmrxf.cpp
+CompileCpp=1
+Folder=sc1ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit254]
+FileName=source\sc1ships\shpmycpo.cpp
+CompileCpp=1
+Folder=sc1ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit255]
+FileName=source\sc1ships\shpshosc.cpp
+CompileCpp=1
+Folder=sc1ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit256]
+FileName=source\sc1ships\shpspael.cpp
+CompileCpp=1
+Folder=sc1ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit257]
+FileName=source\sc1ships\shpsyrpe.cpp
+CompileCpp=1
+Folder=sc1ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit258]
+FileName=source\sc1ships\shpumgdr.cpp
+CompileCpp=1
+Folder=sc1ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit259]
+FileName=source\sc1ships\shpvuxin.cpp
+CompileCpp=1
+Folder=sc1ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit260]
+FileName=source\sc2ships\shpzfpst.cpp
+CompileCpp=1
+Folder=sc2ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit261]
+FileName=source\sc2ships\sc2ships.h
+CompileCpp=1
+Folder=sc2ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit262]
+FileName=source\sc2ships\shpchmav.cpp
+CompileCpp=1
+Folder=sc2ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit263]
+FileName=source\sc2ships\shpdruma.cpp
+CompileCpp=1
+Folder=sc2ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit264]
+FileName=source\sc2ships\shpkohma.cpp
+CompileCpp=1
+Folder=sc2ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit265]
+FileName=source\sc2ships\shpmeltr.cpp
+CompileCpp=1
+Folder=sc2ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit266]
+FileName=source\sc2ships\shporzne.cpp
+CompileCpp=1
+Folder=sc2ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit267]
+FileName=source\sc2ships\shppkufu.cpp
+CompileCpp=1
+Folder=sc2ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit268]
+FileName=source\sc2ships\shpslypr.cpp
+CompileCpp=1
+Folder=sc2ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit269]
+FileName=source\sc2ships\shpsupbl.cpp
+CompileCpp=1
+Folder=sc2ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit270]
+FileName=source\sc2ships\shpthrto.cpp
+CompileCpp=1
+Folder=sc2ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit271]
+FileName=source\sc2ships\shputwju.cpp
+CompileCpp=1
+Folder=sc2ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit272]
+FileName=source\ships\shpzeksh.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit273]
+FileName=source\ships\shpilwsp.h
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit274]
+FileName=source\ships\shpaktgu.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit275]
+FileName=source\ships\shpalabc.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit276]
+FileName=source\ships\shpbahbu.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit277]
+FileName=source\ships\shpbipka.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit278]
+FileName=source\ships\shpbogce.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit279]
+FileName=source\ships\shpchoex.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit280]
+FileName=source\ships\shpconca.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit281]
+FileName=source\ships\shpconho.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit282]
+FileName=source\ships\shpdragr.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit283]
+FileName=source\ships\shpearc3.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit284]
+FileName=source\ships\shpforsh.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit285]
+FileName=source\ships\shpgarty.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit286]
+FileName=source\ships\shpilwsp.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit287]
+FileName=source\ships\shpkahbo.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit288]
+FileName=source\ships\shprogsq.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit289]
+FileName=source\ships\shpstaba.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit290]
+FileName=source\ships\shptauar.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit291]
+FileName=source\ships\shptauda.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit292]
+FileName=source\ships\shptaume.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit293]
+FileName=source\ships\shptausl.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit294]
+FileName=source\ships\shptaust.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit295]
+FileName=source\ships\shptauto.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit296]
+FileName=source\ships\shpwolmi.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit297]
+FileName=source\ships\shpyusra.cpp
+CompileCpp=1
+Folder=ships
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit298]
+FileName=source\tests\testdatapath.cpp
+CompileCpp=1
+Folder=tests
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit299]
+FileName=source\tests\testmain.cpp
+CompileCpp=1
+Folder=tests
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit300]
+FileName=source\util\vector2.cpp
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit301]
+FileName=source\util\aarot.c
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit302]
+FileName=source\util\aastr.c
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit303]
+FileName=source\util\aautil.c
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit304]
+FileName=source\util\errors_c.c
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit305]
+FileName=source\util\get_time.c
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit306]
+FileName=source\util\pmask.c
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit307]
+FileName=source\util\round.c
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit308]
+FileName=source\util\aastr.h
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit309]
+FileName=source\util\aautil.h
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit310]
+FileName=source\util\base.h
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit311]
+FileName=source\util\endian.h
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit312]
+FileName=source\util\errors.h
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit313]
+FileName=source\util\get_time.h
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit314]
+FileName=source\util\history.h
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit315]
+FileName=source\util\pmask.h
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit316]
+FileName=source\util\random.h
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit317]
+FileName=source\util\round.h
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit318]
+FileName=source\util\sound.h
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit319]
+FileName=source\util\types.h
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit320]
+FileName=source\util\vector2.h
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit321]
+FileName=source\util\base.cpp
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit322]
+FileName=source\util\endian.cpp
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit323]
+FileName=source\util\errors.cpp
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit324]
+FileName=source\util\history.cpp
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit325]
+FileName=source\util\random.cpp
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit326]
+FileName=source\util\sound.cpp
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit327]
+FileName=source\util\types.cpp
+CompileCpp=1
+Folder=util
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit328]
+FileName=source\libraries\agup\abitmap.c
+CompileCpp=1
+Folder=libraries/agup
+Compile=1
+Link=1
+Priority=1001
+OverrideBuildCmd=0
+BuildCmd=
+
+[VersionInfo]
+Major=0
+Minor=1
+Release=1
+Build=1
+LanguageID=1033
+CharsetID=1252
+CompanyName=
+FileVersion=
+FileDescription=Developed using the Dev-C++ IDE
+InternalName=
+LegalCopyright=
+LegalTrademarks=
+OriginalFilename=
+ProductName=
+ProductVersion=
+AutoIncBuildNr=0
+



From yurand at sheep.berlios.de  Thu Oct 28 19:52:49 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Thu, 28 Oct 2004 19:52:49 +0200
Subject: [Tw-light-svn] r91 - in trunk: . source source/melee web
Message-ID: <200410281752.i9SHqnhQ019055@sheep.berlios.de>

Author: yurand
Date: 2004-10-28 19:52:48 +0200 (Thu, 28 Oct 2004)
New Revision: 91

Modified:
   trunk/makefile
   trunk/source/gui.cpp
   trunk/source/gui.h
   trunk/source/id.h
   trunk/source/input.cpp
   trunk/source/input.h
   trunk/source/melee/manim.cpp
   trunk/source/melee/manim.h
   trunk/source/melee/mcbodies.cpp
   trunk/source/melee/mcbodies.h
   trunk/source/melee/mcontrol.cpp
   trunk/source/melee/mcontrol.h
   trunk/source/melee/mfleet.cpp
   trunk/source/melee/mfleet.h
   trunk/source/melee/mframe.cpp
   trunk/source/melee/mframe.h
   trunk/source/melee/mgame.cpp
   trunk/source/melee/mgame.h
   trunk/source/melee/mhelpers.cpp
   trunk/source/melee/mitems.cpp
   trunk/source/melee/mitems.h
   trunk/source/melee/mlog.cpp
   trunk/source/melee/mlog.h
   trunk/source/melee/mmain.cpp
   trunk/source/melee/mmain.h
   trunk/source/melee/mmath.cpp
   trunk/source/melee/mnet1.cpp
   trunk/source/melee/mnet1.h
   trunk/source/melee/moptions.cpp
   trunk/source/melee/moptions.h
   trunk/source/melee/mship.cpp
   trunk/source/melee/mship.h
   trunk/web/style.css
   trunk/web/update.sh
Log:
Issue #23


Modified: trunk/makefile
===================================================================
--- trunk/makefile	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/makefile	2004-10-28 17:52:48 UTC (rev 91)
@@ -23,7 +23,7 @@
 
 PRODUCTVERSION = 0.3
 
-SVNVERSION = ${shell svnversion .}
+SVNVERSION := ${shell svnversion .}
 
 CC = gcc
 CX = g++
@@ -72,7 +72,7 @@
 VPATH = tests source source/libraries/agup source/ais source/games \
         source/melee source/tests \
         source/other source/ships source/sc1ships source/sc2ships \
-        source/twgui source/util source/libraries/alogg \
+        source/util source/libraries/alogg \
         source/libraries/jpgalleg source/libraries/jgmod source/libraries/cppunit \
         source/libraries/raknet source/libraries/lua source/libraries/lua/lib
 

Modified: trunk/source/gui.cpp
===================================================================
--- trunk/source/gui.cpp	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/gui.cpp	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: gui.cpp,v 1.2 2004/08/03 11:37:22 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/gui.h
===================================================================
--- trunk/source/gui.h	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/gui.h	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: gui.h,v 1.1.1.1 2004/08/01 10:21:18 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/id.h
===================================================================
--- trunk/source/id.h	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/id.h	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: id.h,v 1.1.1.1 2004/08/01 10:21:18 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/input.cpp
===================================================================
--- trunk/source/input.cpp	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/input.cpp	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: input.cpp,v 1.1.1.1 2004/08/01 10:21:19 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/input.h
===================================================================
--- trunk/source/input.h	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/input.h	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: input.h,v 1.1.1.1 2004/08/01 10:21:18 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/manim.cpp
===================================================================
--- trunk/source/melee/manim.cpp	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/manim.cpp	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: manim.cpp,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/manim.h
===================================================================
--- trunk/source/melee/manim.h	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/manim.h	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: manim.h,v 1.2 2004/08/07 12:33:53 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mcbodies.cpp
===================================================================
--- trunk/source/melee/mcbodies.cpp	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mcbodies.cpp	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mcbodies.cpp,v 1.2 2004/08/07 12:33:53 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mcbodies.h
===================================================================
--- trunk/source/melee/mcbodies.h	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mcbodies.h	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mcbodies.h,v 1.2 2004/08/07 12:33:53 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mcontrol.cpp
===================================================================
--- trunk/source/melee/mcontrol.cpp	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mcontrol.cpp	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mcontrol.cpp,v 1.2 2004/08/03 11:37:22 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mcontrol.h
===================================================================
--- trunk/source/melee/mcontrol.h	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mcontrol.h	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mcontrol.h,v 1.2 2004/08/03 11:37:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mfleet.cpp
===================================================================
--- trunk/source/melee/mfleet.cpp	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mfleet.cpp	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mfleet.cpp,v 1.3 2004/08/08 17:36:05 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mfleet.h
===================================================================
--- trunk/source/melee/mfleet.h	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mfleet.h	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mfleet.h,v 1.1.1.1 2004/08/01 10:21:22 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mframe.cpp
===================================================================
--- trunk/source/melee/mframe.cpp	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mframe.cpp	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mframe.cpp,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mframe.h
===================================================================
--- trunk/source/melee/mframe.h	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mframe.h	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mframe.h,v 1.2 2004/08/07 12:33:53 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mgame.cpp
===================================================================
--- trunk/source/melee/mgame.cpp	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mgame.cpp	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,4 +1,3 @@
-/* $Id: mgame.cpp,v 1.5 2004/08/08 17:36:06 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
                     http://tw-light.berlios.de/

Modified: trunk/source/melee/mgame.h
===================================================================
--- trunk/source/melee/mgame.h	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mgame.h	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mgame.h,v 1.1.1.1 2004/08/01 10:21:22 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mhelpers.cpp
===================================================================
--- trunk/source/melee/mhelpers.cpp	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mhelpers.cpp	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mhelpers.cpp,v 1.2 2004/08/03 11:37:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mitems.cpp
===================================================================
--- trunk/source/melee/mitems.cpp	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mitems.cpp	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mitems.cpp,v 1.1.1.1 2004/08/01 10:21:22 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mitems.h
===================================================================
--- trunk/source/melee/mitems.h	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mitems.h	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mitems.h,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mlog.cpp
===================================================================
--- trunk/source/melee/mlog.cpp	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mlog.cpp	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mlog.cpp,v 1.2 2004/08/03 07:08:55 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mlog.h
===================================================================
--- trunk/source/melee/mlog.h	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mlog.h	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mlog.h,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mmain.cpp
===================================================================
--- trunk/source/melee/mmain.cpp	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mmain.cpp	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mmain.cpp,v 1.3 2004/08/08 17:36:06 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mmain.h
===================================================================
--- trunk/source/melee/mmain.h	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mmain.h	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mmain.h,v 1.1.1.1 2004/08/01 10:21:22 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mmath.cpp
===================================================================
--- trunk/source/melee/mmath.cpp	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mmath.cpp	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mmath.cpp,v 1.2 2004/08/05 21:06:38 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mnet1.cpp
===================================================================
--- trunk/source/melee/mnet1.cpp	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mnet1.cpp	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mnet1.cpp,v 1.2 2004/08/03 07:08:55 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mnet1.h
===================================================================
--- trunk/source/melee/mnet1.h	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mnet1.h	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mnet1.h,v 1.2 2004/08/03 07:08:55 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/moptions.cpp
===================================================================
--- trunk/source/melee/moptions.cpp	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/moptions.cpp	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: moptions.cpp,v 1.3 2004/08/03 11:37:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/moptions.h
===================================================================
--- trunk/source/melee/moptions.h	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/moptions.h	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: moptions.h,v 1.1 2004/08/03 22:17:54 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/melee/mship.cpp
===================================================================
--- trunk/source/melee/mship.cpp	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mship.cpp	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,4 +1,3 @@
-/* $Id: mship.cpp,v 1.2 2004/08/08 17:36:06 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
                     http://tw-light.berlios.de/

Modified: trunk/source/melee/mship.h
===================================================================
--- trunk/source/melee/mship.h	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/source/melee/mship.h	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,7 +1,6 @@
-/* $Id: mship.h,v 1.2 2004/08/07 12:33:54 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/web/style.css
===================================================================
--- trunk/web/style.css	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/web/style.css	2004-10-28 17:52:48 UTC (rev 91)
@@ -45,26 +45,26 @@
 h2 {
   color: white;
   background-color: gray;
-  border-top: 2px solid gray;
-  border-left: 2px solid gray;
-  border-right: 2px solid gray;
-  border-bottom: 2px solid gray;    
-  padding: 0px 0px 0px 2px;
+  border-top: 1px solid gray;
+  border-left: 1px solid gray;
+  border-right: 1px solid gray;
+  border-bottom: 1px solid gray;    
+  padding: 0px 0px 0px 1px;
 }
 
 h3 {
   color: white;
   background-color: #001C36; 
-  border-top: 2px solid gray;
-  border-left: 2px solid gray;
-  border-right: 2px solid gray;
-  border-bottom: 2px solid gray;    
-  padding: 0px 0px 0px 2px;
+  border-top: 1px solid gray;
+  border-left: 1px solid gray;
+  border-right: 1px solid gray;
+  border-bottom: 1px solid gray;    
+  padding: 0px 0px 0px 1px;
 
 }
 
 h4 {
   color: white;
   background-color: transparent;  
-  padding: 0px 0px 0px 2px;
+  padding: 0px 0px 0px 1px;
 }

Modified: trunk/web/update.sh
===================================================================
--- trunk/web/update.sh	2004-10-26 05:35:40 UTC (rev 90)
+++ trunk/web/update.sh	2004-10-28 17:52:48 UTC (rev 91)
@@ -1,2 +1,2 @@
 #!/bin/bash
-pscp header.inc footer.inc *.php yurand at shell.berlios.de:/home/groups/tw-light/htdocs
\ No newline at end of file
+pscp style.css yurand at shell.berlios.de:/home/groups/tw-light/htdocs
\ No newline at end of file



From yurand at sheep.berlios.de  Thu Oct 28 19:58:19 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Thu, 28 Oct 2004 19:58:19 +0200
Subject: [Tw-light-svn] r92 - trunk/source
Message-ID: <200410281758.i9SHwJRZ019274@sheep.berlios.de>

Author: yurand
Date: 2004-10-28 19:58:18 +0200 (Thu, 28 Oct 2004)
New Revision: 92

Modified:
   trunk/source/scp.cpp
Log:
Issue #23 Doesn't compile under linux


Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2004-10-28 17:52:48 UTC (rev 91)
+++ trunk/source/scp.cpp	2004-10-28 17:58:18 UTC (rev 92)
@@ -19,6 +19,7 @@
 #include <time.h>
 #include <string>
 #include <errno.h>
+#include <ctype.h>
 
 #include "util/sound.h"
 



From yurand at sheep.berlios.de  Sun Oct 31 12:05:06 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 31 Oct 2004 12:05:06 +0100
Subject: [Tw-light-svn] r93 - in trunk: . source source/ais source/games source/melee source/other
Message-ID: <200410311105.i9VB56H4030647@sheep.berlios.de>

Author: yurand
Date: 2004-10-31 12:05:05 +0100 (Sun, 31 Oct 2004)
New Revision: 93

Added:
   trunk/source/games/glegacies.cpp
Modified:
   trunk/source/ais.h
   trunk/source/ais/c_input.cpp
   trunk/source/melee/mitems.h
   trunk/source/melee/mship.h
   trunk/source/other/dialogs.cpp
   trunk/source/other/dialogs.h
   trunk/sources.lst
Log:
Added chat key


Modified: trunk/source/ais/c_input.cpp
===================================================================
--- trunk/source/ais/c_input.cpp	2004-10-28 17:58:18 UTC (rev 92)
+++ trunk/source/ais/c_input.cpp	2004-10-31 11:05:05 UTC (rev 93)
@@ -178,22 +178,18 @@
 {
   STACKTRACE;
   tw_set_config_file (inifile);
-  thrust  = get_config_int(inisection, "Thrust",      0);
-  back    = get_config_int(inisection, "Backwards",   0);
-  left    = get_config_int(inisection, "Left",        0);
-  right   = get_config_int(inisection, "Right",       0);
-  fire    = get_config_int(inisection, "Fire",        0);
-  altfire = get_config_int(inisection, "AltFire",     0);
-  special = get_config_int(inisection, "Special",     0);
-  next    = get_config_int(inisection, "Next_Target", 0);
-  prev    = get_config_int(inisection, "Prev_Target", 0);
+  thrust  = get_config_int(inisection, "Thrust",         0);
+  back    = get_config_int(inisection, "Backwards",      0);
+  left    = get_config_int(inisection, "Left",           0);
+  right   = get_config_int(inisection, "Right",          0);
+  fire    = get_config_int(inisection, "Fire",           0);
+  altfire = get_config_int(inisection, "AltFire",        0);
+  special = get_config_int(inisection, "Special",        0);
+  next    = get_config_int(inisection, "Next_Target",    0);
+  prev    = get_config_int(inisection, "Prev_Target",    0);
   closest = get_config_int(inisection, "Closest_Target", 0);
-  extra1  = get_config_int(inisection, "Extra1", 0);
-  extra2  = get_config_int(inisection, "Extra2", 0);
-  extra3  = get_config_int(inisection, "Extra3", 0);
-  extra4  = get_config_int(inisection, "Extra4", 0);
-  extra5  = get_config_int(inisection, "Extra5", 0);
-  suicide = get_config_int(inisection, "Extra6", 0);
+  chat    = get_config_int(inisection, "Chat",           0);
+  suicide = get_config_int(inisection, "Suicide",        0);
   return;
 }
 
@@ -215,12 +211,8 @@
   set_config_int(inisection, "Next_Target",    next);
   set_config_int(inisection, "Prev_Target",    prev);
   set_config_int(inisection, "Closest_Target", closest);
-  set_config_int(inisection, "Extra1", extra1);
-  set_config_int(inisection, "Extra2", extra2);
-  set_config_int(inisection, "Extra3", extra3);
-  set_config_int(inisection, "Extra4", extra4);
-  set_config_int(inisection, "Extra5", extra5);
-  set_config_int(inisection, "Extra6", suicide);
+  set_config_int(inisection, "Chat",           chat);
+  set_config_int(inisection, "Suicide",        suicide);
   return;
 }
 
@@ -246,11 +238,7 @@
   if (key_pressed(next))    r |= keyflag::next;
   if (key_pressed(prev))    r |= keyflag::prev;
   if (key_pressed(closest)) r |= keyflag::closest;
-  if (key_pressed(extra1))  r |= keyflag::extra1;
-  if (key_pressed(extra2))  r |= keyflag::extra2;
-  if (key_pressed(extra3))  r |= keyflag::extra3;
-  if (key_pressed(extra4))  r |= keyflag::extra4;
-  if (key_pressed(extra5))  r |= keyflag::extra5;
+  if (key_pressed(chat))    r |= keyflag::chat;
   if (key_pressed(suicide)) r |= keyflag::suicide;
   return r;
 }
@@ -315,6 +303,7 @@
   key_to_description(next, desc);   sprintf ( line, "  Next Target: %s\n", desc);strcat(text, line);
   key_to_description(prev, desc);   sprintf ( line, "  Previous Target: %s\n", desc);strcat(text, line);
   key_to_description(closest, desc);sprintf ( line, "  Closest: %s\n", desc);strcat(text, line);
+  key_to_description(chat, desc);   sprintf ( line, "  Chat: %s\n", desc);strcat(text, line);
   key_to_description(suicide, desc);sprintf ( line, "  Suicide: %s\n", desc);strcat(text, line);
 }
 
@@ -365,22 +354,11 @@
       key_to_description ( closest, s );
       
       s = dialog_string[index]; index += 1;
-      s += sprintf ( s, "Extra1: ");
-      key_to_description ( extra1, s );
+      s += sprintf ( s, "Chat:           ");
+      key_to_description ( chat, s );
+
       s = dialog_string[index]; index += 1;
-      s += sprintf ( s, "Extra2: ");
-      key_to_description ( extra2, s );
-      s = dialog_string[index]; index += 1;
-      s += sprintf ( s, "Extra3: ");
-      key_to_description ( extra3, s );
-      s = dialog_string[index]; index += 1;
-      s += sprintf ( s, "Extra4: ");
-      key_to_description ( extra4, s );
-      s = dialog_string[index]; index += 1;
-      s += sprintf ( s, "Extra5: ");
-      key_to_description ( extra5, s );
-      s = dialog_string[index]; index += 1;
-      s += sprintf ( s, "Suicide: ");
+      s += sprintf ( s, "Suicide:        ");
       key_to_description ( suicide, s );
       
       s = dialog_string[index]; index += 1;
@@ -422,12 +400,8 @@
 	case 8:  next    = t; break;
 	case 9:  prev    = t; break;
 	case 10: closest = t; break;
-	case 11: extra1 = t; break;
-	case 12: extra2 = t; break;
-	case 13: extra3 = t; break;
-	case 14: extra4 = t; break;
-	case 15: extra5 = t; break;
-	case 16: suicide = t; break;
+	case 11: chat = t; break;
+	case 12: suicide = t; break;
 	case KEY_DIALOG_OK:  save("scp.ini", getDescription()); return;
 	case KEY_DIALOG_CANCEL: load("scp.ini", getDescription()); return;
 	case KEY_DIALOG_CALIBRATE: calibrate_joysticks(); break;

Modified: trunk/source/ais.h
===================================================================
--- trunk/source/ais.h	2004-10-28 17:58:18 UTC (rev 92)
+++ trunk/source/ais.h	2004-10-31 11:05:05 UTC (rev 93)
@@ -39,7 +39,7 @@
   int next;
   int prev;
   int closest;
-  int extra1, extra2, extra3, extra4, extra5;
+  int chat;
   int suicide;
  public:
   virtual void load(const char* inifile, const char* inisection);

Added: trunk/source/games/glegacies.cpp
===================================================================
--- trunk/source/games/glegacies.cpp	2004-10-28 17:58:18 UTC (rev 92)
+++ trunk/source/games/glegacies.cpp	2004-10-31 11:05:05 UTC (rev 93)
@@ -0,0 +1,42 @@
+/*
+This file is part of "TW-Light" 
+                    http://tw-light.berlios.de/
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+
+#include <stdio.h>   //standard io libary (needed for sprintf)
+#include <allegro.h> //allegro library header
+
+#include "melee.h"          //used by all TW source files.  well, mostly. 
+#include "melee/mgame.h"    //Game stuff
+#include "melee/mcbodies.h" //asteroids & planets
+#include "melee/mship.h"    //ships
+#include "melee/mshot.h"   //shots, missiles, lasers
+#include "melee/mlog.h"     //networking / demo recording / demo playback
+#include "melee/mcontrol.h" //controllers & AIs
+#include "melee/mview.h"    //Views & messages
+#include "melee/mshppan.h"  //ship panels...
+
+#include "melee/mitems.h"  //ship panels...
+#include "melee/manim.h"  //ship panels...
+#include "scp.h"
+#include "other/dialogs.h"
+
+#include "gadventure.h"
+
+/// TW Legacies Adventure Game 
+///
+
+REGISTER_GAME ( LegaciesGame, "TW:Legacies" )
+

Modified: trunk/source/melee/mitems.h
===================================================================
--- trunk/source/melee/mitems.h	2004-10-28 17:58:18 UTC (rev 92)
+++ trunk/source/melee/mitems.h	2004-10-31 11:05:05 UTC (rev 93)
@@ -14,6 +14,9 @@
 GNU General Public License for more details.
 */
 
+#ifndef __TW_MITEMS_H__
+#define __TW_MITEMS_H__
+
 class HealthBar : public Presence
 {
 public:
@@ -61,3 +64,6 @@
 	virtual void calculate();
 	Orbiter ( SpaceSprite *sprite, SpaceLocation *orbit, double distance);
 };
+
+#endif
+

Modified: trunk/source/melee/mship.h
===================================================================
--- trunk/source/melee/mship.h	2004-10-28 17:58:18 UTC (rev 92)
+++ trunk/source/melee/mship.h	2004-10-31 11:05:05 UTC (rev 93)
@@ -35,12 +35,8 @@
     next       =	(1<<7),
     prev       =	(1<<8),
     closest    =	(1<<9),
-    extra1     =   (1<<10),
-    extra2     =   (1<<11),
-    extra3     =   (1<<12),
-    extra4     =   (1<<13),
-    extra5     =   (1<<14),
-    suicide    =   (1<<15),
+    chat       =        (1<<10),
+    suicide    =        (1<<11),
   };
 };
 

Modified: trunk/source/other/dialogs.cpp
===================================================================
--- trunk/source/other/dialogs.cpp	2004-10-28 17:58:18 UTC (rev 92)
+++ trunk/source/other/dialogs.cpp	2004-10-31 11:05:05 UTC (rev 93)
@@ -1,7 +1,7 @@
 /* $Id: dialogs.cpp,v 1.2 2004/08/03 21:05:00 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -52,14 +52,9 @@
   { my_d_button_proc,  60,   270,  500,  25,   255,  0,    0,    D_EXIT,  0,    0,    dialog_string[7], NULL, NULL },
   { my_d_button_proc,  60,   300,  500,  25,   255,  0,    0,    D_EXIT,  0,    0,    dialog_string[8], NULL, NULL },
   { my_d_button_proc,  60,   330,  500,  25,   255,  0,    0,    D_EXIT,  0,    0,    dialog_string[9], NULL, NULL },
-  { my_d_button_proc,  60,   360,  500,  15,   255,  0,    0,    D_EXIT,  0,    0,    dialog_string[10], NULL, NULL },
-  { my_d_button_proc,  60,   375,  500,  15,   255,  0,    0,    D_EXIT,  0,    0,    dialog_string[11], NULL, NULL },
-  { my_d_button_proc,  60,   390,  500,  15,   255,  0,    0,    D_EXIT,  0,    0,    dialog_string[12], NULL, NULL },
-  { my_d_button_proc,  60,   405,  500,  15,   255,  0,    0,    D_EXIT,  0,    0,    dialog_string[13], NULL, NULL },
-  { my_d_button_proc,  60,   420,  500,  15,   255,  0,    0,    D_EXIT,  0,    0,    dialog_string[14], NULL, NULL },
-  { my_d_button_proc,  60,   435,  500,  15,   255,  0,    0,    D_EXIT,  0,    0,    dialog_string[15], NULL, NULL },
-  { my_d_button_proc,  60,   450,  500,  15,   255,  0,    0,    D_EXIT,  0,    0,    dialog_string[16], NULL, NULL },
-  
+  { my_d_button_proc,  60,   360,  500,  25,   255,  0,    0,    D_EXIT,  0,    0,    dialog_string[10], NULL, NULL },
+  { my_d_button_proc,  60,   390,  500,  25,   255,  0,    0,    D_EXIT,  0,    0,    dialog_string[11], NULL, NULL },
+  { my_d_button_proc,  60,   420,  500,  25,   255,  0,    0,    D_EXIT,  0,    0,    dialog_string[12], NULL, NULL },
   { my_d_button_proc,  180,  20,   180,  25,   255,  0,    0,    D_EXIT,  0,    0,    (void*)"Accept Changes", NULL, NULL },
   { my_d_button_proc,     180,  50,   180,  25,   255,  0,    0,    D_EXIT,  0,    0,    (void*)"Cancel", NULL, NULL },
   { my_d_button_proc,  360,  35,   200,  25,   255,  0,    0,    D_EXIT,  0,    0,    (void*)"Calibrate Joysticks", NULL, NULL },

Modified: trunk/source/other/dialogs.h
===================================================================
--- trunk/source/other/dialogs.h	2004-10-28 17:58:18 UTC (rev 92)
+++ trunk/source/other/dialogs.h	2004-10-31 11:05:05 UTC (rev 93)
@@ -61,7 +61,7 @@
 enum 
 {
   KEY_DIALOG_MODIFY = 0,
-  KEY_DIALOG_OK = 17,
+  KEY_DIALOG_OK = 13,
   KEY_DIALOG_CANCEL,   
   KEY_DIALOG_CALIBRATE,
 };

Modified: trunk/sources.lst
===================================================================
--- trunk/sources.lst	2004-10-28 17:58:18 UTC (rev 92)
+++ trunk/sources.lst	2004-10-31 11:05:05 UTC (rev 93)
@@ -20,6 +20,7 @@
 source/games/ggob.cpp
 source/games/gflmelee.cpp
 source/games/gdefender.cpp
+source/games/glegacies.cpp
 source/melee/mlog.cpp
 source/melee/mitems.cpp
 source/melee/mnet1.cpp



