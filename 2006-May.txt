From yurand at berlios.de  Mon May  8 13:33:08 2006
From: yurand at berlios.de (yurand at BerliOS)
Date: Mon, 8 May 2006 13:33:08 +0200
Subject: [Tw-light-svn] r208 - in trunk: gamedata gamedata/images/stars gamedata/python source/generated source/melee
Message-ID: <200605081133.k48BX8l8022053@sheep.berlios.de>

Author: yurand
Date: 2006-05-08 13:32:42 +0200 (Mon, 08 May 2006)
New Revision: 208

Added:
   trunk/gamedata/images/stars/star001.bmp
   trunk/gamedata/images/stars/star002.bmp
   trunk/gamedata/images/stars/star003.bmp
   trunk/gamedata/images/stars/star004.bmp
   trunk/gamedata/images/stars/star005.bmp
   trunk/gamedata/images/stars/star006.bmp
   trunk/gamedata/images/stars/star007.bmp
   trunk/gamedata/images/stars/star008.bmp
   trunk/gamedata/images/stars/star009.bmp
   trunk/gamedata/images/stars/star010.bmp
   trunk/gamedata/images/stars/star011.bmp
   trunk/gamedata/images/stars/star012.bmp
   trunk/gamedata/images/stars/star013.bmp
   trunk/gamedata/images/stars/star014.bmp
   trunk/gamedata/images/stars/star015.bmp
   trunk/gamedata/images/stars/star016.bmp
   trunk/gamedata/images/stars/star017.bmp
   trunk/gamedata/images/stars/star018.bmp
   trunk/gamedata/images/stars/star019.bmp
Removed:
   trunk/gamedata/images/stars/STAR_S01_PCX.bmp
   trunk/gamedata/images/stars/STAR_S02_PCX.bmp
   trunk/gamedata/images/stars/STAR_S03_PCX.bmp
   trunk/gamedata/images/stars/star_00.bmp
   trunk/gamedata/images/stars/star_01.bmp
   trunk/gamedata/images/stars/star_02.bmp
   trunk/gamedata/images/stars/star_03.bmp
   trunk/gamedata/images/stars/star_04.bmp
   trunk/gamedata/images/stars/star_05.bmp
   trunk/gamedata/images/stars/star_06.bmp
   trunk/gamedata/images/stars/star_07.bmp
   trunk/gamedata/images/stars/star_08.bmp
   trunk/gamedata/images/stars/star_09.bmp
   trunk/gamedata/images/stars/star_10.bmp
   trunk/gamedata/images/stars/star_11.bmp
   trunk/gamedata/images/stars/star_12.bmp
   trunk/gamedata/images/stars/star_13.bmp
   trunk/gamedata/images/stars/star_14.bmp
   trunk/gamedata/images/stars/star_15.bmp
   trunk/gamedata/stars.dat
Modified:
   trunk/gamedata/python/tml.py
   trunk/source/generated/tml.py
   trunk/source/generated/tml_wrap.cpp
   trunk/source/melee/mcbodies.cpp
Log:
Removing duplicated images


Deleted: trunk/gamedata/images/stars/STAR_S01_PCX.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/STAR_S02_PCX.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/STAR_S03_PCX.bmp
===================================================================
(Binary files differ)

Added: trunk/gamedata/images/stars/star001.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star001.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star002.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star002.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star003.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star003.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star004.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star004.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star005.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star005.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star006.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star006.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star007.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star007.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star008.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star008.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star009.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star009.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star010.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star010.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star011.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star011.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star012.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star012.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star013.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star013.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star014.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star014.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star015.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star015.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star016.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star016.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star017.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star017.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star018.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star018.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star019.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star019.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Deleted: trunk/gamedata/images/stars/star_00.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_01.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_02.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_03.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_04.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_05.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_06.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_07.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_08.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_09.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_10.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_11.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_12.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_13.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_14.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_15.bmp
===================================================================
(Binary files differ)

Modified: trunk/gamedata/python/tml.py
===================================================================
--- trunk/gamedata/python/tml.py	2006-01-18 05:03:58 UTC (rev 207)
+++ trunk/gamedata/python/tml.py	2006-05-08 11:32:42 UTC (rev 208)
@@ -1,408 +1,353 @@
-# This file was created automatically by SWIG.
-# Don't modify this file, modify the SWIG interface instead.
-# This file is compatible with both classic and new-style classes.
-
-import _tml
-
-def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
-    if (name == "this"):
-        if isinstance(value, class_type):
-            self.__dict__[name] = value.this
-            if hasattr(value,"thisown"): self.__dict__["thisown"] = value.thisown
-            del value.thisown
-            return
-    method = class_type.__swig_setmethods__.get(name,None)
-    if method: return method(self,value)
-    if (not static) or hasattr(self,name) or (name == "thisown"):
-        self.__dict__[name] = value
-    else:
-        raise AttributeError("You cannot add attributes to %s" % self)
-
-def _swig_setattr(self,class_type,name,value):
-    return _swig_setattr_nondynamic(self,class_type,name,value,0)
-
-def _swig_getattr(self,class_type,name):
-    method = class_type.__swig_getmethods__.get(name,None)
-    if method: return method(self)
-    raise AttributeError,name
-
-import types
-try:
-    _object = types.ObjectType
-    _newclass = 1
-except AttributeError:
-    class _object : pass
-    _newclass = 0
-del types
-
-
-class GameAction(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, GameAction, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, GameAction, name)
-    def __repr__(self):
-        return "<%s.%s; proxy of C++ GameAction instance at %s>" % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    __swig_getmethods__["clean"] = lambda x: _tml.GameAction_clean
-    if _newclass:clean = staticmethod(_tml.GameAction_clean)
-    __swig_getmethods__["add_system"] = lambda x: _tml.GameAction_add_system
-    if _newclass:add_system = staticmethod(_tml.GameAction_add_system)
-    __swig_getmethods__["add_planet"] = lambda x: _tml.GameAction_add_planet
-    if _newclass:add_planet = staticmethod(_tml.GameAction_add_planet)
-    __swig_getmethods__["add_orbiter_station"] = lambda x: _tml.GameAction_add_orbiter_station
-    if _newclass:add_orbiter_station = staticmethod(_tml.GameAction_add_orbiter_station)
-    __swig_getmethods__["add_asteroid"] = lambda x: _tml.GameAction_add_asteroid
-    if _newclass:add_asteroid = staticmethod(_tml.GameAction_add_asteroid)
-    __swig_getmethods__["add_player"] = lambda x: _tml.GameAction_add_player
-    if _newclass:add_player = staticmethod(_tml.GameAction_add_player)
-    __swig_getmethods__["add_ship"] = lambda x: _tml.GameAction_add_ship
-    if _newclass:add_ship = staticmethod(_tml.GameAction_add_ship)
-    __swig_getmethods__["get_string_flag"] = lambda x: _tml.GameAction_get_string_flag
-    if _newclass:get_string_flag = staticmethod(_tml.GameAction_get_string_flag)
-    __swig_getmethods__["save_flag"] = lambda x: _tml.GameAction_save_flag
-    if _newclass:save_flag = staticmethod(_tml.GameAction_save_flag)
-    __swig_getmethods__["get_double_flag"] = lambda x: _tml.GameAction_get_double_flag
-    if _newclass:get_double_flag = staticmethod(_tml.GameAction_get_double_flag)
-    __swig_getmethods__["get_player_ship_id"] = lambda x: _tml.GameAction_get_player_ship_id
-    if _newclass:get_player_ship_id = staticmethod(_tml.GameAction_get_player_ship_id)
-    __swig_getmethods__["get_player_star_system"] = lambda x: _tml.GameAction_get_player_star_system
-    if _newclass:get_player_star_system = staticmethod(_tml.GameAction_get_player_star_system)
-    __swig_getmethods__["set_target"] = lambda x: _tml.GameAction_set_target
-    if _newclass:set_target = staticmethod(_tml.GameAction_set_target)
-    __swig_getmethods__["disable_weapon"] = lambda x: _tml.GameAction_disable_weapon
-    if _newclass:disable_weapon = staticmethod(_tml.GameAction_disable_weapon)
-    __swig_getmethods__["enable_weapon"] = lambda x: _tml.GameAction_enable_weapon
-    if _newclass:enable_weapon = staticmethod(_tml.GameAction_enable_weapon)
-    __swig_getmethods__["go_to_point"] = lambda x: _tml.GameAction_go_to_point
-    if _newclass:go_to_point = staticmethod(_tml.GameAction_go_to_point)
-    __swig_getmethods__["go_to_location"] = lambda x: _tml.GameAction_go_to_location
-    if _newclass:go_to_location = staticmethod(_tml.GameAction_go_to_location)
-    __swig_getmethods__["guard_location"] = lambda x: _tml.GameAction_guard_location
-    if _newclass:guard_location = staticmethod(_tml.GameAction_guard_location)
-    __swig_getmethods__["guard_point"] = lambda x: _tml.GameAction_guard_point
-    if _newclass:guard_point = staticmethod(_tml.GameAction_guard_point)
-    __swig_getmethods__["set_ship_team"] = lambda x: _tml.GameAction_set_ship_team
-    if _newclass:set_ship_team = staticmethod(_tml.GameAction_set_ship_team)
-    __swig_getmethods__["get_enemy_team"] = lambda x: _tml.GameAction_get_enemy_team
-    if _newclass:get_enemy_team = staticmethod(_tml.GameAction_get_enemy_team)
-    __swig_getmethods__["get_player_team"] = lambda x: _tml.GameAction_get_player_team
-    if _newclass:get_player_team = staticmethod(_tml.GameAction_get_player_team)
-    __swig_getmethods__["remove_location"] = lambda x: _tml.GameAction_remove_location
-    if _newclass:remove_location = staticmethod(_tml.GameAction_remove_location)
-    __swig_getmethods__["set_crew"] = lambda x: _tml.GameAction_set_crew
-    if _newclass:set_crew = staticmethod(_tml.GameAction_set_crew)
-    __swig_getmethods__["get_location_pos_x"] = lambda x: _tml.GameAction_get_location_pos_x
-    if _newclass:get_location_pos_x = staticmethod(_tml.GameAction_get_location_pos_x)
-    __swig_getmethods__["get_location_pos_y"] = lambda x: _tml.GameAction_get_location_pos_y
-    if _newclass:get_location_pos_y = staticmethod(_tml.GameAction_get_location_pos_y)
-    __swig_getmethods__["exist"] = lambda x: _tml.GameAction_exist
-    if _newclass:exist = staticmethod(_tml.GameAction_exist)
-    __swig_getmethods__["end_game"] = lambda x: _tml.GameAction_end_game
-    if _newclass:end_game = staticmethod(_tml.GameAction_end_game)
-    __swig_getmethods__["scroll_text"] = lambda x: _tml.GameAction_scroll_text
-    if _newclass:scroll_text = staticmethod(_tml.GameAction_scroll_text)
-    __swig_getmethods__["print_message"] = lambda x: _tml.GameAction_print_message
-    if _newclass:print_message = staticmethod(_tml.GameAction_print_message)
-    __swig_getmethods__["set_camera_mode"] = lambda x: _tml.GameAction_set_camera_mode
-    if _newclass:set_camera_mode = staticmethod(_tml.GameAction_set_camera_mode)
-    def __init__(self, *args):
-        _swig_setattr(self, GameAction, 'this', _tml.new_GameAction(*args))
-        _swig_setattr(self, GameAction, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_GameAction):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class GameActionPtr(GameAction):
-    def __init__(self, this):
-        _swig_setattr(self, GameAction, 'this', this)
-        if not hasattr(self,"thisown"): _swig_setattr(self, GameAction, 'thisown', 0)
-        _swig_setattr(self, GameAction,self.__class__,GameAction)
-_tml.GameAction_swigregister(GameActionPtr)
-
-GameAction_clean = _tml.GameAction_clean
-
-GameAction_add_system = _tml.GameAction_add_system
-
-GameAction_add_planet = _tml.GameAction_add_planet
-
-GameAction_add_orbiter_station = _tml.GameAction_add_orbiter_station
-
-GameAction_add_asteroid = _tml.GameAction_add_asteroid
-
-GameAction_add_player = _tml.GameAction_add_player
-
-GameAction_add_ship = _tml.GameAction_add_ship
-
-GameAction_get_string_flag = _tml.GameAction_get_string_flag
-
-GameAction_save_flag = _tml.GameAction_save_flag
-
-GameAction_get_double_flag = _tml.GameAction_get_double_flag
-
-GameAction_get_player_ship_id = _tml.GameAction_get_player_ship_id
-
-GameAction_get_player_star_system = _tml.GameAction_get_player_star_system
-
-GameAction_set_target = _tml.GameAction_set_target
-
-GameAction_disable_weapon = _tml.GameAction_disable_weapon
-
-GameAction_enable_weapon = _tml.GameAction_enable_weapon
-
-GameAction_go_to_point = _tml.GameAction_go_to_point
-
-GameAction_go_to_location = _tml.GameAction_go_to_location
-
-GameAction_guard_location = _tml.GameAction_guard_location
-
-GameAction_guard_point = _tml.GameAction_guard_point
-
-GameAction_set_ship_team = _tml.GameAction_set_ship_team
-
-GameAction_get_enemy_team = _tml.GameAction_get_enemy_team
-
-GameAction_get_player_team = _tml.GameAction_get_player_team
-
-GameAction_remove_location = _tml.GameAction_remove_location
-
-GameAction_set_crew = _tml.GameAction_set_crew
-
-GameAction_get_location_pos_x = _tml.GameAction_get_location_pos_x
-
-GameAction_get_location_pos_y = _tml.GameAction_get_location_pos_y
-
-GameAction_exist = _tml.GameAction_exist
-
-GameAction_end_game = _tml.GameAction_end_game
-
-GameAction_scroll_text = _tml.GameAction_scroll_text
-
-GameAction_print_message = _tml.GameAction_print_message
-
-GameAction_set_camera_mode = _tml.GameAction_set_camera_mode
-
-class DialogApi(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, DialogApi, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, DialogApi, name)
-    def __repr__(self):
-        return "<%s.%s; proxy of C++ DialogApi instance at %s>" % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    __swig_getmethods__["startDialog"] = lambda x: _tml.DialogApi_startDialog
-    if _newclass:startDialog = staticmethod(_tml.DialogApi_startDialog)
-    __swig_getmethods__["endDialog"] = lambda x: _tml.DialogApi_endDialog
-    if _newclass:endDialog = staticmethod(_tml.DialogApi_endDialog)
-    __swig_getmethods__["askPlayer"] = lambda x: _tml.DialogApi_askPlayer
-    if _newclass:askPlayer = staticmethod(_tml.DialogApi_askPlayer)
-    __swig_getmethods__["showText"] = lambda x: _tml.DialogApi_showText
-    if _newclass:showText = staticmethod(_tml.DialogApi_showText)
-    __swig_getmethods__["showAlienPicture"] = lambda x: _tml.DialogApi_showAlienPicture
-    if _newclass:showAlienPicture = staticmethod(_tml.DialogApi_showAlienPicture)
-    def __init__(self, *args):
-        _swig_setattr(self, DialogApi, 'this', _tml.new_DialogApi(*args))
-        _swig_setattr(self, DialogApi, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_DialogApi):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class DialogApiPtr(DialogApi):
-    def __init__(self, this):
-        _swig_setattr(self, DialogApi, 'this', this)
-        if not hasattr(self,"thisown"): _swig_setattr(self, DialogApi, 'thisown', 0)
-        _swig_setattr(self, DialogApi,self.__class__,DialogApi)
-_tml.DialogApi_swigregister(DialogApiPtr)
-
-DialogApi_startDialog = _tml.DialogApi_startDialog
-
-DialogApi_endDialog = _tml.DialogApi_endDialog
-
-DialogApi_askPlayer = _tml.DialogApi_askPlayer
-
-DialogApi_showText = _tml.DialogApi_showText
-
-DialogApi_showAlienPicture = _tml.DialogApi_showAlienPicture
-
-class GameConfig(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, GameConfig, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, GameConfig, name)
-    def __repr__(self):
-        return "<%s.%s; proxy of C++ GameConfig instance at %s>" % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    __swig_getmethods__["SetGameDirectory"] = lambda x: _tml.GameConfig_SetGameDirectory
-    if _newclass:SetGameDirectory = staticmethod(_tml.GameConfig_SetGameDirectory)
-    __swig_getmethods__["GetGameDirectory"] = lambda x: _tml.GameConfig_GetGameDirectory
-    if _newclass:GetGameDirectory = staticmethod(_tml.GameConfig_GetGameDirectory)
-    __swig_getmethods__["GetAbsolutePath"] = lambda x: _tml.GameConfig_GetAbsolutePath
-    if _newclass:GetAbsolutePath = staticmethod(_tml.GameConfig_GetAbsolutePath)
-    def __init__(self, *args):
-        _swig_setattr(self, GameConfig, 'this', _tml.new_GameConfig(*args))
-        _swig_setattr(self, GameConfig, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_GameConfig):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class GameConfigPtr(GameConfig):
-    def __init__(self, this):
-        _swig_setattr(self, GameConfig, 'this', this)
-        if not hasattr(self,"thisown"): _swig_setattr(self, GameConfig, 'thisown', 0)
-        _swig_setattr(self, GameConfig,self.__class__,GameConfig)
-_tml.GameConfig_swigregister(GameConfigPtr)
-
-GameConfig_SetGameDirectory = _tml.GameConfig_SetGameDirectory
-
-GameConfig_GetGameDirectory = _tml.GameConfig_GetGameDirectory
-
-GameConfig_GetAbsolutePath = _tml.GameConfig_GetAbsolutePath
-
-class EventManager(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, EventManager, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, EventManager, name)
-    def __repr__(self):
-        return "<%s.%s; proxy of C++ EventManager instance at %s>" % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    __swig_getmethods__["clean"] = lambda x: _tml.EventManager_clean
-    if _newclass:clean = staticmethod(_tml.EventManager_clean)
-    __swig_getmethods__["setSingleTimeEvent"] = lambda x: _tml.EventManager_setSingleTimeEvent
-    if _newclass:setSingleTimeEvent = staticmethod(_tml.EventManager_setSingleTimeEvent)
-    __swig_getmethods__["setRepeatableTimeEvent"] = lambda x: _tml.EventManager_setRepeatableTimeEvent
-    if _newclass:setRepeatableTimeEvent = staticmethod(_tml.EventManager_setRepeatableTimeEvent)
-    __swig_getmethods__["disableEvent"] = lambda x: _tml.EventManager_disableEvent
-    if _newclass:disableEvent = staticmethod(_tml.EventManager_disableEvent)
-    __swig_getmethods__["shipDeathById"] = lambda x: _tml.EventManager_shipDeathById
-    if _newclass:shipDeathById = staticmethod(_tml.EventManager_shipDeathById)
-    __swig_getmethods__["shipDeathByType"] = lambda x: _tml.EventManager_shipDeathByType
-    if _newclass:shipDeathByType = staticmethod(_tml.EventManager_shipDeathByType)
-    __swig_getmethods__["distanceMoreThen"] = lambda x: _tml.EventManager_distanceMoreThen
-    if _newclass:distanceMoreThen = staticmethod(_tml.EventManager_distanceMoreThen)
-    __swig_getmethods__["distanceLessThen"] = lambda x: _tml.EventManager_distanceLessThen
-    if _newclass:distanceLessThen = staticmethod(_tml.EventManager_distanceLessThen)
-    __swig_getmethods__["jumpToSystem"] = lambda x: _tml.EventManager_jumpToSystem
-    if _newclass:jumpToSystem = staticmethod(_tml.EventManager_jumpToSystem)
-    __swig_getmethods__["AddEventCondition"] = lambda x: _tml.EventManager_AddEventCondition
-    if _newclass:AddEventCondition = staticmethod(_tml.EventManager_AddEventCondition)
-    def __init__(self, *args):
-        _swig_setattr(self, EventManager, 'this', _tml.new_EventManager(*args))
-        _swig_setattr(self, EventManager, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_EventManager):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class EventManagerPtr(EventManager):
-    def __init__(self, this):
-        _swig_setattr(self, EventManager, 'this', this)
-        if not hasattr(self,"thisown"): _swig_setattr(self, EventManager, 'thisown', 0)
-        _swig_setattr(self, EventManager,self.__class__,EventManager)
-_tml.EventManager_swigregister(EventManagerPtr)
-
-EventManager_clean = _tml.EventManager_clean
-
-EventManager_setSingleTimeEvent = _tml.EventManager_setSingleTimeEvent
-
-EventManager_setRepeatableTimeEvent = _tml.EventManager_setRepeatableTimeEvent
-
-EventManager_disableEvent = _tml.EventManager_disableEvent
-
-EventManager_shipDeathById = _tml.EventManager_shipDeathById
-
-EventManager_shipDeathByType = _tml.EventManager_shipDeathByType
-
-EventManager_distanceMoreThen = _tml.EventManager_distanceMoreThen
-
-EventManager_distanceLessThen = _tml.EventManager_distanceLessThen
-
-EventManager_jumpToSystem = _tml.EventManager_jumpToSystem
-
-EventManager_AddEventCondition = _tml.EventManager_AddEventCondition
-
-class SoundSystem(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, SoundSystem, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, SoundSystem, name)
-    def __repr__(self):
-        return "<%s.%s; proxy of C++ SoundSystem instance at %s>" % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    def __init__(self, *args):
-        _swig_setattr(self, SoundSystem, 'this', _tml.new_SoundSystem(*args))
-        _swig_setattr(self, SoundSystem, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_SoundSystem):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-    def play_music(*args): return _tml.SoundSystem_play_music(*args)
-    def play_sound(*args): return _tml.SoundSystem_play_sound(*args)
-    def stop_sound(*args): return _tml.SoundSystem_stop_sound(*args)
-    def set_music_volume(*args): return _tml.SoundSystem_set_music_volume(*args)
-    def set_sound_volume(*args): return _tml.SoundSystem_set_sound_volume(*args)
-    def load_music_volume(*args): return _tml.SoundSystem_load_music_volume(*args)
-    def load_sound_volume(*args): return _tml.SoundSystem_load_sound_volume(*args)
-    def playing_music(*args): return _tml.SoundSystem_playing_music(*args)
-    def playing_music_file(*args): return _tml.SoundSystem_playing_music_file(*args)
-
-class SoundSystemPtr(SoundSystem):
-    def __init__(self, this):
-        _swig_setattr(self, SoundSystem, 'this', this)
-        if not hasattr(self,"thisown"): _swig_setattr(self, SoundSystem, 'thisown', 0)
-        _swig_setattr(self, SoundSystem,self.__class__,SoundSystem)
-_tml.SoundSystem_swigregister(SoundSystemPtr)
-
-
-GetSoundSystem = _tml.GetSoundSystem
-class vectorString(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorString, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, vectorString, name)
-    def __repr__(self):
-        return "<%s.%s; proxy of C++ std::vector<std::string > instance at %s>" % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    def empty(*args): return _tml.vectorString_empty(*args)
-    def size(*args): return _tml.vectorString_size(*args)
-    def clear(*args): return _tml.vectorString_clear(*args)
-    def swap(*args): return _tml.vectorString_swap(*args)
-    def get_allocator(*args): return _tml.vectorString_get_allocator(*args)
-    def pop_back(*args): return _tml.vectorString_pop_back(*args)
-    def __init__(self, *args):
-        _swig_setattr(self, vectorString, 'this', _tml.new_vectorString(*args))
-        _swig_setattr(self, vectorString, 'thisown', 1)
-    def push_back(*args): return _tml.vectorString_push_back(*args)
-    def front(*args): return _tml.vectorString_front(*args)
-    def back(*args): return _tml.vectorString_back(*args)
-    def assign(*args): return _tml.vectorString_assign(*args)
-    def resize(*args): return _tml.vectorString_resize(*args)
-    def reserve(*args): return _tml.vectorString_reserve(*args)
-    def capacity(*args): return _tml.vectorString_capacity(*args)
-    def __nonzero__(*args): return _tml.vectorString___nonzero__(*args)
-    def __len__(*args): return _tml.vectorString___len__(*args)
-    def pop(*args): return _tml.vectorString_pop(*args)
-    def __getslice__(*args): return _tml.vectorString___getslice__(*args)
-    def __setslice__(*args): return _tml.vectorString___setslice__(*args)
-    def __delslice__(*args): return _tml.vectorString___delslice__(*args)
-    def __delitem__(*args): return _tml.vectorString___delitem__(*args)
-    def __getitem__(*args): return _tml.vectorString___getitem__(*args)
-    def __setitem__(*args): return _tml.vectorString___setitem__(*args)
-    def append(*args): return _tml.vectorString_append(*args)
-    def __del__(self, destroy=_tml.delete_vectorString):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class vectorStringPtr(vectorString):
-    def __init__(self, this):
-        _swig_setattr(self, vectorString, 'this', this)
-        if not hasattr(self,"thisown"): _swig_setattr(self, vectorString, 'thisown', 0)
-        _swig_setattr(self, vectorString,self.__class__,vectorString)
-_tml.vectorString_swigregister(vectorStringPtr)
-cvar = _tml.cvar
-
-
+# This file was created automatically by SWIG 1.3.29.
+# Don't modify this file, modify the SWIG interface instead.
+# This file is compatible with both classic and new-style classes.
+
+import _tml
+import new
+new_instancemethod = new.instancemethod
+def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
+    if (name == "thisown"): return self.this.own(value)
+    if (name == "this"):
+        if type(value).__name__ == 'PySwigObject':
+            self.__dict__[name] = value
+            return
+    method = class_type.__swig_setmethods__.get(name,None)
+    if method: return method(self,value)
+    if (not static) or hasattr(self,name):
+        self.__dict__[name] = value
+    else:
+        raise AttributeError("You cannot add attributes to %s" % self)
+
+def _swig_setattr(self,class_type,name,value):
+    return _swig_setattr_nondynamic(self,class_type,name,value,0)
+
+def _swig_getattr(self,class_type,name):
+    if (name == "thisown"): return self.this.own()
+    method = class_type.__swig_getmethods__.get(name,None)
+    if method: return method(self)
+    raise AttributeError,name
+
+def _swig_repr(self):
+    try: strthis = "proxy of " + self.this.__repr__()
+    except: strthis = ""
+    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
+
+import types
+try:
+    _object = types.ObjectType
+    _newclass = 1
+except AttributeError:
+    class _object : pass
+    _newclass = 0
+del types
+
+
+class GameAction(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GameAction, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GameAction, name)
+    __repr__ = _swig_repr
+    __swig_getmethods__["clean"] = lambda x: _tml.GameAction_clean
+    if _newclass:clean = staticmethod(_tml.GameAction_clean)
+    __swig_getmethods__["add_system"] = lambda x: _tml.GameAction_add_system
+    if _newclass:add_system = staticmethod(_tml.GameAction_add_system)
+    __swig_getmethods__["add_planet"] = lambda x: _tml.GameAction_add_planet
+    if _newclass:add_planet = staticmethod(_tml.GameAction_add_planet)
+    __swig_getmethods__["add_orbiter_station"] = lambda x: _tml.GameAction_add_orbiter_station
+    if _newclass:add_orbiter_station = staticmethod(_tml.GameAction_add_orbiter_station)
+    __swig_getmethods__["add_asteroid"] = lambda x: _tml.GameAction_add_asteroid
+    if _newclass:add_asteroid = staticmethod(_tml.GameAction_add_asteroid)
+    __swig_getmethods__["add_player"] = lambda x: _tml.GameAction_add_player
+    if _newclass:add_player = staticmethod(_tml.GameAction_add_player)
+    __swig_getmethods__["add_ship"] = lambda x: _tml.GameAction_add_ship
+    if _newclass:add_ship = staticmethod(_tml.GameAction_add_ship)
+    __swig_getmethods__["get_string_flag"] = lambda x: _tml.GameAction_get_string_flag
+    if _newclass:get_string_flag = staticmethod(_tml.GameAction_get_string_flag)
+    __swig_getmethods__["save_flag"] = lambda x: _tml.GameAction_save_flag
+    if _newclass:save_flag = staticmethod(_tml.GameAction_save_flag)
+    __swig_getmethods__["get_double_flag"] = lambda x: _tml.GameAction_get_double_flag
+    if _newclass:get_double_flag = staticmethod(_tml.GameAction_get_double_flag)
+    __swig_getmethods__["get_player_ship_id"] = lambda x: _tml.GameAction_get_player_ship_id
+    if _newclass:get_player_ship_id = staticmethod(_tml.GameAction_get_player_ship_id)
+    __swig_getmethods__["get_player_star_system"] = lambda x: _tml.GameAction_get_player_star_system
+    if _newclass:get_player_star_system = staticmethod(_tml.GameAction_get_player_star_system)
+    __swig_getmethods__["set_target"] = lambda x: _tml.GameAction_set_target
+    if _newclass:set_target = staticmethod(_tml.GameAction_set_target)
+    __swig_getmethods__["disable_weapon"] = lambda x: _tml.GameAction_disable_weapon
+    if _newclass:disable_weapon = staticmethod(_tml.GameAction_disable_weapon)
+    __swig_getmethods__["enable_weapon"] = lambda x: _tml.GameAction_enable_weapon
+    if _newclass:enable_weapon = staticmethod(_tml.GameAction_enable_weapon)
+    __swig_getmethods__["go_to_point"] = lambda x: _tml.GameAction_go_to_point
+    if _newclass:go_to_point = staticmethod(_tml.GameAction_go_to_point)
+    __swig_getmethods__["go_to_location"] = lambda x: _tml.GameAction_go_to_location
+    if _newclass:go_to_location = staticmethod(_tml.GameAction_go_to_location)
+    __swig_getmethods__["guard_location"] = lambda x: _tml.GameAction_guard_location
+    if _newclass:guard_location = staticmethod(_tml.GameAction_guard_location)
+    __swig_getmethods__["guard_point"] = lambda x: _tml.GameAction_guard_point
+    if _newclass:guard_point = staticmethod(_tml.GameAction_guard_point)
+    __swig_getmethods__["set_ship_team"] = lambda x: _tml.GameAction_set_ship_team
+    if _newclass:set_ship_team = staticmethod(_tml.GameAction_set_ship_team)
+    __swig_getmethods__["get_enemy_team"] = lambda x: _tml.GameAction_get_enemy_team
+    if _newclass:get_enemy_team = staticmethod(_tml.GameAction_get_enemy_team)
+    __swig_getmethods__["get_player_team"] = lambda x: _tml.GameAction_get_player_team
+    if _newclass:get_player_team = staticmethod(_tml.GameAction_get_player_team)
+    __swig_getmethods__["remove_location"] = lambda x: _tml.GameAction_remove_location
+    if _newclass:remove_location = staticmethod(_tml.GameAction_remove_location)
+    __swig_getmethods__["set_crew"] = lambda x: _tml.GameAction_set_crew
+    if _newclass:set_crew = staticmethod(_tml.GameAction_set_crew)
+    __swig_getmethods__["get_location_pos_x"] = lambda x: _tml.GameAction_get_location_pos_x
+    if _newclass:get_location_pos_x = staticmethod(_tml.GameAction_get_location_pos_x)
+    __swig_getmethods__["get_location_pos_y"] = lambda x: _tml.GameAction_get_location_pos_y
+    if _newclass:get_location_pos_y = staticmethod(_tml.GameAction_get_location_pos_y)
+    __swig_getmethods__["exist"] = lambda x: _tml.GameAction_exist
+    if _newclass:exist = staticmethod(_tml.GameAction_exist)
+    __swig_getmethods__["end_game"] = lambda x: _tml.GameAction_end_game
+    if _newclass:end_game = staticmethod(_tml.GameAction_end_game)
+    __swig_getmethods__["scroll_text"] = lambda x: _tml.GameAction_scroll_text
+    if _newclass:scroll_text = staticmethod(_tml.GameAction_scroll_text)
+    __swig_getmethods__["print_message"] = lambda x: _tml.GameAction_print_message
+    if _newclass:print_message = staticmethod(_tml.GameAction_print_message)
+    __swig_getmethods__["set_camera_mode"] = lambda x: _tml.GameAction_set_camera_mode
+    if _newclass:set_camera_mode = staticmethod(_tml.GameAction_set_camera_mode)
+    def __init__(self, *args): 
+        this = _tml.new_GameAction(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_GameAction
+    __del__ = lambda self : None;
+GameAction_swigregister = _tml.GameAction_swigregister
+GameAction_swigregister(GameAction)
+GameAction_clean = _tml.GameAction_clean
+GameAction_add_system = _tml.GameAction_add_system
+GameAction_add_planet = _tml.GameAction_add_planet
+GameAction_add_orbiter_station = _tml.GameAction_add_orbiter_station
+GameAction_add_asteroid = _tml.GameAction_add_asteroid
+GameAction_add_player = _tml.GameAction_add_player
+GameAction_add_ship = _tml.GameAction_add_ship
+GameAction_get_string_flag = _tml.GameAction_get_string_flag
+GameAction_save_flag = _tml.GameAction_save_flag
+GameAction_get_double_flag = _tml.GameAction_get_double_flag
+GameAction_get_player_ship_id = _tml.GameAction_get_player_ship_id
+GameAction_get_player_star_system = _tml.GameAction_get_player_star_system
+GameAction_set_target = _tml.GameAction_set_target
+GameAction_disable_weapon = _tml.GameAction_disable_weapon
+GameAction_enable_weapon = _tml.GameAction_enable_weapon
+GameAction_go_to_point = _tml.GameAction_go_to_point
+GameAction_go_to_location = _tml.GameAction_go_to_location
+GameAction_guard_location = _tml.GameAction_guard_location
+GameAction_guard_point = _tml.GameAction_guard_point
+GameAction_set_ship_team = _tml.GameAction_set_ship_team
+GameAction_get_enemy_team = _tml.GameAction_get_enemy_team
+GameAction_get_player_team = _tml.GameAction_get_player_team
+GameAction_remove_location = _tml.GameAction_remove_location
+GameAction_set_crew = _tml.GameAction_set_crew
+GameAction_get_location_pos_x = _tml.GameAction_get_location_pos_x
+GameAction_get_location_pos_y = _tml.GameAction_get_location_pos_y
+GameAction_exist = _tml.GameAction_exist
+GameAction_end_game = _tml.GameAction_end_game
+GameAction_scroll_text = _tml.GameAction_scroll_text
+GameAction_print_message = _tml.GameAction_print_message
+GameAction_set_camera_mode = _tml.GameAction_set_camera_mode
+
+class DialogApi(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, DialogApi, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, DialogApi, name)
+    __repr__ = _swig_repr
+    __swig_getmethods__["startDialog"] = lambda x: _tml.DialogApi_startDialog
+    if _newclass:startDialog = staticmethod(_tml.DialogApi_startDialog)
+    __swig_getmethods__["endDialog"] = lambda x: _tml.DialogApi_endDialog
+    if _newclass:endDialog = staticmethod(_tml.DialogApi_endDialog)
+    __swig_getmethods__["askPlayer"] = lambda x: _tml.DialogApi_askPlayer
+    if _newclass:askPlayer = staticmethod(_tml.DialogApi_askPlayer)
+    __swig_getmethods__["showText"] = lambda x: _tml.DialogApi_showText
+    if _newclass:showText = staticmethod(_tml.DialogApi_showText)
+    __swig_getmethods__["showAlienPicture"] = lambda x: _tml.DialogApi_showAlienPicture
+    if _newclass:showAlienPicture = staticmethod(_tml.DialogApi_showAlienPicture)
+    def __init__(self, *args): 
+        this = _tml.new_DialogApi(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_DialogApi
+    __del__ = lambda self : None;
+DialogApi_swigregister = _tml.DialogApi_swigregister
+DialogApi_swigregister(DialogApi)
+DialogApi_startDialog = _tml.DialogApi_startDialog
+DialogApi_endDialog = _tml.DialogApi_endDialog
+DialogApi_askPlayer = _tml.DialogApi_askPlayer
+DialogApi_showText = _tml.DialogApi_showText
+DialogApi_showAlienPicture = _tml.DialogApi_showAlienPicture
+
+class GameConfig(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GameConfig, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GameConfig, name)
+    __repr__ = _swig_repr
+    __swig_getmethods__["SetGameDirectory"] = lambda x: _tml.GameConfig_SetGameDirectory
+    if _newclass:SetGameDirectory = staticmethod(_tml.GameConfig_SetGameDirectory)
+    __swig_getmethods__["GetGameDirectory"] = lambda x: _tml.GameConfig_GetGameDirectory
+    if _newclass:GetGameDirectory = staticmethod(_tml.GameConfig_GetGameDirectory)
+    __swig_getmethods__["GetAbsolutePath"] = lambda x: _tml.GameConfig_GetAbsolutePath
+    if _newclass:GetAbsolutePath = staticmethod(_tml.GameConfig_GetAbsolutePath)
+    def __init__(self, *args): 
+        this = _tml.new_GameConfig(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_GameConfig
+    __del__ = lambda self : None;
+GameConfig_swigregister = _tml.GameConfig_swigregister
+GameConfig_swigregister(GameConfig)
+GameConfig_SetGameDirectory = _tml.GameConfig_SetGameDirectory
+GameConfig_GetGameDirectory = _tml.GameConfig_GetGameDirectory
+GameConfig_GetAbsolutePath = _tml.GameConfig_GetAbsolutePath
+
+class EventManager(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, EventManager, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, EventManager, name)
+    __repr__ = _swig_repr
+    __swig_getmethods__["clean"] = lambda x: _tml.EventManager_clean
+    if _newclass:clean = staticmethod(_tml.EventManager_clean)
+    __swig_getmethods__["setSingleTimeEvent"] = lambda x: _tml.EventManager_setSingleTimeEvent
+    if _newclass:setSingleTimeEvent = staticmethod(_tml.EventManager_setSingleTimeEvent)
+    __swig_getmethods__["setRepeatableTimeEvent"] = lambda x: _tml.EventManager_setRepeatableTimeEvent
+    if _newclass:setRepeatableTimeEvent = staticmethod(_tml.EventManager_setRepeatableTimeEvent)
+    __swig_getmethods__["disableEvent"] = lambda x: _tml.EventManager_disableEvent
+    if _newclass:disableEvent = staticmethod(_tml.EventManager_disableEvent)
+    __swig_getmethods__["shipDeathById"] = lambda x: _tml.EventManager_shipDeathById
+    if _newclass:shipDeathById = staticmethod(_tml.EventManager_shipDeathById)
+    __swig_getmethods__["shipDeathByType"] = lambda x: _tml.EventManager_shipDeathByType
+    if _newclass:shipDeathByType = staticmethod(_tml.EventManager_shipDeathByType)
+    __swig_getmethods__["distanceMoreThen"] = lambda x: _tml.EventManager_distanceMoreThen
+    if _newclass:distanceMoreThen = staticmethod(_tml.EventManager_distanceMoreThen)
+    __swig_getmethods__["distanceLessThen"] = lambda x: _tml.EventManager_distanceLessThen
+    if _newclass:distanceLessThen = staticmethod(_tml.EventManager_distanceLessThen)
+    __swig_getmethods__["jumpToSystem"] = lambda x: _tml.EventManager_jumpToSystem
+    if _newclass:jumpToSystem = staticmethod(_tml.EventManager_jumpToSystem)
+    __swig_getmethods__["AddEventCondition"] = lambda x: _tml.EventManager_AddEventCondition
+    if _newclass:AddEventCondition = staticmethod(_tml.EventManager_AddEventCondition)
+    def __init__(self, *args): 
+        this = _tml.new_EventManager(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_EventManager
+    __del__ = lambda self : None;
+EventManager_swigregister = _tml.EventManager_swigregister
+EventManager_swigregister(EventManager)
+EventManager_clean = _tml.EventManager_clean
+EventManager_setSingleTimeEvent = _tml.EventManager_setSingleTimeEvent
+EventManager_setRepeatableTimeEvent = _tml.EventManager_setRepeatableTimeEvent
+EventManager_disableEvent = _tml.EventManager_disableEvent
+EventManager_shipDeathById = _tml.EventManager_shipDeathById
+EventManager_shipDeathByType = _tml.EventManager_shipDeathByType
+EventManager_distanceMoreThen = _tml.EventManager_distanceMoreThen
+EventManager_distanceLessThen = _tml.EventManager_distanceLessThen
+EventManager_jumpToSystem = _tml.EventManager_jumpToSystem
+EventManager_AddEventCondition = _tml.EventManager_AddEventCondition
+
+class SoundSystem(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, SoundSystem, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, SoundSystem, name)
+    __repr__ = _swig_repr
+    def __init__(self, *args): 
+        this = _tml.new_SoundSystem(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_SoundSystem
+    __del__ = lambda self : None;
+    def play_music(*args): return _tml.SoundSystem_play_music(*args)
+    def play_sound(*args): return _tml.SoundSystem_play_sound(*args)
+    def stop_sound(*args): return _tml.SoundSystem_stop_sound(*args)
+    def set_music_volume(*args): return _tml.SoundSystem_set_music_volume(*args)
+    def set_sound_volume(*args): return _tml.SoundSystem_set_sound_volume(*args)
+    def load_music_volume(*args): return _tml.SoundSystem_load_music_volume(*args)
+    def load_sound_volume(*args): return _tml.SoundSystem_load_sound_volume(*args)
+    def playing_music(*args): return _tml.SoundSystem_playing_music(*args)
+    def playing_music_file(*args): return _tml.SoundSystem_playing_music_file(*args)
+SoundSystem_swigregister = _tml.SoundSystem_swigregister
+SoundSystem_swigregister(SoundSystem)
+
+GetSoundSystem = _tml.GetSoundSystem
+class PySwigIterator(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, PySwigIterator, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, PySwigIterator, name)
+    def __init__(self): raise AttributeError, "No constructor defined"
+    __repr__ = _swig_repr
+    __swig_destroy__ = _tml.delete_PySwigIterator
+    __del__ = lambda self : None;
+    def value(*args): return _tml.PySwigIterator_value(*args)
+    def incr(*args): return _tml.PySwigIterator_incr(*args)
+    def decr(*args): return _tml.PySwigIterator_decr(*args)
+    def distance(*args): return _tml.PySwigIterator_distance(*args)
+    def equal(*args): return _tml.PySwigIterator_equal(*args)
+    def copy(*args): return _tml.PySwigIterator_copy(*args)
+    def next(*args): return _tml.PySwigIterator_next(*args)
+    def previous(*args): return _tml.PySwigIterator_previous(*args)
+    def advance(*args): return _tml.PySwigIterator_advance(*args)
+    def __eq__(*args): return _tml.PySwigIterator___eq__(*args)
+    def __ne__(*args): return _tml.PySwigIterator___ne__(*args)
+    def __iadd__(*args): return _tml.PySwigIterator___iadd__(*args)
+    def __isub__(*args): return _tml.PySwigIterator___isub__(*args)
+    def __add__(*args): return _tml.PySwigIterator___add__(*args)
+    def __sub__(*args): return _tml.PySwigIterator___sub__(*args)
+    def __iter__(self): return self
+PySwigIterator_swigregister = _tml.PySwigIterator_swigregister
+PySwigIterator_swigregister(PySwigIterator)
+cvar = _tml.cvar
+
+class vectorString(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorString, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, vectorString, name)
+    __repr__ = _swig_repr
+    def iterator(*args): return _tml.vectorString_iterator(*args)
+    def __iter__(self): return self.iterator()
+    def __nonzero__(*args): return _tml.vectorString___nonzero__(*args)
+    def __len__(*args): return _tml.vectorString___len__(*args)
+    def pop(*args): return _tml.vectorString_pop(*args)
+    def __getslice__(*args): return _tml.vectorString___getslice__(*args)
+    def __setslice__(*args): return _tml.vectorString___setslice__(*args)
+    def __delslice__(*args): return _tml.vectorString___delslice__(*args)
+    def __delitem__(*args): return _tml.vectorString___delitem__(*args)
+    def __getitem__(*args): return _tml.vectorString___getitem__(*args)
+    def __setitem__(*args): return _tml.vectorString___setitem__(*args)
+    def append(*args): return _tml.vectorString_append(*args)
+    def empty(*args): return _tml.vectorString_empty(*args)
+    def size(*args): return _tml.vectorString_size(*args)
+    def clear(*args): return _tml.vectorString_clear(*args)
+    def swap(*args): return _tml.vectorString_swap(*args)
+    def get_allocator(*args): return _tml.vectorString_get_allocator(*args)
+    def begin(*args): return _tml.vectorString_begin(*args)
+    def end(*args): return _tml.vectorString_end(*args)
+    def rbegin(*args): return _tml.vectorString_rbegin(*args)
+    def rend(*args): return _tml.vectorString_rend(*args)
+    def pop_back(*args): return _tml.vectorString_pop_back(*args)
+    def erase(*args): return _tml.vectorString_erase(*args)
+    def __init__(self, *args): 
+        this = _tml.new_vectorString(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    def push_back(*args): return _tml.vectorString_push_back(*args)
+    def front(*args): return _tml.vectorString_front(*args)
+    def back(*args): return _tml.vectorString_back(*args)
+    def assign(*args): return _tml.vectorString_assign(*args)
+    def resize(*args): return _tml.vectorString_resize(*args)
+    def insert(*args): return _tml.vectorString_insert(*args)
+    def reserve(*args): return _tml.vectorString_reserve(*args)
+    def capacity(*args): return _tml.vectorString_capacity(*args)
+    __swig_destroy__ = _tml.delete_vectorString
+    __del__ = lambda self : None;
+vectorString_swigregister = _tml.vectorString_swigregister
+vectorString_swigregister(vectorString)
+
+
+

Deleted: trunk/gamedata/stars.dat
===================================================================
(Binary files differ)

Modified: trunk/source/generated/tml.py
===================================================================
--- trunk/source/generated/tml.py	2006-01-18 05:03:58 UTC (rev 207)
+++ trunk/source/generated/tml.py	2006-05-08 11:32:42 UTC (rev 208)
@@ -1,408 +1,353 @@
-# This file was created automatically by SWIG.
-# Don't modify this file, modify the SWIG interface instead.
-# This file is compatible with both classic and new-style classes.
-
-import _tml
-
-def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
-    if (name == "this"):
-        if isinstance(value, class_type):
-            self.__dict__[name] = value.this
-            if hasattr(value,"thisown"): self.__dict__["thisown"] = value.thisown
-            del value.thisown
-            return
-    method = class_type.__swig_setmethods__.get(name,None)
-    if method: return method(self,value)
-    if (not static) or hasattr(self,name) or (name == "thisown"):
-        self.__dict__[name] = value
-    else:
-        raise AttributeError("You cannot add attributes to %s" % self)
-
-def _swig_setattr(self,class_type,name,value):
-    return _swig_setattr_nondynamic(self,class_type,name,value,0)
-
-def _swig_getattr(self,class_type,name):
-    method = class_type.__swig_getmethods__.get(name,None)
-    if method: return method(self)
-    raise AttributeError,name
-
-import types
-try:
-    _object = types.ObjectType
-    _newclass = 1
-except AttributeError:
-    class _object : pass
-    _newclass = 0
-del types
-
-
-class GameAction(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, GameAction, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, GameAction, name)
-    def __repr__(self):
-        return "<%s.%s; proxy of C++ GameAction instance at %s>" % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    __swig_getmethods__["clean"] = lambda x: _tml.GameAction_clean
-    if _newclass:clean = staticmethod(_tml.GameAction_clean)
-    __swig_getmethods__["add_system"] = lambda x: _tml.GameAction_add_system
-    if _newclass:add_system = staticmethod(_tml.GameAction_add_system)
-    __swig_getmethods__["add_planet"] = lambda x: _tml.GameAction_add_planet
-    if _newclass:add_planet = staticmethod(_tml.GameAction_add_planet)
-    __swig_getmethods__["add_orbiter_station"] = lambda x: _tml.GameAction_add_orbiter_station
-    if _newclass:add_orbiter_station = staticmethod(_tml.GameAction_add_orbiter_station)
-    __swig_getmethods__["add_asteroid"] = lambda x: _tml.GameAction_add_asteroid
-    if _newclass:add_asteroid = staticmethod(_tml.GameAction_add_asteroid)
-    __swig_getmethods__["add_player"] = lambda x: _tml.GameAction_add_player
-    if _newclass:add_player = staticmethod(_tml.GameAction_add_player)
-    __swig_getmethods__["add_ship"] = lambda x: _tml.GameAction_add_ship
-    if _newclass:add_ship = staticmethod(_tml.GameAction_add_ship)
-    __swig_getmethods__["get_string_flag"] = lambda x: _tml.GameAction_get_string_flag
-    if _newclass:get_string_flag = staticmethod(_tml.GameAction_get_string_flag)
-    __swig_getmethods__["save_flag"] = lambda x: _tml.GameAction_save_flag
-    if _newclass:save_flag = staticmethod(_tml.GameAction_save_flag)
-    __swig_getmethods__["get_double_flag"] = lambda x: _tml.GameAction_get_double_flag
-    if _newclass:get_double_flag = staticmethod(_tml.GameAction_get_double_flag)
-    __swig_getmethods__["get_player_ship_id"] = lambda x: _tml.GameAction_get_player_ship_id
-    if _newclass:get_player_ship_id = staticmethod(_tml.GameAction_get_player_ship_id)
-    __swig_getmethods__["get_player_star_system"] = lambda x: _tml.GameAction_get_player_star_system
-    if _newclass:get_player_star_system = staticmethod(_tml.GameAction_get_player_star_system)
-    __swig_getmethods__["set_target"] = lambda x: _tml.GameAction_set_target
-    if _newclass:set_target = staticmethod(_tml.GameAction_set_target)
-    __swig_getmethods__["disable_weapon"] = lambda x: _tml.GameAction_disable_weapon
-    if _newclass:disable_weapon = staticmethod(_tml.GameAction_disable_weapon)
-    __swig_getmethods__["enable_weapon"] = lambda x: _tml.GameAction_enable_weapon
-    if _newclass:enable_weapon = staticmethod(_tml.GameAction_enable_weapon)
-    __swig_getmethods__["go_to_point"] = lambda x: _tml.GameAction_go_to_point
-    if _newclass:go_to_point = staticmethod(_tml.GameAction_go_to_point)
-    __swig_getmethods__["go_to_location"] = lambda x: _tml.GameAction_go_to_location
-    if _newclass:go_to_location = staticmethod(_tml.GameAction_go_to_location)
-    __swig_getmethods__["guard_location"] = lambda x: _tml.GameAction_guard_location
-    if _newclass:guard_location = staticmethod(_tml.GameAction_guard_location)
-    __swig_getmethods__["guard_point"] = lambda x: _tml.GameAction_guard_point
-    if _newclass:guard_point = staticmethod(_tml.GameAction_guard_point)
-    __swig_getmethods__["set_ship_team"] = lambda x: _tml.GameAction_set_ship_team
-    if _newclass:set_ship_team = staticmethod(_tml.GameAction_set_ship_team)
-    __swig_getmethods__["get_enemy_team"] = lambda x: _tml.GameAction_get_enemy_team
-    if _newclass:get_enemy_team = staticmethod(_tml.GameAction_get_enemy_team)
-    __swig_getmethods__["get_player_team"] = lambda x: _tml.GameAction_get_player_team
-    if _newclass:get_player_team = staticmethod(_tml.GameAction_get_player_team)
-    __swig_getmethods__["remove_location"] = lambda x: _tml.GameAction_remove_location
-    if _newclass:remove_location = staticmethod(_tml.GameAction_remove_location)
-    __swig_getmethods__["set_crew"] = lambda x: _tml.GameAction_set_crew
-    if _newclass:set_crew = staticmethod(_tml.GameAction_set_crew)
-    __swig_getmethods__["get_location_pos_x"] = lambda x: _tml.GameAction_get_location_pos_x
-    if _newclass:get_location_pos_x = staticmethod(_tml.GameAction_get_location_pos_x)
-    __swig_getmethods__["get_location_pos_y"] = lambda x: _tml.GameAction_get_location_pos_y
-    if _newclass:get_location_pos_y = staticmethod(_tml.GameAction_get_location_pos_y)
-    __swig_getmethods__["exist"] = lambda x: _tml.GameAction_exist
-    if _newclass:exist = staticmethod(_tml.GameAction_exist)
-    __swig_getmethods__["end_game"] = lambda x: _tml.GameAction_end_game
-    if _newclass:end_game = staticmethod(_tml.GameAction_end_game)
-    __swig_getmethods__["scroll_text"] = lambda x: _tml.GameAction_scroll_text
-    if _newclass:scroll_text = staticmethod(_tml.GameAction_scroll_text)
-    __swig_getmethods__["print_message"] = lambda x: _tml.GameAction_print_message
-    if _newclass:print_message = staticmethod(_tml.GameAction_print_message)
-    __swig_getmethods__["set_camera_mode"] = lambda x: _tml.GameAction_set_camera_mode
-    if _newclass:set_camera_mode = staticmethod(_tml.GameAction_set_camera_mode)
-    def __init__(self, *args):
-        _swig_setattr(self, GameAction, 'this', _tml.new_GameAction(*args))
-        _swig_setattr(self, GameAction, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_GameAction):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class GameActionPtr(GameAction):
-    def __init__(self, this):
-        _swig_setattr(self, GameAction, 'this', this)
-        if not hasattr(self,"thisown"): _swig_setattr(self, GameAction, 'thisown', 0)
-        _swig_setattr(self, GameAction,self.__class__,GameAction)
-_tml.GameAction_swigregister(GameActionPtr)
-
-GameAction_clean = _tml.GameAction_clean
-
-GameAction_add_system = _tml.GameAction_add_system
-
-GameAction_add_planet = _tml.GameAction_add_planet
-
-GameAction_add_orbiter_station = _tml.GameAction_add_orbiter_station
-
-GameAction_add_asteroid = _tml.GameAction_add_asteroid
-
-GameAction_add_player = _tml.GameAction_add_player
-
-GameAction_add_ship = _tml.GameAction_add_ship
-
-GameAction_get_string_flag = _tml.GameAction_get_string_flag
-
-GameAction_save_flag = _tml.GameAction_save_flag
-
-GameAction_get_double_flag = _tml.GameAction_get_double_flag
-
-GameAction_get_player_ship_id = _tml.GameAction_get_player_ship_id
-
-GameAction_get_player_star_system = _tml.GameAction_get_player_star_system
-
-GameAction_set_target = _tml.GameAction_set_target
-
-GameAction_disable_weapon = _tml.GameAction_disable_weapon
-
-GameAction_enable_weapon = _tml.GameAction_enable_weapon
-
-GameAction_go_to_point = _tml.GameAction_go_to_point
-
-GameAction_go_to_location = _tml.GameAction_go_to_location
-
-GameAction_guard_location = _tml.GameAction_guard_location
-
-GameAction_guard_point = _tml.GameAction_guard_point
-
-GameAction_set_ship_team = _tml.GameAction_set_ship_team
-
-GameAction_get_enemy_team = _tml.GameAction_get_enemy_team
-
-GameAction_get_player_team = _tml.GameAction_get_player_team
-
-GameAction_remove_location = _tml.GameAction_remove_location
-
-GameAction_set_crew = _tml.GameAction_set_crew
-
-GameAction_get_location_pos_x = _tml.GameAction_get_location_pos_x
-
-GameAction_get_location_pos_y = _tml.GameAction_get_location_pos_y
-
-GameAction_exist = _tml.GameAction_exist
-
-GameAction_end_game = _tml.GameAction_end_game
-
-GameAction_scroll_text = _tml.GameAction_scroll_text
-
-GameAction_print_message = _tml.GameAction_print_message
-
-GameAction_set_camera_mode = _tml.GameAction_set_camera_mode
-
-class DialogApi(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, DialogApi, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, DialogApi, name)
-    def __repr__(self):
-        return "<%s.%s; proxy of C++ DialogApi instance at %s>" % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    __swig_getmethods__["startDialog"] = lambda x: _tml.DialogApi_startDialog
-    if _newclass:startDialog = staticmethod(_tml.DialogApi_startDialog)
-    __swig_getmethods__["endDialog"] = lambda x: _tml.DialogApi_endDialog
-    if _newclass:endDialog = staticmethod(_tml.DialogApi_endDialog)
-    __swig_getmethods__["askPlayer"] = lambda x: _tml.DialogApi_askPlayer
-    if _newclass:askPlayer = staticmethod(_tml.DialogApi_askPlayer)
-    __swig_getmethods__["showText"] = lambda x: _tml.DialogApi_showText
-    if _newclass:showText = staticmethod(_tml.DialogApi_showText)
-    __swig_getmethods__["showAlienPicture"] = lambda x: _tml.DialogApi_showAlienPicture
-    if _newclass:showAlienPicture = staticmethod(_tml.DialogApi_showAlienPicture)
-    def __init__(self, *args):
-        _swig_setattr(self, DialogApi, 'this', _tml.new_DialogApi(*args))
-        _swig_setattr(self, DialogApi, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_DialogApi):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class DialogApiPtr(DialogApi):
-    def __init__(self, this):
-        _swig_setattr(self, DialogApi, 'this', this)
-        if not hasattr(self,"thisown"): _swig_setattr(self, DialogApi, 'thisown', 0)
-        _swig_setattr(self, DialogApi,self.__class__,DialogApi)
-_tml.DialogApi_swigregister(DialogApiPtr)
-
-DialogApi_startDialog = _tml.DialogApi_startDialog
-
-DialogApi_endDialog = _tml.DialogApi_endDialog
-
-DialogApi_askPlayer = _tml.DialogApi_askPlayer
-
-DialogApi_showText = _tml.DialogApi_showText
-
-DialogApi_showAlienPicture = _tml.DialogApi_showAlienPicture
-
-class GameConfig(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, GameConfig, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, GameConfig, name)
-    def __repr__(self):
-        return "<%s.%s; proxy of C++ GameConfig instance at %s>" % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    __swig_getmethods__["SetGameDirectory"] = lambda x: _tml.GameConfig_SetGameDirectory
-    if _newclass:SetGameDirectory = staticmethod(_tml.GameConfig_SetGameDirectory)
-    __swig_getmethods__["GetGameDirectory"] = lambda x: _tml.GameConfig_GetGameDirectory
-    if _newclass:GetGameDirectory = staticmethod(_tml.GameConfig_GetGameDirectory)
-    __swig_getmethods__["GetAbsolutePath"] = lambda x: _tml.GameConfig_GetAbsolutePath
-    if _newclass:GetAbsolutePath = staticmethod(_tml.GameConfig_GetAbsolutePath)
-    def __init__(self, *args):
-        _swig_setattr(self, GameConfig, 'this', _tml.new_GameConfig(*args))
-        _swig_setattr(self, GameConfig, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_GameConfig):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class GameConfigPtr(GameConfig):
-    def __init__(self, this):
-        _swig_setattr(self, GameConfig, 'this', this)
-        if not hasattr(self,"thisown"): _swig_setattr(self, GameConfig, 'thisown', 0)
-        _swig_setattr(self, GameConfig,self.__class__,GameConfig)
-_tml.GameConfig_swigregister(GameConfigPtr)
-
-GameConfig_SetGameDirectory = _tml.GameConfig_SetGameDirectory
-
-GameConfig_GetGameDirectory = _tml.GameConfig_GetGameDirectory
-
-GameConfig_GetAbsolutePath = _tml.GameConfig_GetAbsolutePath
-
-class EventManager(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, EventManager, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, EventManager, name)
-    def __repr__(self):
-        return "<%s.%s; proxy of C++ EventManager instance at %s>" % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    __swig_getmethods__["clean"] = lambda x: _tml.EventManager_clean
-    if _newclass:clean = staticmethod(_tml.EventManager_clean)
-    __swig_getmethods__["setSingleTimeEvent"] = lambda x: _tml.EventManager_setSingleTimeEvent
-    if _newclass:setSingleTimeEvent = staticmethod(_tml.EventManager_setSingleTimeEvent)
-    __swig_getmethods__["setRepeatableTimeEvent"] = lambda x: _tml.EventManager_setRepeatableTimeEvent
-    if _newclass:setRepeatableTimeEvent = staticmethod(_tml.EventManager_setRepeatableTimeEvent)
-    __swig_getmethods__["disableEvent"] = lambda x: _tml.EventManager_disableEvent
-    if _newclass:disableEvent = staticmethod(_tml.EventManager_disableEvent)
-    __swig_getmethods__["shipDeathById"] = lambda x: _tml.EventManager_shipDeathById
-    if _newclass:shipDeathById = staticmethod(_tml.EventManager_shipDeathById)
-    __swig_getmethods__["shipDeathByType"] = lambda x: _tml.EventManager_shipDeathByType
-    if _newclass:shipDeathByType = staticmethod(_tml.EventManager_shipDeathByType)
-    __swig_getmethods__["distanceMoreThen"] = lambda x: _tml.EventManager_distanceMoreThen
-    if _newclass:distanceMoreThen = staticmethod(_tml.EventManager_distanceMoreThen)
-    __swig_getmethods__["distanceLessThen"] = lambda x: _tml.EventManager_distanceLessThen
-    if _newclass:distanceLessThen = staticmethod(_tml.EventManager_distanceLessThen)
-    __swig_getmethods__["jumpToSystem"] = lambda x: _tml.EventManager_jumpToSystem
-    if _newclass:jumpToSystem = staticmethod(_tml.EventManager_jumpToSystem)
-    __swig_getmethods__["AddEventCondition"] = lambda x: _tml.EventManager_AddEventCondition
-    if _newclass:AddEventCondition = staticmethod(_tml.EventManager_AddEventCondition)
-    def __init__(self, *args):
-        _swig_setattr(self, EventManager, 'this', _tml.new_EventManager(*args))
-        _swig_setattr(self, EventManager, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_EventManager):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class EventManagerPtr(EventManager):
-    def __init__(self, this):
-        _swig_setattr(self, EventManager, 'this', this)
-        if not hasattr(self,"thisown"): _swig_setattr(self, EventManager, 'thisown', 0)
-        _swig_setattr(self, EventManager,self.__class__,EventManager)
-_tml.EventManager_swigregister(EventManagerPtr)
-
-EventManager_clean = _tml.EventManager_clean
-
-EventManager_setSingleTimeEvent = _tml.EventManager_setSingleTimeEvent
-
-EventManager_setRepeatableTimeEvent = _tml.EventManager_setRepeatableTimeEvent
-
-EventManager_disableEvent = _tml.EventManager_disableEvent
-
-EventManager_shipDeathById = _tml.EventManager_shipDeathById
-
-EventManager_shipDeathByType = _tml.EventManager_shipDeathByType
-
-EventManager_distanceMoreThen = _tml.EventManager_distanceMoreThen
-
-EventManager_distanceLessThen = _tml.EventManager_distanceLessThen
-
-EventManager_jumpToSystem = _tml.EventManager_jumpToSystem
-
-EventManager_AddEventCondition = _tml.EventManager_AddEventCondition
-
-class SoundSystem(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, SoundSystem, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, SoundSystem, name)
-    def __repr__(self):
-        return "<%s.%s; proxy of C++ SoundSystem instance at %s>" % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    def __init__(self, *args):
-        _swig_setattr(self, SoundSystem, 'this', _tml.new_SoundSystem(*args))
-        _swig_setattr(self, SoundSystem, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_SoundSystem):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-    def play_music(*args): return _tml.SoundSystem_play_music(*args)
-    def play_sound(*args): return _tml.SoundSystem_play_sound(*args)
-    def stop_sound(*args): return _tml.SoundSystem_stop_sound(*args)
-    def set_music_volume(*args): return _tml.SoundSystem_set_music_volume(*args)
-    def set_sound_volume(*args): return _tml.SoundSystem_set_sound_volume(*args)
-    def load_music_volume(*args): return _tml.SoundSystem_load_music_volume(*args)
-    def load_sound_volume(*args): return _tml.SoundSystem_load_sound_volume(*args)
-    def playing_music(*args): return _tml.SoundSystem_playing_music(*args)
-    def playing_music_file(*args): return _tml.SoundSystem_playing_music_file(*args)
-
-class SoundSystemPtr(SoundSystem):
-    def __init__(self, this):
-        _swig_setattr(self, SoundSystem, 'this', this)
-        if not hasattr(self,"thisown"): _swig_setattr(self, SoundSystem, 'thisown', 0)
-        _swig_setattr(self, SoundSystem,self.__class__,SoundSystem)
-_tml.SoundSystem_swigregister(SoundSystemPtr)
-
-
-GetSoundSystem = _tml.GetSoundSystem
-class vectorString(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorString, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, vectorString, name)
-    def __repr__(self):
-        return "<%s.%s; proxy of C++ std::vector<std::string > instance at %s>" % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    def empty(*args): return _tml.vectorString_empty(*args)
-    def size(*args): return _tml.vectorString_size(*args)
-    def clear(*args): return _tml.vectorString_clear(*args)
-    def swap(*args): return _tml.vectorString_swap(*args)
-    def get_allocator(*args): return _tml.vectorString_get_allocator(*args)
-    def pop_back(*args): return _tml.vectorString_pop_back(*args)
-    def __init__(self, *args):
-        _swig_setattr(self, vectorString, 'this', _tml.new_vectorString(*args))
-        _swig_setattr(self, vectorString, 'thisown', 1)
-    def push_back(*args): return _tml.vectorString_push_back(*args)
-    def front(*args): return _tml.vectorString_front(*args)
-    def back(*args): return _tml.vectorString_back(*args)
-    def assign(*args): return _tml.vectorString_assign(*args)
-    def resize(*args): return _tml.vectorString_resize(*args)
-    def reserve(*args): return _tml.vectorString_reserve(*args)
-    def capacity(*args): return _tml.vectorString_capacity(*args)
-    def __nonzero__(*args): return _tml.vectorString___nonzero__(*args)
-    def __len__(*args): return _tml.vectorString___len__(*args)
-    def pop(*args): return _tml.vectorString_pop(*args)
-    def __getslice__(*args): return _tml.vectorString___getslice__(*args)
-    def __setslice__(*args): return _tml.vectorString___setslice__(*args)
-    def __delslice__(*args): return _tml.vectorString___delslice__(*args)
-    def __delitem__(*args): return _tml.vectorString___delitem__(*args)
-    def __getitem__(*args): return _tml.vectorString___getitem__(*args)
-    def __setitem__(*args): return _tml.vectorString___setitem__(*args)
-    def append(*args): return _tml.vectorString_append(*args)
-    def __del__(self, destroy=_tml.delete_vectorString):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class vectorStringPtr(vectorString):
-    def __init__(self, this):
-        _swig_setattr(self, vectorString, 'this', this)
-        if not hasattr(self,"thisown"): _swig_setattr(self, vectorString, 'thisown', 0)
-        _swig_setattr(self, vectorString,self.__class__,vectorString)
-_tml.vectorString_swigregister(vectorStringPtr)
-cvar = _tml.cvar
-
-
+# This file was created automatically by SWIG 1.3.29.
+# Don't modify this file, modify the SWIG interface instead.
+# This file is compatible with both classic and new-style classes.
+
+import _tml
+import new
+new_instancemethod = new.instancemethod
+def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
+    if (name == "thisown"): return self.this.own(value)
+    if (name == "this"):
+        if type(value).__name__ == 'PySwigObject':
+            self.__dict__[name] = value
+            return
+    method = class_type.__swig_setmethods__.get(name,None)
+    if method: return method(self,value)
+    if (not static) or hasattr(self,name):
+        self.__dict__[name] = value
+    else:
+        raise AttributeError("You cannot add attributes to %s" % self)
+
+def _swig_setattr(self,class_type,name,value):
+    return _swig_setattr_nondynamic(self,class_type,name,value,0)
+
+def _swig_getattr(self,class_type,name):
+    if (name == "thisown"): return self.this.own()
+    method = class_type.__swig_getmethods__.get(name,None)
+    if method: return method(self)
+    raise AttributeError,name
+
+def _swig_repr(self):
+    try: strthis = "proxy of " + self.this.__repr__()
+    except: strthis = ""
+    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
+
+import types
+try:
+    _object = types.ObjectType
+    _newclass = 1
+except AttributeError:
+    class _object : pass
+    _newclass = 0
+del types
+
+
+class GameAction(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GameAction, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GameAction, name)
+    __repr__ = _swig_repr
+    __swig_getmethods__["clean"] = lambda x: _tml.GameAction_clean
+    if _newclass:clean = staticmethod(_tml.GameAction_clean)
+    __swig_getmethods__["add_system"] = lambda x: _tml.GameAction_add_system
+    if _newclass:add_system = staticmethod(_tml.GameAction_add_system)
+    __swig_getmethods__["add_planet"] = lambda x: _tml.GameAction_add_planet
+    if _newclass:add_planet = staticmethod(_tml.GameAction_add_planet)
+    __swig_getmethods__["add_orbiter_station"] = lambda x: _tml.GameAction_add_orbiter_station
+    if _newclass:add_orbiter_station = staticmethod(_tml.GameAction_add_orbiter_station)
+    __swig_getmethods__["add_asteroid"] = lambda x: _tml.GameAction_add_asteroid
+    if _newclass:add_asteroid = staticmethod(_tml.GameAction_add_asteroid)
+    __swig_getmethods__["add_player"] = lambda x: _tml.GameAction_add_player
+    if _newclass:add_player = staticmethod(_tml.GameAction_add_player)
+    __swig_getmethods__["add_ship"] = lambda x: _tml.GameAction_add_ship
+    if _newclass:add_ship = staticmethod(_tml.GameAction_add_ship)
+    __swig_getmethods__["get_string_flag"] = lambda x: _tml.GameAction_get_string_flag
+    if _newclass:get_string_flag = staticmethod(_tml.GameAction_get_string_flag)
+    __swig_getmethods__["save_flag"] = lambda x: _tml.GameAction_save_flag
+    if _newclass:save_flag = staticmethod(_tml.GameAction_save_flag)
+    __swig_getmethods__["get_double_flag"] = lambda x: _tml.GameAction_get_double_flag
+    if _newclass:get_double_flag = staticmethod(_tml.GameAction_get_double_flag)
+    __swig_getmethods__["get_player_ship_id"] = lambda x: _tml.GameAction_get_player_ship_id
+    if _newclass:get_player_ship_id = staticmethod(_tml.GameAction_get_player_ship_id)
+    __swig_getmethods__["get_player_star_system"] = lambda x: _tml.GameAction_get_player_star_system
+    if _newclass:get_player_star_system = staticmethod(_tml.GameAction_get_player_star_system)
+    __swig_getmethods__["set_target"] = lambda x: _tml.GameAction_set_target
+    if _newclass:set_target = staticmethod(_tml.GameAction_set_target)
+    __swig_getmethods__["disable_weapon"] = lambda x: _tml.GameAction_disable_weapon
+    if _newclass:disable_weapon = staticmethod(_tml.GameAction_disable_weapon)
+    __swig_getmethods__["enable_weapon"] = lambda x: _tml.GameAction_enable_weapon
+    if _newclass:enable_weapon = staticmethod(_tml.GameAction_enable_weapon)
+    __swig_getmethods__["go_to_point"] = lambda x: _tml.GameAction_go_to_point
+    if _newclass:go_to_point = staticmethod(_tml.GameAction_go_to_point)
+    __swig_getmethods__["go_to_location"] = lambda x: _tml.GameAction_go_to_location
+    if _newclass:go_to_location = staticmethod(_tml.GameAction_go_to_location)
+    __swig_getmethods__["guard_location"] = lambda x: _tml.GameAction_guard_location
+    if _newclass:guard_location = staticmethod(_tml.GameAction_guard_location)
+    __swig_getmethods__["guard_point"] = lambda x: _tml.GameAction_guard_point
+    if _newclass:guard_point = staticmethod(_tml.GameAction_guard_point)
+    __swig_getmethods__["set_ship_team"] = lambda x: _tml.GameAction_set_ship_team
+    if _newclass:set_ship_team = staticmethod(_tml.GameAction_set_ship_team)
+    __swig_getmethods__["get_enemy_team"] = lambda x: _tml.GameAction_get_enemy_team
+    if _newclass:get_enemy_team = staticmethod(_tml.GameAction_get_enemy_team)
+    __swig_getmethods__["get_player_team"] = lambda x: _tml.GameAction_get_player_team
+    if _newclass:get_player_team = staticmethod(_tml.GameAction_get_player_team)
+    __swig_getmethods__["remove_location"] = lambda x: _tml.GameAction_remove_location
+    if _newclass:remove_location = staticmethod(_tml.GameAction_remove_location)
+    __swig_getmethods__["set_crew"] = lambda x: _tml.GameAction_set_crew
+    if _newclass:set_crew = staticmethod(_tml.GameAction_set_crew)
+    __swig_getmethods__["get_location_pos_x"] = lambda x: _tml.GameAction_get_location_pos_x
+    if _newclass:get_location_pos_x = staticmethod(_tml.GameAction_get_location_pos_x)
+    __swig_getmethods__["get_location_pos_y"] = lambda x: _tml.GameAction_get_location_pos_y
+    if _newclass:get_location_pos_y = staticmethod(_tml.GameAction_get_location_pos_y)
+    __swig_getmethods__["exist"] = lambda x: _tml.GameAction_exist
+    if _newclass:exist = staticmethod(_tml.GameAction_exist)
+    __swig_getmethods__["end_game"] = lambda x: _tml.GameAction_end_game
+    if _newclass:end_game = staticmethod(_tml.GameAction_end_game)
+    __swig_getmethods__["scroll_text"] = lambda x: _tml.GameAction_scroll_text
+    if _newclass:scroll_text = staticmethod(_tml.GameAction_scroll_text)
+    __swig_getmethods__["print_message"] = lambda x: _tml.GameAction_print_message
+    if _newclass:print_message = staticmethod(_tml.GameAction_print_message)
+    __swig_getmethods__["set_camera_mode"] = lambda x: _tml.GameAction_set_camera_mode
+    if _newclass:set_camera_mode = staticmethod(_tml.GameAction_set_camera_mode)
+    def __init__(self, *args): 
+        this = _tml.new_GameAction(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_GameAction
+    __del__ = lambda self : None;
+GameAction_swigregister = _tml.GameAction_swigregister
+GameAction_swigregister(GameAction)
+GameAction_clean = _tml.GameAction_clean
+GameAction_add_system = _tml.GameAction_add_system
+GameAction_add_planet = _tml.GameAction_add_planet
+GameAction_add_orbiter_station = _tml.GameAction_add_orbiter_station
+GameAction_add_asteroid = _tml.GameAction_add_asteroid
+GameAction_add_player = _tml.GameAction_add_player
+GameAction_add_ship = _tml.GameAction_add_ship
+GameAction_get_string_flag = _tml.GameAction_get_string_flag
+GameAction_save_flag = _tml.GameAction_save_flag
+GameAction_get_double_flag = _tml.GameAction_get_double_flag
+GameAction_get_player_ship_id = _tml.GameAction_get_player_ship_id
+GameAction_get_player_star_system = _tml.GameAction_get_player_star_system
+GameAction_set_target = _tml.GameAction_set_target
+GameAction_disable_weapon = _tml.GameAction_disable_weapon
+GameAction_enable_weapon = _tml.GameAction_enable_weapon
+GameAction_go_to_point = _tml.GameAction_go_to_point
+GameAction_go_to_location = _tml.GameAction_go_to_location
+GameAction_guard_location = _tml.GameAction_guard_location
+GameAction_guard_point = _tml.GameAction_guard_point
+GameAction_set_ship_team = _tml.GameAction_set_ship_team
+GameAction_get_enemy_team = _tml.GameAction_get_enemy_team
+GameAction_get_player_team = _tml.GameAction_get_player_team
+GameAction_remove_location = _tml.GameAction_remove_location
+GameAction_set_crew = _tml.GameAction_set_crew
+GameAction_get_location_pos_x = _tml.GameAction_get_location_pos_x
+GameAction_get_location_pos_y = _tml.GameAction_get_location_pos_y
+GameAction_exist = _tml.GameAction_exist
+GameAction_end_game = _tml.GameAction_end_game
+GameAction_scroll_text = _tml.GameAction_scroll_text
+GameAction_print_message = _tml.GameAction_print_message
+GameAction_set_camera_mode = _tml.GameAction_set_camera_mode
+
+class DialogApi(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, DialogApi, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, DialogApi, name)
+    __repr__ = _swig_repr
+    __swig_getmethods__["startDialog"] = lambda x: _tml.DialogApi_startDialog
+    if _newclass:startDialog = staticmethod(_tml.DialogApi_startDialog)
+    __swig_getmethods__["endDialog"] = lambda x: _tml.DialogApi_endDialog
+    if _newclass:endDialog = staticmethod(_tml.DialogApi_endDialog)
+    __swig_getmethods__["askPlayer"] = lambda x: _tml.DialogApi_askPlayer
+    if _newclass:askPlayer = staticmethod(_tml.DialogApi_askPlayer)
+    __swig_getmethods__["showText"] = lambda x: _tml.DialogApi_showText
+    if _newclass:showText = staticmethod(_tml.DialogApi_showText)
+    __swig_getmethods__["showAlienPicture"] = lambda x: _tml.DialogApi_showAlienPicture
+    if _newclass:showAlienPicture = staticmethod(_tml.DialogApi_showAlienPicture)
+    def __init__(self, *args): 
+        this = _tml.new_DialogApi(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_DialogApi
+    __del__ = lambda self : None;
+DialogApi_swigregister = _tml.DialogApi_swigregister
+DialogApi_swigregister(DialogApi)
+DialogApi_startDialog = _tml.DialogApi_startDialog
+DialogApi_endDialog = _tml.DialogApi_endDialog
+DialogApi_askPlayer = _tml.DialogApi_askPlayer
+DialogApi_showText = _tml.DialogApi_showText
+DialogApi_showAlienPicture = _tml.DialogApi_showAlienPicture
+
+class GameConfig(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GameConfig, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GameConfig, name)
+    __repr__ = _swig_repr
+    __swig_getmethods__["SetGameDirectory"] = lambda x: _tml.GameConfig_SetGameDirectory
+    if _newclass:SetGameDirectory = staticmethod(_tml.GameConfig_SetGameDirectory)
+    __swig_getmethods__["GetGameDirectory"] = lambda x: _tml.GameConfig_GetGameDirectory
+    if _newclass:GetGameDirectory = staticmethod(_tml.GameConfig_GetGameDirectory)
+    __swig_getmethods__["GetAbsolutePath"] = lambda x: _tml.GameConfig_GetAbsolutePath
+    if _newclass:GetAbsolutePath = staticmethod(_tml.GameConfig_GetAbsolutePath)
+    def __init__(self, *args): 
+        this = _tml.new_GameConfig(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_GameConfig
+    __del__ = lambda self : None;
+GameConfig_swigregister = _tml.GameConfig_swigregister
+GameConfig_swigregister(GameConfig)
+GameConfig_SetGameDirectory = _tml.GameConfig_SetGameDirectory
+GameConfig_GetGameDirectory = _tml.GameConfig_GetGameDirectory
+GameConfig_GetAbsolutePath = _tml.GameConfig_GetAbsolutePath
+
+class EventManager(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, EventManager, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, EventManager, name)
+    __repr__ = _swig_repr
+    __swig_getmethods__["clean"] = lambda x: _tml.EventManager_clean
+    if _newclass:clean = staticmethod(_tml.EventManager_clean)
+    __swig_getmethods__["setSingleTimeEvent"] = lambda x: _tml.EventManager_setSingleTimeEvent
+    if _newclass:setSingleTimeEvent = staticmethod(_tml.EventManager_setSingleTimeEvent)
+    __swig_getmethods__["setRepeatableTimeEvent"] = lambda x: _tml.EventManager_setRepeatableTimeEvent
+    if _newclass:setRepeatableTimeEvent = staticmethod(_tml.EventManager_setRepeatableTimeEvent)
+    __swig_getmethods__["disableEvent"] = lambda x: _tml.EventManager_disableEvent
+    if _newclass:disableEvent = staticmethod(_tml.EventManager_disableEvent)
+    __swig_getmethods__["shipDeathById"] = lambda x: _tml.EventManager_shipDeathById
+    if _newclass:shipDeathById = staticmethod(_tml.EventManager_shipDeathById)
+    __swig_getmethods__["shipDeathByType"] = lambda x: _tml.EventManager_shipDeathByType
+    if _newclass:shipDeathByType = staticmethod(_tml.EventManager_shipDeathByType)
+    __swig_getmethods__["distanceMoreThen"] = lambda x: _tml.EventManager_distanceMoreThen
+    if _newclass:distanceMoreThen = staticmethod(_tml.EventManager_distanceMoreThen)
+    __swig_getmethods__["distanceLessThen"] = lambda x: _tml.EventManager_distanceLessThen
+    if _newclass:distanceLessThen = staticmethod(_tml.EventManager_distanceLessThen)
+    __swig_getmethods__["jumpToSystem"] = lambda x: _tml.EventManager_jumpToSystem
+    if _newclass:jumpToSystem = staticmethod(_tml.EventManager_jumpToSystem)
+    __swig_getmethods__["AddEventCondition"] = lambda x: _tml.EventManager_AddEventCondition
+    if _newclass:AddEventCondition = staticmethod(_tml.EventManager_AddEventCondition)
+    def __init__(self, *args): 
+        this = _tml.new_EventManager(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_EventManager
+    __del__ = lambda self : None;
+EventManager_swigregister = _tml.EventManager_swigregister
+EventManager_swigregister(EventManager)
+EventManager_clean = _tml.EventManager_clean
+EventManager_setSingleTimeEvent = _tml.EventManager_setSingleTimeEvent
+EventManager_setRepeatableTimeEvent = _tml.EventManager_setRepeatableTimeEvent
+EventManager_disableEvent = _tml.EventManager_disableEvent
+EventManager_shipDeathById = _tml.EventManager_shipDeathById
+EventManager_shipDeathByType = _tml.EventManager_shipDeathByType
+EventManager_distanceMoreThen = _tml.EventManager_distanceMoreThen
+EventManager_distanceLessThen = _tml.EventManager_distanceLessThen
+EventManager_jumpToSystem = _tml.EventManager_jumpToSystem
+EventManager_AddEventCondition = _tml.EventManager_AddEventCondition
+
+class SoundSystem(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, SoundSystem, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, SoundSystem, name)
+    __repr__ = _swig_repr
+    def __init__(self, *args): 
+        this = _tml.new_SoundSystem(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_SoundSystem
+    __del__ = lambda self : None;
+    def play_music(*args): return _tml.SoundSystem_play_music(*args)
+    def play_sound(*args): return _tml.SoundSystem_play_sound(*args)
+    def stop_sound(*args): return _tml.SoundSystem_stop_sound(*args)
+    def set_music_volume(*args): return _tml.SoundSystem_set_music_volume(*args)
+    def set_sound_volume(*args): return _tml.SoundSystem_set_sound_volume(*args)
+    def load_music_volume(*args): return _tml.SoundSystem_load_music_volume(*args)
+    def load_sound_volume(*args): return _tml.SoundSystem_load_sound_volume(*args)
+    def playing_music(*args): return _tml.SoundSystem_playing_music(*args)
+    def playing_music_file(*args): return _tml.SoundSystem_playing_music_file(*args)
+SoundSystem_swigregister = _tml.SoundSystem_swigregister
+SoundSystem_swigregister(SoundSystem)
+
+GetSoundSystem = _tml.GetSoundSystem
+class PySwigIterator(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, PySwigIterator, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, PySwigIterator, name)
+    def __init__(self): raise AttributeError, "No constructor defined"
+    __repr__ = _swig_repr
+    __swig_destroy__ = _tml.delete_PySwigIterator
+    __del__ = lambda self : None;
+    def value(*args): return _tml.PySwigIterator_value(*args)
+    def incr(*args): return _tml.PySwigIterator_incr(*args)
+    def decr(*args): return _tml.PySwigIterator_decr(*args)
+    def distance(*args): return _tml.PySwigIterator_distance(*args)
+    def equal(*args): return _tml.PySwigIterator_equal(*args)
+    def copy(*args): return _tml.PySwigIterator_copy(*args)
+    def next(*args): return _tml.PySwigIterator_next(*args)
+    def previous(*args): return _tml.PySwigIterator_previous(*args)
+    def advance(*args): return _tml.PySwigIterator_advance(*args)
+    def __eq__(*args): return _tml.PySwigIterator___eq__(*args)
+    def __ne__(*args): return _tml.PySwigIterator___ne__(*args)
+    def __iadd__(*args): return _tml.PySwigIterator___iadd__(*args)
+    def __isub__(*args): return _tml.PySwigIterator___isub__(*args)
+    def __add__(*args): return _tml.PySwigIterator___add__(*args)
+    def __sub__(*args): return _tml.PySwigIterator___sub__(*args)
+    def __iter__(self): return self
+PySwigIterator_swigregister = _tml.PySwigIterator_swigregister
+PySwigIterator_swigregister(PySwigIterator)
+cvar = _tml.cvar
+
+class vectorString(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorString, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, vectorString, name)
+    __repr__ = _swig_repr
+    def iterator(*args): return _tml.vectorString_iterator(*args)
+    def __iter__(self): return self.iterator()
+    def __nonzero__(*args): return _tml.vectorString___nonzero__(*args)
+    def __len__(*args): return _tml.vectorString___len__(*args)
+    def pop(*args): return _tml.vectorString_pop(*args)
+    def __getslice__(*args): return _tml.vectorString___getslice__(*args)
+    def __setslice__(*args): return _tml.vectorString___setslice__(*args)
+    def __delslice__(*args): return _tml.vectorString___delslice__(*args)
+    def __delitem__(*args): return _tml.vectorString___delitem__(*args)
+    def __getitem__(*args): return _tml.vectorString___getitem__(*args)
+    def __setitem__(*args): return _tml.vectorString___setitem__(*args)
+    def append(*args): return _tml.vectorString_append(*args)
+    def empty(*args): return _tml.vectorString_empty(*args)
+    def size(*args): return _tml.vectorString_size(*args)
+    def clear(*args): return _tml.vectorString_clear(*args)
+    def swap(*args): return _tml.vectorString_swap(*args)
+    def get_allocator(*args): return _tml.vectorString_get_allocator(*args)
+    def begin(*args): return _tml.vectorString_begin(*args)
+    def end(*args): return _tml.vectorString_end(*args)
+    def rbegin(*args): return _tml.vectorString_rbegin(*args)
+    def rend(*args): return _tml.vectorString_rend(*args)
+    def pop_back(*args): return _tml.vectorString_pop_back(*args)
+    def erase(*args): return _tml.vectorString_erase(*args)
+    def __init__(self, *args): 
+        this = _tml.new_vectorString(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    def push_back(*args): return _tml.vectorString_push_back(*args)
+    def front(*args): return _tml.vectorString_front(*args)
+    def back(*args): return _tml.vectorString_back(*args)
+    def assign(*args): return _tml.vectorString_assign(*args)
+    def resize(*args): return _tml.vectorString_resize(*args)
+    def insert(*args): return _tml.vectorString_insert(*args)
+    def reserve(*args): return _tml.vectorString_reserve(*args)
+    def capacity(*args): return _tml.vectorString_capacity(*args)
+    __swig_destroy__ = _tml.delete_vectorString
+    __del__ = lambda self : None;
+vectorString_swigregister = _tml.vectorString_swigregister
+vectorString_swigregister(vectorString)
+
+
+

Modified: trunk/source/generated/tml_wrap.cpp
===================================================================
--- trunk/source/generated/tml_wrap.cpp	2006-01-18 05:03:58 UTC (rev 207)
+++ trunk/source/generated/tml_wrap.cpp	2006-05-08 11:32:42 UTC (rev 208)
@@ -1,7178 +1,10449 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 1.3.25
- * 
- * This file is not intended to be easily readable and contains a number of 
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG 
- * interface file instead. 
- * ----------------------------------------------------------------------------- */
-
-#define SWIGPYTHON
-
-#ifdef __cplusplus
-template<class T> class SwigValueWrapper {
-    T *tt;
-public:
-    SwigValueWrapper() : tt(0) { }
-    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
-    SwigValueWrapper(const T& t) : tt(new T(t)) { }
-    ~SwigValueWrapper() { delete tt; } 
-    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
-    operator T&() const { return *tt; }
-    T *operator&() { return tt; }
-private:
-    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
-};
-#endif
-
-/***********************************************************************
- *
- *  This section contains generic SWIG labels for method/variable
- *  declarations/attributes, and other compiler dependent labels.
- *
- ************************************************************************/
-
-/* template workaround for compilers that cannot correctly implement the C++ standard */
-#ifndef SWIGTEMPLATEDISAMBIGUATOR
-#  if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
-#    define SWIGTEMPLATEDISAMBIGUATOR template
-#  else
-#    define SWIGTEMPLATEDISAMBIGUATOR 
-#  endif
-#endif
-
-/* inline attribute */
-#ifndef SWIGINLINE
-# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
-#   define SWIGINLINE inline
-# else
-#   define SWIGINLINE
-# endif
-#endif
-
-/* attribute recognised by some compilers to avoid 'unused' warnings */
-#ifndef SWIGUNUSED
-# if defined(__GNUC__) || defined(__ICC)
-#   define SWIGUNUSED __attribute__ ((unused)) 
-# else
-#   define SWIGUNUSED 
-# endif
-#endif
-
-/* internal SWIG method */
-#ifndef SWIGINTERN
-# define SWIGINTERN static SWIGUNUSED
-#endif
-
-/* internal inline SWIG method */
-#ifndef SWIGINTERNINLINE
-# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
-#endif
-
-/* exporting methods for Windows DLLs */
-#ifndef SWIGEXPORT
-# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#   if defined(STATIC_LINKED)
-#     define SWIGEXPORT
-#   else
-#     define SWIGEXPORT __declspec(dllexport)
-#   endif
-# else
-#   define SWIGEXPORT
-# endif
-#endif
-
-/* calling conventions for Windows */
-#ifndef SWIGSTDCALL
-# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#   define SWIGSTDCALL __stdcall
-# else
-#   define SWIGSTDCALL
-# endif 
-#endif
-
-
-
-#include <Python.h>
-
-/***********************************************************************
- * swigrun.swg
- *
- *     This file contains generic CAPI SWIG runtime support for pointer
- *     type checking.
- *
- ************************************************************************/
-
-/* This should only be incremented when either the layout of swig_type_info changes,
-   or for whatever reason, the runtime changes incompatibly */
-#define SWIG_RUNTIME_VERSION "2"
-
-/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
-#ifdef SWIG_TYPE_TABLE
-# define SWIG_QUOTE_STRING(x) #x
-# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
-# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
-#else
-# define SWIG_TYPE_TABLE_NAME
-#endif
-
-/*
-  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
-  creating a static or dynamic library from the swig runtime code.
-  In 99.9% of the cases, swig just needs to declare them as 'static'.
-  
-  But only do this if is strictly necessary, ie, if you have problems
-  with your compiler or so.
-*/
-
-#ifndef SWIGRUNTIME
-# define SWIGRUNTIME SWIGINTERN
-#endif
-
-#ifndef SWIGRUNTIMEINLINE
-# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
-#endif
-
-#include <string.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef void *(*swig_converter_func)(void *);
-typedef struct swig_type_info *(*swig_dycast_func)(void **);
-
-/* Structure to store inforomation on one type */
-typedef struct swig_type_info {
-  const char             *name;			/* mangled name of this type */
-  const char             *str;			/* human readable name of this type */
-  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
-  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
-  void                   *clientdata;		/* language specific type data */
-} swig_type_info;
-
-/* Structure to store a type and conversion function used for casting */
-typedef struct swig_cast_info {
-  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
-  swig_converter_func     converter;		/* function to cast the void pointers */
-  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
-  struct swig_cast_info  *prev;			/* pointer to the previous cast */
-} swig_cast_info;
-
-/* Structure used to store module information
- * Each module generates one structure like this, and the runtime collects
- * all of these structures and stores them in a circularly linked list.*/
-typedef struct swig_module_info {
-  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
-  size_t                 size;		        /* Number of types in this module */
-  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
-  swig_type_info         **type_initial;	/* Array of initially generated type structures */
-  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
-  void                    *clientdata;		/* Language specific module data */
-} swig_module_info;
-
-
-/* 
-  Compare two type names skipping the space characters, therefore
-  "char*" == "char *" and "Class<int>" == "Class<int >", etc.
-
-  Return 0 when the two name types are equivalent, as in
-  strncmp, but skipping ' '.
-*/
-SWIGRUNTIME int
-SWIG_TypeNameComp(const char *f1, const char *l1,
-		  const char *f2, const char *l2) {
-  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
-    while ((*f1 == ' ') && (f1 != l1)) ++f1;
-    while ((*f2 == ' ') && (f2 != l2)) ++f2;
-    if (*f1 != *f2) return (int)(*f1 - *f2);
-  }
-  return (l1 - f1) - (l2 - f2);
-}
-
-/*
-  Check type equivalence in a name list like <name1>|<name2>|...
-  Return 0 if not equal, 1 if equal
-*/
-SWIGRUNTIME int
-SWIG_TypeEquiv(const char *nb, const char *tb) {
-  int equiv = 0;
-  const char* te = tb + strlen(tb);
-  const char* ne = nb;
-  while (!equiv && *ne) {
-    for (nb = ne; *ne; ++ne) {
-      if (*ne == '|') break;
-    }
-    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
-    if (*ne) ++ne;
-  }
-  return equiv;
-}
-
-/*
-  Check type equivalence in a name list like <name1>|<name2>|...
-  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
-*/
-SWIGRUNTIME int
-SWIG_TypeCompare(const char *nb, const char *tb) {
-  int equiv = 0;
-  const char* te = tb + strlen(tb);
-  const char* ne = nb;
-  while (!equiv && *ne) {
-    for (nb = ne; *ne; ++ne) {
-      if (*ne == '|') break;
-    }
-    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
-    if (*ne) ++ne;
-  }
-  return equiv;
-}
-
-
-/* think of this as a c++ template<> or a scheme macro */
-#define SWIG_TypeCheck_Template(comparison, ty)         \
-  if (ty) {                                             \
-    swig_cast_info *iter = ty->cast;                    \
-    while (iter) {                                      \
-      if (comparison) {                                 \
-        if (iter == ty->cast) return iter;              \
-        /* Move iter to the top of the linked list */   \
-        iter->prev->next = iter->next;                  \
-        if (iter->next)                                 \
-          iter->next->prev = iter->prev;                \
-        iter->next = ty->cast;                          \
-        iter->prev = 0;                                 \
-        if (ty->cast) ty->cast->prev = iter;            \
-        ty->cast = iter;                                \
-        return iter;                                    \
-      }                                                 \
-      iter = iter->next;                                \
-    }                                                   \
-  }                                                     \
-  return 0
-
-/*
-  Check the typename
-*/
-SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheck(const char *c, swig_type_info *ty) {
-  SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);
-}
-
-/* Same as previous function, except strcmp is replaced with a pointer comparison */
-SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
-  SWIG_TypeCheck_Template(iter->type == from, into);
-}
-
-/*
-  Cast a pointer up an inheritance hierarchy
-*/
-SWIGRUNTIMEINLINE void *
-SWIG_TypeCast(swig_cast_info *ty, void *ptr) {
-  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr);
-}
-
-/* 
-   Dynamic pointer casting. Down an inheritance hierarchy
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
-  swig_type_info *lastty = ty;
-  if (!ty || !ty->dcast) return ty;
-  while (ty && (ty->dcast)) {
-    ty = (*ty->dcast)(ptr);
-    if (ty) lastty = ty;
-  }
-  return lastty;
-}
-
-/*
-  Return the name associated with this type
-*/
-SWIGRUNTIMEINLINE const char *
-SWIG_TypeName(const swig_type_info *ty) {
-  return ty->name;
-}
-
-/*
-  Return the pretty name associated with this type,
-  that is an unmangled type name in a form presentable to the user.
-*/
-SWIGRUNTIME const char *
-SWIG_TypePrettyName(const swig_type_info *type) {
-  /* The "str" field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
-  if (type->str != NULL) {
-    const char *last_name = type->str;
-    const char *s;
-    for (s = type->str; *s; s++)
-      if (*s == '|') last_name = s+1;
-    return last_name;
-  }
-  else
-    return type->name;
-}
-
-/* 
-   Set the clientdata field for a type
-*/
-SWIGRUNTIME void
-SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
-  if (!ti->clientdata) {
-    swig_cast_info *cast = ti->cast;
-    /* if (ti->clientdata == clientdata) return; */
-    ti->clientdata = clientdata;
-    
-    while (cast) {
-      if (!cast->converter)
-	SWIG_TypeClientData(cast->type, clientdata);
-      cast = cast->next;
-    }
-  }
-}
-
-/*
-  Search for a swig_type_info structure only by mangled name
-  Search is a O(log #types)
-  
-  We start searching at module start, and finish searching when start == end.  
-  Note: if start == end at the beginning of the function, we go all the way around
-  the circular list.
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_MangledTypeQueryModule(swig_module_info *start, 
-                            swig_module_info *end, 
-		            const char *name) {
-  swig_module_info *iter = start;
-  do {
-    if (iter->size) {
-      register size_t l = 0;
-      register size_t r = iter->size - 1;
-      do {
-	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
-	register size_t i = (l + r) >> 1; 
-	const char *iname = iter->types[i]->name;
-	if (iname) {
-	  register int compare = strcmp(name, iname);
-	  if (compare == 0) {	    
-	    return iter->types[i];
-	  } else if (compare < 0) {
-	    if (i) {
-	      r = i - 1;
-	    } else {
-	      break;
-	    }
-	  } else if (compare > 0) {
-	    l = i + 1;
-	  }
-	} else {
-	  break; /* should never happen */
-	}
-      } while (l <= r);
-    }
-    iter = iter->next;
-  } while (iter != end);
-  return 0;
-}
-
-/*
-  Search for a swig_type_info structure for either a mangled name or a human readable name.
-  It first searches the mangled names of the types, which is a O(log #types)
-  If a type is not found it then searches the human readable names, which is O(#types).
-  
-  We start searching at module start, and finish searching when start == end.  
-  Note: if start == end at the beginning of the function, we go all the way around
-  the circular list.
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_TypeQueryModule(swig_module_info *start, 
-                     swig_module_info *end, 
-		     const char *name) {
-  /* STEP 1: Search the name field using binary search */
-  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
-  if (ret) {
-    return ret;
-  } else {
-    /* STEP 2: If the type hasn't been found, do a complete search
-       of the str field (the human readable name) */
-    swig_module_info *iter = start;
-    do {
-      register size_t i = 0;
-      for (; i < iter->size; ++i) {
-	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
-	  return iter->types[i];
-      }
-      iter = iter->next;
-    } while (iter != end);
-  }
-  
-  /* neither found a match */
-  return 0;
-}
-
-
-/* 
-   Pack binary data into a string
-*/
-SWIGRUNTIME char *
-SWIG_PackData(char *c, void *ptr, size_t sz) {
-  static const char hex[17] = "0123456789abcdef";
-  register const unsigned char *u = (unsigned char *) ptr;
-  register const unsigned char *eu =  u + sz;
-  for (; u != eu; ++u) {
-    register unsigned char uu = *u;
-    *(c++) = hex[(uu & 0xf0) >> 4];
-    *(c++) = hex[uu & 0xf];
-  }
-  return c;
-}
-
-/* 
-   Unpack binary data from a string
-*/
-SWIGRUNTIME const char *
-SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
-  register unsigned char *u = (unsigned char *) ptr;
-  register const unsigned char *eu = u + sz;
-  for (; u != eu; ++u) {
-    register char d = *(c++);
-    register unsigned char uu = 0;
-    if ((d >= '0') && (d <= '9'))
-      uu = ((d - '0') << 4);
-    else if ((d >= 'a') && (d <= 'f'))
-      uu = ((d - ('a'-10)) << 4);
-    else 
-      return (char *) 0;
-    d = *(c++);
-    if ((d >= '0') && (d <= '9'))
-      uu |= (d - '0');
-    else if ((d >= 'a') && (d <= 'f'))
-      uu |= (d - ('a'-10));
-    else 
-      return (char *) 0;
-    *u = uu;
-  }
-  return c;
-}
-
-/* 
-   Pack 'void *' into a string buffer.
-*/
-SWIGRUNTIME char *
-SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
-  char *r = buff;
-  if ((2*sizeof(void *) + 2) > bsz) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r,&ptr,sizeof(void *));
-  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
-  strcpy(r,name);
-  return buff;
-}
-
-SWIGRUNTIME const char *
-SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
-  if (*c != '_') {
-    if (strcmp(c,"NULL") == 0) {
-      *ptr = (void *) 0;
-      return name;
-    } else {
-      return 0;
-    }
-  }
-  return SWIG_UnpackData(++c,ptr,sizeof(void *));
-}
-
-SWIGRUNTIME char *
-SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
-  char *r = buff;
-  size_t lname = (name ? strlen(name) : 0);
-  if ((2*sz + 2 + lname) > bsz) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r,ptr,sz);
-  if (lname) {
-    strncpy(r,name,lname+1);
-  } else {
-    *r = 0;
-  }
-  return buff;
-}
-
-SWIGRUNTIME const char *
-SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
-  if (*c != '_') {
-    if (strcmp(c,"NULL") == 0) {
-      memset(ptr,0,sz);
-      return name;
-    } else {
-      return 0;
-    }
-  }
-  return SWIG_UnpackData(++c,ptr,sz);
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-/* -----------------------------------------------------------------------------
- * SWIG API. Portion that goes into the runtime
- * ----------------------------------------------------------------------------- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* -----------------------------------------------------------------------------
- * for internal method declarations
- * ----------------------------------------------------------------------------- */
-
-#ifndef SWIGINTERN
-#  define SWIGINTERN static SWIGUNUSED
-#endif
-
-#ifndef SWIGINTERNINLINE
-#  define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
-#endif
-
-/*
-  Exception handling in wrappers
-*/
-#define SWIG_fail                goto fail
-#define SWIG_arg_fail(arg)       SWIG_Python_ArgFail(arg)
-#define SWIG_append_errmsg(msg)   SWIG_Python_AddErrMesg(msg,0)
-#define SWIG_preppend_errmsg(msg) SWIG_Python_AddErrMesg(msg,1)
-#define SWIG_type_error(type,obj) SWIG_Python_TypeError(type,obj)
-#define SWIG_null_ref(type)       SWIG_Python_NullRef(type)
-
-/*
-  Contract support
-*/
-#define SWIG_contract_assert(expr, msg) \
- if (!(expr)) { PyErr_SetString(PyExc_RuntimeError, (char *) msg ); goto fail; } else
-
-/* -----------------------------------------------------------------------------
- * Constant declarations
- * ----------------------------------------------------------------------------- */
-
-/* Constant Types */
-#define SWIG_PY_INT     1
-#define SWIG_PY_FLOAT   2
-#define SWIG_PY_STRING  3
-#define SWIG_PY_POINTER 4
-#define SWIG_PY_BINARY  5
-
-/* Constant information structure */
-typedef struct swig_const_info {
-    int type;
-    char *name;
-    long lvalue;
-    double dvalue;
-    void   *pvalue;
-    swig_type_info **ptype;
-} swig_const_info;
-
-
-/* -----------------------------------------------------------------------------
- * Alloc. memory flags
- * ----------------------------------------------------------------------------- */
-#define SWIG_OLDOBJ  1
-#define SWIG_NEWOBJ  SWIG_OLDOBJ + 1
-#define SWIG_PYSTR   SWIG_NEWOBJ + 1
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/***********************************************************************
- * pyrun.swg
- *
- *     This file contains the runtime support for Python modules
- *     and includes code for managing global variables and pointer
- *     type checking.
- *
- * Author : David Beazley (beazley at cs.uchicago.edu)
- ************************************************************************/
-
-/* Common SWIG API */
-#define SWIG_ConvertPtr(obj, pp, type, flags)    SWIG_Python_ConvertPtr(obj, pp, type, flags)
-#define SWIG_NewPointerObj(p, type, flags)       SWIG_Python_NewPointerObj(p, type, flags)
-#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)
- 
-
-/* Python-specific SWIG API */
-#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags)   SWIG_Python_ConvertPacked(obj, ptr, sz, ty, flags)
-#define SWIG_NewPackedObj(ptr, sz, type)              SWIG_Python_NewPackedObj(ptr, sz, type)
-
-/* Runtime API */
-#define SWIG_GetModule(clientdata) SWIG_Python_GetModule()
-#define SWIG_SetModule(clientdata, pointer) SWIG_Python_SetModule(pointer)
-
-/* -----------------------------------------------------------------------------
- * Pointer declarations
- * ----------------------------------------------------------------------------- */
-/*
-  Use SWIG_NO_COBJECT_TYPES to force the use of strings to represent
-  C/C++ pointers in the python side. Very useful for debugging, but
-  not always safe.
-*/
-#if !defined(SWIG_NO_COBJECT_TYPES) && !defined(SWIG_COBJECT_TYPES)
-#  define SWIG_COBJECT_TYPES
-#endif
-
-/* Flags for pointer conversion */
-#define SWIG_POINTER_EXCEPTION     0x1
-#define SWIG_POINTER_DISOWN        0x2
-
-
-/* Add PyOS_snprintf for old Pythons */
-#if PY_VERSION_HEX < 0x02020000
-#define PyOS_snprintf snprintf
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* -----------------------------------------------------------------------------
- * Create a new pointer string 
- * ----------------------------------------------------------------------------- */
-#ifndef SWIG_BUFFER_SIZE
-#define SWIG_BUFFER_SIZE 1024
-#endif
-
-#if defined(SWIG_COBJECT_TYPES)
-#if !defined(SWIG_COBJECT_PYTHON)
-/* -----------------------------------------------------------------------------
- * Implements a simple Swig Object type, and use it instead of PyCObject
- * ----------------------------------------------------------------------------- */
-
-typedef struct {
-  PyObject_HEAD
-  void *ptr;
-  const char *desc;
-} PySwigObject;
-
-/* Declarations for objects of type PySwigObject */
-
-SWIGRUNTIME int
-PySwigObject_print(PySwigObject *v, FILE *fp, int flags)
-{
-  char result[SWIG_BUFFER_SIZE];
-  flags = flags;
-  if (SWIG_PackVoidPtr(result, v->ptr, v->desc, sizeof(result))) {
-    fputs("<Swig Object at ", fp); fputs(result, fp); fputs(">", fp);
-    return 0; 
-  } else {
-    return 1; 
-  }
-}
-  
-SWIGRUNTIME PyObject *
-PySwigObject_repr(PySwigObject *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  return SWIG_PackVoidPtr(result, v->ptr, v->desc, sizeof(result)) ?
-    PyString_FromFormat("<Swig Object at %s>", result) : 0;
-}
-
-SWIGRUNTIME PyObject *
-PySwigObject_str(PySwigObject *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  return SWIG_PackVoidPtr(result, v->ptr, v->desc, sizeof(result)) ?
-    PyString_FromString(result) : 0;
-}
-
-SWIGRUNTIME PyObject *
-PySwigObject_long(PySwigObject *v)
-{
-  return PyLong_FromVoidPtr(v->ptr);
-}
-
-SWIGRUNTIME PyObject *
-PySwigObject_format(const char* fmt, PySwigObject *v)
-{
-  PyObject *res = NULL;
-  PyObject *args = PyTuple_New(1);
-  if (args && (PyTuple_SetItem(args, 0, PySwigObject_long(v)) == 0)) {
-    PyObject *ofmt = PyString_FromString(fmt);
-    if (ofmt) {
-      res = PyString_Format(ofmt,args);
-      Py_DECREF(ofmt);
-    }
-    Py_DECREF(args);
-  }  
-  return res;
-}
-
-SWIGRUNTIME PyObject *
-PySwigObject_oct(PySwigObject *v)
-{
-  return PySwigObject_format("%o",v);
-}
-
-SWIGRUNTIME PyObject *
-PySwigObject_hex(PySwigObject *v)
-{
-  return PySwigObject_format("%x",v);
-}
-
-SWIGRUNTIME int
-PySwigObject_compare(PySwigObject *v, PySwigObject *w)
-{
-  int c = strcmp(v->desc, w->desc);
-  if (c) {
-    return (c > 0) ? 1 : -1;
-  } else {
-    void *i = v->ptr;
-    void *j = w->ptr;
-    return (i < j) ? -1 : ((i > j) ? 1 : 0);
-  }
-}
-
-SWIGRUNTIME void
-PySwigObject_dealloc(PySwigObject *self)
-{
-  PyObject_DEL(self);
-}
-
-SWIGRUNTIME PyTypeObject*
-PySwigObject_type(void) {
-  static char pyswigobject_type__doc__[] = 
-    "Swig object carries a C/C++ instance pointer";
-  
-  static PyNumberMethods PySwigObject_as_number = {
-    (binaryfunc)0, /*nb_add*/
-    (binaryfunc)0, /*nb_subtract*/
-    (binaryfunc)0, /*nb_multiply*/
-    (binaryfunc)0, /*nb_divide*/
-    (binaryfunc)0, /*nb_remainder*/
-    (binaryfunc)0, /*nb_divmod*/
-    (ternaryfunc)0,/*nb_power*/
-    (unaryfunc)0,  /*nb_negative*/
-    (unaryfunc)0,  /*nb_positive*/
-    (unaryfunc)0,  /*nb_absolute*/
-    (inquiry)0,    /*nb_nonzero*/
-    0,		   /*nb_invert*/
-    0,		   /*nb_lshift*/
-    0,		   /*nb_rshift*/
-    0,		   /*nb_and*/
-    0,		   /*nb_xor*/
-    0,		   /*nb_or*/
-    (coercion)0,   /*nb_coerce*/
-    (unaryfunc)PySwigObject_long, /*nb_int*/
-    (unaryfunc)PySwigObject_long, /*nb_long*/
-    (unaryfunc)0,                 /*nb_float*/
-    (unaryfunc)PySwigObject_oct,  /*nb_oct*/
-    (unaryfunc)PySwigObject_hex,  /*nb_hex*/
-#if PY_VERSION_HEX >= 0x02000000
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */ 
-#endif
-  };
-
-  static PyTypeObject pyswigobject_type
-#if !defined(__cplusplus)
-  ;  
-  static int type_init = 0;
-  if (!type_init) {
-    PyTypeObject tmp
-#endif
-    = {
-    PyObject_HEAD_INIT(&PyType_Type)
-    0,					/*ob_size*/
-    (char *)"PySwigObject",		/*tp_name*/
-    sizeof(PySwigObject),		/*tp_basicsize*/
-    0,					/*tp_itemsize*/
-    /* methods */
-    (destructor)PySwigObject_dealloc,	/*tp_dealloc*/
-    (printfunc)PySwigObject_print,	/*tp_print*/
-    (getattrfunc)0,			/*tp_getattr*/
-    (setattrfunc)0,			/*tp_setattr*/
-    (cmpfunc)PySwigObject_compare,	/*tp_compare*/
-    (reprfunc)PySwigObject_repr,	/*tp_repr*/
-    &PySwigObject_as_number,	        /*tp_as_number*/
-    0,					/*tp_as_sequence*/
-    0,					/*tp_as_mapping*/
-    (hashfunc)0,			/*tp_hash*/
-    (ternaryfunc)0,			/*tp_call*/
-    (reprfunc)PySwigObject_str,		/*tp_str*/
-    /* Space for future expansion */
-    0,0,0,0,
-    pyswigobject_type__doc__, 	        /* Documentation string */
-#if PY_VERSION_HEX >= 0x02000000
-    0,                                  /* tp_traverse */
-    0,                                  /* tp_clear */
-#endif
-#if PY_VERSION_HEX >= 0x02010000
-    0,                                  /* tp_richcompare */
-    0,                                  /* tp_weaklistoffset */
-#endif
-#if PY_VERSION_HEX >= 0x02020000
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
-#endif
-#if PY_VERSION_HEX >= 0x02030000
-    0,                                  /* tp_del */
-#endif
-#ifdef COUNT_ALLOCS
-    0,0,0,0                             /* tp_alloc -> tp_next */
-#endif
-    };
-#if !defined(__cplusplus)
-    pyswigobject_type = tmp;
-    type_init = 1;
-  }
-#endif
-  return &pyswigobject_type;
-}
-
-SWIGRUNTIME PyObject *
-PySwigObject_FromVoidPtrAndDesc(void *ptr, const char *desc)
-{
-  PySwigObject *self = PyObject_NEW(PySwigObject, PySwigObject_type());
-  if (self) {
-    self->ptr = ptr;
-    self->desc = desc;
-  }
-  return (PyObject *)self;
-}
-
-SWIGRUNTIMEINLINE void *
-PySwigObject_AsVoidPtr(PyObject *self)
-{
-  return ((PySwigObject *)self)->ptr;
-}
-
-SWIGRUNTIMEINLINE const char *
-PySwigObject_GetDesc(PyObject *self)
-{
-  return ((PySwigObject *)self)->desc;
-}
-
-SWIGRUNTIMEINLINE int
-PySwigObject_Check(PyObject *op) {
-  return ((op)->ob_type == PySwigObject_type()) 
-    || (strcmp((op)->ob_type->tp_name,"PySwigObject") == 0);
-}
-
-/* -----------------------------------------------------------------------------
- * Implements a simple Swig Packed type, and use it instead of string
- * ----------------------------------------------------------------------------- */
-
-typedef struct {
-  PyObject_HEAD
-  void *pack;
-  const char *desc;
-  size_t size;
-} PySwigPacked;
-
-SWIGRUNTIME int
-PySwigPacked_print(PySwigPacked *v, FILE *fp, int flags)
-{
-  char result[SWIG_BUFFER_SIZE];
-  flags = flags;
-  fputs("<Swig Packed ", fp); 
-  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
-    fputs("at ", fp); 
-    fputs(result, fp); 
-  }
-  fputs(v->desc,fp); 
-  fputs(">", fp);
-  return 0; 
-}
-  
-SWIGRUNTIME PyObject *
-PySwigPacked_repr(PySwigPacked *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
-    return PyString_FromFormat("<Swig Packed at %s%s>", result, v->desc);
-  } else {
-    return PyString_FromFormat("<Swig Packed %s>", v->desc);
-  }  
-}
-
-SWIGRUNTIME PyObject *
-PySwigPacked_str(PySwigPacked *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
-    return PyString_FromFormat("%s%s", result, v->desc);
-  } else {
-    return PyString_FromFormat("%s", v->desc);
-  }  
-}
-
-SWIGRUNTIME int
-PySwigPacked_compare(PySwigPacked *v, PySwigPacked *w)
-{
-  int c = strcmp(v->desc, w->desc);
-  if (c) {
-    return (c > 0) ? 1 : -1;
-  } else {
-    size_t i = v->size;
-    size_t j = w->size;
-    int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
-    return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);
-  }
-}
-
-SWIGRUNTIME void
-PySwigPacked_dealloc(PySwigPacked *self)
-{
-  free(self->pack);
-  PyObject_DEL(self);
-}
-
-SWIGRUNTIME PyTypeObject*
-PySwigPacked_type(void) {
-  static char pyswigpacked_type__doc__[] = 
-    "Swig object carries a C/C++ instance pointer";
-  static PyTypeObject pyswigpacked_type
-#if !defined(__cplusplus)
-  ;
-  static int type_init = 0;  
-  if (!type_init) {
-    PyTypeObject tmp
-#endif
-    = {
-    PyObject_HEAD_INIT(&PyType_Type)
-    0,					/*ob_size*/
-    (char *)"PySwigPacked",		/*tp_name*/
-    sizeof(PySwigPacked),		/*tp_basicsize*/
-    0,					/*tp_itemsize*/
-    /* methods */
-    (destructor)PySwigPacked_dealloc,	/*tp_dealloc*/
-    (printfunc)PySwigPacked_print,	/*tp_print*/
-    (getattrfunc)0,			/*tp_getattr*/
-    (setattrfunc)0,			/*tp_setattr*/
-    (cmpfunc)PySwigPacked_compare,	/*tp_compare*/
-    (reprfunc)PySwigPacked_repr,	/*tp_repr*/
-    0,	                                /*tp_as_number*/
-    0,					/*tp_as_sequence*/
-    0,					/*tp_as_mapping*/
-    (hashfunc)0,			/*tp_hash*/
-    (ternaryfunc)0,			/*tp_call*/
-    (reprfunc)PySwigPacked_str,		/*tp_str*/
-    /* Space for future expansion */
-    0,0,0,0,
-    pyswigpacked_type__doc__, 	        /* Documentation string */
-#if PY_VERSION_HEX >= 0x02000000
-    0,                                  /* tp_traverse */
-    0,                                  /* tp_clear */
-#endif
-#if PY_VERSION_HEX >= 0x02010000
-    0,                                  /* tp_richcompare */
-    0,                                  /* tp_weaklistoffset */
-#endif
-#if PY_VERSION_HEX >= 0x02020000         
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
-#endif
-#if PY_VERSION_HEX >= 0x02030000
-    0,                                  /* tp_del */
-#endif
-#ifdef COUNT_ALLOCS
-    0,0,0,0                             /* tp_alloc -> tp_next */
-#endif
-    };
-#if !defined(__cplusplus)
-    pyswigpacked_type = tmp;
-    type_init = 1;
-  }
-#endif
-  return &pyswigpacked_type;
-}
-
-SWIGRUNTIME PyObject *
-PySwigPacked_FromDataAndDesc(void *ptr, size_t size, const char *desc)
-{
-  PySwigPacked *self = PyObject_NEW(PySwigPacked, PySwigPacked_type());
-  if (self == NULL) {
-    return NULL;
-  } else {
-    void *pack = malloc(size);
-    if (pack) {
-      memcpy(pack, ptr, size);
-      self->pack = pack;
-      self->desc = desc;
-      self->size = size;
-      return (PyObject *) self;
-    }
-    return NULL;
-  }
-}
-
-SWIGRUNTIMEINLINE const char *
-PySwigPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
-{
-  PySwigPacked *self = (PySwigPacked *)obj;
-  if (self->size != size) return 0;
-  memcpy(ptr, self->pack, size);
-  return self->desc;
-}
-
-SWIGRUNTIMEINLINE const char *
-PySwigPacked_GetDesc(PyObject *self)
-{
-  return ((PySwigPacked *)self)->desc;
-}
-
-SWIGRUNTIMEINLINE int
-PySwigPacked_Check(PyObject *op) {
-  return ((op)->ob_type == PySwigPacked_type()) 
-    || (strcmp((op)->ob_type->tp_name,"PySwigPacked") == 0);
-}
-
-#else
-/* -----------------------------------------------------------------------------
- * Use the old Python PyCObject instead of PySwigObject
- * ----------------------------------------------------------------------------- */
-
-#define PySwigObject_GetDesc(obj)	           PyCObject_GetDesc(obj)
-#define PySwigObject_Check(obj)	           PyCObject_Check(obj)
-#define PySwigObject_AsVoidPtr(obj)	   PyCObject_AsVoidPtr(obj)
-#define PySwigObject_FromVoidPtrAndDesc(p, d)  PyCObject_FromVoidPtrAndDesc(p, d, NULL)
-
-#endif
-
-#endif
-
-/* -----------------------------------------------------------------------------
- * errors manipulation
- * ----------------------------------------------------------------------------- */
-
-SWIGRUNTIME void
-SWIG_Python_TypeError(const char *type, PyObject *obj)
-{
-  if (type) {
-#if defined(SWIG_COBJECT_TYPES)
-    if (obj && PySwigObject_Check(obj)) {
-      const char *otype = (const char *) PySwigObject_GetDesc(obj);
-      if (otype) {
-	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'PySwigObject(%s)' is received",
-		     type, otype);
-	return;
-      }
-    } else 
-#endif      
-    {
-      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
-      if (otype) {
-	PyObject *str = PyObject_Str(obj);
-	const char *cstr = str ? PyString_AsString(str) : 0;
-	if (cstr) {
-	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
-		       type, otype, cstr);
-	} else {
-	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
-		       type, otype);
-	}
-	Py_XDECREF(str);
-	return;
-      }
-    }   
-    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
-  } else {
-    PyErr_Format(PyExc_TypeError, "unexpected type is received");
-  }
-}
-
-SWIGRUNTIMEINLINE void
-SWIG_Python_NullRef(const char *type)
-{
-  if (type) {
-    PyErr_Format(PyExc_TypeError, "null reference of type '%s' was received",type);
-  } else {
-    PyErr_Format(PyExc_TypeError, "null reference was received");
-  }
-}
-
-SWIGRUNTIME int
-SWIG_Python_AddErrMesg(const char* mesg, int infront)
-{
-  if (PyErr_Occurred()) {
-    PyObject *type = 0;
-    PyObject *value = 0;
-    PyObject *traceback = 0;
-    PyErr_Fetch(&type, &value, &traceback);
-    if (value) {
-      PyObject *old_str = PyObject_Str(value);
-      Py_XINCREF(type);
-      PyErr_Clear();
-      if (infront) {
-	PyErr_Format(type, "%s %s", mesg, PyString_AsString(old_str));
-      } else {
-	PyErr_Format(type, "%s %s", PyString_AsString(old_str), mesg);
-      }
-      Py_DECREF(old_str);
-    }
-    return 1;
-  } else {
-    return 0;
-  }
-}
-
-SWIGRUNTIME int
-SWIG_Python_ArgFail(int argnum)
-{
-  if (PyErr_Occurred()) {
-    /* add information about failing argument */
-    char mesg[256];
-    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
-    return SWIG_Python_AddErrMesg(mesg, 1);
-  } else {
-    return 0;
-  }
-}
-
-
-/* -----------------------------------------------------------------------------
- * pointers/data manipulation
- * ----------------------------------------------------------------------------- */
-
-/* Convert a pointer value */
-SWIGRUNTIME int
-SWIG_Python_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
-  swig_cast_info *tc;
-  const char *c = 0;
-  static PyObject *SWIG_this = 0;
-  int    newref = 0;
-  PyObject  *pyobj = 0;
-  void *vptr;
-  
-  if (!obj) return 0;
-  if (obj == Py_None) {
-    *ptr = 0;
-    return 0;
-  }
-
-#ifdef SWIG_COBJECT_TYPES
-  if (!(PySwigObject_Check(obj))) {
-    if (!SWIG_this)
-      SWIG_this = PyString_FromString("this");
-    pyobj = obj;
-    obj = PyObject_GetAttr(obj,SWIG_this);
-    newref = 1;
-    if (!obj) goto type_error;
-    if (!PySwigObject_Check(obj)) {
-      Py_DECREF(obj);
-      goto type_error;
-    }
-  }  
-  vptr = PySwigObject_AsVoidPtr(obj);
-  c = (const char *) PySwigObject_GetDesc(obj);
-  if (newref) { Py_DECREF(obj); }
-  goto type_check;
-#else
-  if (!(PyString_Check(obj))) {
-    if (!SWIG_this)
-      SWIG_this = PyString_FromString("this");
-    pyobj = obj;
-    obj = PyObject_GetAttr(obj,SWIG_this);
-    newref = 1;
-    if (!obj) goto type_error;
-    if (!PyString_Check(obj)) {
-      Py_DECREF(obj);
-      goto type_error;
-    }
-  } 
-  c = PyString_AS_STRING(obj);
-  /* Pointer values must start with leading underscore */
-  c = SWIG_UnpackVoidPtr(c, &vptr, ty->name);
-  if (newref) { Py_DECREF(obj); }
-  if (!c) goto type_error;
-#endif
-
-type_check:
-  if (ty) {
-    tc = SWIG_TypeCheck(c,ty);
-    if (!tc) goto type_error;
-    *ptr = SWIG_TypeCast(tc,vptr);
-  } else {
-    *ptr = vptr;
-  }
-  if ((pyobj) && (flags & SWIG_POINTER_DISOWN)) {
-    PyObject_SetAttrString(pyobj,(char*)"thisown",Py_False);
-  }
-  return 0;
-
-type_error:
-  PyErr_Clear();
-  if (pyobj && !obj) {    
-    obj = pyobj;
-    if (PyCFunction_Check(obj)) {
-      /* here we get the method pointer for callbacks */
-      char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
-      c = doc ? strstr(doc, "swig_ptr: ") : 0;
-      if (c) {
-	c = ty ? SWIG_UnpackVoidPtr(c + 10, &vptr, ty->name) : 0;
-	if (!c) goto type_error;
-	goto type_check;
-      }
-    }
-  }
-  if (flags & SWIG_POINTER_EXCEPTION) {
-    if (ty) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-    } else {
-      SWIG_Python_TypeError("C/C++ pointer", obj);
-    }
-  }
-  return -1;
-}
-
-/* Convert a pointer value, signal an exception on a type mismatch */
-SWIGRUNTIME void *
-SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
-  void *result;
-  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
-    PyErr_Clear();
-    if (flags & SWIG_POINTER_EXCEPTION) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-      SWIG_Python_ArgFail(argnum);
-    }
-  }
-  return result;
-}
-
-/* Convert a packed value value */
-SWIGRUNTIME int
-SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty, int flags) {
-  swig_cast_info *tc;
-  const char *c = 0;
-
-#if defined(SWIG_COBJECT_TYPES) && !defined(SWIG_COBJECT_PYTHON)
-  c = PySwigPacked_UnpackData(obj, ptr, sz);
-#else
-  if ((!obj) || (!PyString_Check(obj))) goto type_error;
-  c = PyString_AS_STRING(obj);
-  /* Pointer values must start with leading underscore */
-  c = SWIG_UnpackDataName(c, ptr, sz, ty->name);
-#endif
-  if (!c) goto type_error;
-  if (ty) {
-    tc = SWIG_TypeCheck(c,ty);
-    if (!tc) goto type_error;
-  }
-  return 0;
-
-type_error:
-  PyErr_Clear();
-  if (flags & SWIG_POINTER_EXCEPTION) {
-    if (ty) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-    } else {
-      SWIG_Python_TypeError("C/C++ packed data", obj);
-    }
-  }
-  return -1;
-}  
-
-/* Create a new array object */
-SWIGRUNTIME PyObject *
-SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int own) {
-  PyObject *robj = 0;
-  if (!type) {
-    if (!PyErr_Occurred()) {
-      PyErr_Format(PyExc_TypeError, "Swig: null type passed to NewPointerObj");
-    }
-    return robj;
-  }
-  if (!ptr) {
-    Py_INCREF(Py_None);
-    return Py_None;
-  }
-#ifdef SWIG_COBJECT_TYPES
-  robj = PySwigObject_FromVoidPtrAndDesc((void *) ptr, (char *)type->name);
-#else
-  {
-    char result[SWIG_BUFFER_SIZE];
-    robj = SWIG_PackVoidPtr(result, ptr, type->name, sizeof(result)) ?
-      PyString_FromString(result) : 0;
-  }
-#endif
-  if (!robj || (robj == Py_None)) return robj;
-  if (type->clientdata) {
-    PyObject *inst;
-    PyObject *args = Py_BuildValue((char*)"(O)", robj);
-    Py_DECREF(robj);
-    inst = PyObject_CallObject((PyObject *) type->clientdata, args);
-    Py_DECREF(args);
-    if (inst) {
-      if (own) {
-        PyObject_SetAttrString(inst,(char*)"thisown",Py_True);
-      }
-      robj = inst;
-    }
-  }
-  return robj;
-}
-
-SWIGRUNTIME PyObject *
-SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
-  PyObject *robj = 0;
-  if (!ptr) {
-    Py_INCREF(Py_None);
-    return Py_None;
-  }
-#if defined(SWIG_COBJECT_TYPES) && !defined(SWIG_COBJECT_PYTHON)
-  robj = PySwigPacked_FromDataAndDesc((void *) ptr, sz, (char *)type->name);
-#else
-  {
-    char result[SWIG_BUFFER_SIZE];
-    robj = SWIG_PackDataName(result, ptr, sz, type->name, sizeof(result)) ?
-      PyString_FromString(result) : 0;
-  }
-#endif
-  return robj;
-}
-
-/* -----------------------------------------------------------------------------*
- *  Get type list 
- * -----------------------------------------------------------------------------*/
-
-#ifdef SWIG_LINK_RUNTIME
-void *SWIG_ReturnGlobalTypeList(void *);
-#endif
-
-SWIGRUNTIME swig_module_info *
-SWIG_Python_GetModule(void) {
-  static void *type_pointer = (void *)0;
-  /* first check if module already created */
-  if (!type_pointer) {
-#ifdef SWIG_LINK_RUNTIME
-    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
-#else
-    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
-				    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      type_pointer = (void *)0;
-    }
-  }
-#endif
-  return (swig_module_info *) type_pointer;
-}
-
-SWIGRUNTIME void
-SWIG_Python_SetModule(swig_module_info *swig_module) {
-  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} };/* Sentinel */
-
-  PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
-				   swig_empty_runtime_method_table);
-  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, NULL);
-  if (pointer && module) {
-    PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);
-  }
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/* -------- TYPES TABLE (BEGIN) -------- */
-
-#define SWIGTYPE_p_DialogApi swig_types[0]
-#define SWIGTYPE_p_EventManager swig_types[1]
-#define SWIGTYPE_p_GameAction swig_types[2]
-#define SWIGTYPE_p_GameConfig swig_types[3]
-#define SWIGTYPE_p_SoundSystem swig_types[4]
-#define SWIGTYPE_p_allocator_type swig_types[5]
-#define SWIGTYPE_p_boost__shared_ptrTSpaceLocation_t swig_types[6]
-#define SWIGTYPE_p_boost__shared_ptrTTGameEvent_t swig_types[7]
-#define SWIGTYPE_p_char swig_types[8]
-#define SWIGTYPE_p_difference_type swig_types[9]
-#define SWIGTYPE_p_size_type swig_types[10]
-#define SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t swig_types[11]
-#define SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type swig_types[12]
-#define SWIGTYPE_p_value_type swig_types[13]
-#define SWIGTYPE_ptrdiff_t swig_types[14]
-#define SWIGTYPE_size_t swig_types[15]
-#define SWIGTYPE_std__ptrdiff_t swig_types[16]
-#define SWIGTYPE_std__size_t swig_types[17]
-static swig_type_info *swig_types[18];
-static swig_module_info swig_module = {swig_types, 18, 0, 0, 0, 0};
-#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
-#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
-
-/* -------- TYPES TABLE (END) -------- */
-
-
-/*-----------------------------------------------
-              @(target):= _tml.so
-  ------------------------------------------------*/
-#define SWIG_init    init_tml
-
-#define SWIG_name    "_tml"
-
-#include "tml/gameaction.h"
-#include "tml/gamedialog.h"
-#include "tml/gameconfig.h"
-#include "tml/eventmanager.h"
-#include "util/sound.h"
-
-
-#include <string>
-
-
-  
-#if defined(__SUNPRO_CC) 
-#define SWIG_STD_NOASSIGN_STL
-#define SWIG_STD_NOINSERT_TEMPLATE_STL
-#endif
-
-
-
-#include <string>
-#include <stdexcept>
-
-
-#include <utility>
-
-
-/* returns SWIG_OLDOBJ if the input is a raw char*, SWIG_PYSTR if is a PyString */
-SWIGINTERN int
-SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize)
-{
-  static swig_type_info* pchar_info = 0;
-  char* vptr = 0;
-  if (!pchar_info) pchar_info = SWIG_TypeQuery("char *");
-  if (SWIG_ConvertPtr(obj, (void**)&vptr, pchar_info, 0) != -1) {
-    if (cptr) *cptr = vptr;
-    if (psize) *psize = vptr ? (strlen(vptr) + 1) : 0;
-    return SWIG_OLDOBJ;
-  } else {
-    PyErr_Clear();
-    if (PyString_Check(obj)) {
-      if (cptr) {
-	*cptr = PyString_AS_STRING(obj);
-	if (psize) {
-	  *psize = PyString_GET_SIZE(obj) + 1;
-	}
-      }
-      return SWIG_PYSTR;
-    }
-  }
-  if (cptr) {
-    SWIG_type_error("char *", obj);
-  }
-  return 0;
-}
-
-
-  SWIGINTERN int
-    SWIG_AsPtr_std_string(PyObject* obj, std::string **val)
-    {
-      static swig_type_info* string_info = SWIG_TypeQuery("std::string *");
-      std::string *vptr;    
-      if (SWIG_ConvertPtr(obj, (void**)&vptr, string_info, 0) != -1) {
-	if (val) *val = vptr;
-	return SWIG_OLDOBJ;
-      } else {
-	PyErr_Clear();
-	char* buf = 0 ; size_t size = 0;
-	if (SWIG_AsCharPtrAndSize(obj, &buf, &size)) {
-	  if (buf) {
-	    if (val) *val = new std::string(buf, size - 1);
-	    return SWIG_NEWOBJ;
-	  }
-	} else {
-	  PyErr_Clear();
-	}  
-	if (val) {
-	  PyErr_SetString(PyExc_TypeError,"a string is expected");
-	}
-	return 0;
-      }
-    }
-
-
-SWIGINTERN int
-  SWIG_AsVal_double(PyObject *obj, double *val)
-{
-  if (PyFloat_Check(obj)) {
-    if (val) *val = PyFloat_AS_DOUBLE(obj);
-    return 1;
-  }  
-  if (PyInt_Check(obj)) {
-    if (val) *val = PyInt_AS_LONG(obj);
-    return 1;
-  }
-  if (PyLong_Check(obj)) {
-    double v = PyLong_AsDouble(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = v;
-      return 1;
-    } else {
-      if (!val) PyErr_Clear();
-      return 0;
-    }
-  }
-  if (val) {
-    SWIG_type_error("double", obj);
-  }
-  return 0;
-}
-
-
-SWIGINTERNINLINE double
-SWIG_As_double(PyObject* obj)
-{
-  double v;
-  if (!SWIG_AsVal_double(obj, &v)) {
-    /*
-      this is needed to make valgrind/purify happier. 
-     */
-    memset((void*)&v, 0, sizeof(double));
-  }
-  return v;
-}
-
-  
-SWIGINTERNINLINE int
-SWIG_Check_double(PyObject* obj)
-{
-  return SWIG_AsVal_double(obj, (double*)0);
-}
-
-
-  /*@c:\\swig\\Lib\\python\\pymacros.swg,66,SWIG_define@*/
-#define SWIG_From_int PyInt_FromLong
-/*@@*/
-
-
-SWIGINTERNINLINE PyObject *
-SWIG_FromCharArray(const char* carray, size_t size)
-{
-  if (size > INT_MAX) {
-    return SWIG_NewPointerObj((char *)(carray), 
-			      SWIG_TypeQuery("char *"), 0);
-  } else {
-    return PyString_FromStringAndSize(carray, (int)(size));
-  }
-}
-
-
-SWIGINTERNINLINE PyObject*
-  SWIG_From_std_string(const std::string& s)
-  {
-    return SWIG_FromCharArray(s.data(), s.size());
-  }
-
-
-  /*@c:\\swig\\Lib\\python\\pymacros.swg,66,SWIG_define@*/
-#define SWIG_From_double PyFloat_FromDouble
-/*@@*/
-
-
-SWIGINTERNINLINE PyObject*
-  SWIG_From_bool(bool value)
-{
-  PyObject *obj = value ? Py_True : Py_False;
-  Py_INCREF(obj);
-  return obj;
-}
-
-
-#include <limits.h>
-
-
-SWIGINTERN int
-  SWIG_CheckLongInRange(long value, long min_value, long max_value,
-			const char *errmsg)
-{
-  if (value < min_value) {
-    if (errmsg) {
-      PyErr_Format(PyExc_OverflowError, 
-		   "value %ld is less than '%s' minimum %ld", 
-		   value, errmsg, min_value);
-    }
-    return 0;    
-  } else if (value > max_value) {
-    if (errmsg) {
-      PyErr_Format(PyExc_OverflowError,
-		   "value %ld is greater than '%s' maximum %ld", 
-		   value, errmsg, max_value);
-    }
-    return 0;
-  }
-  return 1;
-}
-
-
-SWIGINTERN int
-  SWIG_AsVal_long(PyObject * obj, long* val)
-{
-  if (PyInt_Check(obj)) {
-    if (val) *val = PyInt_AS_LONG(obj);
-    return 1;
-  }
-  if (PyLong_Check(obj)) {
-    long v = PyLong_AsLong(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = v;
-      return 1;
-    } else {
-      if (!val) PyErr_Clear();
-      return 0;
-    }
-  }
-  if (val) {
-    SWIG_type_error("long", obj);
-  }
-  return 0;
- }
-
-
-#if INT_MAX != LONG_MAX
-SWIGINTERN int
-  SWIG_AsVal_int(PyObject *obj, int *val)
-{ 
-  const char* errmsg = val ? "int" : (char*)0;
-  long v;
-  if (SWIG_AsVal_long(obj, &v)) {
-    if (SWIG_CheckLongInRange(v, INT_MIN,INT_MAX, errmsg)) {
-      if (val) *val = (int)(v);
-      return 1;
-    } else {
-      return 0;
-    }
-  } else {
-    PyErr_Clear();
-  }
-  if (val) {
-    SWIG_type_error(errmsg, obj);
-  }
-  return 0;    
-}
-#else
-SWIGINTERNINLINE int
-  SWIG_AsVal_int(PyObject *obj, int *val)
-{
-  return SWIG_AsVal_long(obj,(long*)val);
-}
-#endif
-
-
-SWIGINTERNINLINE int
-SWIG_As_int(PyObject* obj)
-{
-  int v;
-  if (!SWIG_AsVal_int(obj, &v)) {
-    /*
-      this is needed to make valgrind/purify happier. 
-     */
-    memset((void*)&v, 0, sizeof(int));
-  }
-  return v;
-}
-
-  
-SWIGINTERNINLINE int
-SWIG_Check_int(PyObject* obj)
-{
-  return SWIG_AsVal_int(obj, (int*)0);
-}
-
-
-SWIGINTERN int
-  SWIG_AsVal_bool(PyObject *obj, bool *val)
-{
-  if (obj == Py_True) {
-    if (val) *val = true;
-    return 1;
-  }
-  if (obj == Py_False) {
-    if (val) *val = false;
-    return 1;
-  }
-  int res = 0;
-  if (SWIG_AsVal_int(obj, &res)) {    
-    if (val) *val = res ? true : false;
-    return 1;
-  } else {
-    PyErr_Clear();
-  }  
-  if (val) {
-    SWIG_type_error("bool", obj);
-  }
-  return 0;
-}
-
-
-SWIGINTERNINLINE bool
-SWIG_As_bool(PyObject* obj)
-{
-  bool v;
-  if (!SWIG_AsVal_bool(obj, &v)) {
-    /*
-      this is needed to make valgrind/purify happier. 
-     */
-    memset((void*)&v, 0, sizeof(bool));
-  }
-  return v;
-}
-
-  
-SWIGINTERNINLINE int
-SWIG_Check_bool(PyObject* obj)
-{
-  return SWIG_AsVal_bool(obj, (bool*)0);
-}
-
-extern SoundSystem *tw_sound;
-SoundSystem *GetSoundSystem();
-
-#include <iostream>  
-
-
-#if PY_VERSION_HEX < 0x02000000
-#define PySequence_Size PySequence_Length
-#endif
-#include <stdexcept>
-
-
-#define  SWIG_MemoryError    1
-#define  SWIG_IOError        2
-#define  SWIG_RuntimeError   3
-#define  SWIG_IndexError     4
-#define  SWIG_TypeError      5
-#define  SWIG_DivisionByZero 6
-#define  SWIG_OverflowError  7
-#define  SWIG_SyntaxError    8
-#define  SWIG_ValueError     9
-#define  SWIG_SystemError   10
-#define  SWIG_UnknownError  99
-
-
-SWIGINTERN void SWIG_exception_(int code, const char *msg) {
-  switch(code) {
-  case SWIG_MemoryError:
-    PyErr_SetString(PyExc_MemoryError,msg);
-    break;
-  case SWIG_IOError:
-    PyErr_SetString(PyExc_IOError,msg);
-    break;
-  case SWIG_RuntimeError:
-    PyErr_SetString(PyExc_RuntimeError,msg);
-    break;
-  case SWIG_IndexError:
-    PyErr_SetString(PyExc_IndexError,msg);
-    break;
-  case SWIG_TypeError:
-    PyErr_SetString(PyExc_TypeError,msg);
-    break;
-  case SWIG_DivisionByZero:
-    PyErr_SetString(PyExc_ZeroDivisionError,msg);
-    break;
-  case SWIG_OverflowError:
-    PyErr_SetString(PyExc_OverflowError,msg);
-    break;
-  case SWIG_SyntaxError:
-    PyErr_SetString(PyExc_SyntaxError,msg);
-    break;
-  case SWIG_ValueError:
-    PyErr_SetString(PyExc_ValueError,msg);
-    break;
-  case SWIG_SystemError:
-    PyErr_SetString(PyExc_SystemError,msg);
-    break;
-  default:
-    PyErr_SetString(PyExc_RuntimeError,msg);
-    break;
-  }
-}
-
-#define SWIG_exception(a,b) { SWIG_exception_(a,b); SWIG_fail; }
-
-
-#include <stdexcept>
-
-
-#include <algorithm>
-
-
-#include <vector>
-
-
-SWIGINTERN int
-  SWIG_AsVal_std_string(PyObject* obj, std::string *val)
-  {
-    std::string* s;
-    int res = SWIG_AsPtr_std_string(obj, &s);
-    if ((res != 0) && s) {
-      if (val) *val = *s;
-      if (res == SWIG_NEWOBJ) delete s;
-      return res;
-    }
-    if (val) {
-      PyErr_SetString(PyExc_TypeError,"a string is expected");
-    }
-    return 0;
-  }
-
-
-namespace swig {  
-  template <class Type>
-  struct noconst_traits {
-    typedef Type noconst_type;
-  };
-
-  template <class Type>
-  struct noconst_traits<const Type> {
-    typedef Type noconst_type;
-  };
-
-  /*
-    type categories
-  */
-  struct pointer_category { };  
-  struct value_category { };
-
-  /*
-    General traits that provides type_name and type_info
-  */
-  template <class Type> struct traits { };
-
-  template <class Type>
-  inline const char* type_name() {
-    return traits<typename noconst_traits<Type >::noconst_type >::type_name();
-  }
-
-  template <class Type> 
-  struct traits_info {
-    static swig_type_info *type_query(std::string name) {
-      name += " *";
-      return SWIG_TypeQuery(name.c_str());
-    }    
-    static swig_type_info *type_info() {
-      static swig_type_info *info = type_query(type_name<Type>());
-      return info;
-    }
-  };
-
-  template <class Type>
-  inline swig_type_info *type_info() {
-    return traits_info<Type>::type_info();
-  }
-
-  /*
-    Partial specialization for pointers
-  */
-  template <class Type> struct traits <Type *> {
-    typedef pointer_category category;
-    static std::string make_ptr_name(const char* name) {
-      std::string ptrname = name;
-      ptrname += " *";
-      return ptrname;
-    }    
-    static const char* type_name() {
-      static std::string name = make_ptr_name(swig::type_name<Type>());
-      return name.c_str();
-    }
-  };
-
-  template <class Type, class Category> 
-  struct traits_as { };
- 
-  template <class Type, class Category> 
-  struct traits_check { };
-
-}
-
-
-namespace swig {  
-  /*
-    Traits that provides the from method
-  */
-  template <class Type> struct traits_from_ptr {
-    static PyObject *from(Type *val, int owner = 0) {
-      return SWIG_NewPointerObj(val, type_info<Type>(), owner);
-    }
-  };
-
-  template <class Type> struct traits_from {
-    static PyObject *from(const Type& val) {
-      return traits_from_ptr<Type>::from(new Type(val), 1);
-    }
-  };
-
-  template <class Type> struct traits_from<Type *> {
-    static PyObject *from(Type* val) {
-      return traits_from_ptr<Type>::from(val, 0);
-    }
-  };
-
-  template <class Type>
-  inline PyObject *from(const Type& val) {
-    return traits_from<Type>::from(val);
-  }
-
-  template <class Type>
-  inline PyObject *from_ptr(Type* val, int owner) {
-    return traits_from_ptr<Type>::from(val, owner);
-  }
-
-  /*
-    Traits that provides the asval/as/check method
-  */
-  template <class Type>
-  struct traits_asptr {   
-    static int asptr(PyObject *obj, Type **val) {
-      Type *p;
-      int res = (SWIG_ConvertPtr(obj, (void**)&p, type_info<Type>(), 0) != -1) 
-	? SWIG_OLDOBJ : 0;
-      if (res) {
-	if (val) {
-	  *val = p;
-	}
-      } else {
-	SWIG_type_error(type_name<Type>(), obj);
-      }
-      return res;
-    }
-  }; 
-
-  template <class Type>
-  inline int asptr(PyObject *obj, Type **vptr) {
-    return traits_asptr<Type>::asptr(obj, vptr);
-  }
-
-  template <class Type> 
-  struct traits_asval {
-    static bool asval(PyObject *obj, Type *val) {
-      if (val) {
-	Type *p = 0;
-	int res = traits_asptr<Type>::asptr(obj, &p);
-	if ((res != 0) && p) {
-	  typedef typename noconst_traits<Type>::noconst_type noconst_type;
-	  *(const_cast<noconst_type*>(val)) = *p;
-	  if (res == SWIG_NEWOBJ) delete p;
-	  return true;
-	} else {
-	  return false;
-	}
-      } else {
-	return traits_asptr<Type>::asptr(obj, (Type **)(0)) ? true : false;
-      }
-    }
-  };
-
-  template <class Type> struct traits_asval<Type*> {
-    static bool asval(PyObject *obj, Type **val) {
-      if (val) {
-        typedef typename noconst_traits<Type>::noconst_type noconst_type;
-        noconst_type *p = 0;
-        int res = traits_asptr<noconst_type>::asptr(obj, &p);
-        if (res) {
-          *(const_cast<noconst_type**>(val)) = p;
-     	  return true;
-	} else {
-	  return false;
-	}
-      } else {
-	return traits_asptr<Type>::asptr(obj, (Type **)(0)) ? true : false;
-      }
-    }
-  };
-  
-  template <class Type>
-  inline bool asval(PyObject *obj, Type *val) {
-    return traits_asval<Type>::asval(obj, val) ? true : false;
-  }
-
-  template <class Type> 
-  struct traits_as<Type, value_category> {
-    static Type as(PyObject *obj, bool throw_error) {
-      Type v;
-      if (!obj || !asval(obj, &v)) {
-	if (!PyErr_Occurred()) {
-	  SWIG_type_error(swig::type_name<Type>(), obj);
-	}
-	if (throw_error) throw std::invalid_argument("bad type");
-      }
-      return v;
-    }
-  };
-
-  template <class Type> 
-  struct traits_as<Type, pointer_category> {
-    static Type as(PyObject *obj, bool throw_error) {
-      Type *v = 0;      
-      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : 0);
-      if (res && v) {
-	if (res == SWIG_NEWOBJ) {
-	  Type r(*v);
-	  delete v;
-	  return r;
-	} else {
-	  return *v;
-	}
-      } else {
-	// Uninitialized return value, no Type() constructor required.
-	static Type *v_def = (Type*) malloc(sizeof(Type));
-	if (!PyErr_Occurred()) {
-	  SWIG_type_error(swig::type_name<Type>(), obj);
-	}
-	if (throw_error) throw std::invalid_argument("bad type");
-	memset(v_def,0,sizeof(Type));
-	return *v_def;
-      }
-    }
-  };
-
-  template <class Type> 
-  struct traits_as<Type*, pointer_category> {
-    static Type* as(PyObject *obj, bool throw_error) {
-      Type *v = 0;      
-      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : 0);
-      if (res) {
-	return v;
-      } else {
-	if (!PyErr_Occurred()) {
-	  SWIG_type_error(swig::type_name<Type>(), obj);
-	}
-	if (throw_error) throw std::invalid_argument("bad type");
-	return 0;
-      }
-    }
-  };
-    
-  template <class Type>
-  inline Type as(PyObject *obj, bool te = false) {
-    return traits_as<Type, typename traits<Type>::category>::as(obj, te);
-  }
-
-  template <class Type> 
-  struct traits_check<Type, value_category> {
-    static bool check(PyObject *obj) {
-      return obj && asval(obj, (Type *)(0));
-    }
-  };
-
-  template <class Type> 
-  struct traits_check<Type, pointer_category> {
-    static bool check(PyObject *obj) {
-      return obj && asptr(obj, (Type **)(0));
-    }
-  };
-
-  template <class Type>
-  inline bool check(PyObject *obj) {
-    return traits_check<Type, typename traits<Type>::category>::check(obj);
-  }
-}
-
-
-namespace swig {
-  template <> struct traits<std::string > {
-    typedef value_category category;
-    static const char* type_name() { return"std::string"; }
-  };  
-  template <>  struct traits_asval<std::string > {   
-    typedef std::string value_type;
-    static int asval(PyObject *obj, value_type *val) { 
-      return SWIG_AsVal_std_string(obj, val);
-    }
-  };
-  template <>  struct traits_from<std::string > {
-    typedef std::string value_type;
-    static PyObject *from(const value_type& val) {
-      return SWIG_From_std_string(val);
-    }
-  };
-}
-
-
-  namespace swig {
-    struct PyObject_var {
-      PyObject* ptr;
-      PyObject_var(PyObject* obj = 0) : ptr(obj) { }      
-      ~PyObject_var() { if (ptr) Py_DECREF(ptr); }      
-      operator PyObject*() { return ptr; }
-      PyObject* operator->() const { return ptr; }
-    };
-  }
-
-
-namespace swig {
-  inline size_t
-  check_index(ptrdiff_t i, size_t size, bool insert = false) {
-    if ( i < 0 ) {
-      if ((size_t) (-i) <= size) 
-	return (size_t) (i + size);
-    } else if ( (size_t) i < size ) {
-      return (size_t) i;
-    } else if (insert && ((size_t) i == size)) {
-      return size;
-    }
-    
-    throw std::out_of_range("index out of range");
-  }
-
-  inline size_t
-  slice_index(ptrdiff_t i, size_t size) {
-    if ( i < 0 ) {
-      if ((size_t) (-i) <= size) {
-	return (size_t) (i + size);
-      } else {
-	throw std::out_of_range("index out of range");
-      }
-    } else {
-      return ( (size_t) i < size ) ? ((size_t) i) : size;
-    }
-  }
-
-  template <class Sequence, class Difference>
-  inline typename Sequence::iterator 
-  getpos(Sequence* self, Difference i)  {
-    typename Sequence::iterator pos = self->begin(); 
-    std::advance(pos, check_index(i,self->size()));
-    return pos;
-  }
-
-  template <class Sequence, class Difference>
-  inline typename Sequence::const_iterator 
-  cgetpos(const Sequence* self, Difference i)  {
-    typename Sequence::const_iterator pos = self->begin(); 
-    std::advance(pos, check_index(i,self->size()));
-    return pos;
-  }
-
-  template <class Sequence, class Difference>
-  inline Sequence*
-  getslice(const Sequence* self, Difference i, Difference j) { 
-    typename Sequence::size_type size = self->size();
-    typename Sequence::size_type ii = swig::check_index(i, size);
-    typename Sequence::size_type jj = swig::slice_index(j, size);
-    
-    if (jj > ii) {
-      typename Sequence::const_iterator vb = self->begin();
-      typename Sequence::const_iterator ve = self->begin();
-      std::advance(vb,ii);
-      std::advance(ve,jj);
-      return new Sequence(vb, ve);
-    } else {
-      return new Sequence();
-    }
-  }
-
-  template <class Sequence, class Difference, class InputSeq>
-  inline void
-  setslice(Sequence* self, Difference i, Difference j, const InputSeq& v) {
-    typename Sequence::size_type size = self->size();
-    typename Sequence::size_type ii = swig::check_index(i, size, true);
-    typename Sequence::size_type jj = swig::slice_index(j, size);
-    if (jj < ii) jj = ii;
-    typename Sequence::iterator sb = self->begin();
-    typename InputSeq::const_iterator vmid = v.begin();
-    std::advance(sb,ii);
-    std::advance(vmid, jj - ii);
-    self->insert(std::copy(v.begin(), vmid, sb), vmid, v.end());
-  }
- 
-  template <class Sequence, class Difference>
-  inline void
-  delslice(Sequence* self, Difference i, Difference j) {
-    typename Sequence::size_type size = self->size();
-    typename Sequence::size_type ii = swig::check_index(i, size, true);
-    typename Sequence::size_type jj = swig::slice_index(j, size);
-    if (jj > ii) {
-      typename Sequence::iterator sb = self->begin();
-      typename Sequence::iterator se = self->begin();
-      std::advance(sb,ii);
-      std::advance(se,jj);
-      self->erase(sb,se);
-    }
-  }
-}
-
-
-#include <iterator>
-namespace swig
-{
-  template <class T> 
-  struct PySequence_Ref
-  {
-    PySequence_Ref(PyObject* seq, int index) 
-      : _seq(seq), _index(index)
-    {
-    }
-
-    operator T () const 
-    {
-      swig::PyObject_var item = PySequence_GetItem(_seq, _index);
-      try {
-	return swig::as<T>(item, true);
-      } catch (std::exception& e) {
-	char msg[1024];
-	PyOS_snprintf(msg, sizeof(msg), "in sequence element %d ", _index);
-	if (!PyErr_Occurred()) {
-	  SWIG_type_error(swig::type_name<T>(), item);
-	}
-	SWIG_append_errmsg(msg);
-	SWIG_append_errmsg(e.what());
-	throw;
-      }
-    }
-    
-    PySequence_Ref& operator=(const T& v) 
-    {
-      PySequence_SetItem(_seq, _index, swig::from<T>(v));
-      return *this;
-    }
-    
-  private:
-    PyObject* _seq;
-    int _index;
-  };
-
-  template <class T> 
-  struct PySequence_ArrowProxy 
-  {
-    PySequence_ArrowProxy(const T& x): m_value(x) {}
-    const T* operator->() const { return &m_value; }
-    operator const T*() const { return &m_value; }
-    T m_value;
-  };    
-
-  template <class T, class Reference > 
-  struct PySequence_Iter
-  {
-    typedef PySequence_Iter<T, Reference > self;
-
-    typedef std::random_access_iterator_tag iterator_category;
-    typedef Reference reference;
-    typedef T value_type;
-    typedef T* pointer;
-    typedef int difference_type;
-
-    PySequence_Iter()
-    {
-    }
-
-    PySequence_Iter(PyObject* seq, int index)
-      : _seq(seq), _index(index)
-    {
-    }
-
-    reference operator*() const
-    { 
-      return reference(_seq, _index);
-    }
-
-    PySequence_ArrowProxy<T>
-    operator->() const {
-      return PySequence_ArrowProxy<T>(operator*());
-    }
-
-    bool operator==(const self& ri) const 
-    { 
-      return (_index == ri._index) && (_seq == ri._seq);
-    }
-
-    bool operator!=(const self& ri) const 
-    {
-      return !(operator==(ri));
-    }    
-
-    self& operator ++ ()
-    {
-      ++_index;      
-      return *this;
-    }
-
-    self& operator -- ()
-    {
-      --_index;
-      return *this;
-    }
-
-    self& operator += (difference_type n) 
-    {
-      _index += n;
-      return *this;
-    }
-
-    self operator +(difference_type n) const
-    {
-      return self(_seq, _index + n);
-    }
-
-    self& operator -= (difference_type n) 
-    {
-      _index -= n;
-      return *this;
-    }
-
-    self operator -(difference_type n) const
-    {
-      return self(_seq, _index - n);
-    }    
-
-    difference_type operator - (const self& ri) const
-    {
-      return _index - ri._index;
-    }
-
-    reference 
-    operator[](difference_type n) const 
-    { 
-      return reference(_seq, _index + n);
-    }
-
-  private:
-    PyObject* _seq;
-    int _index;
-  }; 
-
-  template <class T> 
-  struct PySequence_Cont
-  {
-    typedef PySequence_Ref<T> reference;
-    typedef const PySequence_Ref<T> const_reference;
-    typedef T value_type;
-    typedef T* pointer;
-    typedef int difference_type;
-    typedef int size_type;
-    typedef const pointer const_pointer;
-    typedef PySequence_Iter<T, reference> iterator;
-    typedef PySequence_Iter<T, const_reference> const_iterator;
-
-    PySequence_Cont(PyObject* seq) : _seq(0)
-    {
-      if (!PySequence_Check(seq)) {
-	throw std::invalid_argument("a sequence is expected");
-      }
-      _seq = seq;
-      Py_INCREF(_seq);
-    }
-
-    ~PySequence_Cont() 
-    {
-      if (_seq) Py_DECREF(_seq);
-    }
-
-    size_type size() const
-    {
-      return PySequence_Size(_seq);
-    }
-
-    bool empty() const
-    {
-      return size() == 0;
-    }    
-
-    iterator begin()
-    {
-      return iterator(_seq, 0);
-    }
-
-    const_iterator begin() const
-    {
-      return const_iterator(_seq, 0);
-    }
-    
-    iterator end()
-    {
-      return iterator(_seq, size());
-    }
-    
-    const_iterator end() const
-    {
-      return const_iterator(_seq, size());
-    }    
-
-    reference operator[](difference_type n) 
-    { 
-      return reference(_seq, n);
-    }
-
-    const_reference operator[](difference_type n)  const
-    { 
-      return const_reference(_seq, n);
-    }
-
-    bool check(bool set_err = true) const
-    {
-      int s = size();
-      for (int i = 0; i < s; ++i) {
-	swig::PyObject_var item = PySequence_GetItem(_seq, i);
-	if (!swig::check<value_type>(item)) {
-	  if (set_err) {
-	    char msg[1024];
-	    PyOS_snprintf(msg, sizeof(msg), "in sequence element %d", i);
-	    SWIG_type_error(swig::type_name<value_type>(), item);
-	    SWIG_append_errmsg(msg);
-	  }
-	  return 0;
-	}
-      }
-      return 1;  
-    }
-
-  private:
-    PyObject* _seq;
-  };
-
-}
-
-
-  namespace swig {
-    template <class PySeq, class Seq> 
-    inline void
-    assign(const PySeq& pyseq, Seq* seq) {
-#ifdef SWIG_STD_NOASSIGN_STL
-      typedef typename PySeq::value_type value_type;
-      typename PySeq::const_iterator it = pyseq.begin();
-      for (;it != pyseq.end(); ++it) {
-	seq->insert(seq->end(),(value_type)(*it));
-      }
-#else
-      seq->assign(pyseq.begin(), pyseq.end());
-#endif
-    }
-
-    template <class Seq, class T = typename Seq::value_type >
-    struct traits_asptr_stdseq {
-      typedef Seq sequence;
-      typedef T value_type;
-		    
-      static int asptr(PyObject *obj, sequence **seq) {
-	if (PySequence_Check(obj)) {
-	  try {
-	    PySequence_Cont<value_type> pyseq(obj);
-	    if (seq) {
-	      sequence *pseq = new sequence();
-	      assign(pyseq, pseq);
-	      *seq = pseq;
-	      return SWIG_NEWOBJ;
-	    } else {
-	      return pyseq.check();
-	    }
-	  } catch (std::exception& e) {
-	    if (seq) {
-	      if (!PyErr_Occurred())
-		PyErr_SetString(PyExc_TypeError, e.what());
-	    }
-	    return 0;
-	  }
-	} else {
-	  sequence *p;
-	  if (SWIG_ConvertPtr(obj,(void**)&p,
-			      swig::type_info<sequence>(),0) != -1) {
-	    if (seq) *seq = p;
-	    return 1;
-	  }
-	}
-	if (seq) {
-	  PyErr_Format(PyExc_TypeError, "a %s is expected", 
-		       swig::type_name<sequence>());
-	}
-	return 0;	  
-      }
-    };
-
-    template <class Seq, class T = typename Seq::value_type >
-    struct traits_from_stdseq {
-      typedef Seq sequence;
-      typedef T value_type;
-      typedef typename Seq::size_type size_type;
-      typedef typename sequence::const_iterator const_iterator;
-
-      static PyObject *from(const sequence& seq) {
-	size_type size = seq.size();
-	if (size <= (size_type)INT_MAX) {
-	  PyObject *obj = PyTuple_New((int)size);
-	  int i = 0;
-	  for (const_iterator it = seq.begin();
-	       it != seq.end(); ++it, ++i) {
-	    PyTuple_SetItem(obj,i,swig::from<value_type>(*it));
-	  }
-	  return obj;
-	} else {
-	  PyErr_SetString(PyExc_OverflowError,
-			  "sequence size not valid in python");
-	  return NULL;
-	}
-      }
-    };
-  }
-
-
-  namespace swig {
-    template <class T>
-    struct traits_asptr<std::vector<T> >  {
-      static int asptr(PyObject *obj, std::vector<T> **vec) {
-	return traits_asptr_stdseq<std::vector<T> >::asptr(obj, vec);
-      }
-    };
-    
-    template <class T>
-    struct traits_from<std::vector<T> > {
-      static PyObject *from(const std::vector<T>& vec) {
-	return traits_from_stdseq<std::vector<T> >::from(vec);
-      }
-    };
-  }
-
-
-      namespace swig {
-	template <>  struct traits<std::vector<std::string, std::allocator<std::string > > > {
-	  typedef pointer_category category;
-	  static const char* type_name() {
-	    return "std::vector<" "std::string" "," "std::allocator<std::string >" " >";
-	  }
-	};
-      }
-    
-
-SWIGINTERNINLINE PyObject* 
-  SWIG_From_unsigned_SS_long(unsigned long value)
-{
-  return (value > LONG_MAX) ?
-    PyLong_FromUnsignedLong(value) 
-    : PyInt_FromLong((long)(value)); 
-}
-
-
-SWIGINTERN int
-  SWIG_AsVal_unsigned_SS_long(PyObject *obj, unsigned long *val) 
-{
-  if (PyInt_Check(obj)) {
-    long v = PyInt_AS_LONG(obj);
-    if (v >= 0) {
-      if (val) *val = v;
-      return 1;
-    }   
-  }
-  if (PyLong_Check(obj)) {
-    unsigned long v = PyLong_AsUnsignedLong(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = v;
-      return 1;
-    } else {
-      if (!val) PyErr_Clear();
-      return 0;
-    }
-  } 
-  if (val) {
-    SWIG_type_error("unsigned long", obj);
-  }
-  return 0;
-}
-
-
-SWIGINTERNINLINE unsigned long
-SWIG_As_unsigned_SS_long(PyObject* obj)
-{
-  unsigned long v;
-  if (!SWIG_AsVal_unsigned_SS_long(obj, &v)) {
-    /*
-      this is needed to make valgrind/purify happier. 
-     */
-    memset((void*)&v, 0, sizeof(unsigned long));
-  }
-  return v;
-}
-
-  
-SWIGINTERNINLINE int
-SWIG_Check_unsigned_SS_long(PyObject* obj)
-{
-  return SWIG_AsVal_unsigned_SS_long(obj, (unsigned long*)0);
-}
-
-static bool std_vector_Sl_std_string_Sg____nonzero__(std::vector<std::string > const *self){
-      return !(self->empty());
-    }
-static std::vector<std::string >::size_type std_vector_Sl_std_string_Sg____len__(std::vector<std::string > const *self){
-      return self->size();
-    }
-static std::vector<std::string >::value_type std_vector_Sl_std_string_Sg__pop(std::vector<std::string > *self){
-      if (self->size() == 0)
-	throw std::out_of_range("pop from empty container");
-      std::vector<std::string,std::allocator<std::string > >::value_type x = self->back();
-      self->pop_back();
-      return x;
-    }
-
-SWIGINTERNINLINE long
-SWIG_As_long(PyObject* obj)
-{
-  long v;
-  if (!SWIG_AsVal_long(obj, &v)) {
-    /*
-      this is needed to make valgrind/purify happier. 
-     */
-    memset((void*)&v, 0, sizeof(long));
-  }
-  return v;
-}
-
-  
-SWIGINTERNINLINE int
-SWIG_Check_long(PyObject* obj)
-{
-  return SWIG_AsVal_long(obj, (long*)0);
-}
-
-static std::vector<std::string,std::allocator<std::string > > *std_vector_Sl_std_string_Sg____getslice__(std::vector<std::string > *self,std::vector<std::string >::difference_type i,std::vector<std::string >::difference_type j){
-      return swig::getslice(self, i, j);
-    }
-static void std_vector_Sl_std_string_Sg____setslice__(std::vector<std::string > *self,std::vector<std::string >::difference_type i,std::vector<std::string >::difference_type j,std::vector<std::string,std::allocator<std::string > > const &v){
-      swig::setslice(self, i, j, v);
-    }
-static void std_vector_Sl_std_string_Sg____delslice__(std::vector<std::string > *self,std::vector<std::string >::difference_type i,std::vector<std::string >::difference_type j){
-      swig::delslice(self, i, j);
-    }
-static void std_vector_Sl_std_string_Sg____delitem__(std::vector<std::string > *self,std::vector<std::string >::difference_type i){
-      self->erase(swig::getpos(self,i));
-    }
-static std::vector<std::string >::value_type const &std_vector_Sl_std_string_Sg____getitem__(std::vector<std::string > const *self,std::vector<std::string >::difference_type i){
-      return *(swig::cgetpos(self, i));
-    }
-static void std_vector_Sl_std_string_Sg____setitem__(std::vector<std::string > *self,std::vector<std::string >::difference_type i,std::vector<std::string >::value_type const &x){
-      *(swig::getpos(self,i)) = x;
-    }
-static void std_vector_Sl_std_string_Sg__append(std::vector<std::string > *self,std::vector<std::string >::value_type const &x){
-      self->push_back(x);
-    }
-#ifdef __cplusplus
-extern "C" {
-#endif
-static PyObject *_wrap_GameAction_clean(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    
-    if(!PyArg_ParseTuple(args,(char *)":GameAction_clean")) goto fail;
-    GameAction::clean();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_system(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    double arg2 ;
-    double arg3 ;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOO:GameAction_add_system",&obj0,&obj1,&obj2)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    GameAction::add_system((std::string const &)*arg1,arg2,arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_planet(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    double arg3 ;
-    double arg4 ;
-    int result;
-    int res1 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOOO:GameAction_add_planet",&obj0,&obj1,&obj2,&obj3)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (double)(SWIG_As_double(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    result = (int)GameAction::add_planet((std::string const &)*arg1,(std::string const &)*arg2,arg3,arg4);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_orbiter_station(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    std::string *arg3 = 0 ;
-    std::string *arg4 = 0 ;
-    std::string *arg5 = 0 ;
-    std::string *arg6 = 0 ;
-    std::string *arg7 = 0 ;
-    int result;
-    int res1 = 0 ;
-    int res2 = 0 ;
-    int res3 = 0 ;
-    int res4 = 0 ;
-    int res5 = 0 ;
-    int res6 = 0 ;
-    int res7 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    PyObject * obj4 = 0 ;
-    PyObject * obj5 = 0 ;
-    PyObject * obj6 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOOOOOO:GameAction_add_orbiter_station",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res3 = SWIG_AsPtr_std_string(obj2, &ptr);
-        if (!res3) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj2);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(3)) SWIG_fail;
-        arg3 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res4 = SWIG_AsPtr_std_string(obj3, &ptr);
-        if (!res4) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj3);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(4)) SWIG_fail;
-        arg4 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res5 = SWIG_AsPtr_std_string(obj4, &ptr);
-        if (!res5) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj4);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(5)) SWIG_fail;
-        arg5 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res6 = SWIG_AsPtr_std_string(obj5, &ptr);
-        if (!res6) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj5);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(6)) SWIG_fail;
-        arg6 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res7 = SWIG_AsPtr_std_string(obj6, &ptr);
-        if (!res7) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj6);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(7)) SWIG_fail;
-        arg7 = ptr;
-    }
-    result = (int)GameAction::add_orbiter_station((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,(std::string const &)*arg6,(std::string const &)*arg7);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    if (res3 == SWIG_NEWOBJ) delete arg3;
-    if (res4 == SWIG_NEWOBJ) delete arg4;
-    if (res5 == SWIG_NEWOBJ) delete arg5;
-    if (res6 == SWIG_NEWOBJ) delete arg6;
-    if (res7 == SWIG_NEWOBJ) delete arg7;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    if (res3 == SWIG_NEWOBJ) delete arg3;
-    if (res4 == SWIG_NEWOBJ) delete arg4;
-    if (res5 == SWIG_NEWOBJ) delete arg5;
-    if (res6 == SWIG_NEWOBJ) delete arg6;
-    if (res7 == SWIG_NEWOBJ) delete arg7;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_asteroid__SWIG_0(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    double arg2 ;
-    double arg3 ;
-    double arg4 ;
-    double arg5 ;
-    int result;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    PyObject * obj4 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOOOO:GameAction_add_asteroid",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (double)(SWIG_As_double(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    {
-        arg5 = (double)(SWIG_As_double(obj4)); 
-        if (SWIG_arg_fail(5)) SWIG_fail;
-    }
-    result = (int)GameAction::add_asteroid((std::string const &)*arg1,arg2,arg3,arg4,arg5);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_asteroid__SWIG_1(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    double arg2 ;
-    double arg3 ;
-    double arg4 ;
-    int result;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOOO:GameAction_add_asteroid",&obj0,&obj1,&obj2,&obj3)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (double)(SWIG_As_double(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    result = (int)GameAction::add_asteroid((std::string const &)*arg1,arg2,arg3,arg4);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_asteroid__SWIG_2(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    double arg2 ;
-    double arg3 ;
-    int result;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOO:GameAction_add_asteroid",&obj0,&obj1,&obj2)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    result = (int)GameAction::add_asteroid((std::string const &)*arg1,arg2,arg3);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_asteroid__SWIG_3(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    double arg2 ;
-    int result;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:GameAction_add_asteroid",&obj0,&obj1)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    result = (int)GameAction::add_asteroid((std::string const &)*arg1,arg2);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_asteroid__SWIG_4(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    int result;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:GameAction_add_asteroid",&obj0)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    result = (int)GameAction::add_asteroid((std::string const &)*arg1);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_asteroid(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[6];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii < argc) && (ii < 5); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 1) {
-        int _v;
-        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
-        if (_v) {
-            return _wrap_GameAction_add_asteroid__SWIG_4(self,args);
-        }
-    }
-    if (argc == 2) {
-        int _v;
-        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
-        if (_v) {
-            _v = SWIG_Check_double(argv[1]);
-            if (_v) {
-                return _wrap_GameAction_add_asteroid__SWIG_3(self,args);
-            }
-        }
-    }
-    if (argc == 3) {
-        int _v;
-        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
-        if (_v) {
-            _v = SWIG_Check_double(argv[1]);
-            if (_v) {
-                _v = SWIG_Check_double(argv[2]);
-                if (_v) {
-                    return _wrap_GameAction_add_asteroid__SWIG_2(self,args);
-                }
-            }
-        }
-    }
-    if (argc == 4) {
-        int _v;
-        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
-        if (_v) {
-            _v = SWIG_Check_double(argv[1]);
-            if (_v) {
-                _v = SWIG_Check_double(argv[2]);
-                if (_v) {
-                    _v = SWIG_Check_double(argv[3]);
-                    if (_v) {
-                        return _wrap_GameAction_add_asteroid__SWIG_1(self,args);
-                    }
-                }
-            }
-        }
-    }
-    if (argc == 5) {
-        int _v;
-        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
-        if (_v) {
-            _v = SWIG_Check_double(argv[1]);
-            if (_v) {
-                _v = SWIG_Check_double(argv[2]);
-                if (_v) {
-                    _v = SWIG_Check_double(argv[3]);
-                    if (_v) {
-                        _v = SWIG_Check_double(argv[4]);
-                        if (_v) {
-                            return _wrap_GameAction_add_asteroid__SWIG_0(self,args);
-                        }
-                    }
-                }
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'GameAction_add_asteroid'");
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_player(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    double arg3 ;
-    double arg4 ;
-    int result;
-    int res1 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOOO:GameAction_add_player",&obj0,&obj1,&obj2,&obj3)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (double)(SWIG_As_double(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    result = (int)GameAction::add_player((std::string const &)*arg1,(std::string const &)*arg2,arg3,arg4);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_ship(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    double arg3 ;
-    double arg4 ;
-    double arg5 ;
-    int result;
-    int res1 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    PyObject * obj4 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOOOO:GameAction_add_ship",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (double)(SWIG_As_double(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    {
-        arg5 = (double)(SWIG_As_double(obj4)); 
-        if (SWIG_arg_fail(5)) SWIG_fail;
-    }
-    result = (int)GameAction::add_ship((std::string const &)*arg1,(std::string const &)*arg2,arg3,arg4,arg5);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_save_flag__SWIG_0(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    int res1 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:GameAction_save_flag",&obj0,&obj1)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    GameAction::save_flag((std::string const &)*arg1,(std::string const &)*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_string_flag(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    std::string result;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:GameAction_get_string_flag",&obj0)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    result = GameAction::get_string_flag((std::string const &)*arg1);
-    
-    {
-        resultobj = SWIG_From_std_string((std::string)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_save_flag__SWIG_1(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    double arg2 ;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:GameAction_save_flag",&obj0,&obj1)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    GameAction::save_flag((std::string const &)*arg1,arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_save_flag(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[3];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 2) {
-        int _v;
-        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
-        if (_v) {
-            _v = SWIG_Check_double(argv[1]);
-            if (_v) {
-                return _wrap_GameAction_save_flag__SWIG_1(self,args);
-            }
-        }
-    }
-    if (argc == 2) {
-        int _v;
-        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
-        if (_v) {
-            _v = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-            if (_v) {
-                return _wrap_GameAction_save_flag__SWIG_0(self,args);
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'GameAction_save_flag'");
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_double_flag(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    double result;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:GameAction_get_double_flag",&obj0)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    result = (double)GameAction::get_double_flag((std::string const &)*arg1);
-    
-    {
-        resultobj = SWIG_From_double((double)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_player_ship_id(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double result;
-    
-    if(!PyArg_ParseTuple(args,(char *)":GameAction_get_player_ship_id")) goto fail;
-    result = (double)GameAction::get_player_ship_id();
-    
-    {
-        resultobj = SWIG_From_double((double)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_player_star_system(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string result;
-    
-    if(!PyArg_ParseTuple(args,(char *)":GameAction_get_player_star_system")) goto fail;
-    result = GameAction::get_player_star_system();
-    
-    {
-        resultobj = SWIG_From_std_string((std::string)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_set_target(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:GameAction_set_target",&obj0,&obj1)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    GameAction::set_target(arg1,arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_disable_weapon(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:GameAction_disable_weapon",&obj0)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    GameAction::disable_weapon(arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_enable_weapon(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:GameAction_enable_weapon",&obj0)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    GameAction::enable_weapon(arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_go_to_point(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    double arg4 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOOO:GameAction_go_to_point",&obj0,&obj1,&obj2,&obj3)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (double)(SWIG_As_double(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    result = (int)GameAction::go_to_point(arg1,arg2,arg3,arg4);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_go_to_location(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOO:GameAction_go_to_location",&obj0,&obj1,&obj2)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    result = (int)GameAction::go_to_location(arg1,arg2,arg3);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_guard_location(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOO:GameAction_guard_location",&obj0,&obj1,&obj2)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    result = (int)GameAction::guard_location(arg1,arg2,arg3);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_guard_point(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    double arg4 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOOO:GameAction_guard_point",&obj0,&obj1,&obj2,&obj3)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (double)(SWIG_As_double(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    result = (int)GameAction::guard_point(arg1,arg2,arg3,arg4);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_set_ship_team(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:GameAction_set_ship_team",&obj0,&obj1)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    GameAction::set_ship_team(arg1,arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_enemy_team(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    int result;
-    
-    if(!PyArg_ParseTuple(args,(char *)":GameAction_get_enemy_team")) goto fail;
-    result = (int)GameAction::get_enemy_team();
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_player_team(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    int result;
-    
-    if(!PyArg_ParseTuple(args,(char *)":GameAction_get_player_team")) goto fail;
-    result = (int)GameAction::get_player_team();
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_remove_location(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:GameAction_remove_location",&obj0)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    GameAction::remove_location(arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_set_crew(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:GameAction_set_crew",&obj0,&obj1)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    GameAction::set_crew(arg1,arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_location_pos_x(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:GameAction_get_location_pos_x",&obj0)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    result = (int)GameAction::get_location_pos_x(arg1);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_location_pos_y(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:GameAction_get_location_pos_y",&obj0)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    result = (int)GameAction::get_location_pos_y(arg1);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_exist(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    bool result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:GameAction_exist",&obj0)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    result = (bool)GameAction::exist(arg1);
-    
-    {
-        resultobj = SWIG_From_bool((bool)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_end_game(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    
-    if(!PyArg_ParseTuple(args,(char *)":GameAction_end_game")) goto fail;
-    GameAction::end_game();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_scroll_text(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string,std::allocator<std::string > > *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:GameAction_scroll_text",&obj0,&obj1)) goto fail;
-    {
-        SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        if (arg1 == NULL) {
-            SWIG_null_ref("std::vector<std::string,std::allocator<std::string > >");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    GameAction::scroll_text((std::vector<std::string,std::allocator<std::string > > const &)*arg1,(std::string const &)*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_print_message(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    int arg2 ;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:GameAction_print_message",&obj0,&obj1)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        arg2 = (int)(SWIG_As_int(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    GameAction::print_message((std::string const &)*arg1,arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_set_camera_mode(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:GameAction_set_camera_mode",&obj0)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    GameAction::set_camera_mode((std::string const &)*arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_GameAction(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    GameAction *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)":new_GameAction")) goto fail;
-    result = (GameAction *)new GameAction();
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_GameAction, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_GameAction(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    GameAction *arg1 = (GameAction *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:delete_GameAction",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_GameAction, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * GameAction_swigregister(PyObject *, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_GameAction, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)"");
-}
-static PyObject *_wrap_DialogApi_startDialog(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    
-    if(!PyArg_ParseTuple(args,(char *)":DialogApi_startDialog")) goto fail;
-    DialogApi::startDialog();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_DialogApi_endDialog(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    
-    if(!PyArg_ParseTuple(args,(char *)":DialogApi_endDialog")) goto fail;
-    DialogApi::endDialog();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_DialogApi_askPlayer(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string,std::allocator<std::string > > *arg1 = 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:DialogApi_askPlayer",&obj0)) goto fail;
-    {
-        SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        if (arg1 == NULL) {
-            SWIG_null_ref("std::vector<std::string,std::allocator<std::string > >");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    result = (int)DialogApi::askPlayer((std::vector<std::string,std::allocator<std::string > > const &)*arg1);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_DialogApi_showText(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    int arg2 ;
-    int arg3 ;
-    int arg4 ;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOOO:DialogApi_showText",&obj0,&obj1,&obj2,&obj3)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        arg2 = (int)(SWIG_As_int(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (int)(SWIG_As_int(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (int)(SWIG_As_int(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    DialogApi::showText((std::string const &)*arg1,arg2,arg3,arg4);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_DialogApi_showAlienPicture(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:DialogApi_showAlienPicture",&obj0)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    DialogApi::showAlienPicture((std::string const &)*arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_DialogApi(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    DialogApi *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)":new_DialogApi")) goto fail;
-    result = (DialogApi *)new DialogApi();
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_DialogApi, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_DialogApi(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    DialogApi *arg1 = (DialogApi *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:delete_DialogApi",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_DialogApi, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * DialogApi_swigregister(PyObject *, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_DialogApi, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)"");
-}
-static PyObject *_wrap_GameConfig_SetGameDirectory(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:GameConfig_SetGameDirectory",&obj0)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    GameConfig::SetGameDirectory((std::string const &)*arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameConfig_GetGameDirectory(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string result;
-    
-    if(!PyArg_ParseTuple(args,(char *)":GameConfig_GetGameDirectory")) goto fail;
-    result = GameConfig::GetGameDirectory();
-    
-    {
-        resultobj = SWIG_From_std_string((std::string)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameConfig_GetAbsolutePath(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    std::string result;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:GameConfig_GetAbsolutePath",&obj0)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    result = GameConfig::GetAbsolutePath((std::string const &)*arg1);
-    
-    {
-        resultobj = SWIG_From_std_string((std::string)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_GameConfig(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    GameConfig *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)":new_GameConfig")) goto fail;
-    result = (GameConfig *)new GameConfig();
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_GameConfig, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_GameConfig(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    GameConfig *arg1 = (GameConfig *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:delete_GameConfig",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_GameConfig, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * GameConfig_swigregister(PyObject *, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_GameConfig, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)"");
-}
-static PyObject *_wrap_EventManager_clean(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    
-    if(!PyArg_ParseTuple(args,(char *)":EventManager_clean")) goto fail;
-    EventManager::clean();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_setSingleTimeEvent(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    std::string *arg2 = 0 ;
-    int result;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:EventManager_setSingleTimeEvent",&obj0,&obj1)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    result = (int)EventManager::setSingleTimeEvent(arg1,(std::string const &)*arg2);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_setRepeatableTimeEvent(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    std::string *arg2 = 0 ;
-    int result;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:EventManager_setRepeatableTimeEvent",&obj0,&obj1)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    result = (int)EventManager::setRepeatableTimeEvent(arg1,(std::string const &)*arg2);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_disableEvent(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:EventManager_disableEvent",&obj0)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    EventManager::disableEvent(arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_shipDeathById(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    std::string *arg2 = 0 ;
-    int result;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:EventManager_shipDeathById",&obj0,&obj1)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    result = (int)EventManager::shipDeathById(arg1,(std::string const &)*arg2);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_shipDeathByType(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    int result;
-    int res1 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:EventManager_shipDeathByType",&obj0,&obj1)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    result = (int)EventManager::shipDeathByType((std::string const &)*arg1,(std::string const &)*arg2);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_distanceMoreThen__SWIG_0(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    double arg4 ;
-    std::string *arg5 = 0 ;
-    int result;
-    int res5 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    PyObject * obj4 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOOOO:EventManager_distanceMoreThen",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (double)(SWIG_As_double(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res5 = SWIG_AsPtr_std_string(obj4, &ptr);
-        if (!res5) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj4);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(5)) SWIG_fail;
-        arg5 = ptr;
-    }
-    result = (int)EventManager::distanceMoreThen(arg1,arg2,arg3,arg4,(std::string const &)*arg5);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res5 == SWIG_NEWOBJ) delete arg5;
-    return resultobj;
-    fail:
-    if (res5 == SWIG_NEWOBJ) delete arg5;
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_distanceLessThen__SWIG_0(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    double arg4 ;
-    std::string *arg5 = 0 ;
-    int result;
-    int res5 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    PyObject * obj4 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOOOO:EventManager_distanceLessThen",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (double)(SWIG_As_double(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res5 = SWIG_AsPtr_std_string(obj4, &ptr);
-        if (!res5) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj4);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(5)) SWIG_fail;
-        arg5 = ptr;
-    }
-    result = (int)EventManager::distanceLessThen(arg1,arg2,arg3,arg4,(std::string const &)*arg5);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res5 == SWIG_NEWOBJ) delete arg5;
-    return resultobj;
-    fail:
-    if (res5 == SWIG_NEWOBJ) delete arg5;
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_distanceMoreThen__SWIG_1(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    std::string *arg4 = 0 ;
-    int result;
-    int res4 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOOO:EventManager_distanceMoreThen",&obj0,&obj1,&obj2,&obj3)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res4 = SWIG_AsPtr_std_string(obj3, &ptr);
-        if (!res4) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj3);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(4)) SWIG_fail;
-        arg4 = ptr;
-    }
-    result = (int)EventManager::distanceMoreThen(arg1,arg2,arg3,(std::string const &)*arg4);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res4 == SWIG_NEWOBJ) delete arg4;
-    return resultobj;
-    fail:
-    if (res4 == SWIG_NEWOBJ) delete arg4;
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_distanceMoreThen(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[6];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii < argc) && (ii < 5); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 4) {
-        int _v;
-        _v = SWIG_Check_double(argv[0]);
-        if (_v) {
-            _v = SWIG_Check_double(argv[1]);
-            if (_v) {
-                _v = SWIG_Check_double(argv[2]);
-                if (_v) {
-                    _v = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
-                    if (_v) {
-                        return _wrap_EventManager_distanceMoreThen__SWIG_1(self,args);
-                    }
-                }
-            }
-        }
-    }
-    if (argc == 5) {
-        int _v;
-        _v = SWIG_Check_double(argv[0]);
-        if (_v) {
-            _v = SWIG_Check_double(argv[1]);
-            if (_v) {
-                _v = SWIG_Check_double(argv[2]);
-                if (_v) {
-                    _v = SWIG_Check_double(argv[3]);
-                    if (_v) {
-                        _v = SWIG_AsPtr_std_string(argv[4], (std::string**)(0));
-                        if (_v) {
-                            return _wrap_EventManager_distanceMoreThen__SWIG_0(self,args);
-                        }
-                    }
-                }
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'EventManager_distanceMoreThen'");
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_distanceLessThen__SWIG_1(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    std::string *arg4 = 0 ;
-    int result;
-    int res4 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOOO:EventManager_distanceLessThen",&obj0,&obj1,&obj2,&obj3)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res4 = SWIG_AsPtr_std_string(obj3, &ptr);
-        if (!res4) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj3);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(4)) SWIG_fail;
-        arg4 = ptr;
-    }
-    result = (int)EventManager::distanceLessThen(arg1,arg2,arg3,(std::string const &)*arg4);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res4 == SWIG_NEWOBJ) delete arg4;
-    return resultobj;
-    fail:
-    if (res4 == SWIG_NEWOBJ) delete arg4;
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_distanceLessThen(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[6];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii < argc) && (ii < 5); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 4) {
-        int _v;
-        _v = SWIG_Check_double(argv[0]);
-        if (_v) {
-            _v = SWIG_Check_double(argv[1]);
-            if (_v) {
-                _v = SWIG_Check_double(argv[2]);
-                if (_v) {
-                    _v = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
-                    if (_v) {
-                        return _wrap_EventManager_distanceLessThen__SWIG_1(self,args);
-                    }
-                }
-            }
-        }
-    }
-    if (argc == 5) {
-        int _v;
-        _v = SWIG_Check_double(argv[0]);
-        if (_v) {
-            _v = SWIG_Check_double(argv[1]);
-            if (_v) {
-                _v = SWIG_Check_double(argv[2]);
-                if (_v) {
-                    _v = SWIG_Check_double(argv[3]);
-                    if (_v) {
-                        _v = SWIG_AsPtr_std_string(argv[4], (std::string**)(0));
-                        if (_v) {
-                            return _wrap_EventManager_distanceLessThen__SWIG_0(self,args);
-                        }
-                    }
-                }
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'EventManager_distanceLessThen'");
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_jumpToSystem(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    int result;
-    int res1 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:EventManager_jumpToSystem",&obj0,&obj1)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    result = (int)EventManager::jumpToSystem((std::string const &)*arg1,(std::string const &)*arg2);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_AddEventCondition(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    std::string *arg2 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:EventManager_AddEventCondition",&obj0,&obj1)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    EventManager::AddEventCondition(arg1,(std::string const &)*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_EventManager(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    EventManager *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)":new_EventManager")) goto fail;
-    result = (EventManager *)new EventManager();
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_EventManager, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_EventManager(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    EventManager *arg1 = (EventManager *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:delete_EventManager",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_EventManager, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * EventManager_swigregister(PyObject *, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_EventManager, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)"");
-}
-static PyObject *_wrap_new_SoundSystem__SWIG_0(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    bool arg1 ;
-    SoundSystem *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:new_SoundSystem",&obj0)) goto fail;
-    {
-        arg1 = (bool)(SWIG_As_bool(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    result = (SoundSystem *)new SoundSystem(arg1);
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_SoundSystem, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_SoundSystem__SWIG_1(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)":new_SoundSystem")) goto fail;
-    result = (SoundSystem *)new SoundSystem();
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_SoundSystem, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_SoundSystem(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[2];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii < argc) && (ii < 1); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 0) {
-        return _wrap_new_SoundSystem__SWIG_1(self,args);
-    }
-    if (argc == 1) {
-        int _v;
-        _v = SWIG_Check_bool(argv[0]);
-        if (_v) {
-            return _wrap_new_SoundSystem__SWIG_0(self,args);
-        }
-    }
-    
-    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'new_SoundSystem'");
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_SoundSystem(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:delete_SoundSystem",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_play_music__SWIG_0(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    std::string arg2 ;
-    int arg3 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOO:SoundSystem_play_music",&obj0,&obj1,&obj2)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        std::string *ptr = (std::string *)0;
-        int res = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = *ptr;
-        if (res == SWIG_NEWOBJ) delete ptr;
-    }
-    {
-        arg3 = (int)(SWIG_As_int(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    (arg1)->play_music(arg2,arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_play_music__SWIG_1(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    std::string arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:SoundSystem_play_music",&obj0,&obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        std::string *ptr = (std::string *)0;
-        int res = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = *ptr;
-        if (res == SWIG_NEWOBJ) delete ptr;
-    }
-    (arg1)->play_music(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_play_music(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[4];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 2) {
-        int _v;
-        {
-            void *ptr;
-            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_SoundSystem, 0) == -1) {
-                _v = 0;
-                PyErr_Clear();
-            } else {
-                _v = 1;
-            }
-        }
-        if (_v) {
-            _v = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-            if (_v) {
-                return _wrap_SoundSystem_play_music__SWIG_1(self,args);
-            }
-        }
-    }
-    if (argc == 3) {
-        int _v;
-        {
-            void *ptr;
-            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_SoundSystem, 0) == -1) {
-                _v = 0;
-                PyErr_Clear();
-            } else {
-                _v = 1;
-            }
-        }
-        if (_v) {
-            _v = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-            if (_v) {
-                _v = SWIG_Check_int(argv[2]);
-                if (_v) {
-                    return _wrap_SoundSystem_play_music__SWIG_0(self,args);
-                }
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'SoundSystem_play_music'");
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_play_sound__SWIG_0(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    std::string arg2 ;
-    double arg3 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOO:SoundSystem_play_sound",&obj0,&obj1,&obj2)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        std::string *ptr = (std::string *)0;
-        int res = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = *ptr;
-        if (res == SWIG_NEWOBJ) delete ptr;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    (arg1)->play_sound(arg2,arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_play_sound__SWIG_1(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    std::string arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:SoundSystem_play_sound",&obj0,&obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        std::string *ptr = (std::string *)0;
-        int res = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = *ptr;
-        if (res == SWIG_NEWOBJ) delete ptr;
-    }
-    (arg1)->play_sound(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_play_sound(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[4];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 2) {
-        int _v;
-        {
-            void *ptr;
-            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_SoundSystem, 0) == -1) {
-                _v = 0;
-                PyErr_Clear();
-            } else {
-                _v = 1;
-            }
-        }
-        if (_v) {
-            _v = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-            if (_v) {
-                return _wrap_SoundSystem_play_sound__SWIG_1(self,args);
-            }
-        }
-    }
-    if (argc == 3) {
-        int _v;
-        {
-            void *ptr;
-            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_SoundSystem, 0) == -1) {
-                _v = 0;
-                PyErr_Clear();
-            } else {
-                _v = 1;
-            }
-        }
-        if (_v) {
-            _v = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-            if (_v) {
-                _v = SWIG_Check_double(argv[2]);
-                if (_v) {
-                    return _wrap_SoundSystem_play_sound__SWIG_0(self,args);
-                }
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'SoundSystem_play_sound'");
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_stop_sound(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    std::string arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:SoundSystem_stop_sound",&obj0,&obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        std::string *ptr = (std::string *)0;
-        int res = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::string", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::string");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = *ptr;
-        if (res == SWIG_NEWOBJ) delete ptr;
-    }
-    (arg1)->stop_sound(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_set_music_volume(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    double arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:SoundSystem_set_music_volume",&obj0,&obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    (arg1)->set_music_volume(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_set_sound_volume(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    double arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:SoundSystem_set_sound_volume",&obj0,&obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    (arg1)->set_sound_volume(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_load_music_volume(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    double result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:SoundSystem_load_music_volume",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = (double)(arg1)->load_music_volume();
-    
-    {
-        resultobj = SWIG_From_double((double)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_load_sound_volume(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    double result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:SoundSystem_load_sound_volume",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = (double)(arg1)->load_sound_volume();
-    
-    {
-        resultobj = SWIG_From_double((double)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_playing_music(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    bool result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:SoundSystem_playing_music",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = (bool)(arg1)->playing_music();
-    
-    {
-        resultobj = SWIG_From_bool((bool)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_playing_music_file(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    std::string result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:SoundSystem_playing_music_file",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = (arg1)->playing_music_file();
-    
-    {
-        resultobj = SWIG_From_std_string((std::string)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * SoundSystem_swigregister(PyObject *, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_SoundSystem, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)"");
-}
-static int _wrap_tw_sound_set(PyObject *_val) {
-    {
-        void *temp;
-        if ((SWIG_ConvertPtr(_val, &temp, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN)) == -1) {
-            SWIG_append_errmsg("C/C++ variable 'tw_sound'");
-            return 1;
-        }
-        tw_sound = (SoundSystem *) temp;
-    }
-    return 0;
-}
-
-
-static PyObject *_wrap_tw_sound_get(void) {
-    PyObject *pyobj = NULL;
-    
-    pyobj = SWIG_NewPointerObj((void *)(tw_sound), SWIGTYPE_p_SoundSystem, 0);
-    return pyobj;
-}
-
-
-static PyObject *_wrap_GetSoundSystem(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)":GetSoundSystem")) goto fail;
-    result = (SoundSystem *)GetSoundSystem();
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_SoundSystem, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_vectorString__SWIG_0(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)":new_vectorString")) goto fail;
-    result = (std::vector<std::string > *)new std::vector<std::string >();
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_vectorString__SWIG_1(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = 0 ;
-    std::vector<std::string > *result;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:new_vectorString",&obj0)) goto fail;
-    {
-        std::vector<std::string,std::allocator<std::string > > *ptr = (std::vector<std::string,std::allocator<std::string > > *)0;
-        res1 = swig::asptr(obj0, &ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::vector<std::string >", obj0);
-        } else if (!ptr) {
-            SWIG_null_ref("std::vector<std::string >");
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    result = (std::vector<std::string > *)new std::vector<std::string >((std::vector<std::string > const &)*arg1);
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 1);
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_empty(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    bool result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:vectorString_empty",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = (bool)((std::vector<std::string > const *)arg1)->empty();
-    
-    {
-        resultobj = SWIG_From_bool((bool)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_size(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string >::size_type result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:vectorString_size",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = ((std::vector<std::string > const *)arg1)->size();
-    
-    {
-        resultobj = SWIG_From_unsigned_SS_long((unsigned long)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_clear(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:vectorString_clear",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    (arg1)->clear();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_swap(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string > *arg2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:vectorString_swap",&obj0,&obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        SWIG_Python_ConvertPtr(obj1, (void **)&arg2, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        if (arg2 == NULL) {
-            SWIG_null_ref("std::vector<std::string >");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    (arg1)->swap(*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_get_allocator(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    SwigValueWrapper<std::allocator<std::string > > result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:vectorString_get_allocator",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = ((std::vector<std::string > const *)arg1)->get_allocator();
-    
-    {
-        std::vector<std::string >::allocator_type * resultptr;
-        resultptr = new std::vector<std::string >::allocator_type((std::vector<std::string >::allocator_type &)(result));
-        resultobj = SWIG_NewPointerObj((void *)(resultptr), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type, 1);
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_vectorString__SWIG_2(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string >::size_type arg1 ;
-    std::vector<std::string > *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:new_vectorString",&obj0)) goto fail;
-    {
-        arg1 = (std::vector<std::string >::size_type)(SWIG_As_unsigned_SS_long(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    result = (std::vector<std::string > *)new std::vector<std::string >(arg1);
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_pop_back(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:vectorString_pop_back",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    (arg1)->pop_back();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_resize__SWIG_0(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string >::size_type arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:vectorString_resize",&obj0,&obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector<std::string >::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    (arg1)->resize(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_vectorString__SWIG_3(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string >::size_type arg1 ;
-    std::vector<std::string >::value_type *arg2 = 0 ;
-    std::vector<std::string > *result;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:new_vectorString",&obj0,&obj1)) goto fail;
-    {
-        arg1 = (std::vector<std::string >::size_type)(SWIG_As_unsigned_SS_long(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::vector<std::string >::value_type", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::vector<std::string >::value_type");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    result = (std::vector<std::string > *)new std::vector<std::string >(arg1,(std::string const &)*arg2);
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 1);
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_vectorString(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[3];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii < argc) && (ii < 2); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 0) {
-        return _wrap_new_vectorString__SWIG_0(self,args);
-    }
-    if (argc == 1) {
-        int _v;
-        _v = SWIG_Check_unsigned_SS_long(argv[0]);
-        if (_v) {
-            return _wrap_new_vectorString__SWIG_2(self,args);
-        }
-    }
-    if (argc == 1) {
-        int _v;
-        _v = swig::asptr(argv[0], (std::vector<std::string,std::allocator<std::string > >**)(0));
-        if (_v) {
-            return _wrap_new_vectorString__SWIG_1(self,args);
-        }
-    }
-    if (argc == 2) {
-        int _v;
-        _v = SWIG_Check_unsigned_SS_long(argv[0]);
-        if (_v) {
-            _v = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-            if (_v) {
-                return _wrap_new_vectorString__SWIG_3(self,args);
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'new_vectorString'");
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_push_back(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string >::value_type *arg2 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:vectorString_push_back",&obj0,&obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::vector<std::string >::value_type", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::vector<std::string >::value_type");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    (arg1)->push_back((std::string const &)*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_front(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string >::value_type *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:vectorString_front",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        std::vector<std::string >::value_type const &_result_ref = ((std::vector<std::string > const *)arg1)->front();
-        result = (std::vector<std::string >::value_type *) &_result_ref;
-    }
-    
-    {
-        resultobj = SWIG_From_std_string((std::string)(*result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_back(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string >::value_type *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:vectorString_back",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        std::vector<std::string >::value_type const &_result_ref = ((std::vector<std::string > const *)arg1)->back();
-        result = (std::vector<std::string >::value_type *) &_result_ref;
-    }
-    
-    {
-        resultobj = SWIG_From_std_string((std::string)(*result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_assign(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string >::size_type arg2 ;
-    std::vector<std::string >::value_type *arg3 = 0 ;
-    int res3 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOO:vectorString_assign",&obj0,&obj1,&obj2)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector<std::string >::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res3 = SWIG_AsPtr_std_string(obj2, &ptr);
-        if (!res3) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::vector<std::string >::value_type", obj2);
-        } else if (!ptr) {
-            SWIG_null_ref("std::vector<std::string >::value_type");
-        }
-        if (SWIG_arg_fail(3)) SWIG_fail;
-        arg3 = ptr;
-    }
-    (arg1)->assign(arg2,(std::string const &)*arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res3 == SWIG_NEWOBJ) delete arg3;
-    return resultobj;
-    fail:
-    if (res3 == SWIG_NEWOBJ) delete arg3;
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_resize__SWIG_1(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string >::size_type arg2 ;
-    std::vector<std::string >::value_type *arg3 = 0 ;
-    int res3 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOO:vectorString_resize",&obj0,&obj1,&obj2)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector<std::string >::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res3 = SWIG_AsPtr_std_string(obj2, &ptr);
-        if (!res3) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::vector<std::string >::value_type", obj2);
-        } else if (!ptr) {
-            SWIG_null_ref("std::vector<std::string >::value_type");
-        }
-        if (SWIG_arg_fail(3)) SWIG_fail;
-        arg3 = ptr;
-    }
-    (arg1)->resize(arg2,(std::string const &)*arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res3 == SWIG_NEWOBJ) delete arg3;
-    return resultobj;
-    fail:
-    if (res3 == SWIG_NEWOBJ) delete arg3;
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_resize(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[4];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 2) {
-        int _v;
-        {
-            void *ptr;
-            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0) == -1) {
-                _v = 0;
-                PyErr_Clear();
-            } else {
-                _v = 1;
-            }
-        }
-        if (_v) {
-            _v = SWIG_Check_unsigned_SS_long(argv[1]);
-            if (_v) {
-                return _wrap_vectorString_resize__SWIG_0(self,args);
-            }
-        }
-    }
-    if (argc == 3) {
-        int _v;
-        {
-            void *ptr;
-            if (SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0) == -1) {
-                _v = 0;
-                PyErr_Clear();
-            } else {
-                _v = 1;
-            }
-        }
-        if (_v) {
-            _v = SWIG_Check_unsigned_SS_long(argv[1]);
-            if (_v) {
-                _v = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
-                if (_v) {
-                    return _wrap_vectorString_resize__SWIG_1(self,args);
-                }
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_NotImplementedError,"No matching function for overloaded 'vectorString_resize'");
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_reserve(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string >::size_type arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:vectorString_reserve",&obj0,&obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector<std::string >::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    (arg1)->reserve(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_capacity(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string >::size_type result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:vectorString_capacity",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = ((std::vector<std::string > const *)arg1)->capacity();
-    
-    {
-        resultobj = SWIG_From_unsigned_SS_long((unsigned long)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___nonzero__(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    bool result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:vectorString___nonzero__",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = (bool)std_vector_Sl_std_string_Sg____nonzero__((std::vector<std::string > const *)arg1);
-    
-    {
-        resultobj = SWIG_From_bool((bool)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___len__(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string >::size_type result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:vectorString___len__",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = std_vector_Sl_std_string_Sg____len__((std::vector<std::string > const *)arg1);
-    
-    {
-        resultobj = SWIG_From_unsigned_SS_long((unsigned long)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_pop(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string >::value_type result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:vectorString_pop",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        try {
-            result = std_vector_Sl_std_string_Sg__pop(arg1);
-        }
-        catch (std::out_of_range& e) {
-            if (!PyErr_Occurred()) {
-                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
-            } else {
-                SWIG_fail;
-            }
-        }
-        /*@c:\\swig\\Lib\\exception.i,341,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
-            SWIG_exception(SWIG_SystemError, e.what() );
-        }
-        catch (...) {
-            SWIG_exception(SWIG_UnknownError, "unknown exception");
-        }
-        /*@@*/
-    }
-    {
-        resultobj = SWIG_From_std_string((std::string)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___getslice__(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string >::difference_type arg2 ;
-    std::vector<std::string >::difference_type arg3 ;
-    std::vector<std::string,std::allocator<std::string > > *result;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOO:vectorString___getslice__",&obj0,&obj1,&obj2)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector<std::string >::difference_type)(SWIG_As_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (std::vector<std::string >::difference_type)(SWIG_As_long(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        try {
-            result = (std::vector<std::string,std::allocator<std::string > > *)std_vector_Sl_std_string_Sg____getslice__(arg1,arg2,arg3);
-        }
-        catch (std::out_of_range& e) {
-            if (!PyErr_Occurred()) {
-                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
-            } else {
-                SWIG_fail;
-            }
-        }
-        /*@c:\\swig\\Lib\\exception.i,341,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
-            SWIG_exception(SWIG_SystemError, e.what() );
-        }
-        catch (...) {
-            SWIG_exception(SWIG_UnknownError, "unknown exception");
-        }
-        /*@@*/
-    }
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___setslice__(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string >::difference_type arg2 ;
-    std::vector<std::string >::difference_type arg3 ;
-    std::vector<std::string,std::allocator<std::string > > *arg4 = 0 ;
-    int res4 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOOO:vectorString___setslice__",&obj0,&obj1,&obj2,&obj3)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector<std::string >::difference_type)(SWIG_As_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (std::vector<std::string >::difference_type)(SWIG_As_long(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        std::vector<std::string,std::allocator<std::string > > *ptr = (std::vector<std::string,std::allocator<std::string > > *)0;
-        res4 = swig::asptr(obj3, &ptr);
-        if (!res4) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::vector<std::string,std::allocator<std::string > >", obj3);
-        } else if (!ptr) {
-            SWIG_null_ref("std::vector<std::string,std::allocator<std::string > >");
-        }
-        if (SWIG_arg_fail(4)) SWIG_fail;
-        arg4 = ptr;
-    }
-    {
-        try {
-            std_vector_Sl_std_string_Sg____setslice__(arg1,arg2,arg3,(std::vector<std::string,std::allocator<std::string > > const &)*arg4);
-        }
-        catch (std::out_of_range& e) {
-            if (!PyErr_Occurred()) {
-                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
-            } else {
-                SWIG_fail;
-            }
-        }
-        catch (std::invalid_argument& e) {
-            if (!PyErr_Occurred()) {
-                SWIG_exception(SWIG_TypeError,const_cast<char*>(e.what()));
-            } else {
-                SWIG_fail;
-            }      
-        }
-        /*@c:\\swig\\Lib\\exception.i,341,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
-            SWIG_exception(SWIG_SystemError, e.what() );
-        }
-        catch (...) {
-            SWIG_exception(SWIG_UnknownError, "unknown exception");
-        }
-        /*@@*/
-    }
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res4 == SWIG_NEWOBJ) delete arg4;
-    return resultobj;
-    fail:
-    if (res4 == SWIG_NEWOBJ) delete arg4;
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___delslice__(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string >::difference_type arg2 ;
-    std::vector<std::string >::difference_type arg3 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOO:vectorString___delslice__",&obj0,&obj1,&obj2)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector<std::string >::difference_type)(SWIG_As_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (std::vector<std::string >::difference_type)(SWIG_As_long(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        try {
-            std_vector_Sl_std_string_Sg____delslice__(arg1,arg2,arg3);
-        }
-        catch (std::out_of_range& e) {
-            if (!PyErr_Occurred()) {
-                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
-            } else {
-                SWIG_fail;
-            }
-        }
-        /*@c:\\swig\\Lib\\exception.i,341,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
-            SWIG_exception(SWIG_SystemError, e.what() );
-        }
-        catch (...) {
-            SWIG_exception(SWIG_UnknownError, "unknown exception");
-        }
-        /*@@*/
-    }
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___delitem__(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string >::difference_type arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:vectorString___delitem__",&obj0,&obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector<std::string >::difference_type)(SWIG_As_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        try {
-            std_vector_Sl_std_string_Sg____delitem__(arg1,arg2);
-        }
-        catch (std::out_of_range& e) {
-            if (!PyErr_Occurred()) {
-                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
-            } else {
-                SWIG_fail;
-            }
-        }
-        /*@c:\\swig\\Lib\\exception.i,341,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
-            SWIG_exception(SWIG_SystemError, e.what() );
-        }
-        catch (...) {
-            SWIG_exception(SWIG_UnknownError, "unknown exception");
-        }
-        /*@@*/
-    }
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___getitem__(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string >::difference_type arg2 ;
-    std::vector<std::string >::value_type *result;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:vectorString___getitem__",&obj0,&obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector<std::string >::difference_type)(SWIG_As_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        try {
-            {
-                std::vector<std::string >::value_type const &_result_ref = std_vector_Sl_std_string_Sg____getitem__((std::vector<std::string > const *)arg1,arg2);
-                result = (std::vector<std::string >::value_type *) &_result_ref;
-            }
-        }
-        catch (std::out_of_range& e) {
-            if (!PyErr_Occurred()) {
-                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
-            } else {
-                SWIG_fail;
-            }
-        }
-        /*@c:\\swig\\Lib\\exception.i,341,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
-            SWIG_exception(SWIG_SystemError, e.what() );
-        }
-        catch (...) {
-            SWIG_exception(SWIG_UnknownError, "unknown exception");
-        }
-        /*@@*/
-    }
-    {
-        resultobj = SWIG_From_std_string((std::string)(*result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___setitem__(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string >::difference_type arg2 ;
-    std::vector<std::string >::value_type *arg3 = 0 ;
-    int res3 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OOO:vectorString___setitem__",&obj0,&obj1,&obj2)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector<std::string >::difference_type)(SWIG_As_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res3 = SWIG_AsPtr_std_string(obj2, &ptr);
-        if (!res3) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::vector<std::string >::value_type", obj2);
-        } else if (!ptr) {
-            SWIG_null_ref("std::vector<std::string >::value_type");
-        }
-        if (SWIG_arg_fail(3)) SWIG_fail;
-        arg3 = ptr;
-    }
-    {
-        try {
-            std_vector_Sl_std_string_Sg____setitem__(arg1,arg2,(std::string const &)*arg3);
-        }
-        catch (std::out_of_range& e) {
-            if (!PyErr_Occurred()) {
-                SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
-            } else {
-                SWIG_fail;
-            }
-        }
-        /*@c:\\swig\\Lib\\exception.i,341,SWIG_CATCH_UNKNOWN@*/  catch (std::exception& e) {
-            SWIG_exception(SWIG_SystemError, e.what() );
-        }
-        catch (...) {
-            SWIG_exception(SWIG_UnknownError, "unknown exception");
-        }
-        /*@@*/
-    }
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res3 == SWIG_NEWOBJ) delete arg3;
-    return resultobj;
-    fail:
-    if (res3 == SWIG_NEWOBJ) delete arg3;
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_append(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    std::vector<std::string >::value_type *arg2 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"OO:vectorString_append",&obj0,&obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error("std::vector<std::string >::value_type", obj1);
-        } else if (!ptr) {
-            SWIG_null_ref("std::vector<std::string >::value_type");
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    std_vector_Sl_std_string_Sg__append(arg1,(std::string const &)*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_vectorString(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)"O:delete_vectorString",&obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * vectorString_swigregister(PyObject *, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)"");
-}
-static PyMethodDef SwigMethods[] = {
-	 { (char *)"GameAction_clean", _wrap_GameAction_clean, METH_VARARGS, NULL},
-	 { (char *)"GameAction_add_system", _wrap_GameAction_add_system, METH_VARARGS, NULL},
-	 { (char *)"GameAction_add_planet", _wrap_GameAction_add_planet, METH_VARARGS, NULL},
-	 { (char *)"GameAction_add_orbiter_station", _wrap_GameAction_add_orbiter_station, METH_VARARGS, NULL},
-	 { (char *)"GameAction_add_asteroid", _wrap_GameAction_add_asteroid, METH_VARARGS, NULL},
-	 { (char *)"GameAction_add_player", _wrap_GameAction_add_player, METH_VARARGS, NULL},
-	 { (char *)"GameAction_add_ship", _wrap_GameAction_add_ship, METH_VARARGS, NULL},
-	 { (char *)"GameAction_get_string_flag", _wrap_GameAction_get_string_flag, METH_VARARGS, NULL},
-	 { (char *)"GameAction_save_flag", _wrap_GameAction_save_flag, METH_VARARGS, NULL},
-	 { (char *)"GameAction_get_double_flag", _wrap_GameAction_get_double_flag, METH_VARARGS, NULL},
-	 { (char *)"GameAction_get_player_ship_id", _wrap_GameAction_get_player_ship_id, METH_VARARGS, NULL},
-	 { (char *)"GameAction_get_player_star_system", _wrap_GameAction_get_player_star_system, METH_VARARGS, NULL},
-	 { (char *)"GameAction_set_target", _wrap_GameAction_set_target, METH_VARARGS, NULL},
-	 { (char *)"GameAction_disable_weapon", _wrap_GameAction_disable_weapon, METH_VARARGS, NULL},
-	 { (char *)"GameAction_enable_weapon", _wrap_GameAction_enable_weapon, METH_VARARGS, NULL},
-	 { (char *)"GameAction_go_to_point", _wrap_GameAction_go_to_point, METH_VARARGS, NULL},
-	 { (char *)"GameAction_go_to_location", _wrap_GameAction_go_to_location, METH_VARARGS, NULL},
-	 { (char *)"GameAction_guard_location", _wrap_GameAction_guard_location, METH_VARARGS, NULL},
-	 { (char *)"GameAction_guard_point", _wrap_GameAction_guard_point, METH_VARARGS, NULL},
-	 { (char *)"GameAction_set_ship_team", _wrap_GameAction_set_ship_team, METH_VARARGS, NULL},
-	 { (char *)"GameAction_get_enemy_team", _wrap_GameAction_get_enemy_team, METH_VARARGS, NULL},
-	 { (char *)"GameAction_get_player_team", _wrap_GameAction_get_player_team, METH_VARARGS, NULL},
-	 { (char *)"GameAction_remove_location", _wrap_GameAction_remove_location, METH_VARARGS, NULL},
-	 { (char *)"GameAction_set_crew", _wrap_GameAction_set_crew, METH_VARARGS, NULL},
-	 { (char *)"GameAction_get_location_pos_x", _wrap_GameAction_get_location_pos_x, METH_VARARGS, NULL},
-	 { (char *)"GameAction_get_location_pos_y", _wrap_GameAction_get_location_pos_y, METH_VARARGS, NULL},
-	 { (char *)"GameAction_exist", _wrap_GameAction_exist, METH_VARARGS, NULL},
-	 { (char *)"GameAction_end_game", _wrap_GameAction_end_game, METH_VARARGS, NULL},
-	 { (char *)"GameAction_scroll_text", _wrap_GameAction_scroll_text, METH_VARARGS, NULL},
-	 { (char *)"GameAction_print_message", _wrap_GameAction_print_message, METH_VARARGS, NULL},
-	 { (char *)"GameAction_set_camera_mode", _wrap_GameAction_set_camera_mode, METH_VARARGS, NULL},
-	 { (char *)"new_GameAction", _wrap_new_GameAction, METH_VARARGS, NULL},
-	 { (char *)"delete_GameAction", _wrap_delete_GameAction, METH_VARARGS, NULL},
-	 { (char *)"GameAction_swigregister", GameAction_swigregister, METH_VARARGS, NULL},
-	 { (char *)"DialogApi_startDialog", _wrap_DialogApi_startDialog, METH_VARARGS, NULL},
-	 { (char *)"DialogApi_endDialog", _wrap_DialogApi_endDialog, METH_VARARGS, NULL},
-	 { (char *)"DialogApi_askPlayer", _wrap_DialogApi_askPlayer, METH_VARARGS, NULL},
-	 { (char *)"DialogApi_showText", _wrap_DialogApi_showText, METH_VARARGS, NULL},
-	 { (char *)"DialogApi_showAlienPicture", _wrap_DialogApi_showAlienPicture, METH_VARARGS, NULL},
-	 { (char *)"new_DialogApi", _wrap_new_DialogApi, METH_VARARGS, NULL},
-	 { (char *)"delete_DialogApi", _wrap_delete_DialogApi, METH_VARARGS, NULL},
-	 { (char *)"DialogApi_swigregister", DialogApi_swigregister, METH_VARARGS, NULL},
-	 { (char *)"GameConfig_SetGameDirectory", _wrap_GameConfig_SetGameDirectory, METH_VARARGS, NULL},
-	 { (char *)"GameConfig_GetGameDirectory", _wrap_GameConfig_GetGameDirectory, METH_VARARGS, NULL},
-	 { (char *)"GameConfig_GetAbsolutePath", _wrap_GameConfig_GetAbsolutePath, METH_VARARGS, NULL},
-	 { (char *)"new_GameConfig", _wrap_new_GameConfig, METH_VARARGS, NULL},
-	 { (char *)"delete_GameConfig", _wrap_delete_GameConfig, METH_VARARGS, NULL},
-	 { (char *)"GameConfig_swigregister", GameConfig_swigregister, METH_VARARGS, NULL},
-	 { (char *)"EventManager_clean", _wrap_EventManager_clean, METH_VARARGS, NULL},
-	 { (char *)"EventManager_setSingleTimeEvent", _wrap_EventManager_setSingleTimeEvent, METH_VARARGS, NULL},
-	 { (char *)"EventManager_setRepeatableTimeEvent", _wrap_EventManager_setRepeatableTimeEvent, METH_VARARGS, NULL},
-	 { (char *)"EventManager_disableEvent", _wrap_EventManager_disableEvent, METH_VARARGS, NULL},
-	 { (char *)"EventManager_shipDeathById", _wrap_EventManager_shipDeathById, METH_VARARGS, NULL},
-	 { (char *)"EventManager_shipDeathByType", _wrap_EventManager_shipDeathByType, METH_VARARGS, NULL},
-	 { (char *)"EventManager_distanceMoreThen", _wrap_EventManager_distanceMoreThen, METH_VARARGS, NULL},
-	 { (char *)"EventManager_distanceLessThen", _wrap_EventManager_distanceLessThen, METH_VARARGS, NULL},
-	 { (char *)"EventManager_jumpToSystem", _wrap_EventManager_jumpToSystem, METH_VARARGS, NULL},
-	 { (char *)"EventManager_AddEventCondition", _wrap_EventManager_AddEventCondition, METH_VARARGS, NULL},
-	 { (char *)"new_EventManager", _wrap_new_EventManager, METH_VARARGS, NULL},
-	 { (char *)"delete_EventManager", _wrap_delete_EventManager, METH_VARARGS, NULL},
-	 { (char *)"EventManager_swigregister", EventManager_swigregister, METH_VARARGS, NULL},
-	 { (char *)"new_SoundSystem", _wrap_new_SoundSystem, METH_VARARGS, NULL},
-	 { (char *)"delete_SoundSystem", _wrap_delete_SoundSystem, METH_VARARGS, NULL},
-	 { (char *)"SoundSystem_play_music", _wrap_SoundSystem_play_music, METH_VARARGS, NULL},
-	 { (char *)"SoundSystem_play_sound", _wrap_SoundSystem_play_sound, METH_VARARGS, NULL},
-	 { (char *)"SoundSystem_stop_sound", _wrap_SoundSystem_stop_sound, METH_VARARGS, NULL},
-	 { (char *)"SoundSystem_set_music_volume", _wrap_SoundSystem_set_music_volume, METH_VARARGS, NULL},
-	 { (char *)"SoundSystem_set_sound_volume", _wrap_SoundSystem_set_sound_volume, METH_VARARGS, NULL},
-	 { (char *)"SoundSystem_load_music_volume", _wrap_SoundSystem_load_music_volume, METH_VARARGS, NULL},
-	 { (char *)"SoundSystem_load_sound_volume", _wrap_SoundSystem_load_sound_volume, METH_VARARGS, NULL},
-	 { (char *)"SoundSystem_playing_music", _wrap_SoundSystem_playing_music, METH_VARARGS, NULL},
-	 { (char *)"SoundSystem_playing_music_file", _wrap_SoundSystem_playing_music_file, METH_VARARGS, NULL},
-	 { (char *)"SoundSystem_swigregister", SoundSystem_swigregister, METH_VARARGS, NULL},
-	 { (char *)"GetSoundSystem", _wrap_GetSoundSystem, METH_VARARGS, NULL},
-	 { (char *)"vectorString_empty", _wrap_vectorString_empty, METH_VARARGS, NULL},
-	 { (char *)"vectorString_size", _wrap_vectorString_size, METH_VARARGS, NULL},
-	 { (char *)"vectorString_clear", _wrap_vectorString_clear, METH_VARARGS, NULL},
-	 { (char *)"vectorString_swap", _wrap_vectorString_swap, METH_VARARGS, NULL},
-	 { (char *)"vectorString_get_allocator", _wrap_vectorString_get_allocator, METH_VARARGS, NULL},
-	 { (char *)"vectorString_pop_back", _wrap_vectorString_pop_back, METH_VARARGS, NULL},
-	 { (char *)"new_vectorString", _wrap_new_vectorString, METH_VARARGS, NULL},
-	 { (char *)"vectorString_push_back", _wrap_vectorString_push_back, METH_VARARGS, NULL},
-	 { (char *)"vectorString_front", _wrap_vectorString_front, METH_VARARGS, NULL},
-	 { (char *)"vectorString_back", _wrap_vectorString_back, METH_VARARGS, NULL},
-	 { (char *)"vectorString_assign", _wrap_vectorString_assign, METH_VARARGS, NULL},
-	 { (char *)"vectorString_resize", _wrap_vectorString_resize, METH_VARARGS, NULL},
-	 { (char *)"vectorString_reserve", _wrap_vectorString_reserve, METH_VARARGS, NULL},
-	 { (char *)"vectorString_capacity", _wrap_vectorString_capacity, METH_VARARGS, NULL},
-	 { (char *)"vectorString___nonzero__", _wrap_vectorString___nonzero__, METH_VARARGS, NULL},
-	 { (char *)"vectorString___len__", _wrap_vectorString___len__, METH_VARARGS, NULL},
-	 { (char *)"vectorString_pop", _wrap_vectorString_pop, METH_VARARGS, NULL},
-	 { (char *)"vectorString___getslice__", _wrap_vectorString___getslice__, METH_VARARGS, NULL},
-	 { (char *)"vectorString___setslice__", _wrap_vectorString___setslice__, METH_VARARGS, NULL},
-	 { (char *)"vectorString___delslice__", _wrap_vectorString___delslice__, METH_VARARGS, NULL},
-	 { (char *)"vectorString___delitem__", _wrap_vectorString___delitem__, METH_VARARGS, NULL},
-	 { (char *)"vectorString___getitem__", _wrap_vectorString___getitem__, METH_VARARGS, NULL},
-	 { (char *)"vectorString___setitem__", _wrap_vectorString___setitem__, METH_VARARGS, NULL},
-	 { (char *)"vectorString_append", _wrap_vectorString_append, METH_VARARGS, NULL},
-	 { (char *)"delete_vectorString", _wrap_delete_vectorString, METH_VARARGS, NULL},
-	 { (char *)"vectorString_swigregister", vectorString_swigregister, METH_VARARGS, NULL},
-	 { NULL, NULL, 0, NULL }
-};
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
-
-static swig_type_info _swigt__p_DialogApi = {"_p_DialogApi", "DialogApi *", 0, 0, 0};
-static swig_type_info _swigt__p_EventManager = {"_p_EventManager", "EventManager *", 0, 0, 0};
-static swig_type_info _swigt__p_GameAction = {"_p_GameAction", "GameAction *", 0, 0, 0};
-static swig_type_info _swigt__p_GameConfig = {"_p_GameConfig", "GameConfig *", 0, 0, 0};
-static swig_type_info _swigt__p_SoundSystem = {"_p_SoundSystem", "SoundSystem *", 0, 0, 0};
-static swig_type_info _swigt__p_allocator_type = {"_p_allocator_type", "allocator_type *", 0, 0, 0};
-static swig_type_info _swigt__p_boost__shared_ptrTSpaceLocation_t = {"_p_boost__shared_ptrTSpaceLocation_t", "boost::shared_ptr<SpaceLocation > *|SpaceLocationPtr *", 0, 0, 0};
-static swig_type_info _swigt__p_boost__shared_ptrTTGameEvent_t = {"_p_boost__shared_ptrTTGameEvent_t", "boost::shared_ptr<TGameEvent > *|TGameEventPtr *", 0, 0, 0};
-static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, 0};
-static swig_type_info _swigt__p_difference_type = {"_p_difference_type", "difference_type *", 0, 0, 0};
-static swig_type_info _swigt__p_size_type = {"_p_size_type", "size_type *", 0, 0, 0};
-static swig_type_info _swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t = {"_p_std__vectorTstd__string_std__allocatorTstd__string_t_t", "std::vector<std::string > *", 0, 0, 0};
-static swig_type_info _swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type = {"_p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type", "std::allocator<std::string > *|std::vector<std::string >::allocator_type *", 0, 0, 0};
-static swig_type_info _swigt__p_value_type = {"_p_value_type", "value_type *", 0, 0, 0};
-static swig_type_info _swigt__ptrdiff_t = {"_ptrdiff_t", "ptrdiff_t", 0, 0, 0};
-static swig_type_info _swigt__size_t = {"_size_t", "size_t", 0, 0, 0};
-static swig_type_info _swigt__std__ptrdiff_t = {"_std__ptrdiff_t", "std::ptrdiff_t", 0, 0, 0};
-static swig_type_info _swigt__std__size_t = {"_std__size_t", "std::size_t", 0, 0, 0};
-
-static swig_type_info *swig_type_initial[] = {
-  &_swigt__p_DialogApi,
-  &_swigt__p_EventManager,
-  &_swigt__p_GameAction,
-  &_swigt__p_GameConfig,
-  &_swigt__p_SoundSystem,
-  &_swigt__p_allocator_type,
-  &_swigt__p_boost__shared_ptrTSpaceLocation_t,
-  &_swigt__p_boost__shared_ptrTTGameEvent_t,
-  &_swigt__p_char,
-  &_swigt__p_difference_type,
-  &_swigt__p_size_type,
-  &_swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t,
-  &_swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type,
-  &_swigt__p_value_type,
-  &_swigt__ptrdiff_t,
-  &_swigt__size_t,
-  &_swigt__std__ptrdiff_t,
-  &_swigt__std__size_t,
-};
-
-static swig_cast_info _swigc__p_DialogApi[] = {  {&_swigt__p_DialogApi, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_EventManager[] = {  {&_swigt__p_EventManager, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_GameAction[] = {  {&_swigt__p_GameAction, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_GameConfig[] = {  {&_swigt__p_GameConfig, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_SoundSystem[] = {  {&_swigt__p_SoundSystem, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_allocator_type[] = {  {&_swigt__p_allocator_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_boost__shared_ptrTSpaceLocation_t[] = {  {&_swigt__p_boost__shared_ptrTSpaceLocation_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_boost__shared_ptrTTGameEvent_t[] = {  {&_swigt__p_boost__shared_ptrTTGameEvent_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_difference_type[] = {  {&_swigt__p_difference_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_size_type[] = {  {&_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__vectorTstd__string_std__allocatorTstd__string_t_t[] = {  {&_swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type[] = {  {&_swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_value_type[] = {  {&_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__ptrdiff_t[] = {  {&_swigt__ptrdiff_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__size_t[] = {  {&_swigt__size_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__std__ptrdiff_t[] = {  {&_swigt__std__ptrdiff_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__std__size_t[] = {  {&_swigt__std__size_t, 0, 0, 0},{0, 0, 0, 0}};
-
-static swig_cast_info *swig_cast_initial[] = {
-  _swigc__p_DialogApi,
-  _swigc__p_EventManager,
-  _swigc__p_GameAction,
-  _swigc__p_GameConfig,
-  _swigc__p_SoundSystem,
-  _swigc__p_allocator_type,
-  _swigc__p_boost__shared_ptrTSpaceLocation_t,
-  _swigc__p_boost__shared_ptrTTGameEvent_t,
-  _swigc__p_char,
-  _swigc__p_difference_type,
-  _swigc__p_size_type,
-  _swigc__p_std__vectorTstd__string_std__allocatorTstd__string_t_t,
-  _swigc__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type,
-  _swigc__p_value_type,
-  _swigc__ptrdiff_t,
-  _swigc__size_t,
-  _swigc__std__ptrdiff_t,
-  _swigc__std__size_t,
-};
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
-
-static swig_const_info swig_const_table[] = {
-{0, 0, 0, 0.0, 0, 0}};
-
-#ifdef __cplusplus
-}
-#endif
-/*************************************************************************
- * Type initialization:
- * This problem is tough by the requirement that no dynamic 
- * memory is used. Also, since swig_type_info structures store pointers to 
- * swig_cast_info structures and swig_cast_info structures store pointers back
- * to swig_type_info structures, we need some lookup code at initialization. 
- * The idea is that swig generates all the structures that are needed. 
- * The runtime then collects these partially filled structures. 
- * The SWIG_InitializeModule function takes these initial arrays out of 
- * swig_module, and does all the lookup, filling in the swig_module.types
- * array with the correct data and linking the correct swig_cast_info
- * structures together.
-
- * The generated swig_type_info structures are assigned staticly to an initial 
- * array. We just loop though that array, and handle each type individually.
- * First we lookup if this type has been already loaded, and if so, use the
- * loaded structure instead of the generated one. Then we have to fill in the
- * cast linked list. The cast data is initially stored in something like a
- * two-dimensional array. Each row corresponds to a type (there are the same
- * number of rows as there are in the swig_type_initial array). Each entry in
- * a column is one of the swig_cast_info structures for that type.
- * The cast_initial array is actually an array of arrays, because each row has
- * a variable number of columns. So to actually build the cast linked list,
- * we find the array of casts associated with the type, and loop through it 
- * adding the casts to the list. The one last trick we need to do is making
- * sure the type pointer in the swig_cast_info struct is correct.
-
- * First off, we lookup the cast->type name to see if it is already loaded. 
- * There are three cases to handle:
- *  1) If the cast->type has already been loaded AND the type we are adding
- *     casting info to has not been loaded (it is in this module), THEN we
- *     replace the cast->type pointer with the type pointer that has already
- *     been loaded.
- *  2) If BOTH types (the one we are adding casting info to, and the 
- *     cast->type) are loaded, THEN the cast info has already been loaded by
- *     the previous module so we just ignore it.
- *  3) Finally, if cast->type has not already been loaded, then we add that
- *     swig_cast_info to the linked list (because the cast->type) pointer will
- *     be correct.
-**/
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-    
-    SWIGRUNTIME void
-    SWIG_InitializeModule(void *clientdata) {
-        swig_type_info *type, *ret;
-        swig_cast_info *cast;
-        size_t i;
-        swig_module_info *module_head;
-        static int init_run = 0;
-        
-        clientdata = clientdata;
-        
-        if (init_run) return;
-        init_run = 1;
-        
-        /* Initialize the swig_module */
-        swig_module.type_initial = swig_type_initial;
-        swig_module.cast_initial = swig_cast_initial;
-        
-        /* Try and load any already created modules */
-        module_head = SWIG_GetModule(clientdata);
-        if (module_head) {
-            swig_module.next = module_head->next;
-            module_head->next = &swig_module;
-        } else {
-            /* This is the first module loaded */
-            swig_module.next = &swig_module;
-            SWIG_SetModule(clientdata, &swig_module);
-        }
-        
-        /* Now work on filling in swig_module.types */
-        for (i = 0; i < swig_module.size; ++i) {
-            type = 0;
-            
-            /* if there is another module already loaded */
-            if (swig_module.next != &swig_module) {
-                type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
-            }
-            if (type) {
-                /* Overwrite clientdata field */
-                if (swig_module.type_initial[i]->clientdata) type->clientdata = swig_module.type_initial[i]->clientdata;
-            } else {
-                type = swig_module.type_initial[i];
-            }
-            
-            /* Insert casting types */
-            cast = swig_module.cast_initial[i];
-            while (cast->type) {
-                /* Don't need to add information already in the list */
-                ret = 0;
-                if (swig_module.next != &swig_module) {
-                    ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
-                }
-                if (ret && type == swig_module.type_initial[i]) {
-                    cast->type = ret;
-                    ret = 0;
-                }
-                
-                if (!ret) {
-                    if (type->cast) {
-                        type->cast->prev = cast;
-                        cast->next = type->cast;
-                    }
-                    type->cast = cast;
-                }
-                
-                cast++;
-            }
-            
-            /* Set entry in modules->types array equal to the type */
-            swig_module.types[i] = type;
-        }
-    }
-    
-    /* This function will propagate the clientdata field of type to
-    * any new swig_type_info structures that have been added into the list
-    * of equivalent types.  It is like calling
-    * SWIG_TypeClientData(type, clientdata) a second time.
-    */
-    SWIGRUNTIME void
-    SWIG_PropagateClientData(void) {
-        size_t i;
-        swig_cast_info *equiv;
-        static int init_run = 0;
-        
-        if (init_run) return;
-        init_run = 1;
-        
-        for (i = 0; i < swig_module.size; i++) {
-            if (swig_module.types[i]->clientdata) {
-                equiv = swig_module.types[i]->cast;
-                while (equiv) {
-                    if (!equiv->converter) {
-                        if (equiv->type && !equiv->type->clientdata)
-                        SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
-                    }
-                    equiv = equiv->next;
-                }
-            }
-        }
-    }
-    
-#ifdef __cplusplus
-}
-#endif
-
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-    
-    /* Python-specific SWIG API */
-#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
-    
-    /* -----------------------------------------------------------------------------
-     * global variable support code.
-     * ----------------------------------------------------------------------------- */
-    
-    typedef struct swig_globalvar {
-        char       *name;                  /* Name of global variable */
-        PyObject *(*get_attr)(void);       /* Return the current value */
-        int       (*set_attr)(PyObject *); /* Set the value */
-        struct swig_globalvar *next;
-    } swig_globalvar;
-    
-    typedef struct swig_varlinkobject {
-        PyObject_HEAD
-        swig_globalvar *vars;
-    } swig_varlinkobject;
-    
-    SWIGINTERN PyObject *
-    swig_varlink_repr(swig_varlinkobject *v) {
-        v = v;
-        return PyString_FromString("<Swig global variables>");
-    }
-    
-    SWIGINTERN int
-    swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
-        swig_globalvar  *var;
-        flags = flags;
-        fprintf(fp,"Swig global variables { ");
-        for (var = v->vars; var; var=var->next) {
-            fprintf(fp,"%s", var->name);
-            if (var->next) fprintf(fp,", ");
-        }
-        fprintf(fp," }\n");
-        return 0;
-    }
-    
-    SWIGINTERN PyObject *
-    swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-        swig_globalvar *var = v->vars;
-        while (var) {
-            if (strcmp(var->name,n) == 0) {
-                return (*var->get_attr)();
-            }
-            var = var->next;
-        }
-        PyErr_SetString(PyExc_NameError,"Unknown C global variable");
-        return NULL;
-    }
-    
-    SWIGINTERN int
-    swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-        swig_globalvar *var = v->vars;
-        while (var) {
-            if (strcmp(var->name,n) == 0) {
-                return (*var->set_attr)(p);
-            }
-            var = var->next;
-        }
-        PyErr_SetString(PyExc_NameError,"Unknown C global variable");
-        return 1;
-    }
-    
-    SWIGINTERN PyTypeObject*
-    swig_varlink_type(void) {
-        static char varlink__doc__[] = "Swig var link object";
-        static PyTypeObject varlink_type
-#if !defined(__cplusplus)
-        ;
-        static int type_init = 0;  
-        if (!type_init) {
-            PyTypeObject tmp
-#endif
-            = {
-                PyObject_HEAD_INIT(&PyType_Type)
-                0,                                  /* Number of items in variable part (ob_size) */
-                (char *)"swigvarlink",              /* Type name (tp_name) */
-                sizeof(swig_varlinkobject),         /* Basic size (tp_basicsize) */
-                0,                                  /* Itemsize (tp_itemsize) */
-                0,                                  /* Deallocator (tp_dealloc) */ 
-                (printfunc) swig_varlink_print,     /* Print (tp_print) */
-                (getattrfunc) swig_varlink_getattr, /* get attr (tp_getattr) */
-                (setattrfunc) swig_varlink_setattr, /* Set attr (tp_setattr) */
-                0,                                  /* tp_compare */
-                (reprfunc) swig_varlink_repr,       /* tp_repr */
-                0,                                  /* tp_as_number */
-                0,                                  /* tp_as_sequence */
-                0,                                  /* tp_as_mapping */
-                0,                                  /* tp_hash */
-                0,                                  /* tp_call */
-                0,                                  /* tp_str */
-                0,                                  /* tp_getattro */
-                0,                                  /* tp_setattro */
-                0,                                  /* tp_as_buffer */
-                0,                                  /* tp_flags */
-                varlink__doc__,                     /* tp_doc */
-#if PY_VERSION_HEX >= 0x02000000
-                0,                                  /* tp_traverse */
-                0,                                  /* tp_clear */
-#endif
-#if PY_VERSION_HEX >= 0x02010000
-                0,                                  /* tp_richcompare */
-                0,                                  /* tp_weaklistoffset */
-#endif
-#if PY_VERSION_HEX >= 0x02020000
-                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
-#endif
-#if PY_VERSION_HEX >= 0x02030000
-                0,                                  /* tp_del */
-#endif
-#ifdef COUNT_ALLOCS
-                0,0,0,0                             /* tp_alloc -> tp_next */
-#endif
-            };
-#if !defined(__cplusplus)
-            varlink_type = tmp;
-            type_init = 1;
-        }
-#endif
-        return &varlink_type;
-    }
-    
-    /* Create a variable linking object for use later */
-    SWIGINTERN PyObject *
-    SWIG_Python_newvarlink(void) {
-        swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
-        if (result) {
-            result->vars = 0;
-        }
-        return ((PyObject*) result);
-    }
-    
-    SWIGINTERN void 
-    SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-        swig_varlinkobject *v = (swig_varlinkobject *) p;
-        swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-        if (gv) {
-            size_t size = strlen(name)+1;
-            gv->name = (char *)malloc(size);
-            if (gv->name) {
-                strncpy(gv->name,name,size);
-                gv->get_attr = get_attr;
-                gv->set_attr = set_attr;
-                gv->next = v->vars;
-            }
-        }
-        v->vars = gv;
-    }
-    
-    /* -----------------------------------------------------------------------------
-     * constants/methods manipulation
-     * ----------------------------------------------------------------------------- */
-    
-    /* Install Constants */
-    SWIGINTERN void
-    SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
-        PyObject *obj = 0;
-        size_t i;
-        for (i = 0; constants[i].type; ++i) {
-            switch(constants[i].type) {
-                case SWIG_PY_INT:
-                obj = PyInt_FromLong(constants[i].lvalue);
-                break;
-                case SWIG_PY_FLOAT:
-                obj = PyFloat_FromDouble(constants[i].dvalue);
-                break;
-                case SWIG_PY_STRING:
-                if (constants[i].pvalue) {
-                    obj = PyString_FromString((char *) constants[i].pvalue);
-                } else {
-                    Py_INCREF(Py_None);
-                    obj = Py_None;
-                }
-                break;
-                case SWIG_PY_POINTER:
-                obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
-                break;
-                case SWIG_PY_BINARY:
-                obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
-                break;
-                default:
-                obj = 0;
-                break;
-            }
-            if (obj) {
-                PyDict_SetItemString(d,constants[i].name,obj);
-                Py_DECREF(obj);
-            }
-        }
-    }
-    
-    /* -----------------------------------------------------------------------------*/
-    /* Fix SwigMethods to carry the callback ptrs when needed */
-    /* -----------------------------------------------------------------------------*/
-    
-    SWIGINTERN void
-    SWIG_Python_FixMethods(PyMethodDef *methods,
-    swig_const_info *const_table,
-    swig_type_info **types,
-    swig_type_info **types_initial) {
-        size_t i;
-        for (i = 0; methods[i].ml_name; ++i) {
-            char *c = methods[i].ml_doc;
-            if (c && (c = strstr(c, "swig_ptr: "))) {
-                int j;
-                swig_const_info *ci = 0;
-                char *name = c + 10;
-                for (j = 0; const_table[j].type; ++j) {
-                    if (strncmp(const_table[j].name, name, 
-                    strlen(const_table[j].name)) == 0) {
-                        ci = &(const_table[j]);
-                        break;
-                    }
-                }
-                if (ci) {
-                    size_t shift = (ci->ptype) - types;
-                    swig_type_info *ty = types_initial[shift];
-                    size_t ldoc = (c - methods[i].ml_doc);
-                    size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
-                    char *ndoc = (char*)malloc(ldoc + lptr + 10);
-                    if (ndoc) {
-                        char *buff = ndoc;
-                        void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
-                        if (ptr) {
-                            strncpy(buff, methods[i].ml_doc, ldoc);
-                            buff += ldoc;
-                            strncpy(buff, "swig_ptr: ", 10);
-                            buff += 10;
-                            SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
-                            methods[i].ml_doc = ndoc;
-                        }
-                    }
-                }
-            }
-        }
-    }
-    
-    /* -----------------------------------------------------------------------------*
-     *  Initialize type list
-     * -----------------------------------------------------------------------------*/
-    
-#if PY_MAJOR_VERSION < 2
-    /* PyModule_AddObject function was introduced in Python 2.0.  The following function
-    is copied out of Python/modsupport.c in python version 2.3.4 */
-    SWIGINTERN int
-    PyModule_AddObject(PyObject *m, char *name, PyObject *o)
-    {
-        PyObject *dict;
-        if (!PyModule_Check(m)) {
-            PyErr_SetString(PyExc_TypeError,
-            "PyModule_AddObject() needs module as first arg");
-            return -1;
-        }
-        if (!o) {
-            PyErr_SetString(PyExc_TypeError,
-            "PyModule_AddObject() needs non-NULL value");
-            return -1;
-        }
-        
-        dict = PyModule_GetDict(m);
-        if (dict == NULL) {
-            /* Internal error -- modules must have a dict! */
-            PyErr_Format(PyExc_SystemError, "module '%s' has no __dict__",
-            PyModule_GetName(m));
-            return -1;
-        }
-        if (PyDict_SetItemString(dict, name, o))
-        return -1;
-        Py_DECREF(o);
-        return 0;
-    }
-#endif
-    
-#ifdef __cplusplus
-}
-#endif
-
-/* -----------------------------------------------------------------------------*
- *  Partial Init method
- * -----------------------------------------------------------------------------*/
-
-#ifdef __cplusplus
-extern "C"
-#endif
-SWIGEXPORT void SWIG_init(void) {
-    static PyObject *SWIG_globals = 0; 
-    PyObject *m, *d;
-    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
-    
-    /* Fix SwigMethods to carry the callback ptrs when needed */
-    SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
-    
-    m = Py_InitModule((char *) SWIG_name, SwigMethods);
-    d = PyModule_GetDict(m);
-    
-    SWIG_InitializeModule(0);
-    SWIG_InstallConstants(d,swig_const_table);
-    
-    PyDict_SetItemString(d,(char*)"cvar", SWIG_globals);
-    SWIG_addvarlink(SWIG_globals,(char*)"tw_sound",_wrap_tw_sound_get, _wrap_tw_sound_set);
-}
-
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 1.3.29
+ * 
+ * This file is not intended to be easily readable and contains a number of 
+ * coding conventions designed to improve portability and efficiency. Do not make
+ * changes to this file unless you know what you are doing--modify the SWIG 
+ * interface file instead. 
+ * ----------------------------------------------------------------------------- */
+
+#define SWIGPYTHON
+#define SWIG_PYTHON_DIRECTOR_NO_VTABLE
+
+#ifdef __cplusplus
+template<class T> class SwigValueWrapper {
+    T *tt;
+public:
+    SwigValueWrapper() : tt(0) { }
+    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
+    SwigValueWrapper(const T& t) : tt(new T(t)) { }
+    ~SwigValueWrapper() { delete tt; } 
+    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
+    operator T&() const { return *tt; }
+    T *operator&() { return tt; }
+private:
+    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
+};
+#endif
+
+/* -----------------------------------------------------------------------------
+ *  This section contains generic SWIG labels for method/variable
+ *  declarations/attributes, and other compiler dependent labels.
+ * ----------------------------------------------------------------------------- */
+
+/* template workaround for compilers that cannot correctly implement the C++ standard */
+#ifndef SWIGTEMPLATEDISAMBIGUATOR
+# if defined(__SUNPRO_CC)
+#   if (__SUNPRO_CC <= 0x560)
+#     define SWIGTEMPLATEDISAMBIGUATOR template
+#   else
+#     define SWIGTEMPLATEDISAMBIGUATOR 
+#   endif
+# else
+#   define SWIGTEMPLATEDISAMBIGUATOR 
+# endif
+#endif
+
+/* inline attribute */
+#ifndef SWIGINLINE
+# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
+#   define SWIGINLINE inline
+# else
+#   define SWIGINLINE
+# endif
+#endif
+
+/* attribute recognised by some compilers to avoid 'unused' warnings */
+#ifndef SWIGUNUSED
+# if defined(__GNUC__)
+#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+#     define SWIGUNUSED __attribute__ ((__unused__)) 
+#   else
+#     define SWIGUNUSED
+#   endif
+# elif defined(__ICC)
+#   define SWIGUNUSED __attribute__ ((__unused__)) 
+# else
+#   define SWIGUNUSED 
+# endif
+#endif
+
+#ifndef SWIGUNUSEDPARM
+# ifdef __cplusplus
+#   define SWIGUNUSEDPARM(p)
+# else
+#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
+# endif
+#endif
+
+/* internal SWIG method */
+#ifndef SWIGINTERN
+# define SWIGINTERN static SWIGUNUSED
+#endif
+
+/* internal inline SWIG method */
+#ifndef SWIGINTERNINLINE
+# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
+#endif
+
+/* exporting methods */
+#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
+#  ifndef GCC_HASCLASSVISIBILITY
+#    define GCC_HASCLASSVISIBILITY
+#  endif
+#endif
+
+#ifndef SWIGEXPORT
+# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#   if defined(STATIC_LINKED)
+#     define SWIGEXPORT
+#   else
+#     define SWIGEXPORT __declspec(dllexport)
+#   endif
+# else
+#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
+#     define SWIGEXPORT __attribute__ ((visibility("default")))
+#   else
+#     define SWIGEXPORT
+#   endif
+# endif
+#endif
+
+/* calling conventions for Windows */
+#ifndef SWIGSTDCALL
+# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#   define SWIGSTDCALL __stdcall
+# else
+#   define SWIGSTDCALL
+# endif 
+#endif
+
+/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
+#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)
+# define _CRT_SECURE_NO_DEPRECATE
+#endif
+
+
+/* Python.h has to appear first */
+#include <Python.h>
+
+/* -----------------------------------------------------------------------------
+ * swigrun.swg
+ *
+ * This file contains generic CAPI SWIG runtime support for pointer
+ * type checking.
+ * ----------------------------------------------------------------------------- */
+
+/* This should only be incremented when either the layout of swig_type_info changes,
+   or for whatever reason, the runtime changes incompatibly */
+#define SWIG_RUNTIME_VERSION "2"
+
+/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
+#ifdef SWIG_TYPE_TABLE
+# define SWIG_QUOTE_STRING(x) #x
+# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
+# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
+#else
+# define SWIG_TYPE_TABLE_NAME
+#endif
+
+/*
+  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
+  creating a static or dynamic library from the swig runtime code.
+  In 99.9% of the cases, swig just needs to declare them as 'static'.
+  
+  But only do this if is strictly necessary, ie, if you have problems
+  with your compiler or so.
+*/
+
+#ifndef SWIGRUNTIME
+# define SWIGRUNTIME SWIGINTERN
+#endif
+
+#ifndef SWIGRUNTIMEINLINE
+# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
+#endif
+
+/*  Generic buffer size */
+#ifndef SWIG_BUFFER_SIZE
+# define SWIG_BUFFER_SIZE 1024
+#endif
+
+/* Flags for pointer conversions */
+#define SWIG_POINTER_DISOWN        0x1
+
+/* Flags for new pointer objects */
+#define SWIG_POINTER_OWN           0x1
+
+
+/* 
+   Flags/methods for returning states.
+   
+   The swig conversion methods, as ConvertPtr, return and integer 
+   that tells if the conversion was successful or not. And if not,
+   an error code can be returned (see swigerrors.swg for the codes).
+   
+   Use the following macros/flags to set or process the returning
+   states.
+   
+   In old swig versions, you usually write code as:
+
+     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
+       // success code
+     } else {
+       //fail code
+     }
+
+   Now you can be more explicit as:
+
+    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
+    if (SWIG_IsOK(res)) {
+      // success code
+    } else {
+      // fail code
+    }
+
+   that seems to be the same, but now you can also do
+
+    Type *ptr;
+    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
+    if (SWIG_IsOK(res)) {
+      // success code
+      if (SWIG_IsNewObj(res) {
+        ...
+	delete *ptr;
+      } else {
+        ...
+      }
+    } else {
+      // fail code
+    }
+    
+   I.e., now SWIG_ConvertPtr can return new objects and you can
+   identify the case and take care of the deallocation. Of course that
+   requires also to SWIG_ConvertPtr to return new result values, as
+
+      int SWIG_ConvertPtr(obj, ptr,...) {         
+        if (<obj is ok>) {			       
+          if (<need new object>) {		       
+            *ptr = <ptr to new allocated object>; 
+            return SWIG_NEWOBJ;		       
+          } else {				       
+            *ptr = <ptr to old object>;	       
+            return SWIG_OLDOBJ;		       
+          } 				       
+        } else {				       
+          return SWIG_BADOBJ;		       
+        }					       
+      }
+
+   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
+   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
+   swig errors code.
+
+   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
+   allows to return the 'cast rank', for example, if you have this
+
+       int food(double)
+       int fooi(int);
+
+   and you call
+ 
+      food(1)   // cast rank '1'  (1 -> 1.0)
+      fooi(1)   // cast rank '0'
+
+   just use the SWIG_AddCast()/SWIG_CheckState()
+
+
+ */
+#define SWIG_OK                    (0) 
+#define SWIG_ERROR                 (-1)
+#define SWIG_IsOK(r)               (r >= 0)
+#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  
+
+/* The CastRankLimit says how many bits are used for the cast rank */
+#define SWIG_CASTRANKLIMIT         (1 << 8)
+/* The NewMask denotes the object was created (using new/malloc) */
+#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
+/* The TmpMask is for in/out typemaps that use temporal objects */
+#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
+/* Simple returning values */
+#define SWIG_BADOBJ                (SWIG_ERROR)
+#define SWIG_OLDOBJ                (SWIG_OK)
+#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
+#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
+/* Check, add and del mask methods */
+#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
+#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
+#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
+#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
+#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
+#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
+
+
+/* Cast-Rank Mode */
+#if defined(SWIG_CASTRANK_MODE)
+#  ifndef SWIG_TypeRank
+#    define SWIG_TypeRank             unsigned long
+#  endif
+#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
+#    define SWIG_MAXCASTRANK          (2)
+#  endif
+#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
+#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
+SWIGINTERNINLINE int SWIG_AddCast(int r) { 
+  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
+}
+SWIGINTERNINLINE int SWIG_CheckState(int r) { 
+  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
+}
+#else /* no cast-rank mode */
+#  define SWIG_AddCast
+#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
+#endif
+
+
+
+
+#include <string.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void *(*swig_converter_func)(void *);
+typedef struct swig_type_info *(*swig_dycast_func)(void **);
+
+/* Structure to store inforomation on one type */
+typedef struct swig_type_info {
+  const char             *name;			/* mangled name of this type */
+  const char             *str;			/* human readable name of this type */
+  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
+  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
+  void                   *clientdata;		/* language specific type data */
+  int                    owndata;		/* flag if the structure owns the clientdata */
+} swig_type_info;
+
+/* Structure to store a type and conversion function used for casting */
+typedef struct swig_cast_info {
+  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
+  swig_converter_func     converter;		/* function to cast the void pointers */
+  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
+  struct swig_cast_info  *prev;			/* pointer to the previous cast */
+} swig_cast_info;
+
+/* Structure used to store module information
+ * Each module generates one structure like this, and the runtime collects
+ * all of these structures and stores them in a circularly linked list.*/
+typedef struct swig_module_info {
+  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
+  size_t                 size;		        /* Number of types in this module */
+  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
+  swig_type_info         **type_initial;	/* Array of initially generated type structures */
+  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
+  void                    *clientdata;		/* Language specific module data */
+} swig_module_info;
+
+/* 
+  Compare two type names skipping the space characters, therefore
+  "char*" == "char *" and "Class<int>" == "Class<int >", etc.
+
+  Return 0 when the two name types are equivalent, as in
+  strncmp, but skipping ' '.
+*/
+SWIGRUNTIME int
+SWIG_TypeNameComp(const char *f1, const char *l1,
+		  const char *f2, const char *l2) {
+  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
+    while ((*f1 == ' ') && (f1 != l1)) ++f1;
+    while ((*f2 == ' ') && (f2 != l2)) ++f2;
+    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
+  }
+  return (l1 - f1) - (l2 - f2);
+}
+
+/*
+  Check type equivalence in a name list like <name1>|<name2>|...
+  Return 0 if not equal, 1 if equal
+*/
+SWIGRUNTIME int
+SWIG_TypeEquiv(const char *nb, const char *tb) {
+  int equiv = 0;
+  const char* te = tb + strlen(tb);
+  const char* ne = nb;
+  while (!equiv && *ne) {
+    for (nb = ne; *ne; ++ne) {
+      if (*ne == '|') break;
+    }
+    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
+    if (*ne) ++ne;
+  }
+  return equiv;
+}
+
+/*
+  Check type equivalence in a name list like <name1>|<name2>|...
+  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
+*/
+SWIGRUNTIME int
+SWIG_TypeCompare(const char *nb, const char *tb) {
+  int equiv = 0;
+  const char* te = tb + strlen(tb);
+  const char* ne = nb;
+  while (!equiv && *ne) {
+    for (nb = ne; *ne; ++ne) {
+      if (*ne == '|') break;
+    }
+    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
+    if (*ne) ++ne;
+  }
+  return equiv;
+}
+
+
+/* think of this as a c++ template<> or a scheme macro */
+#define SWIG_TypeCheck_Template(comparison, ty)         \
+  if (ty) {                                             \
+    swig_cast_info *iter = ty->cast;                    \
+    while (iter) {                                      \
+      if (comparison) {                                 \
+        if (iter == ty->cast) return iter;              \
+        /* Move iter to the top of the linked list */   \
+        iter->prev->next = iter->next;                  \
+        if (iter->next)                                 \
+          iter->next->prev = iter->prev;                \
+        iter->next = ty->cast;                          \
+        iter->prev = 0;                                 \
+        if (ty->cast) ty->cast->prev = iter;            \
+        ty->cast = iter;                                \
+        return iter;                                    \
+      }                                                 \
+      iter = iter->next;                                \
+    }                                                   \
+  }                                                     \
+  return 0
+
+/*
+  Check the typename
+*/
+SWIGRUNTIME swig_cast_info *
+SWIG_TypeCheck(const char *c, swig_type_info *ty) {
+  SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);
+}
+
+/* Same as previous function, except strcmp is replaced with a pointer comparison */
+SWIGRUNTIME swig_cast_info *
+SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
+  SWIG_TypeCheck_Template(iter->type == from, into);
+}
+
+/*
+  Cast a pointer up an inheritance hierarchy
+*/
+SWIGRUNTIMEINLINE void *
+SWIG_TypeCast(swig_cast_info *ty, void *ptr) {
+  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr);
+}
+
+/* 
+   Dynamic pointer casting. Down an inheritance hierarchy
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
+  swig_type_info *lastty = ty;
+  if (!ty || !ty->dcast) return ty;
+  while (ty && (ty->dcast)) {
+    ty = (*ty->dcast)(ptr);
+    if (ty) lastty = ty;
+  }
+  return lastty;
+}
+
+/*
+  Return the name associated with this type
+*/
+SWIGRUNTIMEINLINE const char *
+SWIG_TypeName(const swig_type_info *ty) {
+  return ty->name;
+}
+
+/*
+  Return the pretty name associated with this type,
+  that is an unmangled type name in a form presentable to the user.
+*/
+SWIGRUNTIME const char *
+SWIG_TypePrettyName(const swig_type_info *type) {
+  /* The "str" field contains the equivalent pretty names of the
+     type, separated by vertical-bar characters.  We choose
+     to print the last name, as it is often (?) the most
+     specific. */
+  if (!type) return NULL;
+  if (type->str != NULL) {
+    const char *last_name = type->str;
+    const char *s;
+    for (s = type->str; *s; s++)
+      if (*s == '|') last_name = s+1;
+    return last_name;
+  }
+  else
+    return type->name;
+}
+
+/* 
+   Set the clientdata field for a type
+*/
+SWIGRUNTIME void
+SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
+  swig_cast_info *cast = ti->cast;
+  /* if (ti->clientdata == clientdata) return; */
+  ti->clientdata = clientdata;
+  
+  while (cast) {
+    if (!cast->converter) {
+      swig_type_info *tc = cast->type;
+      if (!tc->clientdata) {
+	SWIG_TypeClientData(tc, clientdata);
+      }
+    }    
+    cast = cast->next;
+  }
+}
+SWIGRUNTIME void
+SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
+  SWIG_TypeClientData(ti, clientdata);
+  ti->owndata = 1;
+}
+  
+/*
+  Search for a swig_type_info structure only by mangled name
+  Search is a O(log #types)
+  
+  We start searching at module start, and finish searching when start == end.  
+  Note: if start == end at the beginning of the function, we go all the way around
+  the circular list.
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_MangledTypeQueryModule(swig_module_info *start, 
+                            swig_module_info *end, 
+		            const char *name) {
+  swig_module_info *iter = start;
+  do {
+    if (iter->size) {
+      register size_t l = 0;
+      register size_t r = iter->size - 1;
+      do {
+	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
+	register size_t i = (l + r) >> 1; 
+	const char *iname = iter->types[i]->name;
+	if (iname) {
+	  register int compare = strcmp(name, iname);
+	  if (compare == 0) {	    
+	    return iter->types[i];
+	  } else if (compare < 0) {
+	    if (i) {
+	      r = i - 1;
+	    } else {
+	      break;
+	    }
+	  } else if (compare > 0) {
+	    l = i + 1;
+	  }
+	} else {
+	  break; /* should never happen */
+	}
+      } while (l <= r);
+    }
+    iter = iter->next;
+  } while (iter != end);
+  return 0;
+}
+
+/*
+  Search for a swig_type_info structure for either a mangled name or a human readable name.
+  It first searches the mangled names of the types, which is a O(log #types)
+  If a type is not found it then searches the human readable names, which is O(#types).
+  
+  We start searching at module start, and finish searching when start == end.  
+  Note: if start == end at the beginning of the function, we go all the way around
+  the circular list.
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_TypeQueryModule(swig_module_info *start, 
+                     swig_module_info *end, 
+		     const char *name) {
+  /* STEP 1: Search the name field using binary search */
+  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
+  if (ret) {
+    return ret;
+  } else {
+    /* STEP 2: If the type hasn't been found, do a complete search
+       of the str field (the human readable name) */
+    swig_module_info *iter = start;
+    do {
+      register size_t i = 0;
+      for (; i < iter->size; ++i) {
+	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
+	  return iter->types[i];
+      }
+      iter = iter->next;
+    } while (iter != end);
+  }
+  
+  /* neither found a match */
+  return 0;
+}
+
+/* 
+   Pack binary data into a string
+*/
+SWIGRUNTIME char *
+SWIG_PackData(char *c, void *ptr, size_t sz) {
+  static const char hex[17] = "0123456789abcdef";
+  register const unsigned char *u = (unsigned char *) ptr;
+  register const unsigned char *eu =  u + sz;
+  for (; u != eu; ++u) {
+    register unsigned char uu = *u;
+    *(c++) = hex[(uu & 0xf0) >> 4];
+    *(c++) = hex[uu & 0xf];
+  }
+  return c;
+}
+
+/* 
+   Unpack binary data from a string
+*/
+SWIGRUNTIME const char *
+SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
+  register unsigned char *u = (unsigned char *) ptr;
+  register const unsigned char *eu = u + sz;
+  for (; u != eu; ++u) {
+    register char d = *(c++);
+    register unsigned char uu;
+    if ((d >= '0') && (d <= '9'))
+      uu = ((d - '0') << 4);
+    else if ((d >= 'a') && (d <= 'f'))
+      uu = ((d - ('a'-10)) << 4);
+    else 
+      return (char *) 0;
+    d = *(c++);
+    if ((d >= '0') && (d <= '9'))
+      uu |= (d - '0');
+    else if ((d >= 'a') && (d <= 'f'))
+      uu |= (d - ('a'-10));
+    else 
+      return (char *) 0;
+    *u = uu;
+  }
+  return c;
+}
+
+/* 
+   Pack 'void *' into a string buffer.
+*/
+SWIGRUNTIME char *
+SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
+  char *r = buff;
+  if ((2*sizeof(void *) + 2) > bsz) return 0;
+  *(r++) = '_';
+  r = SWIG_PackData(r,&ptr,sizeof(void *));
+  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
+  strcpy(r,name);
+  return buff;
+}
+
+SWIGRUNTIME const char *
+SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
+  if (*c != '_') {
+    if (strcmp(c,"NULL") == 0) {
+      *ptr = (void *) 0;
+      return name;
+    } else {
+      return 0;
+    }
+  }
+  return SWIG_UnpackData(++c,ptr,sizeof(void *));
+}
+
+SWIGRUNTIME char *
+SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
+  char *r = buff;
+  size_t lname = (name ? strlen(name) : 0);
+  if ((2*sz + 2 + lname) > bsz) return 0;
+  *(r++) = '_';
+  r = SWIG_PackData(r,ptr,sz);
+  if (lname) {
+    strncpy(r,name,lname+1);
+  } else {
+    *r = 0;
+  }
+  return buff;
+}
+
+SWIGRUNTIME const char *
+SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
+  if (*c != '_') {
+    if (strcmp(c,"NULL") == 0) {
+      memset(ptr,0,sz);
+      return name;
+    } else {
+      return 0;
+    }
+  }
+  return SWIG_UnpackData(++c,ptr,sz);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+/*  Errors in SWIG */
+#define  SWIG_UnknownError    	   -1 
+#define  SWIG_IOError        	   -2 
+#define  SWIG_RuntimeError   	   -3 
+#define  SWIG_IndexError     	   -4 
+#define  SWIG_TypeError      	   -5 
+#define  SWIG_DivisionByZero 	   -6 
+#define  SWIG_OverflowError  	   -7 
+#define  SWIG_SyntaxError    	   -8 
+#define  SWIG_ValueError     	   -9 
+#define  SWIG_SystemError    	   -10
+#define  SWIG_AttributeError 	   -11
+#define  SWIG_MemoryError    	   -12 
+#define  SWIG_NullReferenceError   -13
+
+
+
+/* Python.h has to appear first */
+#include <Python.h>
+
+/* Add PyOS_snprintf for old Pythons */
+#if PY_VERSION_HEX < 0x02020000
+# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
+#  define PyOS_snprintf _snprintf
+# else
+#  define PyOS_snprintf snprintf
+# endif
+#endif
+
+/* A crude PyString_FromFormat implementation for old Pythons */
+#if PY_VERSION_HEX < 0x02020000
+
+#ifndef SWIG_PYBUFFER_SIZE
+# define SWIG_PYBUFFER_SIZE 1024
+#endif
+
+static PyObject *
+PyString_FromFormat(const char *fmt, ...) {
+  va_list ap;
+  char buf[SWIG_PYBUFFER_SIZE * 2];
+  int res;
+  va_start(ap, fmt);
+  res = vsnprintf(buf, sizeof(buf), fmt, ap);
+  va_end(ap);
+  return (res < 0 || res >= (int)sizeof(buf)) ? 0 : PyString_FromString(buf);
+}
+#endif
+
+/* Add PyObject_Del for old Pythons */
+#if PY_VERSION_HEX < 0x01060000
+# define PyObject_Del(op) PyMem_DEL((op))
+#endif
+#ifndef PyObject_DEL
+# define PyObject_DEL PyObject_Del
+#endif
+
+/* A crude PyExc_StopIteration exception for old Pythons */
+#if PY_VERSION_HEX < 0x02020000
+# ifndef PyExc_StopIteration
+#  define PyExc_StopIteration PyExc_RuntimeError
+# endif
+# ifndef PyObject_GenericGetAttr
+#  define PyObject_GenericGetAttr 0
+# endif
+#endif
+/* Py_NotImplemented is defined in 2.1 and up. */
+#if PY_VERSION_HEX < 0x02010000
+# ifndef Py_NotImplemented
+#  define Py_NotImplemented PyExc_RuntimeError
+# endif
+#endif
+
+
+/* A crude PyString_AsStringAndSize implementation for old Pythons */
+#if PY_VERSION_HEX < 0x02010000
+# ifndef PyString_AsStringAndSize
+#  define PyString_AsStringAndSize(obj, s, len) {*s = PyString_AsString(obj); *len = *s ? strlen(*s) : 0;}
+# endif
+#endif
+
+/* PySequence_Size for old Pythons */
+#if PY_VERSION_HEX < 0x02000000
+# ifndef PySequence_Size
+#  define PySequence_Size PySequence_Length
+# endif
+#endif
+
+
+/* PyBool_FromLong for old Pythons */
+#if PY_VERSION_HEX < 0x02030000
+static
+PyObject *PyBool_FromLong(long ok)
+{
+  PyObject *result = ok ? Py_True : Py_False;
+  Py_INCREF(result);
+  return result;
+}
+#endif
+
+
+/* -----------------------------------------------------------------------------
+ * error manipulation
+ * ----------------------------------------------------------------------------- */
+
+SWIGRUNTIME PyObject*
+SWIG_Python_ErrorType(int code) {
+  PyObject* type = 0;
+  switch(code) {
+  case SWIG_MemoryError:
+    type = PyExc_MemoryError;
+    break;
+  case SWIG_IOError:
+    type = PyExc_IOError;
+    break;
+  case SWIG_RuntimeError:
+    type = PyExc_RuntimeError;
+    break;
+  case SWIG_IndexError:
+    type = PyExc_IndexError;
+    break;
+  case SWIG_TypeError:
+    type = PyExc_TypeError;
+    break;
+  case SWIG_DivisionByZero:
+    type = PyExc_ZeroDivisionError;
+    break;
+  case SWIG_OverflowError:
+    type = PyExc_OverflowError;
+    break;
+  case SWIG_SyntaxError:
+    type = PyExc_SyntaxError;
+    break;
+  case SWIG_ValueError:
+    type = PyExc_ValueError;
+    break;
+  case SWIG_SystemError:
+    type = PyExc_SystemError;
+    break;
+  case SWIG_AttributeError:
+    type = PyExc_AttributeError;
+    break;
+  default:
+    type = PyExc_RuntimeError;
+  }
+  return type;
+}
+
+
+SWIGRUNTIME void
+SWIG_Python_AddErrorMsg(const char* mesg)
+{
+  PyObject *type = 0;
+  PyObject *value = 0;
+  PyObject *traceback = 0;
+
+  if (PyErr_Occurred()) PyErr_Fetch(&type, &value, &traceback);
+  if (value) {
+    PyObject *old_str = PyObject_Str(value);
+    PyErr_Clear();
+    Py_XINCREF(type);
+    PyErr_Format(type, "%s %s", PyString_AsString(old_str), mesg);
+    Py_DECREF(old_str);
+    Py_DECREF(value);
+  } else {
+    PyErr_Format(PyExc_RuntimeError, mesg);
+  }
+}
+
+
+
+#if defined(SWIG_PYTHON_NO_THREADS)
+#  if defined(SWIG_PYTHON_THREADS)
+#    undef SWIG_PYTHON_THREADS
+#  endif
+#endif
+#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
+#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
+#    if (PY_VERSION_HEX >= 0x02030000) /* For 2.3 or later, use the PyGILState calls */
+#      define SWIG_PYTHON_USE_GIL
+#    endif
+#  endif
+#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
+#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
+#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
+#    endif
+#    ifdef __cplusplus /* C++ code */
+       class SWIG_Python_Thread_Block {
+         bool status;
+         PyGILState_STATE state;
+       public:
+         void end() { if (status) { PyGILState_Release(state); status = false;} }
+         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
+         ~SWIG_Python_Thread_Block() { end(); }
+       };
+       class SWIG_Python_Thread_Allow {
+         bool status;
+         PyThreadState *save;
+       public:
+         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
+         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
+         ~SWIG_Python_Thread_Allow() { end(); }
+       };
+#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
+#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
+#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
+#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
+#    else /* C code */
+#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
+#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
+#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
+#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
+#    endif
+#  else /* Old thread way, not implemented, user must provide it */
+#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
+#      define SWIG_PYTHON_INITIALIZE_THREADS
+#    endif
+#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
+#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
+#    endif
+#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
+#      define SWIG_PYTHON_THREAD_END_BLOCK
+#    endif
+#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
+#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
+#    endif
+#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
+#      define SWIG_PYTHON_THREAD_END_ALLOW
+#    endif
+#  endif
+#else /* No thread support */
+#  define SWIG_PYTHON_INITIALIZE_THREADS
+#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
+#  define SWIG_PYTHON_THREAD_END_BLOCK
+#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
+#  define SWIG_PYTHON_THREAD_END_ALLOW
+#endif
+
+/* -----------------------------------------------------------------------------
+ * Python API portion that goes into the runtime
+ * ----------------------------------------------------------------------------- */
+
+#ifdef __cplusplus
+extern "C" {
+#if 0
+} /* cc-mode */
+#endif
+#endif
+
+/* -----------------------------------------------------------------------------
+ * Constant declarations
+ * ----------------------------------------------------------------------------- */
+
+/* Constant Types */
+#define SWIG_PY_POINTER 4
+#define SWIG_PY_BINARY  5
+
+/* Constant information structure */
+typedef struct swig_const_info {
+  int type;
+  char *name;
+  long lvalue;
+  double dvalue;
+  void   *pvalue;
+  swig_type_info **ptype;
+} swig_const_info;
+
+#ifdef __cplusplus
+#if 0
+{ /* cc-mode */
+#endif
+}
+#endif
+
+
+/* -----------------------------------------------------------------------------
+ * See the LICENSE file for information on copyright, usage and redistribution
+ * of SWIG, and the README file for authors - http://www.swig.org/release.html.
+ *
+ * pyrun.swg
+ *
+ * This file contains the runtime support for Python modules
+ * and includes code for managing global variables and pointer
+ * type checking.
+ *
+ * ----------------------------------------------------------------------------- */
+
+/* Common SWIG API */
+
+/* for raw pointers */
+#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
+#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
+#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)
+#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(ptr, type, flags)
+#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
+#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
+#define swig_owntype                                    int
+
+/* for raw packed data */
+#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
+#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)
+
+/* for class or struct pointers */
+#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
+#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)
+
+/* for C or C++ function pointers */
+#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
+#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(ptr, type, 0)
+
+/* for C++ member pointers, ie, member methods */
+#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
+#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)
+
+
+/* Runtime API */
+
+#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule()
+#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
+#define SWIG_NewClientData(obj)                         PySwigClientData_New(obj)
+
+#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
+#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
+#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
+#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
+#define SWIG_fail                        		goto fail					   
+
+
+/* Runtime API implementation */
+
+/* Error manipulation */
+
+SWIGINTERN void 
+SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
+  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
+  PyErr_SetObject(errtype, obj);
+  Py_DECREF(obj);
+  SWIG_PYTHON_THREAD_END_BLOCK;
+}
+
+SWIGINTERN void 
+SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
+  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
+  PyErr_SetString(errtype, (char *) msg);
+  SWIG_PYTHON_THREAD_END_BLOCK;
+}
+
+#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)
+
+/* Set a constant value */
+
+SWIGINTERN void
+SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
+  PyDict_SetItemString(d, (char*) name, obj);
+  Py_DECREF(obj);                            
+}
+
+/* Append a value to the result obj */
+
+SWIGINTERN PyObject*
+SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
+#if !defined(SWIG_PYTHON_OUTPUT_TUPLE)
+  if (!result) {
+    result = obj;
+  } else if (result == Py_None) {
+    Py_DECREF(result);
+    result = obj;
+  } else {
+    if (!PyList_Check(result)) {
+      PyObject *o2 = result;
+      result = PyList_New(1);
+      PyList_SetItem(result, 0, o2);
+    }
+    PyList_Append(result,obj);
+    Py_DECREF(obj);
+  }
+  return result;
+#else
+  PyObject*   o2;
+  PyObject*   o3;
+  if (!result) {
+    result = obj;
+  } else if (result == Py_None) {
+    Py_DECREF(result);
+    result = obj;
+  } else {
+    if (!PyTuple_Check(result)) {
+      o2 = result;
+      result = PyTuple_New(1);
+      PyTuple_SET_ITEM(result, 0, o2);
+    }
+    o3 = PyTuple_New(1);
+    PyTuple_SET_ITEM(o3, 0, obj);
+    o2 = result;
+    result = PySequence_Concat(o2, o3);
+    Py_DECREF(o2);
+    Py_DECREF(o3);
+  }
+  return result;
+#endif
+}
+
+/* Unpack the argument tuple */
+
+SWIGINTERN int
+SWIG_Python_UnpackTuple(PyObject *args, const char *name, int min, int max, PyObject **objs)
+{
+  if (!args) {
+    if (!min && !max) {
+      return 1;
+    } else {
+      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
+		   name, (min == max ? "" : "at least "), min);
+      return 0;
+    }
+  }  
+  if (!PyTuple_Check(args)) {
+    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
+    return 0;
+  } else {
+    register int l = PyTuple_GET_SIZE(args);
+    if (l < min) {
+      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
+		   name, (min == max ? "" : "at least "), min, l);
+      return 0;
+    } else if (l > max) {
+      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
+		   name, (min == max ? "" : "at most "), max, l);
+      return 0;
+    } else {
+      register int i;
+      for (i = 0; i < l; ++i) {
+	objs[i] = PyTuple_GET_ITEM(args, i);
+      }
+      for (; l < max; ++l) {
+	objs[l] = 0;
+      }
+      return i + 1;
+    }    
+  }
+}
+
+/* A functor is a function object with one single object argument */
+#if PY_VERSION_HEX >= 0x02020000
+#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);
+#else
+#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunction(functor, "O", obj);
+#endif
+
+/*
+  Helper for static pointer initialization for both C and C++ code, for example
+  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
+*/
+#ifdef __cplusplus
+#define SWIG_STATIC_POINTER(var)  var
+#else
+#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
+#endif
+
+/* -----------------------------------------------------------------------------
+ * Pointer declarations
+ * ----------------------------------------------------------------------------- */
+
+/* Flags for new pointer objects */
+#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
+#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)
+
+#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)
+
+#ifdef __cplusplus
+extern "C" {
+#if 0
+} /* cc-mode */
+#endif
+#endif
+
+/*  How to access Py_None */
+#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#  ifndef SWIG_PYTHON_NO_BUILD_NONE
+#    ifndef SWIG_PYTHON_BUILD_NONE
+#      define SWIG_PYTHON_BUILD_NONE
+#    endif
+#  endif
+#endif
+
+#ifdef SWIG_PYTHON_BUILD_NONE
+#  ifdef Py_None
+#   undef Py_None
+#   define Py_None SWIG_Py_None()
+#  endif
+SWIGRUNTIMEINLINE PyObject * 
+_SWIG_Py_None(void)
+{
+  PyObject *none = Py_BuildValue("");
+  Py_DECREF(none);
+  return none;
+}
+SWIGRUNTIME PyObject * 
+SWIG_Py_None(void)
+{
+  static PyObject *SWIG_STATIC_POINTER(none) = _SWIG_Py_None();
+  return none;
+}
+#endif
+
+/* The python void return value */
+
+SWIGRUNTIMEINLINE PyObject * 
+SWIG_Py_Void(void)
+{
+  PyObject *none = Py_None;
+  Py_INCREF(none);
+  return none;
+}
+
+/* PySwigClientData */
+
+typedef struct {
+  PyObject *klass;
+  PyObject *newraw;
+  PyObject *newargs;
+  PyObject *destroy;
+  int delargs;
+  int implicitconv;
+} PySwigClientData;
+
+SWIGRUNTIMEINLINE int 
+SWIG_Python_CheckImplicit(swig_type_info *ty)
+{
+  PySwigClientData *data = (PySwigClientData *)ty->clientdata;
+  return data ? data->implicitconv : 0;
+}
+
+SWIGRUNTIMEINLINE PyObject *
+SWIG_Python_ExceptionType(swig_type_info *desc) {
+  PySwigClientData *data = desc ? (PySwigClientData *) desc->clientdata : 0;
+  PyObject *klass = data ? data->klass : 0;
+  return (klass ? klass : PyExc_RuntimeError);
+}
+
+
+SWIGRUNTIME PySwigClientData * 
+PySwigClientData_New(PyObject* obj)
+{
+  if (!obj) {
+    return 0;
+  } else {
+    PySwigClientData *data = (PySwigClientData *)malloc(sizeof(PySwigClientData));
+    /* the klass element */
+    data->klass = obj;
+    Py_INCREF(data->klass);
+    /* the newraw method and newargs arguments used to create a new raw instance */
+    if (PyClass_Check(obj)) {
+      data->newraw = 0;
+      data->newargs = obj;
+      Py_INCREF(obj);
+    } else {
+#if (PY_VERSION_HEX < 0x02020000)
+      data->newraw = 0;
+#else
+      data->newraw = PyObject_GetAttrString(data->klass, (char *)"__new__");
+#endif
+      if (data->newraw) {
+	Py_INCREF(data->newraw);
+	data->newargs = PyTuple_New(1);
+	PyTuple_SetItem(data->newargs, 0, obj);
+      } else {
+	data->newargs = obj;
+      }
+      Py_INCREF(data->newargs);
+    }
+    /* the destroy method, aka as the C++ delete method */
+    data->destroy = PyObject_GetAttrString(data->klass, (char *)"__swig_destroy__");
+    if (PyErr_Occurred()) {
+      PyErr_Clear();
+      data->destroy = 0;
+    }
+    if (data->destroy) {
+      int flags;
+      Py_INCREF(data->destroy);
+      flags = PyCFunction_GET_FLAGS(data->destroy);
+#ifdef METH_O
+      data->delargs = !(flags & (METH_O));
+#else
+      data->delargs = 0;
+#endif
+    } else {
+      data->delargs = 0;
+    }
+    data->implicitconv = 0;
+    return data;
+  }
+}
+
+SWIGRUNTIME void 
+PySwigClientData_Del(PySwigClientData* data)
+{
+  Py_XDECREF(data->newraw);
+  Py_XDECREF(data->newargs);
+  Py_XDECREF(data->destroy);
+}
+
+/* =============== PySwigObject =====================*/
+
+typedef struct {
+  PyObject_HEAD
+  void *ptr;
+  swig_type_info *ty;
+  int own;
+  PyObject *next;
+} PySwigObject;
+
+SWIGRUNTIME PyObject *
+PySwigObject_long(PySwigObject *v)
+{
+  return PyLong_FromVoidPtr(v->ptr);
+}
+
+SWIGRUNTIME PyObject *
+PySwigObject_format(const char* fmt, PySwigObject *v)
+{
+  PyObject *res = NULL;
+  PyObject *args = PyTuple_New(1);
+  if (args) {
+    if (PyTuple_SetItem(args, 0, PySwigObject_long(v)) == 0) {
+      PyObject *ofmt = PyString_FromString(fmt);
+      if (ofmt) {
+	res = PyString_Format(ofmt,args);
+	Py_DECREF(ofmt);
+      }
+      Py_DECREF(args);
+    }
+  }
+  return res;
+}
+
+SWIGRUNTIME PyObject *
+PySwigObject_oct(PySwigObject *v)
+{
+  return PySwigObject_format("%o",v);
+}
+
+SWIGRUNTIME PyObject *
+PySwigObject_hex(PySwigObject *v)
+{
+  return PySwigObject_format("%x",v);
+}
+
+SWIGRUNTIME PyObject *
+#ifdef METH_NOARGS
+PySwigObject_repr(PySwigObject *v)
+#else
+PySwigObject_repr(PySwigObject *v, PyObject *args)
+#endif
+{
+  const char *name = SWIG_TypePrettyName(v->ty);
+  PyObject *hex = PySwigObject_hex(v);    
+  PyObject *repr = PyString_FromFormat("<Swig Object of type '%s' at 0x%s>", name, PyString_AsString(hex));
+  Py_DECREF(hex);
+  if (v->next) {
+#ifdef METH_NOARGS
+    PyObject *nrep = PySwigObject_repr((PySwigObject *)v->next);
+#else
+    PyObject *nrep = PySwigObject_repr((PySwigObject *)v->next, args);
+#endif
+    PyString_ConcatAndDel(&repr,nrep);
+  }
+  return repr;  
+}
+
+SWIGRUNTIME int
+PySwigObject_print(PySwigObject *v, FILE *fp, int SWIGUNUSEDPARM(flags))
+{
+#ifdef METH_NOARGS
+  PyObject *repr = PySwigObject_repr(v);
+#else
+  PyObject *repr = PySwigObject_repr(v, NULL);
+#endif
+  if (repr) {
+    fputs(PyString_AsString(repr), fp);
+    Py_DECREF(repr);
+    return 0; 
+  } else {
+    return 1; 
+  }
+}
+
+SWIGRUNTIME PyObject *
+PySwigObject_str(PySwigObject *v)
+{
+  char result[SWIG_BUFFER_SIZE];
+  return SWIG_PackVoidPtr(result, v->ptr, v->ty->name, sizeof(result)) ?
+    PyString_FromString(result) : 0;
+}
+
+SWIGRUNTIME int
+PySwigObject_compare(PySwigObject *v, PySwigObject *w)
+{
+  void *i = v->ptr;
+  void *j = w->ptr;
+  return (i < j) ? -1 : ((i > j) ? 1 : 0);
+}
+
+SWIGRUNTIME PyTypeObject* _PySwigObject_type(void);
+
+SWIGRUNTIME PyTypeObject*
+PySwigObject_type(void) {
+  static PyTypeObject *SWIG_STATIC_POINTER(type) = _PySwigObject_type();
+  return type;
+}
+
+SWIGRUNTIMEINLINE int
+PySwigObject_Check(PyObject *op) {
+  return ((op)->ob_type == PySwigObject_type())
+    || (strcmp((op)->ob_type->tp_name,"PySwigObject") == 0);
+}
+
+SWIGRUNTIME PyObject *
+PySwigObject_New(void *ptr, swig_type_info *ty, int own);
+
+SWIGRUNTIME void
+PySwigObject_dealloc(PyObject *v)
+{
+  PySwigObject *sobj = (PySwigObject *) v;
+  PyObject *next = sobj->next;
+  if (sobj->own) {
+    swig_type_info *ty = sobj->ty;
+    PySwigClientData *data = ty ? (PySwigClientData *) ty->clientdata : 0;
+    PyObject *destroy = data ? data->destroy : 0;
+    if (destroy) {
+      /* destroy is always a VARARGS method */
+      PyObject *res;
+      if (data->delargs) {
+	/* we need to create a temporal object to carry the destroy operation */
+	PyObject *tmp = PySwigObject_New(sobj->ptr, ty, 0);
+	res = SWIG_Python_CallFunctor(destroy, tmp);
+	Py_DECREF(tmp);
+      } else {
+	PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
+	PyObject *mself = PyCFunction_GET_SELF(destroy);
+	res = ((*meth)(mself, v));
+      }
+      Py_XDECREF(res);
+    } else {
+      const char *name = SWIG_TypePrettyName(ty);
+#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
+      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", name);
+#endif
+    }
+  } 
+  Py_XDECREF(next);
+  PyObject_DEL(v);
+}
+
+SWIGRUNTIME PyObject* 
+PySwigObject_append(PyObject* v, PyObject* next)
+{
+  PySwigObject *sobj = (PySwigObject *) v;
+#ifndef METH_O
+  PyObject *tmp = 0;
+  if (!PyArg_ParseTuple(next,(char *)"O:append", &tmp)) return NULL;
+  next = tmp;
+#endif
+  if (!PySwigObject_Check(next)) {
+    return NULL;
+  }
+  sobj->next = next;
+  Py_INCREF(next);
+  return SWIG_Py_Void();
+}
+
+SWIGRUNTIME PyObject* 
+#ifdef METH_NOARGS
+PySwigObject_next(PyObject* v)
+#else
+PySwigObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
+#endif
+{
+  PySwigObject *sobj = (PySwigObject *) v;
+  if (sobj->next) {    
+    Py_INCREF(sobj->next);
+    return sobj->next;
+  } else {
+    return SWIG_Py_Void();
+  }
+}
+
+SWIGINTERN PyObject*
+#ifdef METH_NOARGS
+PySwigObject_disown(PyObject *v)
+#else
+PySwigObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
+#endif
+{
+  PySwigObject *sobj = (PySwigObject *)v;
+  sobj->own = 0;
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject*
+#ifdef METH_NOARGS
+PySwigObject_acquire(PyObject *v)
+#else
+PySwigObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
+#endif
+{
+  PySwigObject *sobj = (PySwigObject *)v;
+  sobj->own = SWIG_POINTER_OWN;
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject*
+PySwigObject_own(PyObject *v, PyObject *args)
+{
+  PyObject *val = 0;
+#if (PY_VERSION_HEX < 0x02020000)
+  if (!PyArg_ParseTuple(args,(char *)"|O:own",&val))
+#else
+  if (!PyArg_UnpackTuple(args, (char *)"own", 0, 1, &val)) 
+#endif
+    {
+      return NULL;
+    } 
+  else
+    {
+      PySwigObject *sobj = (PySwigObject *)v;
+      PyObject *obj = PyBool_FromLong(sobj->own);
+      if (val) {
+#ifdef METH_NOARGS
+	if (PyObject_IsTrue(val)) {
+	  PySwigObject_acquire(v);
+	} else {
+	  PySwigObject_disown(v);
+	}
+#else
+	if (PyObject_IsTrue(val)) {
+	  PySwigObject_acquire(v,args);
+	} else {
+	  PySwigObject_disown(v,args);
+	}
+#endif
+      } 
+      return obj;
+    }
+}
+
+#ifdef METH_O
+static PyMethodDef
+swigobject_methods[] = {
+  {(char *)"disown",  (PyCFunction)PySwigObject_disown,  METH_NOARGS,  (char *)"releases ownership of the pointer"},
+  {(char *)"acquire", (PyCFunction)PySwigObject_acquire, METH_NOARGS,  (char *)"aquires ownership of the pointer"},
+  {(char *)"own",     (PyCFunction)PySwigObject_own,     METH_VARARGS, (char *)"returns/sets ownership of the pointer"},
+  {(char *)"append",  (PyCFunction)PySwigObject_append,  METH_O,       (char *)"appends another 'this' object"},
+  {(char *)"next",    (PyCFunction)PySwigObject_next,    METH_NOARGS,  (char *)"returns the next 'this' object"},
+  {(char *)"__repr__",(PyCFunction)PySwigObject_repr,    METH_NOARGS,  (char *)"returns object representation"},
+  {0, 0, 0, 0}  
+};
+#else
+static PyMethodDef
+swigobject_methods[] = {
+  {(char *)"disown",  (PyCFunction)PySwigObject_disown,  METH_VARARGS,  (char *)"releases ownership of the pointer"},
+  {(char *)"acquire", (PyCFunction)PySwigObject_acquire, METH_VARARGS,  (char *)"aquires ownership of the pointer"},
+  {(char *)"own",     (PyCFunction)PySwigObject_own,     METH_VARARGS,  (char *)"returns/sets ownership of the pointer"},
+  {(char *)"append",  (PyCFunction)PySwigObject_append,  METH_VARARGS,  (char *)"appends another 'this' object"},
+  {(char *)"next",    (PyCFunction)PySwigObject_next,    METH_VARARGS,  (char *)"returns the next 'this' object"},
+  {(char *)"__repr__",(PyCFunction)PySwigObject_repr,   METH_VARARGS,  (char *)"returns object representation"},
+  {0, 0, 0, 0}  
+};
+#endif
+
+#if PY_VERSION_HEX < 0x02020000
+SWIGINTERN PyObject *
+PySwigObject_getattr(PySwigObject *sobj,char *name)
+{
+  return Py_FindMethod(swigobject_methods, (PyObject *)sobj, name);
+}
+#endif
+
+SWIGRUNTIME PyTypeObject*
+_PySwigObject_type(void) {
+  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";
+  
+  static PyNumberMethods PySwigObject_as_number = {
+    (binaryfunc)0, /*nb_add*/
+    (binaryfunc)0, /*nb_subtract*/
+    (binaryfunc)0, /*nb_multiply*/
+    (binaryfunc)0, /*nb_divide*/
+    (binaryfunc)0, /*nb_remainder*/
+    (binaryfunc)0, /*nb_divmod*/
+    (ternaryfunc)0,/*nb_power*/
+    (unaryfunc)0,  /*nb_negative*/
+    (unaryfunc)0,  /*nb_positive*/
+    (unaryfunc)0,  /*nb_absolute*/
+    (inquiry)0,    /*nb_nonzero*/
+    0,		   /*nb_invert*/
+    0,		   /*nb_lshift*/
+    0,		   /*nb_rshift*/
+    0,		   /*nb_and*/
+    0,		   /*nb_xor*/
+    0,		   /*nb_or*/
+    (coercion)0,   /*nb_coerce*/
+    (unaryfunc)PySwigObject_long, /*nb_int*/
+    (unaryfunc)PySwigObject_long, /*nb_long*/
+    (unaryfunc)0,                 /*nb_float*/
+    (unaryfunc)PySwigObject_oct,  /*nb_oct*/
+    (unaryfunc)PySwigObject_hex,  /*nb_hex*/
+#if PY_VERSION_HEX >= 0x02020000
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */ 
+#elif PY_VERSION_HEX >= 0x02000000
+    0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_or */
+#endif
+  };
+
+  static PyTypeObject pyswigobject_type;  
+  static int type_init = 0;
+  if (!type_init) {
+    const PyTypeObject tmp
+      = {
+	PyObject_HEAD_INIT(NULL)
+	0,				    /* ob_size */
+	(char *)"PySwigObject",		    /* tp_name */
+	sizeof(PySwigObject),		    /* tp_basicsize */
+	0,			            /* tp_itemsize */
+	(destructor)PySwigObject_dealloc,   /* tp_dealloc */
+	(printfunc)PySwigObject_print,	    /* tp_print */
+#if PY_VERSION_HEX < 0x02020000
+	(getattrfunc)PySwigObject_getattr,  /* tp_getattr */ 
+#else
+	(getattrfunc)0,			    /* tp_getattr */ 
+#endif
+	(setattrfunc)0,			    /* tp_setattr */ 
+	(cmpfunc)PySwigObject_compare,	    /* tp_compare */ 
+	(reprfunc)PySwigObject_repr,	    /* tp_repr */    
+	&PySwigObject_as_number,	    /* tp_as_number */
+	0,				    /* tp_as_sequence */
+	0,				    /* tp_as_mapping */
+	(hashfunc)0,			    /* tp_hash */
+	(ternaryfunc)0,			    /* tp_call */
+	(reprfunc)PySwigObject_str,	    /* tp_str */
+	PyObject_GenericGetAttr,            /* tp_getattro */
+	0,				    /* tp_setattro */
+	0,		                    /* tp_as_buffer */
+	Py_TPFLAGS_DEFAULT,	            /* tp_flags */
+	swigobject_doc, 	            /* tp_doc */        
+	0,                                  /* tp_traverse */
+	0,                                  /* tp_clear */
+	0,                                  /* tp_richcompare */
+	0,                                  /* tp_weaklistoffset */
+#if PY_VERSION_HEX >= 0x02020000
+	0,                                  /* tp_iter */
+	0,                                  /* tp_iternext */
+	swigobject_methods,		    /* tp_methods */ 
+	0,			            /* tp_members */
+	0,				    /* tp_getset */	    	
+	0,			            /* tp_base */	        
+	0,				    /* tp_dict */	    	
+	0,				    /* tp_descr_get */  	
+	0,				    /* tp_descr_set */  	
+	0,				    /* tp_dictoffset */ 	
+	0,				    /* tp_init */	    	
+	0,				    /* tp_alloc */	    	
+	0,			            /* tp_new */	    	
+	0,	                            /* tp_free */	   
+        0,                                  /* tp_is_gc */  
+	0,				    /* tp_bases */   
+	0,				    /* tp_mro */
+	0,				    /* tp_cache */   
+ 	0,				    /* tp_subclasses */
+	0,				    /* tp_weaklist */
+#endif
+#if PY_VERSION_HEX >= 0x02030000
+	0,                                  /* tp_del */
+#endif
+#ifdef COUNT_ALLOCS
+	0,0,0,0                             /* tp_alloc -> tp_next */
+#endif
+      };
+    pyswigobject_type = tmp;
+    pyswigobject_type.ob_type = &PyType_Type;
+    type_init = 1;
+  }
+  return &pyswigobject_type;
+}
+
+SWIGRUNTIME PyObject *
+PySwigObject_New(void *ptr, swig_type_info *ty, int own)
+{
+  PySwigObject *sobj = PyObject_NEW(PySwigObject, PySwigObject_type());
+  if (sobj) {
+    sobj->ptr  = ptr;
+    sobj->ty   = ty;
+    sobj->own  = own;
+    sobj->next = 0;
+  }
+  return (PyObject *)sobj;
+}
+
+/* -----------------------------------------------------------------------------
+ * Implements a simple Swig Packed type, and use it instead of string
+ * ----------------------------------------------------------------------------- */
+
+typedef struct {
+  PyObject_HEAD
+  void *pack;
+  swig_type_info *ty;
+  size_t size;
+} PySwigPacked;
+
+SWIGRUNTIME int
+PySwigPacked_print(PySwigPacked *v, FILE *fp, int SWIGUNUSEDPARM(flags))
+{
+  char result[SWIG_BUFFER_SIZE];
+  fputs("<Swig Packed ", fp); 
+  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
+    fputs("at ", fp); 
+    fputs(result, fp); 
+  }
+  fputs(v->ty->name,fp); 
+  fputs(">", fp);
+  return 0; 
+}
+  
+SWIGRUNTIME PyObject *
+PySwigPacked_repr(PySwigPacked *v)
+{
+  char result[SWIG_BUFFER_SIZE];
+  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
+    return PyString_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
+  } else {
+    return PyString_FromFormat("<Swig Packed %s>", v->ty->name);
+  }  
+}
+
+SWIGRUNTIME PyObject *
+PySwigPacked_str(PySwigPacked *v)
+{
+  char result[SWIG_BUFFER_SIZE];
+  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
+    return PyString_FromFormat("%s%s", result, v->ty->name);
+  } else {
+    return PyString_FromString(v->ty->name);
+  }  
+}
+
+SWIGRUNTIME int
+PySwigPacked_compare(PySwigPacked *v, PySwigPacked *w)
+{
+  size_t i = v->size;
+  size_t j = w->size;
+  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
+  return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);
+}
+
+SWIGRUNTIME PyTypeObject* _PySwigPacked_type(void);
+
+SWIGRUNTIME PyTypeObject*
+PySwigPacked_type(void) {
+  static PyTypeObject *SWIG_STATIC_POINTER(type) = _PySwigPacked_type();
+  return type;
+}
+
+SWIGRUNTIMEINLINE int
+PySwigPacked_Check(PyObject *op) {
+  return ((op)->ob_type == _PySwigPacked_type()) 
+    || (strcmp((op)->ob_type->tp_name,"PySwigPacked") == 0);
+}
+
+SWIGRUNTIME void
+PySwigPacked_dealloc(PyObject *v)
+{
+  if (PySwigPacked_Check(v)) {
+    PySwigPacked *sobj = (PySwigPacked *) v;
+    free(sobj->pack);
+  }
+  PyObject_DEL(v);
+}
+
+SWIGRUNTIME PyTypeObject*
+_PySwigPacked_type(void) {
+  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
+  static PyTypeObject pyswigpacked_type;
+  static int type_init = 0;  
+  if (!type_init) {
+    const PyTypeObject tmp
+      = {
+	PyObject_HEAD_INIT(NULL)
+	0,				    /* ob_size */	
+	(char *)"PySwigPacked",		    /* tp_name */	
+	sizeof(PySwigPacked),		    /* tp_basicsize */	
+	0,				    /* tp_itemsize */	
+	(destructor)PySwigPacked_dealloc,   /* tp_dealloc */	
+	(printfunc)PySwigPacked_print,	    /* tp_print */   	
+	(getattrfunc)0,			    /* tp_getattr */ 	
+	(setattrfunc)0,			    /* tp_setattr */ 	
+	(cmpfunc)PySwigPacked_compare,	    /* tp_compare */ 	
+	(reprfunc)PySwigPacked_repr,	    /* tp_repr */    	
+	0,	                            /* tp_as_number */	
+	0,				    /* tp_as_sequence */
+	0,				    /* tp_as_mapping */	
+	(hashfunc)0,			    /* tp_hash */	
+	(ternaryfunc)0,			    /* tp_call */	
+	(reprfunc)PySwigPacked_str,	    /* tp_str */	
+	PyObject_GenericGetAttr,            /* tp_getattro */
+	0,				    /* tp_setattro */
+	0,		                    /* tp_as_buffer */
+	Py_TPFLAGS_DEFAULT,	            /* tp_flags */
+	swigpacked_doc, 	            /* tp_doc */
+	0,                                  /* tp_traverse */
+	0,                                  /* tp_clear */
+	0,                                  /* tp_richcompare */
+	0,                                  /* tp_weaklistoffset */
+#if PY_VERSION_HEX >= 0x02020000
+	0,                                  /* tp_iter */
+	0,                                  /* tp_iternext */
+	0,		                    /* tp_methods */ 
+	0,			            /* tp_members */
+	0,				    /* tp_getset */	    	
+	0,			            /* tp_base */	        
+	0,				    /* tp_dict */	    	
+	0,				    /* tp_descr_get */  	
+	0,				    /* tp_descr_set */  	
+	0,				    /* tp_dictoffset */ 	
+	0,				    /* tp_init */	    	
+	0,				    /* tp_alloc */	    	
+	0,			            /* tp_new */	    	
+	0, 	                            /* tp_free */	   
+        0,                                  /* tp_is_gc */  
+	0,				    /* tp_bases */   
+	0,				    /* tp_mro */
+	0,				    /* tp_cache */   
+ 	0,				    /* tp_subclasses */
+	0,				    /* tp_weaklist */
+#endif
+#if PY_VERSION_HEX >= 0x02030000
+	0,                                  /* tp_del */
+#endif
+#ifdef COUNT_ALLOCS
+	0,0,0,0                             /* tp_alloc -> tp_next */
+#endif
+      };
+    pyswigpacked_type = tmp;
+    pyswigpacked_type.ob_type = &PyType_Type;
+    type_init = 1;
+  }
+  return &pyswigpacked_type;
+}
+
+SWIGRUNTIME PyObject *
+PySwigPacked_New(void *ptr, size_t size, swig_type_info *ty)
+{
+  PySwigPacked *sobj = PyObject_NEW(PySwigPacked, PySwigPacked_type());
+  if (sobj) {
+    void *pack = malloc(size);
+    if (pack) {
+      memcpy(pack, ptr, size);
+      sobj->pack = pack;
+      sobj->ty   = ty;
+      sobj->size = size;
+    } else {
+      PyObject_DEL((PyObject *) sobj);
+      sobj = 0;
+    }
+  }
+  return (PyObject *) sobj;
+}
+
+SWIGRUNTIME swig_type_info *
+PySwigPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
+{
+  if (PySwigPacked_Check(obj)) {
+    PySwigPacked *sobj = (PySwigPacked *)obj;
+    if (sobj->size != size) return 0;
+    memcpy(ptr, sobj->pack, size);
+    return sobj->ty;
+  } else {
+    return 0;
+  }
+}
+
+/* -----------------------------------------------------------------------------
+ * pointers/data manipulation
+ * ----------------------------------------------------------------------------- */
+
+SWIGRUNTIMEINLINE PyObject *
+_SWIG_This(void)
+{
+  return PyString_FromString("this");
+}
+
+SWIGRUNTIME PyObject *
+SWIG_This(void)
+{
+  static PyObject *SWIG_STATIC_POINTER(swig_this) = _SWIG_This();
+  return swig_this;
+}
+
+/* #define SWIG_PYTHON_SLOW_GETSET_THIS */
+
+SWIGRUNTIME PySwigObject *
+SWIG_Python_GetSwigThis(PyObject *pyobj) 
+{
+  if (PySwigObject_Check(pyobj)) {
+    return (PySwigObject *) pyobj;
+  } else {
+    PyObject *obj = 0;
+#if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) && (PY_VERSION_HEX >= 0x02030000))
+    if (PyInstance_Check(pyobj)) {
+      obj = _PyInstance_Lookup(pyobj, SWIG_This());      
+    } else {
+      PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
+      if (dictptr != NULL) {
+	PyObject *dict = *dictptr;
+	obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
+      } else {
+#ifdef PyWeakref_CheckProxy
+	if (PyWeakref_CheckProxy(pyobj)) {
+	  PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
+	  return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
+	}
+#endif
+	obj = PyObject_GetAttr(pyobj,SWIG_This());
+	if (obj) {
+	  Py_DECREF(obj);
+	} else {
+	  if (PyErr_Occurred()) PyErr_Clear();
+	  return 0;
+	}
+      }
+    }
+#else
+    obj = PyObject_GetAttr(pyobj,SWIG_This());
+    if (obj) {
+      Py_DECREF(obj);
+    } else {
+      if (PyErr_Occurred()) PyErr_Clear();
+      return 0;
+    }
+#endif
+    if (obj && !PySwigObject_Check(obj)) {
+      /* a PyObject is called 'this', try to get the 'real this'
+	 PySwigObject from it */ 
+      return SWIG_Python_GetSwigThis(obj);
+    }
+    return (PySwigObject *)obj;
+  }
+}
+
+/* Acquire a pointer value */
+
+SWIGRUNTIME int
+SWIG_Python_AcquirePtr(PyObject *obj, int own) {
+  if (own) {
+    PySwigObject *sobj = SWIG_Python_GetSwigThis(obj);
+    if (sobj) {
+      int oldown = sobj->own;
+      sobj->own = own;
+      return oldown;
+    }
+  }
+  return 0;
+}
+
+/* Convert a pointer value */
+
+SWIGRUNTIME int
+SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
+  if (!obj) return SWIG_ERROR;
+  if (obj == Py_None) {
+    if (ptr) *ptr = 0;
+    return SWIG_OK;
+  } else {
+    PySwigObject *sobj = SWIG_Python_GetSwigThis(obj);
+    while (sobj) {
+      void *vptr = sobj->ptr;
+      if (ty) {
+	swig_type_info *to = sobj->ty;
+	if (to == ty) {
+	  /* no type cast needed */
+	  if (ptr) *ptr = vptr;
+	  break;
+	} else {
+	  swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
+	  if (!tc) {
+	    sobj = (PySwigObject *)sobj->next;
+	  } else {
+	    if (ptr) *ptr = SWIG_TypeCast(tc,vptr);
+	    break;
+	  }
+	}
+      } else {
+	if (ptr) *ptr = vptr;
+	break;
+      }
+    }
+    if (sobj) {
+      if (own) *own = sobj->own;
+      if (flags & SWIG_POINTER_DISOWN) {
+	sobj->own = 0;
+      }
+      return SWIG_OK;
+    } else {
+      int res = SWIG_ERROR;
+      if (flags & SWIG_POINTER_IMPLICIT_CONV) {
+	PySwigClientData *data = ty ? (PySwigClientData *) ty->clientdata : 0;
+	if (data && !data->implicitconv) {
+	  PyObject *klass = data->klass;
+	  if (klass) {
+	    PyObject *impconv;
+	    data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
+	    impconv = SWIG_Python_CallFunctor(klass, obj);
+	    data->implicitconv = 0;
+	    if (PyErr_Occurred()) {
+	      PyErr_Clear();
+	      impconv = 0;
+	    }
+	    if (impconv) {
+	      PySwigObject *iobj = SWIG_Python_GetSwigThis(impconv);
+	      if (iobj) {
+		void *vptr;
+		res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
+		if (SWIG_IsOK(res)) {
+		  if (ptr) {
+		    *ptr = vptr;
+		    /* transfer the ownership to 'ptr' */
+		    iobj->own = 0;
+		    res = SWIG_AddCast(res);
+		    res = SWIG_AddNewMask(res);
+		  } else {
+		    res = SWIG_AddCast(res);		    
+		  }
+		}
+	      }
+	      Py_DECREF(impconv);
+	    }
+	  }
+	}
+      }
+      return res;
+    }
+  }
+}
+
+/* Convert a function ptr value */
+
+SWIGRUNTIME int
+SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
+  if (!PyCFunction_Check(obj)) {
+    return SWIG_ConvertPtr(obj, ptr, ty, 0);
+  } else {
+    void *vptr = 0;
+    
+    /* here we get the method pointer for callbacks */
+    char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
+    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
+    if (desc) {
+      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
+      if (!desc) return SWIG_ERROR;
+    }
+    if (ty) {
+      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);
+      if (!tc) return SWIG_ERROR;
+      *ptr = SWIG_TypeCast(tc,vptr);
+    } else {
+      *ptr = vptr;
+    }
+    return SWIG_OK;
+  }
+}
+
+/* Convert a packed value value */
+
+SWIGRUNTIME int
+SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
+  swig_type_info *to = PySwigPacked_UnpackData(obj, ptr, sz);
+  if (!to) return SWIG_ERROR;
+  if (ty) {
+    if (to != ty) {
+      /* check type cast? */
+      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
+      if (!tc) return SWIG_ERROR;
+    }
+  }
+  return SWIG_OK;
+}  
+
+/* -----------------------------------------------------------------------------
+ * Create a new pointer object
+ * ----------------------------------------------------------------------------- */
+
+/*
+  Create a new instance object, whitout calling __init__, and set the
+  'this' attribute.
+*/
+
+SWIGRUNTIME PyObject* 
+SWIG_Python_NewShadowInstance(PySwigClientData *data, PyObject *swig_this)
+{
+#if (PY_VERSION_HEX >= 0x02020000)
+  PyObject *inst = 0;
+  PyObject *newraw = data->newraw;
+  if (newraw) {
+    inst = PyObject_Call(newraw, data->newargs, NULL);
+    if (inst) {
+#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
+      PyObject **dictptr = _PyObject_GetDictPtr(inst);
+      if (dictptr != NULL) {
+	PyObject *dict = *dictptr;
+	if (dict == NULL) {
+	  dict = PyDict_New();
+	  *dictptr = dict;
+	  PyDict_SetItem(dict, SWIG_This(), swig_this);
+	}
+      }
+#else
+      PyObject *key = SWIG_This();
+      PyObject_SetAttr(inst, key, swig_this);
+#endif
+    }
+  } else {
+    PyObject *dict = PyDict_New();
+    PyDict_SetItem(dict, SWIG_This(), swig_this);
+    inst = PyInstance_NewRaw(data->newargs, dict);
+    Py_DECREF(dict);
+  }
+  return inst;
+#else
+#if (PY_VERSION_HEX >= 0x02010000)
+  PyObject *inst;
+  PyObject *dict = PyDict_New();
+  PyDict_SetItem(dict, SWIG_This(), swig_this);
+  inst = PyInstance_NewRaw(data->newargs, dict);
+  Py_DECREF(dict);
+  return (PyObject *) inst;
+#else
+  PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);
+  if (inst == NULL) {
+    return NULL;
+  }
+  inst->in_class = (PyClassObject *)data->newargs;
+  Py_INCREF(inst->in_class);
+  inst->in_dict = PyDict_New();
+  if (inst->in_dict == NULL) {
+    Py_DECREF(inst);
+    return NULL;
+  }
+#ifdef Py_TPFLAGS_HAVE_WEAKREFS
+  inst->in_weakreflist = NULL;
+#endif
+#ifdef Py_TPFLAGS_GC
+  PyObject_GC_Init(inst);
+#endif
+  PyDict_SetItem(inst->in_dict, SWIG_This(), swig_this);
+  return (PyObject *) inst;
+#endif
+#endif
+}
+
+SWIGRUNTIME void
+SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
+{
+ PyObject *dict;
+#if (PY_VERSION_HEX >= 0x02020000) && !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
+ PyObject **dictptr = _PyObject_GetDictPtr(inst);
+ if (dictptr != NULL) {
+   dict = *dictptr;
+   if (dict == NULL) {
+     dict = PyDict_New();
+     *dictptr = dict;
+   }
+   PyDict_SetItem(dict, SWIG_This(), swig_this);
+   return;
+ }
+#endif
+ dict = PyObject_GetAttrString(inst, "__dict__");
+ PyDict_SetItem(dict, SWIG_This(), swig_this);
+ Py_DECREF(dict);
+} 
+
+
+SWIGINTERN PyObject *
+SWIG_Python_InitShadowInstance(PyObject *args) {
+  PyObject *obj[2];
+  if (!SWIG_Python_UnpackTuple(args,(char*)"swiginit", 2, 2, obj)) {
+    return NULL;
+  } else {
+    PySwigObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
+    if (sthis) {
+      PySwigObject_append((PyObject*) sthis, obj[1]);
+    } else {
+      SWIG_Python_SetSwigThis(obj[0], obj[1]);
+    }
+    return SWIG_Py_Void();
+  }
+}
+
+/* Create a new pointer object */
+
+SWIGRUNTIME PyObject *
+SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int flags) {
+  if (!ptr) {
+    return SWIG_Py_Void();
+  } else {
+    int own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
+    PyObject *robj = PySwigObject_New(ptr, type, own);
+    PySwigClientData *clientdata = type ? (PySwigClientData *)(type->clientdata) : 0;
+    if (clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
+      PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
+      if (inst) {
+	Py_DECREF(robj);
+	robj = inst;
+      }
+    }
+    return robj;
+  }
+}
+
+/* Create a new packed object */
+
+SWIGRUNTIMEINLINE PyObject *
+SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
+  return ptr ? PySwigPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
+}
+
+/* -----------------------------------------------------------------------------*
+ *  Get type list 
+ * -----------------------------------------------------------------------------*/
+
+#ifdef SWIG_LINK_RUNTIME
+void *SWIG_ReturnGlobalTypeList(void *);
+#endif
+
+SWIGRUNTIME swig_module_info *
+SWIG_Python_GetModule(void) {
+  static void *type_pointer = (void *)0;
+  /* first check if module already created */
+  if (!type_pointer) {
+#ifdef SWIG_LINK_RUNTIME
+    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
+#else
+    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
+				    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);
+    if (PyErr_Occurred()) {
+      PyErr_Clear();
+      type_pointer = (void *)0;
+    }
+#endif
+  }
+  return (swig_module_info *) type_pointer;
+}
+
+#if PY_MAJOR_VERSION < 2
+/* PyModule_AddObject function was introduced in Python 2.0.  The following function
+   is copied out of Python/modsupport.c in python version 2.3.4 */
+SWIGINTERN int
+PyModule_AddObject(PyObject *m, char *name, PyObject *o)
+{
+  PyObject *dict;
+  if (!PyModule_Check(m)) {
+    PyErr_SetString(PyExc_TypeError,
+		    "PyModule_AddObject() needs module as first arg");
+    return SWIG_ERROR;
+  }
+  if (!o) {
+    PyErr_SetString(PyExc_TypeError,
+		    "PyModule_AddObject() needs non-NULL value");
+    return SWIG_ERROR;
+  }
+  
+  dict = PyModule_GetDict(m);
+  if (dict == NULL) {
+    /* Internal error -- modules must have a dict! */
+    PyErr_Format(PyExc_SystemError, "module '%s' has no __dict__",
+		 PyModule_GetName(m));
+    return SWIG_ERROR;
+  }
+  if (PyDict_SetItemString(dict, name, o))
+    return SWIG_ERROR;
+  Py_DECREF(o);
+  return SWIG_OK;
+}
+#endif
+
+SWIGRUNTIME void
+SWIG_Python_DestroyModule(void *vptr)
+{
+  swig_module_info *swig_module = (swig_module_info *) vptr;
+  swig_type_info **types = swig_module->types;
+  size_t i;
+  for (i =0; i < swig_module->size; ++i) {
+    swig_type_info *ty = types[i];
+    if (ty->owndata) {
+      PySwigClientData *data = (PySwigClientData *) ty->clientdata;
+      if (data) PySwigClientData_Del(data);
+    }
+  }
+  Py_DECREF(SWIG_This());
+}
+
+SWIGRUNTIME void
+SWIG_Python_SetModule(swig_module_info *swig_module) {
+  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} };/* Sentinel */
+
+  PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
+				   swig_empty_runtime_method_table);
+  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, SWIG_Python_DestroyModule);
+  if (pointer && module) {
+    PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);
+  } else {
+    Py_XDECREF(pointer);
+  }
+}
+
+/* The python cached type query */
+SWIGRUNTIME PyObject *
+SWIG_Python_TypeCache() {
+  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
+  return cache;
+}
+
+SWIGRUNTIME swig_type_info *
+SWIG_Python_TypeQuery(const char *type)
+{
+  PyObject *cache = SWIG_Python_TypeCache();
+  PyObject *key = PyString_FromString(type); 
+  PyObject *obj = PyDict_GetItem(cache, key);
+  swig_type_info *descriptor;
+  if (obj) {
+    descriptor = (swig_type_info *) PyCObject_AsVoidPtr(obj);
+  } else {
+    swig_module_info *swig_module = SWIG_Python_GetModule();
+    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
+    if (descriptor) {
+      obj = PyCObject_FromVoidPtr(descriptor, NULL);
+      PyDict_SetItem(cache, key, obj);
+      Py_DECREF(obj);
+    }
+  }
+  Py_DECREF(key);
+  return descriptor;
+}
+
+/* 
+   For backward compatibility only
+*/
+#define SWIG_POINTER_EXCEPTION  0
+#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
+#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)
+
+SWIGRUNTIME int
+SWIG_Python_AddErrMesg(const char* mesg, int infront)
+{
+  if (PyErr_Occurred()) {
+    PyObject *type = 0;
+    PyObject *value = 0;
+    PyObject *traceback = 0;
+    PyErr_Fetch(&type, &value, &traceback);
+    if (value) {
+      PyObject *old_str = PyObject_Str(value);
+      Py_XINCREF(type);
+      PyErr_Clear();
+      if (infront) {
+	PyErr_Format(type, "%s %s", mesg, PyString_AsString(old_str));
+      } else {
+	PyErr_Format(type, "%s %s", PyString_AsString(old_str), mesg);
+      }
+      Py_DECREF(old_str);
+    }
+    return 1;
+  } else {
+    return 0;
+  }
+}
+  
+SWIGRUNTIME int
+SWIG_Python_ArgFail(int argnum)
+{
+  if (PyErr_Occurred()) {
+    /* add information about failing argument */
+    char mesg[256];
+    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
+    return SWIG_Python_AddErrMesg(mesg, 1);
+  } else {
+    return 0;
+  }
+}
+
+SWIGRUNTIMEINLINE const char *
+PySwigObject_GetDesc(PyObject *self)
+{
+  PySwigObject *v = (PySwigObject *)self;
+  swig_type_info *ty = v ? v->ty : 0;
+  return ty ? ty->str : (char*)"";
+}
+
+SWIGRUNTIME void
+SWIG_Python_TypeError(const char *type, PyObject *obj)
+{
+  if (type) {
+#if defined(SWIG_COBJECT_TYPES)
+    if (obj && PySwigObject_Check(obj)) {
+      const char *otype = (const char *) PySwigObject_GetDesc(obj);
+      if (otype) {
+	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'PySwigObject(%s)' is received",
+		     type, otype);
+	return;
+      }
+    } else 
+#endif      
+    {
+      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
+      if (otype) {
+	PyObject *str = PyObject_Str(obj);
+	const char *cstr = str ? PyString_AsString(str) : 0;
+	if (cstr) {
+	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
+		       type, otype, cstr);
+	} else {
+	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
+		       type, otype);
+	}
+	Py_XDECREF(str);
+	return;
+      }
+    }   
+    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
+  } else {
+    PyErr_Format(PyExc_TypeError, "unexpected type is received");
+  }
+}
+
+
+/* Convert a pointer value, signal an exception on a type mismatch */
+SWIGRUNTIME void *
+SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
+  void *result;
+  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
+    PyErr_Clear();
+    if (flags & SWIG_POINTER_EXCEPTION) {
+      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
+      SWIG_Python_ArgFail(argnum);
+    }
+  }
+  return result;
+}
+
+
+#ifdef __cplusplus
+#if 0
+{ /* cc-mode */
+#endif
+}
+#endif
+
+
+
+#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
+
+#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
+
+
+
+  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg); SWIG_fail;; } while(0) 
+
+
+/* -------- TYPES TABLE (BEGIN) -------- */
+
+#define SWIGTYPE_p_DialogApi swig_types[0]
+#define SWIGTYPE_p_EventManager swig_types[1]
+#define SWIGTYPE_p_GameAction swig_types[2]
+#define SWIGTYPE_p_GameConfig swig_types[3]
+#define SWIGTYPE_p_SoundSystem swig_types[4]
+#define SWIGTYPE_p_allocator_type swig_types[5]
+#define SWIGTYPE_p_boost__shared_ptrTSpaceLocation_t swig_types[6]
+#define SWIGTYPE_p_boost__shared_ptrTTGameEvent_t swig_types[7]
+#define SWIGTYPE_p_char swig_types[8]
+#define SWIGTYPE_p_difference_type swig_types[9]
+#define SWIGTYPE_p_p_PyObject swig_types[10]
+#define SWIGTYPE_p_size_type swig_types[11]
+#define SWIGTYPE_p_std__invalid_argument swig_types[12]
+#define SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t swig_types[13]
+#define SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type swig_types[14]
+#define SWIGTYPE_p_swig__PySwigIterator swig_types[15]
+#define SWIGTYPE_p_value_type swig_types[16]
+static swig_type_info *swig_types[18];
+static swig_module_info swig_module = {swig_types, 17, 0, 0, 0, 0};
+#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
+#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
+
+/* -------- TYPES TABLE (END) -------- */
+
+#if (PY_VERSION_HEX <= 0x02000000)
+# if !defined(SWIG_PYTHON_CLASSIC)
+#  error "This python version requires to use swig with the '-classic' option"
+# endif
+#endif
+
+/*-----------------------------------------------
+              @(target):= _tml.so
+  ------------------------------------------------*/
+#define SWIG_init    init_tml
+
+#define SWIG_name    "_tml"
+
+#define SWIGVERSION 0x010329 
+
+
+#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
+#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 
+
+
+#include <stdexcept>
+
+
+namespace swig {
+  class PyObject_ptr {
+  protected:
+    PyObject *_obj;
+
+  public:
+    PyObject_ptr() :_obj(0)
+    {
+    }
+
+    PyObject_ptr(const PyObject_ptr& item) : _obj(item._obj)
+    {
+      Py_XINCREF(_obj);      
+    }
+    
+    PyObject_ptr(PyObject *obj, bool initial_ref = true) :_obj(obj)
+    {
+      if (initial_ref) Py_XINCREF(_obj);
+    }
+    
+    PyObject_ptr & operator=(const PyObject_ptr& item) 
+    {
+      Py_XINCREF(item._obj);
+      Py_XDECREF(_obj);
+      _obj = item._obj;
+      return *this;      
+    }
+    
+    ~PyObject_ptr() 
+    {
+      Py_XDECREF(_obj);
+    }
+    
+    operator PyObject *() const
+    {
+      return _obj;
+    }
+
+    PyObject *operator->() const
+    {
+      return _obj;
+    }
+  };
+}
+
+
+namespace swig {
+  struct PyObject_var : PyObject_ptr {
+    PyObject_var(PyObject* obj = 0) : PyObject_ptr(obj, false) { }
+    
+    PyObject_var & operator = (PyObject* obj)
+    {
+      Py_XDECREF(_obj);
+      _obj = obj;
+      return *this;      
+    }
+  };
+}
+
+
+#include "tml/gameaction.h"
+#include "tml/gamedialog.h"
+#include "tml/gameconfig.h"
+#include "tml/eventmanager.h"
+#include "util/sound.h"
+
+
+#include <string>
+
+
+#include <stdexcept>
+
+
+  
+#if defined(__SUNPRO_CC) && defined(_RWSTD_VER)
+#  define SWIG_STD_NOASSIGN_STL
+#  define SWIG_STD_NOINSERT_TEMPLATE_STL
+#  define SWIG_STD_NOITERATOR_TRAITS_STL
+#endif
+
+#if defined(__GNUC__)
+#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
+#     define SWIG_STD_NOMODERN_STL
+#  endif
+#endif
+
+
+
+
+#include <string>
+#include <stdexcept>
+
+
+#include <utility>
+
+
+SWIGINTERN swig_type_info*
+SWIG_pchar_descriptor()
+{
+  static int init = 0;
+  static swig_type_info* info = 0;
+  if (!init) {
+    info = SWIG_TypeQuery("_p_char");
+    init = 1;
+  }
+  return info;
+}
+
+
+SWIGINTERN int
+SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
+{
+  if (PyString_Check(obj)) {
+    char *cstr; int len;
+    PyString_AsStringAndSize(obj, &cstr, &len);
+    if (cptr)  {
+      if (alloc) {
+	/* 
+	   In python the user should not be able to modify the inner
+	   string representation. To warranty that, if you define
+	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
+	   buffer is always returned.
+
+	   The default behavior is just to return the pointer value,
+	   so, be careful.
+	*/ 
+#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
+	if (*alloc != SWIG_OLDOBJ) 
+#else
+	if (*alloc == SWIG_NEWOBJ) 
+#endif
+	  {
+	    *cptr = reinterpret_cast< char* >(memcpy((new char[len + 1]), cstr, sizeof(char)*(len + 1)));
+	    *alloc = SWIG_NEWOBJ;
+	  }
+	else {
+	  *cptr = cstr;
+	  *alloc = SWIG_OLDOBJ;
+	}
+      } else {
+	*cptr = PyString_AsString(obj);
+      }
+    }
+    if (psize) *psize = len + 1;
+    return SWIG_OK;
+  } else {
+    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
+    if (pchar_descriptor) {
+      void* vptr = 0;
+      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
+	if (cptr) *cptr = (char *) vptr;
+	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
+	if (alloc) *alloc = SWIG_OLDOBJ;
+	return SWIG_OK;
+      }
+    }
+  }
+  return SWIG_TypeError;
+}
+
+
+SWIGINTERN int
+SWIG_AsPtr_std_string (PyObject * obj, std::string **val) 
+{
+  char* buf = 0 ; size_t size = 0; int alloc = SWIG_OLDOBJ;
+  if (SWIG_IsOK((SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc)))) {
+    if (buf) {
+      if (val) *val = new std::string(buf, size - 1);
+      if (alloc == SWIG_NEWOBJ) delete[] buf;
+      return SWIG_NEWOBJ;
+    } else {
+      if (val) *val = 0;
+      return SWIG_OLDOBJ;
+    }
+  } else {
+    static int init = 0;
+    static swig_type_info* descriptor = 0;
+    if (!init) {
+      descriptor = SWIG_TypeQuery("std::string" " *");
+      init = 1;
+    }
+    if (descriptor) {
+      std::string *vptr;
+      int res = SWIG_ConvertPtr(obj, (void**)&vptr, descriptor, 0);
+      if (SWIG_IsOK(res) && val) *val = vptr;
+      return res;
+    }
+  }
+  return SWIG_ERROR;
+}
+
+
+SWIGINTERN int
+SWIG_AsVal_double (PyObject *obj, double *val)
+{
+  int res = SWIG_TypeError;
+  if (PyFloat_Check(obj)) {
+    if (val) *val = PyFloat_AsDouble(obj);
+    return SWIG_OK;
+  } else if (PyInt_Check(obj)) {
+    if (val) *val = PyInt_AsLong(obj);
+    return SWIG_OK;
+  } else if (PyLong_Check(obj)) {
+    double v = PyLong_AsDouble(obj);
+    if (!PyErr_Occurred()) {
+      if (val) *val = v;
+      return SWIG_OK;
+    } else {
+      PyErr_Clear();
+    }
+  }
+#ifdef SWIG_PYTHON_CAST_MODE
+  {
+    int dispatch = 0;
+    double d = PyFloat_AsDouble(obj);
+    if (!PyErr_Occurred()) {
+      if (val) *val = d;
+      return SWIG_AddCast(SWIG_OK);
+    } else {
+      PyErr_Clear();
+    }
+    if (!dispatch) {
+      long v = PyLong_AsLong(obj);
+      if (!PyErr_Occurred()) {
+	if (val) *val = v;
+	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
+      } else {
+	PyErr_Clear();
+      }
+    }
+  }
+#endif
+  return res;
+}
+
+
+  #define SWIG_From_long   PyInt_FromLong 
+
+
+SWIGINTERNINLINE PyObject *
+SWIG_From_int  (int value)
+{    
+  return SWIG_From_long  (value);
+}
+
+
+SWIGINTERNINLINE PyObject *
+SWIG_FromCharPtrAndSize(const char* carray, size_t size)
+{
+  if (carray) {
+    if (size > INT_MAX) {
+      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
+      return pchar_descriptor ? 
+	SWIG_NewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : SWIG_Py_Void();
+    } else {
+      return PyString_FromStringAndSize(carray, static_cast< int >(size));
+    }
+  } else {
+    return SWIG_Py_Void();
+  }
+}
+
+
+SWIGINTERNINLINE PyObject *
+SWIG_From_std_string  (const std::string& s)
+{
+  return SWIG_FromCharPtrAndSize(s.data(), s.size());
+}
+
+
+  #define SWIG_From_double   PyFloat_FromDouble 
+
+
+SWIGINTERNINLINE PyObject*
+  SWIG_From_bool  (bool value)
+{
+  return PyBool_FromLong(value ? 1 : 0);
+}
+
+
+#include <limits.h>
+#ifndef LLONG_MIN
+# define LLONG_MIN	LONG_LONG_MIN
+#endif
+#ifndef LLONG_MAX
+# define LLONG_MAX	LONG_LONG_MAX
+#endif
+#ifndef ULLONG_MAX
+# define ULLONG_MAX	ULONG_LONG_MAX
+#endif
+
+
+#include <float.h>
+
+
+#include <math.h>
+
+
+SWIGINTERNINLINE int
+SWIG_CanCastAsInteger(double *d, double min, double max) {
+  double x = *d;
+  if ((min <= x && x <= max)) {
+   double fx = floor(x);
+   double cx = ceil(x);
+   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
+   if ((errno == EDOM) || (errno == ERANGE)) {
+     errno = 0;
+   } else {
+     double summ, reps, diff;
+     if (rd < x) {
+       diff = x - rd;
+     } else if (rd > x) {
+       diff = rd - x;
+     } else {
+       return 1;
+     }
+     summ = rd + x;
+     reps = diff/summ;
+     if (reps < 8*DBL_EPSILON) {
+       *d = rd;
+       return 1;
+     }
+   }
+  }
+  return 0;
+}
+
+
+SWIGINTERN int
+SWIG_AsVal_long (PyObject *obj, long* val)
+{
+  if (PyInt_Check(obj)) {
+    if (val) *val = PyInt_AsLong(obj);
+    return SWIG_OK;
+  } else if (PyLong_Check(obj)) {
+    long v = PyLong_AsLong(obj);
+    if (!PyErr_Occurred()) {
+      if (val) *val = v;
+      return SWIG_OK;
+    } else {
+      PyErr_Clear();
+    }
+  }
+#ifdef SWIG_PYTHON_CAST_MODE
+  {
+    int dispatch = 0;
+    long v = PyInt_AsLong(obj);
+    if (!PyErr_Occurred()) {
+      if (val) *val = v;
+      return SWIG_AddCast(SWIG_OK);
+    } else {
+      PyErr_Clear();
+    }
+    if (!dispatch) {
+      double d;
+      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
+      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
+	if (val) *val = (long)(d);
+	return res;
+      }
+    }
+  }
+#endif
+  return SWIG_TypeError;
+}
+
+
+SWIGINTERN int
+SWIG_AsVal_int (PyObject * obj, int *val)
+{
+  long v;
+  int res = SWIG_AsVal_long (obj, &v);
+  if (SWIG_IsOK(res)) {
+    if ((v < INT_MIN || v > INT_MAX)) {
+      return SWIG_OverflowError;
+    } else {
+      if (val) *val = static_cast< int >(v);
+    }
+  }  
+  return res;
+}
+
+
+SWIGINTERN int
+SWIG_AsVal_bool (PyObject *obj, bool *val)
+{
+  if (obj == Py_True) {
+    if (val) *val = true;
+    return SWIG_OK;
+  } else if (obj == Py_False) {
+    if (val) *val = false;
+    return SWIG_OK;
+  } else {
+    long v = 0;
+    int res = SWIG_AddCast(SWIG_AsVal_long (obj, val ? &v : 0));
+    if (SWIG_IsOK(res) && val) *val = v ? true : false;
+    return res;
+  }
+}
+
+
+#include <iostream>
+
+  
+namespace swig {
+  struct stop_iteration {
+  };
+
+  struct PySwigIterator {
+  private:
+    PyObject_ptr _seq;
+
+  protected:
+    PySwigIterator(PyObject *seq) : _seq(seq)
+    {
+    }
+      
+  public:
+    virtual ~PySwigIterator() {}
+
+    // Access iterator method, required by Python
+    virtual PyObject *value() const = 0;
+
+    // Forward iterator method, required by Python
+    virtual PySwigIterator *incr(size_t n = 1) = 0;
+    
+    // Backward iterator method, very common in C++, but not required in Python
+    virtual PySwigIterator *decr(size_t n = 1)
+    {
+      throw stop_iteration();
+    }
+
+    // Random access iterator methods, but not required in Python
+    virtual ptrdiff_t distance(const PySwigIterator &x) const
+    {
+      throw std::invalid_argument("operation not supported");
+    }
+
+    virtual bool equal (const PySwigIterator &x) const
+    {
+      throw std::invalid_argument("operation not supported");
+    }
+    
+    // C++ common/needed methods
+    virtual PySwigIterator *copy() const = 0;
+
+    PyObject *next()
+    {
+      PyObject *obj = value();
+      incr();
+      return obj;
+    }
+
+    PyObject *previous()
+    {
+      decr();
+      return value();
+    }
+
+    PySwigIterator *advance(ptrdiff_t n)
+    {
+      return  (n > 0) ?  incr(n) : decr(-n);
+    }
+      
+    bool operator == (const PySwigIterator& x)  const
+    {
+      return equal(x);
+    }
+      
+    bool operator != (const PySwigIterator& x) const
+    {
+      return ! operator==(x);
+    }
+      
+    PySwigIterator& operator += (ptrdiff_t n)
+    {
+      return *advance(n);
+    }
+
+    PySwigIterator& operator -= (ptrdiff_t n)
+    {
+      return *advance(-n);
+    }
+      
+    PySwigIterator* operator + (ptrdiff_t n) const
+    {
+      return copy()->advance(n);
+    }
+
+    PySwigIterator* operator - (ptrdiff_t n) const
+    {
+      return copy()->advance(-n);
+    }
+      
+    ptrdiff_t operator - (const PySwigIterator& x) const
+    {
+      return x.distance(*this);
+    }
+      
+    static swig_type_info* descriptor() {
+      static int init = 0;
+      static swig_type_info* desc = 0;
+      if (!init) {
+	desc = SWIG_TypeQuery("swig::PySwigIterator *");
+	init = 1;
+      }	
+      return desc;
+    }    
+  };
+}
+
+
+SWIGINTERN int
+SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
+{
+  if (PyInt_Check(obj)) {
+    long v = PyInt_AsLong(obj);
+    if (v >= 0) {
+      if (val) *val = v;
+      return SWIG_OK;
+    } else {
+      return SWIG_OverflowError;
+    }
+  } else if (PyLong_Check(obj)) {
+    unsigned long v = PyLong_AsUnsignedLong(obj);
+    if (!PyErr_Occurred()) {
+      if (val) *val = v;
+      return SWIG_OK;
+    } else {
+      PyErr_Clear();
+    }
+  }
+#ifdef SWIG_PYTHON_CAST_MODE
+  {
+    int dispatch = 0;
+    unsigned long v = PyLong_AsUnsignedLong(obj);
+    if (!PyErr_Occurred()) {
+      if (val) *val = v;
+      return SWIG_AddCast(SWIG_OK);
+    } else {
+      PyErr_Clear();
+    }
+    if (!dispatch) {
+      double d;
+      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
+      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
+	if (val) *val = (unsigned long)(d);
+	return res;
+      }
+    }
+  }
+#endif
+  return SWIG_TypeError;
+}
+
+
+SWIGINTERNINLINE int
+SWIG_AsVal_size_t (PyObject * obj, size_t *val)
+{
+  unsigned long v;
+  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
+  if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
+  return res;
+}
+
+
+SWIGINTERNINLINE PyObject *
+SWIG_From_ptrdiff_t  (ptrdiff_t value)
+{    
+  return SWIG_From_long  (static_cast< long >(value));
+}
+
+
+SWIGINTERNINLINE int
+SWIG_AsVal_ptrdiff_t (PyObject * obj, ptrdiff_t *val)
+{
+  long v;
+  int res = SWIG_AsVal_long (obj, val ? &v : 0);
+  if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
+  return res;
+}
+
+
+#include <stdexcept>
+
+
+#include <algorithm>
+
+
+#include <vector>
+
+
+namespace swig {  
+  template <class Type>
+  struct noconst_traits {
+    typedef Type noconst_type;
+  };
+
+  template <class Type>
+  struct noconst_traits<const Type> {
+    typedef Type noconst_type;
+  };
+
+  /*
+    type categories
+  */
+  struct pointer_category { };  
+  struct value_category { };
+
+  /*
+    General traits that provides type_name and type_info
+  */
+  template <class Type> struct traits { };
+
+  template <class Type>
+  inline const char* type_name() {
+    return traits<typename noconst_traits<Type >::noconst_type >::type_name();
+  }
+
+  template <class Type> 
+  struct traits_info {
+    static swig_type_info *type_query(std::string name) {
+      name += " *";
+      return SWIG_TypeQuery(name.c_str());
+    }    
+    static swig_type_info *type_info() {
+      static swig_type_info *info = type_query(type_name<Type>());
+      return info;
+    }
+  };
+
+  template <class Type>
+  inline swig_type_info *type_info() {
+    return traits_info<Type>::type_info();
+  }
+
+  /*
+    Partial specialization for pointers
+  */
+  template <class Type> struct traits <Type *> {
+    typedef pointer_category category;
+    static std::string make_ptr_name(const char* name) {
+      std::string ptrname = name;
+      ptrname += " *";
+      return ptrname;
+    }    
+    static const char* type_name() {
+      static std::string name = make_ptr_name(swig::type_name<Type>());
+      return name.c_str();
+    }
+  };
+
+  template <class Type, class Category> 
+  struct traits_as { };
+ 
+  template <class Type, class Category> 
+  struct traits_check { };
+
+}
+
+
+namespace swig {  
+  /*
+    Traits that provides the from method
+  */
+  template <class Type> struct traits_from_ptr {
+    static PyObject *from(Type *val, int owner = 0) {
+      return SWIG_NewPointerObj(val, type_info<Type>(), owner);
+    }
+  };
+
+  template <class Type> struct traits_from {
+    static PyObject *from(const Type& val) {
+      return traits_from_ptr<Type>::from(new Type(val), 1);
+    }
+  };
+
+  template <class Type> struct traits_from<Type *> {
+    static PyObject *from(Type* val) {
+      return traits_from_ptr<Type>::from(val, 0);
+    }
+  };
+
+  template <class Type>
+  inline PyObject *from(const Type& val) {
+    return traits_from<Type>::from(val);
+  }
+
+  template <class Type>
+  inline PyObject *from_ptr(Type* val, int owner) {
+    return traits_from_ptr<Type>::from(val, owner);
+  }
+
+  /*
+    Traits that provides the asval/as/check method
+  */
+  template <class Type>
+  struct traits_asptr {   
+    static int asptr(PyObject *obj, Type **val) {
+      Type *p;
+      int res = (SWIG_ConvertPtr(obj, (void**)&p, type_info<Type>(), 0) == SWIG_OK) ? SWIG_OLDOBJ : 0;
+      if (SWIG_IsOK(res)) {
+	if (val) *val = p;
+      }
+      return res;
+    }
+  }; 
+
+  template <class Type>
+  inline int asptr(PyObject *obj, Type **vptr) {
+    return traits_asptr<Type>::asptr(obj, vptr);
+  }
+
+  template <class Type> 
+  struct traits_asval {
+    static int asval(PyObject *obj, Type *val) {
+      if (val) {
+	Type *p = 0;
+	int res = traits_asptr<Type>::asptr(obj, &p);
+	if (!SWIG_IsOK(res)) return res;	
+	if (p) {
+	  typedef typename noconst_traits<Type>::noconst_type noconst_type;
+	  *(const_cast<noconst_type*>(val)) = *p;
+	  if (SWIG_IsNewObj(res)){
+	    delete p;
+	    res = SWIG_DelNewMask(res);
+	  }
+	  return res;
+	} else {
+	  return SWIG_ERROR;
+	}
+      } else {
+	return traits_asptr<Type>::asptr(obj, (Type **)(0));
+      }
+    }
+  };
+
+  template <class Type> struct traits_asval<Type*> {
+    static int asval(PyObject *obj, Type **val) {
+      if (val) {
+        typedef typename noconst_traits<Type>::noconst_type noconst_type;
+        noconst_type *p = 0;
+        int res = traits_asptr<noconst_type>::asptr(obj,  &p);
+        if (SWIG_IsOK(res)) {
+          *(const_cast<noconst_type**>(val)) = p;
+	}
+	return res;
+      } else {
+	return traits_asptr<Type>::asptr(obj, (Type **)(0));
+      }
+    }
+  };
+  
+  template <class Type>
+  inline int asval(PyObject *obj, Type *val) {
+    return traits_asval<Type>::asval(obj, val);
+  }
+
+  template <class Type> 
+  struct traits_as<Type, value_category> {
+    static Type as(PyObject *obj, bool throw_error) {
+      Type v;
+      int res = asval(obj, &v);
+      if (!obj || !SWIG_IsOK(res)) {
+	if (!PyErr_Occurred()) {
+	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
+	}
+	if (throw_error) throw std::invalid_argument("bad type");
+      }
+      return v;
+    }
+  };
+
+  template <class Type> 
+  struct traits_as<Type, pointer_category> {
+    static Type as(PyObject *obj, bool throw_error) {
+      Type *v = 0;      
+      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
+      if (SWIG_IsOK(res) && v) {
+	if (SWIG_IsNewObj(res)) {
+	  Type r(*v);
+	  delete v;
+	  return r;
+	} else {
+	  return *v;
+	}
+      } else {
+	// Uninitialized return value, no Type() constructor required.
+	static Type *v_def = (Type*) malloc(sizeof(Type));
+	if (!PyErr_Occurred()) {
+	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
+	}
+	if (throw_error) throw std::invalid_argument("bad type");
+	memset(v_def,0,sizeof(Type));
+	return *v_def;
+      }
+    }
+  };
+
+  template <class Type> 
+  struct traits_as<Type*, pointer_category> {
+    static Type* as(PyObject *obj, bool throw_error) {
+      Type *v = 0;      
+      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
+      if (SWIG_IsOK(res)) {
+	return v;
+      } else {
+	if (!PyErr_Occurred()) {
+	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
+	}
+	if (throw_error) throw std::invalid_argument("bad type");
+	return 0;
+      }
+    }
+  };
+    
+  template <class Type>
+  inline Type as(PyObject *obj, bool te = false) {
+    return traits_as<Type, typename traits<Type>::category>::as(obj, te);
+  }
+
+  template <class Type> 
+  struct traits_check<Type, value_category> {
+    static bool check(PyObject *obj) {
+      int res = obj ? asval(obj, (Type *)(0)) : SWIG_ERROR;
+      return SWIG_IsOK(res) ? true : false;
+    }
+  };
+
+  template <class Type> 
+  struct traits_check<Type, pointer_category> {
+    static bool check(PyObject *obj) {
+      int res = obj ? asptr(obj, (Type **)(0)) : SWIG_ERROR;
+      return SWIG_IsOK(res) ? true : false;
+    }
+  };
+
+  template <class Type>
+  inline bool check(PyObject *obj) {
+    return traits_check<Type, typename traits<Type>::category>::check(obj);
+  }
+}
+
+
+#include <functional>
+
+namespace std {
+  template <>
+  struct less <PyObject *>: public binary_function<PyObject *, PyObject *, bool>
+  {
+    bool
+    operator()(PyObject * v, PyObject *w) const
+    { 
+      bool res;
+      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
+      res = PyObject_Compare(v, w) < 0;
+      SWIG_PYTHON_THREAD_END_BLOCK;
+      return res;
+    }
+  };
+
+  template <>
+  struct less <swig::PyObject_ptr>: public binary_function<swig::PyObject_ptr, swig::PyObject_ptr, bool>
+  {
+    bool
+    operator()(const swig::PyObject_ptr& v, const swig::PyObject_ptr& w) const
+    {
+      return std::less<PyObject *>()(v, w);
+    }
+  };
+
+  template <>
+  struct less <swig::PyObject_var>: public binary_function<swig::PyObject_var, swig::PyObject_var, bool>
+  {
+    bool
+    operator()(const swig::PyObject_var& v, const swig::PyObject_var& w) const
+    {
+      return std::less<PyObject *>()(v, w);
+    }
+  };
+
+}
+
+namespace swig {
+  template <> struct traits<PyObject *> {
+    typedef value_category category;
+    static const char* type_name() { return "PyObject *"; }
+  };  
+
+  template <>  struct traits_asval<PyObject * > {   
+    typedef PyObject * value_type;
+    static int asval(PyObject *obj, value_type *val) {
+      if (val) *val = obj;
+      return SWIG_OK;
+    }
+  };
+
+  template <> 
+  struct traits_check<PyObject *, value_category> {
+    static bool check(PyObject *) {
+      return true;
+    }
+  };
+
+  template <>  struct traits_from<PyObject *> {
+    typedef PyObject * value_type;
+    static PyObject *from(const value_type& val) {
+      Py_XINCREF(val);
+      return val;
+    }
+  };
+  
+}
+
+namespace swig {
+  inline size_t
+  check_index(ptrdiff_t i, size_t size, bool insert = false) {
+    if ( i < 0 ) {
+      if ((size_t) (-i) <= size)
+	return (size_t) (i + size);
+    } else if ( (size_t) i < size ) {
+      return (size_t) i;
+    } else if (insert && ((size_t) i == size)) {
+      return size;
+    }
+    
+    throw std::out_of_range("index out of range");
+  }
+
+  inline size_t
+  slice_index(ptrdiff_t i, size_t size) {
+    if ( i < 0 ) {
+      if ((size_t) (-i) <= size) {
+	return (size_t) (i + size);
+      } else {
+	throw std::out_of_range("index out of range");
+      }
+    } else {
+      return ( (size_t) i < size ) ? ((size_t) i) : size;
+    }
+  }
+
+  template <class Sequence, class Difference>
+  inline typename Sequence::iterator
+  getpos(Sequence* self, Difference i)  {
+    typename Sequence::iterator pos = self->begin();
+    std::advance(pos, check_index(i,self->size()));
+    return pos;
+  }
+
+  template <class Sequence, class Difference>
+  inline typename Sequence::const_iterator
+  cgetpos(const Sequence* self, Difference i)  {
+    typename Sequence::const_iterator pos = self->begin();
+    std::advance(pos, check_index(i,self->size()));
+    return pos;
+  }
+
+  template <class Sequence, class Difference>
+  inline Sequence*
+  getslice(const Sequence* self, Difference i, Difference j) {
+    typename Sequence::size_type size = self->size();
+    typename Sequence::size_type ii = swig::check_index(i, size);
+    typename Sequence::size_type jj = swig::slice_index(j, size);
+
+    if (jj > ii) {
+      typename Sequence::const_iterator vb = self->begin();
+      typename Sequence::const_iterator ve = self->begin();
+      std::advance(vb,ii);
+      std::advance(ve,jj);
+      return new Sequence(vb, ve);
+    } else {
+      return new Sequence();
+    }
+  }
+
+  template <class Sequence, class Difference, class InputSeq>
+  inline void
+  setslice(Sequence* self, Difference i, Difference j, const InputSeq& v) {
+    typename Sequence::size_type size = self->size();
+    typename Sequence::size_type ii = swig::check_index(i, size, true);
+    typename Sequence::size_type jj = swig::slice_index(j, size);
+    if (jj < ii) jj = ii;
+    size_t ssize = jj - ii;
+    if (ssize <= v.size()) {
+      typename Sequence::iterator sb = self->begin();
+      typename InputSeq::const_iterator vmid = v.begin();
+      std::advance(sb,ii);
+      std::advance(vmid, jj - ii);
+      self->insert(std::copy(v.begin(), vmid, sb), vmid, v.end());
+    } else {
+      typename Sequence::iterator sb = self->begin();
+      typename Sequence::iterator se = self->begin();
+      std::advance(sb,ii);
+      std::advance(se,jj);
+      self->erase(sb,se);
+      self->insert(sb, v.begin(), v.end());
+    }
+  }
+
+  template <class Sequence, class Difference>
+  inline void
+  delslice(Sequence* self, Difference i, Difference j) {
+    typename Sequence::size_type size = self->size();
+    typename Sequence::size_type ii = swig::check_index(i, size, true);
+    typename Sequence::size_type jj = swig::slice_index(j, size);
+    if (jj > ii) {
+      typename Sequence::iterator sb = self->begin();
+      typename Sequence::iterator se = self->begin();
+      std::advance(sb,ii);
+      std::advance(se,jj);
+      self->erase(sb,se);
+    }
+  }
+}
+
+
+#if !defined(SWIG_STD_NOITERATOR_TRAITS_STL)
+#include <iterator>
+#else
+namespace std  {
+  template <class Iterator>
+  struct iterator_traits {
+    typedef ptrdiff_t difference_type;
+    typedef typename Iterator::value_type value_type;
+  };
+
+#if defined(__SUNPRO_CC) && defined(_RWSTD_VER)
+  template <class Iterator, class Category,class T, class Reference, class Pointer, class Distance>
+  struct iterator_traits<__reverse_bi_iterator<Iterator,Category,T,Reference,Pointer,Distance> > {
+    typedef Distance difference_type;
+    typedef T value_type;
+  };
+#endif  
+
+  template <class T>
+  struct iterator_traits<T*> {
+    typedef T value_type;
+    typedef ptrdiff_t difference_type;
+  };
+
+  template<typename _InputIterator>
+  inline typename iterator_traits<_InputIterator>::difference_type
+  distance(_InputIterator __first, _InputIterator __last)
+  {
+    typename iterator_traits<_InputIterator>::difference_type __n = 0;
+    while (__first != __last) {
+      ++__first; ++__n;
+    }
+    return __n;
+  }
+
+} 
+#endif
+
+
+namespace swig {
+  template<typename OutIterator>
+  class PySwigIterator_T :  public PySwigIterator
+  {
+  public:
+    typedef OutIterator out_iterator;
+    typedef typename std::iterator_traits<out_iterator>::value_type value_type;    
+    typedef PySwigIterator_T<out_iterator> self_type;
+
+    PySwigIterator_T(out_iterator curr, PyObject *seq)
+      : PySwigIterator(seq), current(curr)
+    {
+    }
+
+    const out_iterator& get_current() const
+    {
+      return current;
+    }
+
+    
+    bool equal (const PySwigIterator &iter) const
+    {
+      const self_type *iters = dynamic_cast<const self_type *>(&iter);
+      if (iters) {
+	return (current == iters->get_current());
+      } else {
+	throw std::invalid_argument("bad iterator type");
+      }
+    }
+    
+    ptrdiff_t distance(const PySwigIterator &iter) const
+    {
+      const self_type *iters = dynamic_cast<const self_type *>(&iter);
+      if (iters) {
+	return std::distance(current, iters->get_current());
+      } else {
+	throw std::invalid_argument("bad iterator type");
+      }
+    }    
+    
+  protected:
+    out_iterator current;
+  };
+  
+  template <class ValueType>
+  struct from_oper 
+  {
+    typedef const ValueType& argument_type;
+    typedef PyObject *result_type;
+    result_type operator()(argument_type v) const
+    {
+      return swig::from(v);
+    }
+  };
+
+  template<typename OutIterator, 
+	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
+	   typename FromOper = from_oper<ValueType> >
+  class PySwigIteratorOpen_T :  public PySwigIterator_T<OutIterator>
+  {
+  public:
+    FromOper from;
+    typedef OutIterator out_iterator;
+    typedef ValueType value_type;
+    typedef PySwigIterator_T<out_iterator>  base;
+    typedef PySwigIteratorOpen_T<OutIterator, ValueType, FromOper> self_type;
+    
+    PySwigIteratorOpen_T(out_iterator curr, PyObject *seq)
+      : PySwigIterator_T<OutIterator>(curr, seq)
+    {
+    }
+    
+    PyObject *value() const {
+      return from(static_cast<const value_type&>(*(base::current)));
+    }
+    
+    PySwigIterator *copy() const
+    {
+      return new self_type(*this);
+    }
+
+    PySwigIterator *incr(size_t n = 1)
+    {
+      while (n--) {
+	++base::current;
+      }
+      return this;
+    }
+
+    PySwigIterator *decr(size_t n = 1)
+    {
+      while (n--) {
+	--base::current;
+      }
+      return this;
+    }
+  };
+
+  template<typename OutIterator, 
+	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
+	   typename FromOper = from_oper<ValueType> >
+  class PySwigIteratorClosed_T :  public PySwigIterator_T<OutIterator>
+  {
+  public:
+    FromOper from;
+    typedef OutIterator out_iterator;
+    typedef ValueType value_type;
+    typedef PySwigIterator_T<out_iterator>  base;    
+    typedef PySwigIteratorClosed_T<OutIterator, ValueType, FromOper> self_type;
+    
+    PySwigIteratorClosed_T(out_iterator curr, out_iterator first, out_iterator last, PyObject *seq)
+      : PySwigIterator_T<OutIterator>(curr, seq), begin(first), end(last)
+    {
+    }
+    
+    PyObject *value() const {
+      if (base::current == end) {
+	throw stop_iteration();
+      } else {
+	return from(static_cast<const value_type&>(*(base::current)));
+      }
+    }
+    
+    PySwigIterator *copy() const
+    {
+      return new self_type(*this);
+    }
+
+    PySwigIterator *incr(size_t n = 1)
+    {
+      while (n--) {
+	if (base::current == end) {
+	  throw stop_iteration();
+	} else {
+	  ++base::current;
+	}
+      }
+      return this;
+    }
+
+    PySwigIterator *decr(size_t n = 1)
+    {
+      while (n--) {
+	if (base::current == begin) {
+	  throw stop_iteration();
+	} else {
+	  --base::current;
+	}
+      }
+      return this;
+    }
+
+  private:
+    out_iterator begin;
+    out_iterator end;
+  };
+
+  template<typename OutIter>
+  inline PySwigIterator*
+  make_output_iterator(const OutIter& current, const OutIter& begin,const OutIter& end, PyObject *seq = 0)
+  {
+    return new PySwigIteratorClosed_T<OutIter>(current, begin, end, seq);
+  }
+
+  template<typename OutIter>
+  inline PySwigIterator*
+  make_output_iterator(const OutIter& current, PyObject *seq = 0)
+  {
+    return new PySwigIteratorOpen_T<OutIter>(current, seq);
+  }
+}
+
+
+namespace swig
+{
+  template <class T>
+  struct PySequence_Ref
+  {
+    PySequence_Ref(PyObject* seq, int index)
+      : _seq(seq), _index(index)
+    {
+    }
+    
+    operator T () const
+    {
+      swig::PyObject_var item = PySequence_GetItem(_seq, _index);
+      try {
+	return swig::as<T>(item, true);
+      } catch (std::exception& e) {
+	char msg[1024];
+	sprintf(msg, "in sequence element %d ", _index);
+	if (!PyErr_Occurred()) {
+	  SWIG_Error(SWIG_TypeError,  swig::type_name<T>());
+	}
+	SWIG_Python_AddErrorMsg(msg);
+	SWIG_Python_AddErrorMsg(e.what());
+	throw;
+      }
+    }
+
+    PySequence_Ref& operator=(const T& v)
+    {
+      PySequence_SetItem(_seq, _index, swig::from<T>(v));
+      return *this;
+    }
+
+  private:
+    PyObject* _seq;
+    int _index;
+  };
+
+  template <class T>
+  struct PySequence_ArrowProxy
+  {
+    PySequence_ArrowProxy(const T& x): m_value(x) {}
+    const T* operator->() const { return &m_value; }
+    operator const T*() const { return &m_value; }
+    T m_value;
+  };
+
+  template <class T, class Reference >
+  struct PySequence_InputIterator
+  {
+    typedef PySequence_InputIterator<T, Reference > self;
+
+    typedef std::random_access_iterator_tag iterator_category;
+    typedef Reference reference;
+    typedef T value_type;
+    typedef T* pointer;
+    typedef int difference_type;
+
+    PySequence_InputIterator()
+    {
+    }
+
+    PySequence_InputIterator(PyObject* seq, int index)
+      : _seq(seq), _index(index)
+    {
+    }
+
+    reference operator*() const
+    {
+      return reference(_seq, _index);
+    }
+
+    PySequence_ArrowProxy<T>
+    operator->() const {
+      return PySequence_ArrowProxy<T>(operator*());
+    }
+
+    bool operator==(const self& ri) const
+    {
+      return (_index == ri._index) && (_seq == ri._seq);
+    }
+
+    bool operator!=(const self& ri) const
+    {
+      return !(operator==(ri));
+    }
+
+    self& operator ++ ()
+    {
+      ++_index;
+      return *this;
+    }
+
+    self& operator -- ()
+    {
+      --_index;
+      return *this;
+    }
+
+    self& operator += (difference_type n)
+    {
+      _index += n;
+      return *this;
+    }
+
+    self operator +(difference_type n) const
+    {
+      return self(_seq, _index + n);
+    }
+
+    self& operator -= (difference_type n)
+    {
+      _index -= n;
+      return *this;
+    }
+
+    self operator -(difference_type n) const
+    {
+      return self(_seq, _index - n);
+    }
+
+    difference_type operator - (const self& ri) const
+    {
+      return _index - ri._index;
+    }
+
+    bool operator < (const self& ri) const
+    {
+      return _index < ri._index;
+    }
+
+    reference
+    operator[](difference_type n) const
+    {
+      return reference(_seq, _index + n);
+    }
+
+  private:
+    PyObject* _seq;
+    difference_type _index;
+  };
+
+  template <class T>
+  struct PySequence_Cont
+  {
+    typedef PySequence_Ref<T> reference;
+    typedef const PySequence_Ref<T> const_reference;
+    typedef T value_type;
+    typedef T* pointer;
+    typedef int difference_type;
+    typedef int size_type;
+    typedef const pointer const_pointer;
+    typedef PySequence_InputIterator<T, reference> iterator;
+    typedef PySequence_InputIterator<T, const_reference> const_iterator;
+
+    PySequence_Cont(PyObject* seq) : _seq(0)
+    {
+      if (!PySequence_Check(seq)) {
+	throw std::invalid_argument("a sequence is expected");
+      }
+      _seq = seq;
+      Py_INCREF(_seq);
+    }
+
+    ~PySequence_Cont()
+    {
+      if (_seq) Py_DECREF(_seq);
+    }
+
+    size_type size() const
+    {
+      return PySequence_Size(_seq);
+    }
+
+    bool empty() const
+    {
+      return size() == 0;
+    }
+
+    iterator begin()
+    {
+      return iterator(_seq, 0);
+    }
+
+    const_iterator begin() const
+    {
+      return const_iterator(_seq, 0);
+    }
+
+    iterator end()
+    {
+      return iterator(_seq, size());
+    }
+
+    const_iterator end() const
+    {
+      return const_iterator(_seq, size());
+    }
+
+    reference operator[](difference_type n)
+    {
+      return reference(_seq, n);
+    }
+
+    const_reference operator[](difference_type n)  const
+    {
+      return const_reference(_seq, n);
+    }
+
+    bool check(bool set_err = true) const
+    {
+      int s = size();
+      for (int i = 0; i < s; ++i) {
+	swig::PyObject_var item = PySequence_GetItem(_seq, i);
+	if (!swig::check<value_type>(item)) {
+	  if (set_err) {
+	    char msg[1024];
+	    sprintf(msg, "in sequence element %d", i);
+	    SWIG_Error(SWIG_RuntimeError, msg);
+	  }
+	  return false;
+	}
+      }
+      return true;
+    }
+
+  private:
+    PyObject* _seq;
+  };
+
+}
+
+
+SWIGINTERN int
+SWIG_AsVal_std_string (PyObject * obj, std::string *val)
+{
+  std::string* v = (std::string *) 0;
+  int res = SWIG_AsPtr_std_string (obj, &v);
+  if (!SWIG_IsOK(res)) return res;
+  if (v) {
+    if (val) *val = *v;
+    if (SWIG_IsNewObj(res)) {
+      delete v;
+      res = SWIG_DelNewMask(res);
+    }
+    return res;
+  }
+  return SWIG_ERROR;
+}
+
+
+namespace swig {
+  template <> struct traits<std::string > {
+    typedef value_category category;
+    static const char* type_name() { return"std::string"; }
+  };  
+  template <>  struct traits_asval<std::string > {   
+    typedef std::string value_type;
+    static int asval(PyObject *obj, value_type *val) { 
+      return SWIG_AsVal_std_string (obj, val);
+    }
+  };
+  template <>  struct traits_from<std::string > {
+    typedef std::string value_type;
+    static PyObject *from(const value_type& val) {
+      return SWIG_From_std_string  (val);
+    }
+  };
+}
+
+
+namespace swig {
+  template <class PySeq, class Seq>
+  inline void
+  assign(const PySeq& pyseq, Seq* seq) {
+#ifdef SWIG_STD_NOASSIGN_STL
+    typedef typename PySeq::value_type value_type;
+    typename PySeq::const_iterator it = pyseq.begin();
+    for (;it != pyseq.end(); ++it) {
+      seq->insert(seq->end(),(value_type)(*it));
+    }
+#else
+    seq->assign(pyseq.begin(), pyseq.end());
+#endif
+  }
+
+  template <class Seq, class T = typename Seq::value_type >
+  struct traits_asptr_stdseq {
+    typedef Seq sequence;
+    typedef T value_type;
+
+    static int asptr(PyObject *obj, sequence **seq) {
+      if (PySequence_Check(obj)) {
+	try {
+	  PySequence_Cont<value_type> pyseq(obj);
+	  if (seq) {
+	    sequence *pseq = new sequence();
+	    assign(pyseq, pseq);
+	    *seq = pseq;
+	    return SWIG_NEWOBJ;
+	  } else {
+	    return pyseq.check() ? SWIG_OK : SWIG_ERROR;
+	  }
+	} catch (std::exception& e) {
+	  if (seq) {
+	    if (!PyErr_Occurred()) {
+	      PyErr_SetString(PyExc_TypeError, e.what());
+	    }
+	  }
+	  return SWIG_ERROR;
+	}
+      } else {
+	sequence *p;
+	if (SWIG_ConvertPtr(obj,(void**)&p,
+			    swig::type_info<sequence>(),0) == SWIG_OK) {
+	  if (seq) *seq = p;
+	  return SWIG_OLDOBJ;
+	}
+      }
+      return SWIG_ERROR;
+    }
+  };
+
+  template <class Seq, class T = typename Seq::value_type >
+  struct traits_from_stdseq {
+    typedef Seq sequence;
+    typedef T value_type;
+    typedef typename Seq::size_type size_type;
+    typedef typename sequence::const_iterator const_iterator;
+
+    static PyObject *from(const sequence& seq) {
+
+
+
+
+
+
+      size_type size = seq.size();
+      if (size <= (size_type)INT_MAX) {
+	PyObject *obj = PyTuple_New((int)size);
+	int i = 0;
+	for (const_iterator it = seq.begin();
+	     it != seq.end(); ++it, ++i) {
+	  PyTuple_SetItem(obj,i,swig::from<value_type>(*it));
+	}
+	return obj;
+      } else {
+	PyErr_SetString(PyExc_OverflowError,"sequence size not valid in python");
+	return NULL;
+      }
+    }
+  };
+}
+
+
+  namespace swig {
+    template <class T>
+    struct traits_asptr<std::vector<T> >  {
+      static int asptr(PyObject *obj, std::vector<T> **vec) {
+	return traits_asptr_stdseq<std::vector<T> >::asptr(obj, vec);
+      }
+    };
+    
+    template <class T>
+    struct traits_from<std::vector<T> > {
+      static PyObject *from(const std::vector<T>& vec) {
+	return traits_from_stdseq<std::vector<T> >::from(vec);
+      }
+    };
+  }
+
+
+      namespace swig {
+	template <>  struct traits<std::vector<std::string, std::allocator<std::string > > > {
+	  typedef pointer_category category;
+	  static const char* type_name() {
+	    return "std::vector<" "std::string" "," "std::allocator<std::string >" " >";
+	  }
+	};
+      }
+    
+SWIGINTERN swig::PySwigIterator *std_vector_Sl_std_string_Sg__iterator(std::vector<std::string > *self,PyObject **PYTHON_SELF){
+      return swig::make_output_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
+    }
+SWIGINTERN bool std_vector_Sl_std_string_Sg____nonzero__(std::vector<std::string > const *self){
+      return !(self->empty());
+    }
+SWIGINTERN std::vector<std::string >::size_type std_vector_Sl_std_string_Sg____len__(std::vector<std::string > const *self){
+      return self->size();
+    }
+
+SWIGINTERNINLINE PyObject* 
+SWIG_From_unsigned_SS_long  (unsigned long value)
+{
+  return (value > LONG_MAX) ?
+    PyLong_FromUnsignedLong(value) : PyInt_FromLong(static_cast< long >(value)); 
+}
+
+
+SWIGINTERNINLINE PyObject *
+SWIG_From_size_t  (size_t value)
+{    
+  return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
+}
+
+SWIGINTERN std::vector<std::string >::value_type std_vector_Sl_std_string_Sg__pop(std::vector<std::string > *self){
+      if (self->size() == 0)
+	throw std::out_of_range("pop from empty container");
+      std::vector<std::string,std::allocator<std::string > >::value_type x = self->back();
+      self->pop_back();
+      return x;
+    }
+SWIGINTERN std::vector<std::string,std::allocator<std::string > > *std_vector_Sl_std_string_Sg____getslice__(std::vector<std::string > *self,std::vector<std::string >::difference_type i,std::vector<std::string >::difference_type j){
+      return swig::getslice(self, i, j);
+    }
+SWIGINTERN void std_vector_Sl_std_string_Sg____setslice__(std::vector<std::string > *self,std::vector<std::string >::difference_type i,std::vector<std::string >::difference_type j,std::vector<std::string,std::allocator<std::string > > const &v){
+      swig::setslice(self, i, j, v);
+    }
+SWIGINTERN void std_vector_Sl_std_string_Sg____delslice__(std::vector<std::string > *self,std::vector<std::string >::difference_type i,std::vector<std::string >::difference_type j){
+      swig::delslice(self, i, j);
+    }
+SWIGINTERN void std_vector_Sl_std_string_Sg____delitem__(std::vector<std::string > *self,std::vector<std::string >::difference_type i){
+      self->erase(swig::getpos(self,i));
+    }
+SWIGINTERN std::vector<std::string >::value_type const &std_vector_Sl_std_string_Sg____getitem__(std::vector<std::string > const *self,std::vector<std::string >::difference_type i){
+      return *(swig::cgetpos(self, i));
+    }
+SWIGINTERN void std_vector_Sl_std_string_Sg____setitem__(std::vector<std::string > *self,std::vector<std::string >::difference_type i,std::vector<std::string >::value_type const &x){
+      *(swig::getpos(self,i)) = x;
+    }
+SWIGINTERN void std_vector_Sl_std_string_Sg__append(std::vector<std::string > *self,std::vector<std::string >::value_type const &x){
+      self->push_back(x);
+    }
+#ifdef __cplusplus
+extern "C" {
+#endif
+SWIGINTERN PyObject *_wrap_GameAction_clean(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)":GameAction_clean")) SWIG_fail;
+  GameAction::clean();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_system(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  double arg2 ;
+  double arg3 ;
+  int res1 = SWIG_OLDOBJ ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOO:GameAction_add_system",&obj0,&obj1,&obj2)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameAction_add_system" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_system" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GameAction_add_system" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GameAction_add_system" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  GameAction::add_system((std::string const &)*arg1,arg2,arg3);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_planet(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  std::string *arg2 = 0 ;
+  double arg3 ;
+  double arg4 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  int res2 = SWIG_OLDOBJ ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOO:GameAction_add_planet",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameAction_add_planet" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_planet" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GameAction_add_planet" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_planet" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  ecode3 = SWIG_AsVal_double(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GameAction_add_planet" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "GameAction_add_planet" "', argument " "4"" of type '" "double""'");
+  } 
+  arg4 = static_cast< double >(val4);
+  result = (int)GameAction::add_planet((std::string const &)*arg1,(std::string const &)*arg2,arg3,arg4);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_orbiter_station(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  std::string *arg2 = 0 ;
+  std::string *arg3 = 0 ;
+  std::string *arg4 = 0 ;
+  std::string *arg5 = 0 ;
+  std::string *arg6 = 0 ;
+  std::string *arg7 = 0 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  int res2 = SWIG_OLDOBJ ;
+  int res3 = SWIG_OLDOBJ ;
+  int res4 = SWIG_OLDOBJ ;
+  int res5 = SWIG_OLDOBJ ;
+  int res6 = SWIG_OLDOBJ ;
+  int res7 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  PyObject * obj4 = 0 ;
+  PyObject * obj5 = 0 ;
+  PyObject * obj6 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:GameAction_add_orbiter_station",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameAction_add_orbiter_station" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_orbiter_station" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GameAction_add_orbiter_station" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_orbiter_station" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res3 = SWIG_AsPtr_std_string(obj2, &ptr);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GameAction_add_orbiter_station" "', argument " "3"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_orbiter_station" "', argument " "3"" of type '" "std::string const &""'"); 
+    }
+    arg3 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res4 = SWIG_AsPtr_std_string(obj3, &ptr);
+    if (!SWIG_IsOK(res4)) {
+      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "GameAction_add_orbiter_station" "', argument " "4"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_orbiter_station" "', argument " "4"" of type '" "std::string const &""'"); 
+    }
+    arg4 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res5 = SWIG_AsPtr_std_string(obj4, &ptr);
+    if (!SWIG_IsOK(res5)) {
+      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "GameAction_add_orbiter_station" "', argument " "5"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_orbiter_station" "', argument " "5"" of type '" "std::string const &""'"); 
+    }
+    arg5 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res6 = SWIG_AsPtr_std_string(obj5, &ptr);
+    if (!SWIG_IsOK(res6)) {
+      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "GameAction_add_orbiter_station" "', argument " "6"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_orbiter_station" "', argument " "6"" of type '" "std::string const &""'"); 
+    }
+    arg6 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res7 = SWIG_AsPtr_std_string(obj6, &ptr);
+    if (!SWIG_IsOK(res7)) {
+      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "GameAction_add_orbiter_station" "', argument " "7"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_orbiter_station" "', argument " "7"" of type '" "std::string const &""'"); 
+    }
+    arg7 = ptr;
+  }
+  result = (int)GameAction::add_orbiter_station((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,(std::string const &)*arg6,(std::string const &)*arg7);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  if (SWIG_IsNewObj(res5)) delete arg5;
+  if (SWIG_IsNewObj(res6)) delete arg6;
+  if (SWIG_IsNewObj(res7)) delete arg7;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  if (SWIG_IsNewObj(res5)) delete arg5;
+  if (SWIG_IsNewObj(res6)) delete arg6;
+  if (SWIG_IsNewObj(res7)) delete arg7;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_asteroid__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  double arg2 ;
+  double arg3 ;
+  double arg4 ;
+  double arg5 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  double val5 ;
+  int ecode5 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  PyObject * obj4 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOOO:GameAction_add_asteroid",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameAction_add_asteroid" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_asteroid" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GameAction_add_asteroid" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GameAction_add_asteroid" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "GameAction_add_asteroid" "', argument " "4"" of type '" "double""'");
+  } 
+  arg4 = static_cast< double >(val4);
+  ecode5 = SWIG_AsVal_double(obj4, &val5);
+  if (!SWIG_IsOK(ecode5)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "GameAction_add_asteroid" "', argument " "5"" of type '" "double""'");
+  } 
+  arg5 = static_cast< double >(val5);
+  result = (int)GameAction::add_asteroid((std::string const &)*arg1,arg2,arg3,arg4,arg5);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_asteroid__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  double arg2 ;
+  double arg3 ;
+  double arg4 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOO:GameAction_add_asteroid",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameAction_add_asteroid" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_asteroid" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GameAction_add_asteroid" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GameAction_add_asteroid" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "GameAction_add_asteroid" "', argument " "4"" of type '" "double""'");
+  } 
+  arg4 = static_cast< double >(val4);
+  result = (int)GameAction::add_asteroid((std::string const &)*arg1,arg2,arg3,arg4);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_asteroid__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  double arg2 ;
+  double arg3 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOO:GameAction_add_asteroid",&obj0,&obj1,&obj2)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameAction_add_asteroid" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_asteroid" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GameAction_add_asteroid" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GameAction_add_asteroid" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  result = (int)GameAction::add_asteroid((std::string const &)*arg1,arg2,arg3);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_asteroid__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  double arg2 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  double val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:GameAction_add_asteroid",&obj0,&obj1)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameAction_add_asteroid" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_asteroid" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GameAction_add_asteroid" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  result = (int)GameAction::add_asteroid((std::string const &)*arg1,arg2);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_asteroid__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:GameAction_add_asteroid",&obj0)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameAction_add_asteroid" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_asteroid" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  result = (int)GameAction::add_asteroid((std::string const &)*arg1);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_asteroid(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[6];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii < argc) && (ii < 5); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 1) {
+    int _v;
+    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_GameAction_add_asteroid__SWIG_4(self, args);
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_GameAction_add_asteroid__SWIG_3(self, args);
+      }
+    }
+  }
+  if (argc == 3) {
+    int _v;
+    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_double(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          return _wrap_GameAction_add_asteroid__SWIG_2(self, args);
+        }
+      }
+    }
+  }
+  if (argc == 4) {
+    int _v;
+    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_double(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          {
+            int res = SWIG_AsVal_double(argv[3], NULL);
+            _v = SWIG_CheckState(res);
+          }
+          if (_v) {
+            return _wrap_GameAction_add_asteroid__SWIG_1(self, args);
+          }
+        }
+      }
+    }
+  }
+  if (argc == 5) {
+    int _v;
+    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_double(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          {
+            int res = SWIG_AsVal_double(argv[3], NULL);
+            _v = SWIG_CheckState(res);
+          }
+          if (_v) {
+            {
+              int res = SWIG_AsVal_double(argv[4], NULL);
+              _v = SWIG_CheckState(res);
+            }
+            if (_v) {
+              return _wrap_GameAction_add_asteroid__SWIG_0(self, args);
+            }
+          }
+        }
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,"No matching function for overloaded 'GameAction_add_asteroid'");
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_player(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  std::string *arg2 = 0 ;
+  double arg3 ;
+  double arg4 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  int res2 = SWIG_OLDOBJ ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOO:GameAction_add_player",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameAction_add_player" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_player" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GameAction_add_player" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_player" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  ecode3 = SWIG_AsVal_double(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GameAction_add_player" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "GameAction_add_player" "', argument " "4"" of type '" "double""'");
+  } 
+  arg4 = static_cast< double >(val4);
+  result = (int)GameAction::add_player((std::string const &)*arg1,(std::string const &)*arg2,arg3,arg4);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_ship(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  std::string *arg2 = 0 ;
+  double arg3 ;
+  double arg4 ;
+  double arg5 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  int res2 = SWIG_OLDOBJ ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  double val5 ;
+  int ecode5 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  PyObject * obj4 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOOO:GameAction_add_ship",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameAction_add_ship" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_ship" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GameAction_add_ship" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_ship" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  ecode3 = SWIG_AsVal_double(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GameAction_add_ship" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "GameAction_add_ship" "', argument " "4"" of type '" "double""'");
+  } 
+  arg4 = static_cast< double >(val4);
+  ecode5 = SWIG_AsVal_double(obj4, &val5);
+  if (!SWIG_IsOK(ecode5)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "GameAction_add_ship" "', argument " "5"" of type '" "double""'");
+  } 
+  arg5 = static_cast< double >(val5);
+  result = (int)GameAction::add_ship((std::string const &)*arg1,(std::string const &)*arg2,arg3,arg4,arg5);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_save_flag__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  std::string *arg2 = 0 ;
+  int res1 = SWIG_OLDOBJ ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:GameAction_save_flag",&obj0,&obj1)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameAction_save_flag" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_save_flag" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GameAction_save_flag" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_save_flag" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  GameAction::save_flag((std::string const &)*arg1,(std::string const &)*arg2);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_get_string_flag(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  std::string result;
+  int res1 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:GameAction_get_string_flag",&obj0)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameAction_get_string_flag" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_get_string_flag" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  result = GameAction::get_string_flag((std::string const &)*arg1);
+  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_save_flag__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  double arg2 ;
+  int res1 = SWIG_OLDOBJ ;
+  double val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:GameAction_save_flag",&obj0,&obj1)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameAction_save_flag" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_save_flag" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GameAction_save_flag" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  GameAction::save_flag((std::string const &)*arg1,arg2);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_save_flag(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[3];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 2) {
+    int _v;
+    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_GameAction_save_flag__SWIG_1(self, args);
+      }
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_GameAction_save_flag__SWIG_0(self, args);
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,"No matching function for overloaded 'GameAction_save_flag'");
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_get_double_flag(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  double result;
+  int res1 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:GameAction_get_double_flag",&obj0)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameAction_get_double_flag" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_get_double_flag" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  result = (double)GameAction::get_double_flag((std::string const &)*arg1);
+  resultobj = SWIG_From_double(static_cast< double >(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_get_player_ship_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double result;
+  
+  if (!PyArg_ParseTuple(args,(char *)":GameAction_get_player_ship_id")) SWIG_fail;
+  result = (double)GameAction::get_player_ship_id();
+  resultobj = SWIG_From_double(static_cast< double >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_get_player_star_system(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string result;
+  
+  if (!PyArg_ParseTuple(args,(char *)":GameAction_get_player_star_system")) SWIG_fail;
+  result = GameAction::get_player_star_system();
+  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_set_target(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:GameAction_set_target",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GameAction_set_target" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GameAction_set_target" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  GameAction::set_target(arg1,arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_disable_weapon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:GameAction_disable_weapon",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GameAction_disable_weapon" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  GameAction::disable_weapon(arg1);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_enable_weapon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:GameAction_enable_weapon",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GameAction_enable_weapon" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  GameAction::enable_weapon(arg1);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_go_to_point(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  double arg4 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOO:GameAction_go_to_point",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GameAction_go_to_point" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GameAction_go_to_point" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GameAction_go_to_point" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "GameAction_go_to_point" "', argument " "4"" of type '" "double""'");
+  } 
+  arg4 = static_cast< double >(val4);
+  result = (int)GameAction::go_to_point(arg1,arg2,arg3,arg4);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_go_to_location(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOO:GameAction_go_to_location",&obj0,&obj1,&obj2)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GameAction_go_to_location" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GameAction_go_to_location" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GameAction_go_to_location" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  result = (int)GameAction::go_to_location(arg1,arg2,arg3);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_guard_location(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOO:GameAction_guard_location",&obj0,&obj1,&obj2)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GameAction_guard_location" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GameAction_guard_location" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GameAction_guard_location" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  result = (int)GameAction::guard_location(arg1,arg2,arg3);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_guard_point(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  double arg4 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOO:GameAction_guard_point",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GameAction_guard_point" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GameAction_guard_point" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GameAction_guard_point" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "GameAction_guard_point" "', argument " "4"" of type '" "double""'");
+  } 
+  arg4 = static_cast< double >(val4);
+  result = (int)GameAction::guard_point(arg1,arg2,arg3,arg4);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_set_ship_team(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:GameAction_set_ship_team",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GameAction_set_ship_team" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GameAction_set_ship_team" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  GameAction::set_ship_team(arg1,arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_get_enemy_team(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int result;
+  
+  if (!PyArg_ParseTuple(args,(char *)":GameAction_get_enemy_team")) SWIG_fail;
+  result = (int)GameAction::get_enemy_team();
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_get_player_team(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int result;
+  
+  if (!PyArg_ParseTuple(args,(char *)":GameAction_get_player_team")) SWIG_fail;
+  result = (int)GameAction::get_player_team();
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_remove_location(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:GameAction_remove_location",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GameAction_remove_location" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  GameAction::remove_location(arg1);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_set_crew(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:GameAction_set_crew",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GameAction_set_crew" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GameAction_set_crew" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  GameAction::set_crew(arg1,arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_get_location_pos_x(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:GameAction_get_location_pos_x",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GameAction_get_location_pos_x" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  result = (int)GameAction::get_location_pos_x(arg1);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_get_location_pos_y(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:GameAction_get_location_pos_y",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GameAction_get_location_pos_y" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  result = (int)GameAction::get_location_pos_y(arg1);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_exist(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  bool result;
+  double val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:GameAction_exist",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "GameAction_exist" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  result = (bool)GameAction::exist(arg1);
+  resultobj = SWIG_From_bool(static_cast< bool >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_end_game(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)":GameAction_end_game")) SWIG_fail;
+  GameAction::end_game();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_scroll_text(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string,std::allocator<std::string > > *arg1 = 0 ;
+  std::string *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:GameAction_scroll_text",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t,  0  | 0);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameAction_scroll_text" "', argument " "1"" of type '" "std::vector<std::string,std::allocator<std::string > > const &""'"); 
+  }
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_scroll_text" "', argument " "1"" of type '" "std::vector<std::string,std::allocator<std::string > > const &""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string,std::allocator<std::string > > * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GameAction_scroll_text" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_scroll_text" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  GameAction::scroll_text((std::vector<std::string,std::allocator<std::string > > const &)*arg1,(std::string const &)*arg2);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_print_message(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  int arg2 ;
+  int res1 = SWIG_OLDOBJ ;
+  int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:GameAction_print_message",&obj0,&obj1)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameAction_print_message" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_print_message" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  ecode2 = SWIG_AsVal_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GameAction_print_message" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  GameAction::print_message((std::string const &)*arg1,arg2);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_set_camera_mode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  int res1 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:GameAction_set_camera_mode",&obj0)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameAction_set_camera_mode" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_set_camera_mode" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  GameAction::set_camera_mode((std::string const &)*arg1);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_GameAction(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  GameAction *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":new_GameAction")) SWIG_fail;
+  result = (GameAction *)new GameAction();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GameAction, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_GameAction(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  GameAction *arg1 = (GameAction *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:delete_GameAction",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GameAction, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GameAction" "', argument " "1"" of type '" "GameAction *""'"); 
+  }
+  arg1 = reinterpret_cast< GameAction * >(argp1);
+  delete arg1;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *GameAction_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)"O|swigregister", &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_GameAction, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_DialogApi_startDialog(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)":DialogApi_startDialog")) SWIG_fail;
+  DialogApi::startDialog();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_DialogApi_endDialog(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)":DialogApi_endDialog")) SWIG_fail;
+  DialogApi::endDialog();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_DialogApi_askPlayer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string,std::allocator<std::string > > *arg1 = 0 ;
+  int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:DialogApi_askPlayer",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t,  0  | 0);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DialogApi_askPlayer" "', argument " "1"" of type '" "std::vector<std::string,std::allocator<std::string > > const &""'"); 
+  }
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DialogApi_askPlayer" "', argument " "1"" of type '" "std::vector<std::string,std::allocator<std::string > > const &""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string,std::allocator<std::string > > * >(argp1);
+  result = (int)DialogApi::askPlayer((std::vector<std::string,std::allocator<std::string > > const &)*arg1);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_DialogApi_showText(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  int arg2 ;
+  int arg3 ;
+  int arg4 ;
+  int res1 = SWIG_OLDOBJ ;
+  int val2 ;
+  int ecode2 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
+  int val4 ;
+  int ecode4 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOO:DialogApi_showText",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DialogApi_showText" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DialogApi_showText" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  ecode2 = SWIG_AsVal_int(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DialogApi_showText" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  ecode3 = SWIG_AsVal_int(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DialogApi_showText" "', argument " "3"" of type '" "int""'");
+  } 
+  arg3 = static_cast< int >(val3);
+  ecode4 = SWIG_AsVal_int(obj3, &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DialogApi_showText" "', argument " "4"" of type '" "int""'");
+  } 
+  arg4 = static_cast< int >(val4);
+  DialogApi::showText((std::string const &)*arg1,arg2,arg3,arg4);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_DialogApi_showAlienPicture(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  int res1 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:DialogApi_showAlienPicture",&obj0)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DialogApi_showAlienPicture" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DialogApi_showAlienPicture" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  DialogApi::showAlienPicture((std::string const &)*arg1);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_DialogApi(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  DialogApi *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":new_DialogApi")) SWIG_fail;
+  result = (DialogApi *)new DialogApi();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DialogApi, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_DialogApi(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  DialogApi *arg1 = (DialogApi *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:delete_DialogApi",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_DialogApi, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DialogApi" "', argument " "1"" of type '" "DialogApi *""'"); 
+  }
+  arg1 = reinterpret_cast< DialogApi * >(argp1);
+  delete arg1;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *DialogApi_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)"O|swigregister", &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_DialogApi, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_GameConfig_SetGameDirectory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  int res1 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:GameConfig_SetGameDirectory",&obj0)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameConfig_SetGameDirectory" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameConfig_SetGameDirectory" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  GameConfig::SetGameDirectory((std::string const &)*arg1);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameConfig_GetGameDirectory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string result;
+  
+  if (!PyArg_ParseTuple(args,(char *)":GameConfig_GetGameDirectory")) SWIG_fail;
+  result = GameConfig::GetGameDirectory();
+  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameConfig_GetAbsolutePath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  std::string result;
+  int res1 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:GameConfig_GetAbsolutePath",&obj0)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GameConfig_GetAbsolutePath" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameConfig_GetAbsolutePath" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  result = GameConfig::GetAbsolutePath((std::string const &)*arg1);
+  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_GameConfig(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  GameConfig *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":new_GameConfig")) SWIG_fail;
+  result = (GameConfig *)new GameConfig();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GameConfig, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_GameConfig(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  GameConfig *arg1 = (GameConfig *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:delete_GameConfig",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_GameConfig, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GameConfig" "', argument " "1"" of type '" "GameConfig *""'"); 
+  }
+  arg1 = reinterpret_cast< GameConfig * >(argp1);
+  delete arg1;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *GameConfig_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)"O|swigregister", &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_GameConfig, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_EventManager_clean(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)":EventManager_clean")) SWIG_fail;
+  EventManager::clean();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_setSingleTimeEvent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  std::string *arg2 = 0 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:EventManager_setSingleTimeEvent",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "EventManager_setSingleTimeEvent" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EventManager_setSingleTimeEvent" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EventManager_setSingleTimeEvent" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  result = (int)EventManager::setSingleTimeEvent(arg1,(std::string const &)*arg2);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_setRepeatableTimeEvent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  std::string *arg2 = 0 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:EventManager_setRepeatableTimeEvent",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "EventManager_setRepeatableTimeEvent" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EventManager_setRepeatableTimeEvent" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EventManager_setRepeatableTimeEvent" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  result = (int)EventManager::setRepeatableTimeEvent(arg1,(std::string const &)*arg2);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_disableEvent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:EventManager_disableEvent",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "EventManager_disableEvent" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  EventManager::disableEvent(arg1);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_shipDeathById(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  std::string *arg2 = 0 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:EventManager_shipDeathById",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "EventManager_shipDeathById" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EventManager_shipDeathById" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EventManager_shipDeathById" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  result = (int)EventManager::shipDeathById(arg1,(std::string const &)*arg2);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_shipDeathByType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  std::string *arg2 = 0 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:EventManager_shipDeathByType",&obj0,&obj1)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventManager_shipDeathByType" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EventManager_shipDeathByType" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EventManager_shipDeathByType" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EventManager_shipDeathByType" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  result = (int)EventManager::shipDeathByType((std::string const &)*arg1,(std::string const &)*arg2);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_distanceMoreThen__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  double arg4 ;
+  std::string *arg5 = 0 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  int res5 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  PyObject * obj4 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOOO:EventManager_distanceMoreThen",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "EventManager_distanceMoreThen" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EventManager_distanceMoreThen" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "EventManager_distanceMoreThen" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "EventManager_distanceMoreThen" "', argument " "4"" of type '" "double""'");
+  } 
+  arg4 = static_cast< double >(val4);
+  {
+    std::string *ptr = (std::string *)0;
+    res5 = SWIG_AsPtr_std_string(obj4, &ptr);
+    if (!SWIG_IsOK(res5)) {
+      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "EventManager_distanceMoreThen" "', argument " "5"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EventManager_distanceMoreThen" "', argument " "5"" of type '" "std::string const &""'"); 
+    }
+    arg5 = ptr;
+  }
+  result = (int)EventManager::distanceMoreThen(arg1,arg2,arg3,arg4,(std::string const &)*arg5);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (SWIG_IsNewObj(res5)) delete arg5;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res5)) delete arg5;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_distanceLessThen__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  double arg4 ;
+  std::string *arg5 = 0 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  int res5 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  PyObject * obj4 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOOO:EventManager_distanceLessThen",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "EventManager_distanceLessThen" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EventManager_distanceLessThen" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "EventManager_distanceLessThen" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "EventManager_distanceLessThen" "', argument " "4"" of type '" "double""'");
+  } 
+  arg4 = static_cast< double >(val4);
+  {
+    std::string *ptr = (std::string *)0;
+    res5 = SWIG_AsPtr_std_string(obj4, &ptr);
+    if (!SWIG_IsOK(res5)) {
+      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "EventManager_distanceLessThen" "', argument " "5"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EventManager_distanceLessThen" "', argument " "5"" of type '" "std::string const &""'"); 
+    }
+    arg5 = ptr;
+  }
+  result = (int)EventManager::distanceLessThen(arg1,arg2,arg3,arg4,(std::string const &)*arg5);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (SWIG_IsNewObj(res5)) delete arg5;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res5)) delete arg5;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_distanceMoreThen__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  std::string *arg4 = 0 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  int res4 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOO:EventManager_distanceMoreThen",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "EventManager_distanceMoreThen" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EventManager_distanceMoreThen" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "EventManager_distanceMoreThen" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  {
+    std::string *ptr = (std::string *)0;
+    res4 = SWIG_AsPtr_std_string(obj3, &ptr);
+    if (!SWIG_IsOK(res4)) {
+      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "EventManager_distanceMoreThen" "', argument " "4"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EventManager_distanceMoreThen" "', argument " "4"" of type '" "std::string const &""'"); 
+    }
+    arg4 = ptr;
+  }
+  result = (int)EventManager::distanceMoreThen(arg1,arg2,arg3,(std::string const &)*arg4);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_distanceMoreThen(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[6];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii < argc) && (ii < 5); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 4) {
+    int _v;
+    {
+      int res = SWIG_AsVal_double(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_double(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
+          _v = SWIG_CheckState(res);
+          if (_v) {
+            return _wrap_EventManager_distanceMoreThen__SWIG_1(self, args);
+          }
+        }
+      }
+    }
+  }
+  if (argc == 5) {
+    int _v;
+    {
+      int res = SWIG_AsVal_double(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_double(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          {
+            int res = SWIG_AsVal_double(argv[3], NULL);
+            _v = SWIG_CheckState(res);
+          }
+          if (_v) {
+            int res = SWIG_AsPtr_std_string(argv[4], (std::string**)(0));
+            _v = SWIG_CheckState(res);
+            if (_v) {
+              return _wrap_EventManager_distanceMoreThen__SWIG_0(self, args);
+            }
+          }
+        }
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,"No matching function for overloaded 'EventManager_distanceMoreThen'");
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_distanceLessThen__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  std::string *arg4 = 0 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  int res4 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOO:EventManager_distanceLessThen",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "EventManager_distanceLessThen" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EventManager_distanceLessThen" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "EventManager_distanceLessThen" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  {
+    std::string *ptr = (std::string *)0;
+    res4 = SWIG_AsPtr_std_string(obj3, &ptr);
+    if (!SWIG_IsOK(res4)) {
+      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "EventManager_distanceLessThen" "', argument " "4"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EventManager_distanceLessThen" "', argument " "4"" of type '" "std::string const &""'"); 
+    }
+    arg4 = ptr;
+  }
+  result = (int)EventManager::distanceLessThen(arg1,arg2,arg3,(std::string const &)*arg4);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_distanceLessThen(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[6];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii < argc) && (ii < 5); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 4) {
+    int _v;
+    {
+      int res = SWIG_AsVal_double(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_double(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
+          _v = SWIG_CheckState(res);
+          if (_v) {
+            return _wrap_EventManager_distanceLessThen__SWIG_1(self, args);
+          }
+        }
+      }
+    }
+  }
+  if (argc == 5) {
+    int _v;
+    {
+      int res = SWIG_AsVal_double(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_double(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          {
+            int res = SWIG_AsVal_double(argv[3], NULL);
+            _v = SWIG_CheckState(res);
+          }
+          if (_v) {
+            int res = SWIG_AsPtr_std_string(argv[4], (std::string**)(0));
+            _v = SWIG_CheckState(res);
+            if (_v) {
+              return _wrap_EventManager_distanceLessThen__SWIG_0(self, args);
+            }
+          }
+        }
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,"No matching function for overloaded 'EventManager_distanceLessThen'");
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_jumpToSystem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  std::string *arg2 = 0 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:EventManager_jumpToSystem",&obj0,&obj1)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventManager_jumpToSystem" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EventManager_jumpToSystem" "', argument " "1"" of type '" "std::string const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EventManager_jumpToSystem" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EventManager_jumpToSystem" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  result = (int)EventManager::jumpToSystem((std::string const &)*arg1,(std::string const &)*arg2);
+  resultobj = SWIG_From_int(static_cast< int >(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_AddEventCondition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  std::string *arg2 = 0 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:EventManager_AddEventCondition",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "EventManager_AddEventCondition" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EventManager_AddEventCondition" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EventManager_AddEventCondition" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  EventManager::AddEventCondition(arg1,(std::string const &)*arg2);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_EventManager(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  EventManager *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":new_EventManager")) SWIG_fail;
+  result = (EventManager *)new EventManager();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventManager, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_EventManager(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  EventManager *arg1 = (EventManager *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:delete_EventManager",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventManager, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EventManager" "', argument " "1"" of type '" "EventManager *""'"); 
+  }
+  arg1 = reinterpret_cast< EventManager * >(argp1);
+  delete arg1;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *EventManager_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)"O|swigregister", &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_EventManager, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_new_SoundSystem__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  bool arg1 ;
+  SoundSystem *result = 0 ;
+  bool val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:new_SoundSystem",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_bool(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SoundSystem" "', argument " "1"" of type '" "bool""'");
+  } 
+  arg1 = static_cast< bool >(val1);
+  result = (SoundSystem *)new SoundSystem(arg1);
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SoundSystem, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_SoundSystem__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":new_SoundSystem")) SWIG_fail;
+  result = (SoundSystem *)new SoundSystem();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SoundSystem, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_SoundSystem(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[2];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 0) {
+    return _wrap_new_SoundSystem__SWIG_1(self, args);
+  }
+  if (argc == 1) {
+    int _v;
+    {
+      int res = SWIG_AsVal_bool(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      return _wrap_new_SoundSystem__SWIG_0(self, args);
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,"No matching function for overloaded 'new_SoundSystem'");
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_SoundSystem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:delete_SoundSystem",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SoundSystem, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SoundSystem" "', argument " "1"" of type '" "SoundSystem *""'"); 
+  }
+  arg1 = reinterpret_cast< SoundSystem * >(argp1);
+  delete arg1;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_play_music__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  std::string arg2 ;
+  int arg3 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOO:SoundSystem_play_music",&obj0,&obj1,&obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SoundSystem_play_music" "', argument " "1"" of type '" "SoundSystem *""'"); 
+  }
+  arg1 = reinterpret_cast< SoundSystem * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    int res = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res) || !ptr) {
+      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SoundSystem_play_music" "', argument " "2"" of type '" "std::string const""'"); 
+    }
+    arg2 = *ptr;
+    if (SWIG_IsNewObj(res)) delete ptr;
+  }
+  ecode3 = SWIG_AsVal_int(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SoundSystem_play_music" "', argument " "3"" of type '" "int""'");
+  } 
+  arg3 = static_cast< int >(val3);
+  (arg1)->play_music(arg2,arg3);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_play_music__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  std::string arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:SoundSystem_play_music",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SoundSystem_play_music" "', argument " "1"" of type '" "SoundSystem *""'"); 
+  }
+  arg1 = reinterpret_cast< SoundSystem * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    int res = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res) || !ptr) {
+      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SoundSystem_play_music" "', argument " "2"" of type '" "std::string const""'"); 
+    }
+    arg2 = *ptr;
+    if (SWIG_IsNewObj(res)) delete ptr;
+  }
+  (arg1)->play_music(arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_play_music(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[4];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SoundSystem, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_SoundSystem_play_music__SWIG_1(self, args);
+      }
+    }
+  }
+  if (argc == 3) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SoundSystem, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        {
+          int res = SWIG_AsVal_int(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          return _wrap_SoundSystem_play_music__SWIG_0(self, args);
+        }
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,"No matching function for overloaded 'SoundSystem_play_music'");
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_play_sound__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  std::string arg2 ;
+  double arg3 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOO:SoundSystem_play_sound",&obj0,&obj1,&obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SoundSystem_play_sound" "', argument " "1"" of type '" "SoundSystem *""'"); 
+  }
+  arg1 = reinterpret_cast< SoundSystem * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    int res = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res) || !ptr) {
+      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SoundSystem_play_sound" "', argument " "2"" of type '" "std::string const""'"); 
+    }
+    arg2 = *ptr;
+    if (SWIG_IsNewObj(res)) delete ptr;
+  }
+  ecode3 = SWIG_AsVal_double(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SoundSystem_play_sound" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  (arg1)->play_sound(arg2,arg3);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_play_sound__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  std::string arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:SoundSystem_play_sound",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SoundSystem_play_sound" "', argument " "1"" of type '" "SoundSystem *""'"); 
+  }
+  arg1 = reinterpret_cast< SoundSystem * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    int res = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res) || !ptr) {
+      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SoundSystem_play_sound" "', argument " "2"" of type '" "std::string const""'"); 
+    }
+    arg2 = *ptr;
+    if (SWIG_IsNewObj(res)) delete ptr;
+  }
+  (arg1)->play_sound(arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_play_sound(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[4];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SoundSystem, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_SoundSystem_play_sound__SWIG_1(self, args);
+      }
+    }
+  }
+  if (argc == 3) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SoundSystem, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        {
+          int res = SWIG_AsVal_double(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          return _wrap_SoundSystem_play_sound__SWIG_0(self, args);
+        }
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,"No matching function for overloaded 'SoundSystem_play_sound'");
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_stop_sound(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  std::string arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:SoundSystem_stop_sound",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SoundSystem_stop_sound" "', argument " "1"" of type '" "SoundSystem *""'"); 
+  }
+  arg1 = reinterpret_cast< SoundSystem * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    int res = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res) || !ptr) {
+      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SoundSystem_stop_sound" "', argument " "2"" of type '" "std::string const""'"); 
+    }
+    arg2 = *ptr;
+    if (SWIG_IsNewObj(res)) delete ptr;
+  }
+  (arg1)->stop_sound(arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_set_music_volume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  double arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:SoundSystem_set_music_volume",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SoundSystem_set_music_volume" "', argument " "1"" of type '" "SoundSystem *""'"); 
+  }
+  arg1 = reinterpret_cast< SoundSystem * >(argp1);
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SoundSystem_set_music_volume" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  (arg1)->set_music_volume(arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_set_sound_volume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  double arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:SoundSystem_set_sound_volume",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SoundSystem_set_sound_volume" "', argument " "1"" of type '" "SoundSystem *""'"); 
+  }
+  arg1 = reinterpret_cast< SoundSystem * >(argp1);
+  ecode2 = SWIG_AsVal_double(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SoundSystem_set_sound_volume" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  (arg1)->set_sound_volume(arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_load_music_volume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  double result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:SoundSystem_load_music_volume",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SoundSystem_load_music_volume" "', argument " "1"" of type '" "SoundSystem *""'"); 
+  }
+  arg1 = reinterpret_cast< SoundSystem * >(argp1);
+  result = (double)(arg1)->load_music_volume();
+  resultobj = SWIG_From_double(static_cast< double >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_load_sound_volume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  double result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:SoundSystem_load_sound_volume",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SoundSystem_load_sound_volume" "', argument " "1"" of type '" "SoundSystem *""'"); 
+  }
+  arg1 = reinterpret_cast< SoundSystem * >(argp1);
+  result = (double)(arg1)->load_sound_volume();
+  resultobj = SWIG_From_double(static_cast< double >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_playing_music(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  bool result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:SoundSystem_playing_music",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SoundSystem_playing_music" "', argument " "1"" of type '" "SoundSystem *""'"); 
+  }
+  arg1 = reinterpret_cast< SoundSystem * >(argp1);
+  result = (bool)(arg1)->playing_music();
+  resultobj = SWIG_From_bool(static_cast< bool >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_playing_music_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  std::string result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:SoundSystem_playing_music_file",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SoundSystem_playing_music_file" "', argument " "1"" of type '" "SoundSystem *""'"); 
+  }
+  arg1 = reinterpret_cast< SoundSystem * >(argp1);
+  result = (arg1)->playing_music_file();
+  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *SoundSystem_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)"O|swigregister", &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_SoundSystem, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN int tw_sound_set(PyObject *_val) {
+  {
+    void *argp = 0;
+    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_SoundSystem,  0 );  
+    if (!SWIG_IsOK(res)) {
+      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""tw_sound""' of type '""SoundSystem *""'");
+    }
+    tw_sound = reinterpret_cast< SoundSystem * >(argp);
+  }
+  return 0;
+fail:
+  return 1;
+}
+
+
+SWIGINTERN PyObject *tw_sound_get(void) {
+  PyObject *pyobj = 0;
+  
+  pyobj = SWIG_NewPointerObj(SWIG_as_voidptr(tw_sound), SWIGTYPE_p_SoundSystem,  0 );
+  return pyobj;
+}
+
+
+SWIGINTERN PyObject *_wrap_GetSoundSystem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":GetSoundSystem")) SWIG_fail;
+  result = (SoundSystem *)GetSoundSystem();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SoundSystem, 0 |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_PySwigIterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:delete_PySwigIterator",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PySwigIterator" "', argument " "1"" of type '" "swig::PySwigIterator *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  delete arg1;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_value(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  PyObject *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:PySwigIterator_value",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PySwigIterator_value" "', argument " "1"" of type '" "swig::PySwigIterator const *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  try {
+    result = (PyObject *)((swig::PySwigIterator const *)arg1)->value();
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = result;
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_incr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  size_t arg2 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:PySwigIterator_incr",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PySwigIterator_incr" "', argument " "1"" of type '" "swig::PySwigIterator *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PySwigIterator_incr" "', argument " "2"" of type '" "size_t""'");
+  } 
+  arg2 = static_cast< size_t >(val2);
+  try {
+    result = (swig::PySwigIterator *)(arg1)->incr(arg2);
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_incr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:PySwigIterator_incr",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PySwigIterator_incr" "', argument " "1"" of type '" "swig::PySwigIterator *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  try {
+    result = (swig::PySwigIterator *)(arg1)->incr();
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_incr(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[3];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__PySwigIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_PySwigIterator_incr__SWIG_1(self, args);
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__PySwigIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_PySwigIterator_incr__SWIG_0(self, args);
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,"No matching function for overloaded 'PySwigIterator_incr'");
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_decr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  size_t arg2 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:PySwigIterator_decr",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PySwigIterator_decr" "', argument " "1"" of type '" "swig::PySwigIterator *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PySwigIterator_decr" "', argument " "2"" of type '" "size_t""'");
+  } 
+  arg2 = static_cast< size_t >(val2);
+  try {
+    result = (swig::PySwigIterator *)(arg1)->decr(arg2);
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_decr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:PySwigIterator_decr",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PySwigIterator_decr" "', argument " "1"" of type '" "swig::PySwigIterator *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  try {
+    result = (swig::PySwigIterator *)(arg1)->decr();
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_decr(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[3];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__PySwigIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_PySwigIterator_decr__SWIG_1(self, args);
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__PySwigIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_PySwigIterator_decr__SWIG_0(self, args);
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,"No matching function for overloaded 'PySwigIterator_decr'");
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_distance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  swig::PySwigIterator *arg2 = 0 ;
+  ptrdiff_t result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:PySwigIterator_distance",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PySwigIterator_distance" "', argument " "1"" of type '" "swig::PySwigIterator const *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__PySwigIterator,  0  | 0);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PySwigIterator_distance" "', argument " "2"" of type '" "swig::PySwigIterator const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PySwigIterator_distance" "', argument " "2"" of type '" "swig::PySwigIterator const &""'"); 
+  }
+  arg2 = reinterpret_cast< swig::PySwigIterator * >(argp2);
+  try {
+    result = ((swig::PySwigIterator const *)arg1)->distance((swig::PySwigIterator const &)*arg2);
+  }
+  catch(std::invalid_argument &_e) {
+    SWIG_Python_Raise(SWIG_NewPointerObj((new std::invalid_argument(static_cast< const std::invalid_argument& >(_e))),SWIGTYPE_p_std__invalid_argument,SWIG_POINTER_OWN), "std::invalid_argument", SWIGTYPE_p_std__invalid_argument); SWIG_fail;
+  }
+  
+  resultobj = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_equal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  swig::PySwigIterator *arg2 = 0 ;
+  bool result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:PySwigIterator_equal",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PySwigIterator_equal" "', argument " "1"" of type '" "swig::PySwigIterator const *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__PySwigIterator,  0  | 0);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PySwigIterator_equal" "', argument " "2"" of type '" "swig::PySwigIterator const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PySwigIterator_equal" "', argument " "2"" of type '" "swig::PySwigIterator const &""'"); 
+  }
+  arg2 = reinterpret_cast< swig::PySwigIterator * >(argp2);
+  try {
+    result = (bool)((swig::PySwigIterator const *)arg1)->equal((swig::PySwigIterator const &)*arg2);
+  }
+  catch(std::invalid_argument &_e) {
+    SWIG_Python_Raise(SWIG_NewPointerObj((new std::invalid_argument(static_cast< const std::invalid_argument& >(_e))),SWIGTYPE_p_std__invalid_argument,SWIG_POINTER_OWN), "std::invalid_argument", SWIGTYPE_p_std__invalid_argument); SWIG_fail;
+  }
+  
+  resultobj = SWIG_From_bool(static_cast< bool >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:PySwigIterator_copy",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PySwigIterator_copy" "', argument " "1"" of type '" "swig::PySwigIterator const *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  result = (swig::PySwigIterator *)((swig::PySwigIterator const *)arg1)->copy();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, SWIG_POINTER_OWN |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  PyObject *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:PySwigIterator_next",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PySwigIterator_next" "', argument " "1"" of type '" "swig::PySwigIterator *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  try {
+    result = (PyObject *)(arg1)->next();
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = result;
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_previous(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  PyObject *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:PySwigIterator_previous",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PySwigIterator_previous" "', argument " "1"" of type '" "swig::PySwigIterator *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  try {
+    result = (PyObject *)(arg1)->previous();
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = result;
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_advance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  ptrdiff_t arg2 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:PySwigIterator_advance",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PySwigIterator_advance" "', argument " "1"" of type '" "swig::PySwigIterator *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PySwigIterator_advance" "', argument " "2"" of type '" "ptrdiff_t""'");
+  } 
+  arg2 = static_cast< ptrdiff_t >(val2);
+  try {
+    result = (swig::PySwigIterator *)(arg1)->advance(arg2);
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator___eq__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  swig::PySwigIterator *arg2 = 0 ;
+  bool result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:PySwigIterator___eq__",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PySwigIterator___eq__" "', argument " "1"" of type '" "swig::PySwigIterator const *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__PySwigIterator,  0  | 0);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PySwigIterator___eq__" "', argument " "2"" of type '" "swig::PySwigIterator const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PySwigIterator___eq__" "', argument " "2"" of type '" "swig::PySwigIterator const &""'"); 
+  }
+  arg2 = reinterpret_cast< swig::PySwigIterator * >(argp2);
+  result = (bool)((swig::PySwigIterator const *)arg1)->operator ==((swig::PySwigIterator const &)*arg2);
+  resultobj = SWIG_From_bool(static_cast< bool >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator___ne__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  swig::PySwigIterator *arg2 = 0 ;
+  bool result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:PySwigIterator___ne__",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PySwigIterator___ne__" "', argument " "1"" of type '" "swig::PySwigIterator const *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__PySwigIterator,  0  | 0);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PySwigIterator___ne__" "', argument " "2"" of type '" "swig::PySwigIterator const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PySwigIterator___ne__" "', argument " "2"" of type '" "swig::PySwigIterator const &""'"); 
+  }
+  arg2 = reinterpret_cast< swig::PySwigIterator * >(argp2);
+  result = (bool)((swig::PySwigIterator const *)arg1)->operator !=((swig::PySwigIterator const &)*arg2);
+  resultobj = SWIG_From_bool(static_cast< bool >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator___iadd__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  ptrdiff_t arg2 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:PySwigIterator___iadd__",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PySwigIterator___iadd__" "', argument " "1"" of type '" "swig::PySwigIterator *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PySwigIterator___iadd__" "', argument " "2"" of type '" "ptrdiff_t""'");
+  } 
+  arg2 = static_cast< ptrdiff_t >(val2);
+  try {
+    {
+      swig::PySwigIterator &_result_ref = (arg1)->operator +=(arg2);
+      result = (swig::PySwigIterator *) &_result_ref;
+    }
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, SWIG_POINTER_OWN |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator___isub__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  ptrdiff_t arg2 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:PySwigIterator___isub__",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PySwigIterator___isub__" "', argument " "1"" of type '" "swig::PySwigIterator *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PySwigIterator___isub__" "', argument " "2"" of type '" "ptrdiff_t""'");
+  } 
+  arg2 = static_cast< ptrdiff_t >(val2);
+  try {
+    {
+      swig::PySwigIterator &_result_ref = (arg1)->operator -=(arg2);
+      result = (swig::PySwigIterator *) &_result_ref;
+    }
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, SWIG_POINTER_OWN |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator___add__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  ptrdiff_t arg2 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:PySwigIterator___add__",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PySwigIterator___add__" "', argument " "1"" of type '" "swig::PySwigIterator const *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PySwigIterator___add__" "', argument " "2"" of type '" "ptrdiff_t""'");
+  } 
+  arg2 = static_cast< ptrdiff_t >(val2);
+  try {
+    result = (swig::PySwigIterator *)((swig::PySwigIterator const *)arg1)->operator +(arg2);
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, SWIG_POINTER_OWN |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator___sub____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  ptrdiff_t arg2 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:PySwigIterator___sub__",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PySwigIterator___sub__" "', argument " "1"" of type '" "swig::PySwigIterator const *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PySwigIterator___sub__" "', argument " "2"" of type '" "ptrdiff_t""'");
+  } 
+  arg2 = static_cast< ptrdiff_t >(val2);
+  try {
+    result = (swig::PySwigIterator *)((swig::PySwigIterator const *)arg1)->operator -(arg2);
+  }
+  catch(swig::stop_iteration &_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, SWIG_POINTER_OWN |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator___sub____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  swig::PySwigIterator *arg2 = 0 ;
+  ptrdiff_t result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:PySwigIterator___sub__",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PySwigIterator___sub__" "', argument " "1"" of type '" "swig::PySwigIterator const *""'"); 
+  }
+  arg1 = reinterpret_cast< swig::PySwigIterator * >(argp1);
+  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__PySwigIterator,  0  | 0);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PySwigIterator___sub__" "', argument " "2"" of type '" "swig::PySwigIterator const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PySwigIterator___sub__" "', argument " "2"" of type '" "swig::PySwigIterator const &""'"); 
+  }
+  arg2 = reinterpret_cast< swig::PySwigIterator * >(argp2);
+  result = ((swig::PySwigIterator const *)arg1)->operator -((swig::PySwigIterator const &)*arg2);
+  resultobj = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator___sub__(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[3];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__PySwigIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_swig__PySwigIterator, 0);
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_PySwigIterator___sub____SWIG_1(self, args);
+      }
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__PySwigIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_PySwigIterator___sub____SWIG_0(self, args);
+      }
+    }
+  }
+  
+fail:
+  Py_INCREF(Py_NotImplemented);
+  return Py_NotImplemented;
+}
+
+
+SWIGINTERN PyObject *PySwigIterator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)"O|swigregister", &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_swig__PySwigIterator, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_vectorString_iterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  PyObject **arg2 = (PyObject **) 0 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  arg2 = &obj0;
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString_iterator",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_iterator" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  result = (swig::PySwigIterator *)std_vector_Sl_std_string_Sg__iterator(arg1,arg2);
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, SWIG_POINTER_OWN |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString___nonzero__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  bool result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString___nonzero__",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString___nonzero__" "', argument " "1"" of type '" "std::vector<std::string > const *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  result = (bool)std_vector_Sl_std_string_Sg____nonzero__((std::vector<std::string > const *)arg1);
+  resultobj = SWIG_From_bool(static_cast< bool >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString___len__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::size_type result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString___len__",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString___len__" "', argument " "1"" of type '" "std::vector<std::string > const *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  result = std_vector_Sl_std_string_Sg____len__((std::vector<std::string > const *)arg1);
+  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_pop(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::value_type result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString_pop",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_pop" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  try {
+    result = std_vector_Sl_std_string_Sg__pop(arg1);
+  }
+  catch(std::out_of_range &_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
+  }
+  
+  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString___getslice__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::difference_type arg2 ;
+  std::vector<std::string >::difference_type arg3 ;
+  std::vector<std::string,std::allocator<std::string > > *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  ptrdiff_t val3 ;
+  int ecode3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOO:vectorString___getslice__",&obj0,&obj1,&obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString___getslice__" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vectorString___getslice__" "', argument " "2"" of type '" "std::vector<std::string >::difference_type""'");
+  } 
+  arg2 = static_cast< std::vector<std::string >::difference_type >(val2);
+  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "vectorString___getslice__" "', argument " "3"" of type '" "std::vector<std::string >::difference_type""'");
+  } 
+  arg3 = static_cast< std::vector<std::string >::difference_type >(val3);
+  try {
+    result = (std::vector<std::string,std::allocator<std::string > > *)std_vector_Sl_std_string_Sg____getslice__(arg1,arg2,arg3);
+  }
+  catch(std::out_of_range &_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_OWN |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString___setslice__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::difference_type arg2 ;
+  std::vector<std::string >::difference_type arg3 ;
+  std::vector<std::string,std::allocator<std::string > > *arg4 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  ptrdiff_t val3 ;
+  int ecode3 = 0 ;
+  int res4 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOO:vectorString___setslice__",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString___setslice__" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vectorString___setslice__" "', argument " "2"" of type '" "std::vector<std::string >::difference_type""'");
+  } 
+  arg2 = static_cast< std::vector<std::string >::difference_type >(val2);
+  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "vectorString___setslice__" "', argument " "3"" of type '" "std::vector<std::string >::difference_type""'");
+  } 
+  arg3 = static_cast< std::vector<std::string >::difference_type >(val3);
+  {
+    std::vector<std::string,std::allocator<std::string > > *ptr = (std::vector<std::string,std::allocator<std::string > > *)0;
+    res4 = swig::asptr(obj3, &ptr);
+    if (!SWIG_IsOK(res4)) {
+      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "vectorString___setslice__" "', argument " "4"" of type '" "std::vector<std::string,std::allocator<std::string > > const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "vectorString___setslice__" "', argument " "4"" of type '" "std::vector<std::string,std::allocator<std::string > > const &""'"); 
+    }
+    arg4 = ptr;
+  }
+  try {
+    std_vector_Sl_std_string_Sg____setslice__(arg1,arg2,arg3,(std::vector<std::string,std::allocator<std::string > > const &)*arg4);
+  }
+  catch(std::out_of_range &_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
+  }
+  catch(std::invalid_argument &_e) {
+    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
+  }
+  
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString___delslice__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::difference_type arg2 ;
+  std::vector<std::string >::difference_type arg3 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  ptrdiff_t val3 ;
+  int ecode3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOO:vectorString___delslice__",&obj0,&obj1,&obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString___delslice__" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vectorString___delslice__" "', argument " "2"" of type '" "std::vector<std::string >::difference_type""'");
+  } 
+  arg2 = static_cast< std::vector<std::string >::difference_type >(val2);
+  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "vectorString___delslice__" "', argument " "3"" of type '" "std::vector<std::string >::difference_type""'");
+  } 
+  arg3 = static_cast< std::vector<std::string >::difference_type >(val3);
+  try {
+    std_vector_Sl_std_string_Sg____delslice__(arg1,arg2,arg3);
+  }
+  catch(std::out_of_range &_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
+  }
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString___delitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::difference_type arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:vectorString___delitem__",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString___delitem__" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vectorString___delitem__" "', argument " "2"" of type '" "std::vector<std::string >::difference_type""'");
+  } 
+  arg2 = static_cast< std::vector<std::string >::difference_type >(val2);
+  try {
+    std_vector_Sl_std_string_Sg____delitem__(arg1,arg2);
+  }
+  catch(std::out_of_range &_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
+  }
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString___getitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::difference_type arg2 ;
+  std::vector<std::string >::value_type *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:vectorString___getitem__",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString___getitem__" "', argument " "1"" of type '" "std::vector<std::string > const *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vectorString___getitem__" "', argument " "2"" of type '" "std::vector<std::string >::difference_type""'");
+  } 
+  arg2 = static_cast< std::vector<std::string >::difference_type >(val2);
+  try {
+    {
+      std::vector<std::string >::value_type const &_result_ref = std_vector_Sl_std_string_Sg____getitem__((std::vector<std::string > const *)arg1,arg2);
+      result = (std::vector<std::string >::value_type *) &_result_ref;
+    }
+  }
+  catch(std::out_of_range &_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
+  }
+  
+  resultobj = SWIG_From_std_string(static_cast< std::string >(*result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString___setitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::difference_type arg2 ;
+  std::vector<std::string >::value_type *arg3 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  int res3 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOO:vectorString___setitem__",&obj0,&obj1,&obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString___setitem__" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vectorString___setitem__" "', argument " "2"" of type '" "std::vector<std::string >::difference_type""'");
+  } 
+  arg2 = static_cast< std::vector<std::string >::difference_type >(val2);
+  {
+    std::string *ptr = (std::string *)0;
+    res3 = SWIG_AsPtr_std_string(obj2, &ptr);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "vectorString___setitem__" "', argument " "3"" of type '" "std::vector<std::string >::value_type const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "vectorString___setitem__" "', argument " "3"" of type '" "std::vector<std::string >::value_type const &""'"); 
+    }
+    arg3 = ptr;
+  }
+  try {
+    std_vector_Sl_std_string_Sg____setitem__(arg1,arg2,(std::string const &)*arg3);
+  }
+  catch(std::out_of_range &_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
+  }
+  
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_append(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::value_type *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:vectorString_append",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_append" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "vectorString_append" "', argument " "2"" of type '" "std::vector<std::string >::value_type const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "vectorString_append" "', argument " "2"" of type '" "std::vector<std::string >::value_type const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  std_vector_Sl_std_string_Sg__append(arg1,(std::string const &)*arg2);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_vectorString__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)":new_vectorString")) SWIG_fail;
+  result = (std::vector<std::string > *)new std::vector<std::string >();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_vectorString__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = 0 ;
+  std::vector<std::string > *result = 0 ;
+  int res1 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:new_vectorString",&obj0)) SWIG_fail;
+  {
+    std::vector<std::string,std::allocator<std::string > > *ptr = (std::vector<std::string,std::allocator<std::string > > *)0;
+    res1 = swig::asptr(obj0, &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_vectorString" "', argument " "1"" of type '" "std::vector<std::string > const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_vectorString" "', argument " "1"" of type '" "std::vector<std::string > const &""'"); 
+    }
+    arg1 = ptr;
+  }
+  result = (std::vector<std::string > *)new std::vector<std::string >((std::vector<std::string > const &)*arg1);
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_NEW |  0 );
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  bool result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString_empty",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_empty" "', argument " "1"" of type '" "std::vector<std::string > const *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  result = (bool)((std::vector<std::string > const *)arg1)->empty();
+  resultobj = SWIG_From_bool(static_cast< bool >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::size_type result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString_size",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_size" "', argument " "1"" of type '" "std::vector<std::string > const *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  result = ((std::vector<std::string > const *)arg1)->size();
+  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_clear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString_clear",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_clear" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  (arg1)->clear();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_swap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string > *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:vectorString_swap",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_swap" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "vectorString_swap" "', argument " "2"" of type '" "std::vector<std::string > &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "vectorString_swap" "', argument " "2"" of type '" "std::vector<std::string > &""'"); 
+  }
+  arg2 = reinterpret_cast< std::vector<std::string > * >(argp2);
+  (arg1)->swap(*arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_get_allocator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  SwigValueWrapper<std::allocator<std::string > > result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString_get_allocator",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_get_allocator" "', argument " "1"" of type '" "std::vector<std::string > const *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  result = ((std::vector<std::string > const *)arg1)->get_allocator();
+  resultobj = SWIG_NewPointerObj((new std::vector<std::string >::allocator_type(static_cast< const std::vector<std::string >::allocator_type& >(result))), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type, SWIG_POINTER_OWN |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_begin__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString_begin",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_begin" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  result = (arg1)->begin();
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector<std::string >::iterator & >(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_begin__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::const_iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString_begin",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_begin" "', argument " "1"" of type '" "std::vector<std::string > const *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  result = ((std::vector<std::string > const *)arg1)->begin();
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector<std::string >::const_iterator & >(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_begin(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[2];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector<std::string,std::allocator<std::string > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_vectorString_begin__SWIG_0(self, args);
+    }
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector<std::string,std::allocator<std::string > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_vectorString_begin__SWIG_1(self, args);
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,"No matching function for overloaded 'vectorString_begin'");
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_end__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString_end",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_end" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  result = (arg1)->end();
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector<std::string >::iterator & >(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_end__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::const_iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString_end",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_end" "', argument " "1"" of type '" "std::vector<std::string > const *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  result = ((std::vector<std::string > const *)arg1)->end();
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector<std::string >::const_iterator & >(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_end(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[2];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector<std::string,std::allocator<std::string > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_vectorString_end__SWIG_0(self, args);
+    }
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector<std::string,std::allocator<std::string > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_vectorString_end__SWIG_1(self, args);
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,"No matching function for overloaded 'vectorString_end'");
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_rbegin__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::reverse_iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString_rbegin",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_rbegin" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  result = (arg1)->rbegin();
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector<std::string >::reverse_iterator & >(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_rbegin__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::const_reverse_iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString_rbegin",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_rbegin" "', argument " "1"" of type '" "std::vector<std::string > const *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  result = ((std::vector<std::string > const *)arg1)->rbegin();
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector<std::string >::const_reverse_iterator & >(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_rbegin(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[2];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector<std::string,std::allocator<std::string > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_vectorString_rbegin__SWIG_0(self, args);
+    }
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector<std::string,std::allocator<std::string > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_vectorString_rbegin__SWIG_1(self, args);
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,"No matching function for overloaded 'vectorString_rbegin'");
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_rend__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::reverse_iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString_rend",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_rend" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  result = (arg1)->rend();
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector<std::string >::reverse_iterator & >(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_rend__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::const_reverse_iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString_rend",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_rend" "', argument " "1"" of type '" "std::vector<std::string > const *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  result = ((std::vector<std::string > const *)arg1)->rend();
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector<std::string >::const_reverse_iterator & >(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_rend(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[2];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector<std::string,std::allocator<std::string > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_vectorString_rend__SWIG_0(self, args);
+    }
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector<std::string,std::allocator<std::string > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_vectorString_rend__SWIG_1(self, args);
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,"No matching function for overloaded 'vectorString_rend'");
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_vectorString__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string >::size_type arg1 ;
+  std::vector<std::string > *result = 0 ;
+  size_t val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:new_vectorString",&obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_vectorString" "', argument " "1"" of type '" "std::vector<std::string >::size_type""'");
+  } 
+  arg1 = static_cast< std::vector<std::string >::size_type >(val1);
+  result = (std::vector<std::string > *)new std::vector<std::string >(arg1);
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_pop_back(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString_pop_back",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_pop_back" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  (arg1)->pop_back();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_resize__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::size_type arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:vectorString_resize",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_resize" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vectorString_resize" "', argument " "2"" of type '" "std::vector<std::string >::size_type""'");
+  } 
+  arg2 = static_cast< std::vector<std::string >::size_type >(val2);
+  (arg1)->resize(arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_erase__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::iterator arg2 ;
+  std::vector<std::string >::iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  swig::PySwigIterator *iter2 = 0 ;
+  int res2 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:vectorString_erase",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_erase" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::PySwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res2) || !iter2) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "vectorString_erase" "', argument " "2"" of type '" "std::vector<std::string >::iterator""'");
+  } else {
+    swig::PySwigIterator_T<std::vector<std::string >::iterator > *iter_t = dynamic_cast<swig::PySwigIterator_T<std::vector<std::string >::iterator > *>(iter2);
+    if (iter_t) {
+      arg2 = iter_t->get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "vectorString_erase" "', argument " "2"" of type '" "std::vector<std::string >::iterator""'");
+    }
+  }
+  result = (arg1)->erase(arg2);
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector<std::string >::iterator & >(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_erase__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::iterator arg2 ;
+  std::vector<std::string >::iterator arg3 ;
+  std::vector<std::string >::iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  swig::PySwigIterator *iter2 = 0 ;
+  int res2 ;
+  swig::PySwigIterator *iter3 = 0 ;
+  int res3 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOO:vectorString_erase",&obj0,&obj1,&obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_erase" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::PySwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res2) || !iter2) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "vectorString_erase" "', argument " "2"" of type '" "std::vector<std::string >::iterator""'");
+  } else {
+    swig::PySwigIterator_T<std::vector<std::string >::iterator > *iter_t = dynamic_cast<swig::PySwigIterator_T<std::vector<std::string >::iterator > *>(iter2);
+    if (iter_t) {
+      arg2 = iter_t->get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "vectorString_erase" "', argument " "2"" of type '" "std::vector<std::string >::iterator""'");
+    }
+  }
+  res3 = SWIG_ConvertPtr(obj2, SWIG_as_voidptrptr(&iter3), swig::PySwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res3) || !iter3) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "vectorString_erase" "', argument " "3"" of type '" "std::vector<std::string >::iterator""'");
+  } else {
+    swig::PySwigIterator_T<std::vector<std::string >::iterator > *iter_t = dynamic_cast<swig::PySwigIterator_T<std::vector<std::string >::iterator > *>(iter3);
+    if (iter_t) {
+      arg3 = iter_t->get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "vectorString_erase" "', argument " "3"" of type '" "std::vector<std::string >::iterator""'");
+    }
+  }
+  result = (arg1)->erase(arg2,arg3);
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector<std::string >::iterator & >(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_erase(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[4];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 2) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector<std::string,std::allocator<std::string > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      swig::PySwigIterator *iter = 0;
+      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::PySwigIterator::descriptor(), 0);
+      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::PySwigIterator_T<std::vector<std::string >::iterator > *>(iter) != 0));
+      if (_v) {
+        return _wrap_vectorString_erase__SWIG_0(self, args);
+      }
+    }
+  }
+  if (argc == 3) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector<std::string,std::allocator<std::string > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      swig::PySwigIterator *iter = 0;
+      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::PySwigIterator::descriptor(), 0);
+      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::PySwigIterator_T<std::vector<std::string >::iterator > *>(iter) != 0));
+      if (_v) {
+        swig::PySwigIterator *iter = 0;
+        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::PySwigIterator::descriptor(), 0);
+        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::PySwigIterator_T<std::vector<std::string >::iterator > *>(iter) != 0));
+        if (_v) {
+          return _wrap_vectorString_erase__SWIG_1(self, args);
+        }
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,"No matching function for overloaded 'vectorString_erase'");
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_vectorString__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string >::size_type arg1 ;
+  std::vector<std::string >::value_type *arg2 = 0 ;
+  std::vector<std::string > *result = 0 ;
+  size_t val1 ;
+  int ecode1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:new_vectorString",&obj0,&obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_vectorString" "', argument " "1"" of type '" "std::vector<std::string >::size_type""'");
+  } 
+  arg1 = static_cast< std::vector<std::string >::size_type >(val1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_vectorString" "', argument " "2"" of type '" "std::vector<std::string >::value_type const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_vectorString" "', argument " "2"" of type '" "std::vector<std::string >::value_type const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  result = (std::vector<std::string > *)new std::vector<std::string >(arg1,(std::vector<std::string >::value_type const &)*arg2);
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_NEW |  0 );
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_vectorString(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[3];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 0) {
+    return _wrap_new_vectorString__SWIG_0(self, args);
+  }
+  if (argc == 1) {
+    int _v;
+    {
+      int res = SWIG_AsVal_size_t(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      return _wrap_new_vectorString__SWIG_2(self, args);
+    }
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector<std::string,std::allocator<std::string > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_new_vectorString__SWIG_1(self, args);
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    {
+      int res = SWIG_AsVal_size_t(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_new_vectorString__SWIG_3(self, args);
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,"No matching function for overloaded 'new_vectorString'");
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_push_back(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::value_type *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:vectorString_push_back",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_push_back" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "vectorString_push_back" "', argument " "2"" of type '" "std::vector<std::string >::value_type const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "vectorString_push_back" "', argument " "2"" of type '" "std::vector<std::string >::value_type const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  (arg1)->push_back((std::vector<std::string >::value_type const &)*arg2);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_front(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::value_type *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString_front",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_front" "', argument " "1"" of type '" "std::vector<std::string > const *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  {
+    std::vector<std::string >::value_type const &_result_ref = ((std::vector<std::string > const *)arg1)->front();
+    result = (std::vector<std::string >::value_type *) &_result_ref;
+  }
+  resultobj = SWIG_From_std_string(static_cast< std::string >(*result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_back(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::value_type *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString_back",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_back" "', argument " "1"" of type '" "std::vector<std::string > const *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  {
+    std::vector<std::string >::value_type const &_result_ref = ((std::vector<std::string > const *)arg1)->back();
+    result = (std::vector<std::string >::value_type *) &_result_ref;
+  }
+  resultobj = SWIG_From_std_string(static_cast< std::string >(*result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_assign(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::size_type arg2 ;
+  std::vector<std::string >::value_type *arg3 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  int res3 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOO:vectorString_assign",&obj0,&obj1,&obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_assign" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vectorString_assign" "', argument " "2"" of type '" "std::vector<std::string >::size_type""'");
+  } 
+  arg2 = static_cast< std::vector<std::string >::size_type >(val2);
+  {
+    std::string *ptr = (std::string *)0;
+    res3 = SWIG_AsPtr_std_string(obj2, &ptr);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "vectorString_assign" "', argument " "3"" of type '" "std::vector<std::string >::value_type const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "vectorString_assign" "', argument " "3"" of type '" "std::vector<std::string >::value_type const &""'"); 
+    }
+    arg3 = ptr;
+  }
+  (arg1)->assign(arg2,(std::vector<std::string >::value_type const &)*arg3);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_resize__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::size_type arg2 ;
+  std::vector<std::string >::value_type *arg3 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  int res3 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOO:vectorString_resize",&obj0,&obj1,&obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_resize" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vectorString_resize" "', argument " "2"" of type '" "std::vector<std::string >::size_type""'");
+  } 
+  arg2 = static_cast< std::vector<std::string >::size_type >(val2);
+  {
+    std::string *ptr = (std::string *)0;
+    res3 = SWIG_AsPtr_std_string(obj2, &ptr);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "vectorString_resize" "', argument " "3"" of type '" "std::vector<std::string >::value_type const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "vectorString_resize" "', argument " "3"" of type '" "std::vector<std::string >::value_type const &""'"); 
+    }
+    arg3 = ptr;
+  }
+  (arg1)->resize(arg2,(std::vector<std::string >::value_type const &)*arg3);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_resize(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[4];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 2) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector<std::string,std::allocator<std::string > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_vectorString_resize__SWIG_0(self, args);
+      }
+    }
+  }
+  if (argc == 3) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector<std::string,std::allocator<std::string > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
+        _v = SWIG_CheckState(res);
+        if (_v) {
+          return _wrap_vectorString_resize__SWIG_1(self, args);
+        }
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,"No matching function for overloaded 'vectorString_resize'");
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_insert__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::iterator arg2 ;
+  std::vector<std::string >::value_type *arg3 = 0 ;
+  std::vector<std::string >::iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  swig::PySwigIterator *iter2 = 0 ;
+  int res2 ;
+  int res3 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOO:vectorString_insert",&obj0,&obj1,&obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_insert" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::PySwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res2) || !iter2) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "vectorString_insert" "', argument " "2"" of type '" "std::vector<std::string >::iterator""'");
+  } else {
+    swig::PySwigIterator_T<std::vector<std::string >::iterator > *iter_t = dynamic_cast<swig::PySwigIterator_T<std::vector<std::string >::iterator > *>(iter2);
+    if (iter_t) {
+      arg2 = iter_t->get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "vectorString_insert" "', argument " "2"" of type '" "std::vector<std::string >::iterator""'");
+    }
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res3 = SWIG_AsPtr_std_string(obj2, &ptr);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "vectorString_insert" "', argument " "3"" of type '" "std::vector<std::string >::value_type const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "vectorString_insert" "', argument " "3"" of type '" "std::vector<std::string >::value_type const &""'"); 
+    }
+    arg3 = ptr;
+  }
+  result = (arg1)->insert(arg2,(std::vector<std::string >::value_type const &)*arg3);
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector<std::string >::iterator & >(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_insert__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::iterator arg2 ;
+  std::vector<std::string >::size_type arg3 ;
+  std::vector<std::string >::value_type *arg4 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  swig::PySwigIterator *iter2 = 0 ;
+  int res2 ;
+  size_t val3 ;
+  int ecode3 = 0 ;
+  int res4 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OOOO:vectorString_insert",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_insert" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::PySwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res2) || !iter2) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "vectorString_insert" "', argument " "2"" of type '" "std::vector<std::string >::iterator""'");
+  } else {
+    swig::PySwigIterator_T<std::vector<std::string >::iterator > *iter_t = dynamic_cast<swig::PySwigIterator_T<std::vector<std::string >::iterator > *>(iter2);
+    if (iter_t) {
+      arg2 = iter_t->get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "vectorString_insert" "', argument " "2"" of type '" "std::vector<std::string >::iterator""'");
+    }
+  }
+  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "vectorString_insert" "', argument " "3"" of type '" "std::vector<std::string >::size_type""'");
+  } 
+  arg3 = static_cast< std::vector<std::string >::size_type >(val3);
+  {
+    std::string *ptr = (std::string *)0;
+    res4 = SWIG_AsPtr_std_string(obj3, &ptr);
+    if (!SWIG_IsOK(res4)) {
+      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "vectorString_insert" "', argument " "4"" of type '" "std::vector<std::string >::value_type const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "vectorString_insert" "', argument " "4"" of type '" "std::vector<std::string >::value_type const &""'"); 
+    }
+    arg4 = ptr;
+  }
+  (arg1)->insert(arg2,arg3,(std::vector<std::string >::value_type const &)*arg4);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_insert(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[5];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 3) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector<std::string,std::allocator<std::string > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      swig::PySwigIterator *iter = 0;
+      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::PySwigIterator::descriptor(), 0);
+      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::PySwigIterator_T<std::vector<std::string >::iterator > *>(iter) != 0));
+      if (_v) {
+        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
+        _v = SWIG_CheckState(res);
+        if (_v) {
+          return _wrap_vectorString_insert__SWIG_0(self, args);
+        }
+      }
+    }
+  }
+  if (argc == 4) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector<std::string,std::allocator<std::string > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      swig::PySwigIterator *iter = 0;
+      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::PySwigIterator::descriptor(), 0);
+      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::PySwigIterator_T<std::vector<std::string >::iterator > *>(iter) != 0));
+      if (_v) {
+        {
+          int res = SWIG_AsVal_size_t(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
+          _v = SWIG_CheckState(res);
+          if (_v) {
+            return _wrap_vectorString_insert__SWIG_1(self, args);
+          }
+        }
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,"No matching function for overloaded 'vectorString_insert'");
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_reserve(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::size_type arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"OO:vectorString_reserve",&obj0,&obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_reserve" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vectorString_reserve" "', argument " "2"" of type '" "std::vector<std::string >::size_type""'");
+  } 
+  arg2 = static_cast< std::vector<std::string >::size_type >(val2);
+  (arg1)->reserve(arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_capacity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  std::vector<std::string >::size_type result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:vectorString_capacity",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vectorString_capacity" "', argument " "1"" of type '" "std::vector<std::string > const *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  result = ((std::vector<std::string > const *)arg1)->capacity();
+  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_vectorString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector<std::string > *arg1 = (std::vector<std::string > *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)"O:delete_vectorString",&obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_vectorString" "', argument " "1"" of type '" "std::vector<std::string > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
+  delete arg1;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *vectorString_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)"O|swigregister", &obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+static PyMethodDef SwigMethods[] = {
+	 { (char *)"GameAction_clean", _wrap_GameAction_clean, METH_VARARGS, NULL},
+	 { (char *)"GameAction_add_system", _wrap_GameAction_add_system, METH_VARARGS, NULL},
+	 { (char *)"GameAction_add_planet", _wrap_GameAction_add_planet, METH_VARARGS, NULL},
+	 { (char *)"GameAction_add_orbiter_station", _wrap_GameAction_add_orbiter_station, METH_VARARGS, NULL},
+	 { (char *)"GameAction_add_asteroid", _wrap_GameAction_add_asteroid, METH_VARARGS, NULL},
+	 { (char *)"GameAction_add_player", _wrap_GameAction_add_player, METH_VARARGS, NULL},
+	 { (char *)"GameAction_add_ship", _wrap_GameAction_add_ship, METH_VARARGS, NULL},
+	 { (char *)"GameAction_get_string_flag", _wrap_GameAction_get_string_flag, METH_VARARGS, NULL},
+	 { (char *)"GameAction_save_flag", _wrap_GameAction_save_flag, METH_VARARGS, NULL},
+	 { (char *)"GameAction_get_double_flag", _wrap_GameAction_get_double_flag, METH_VARARGS, NULL},
+	 { (char *)"GameAction_get_player_ship_id", _wrap_GameAction_get_player_ship_id, METH_VARARGS, NULL},
+	 { (char *)"GameAction_get_player_star_system", _wrap_GameAction_get_player_star_system, METH_VARARGS, NULL},
+	 { (char *)"GameAction_set_target", _wrap_GameAction_set_target, METH_VARARGS, NULL},
+	 { (char *)"GameAction_disable_weapon", _wrap_GameAction_disable_weapon, METH_VARARGS, NULL},
+	 { (char *)"GameAction_enable_weapon", _wrap_GameAction_enable_weapon, METH_VARARGS, NULL},
+	 { (char *)"GameAction_go_to_point", _wrap_GameAction_go_to_point, METH_VARARGS, NULL},
+	 { (char *)"GameAction_go_to_location", _wrap_GameAction_go_to_location, METH_VARARGS, NULL},
+	 { (char *)"GameAction_guard_location", _wrap_GameAction_guard_location, METH_VARARGS, NULL},
+	 { (char *)"GameAction_guard_point", _wrap_GameAction_guard_point, METH_VARARGS, NULL},
+	 { (char *)"GameAction_set_ship_team", _wrap_GameAction_set_ship_team, METH_VARARGS, NULL},
+	 { (char *)"GameAction_get_enemy_team", _wrap_GameAction_get_enemy_team, METH_VARARGS, NULL},
+	 { (char *)"GameAction_get_player_team", _wrap_GameAction_get_player_team, METH_VARARGS, NULL},
+	 { (char *)"GameAction_remove_location", _wrap_GameAction_remove_location, METH_VARARGS, NULL},
+	 { (char *)"GameAction_set_crew", _wrap_GameAction_set_crew, METH_VARARGS, NULL},
+	 { (char *)"GameAction_get_location_pos_x", _wrap_GameAction_get_location_pos_x, METH_VARARGS, NULL},
+	 { (char *)"GameAction_get_location_pos_y", _wrap_GameAction_get_location_pos_y, METH_VARARGS, NULL},
+	 { (char *)"GameAction_exist", _wrap_GameAction_exist, METH_VARARGS, NULL},
+	 { (char *)"GameAction_end_game", _wrap_GameAction_end_game, METH_VARARGS, NULL},
+	 { (char *)"GameAction_scroll_text", _wrap_GameAction_scroll_text, METH_VARARGS, NULL},
+	 { (char *)"GameAction_print_message", _wrap_GameAction_print_message, METH_VARARGS, NULL},
+	 { (char *)"GameAction_set_camera_mode", _wrap_GameAction_set_camera_mode, METH_VARARGS, NULL},
+	 { (char *)"new_GameAction", _wrap_new_GameAction, METH_VARARGS, NULL},
+	 { (char *)"delete_GameAction", _wrap_delete_GameAction, METH_VARARGS, NULL},
+	 { (char *)"GameAction_swigregister", GameAction_swigregister, METH_VARARGS, NULL},
+	 { (char *)"DialogApi_startDialog", _wrap_DialogApi_startDialog, METH_VARARGS, NULL},
+	 { (char *)"DialogApi_endDialog", _wrap_DialogApi_endDialog, METH_VARARGS, NULL},
+	 { (char *)"DialogApi_askPlayer", _wrap_DialogApi_askPlayer, METH_VARARGS, NULL},
+	 { (char *)"DialogApi_showText", _wrap_DialogApi_showText, METH_VARARGS, NULL},
+	 { (char *)"DialogApi_showAlienPicture", _wrap_DialogApi_showAlienPicture, METH_VARARGS, NULL},
+	 { (char *)"new_DialogApi", _wrap_new_DialogApi, METH_VARARGS, NULL},
+	 { (char *)"delete_DialogApi", _wrap_delete_DialogApi, METH_VARARGS, NULL},
+	 { (char *)"DialogApi_swigregister", DialogApi_swigregister, METH_VARARGS, NULL},
+	 { (char *)"GameConfig_SetGameDirectory", _wrap_GameConfig_SetGameDirectory, METH_VARARGS, NULL},
+	 { (char *)"GameConfig_GetGameDirectory", _wrap_GameConfig_GetGameDirectory, METH_VARARGS, NULL},
+	 { (char *)"GameConfig_GetAbsolutePath", _wrap_GameConfig_GetAbsolutePath, METH_VARARGS, NULL},
+	 { (char *)"new_GameConfig", _wrap_new_GameConfig, METH_VARARGS, NULL},
+	 { (char *)"delete_GameConfig", _wrap_delete_GameConfig, METH_VARARGS, NULL},
+	 { (char *)"GameConfig_swigregister", GameConfig_swigregister, METH_VARARGS, NULL},
+	 { (char *)"EventManager_clean", _wrap_EventManager_clean, METH_VARARGS, NULL},
+	 { (char *)"EventManager_setSingleTimeEvent", _wrap_EventManager_setSingleTimeEvent, METH_VARARGS, NULL},
+	 { (char *)"EventManager_setRepeatableTimeEvent", _wrap_EventManager_setRepeatableTimeEvent, METH_VARARGS, NULL},
+	 { (char *)"EventManager_disableEvent", _wrap_EventManager_disableEvent, METH_VARARGS, NULL},
+	 { (char *)"EventManager_shipDeathById", _wrap_EventManager_shipDeathById, METH_VARARGS, NULL},
+	 { (char *)"EventManager_shipDeathByType", _wrap_EventManager_shipDeathByType, METH_VARARGS, NULL},
+	 { (char *)"EventManager_distanceMoreThen", _wrap_EventManager_distanceMoreThen, METH_VARARGS, NULL},
+	 { (char *)"EventManager_distanceLessThen", _wrap_EventManager_distanceLessThen, METH_VARARGS, NULL},
+	 { (char *)"EventManager_jumpToSystem", _wrap_EventManager_jumpToSystem, METH_VARARGS, NULL},
+	 { (char *)"EventManager_AddEventCondition", _wrap_EventManager_AddEventCondition, METH_VARARGS, NULL},
+	 { (char *)"new_EventManager", _wrap_new_EventManager, METH_VARARGS, NULL},
+	 { (char *)"delete_EventManager", _wrap_delete_EventManager, METH_VARARGS, NULL},
+	 { (char *)"EventManager_swigregister", EventManager_swigregister, METH_VARARGS, NULL},
+	 { (char *)"new_SoundSystem", _wrap_new_SoundSystem, METH_VARARGS, NULL},
+	 { (char *)"delete_SoundSystem", _wrap_delete_SoundSystem, METH_VARARGS, NULL},
+	 { (char *)"SoundSystem_play_music", _wrap_SoundSystem_play_music, METH_VARARGS, NULL},
+	 { (char *)"SoundSystem_play_sound", _wrap_SoundSystem_play_sound, METH_VARARGS, NULL},
+	 { (char *)"SoundSystem_stop_sound", _wrap_SoundSystem_stop_sound, METH_VARARGS, NULL},
+	 { (char *)"SoundSystem_set_music_volume", _wrap_SoundSystem_set_music_volume, METH_VARARGS, NULL},
+	 { (char *)"SoundSystem_set_sound_volume", _wrap_SoundSystem_set_sound_volume, METH_VARARGS, NULL},
+	 { (char *)"SoundSystem_load_music_volume", _wrap_SoundSystem_load_music_volume, METH_VARARGS, NULL},
+	 { (char *)"SoundSystem_load_sound_volume", _wrap_SoundSystem_load_sound_volume, METH_VARARGS, NULL},
+	 { (char *)"SoundSystem_playing_music", _wrap_SoundSystem_playing_music, METH_VARARGS, NULL},
+	 { (char *)"SoundSystem_playing_music_file", _wrap_SoundSystem_playing_music_file, METH_VARARGS, NULL},
+	 { (char *)"SoundSystem_swigregister", SoundSystem_swigregister, METH_VARARGS, NULL},
+	 { (char *)"GetSoundSystem", _wrap_GetSoundSystem, METH_VARARGS, NULL},
+	 { (char *)"delete_PySwigIterator", _wrap_delete_PySwigIterator, METH_VARARGS, NULL},
+	 { (char *)"PySwigIterator_value", _wrap_PySwigIterator_value, METH_VARARGS, NULL},
+	 { (char *)"PySwigIterator_incr", _wrap_PySwigIterator_incr, METH_VARARGS, NULL},
+	 { (char *)"PySwigIterator_decr", _wrap_PySwigIterator_decr, METH_VARARGS, NULL},
+	 { (char *)"PySwigIterator_distance", _wrap_PySwigIterator_distance, METH_VARARGS, NULL},
+	 { (char *)"PySwigIterator_equal", _wrap_PySwigIterator_equal, METH_VARARGS, NULL},
+	 { (char *)"PySwigIterator_copy", _wrap_PySwigIterator_copy, METH_VARARGS, NULL},
+	 { (char *)"PySwigIterator_next", _wrap_PySwigIterator_next, METH_VARARGS, NULL},
+	 { (char *)"PySwigIterator_previous", _wrap_PySwigIterator_previous, METH_VARARGS, NULL},
+	 { (char *)"PySwigIterator_advance", _wrap_PySwigIterator_advance, METH_VARARGS, NULL},
+	 { (char *)"PySwigIterator___eq__", _wrap_PySwigIterator___eq__, METH_VARARGS, NULL},
+	 { (char *)"PySwigIterator___ne__", _wrap_PySwigIterator___ne__, METH_VARARGS, NULL},
+	 { (char *)"PySwigIterator___iadd__", _wrap_PySwigIterator___iadd__, METH_VARARGS, NULL},
+	 { (char *)"PySwigIterator___isub__", _wrap_PySwigIterator___isub__, METH_VARARGS, NULL},
+	 { (char *)"PySwigIterator___add__", _wrap_PySwigIterator___add__, METH_VARARGS, NULL},
+	 { (char *)"PySwigIterator___sub__", _wrap_PySwigIterator___sub__, METH_VARARGS, NULL},
+	 { (char *)"PySwigIterator_swigregister", PySwigIterator_swigregister, METH_VARARGS, NULL},
+	 { (char *)"vectorString_iterator", _wrap_vectorString_iterator, METH_VARARGS, NULL},
+	 { (char *)"vectorString___nonzero__", _wrap_vectorString___nonzero__, METH_VARARGS, NULL},
+	 { (char *)"vectorString___len__", _wrap_vectorString___len__, METH_VARARGS, NULL},
+	 { (char *)"vectorString_pop", _wrap_vectorString_pop, METH_VARARGS, NULL},
+	 { (char *)"vectorString___getslice__", _wrap_vectorString___getslice__, METH_VARARGS, NULL},
+	 { (char *)"vectorString___setslice__", _wrap_vectorString___setslice__, METH_VARARGS, NULL},
+	 { (char *)"vectorString___delslice__", _wrap_vectorString___delslice__, METH_VARARGS, NULL},
+	 { (char *)"vectorString___delitem__", _wrap_vectorString___delitem__, METH_VARARGS, NULL},
+	 { (char *)"vectorString___getitem__", _wrap_vectorString___getitem__, METH_VARARGS, NULL},
+	 { (char *)"vectorString___setitem__", _wrap_vectorString___setitem__, METH_VARARGS, NULL},
+	 { (char *)"vectorString_append", _wrap_vectorString_append, METH_VARARGS, NULL},
+	 { (char *)"vectorString_empty", _wrap_vectorString_empty, METH_VARARGS, NULL},
+	 { (char *)"vectorString_size", _wrap_vectorString_size, METH_VARARGS, NULL},
+	 { (char *)"vectorString_clear", _wrap_vectorString_clear, METH_VARARGS, NULL},
+	 { (char *)"vectorString_swap", _wrap_vectorString_swap, METH_VARARGS, NULL},
+	 { (char *)"vectorString_get_allocator", _wrap_vectorString_get_allocator, METH_VARARGS, NULL},
+	 { (char *)"vectorString_begin", _wrap_vectorString_begin, METH_VARARGS, NULL},
+	 { (char *)"vectorString_end", _wrap_vectorString_end, METH_VARARGS, NULL},
+	 { (char *)"vectorString_rbegin", _wrap_vectorString_rbegin, METH_VARARGS, NULL},
+	 { (char *)"vectorString_rend", _wrap_vectorString_rend, METH_VARARGS, NULL},
+	 { (char *)"vectorString_pop_back", _wrap_vectorString_pop_back, METH_VARARGS, NULL},
+	 { (char *)"vectorString_erase", _wrap_vectorString_erase, METH_VARARGS, NULL},
+	 { (char *)"new_vectorString", _wrap_new_vectorString, METH_VARARGS, NULL},
+	 { (char *)"vectorString_push_back", _wrap_vectorString_push_back, METH_VARARGS, NULL},
+	 { (char *)"vectorString_front", _wrap_vectorString_front, METH_VARARGS, NULL},
+	 { (char *)"vectorString_back", _wrap_vectorString_back, METH_VARARGS, NULL},
+	 { (char *)"vectorString_assign", _wrap_vectorString_assign, METH_VARARGS, NULL},
+	 { (char *)"vectorString_resize", _wrap_vectorString_resize, METH_VARARGS, NULL},
+	 { (char *)"vectorString_insert", _wrap_vectorString_insert, METH_VARARGS, NULL},
+	 { (char *)"vectorString_reserve", _wrap_vectorString_reserve, METH_VARARGS, NULL},
+	 { (char *)"vectorString_capacity", _wrap_vectorString_capacity, METH_VARARGS, NULL},
+	 { (char *)"delete_vectorString", _wrap_delete_vectorString, METH_VARARGS, NULL},
+	 { (char *)"vectorString_swigregister", vectorString_swigregister, METH_VARARGS, NULL},
+	 { NULL, NULL, 0, NULL }
+};
+
+
+/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
+
+static swig_type_info _swigt__p_DialogApi = {"_p_DialogApi", "DialogApi *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_EventManager = {"_p_EventManager", "EventManager *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GameAction = {"_p_GameAction", "GameAction *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GameConfig = {"_p_GameConfig", "GameConfig *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_SoundSystem = {"_p_SoundSystem", "SoundSystem *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_allocator_type = {"_p_allocator_type", "allocator_type *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_boost__shared_ptrTSpaceLocation_t = {"_p_boost__shared_ptrTSpaceLocation_t", "boost::shared_ptr<SpaceLocation > *|SpaceLocationPtr *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_boost__shared_ptrTTGameEvent_t = {"_p_boost__shared_ptrTTGameEvent_t", "boost::shared_ptr<TGameEvent > *|TGameEventPtr *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_difference_type = {"_p_difference_type", "difference_type *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p_PyObject = {"_p_p_PyObject", "PyObject **", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_size_type = {"_p_size_type", "size_type *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_std__invalid_argument = {"_p_std__invalid_argument", "std::invalid_argument *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t = {"_p_std__vectorTstd__string_std__allocatorTstd__string_t_t", "std::vector<std::string > *|std::vector<std::string,std::allocator<std::string > > *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type = {"_p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type", "std::allocator<std::string > *|std::vector<std::string >::allocator_type *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_swig__PySwigIterator = {"_p_swig__PySwigIterator", "swig::PySwigIterator *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_value_type = {"_p_value_type", "value_type *", 0, 0, (void*)0, 0};
+
+static swig_type_info *swig_type_initial[] = {
+  &_swigt__p_DialogApi,
+  &_swigt__p_EventManager,
+  &_swigt__p_GameAction,
+  &_swigt__p_GameConfig,
+  &_swigt__p_SoundSystem,
+  &_swigt__p_allocator_type,
+  &_swigt__p_boost__shared_ptrTSpaceLocation_t,
+  &_swigt__p_boost__shared_ptrTTGameEvent_t,
+  &_swigt__p_char,
+  &_swigt__p_difference_type,
+  &_swigt__p_p_PyObject,
+  &_swigt__p_size_type,
+  &_swigt__p_std__invalid_argument,
+  &_swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t,
+  &_swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type,
+  &_swigt__p_swig__PySwigIterator,
+  &_swigt__p_value_type,
+};
+
+static swig_cast_info _swigc__p_DialogApi[] = {  {&_swigt__p_DialogApi, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_EventManager[] = {  {&_swigt__p_EventManager, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_GameAction[] = {  {&_swigt__p_GameAction, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_GameConfig[] = {  {&_swigt__p_GameConfig, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_SoundSystem[] = {  {&_swigt__p_SoundSystem, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_allocator_type[] = {  {&_swigt__p_allocator_type, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_boost__shared_ptrTSpaceLocation_t[] = {  {&_swigt__p_boost__shared_ptrTSpaceLocation_t, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_boost__shared_ptrTTGameEvent_t[] = {  {&_swigt__p_boost__shared_ptrTTGameEvent_t, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_difference_type[] = {  {&_swigt__p_difference_type, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_p_PyObject[] = {  {&_swigt__p_p_PyObject, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_size_type[] = {  {&_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_std__invalid_argument[] = {  {&_swigt__p_std__invalid_argument, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_std__vectorTstd__string_std__allocatorTstd__string_t_t[] = {  {&_swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type[] = {  {&_swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_swig__PySwigIterator[] = {  {&_swigt__p_swig__PySwigIterator, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_value_type[] = {  {&_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};
+
+static swig_cast_info *swig_cast_initial[] = {
+  _swigc__p_DialogApi,
+  _swigc__p_EventManager,
+  _swigc__p_GameAction,
+  _swigc__p_GameConfig,
+  _swigc__p_SoundSystem,
+  _swigc__p_allocator_type,
+  _swigc__p_boost__shared_ptrTSpaceLocation_t,
+  _swigc__p_boost__shared_ptrTTGameEvent_t,
+  _swigc__p_char,
+  _swigc__p_difference_type,
+  _swigc__p_p_PyObject,
+  _swigc__p_size_type,
+  _swigc__p_std__invalid_argument,
+  _swigc__p_std__vectorTstd__string_std__allocatorTstd__string_t_t,
+  _swigc__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type,
+  _swigc__p_swig__PySwigIterator,
+  _swigc__p_value_type,
+};
+
+
+/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
+
+static swig_const_info swig_const_table[] = {
+{0, 0, 0, 0.0, 0, 0}};
+
+#ifdef __cplusplus
+}
+#endif
+/* -----------------------------------------------------------------------------
+ * Type initialization:
+ * This problem is tough by the requirement that no dynamic 
+ * memory is used. Also, since swig_type_info structures store pointers to 
+ * swig_cast_info structures and swig_cast_info structures store pointers back
+ * to swig_type_info structures, we need some lookup code at initialization. 
+ * The idea is that swig generates all the structures that are needed. 
+ * The runtime then collects these partially filled structures. 
+ * The SWIG_InitializeModule function takes these initial arrays out of 
+ * swig_module, and does all the lookup, filling in the swig_module.types
+ * array with the correct data and linking the correct swig_cast_info
+ * structures together.
+ *
+ * The generated swig_type_info structures are assigned staticly to an initial 
+ * array. We just loop though that array, and handle each type individually.
+ * First we lookup if this type has been already loaded, and if so, use the
+ * loaded structure instead of the generated one. Then we have to fill in the
+ * cast linked list. The cast data is initially stored in something like a
+ * two-dimensional array. Each row corresponds to a type (there are the same
+ * number of rows as there are in the swig_type_initial array). Each entry in
+ * a column is one of the swig_cast_info structures for that type.
+ * The cast_initial array is actually an array of arrays, because each row has
+ * a variable number of columns. So to actually build the cast linked list,
+ * we find the array of casts associated with the type, and loop through it 
+ * adding the casts to the list. The one last trick we need to do is making
+ * sure the type pointer in the swig_cast_info struct is correct.
+ *
+ * First off, we lookup the cast->type name to see if it is already loaded. 
+ * There are three cases to handle:
+ *  1) If the cast->type has already been loaded AND the type we are adding
+ *     casting info to has not been loaded (it is in this module), THEN we
+ *     replace the cast->type pointer with the type pointer that has already
+ *     been loaded.
+ *  2) If BOTH types (the one we are adding casting info to, and the 
+ *     cast->type) are loaded, THEN the cast info has already been loaded by
+ *     the previous module so we just ignore it.
+ *  3) Finally, if cast->type has not already been loaded, then we add that
+ *     swig_cast_info to the linked list (because the cast->type) pointer will
+ *     be correct.
+ * ----------------------------------------------------------------------------- */
+
+#ifdef __cplusplus
+extern "C" {
+#if 0
+} /* c-mode */
+#endif
+#endif
+
+#if 0
+#define SWIGRUNTIME_DEBUG
+#endif
+
+SWIGRUNTIME void
+SWIG_InitializeModule(void *clientdata) {
+  size_t i;
+  swig_module_info *module_head;
+  static int init_run = 0;
+  
+  clientdata = clientdata;
+  
+  if (init_run) return;
+  init_run = 1;
+  
+  /* Initialize the swig_module */
+  swig_module.type_initial = swig_type_initial;
+  swig_module.cast_initial = swig_cast_initial;
+  
+  /* Try and load any already created modules */
+  module_head = SWIG_GetModule(clientdata);
+  if (module_head) {
+    swig_module.next = module_head->next;
+    module_head->next = &swig_module;
+  } else {
+    /* This is the first module loaded */
+    swig_module.next = &swig_module;
+    SWIG_SetModule(clientdata, &swig_module);
+  }
+  
+  /* Now work on filling in swig_module.types */
+#ifdef SWIGRUNTIME_DEBUG
+  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
+#endif
+  for (i = 0; i < swig_module.size; ++i) {
+    swig_type_info *type = 0;
+    swig_type_info *ret;
+    swig_cast_info *cast;
+    
+#ifdef SWIGRUNTIME_DEBUG
+    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
+#endif
+    
+    /* if there is another module already loaded */
+    if (swig_module.next != &swig_module) {
+      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
+    }
+    if (type) {
+      /* Overwrite clientdata field */
+#ifdef SWIGRUNTIME_DEBUG
+      printf("SWIG_InitializeModule: found type %s\n", type->name);
+#endif
+      if (swig_module.type_initial[i]->clientdata) {
+        type->clientdata = swig_module.type_initial[i]->clientdata;
+#ifdef SWIGRUNTIME_DEBUG
+        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
+#endif
+      }
+    } else {
+      type = swig_module.type_initial[i];
+    }
+    
+    /* Insert casting types */
+    cast = swig_module.cast_initial[i];
+    while (cast->type) {
+      /* Don't need to add information already in the list */
+      ret = 0;
+#ifdef SWIGRUNTIME_DEBUG
+      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
+#endif
+      if (swig_module.next != &swig_module) {
+        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
+#ifdef SWIGRUNTIME_DEBUG
+        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
+#endif
+      }
+      if (ret) {
+        if (type == swig_module.type_initial[i]) {
+#ifdef SWIGRUNTIME_DEBUG
+          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
+#endif
+          cast->type = ret;
+          ret = 0;
+        } else {
+          /* Check for casting already in the list */
+          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
+#ifdef SWIGRUNTIME_DEBUG
+          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
+#endif
+          if (!ocast) ret = 0;
+        }
+      }
+      
+      if (!ret) {
+#ifdef SWIGRUNTIME_DEBUG
+        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
+#endif
+        if (type->cast) {
+          type->cast->prev = cast;
+          cast->next = type->cast;
+        }
+        type->cast = cast;
+      }
+      cast++;
+    }
+    /* Set entry in modules->types array equal to the type */
+    swig_module.types[i] = type;
+  }
+  swig_module.types[i] = 0;
+  
+#ifdef SWIGRUNTIME_DEBUG
+  printf("**** SWIG_InitializeModule: Cast List ******\n");
+  for (i = 0; i < swig_module.size; ++i) {
+    int j = 0;
+    swig_cast_info *cast = swig_module.cast_initial[i];
+    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
+    while (cast->type) {
+      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
+      cast++;
+      ++j;
+    }
+    printf("---- Total casts: %d\n",j);
+  }
+  printf("**** SWIG_InitializeModule: Cast List ******\n");
+#endif
+}
+
+/* This function will propagate the clientdata field of type to
+* any new swig_type_info structures that have been added into the list
+* of equivalent types.  It is like calling
+* SWIG_TypeClientData(type, clientdata) a second time.
+*/
+SWIGRUNTIME void
+SWIG_PropagateClientData(void) {
+  size_t i;
+  swig_cast_info *equiv;
+  static int init_run = 0;
+  
+  if (init_run) return;
+  init_run = 1;
+  
+  for (i = 0; i < swig_module.size; i++) {
+    if (swig_module.types[i]->clientdata) {
+      equiv = swig_module.types[i]->cast;
+      while (equiv) {
+        if (!equiv->converter) {
+          if (equiv->type && !equiv->type->clientdata)
+          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
+        }
+        equiv = equiv->next;
+      }
+    }
+  }
+}
+
+#ifdef __cplusplus
+#if 0
+{
+  /* c-mode */
+#endif
+}
+#endif
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+  
+  /* Python-specific SWIG API */
+#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
+#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
+#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
+  
+  /* -----------------------------------------------------------------------------
+   * global variable support code.
+   * ----------------------------------------------------------------------------- */
+  
+  typedef struct swig_globalvar {
+    char       *name;                  /* Name of global variable */
+    PyObject *(*get_attr)(void);       /* Return the current value */
+    int       (*set_attr)(PyObject *); /* Set the value */
+    struct swig_globalvar *next;
+  } swig_globalvar;
+  
+  typedef struct swig_varlinkobject {
+    PyObject_HEAD
+    swig_globalvar *vars;
+  } swig_varlinkobject;
+  
+  SWIGINTERN PyObject *
+  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
+    return PyString_FromString("<Swig global variables>");
+  }
+  
+  SWIGINTERN PyObject *
+  swig_varlink_str(swig_varlinkobject *v) {
+    PyObject *str = PyString_FromString("(");
+    swig_globalvar  *var;
+    for (var = v->vars; var; var=var->next) {
+      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
+      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
+    }
+    PyString_ConcatAndDel(&str,PyString_FromString(")"));
+    return str;
+  }
+  
+  SWIGINTERN int
+  swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {
+    PyObject *str = swig_varlink_str(v);
+    fprintf(fp,"Swig global variables ");
+    fprintf(fp,"%s\n", PyString_AsString(str));
+    Py_DECREF(str);
+    return 0;
+  }
+  
+  SWIGINTERN void
+  swig_varlink_dealloc(swig_varlinkobject *v) {
+    swig_globalvar *var = v->vars;
+    while (var) {
+      swig_globalvar *n = var->next;
+      free(var->name);
+      free(var);
+      var = n;
+    }
+  }
+  
+  SWIGINTERN PyObject *
+  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
+    PyObject *res = NULL;
+    swig_globalvar *var = v->vars;
+    while (var) {
+      if (strcmp(var->name,n) == 0) {
+        res = (*var->get_attr)();
+        break;
+      }
+      var = var->next;
+    }
+    if (res == NULL && !PyErr_Occurred()) {
+      PyErr_SetString(PyExc_NameError,"Unknown C global variable");
+    }
+    return res;
+  }
+  
+  SWIGINTERN int
+  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
+    int res = 1;
+    swig_globalvar *var = v->vars;
+    while (var) {
+      if (strcmp(var->name,n) == 0) {
+        res = (*var->set_attr)(p);
+        break;
+      }
+      var = var->next;
+    }
+    if (res == 1 && !PyErr_Occurred()) {
+      PyErr_SetString(PyExc_NameError,"Unknown C global variable");
+    }
+    return res;
+  }
+  
+  SWIGINTERN PyTypeObject*
+  swig_varlink_type(void) {
+    static char varlink__doc__[] = "Swig var link object";
+    static PyTypeObject varlink_type;
+    static int type_init = 0;  
+    if (!type_init) {
+      const PyTypeObject tmp
+      = {
+        PyObject_HEAD_INIT(NULL)
+        0,                                  /* Number of items in variable part (ob_size) */
+        (char *)"swigvarlink",              /* Type name (tp_name) */
+        sizeof(swig_varlinkobject),         /* Basic size (tp_basicsize) */
+        0,                                  /* Itemsize (tp_itemsize) */
+        (destructor) swig_varlink_dealloc,   /* Deallocator (tp_dealloc) */ 
+        (printfunc) swig_varlink_print,     /* Print (tp_print) */
+        (getattrfunc) swig_varlink_getattr, /* get attr (tp_getattr) */
+        (setattrfunc) swig_varlink_setattr, /* Set attr (tp_setattr) */
+        0,                                  /* tp_compare */
+        (reprfunc) swig_varlink_repr,       /* tp_repr */
+        0,                                  /* tp_as_number */
+        0,                                  /* tp_as_sequence */
+        0,                                  /* tp_as_mapping */
+        0,                                  /* tp_hash */
+        0,                                  /* tp_call */
+        (reprfunc)swig_varlink_str,        /* tp_str */
+        0,                                  /* tp_getattro */
+        0,                                  /* tp_setattro */
+        0,                                  /* tp_as_buffer */
+        0,                                  /* tp_flags */
+        varlink__doc__,                     /* tp_doc */
+        0,                                  /* tp_traverse */
+        0,                                  /* tp_clear */
+        0,                                  /* tp_richcompare */
+        0,                                  /* tp_weaklistoffset */
+#if PY_VERSION_HEX >= 0x02020000
+        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
+#endif
+#if PY_VERSION_HEX >= 0x02030000
+        0,                                  /* tp_del */
+#endif
+#ifdef COUNT_ALLOCS
+        0,0,0,0                             /* tp_alloc -> tp_next */
+#endif
+      };
+      varlink_type = tmp;
+      varlink_type.ob_type = &PyType_Type;
+      type_init = 1;
+    }
+    return &varlink_type;
+  }
+  
+  /* Create a variable linking object for use later */
+  SWIGINTERN PyObject *
+  SWIG_Python_newvarlink(void) {
+    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
+    if (result) {
+      result->vars = 0;
+    }
+    return ((PyObject*) result);
+  }
+  
+  SWIGINTERN void 
+  SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
+    swig_varlinkobject *v = (swig_varlinkobject *) p;
+    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
+    if (gv) {
+      size_t size = strlen(name)+1;
+      gv->name = (char *)malloc(size);
+      if (gv->name) {
+        strncpy(gv->name,name,size);
+        gv->get_attr = get_attr;
+        gv->set_attr = set_attr;
+        gv->next = v->vars;
+      }
+    }
+    v->vars = gv;
+  }
+  
+  SWIGINTERN PyObject *
+  SWIG_globals() {
+    static PyObject *_SWIG_globals = 0; 
+    if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();  
+    return _SWIG_globals;
+  }
+  
+  /* -----------------------------------------------------------------------------
+   * constants/methods manipulation
+   * ----------------------------------------------------------------------------- */
+  
+  /* Install Constants */
+  SWIGINTERN void
+  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
+    PyObject *obj = 0;
+    size_t i;
+    for (i = 0; constants[i].type; ++i) {
+      switch(constants[i].type) {
+      case SWIG_PY_POINTER:
+        obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
+        break;
+      case SWIG_PY_BINARY:
+        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
+        break;
+      default:
+        obj = 0;
+        break;
+      }
+      if (obj) {
+        PyDict_SetItemString(d, constants[i].name, obj);
+        Py_DECREF(obj);
+      }
+    }
+  }
+  
+  /* -----------------------------------------------------------------------------*/
+  /* Fix SwigMethods to carry the callback ptrs when needed */
+  /* -----------------------------------------------------------------------------*/
+  
+  SWIGINTERN void
+  SWIG_Python_FixMethods(PyMethodDef *methods,
+    swig_const_info *const_table,
+    swig_type_info **types,
+    swig_type_info **types_initial) {
+    size_t i;
+    for (i = 0; methods[i].ml_name; ++i) {
+      char *c = methods[i].ml_doc;
+      if (c && (c = strstr(c, "swig_ptr: "))) {
+        int j;
+        swig_const_info *ci = 0;
+        char *name = c + 10;
+        for (j = 0; const_table[j].type; ++j) {
+          if (strncmp(const_table[j].name, name, 
+              strlen(const_table[j].name)) == 0) {
+            ci = &(const_table[j]);
+            break;
+          }
+        }
+        if (ci) {
+          size_t shift = (ci->ptype) - types;
+          swig_type_info *ty = types_initial[shift];
+          size_t ldoc = (c - methods[i].ml_doc);
+          size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
+          char *ndoc = (char*)malloc(ldoc + lptr + 10);
+          if (ndoc) {
+            char *buff = ndoc;
+            void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
+            if (ptr) {
+              strncpy(buff, methods[i].ml_doc, ldoc);
+              buff += ldoc;
+              strncpy(buff, "swig_ptr: ", 10);
+              buff += 10;
+              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
+              methods[i].ml_doc = ndoc;
+            }
+          }
+        }
+      }
+    }
+  } 
+  
+#ifdef __cplusplus
+}
+#endif
+
+/* -----------------------------------------------------------------------------*
+ *  Partial Init method
+ * -----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+#endif
+SWIGEXPORT void SWIG_init(void) {
+  PyObject *m, *d;
+  
+  /* Fix SwigMethods to carry the callback ptrs when needed */
+  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
+  
+  m = Py_InitModule((char *) SWIG_name, SwigMethods);
+  d = PyModule_GetDict(m);
+  
+  SWIG_InitializeModule(0);
+  SWIG_InstallConstants(d,swig_const_table);
+  
+  
+  PyDict_SetItemString(d,(char*)"cvar", SWIG_globals());
+  SWIG_addvarlink(SWIG_globals(),(char*)"tw_sound",tw_sound_get, tw_sound_set);
+}
+

Modified: trunk/source/melee/mcbodies.cpp
===================================================================
--- trunk/source/melee/mcbodies.cpp	2006-01-18 05:03:58 UTC (rev 207)
+++ trunk/source/melee/mcbodies.cpp	2006-05-08 11:32:42 UTC (rev 208)
@@ -31,6 +31,7 @@
 #include "mgame.h"
 #include "other/twconfig.h"
 
+
 Asteroid::Asteroid() 
 :	SpaceObject(NULL, random(map_size), random(PI2), game->meleedata.asteroidSprite), explosion(game->meleedata.asteroidExplosionSprite)
 {
@@ -380,23 +381,25 @@
   int i;
   v = NULL;
   set_depth(DEPTH_STARS);
-  DATAFILE *stardat = load_datafile(data_full_path("stars.dat").c_str());
-  if (!stardat) 
-    {
-      tw_error("stars.dat not found!");
-      num_pics = 0;
-      pic = NULL;
-      num_stars = 0;
-      num_layers = 0;
-      return;
-    }
-  for (i = 0; (stardat[i].type == DAT_RLE_SPRITE) || (stardat[i].type == DAT_BITMAP); i += 1) ;
-  num_pics = i;
+
+  num_pics = 19;
   pic = new SpaceSprite*[num_pics];
   seed = rng.raw64();
   for(i = 0; i < num_pics; i++) 
     {
-      pic[i] = new SpaceSprite(&stardat[i], 1, 
+      char tmp[256];
+      char* ptmp = tmp;
+      sprintf(tmp, "images/stars/star%3d.bmp", i+1);
+      while(*ptmp)
+        {
+	  if(*ptmp == ' ')
+	    *ptmp = '0';
+	  ptmp++;
+        }
+      std::vector<std::string> star;
+      star.push_back(tmp);
+      
+      pic[i] = new SpaceSprite(star, 1, 
 			       SpaceSprite::ALPHA | 
 			       SpaceSprite::MASKED | 
 			       SpaceSprite::IRREGULAR | 
@@ -411,7 +414,6 @@
   field_depth = get_config_int("Stars", "Depth", 192);
   tw_set_config_file("client.ini");
   aa_mode = get_config_int("Stars", "Quality", 5);
-  unload_datafile(stardat);
 }
 Stars::~Stars() 
 {



From yurand at berlios.de  Mon May  8 14:42:19 2006
From: yurand at berlios.de (yurand at BerliOS)
Date: Mon, 8 May 2006 14:42:19 +0200
Subject: [Tw-light-svn] r209 - in trunk: gamedata gamedata/games/test_game/scripts/systems gamedata/images gamedata/images/stations source source/games source/generated source/melee source/tml
Message-ID: <200605081242.k48CgJJt023559@sheep.berlios.de>

Author: yurand
Date: 2006-05-08 14:41:42 +0200 (Mon, 08 May 2006)
New Revision: 209

Added:
   trunk/gamedata/images/defender.bmp
   trunk/gamedata/images/stations/
   trunk/gamedata/images/stations/station0picture.bmp
   trunk/gamedata/images/stations/station0sprite.bmp
   trunk/gamedata/images/stations/station1picture.bmp
   trunk/gamedata/images/stations/station1sprite.bmp
   trunk/gamedata/images/stations/station2picture.bmp
   trunk/gamedata/images/stations/station2sprite.bmp
Removed:
   trunk/gamedata/gob.dat
Modified:
   trunk/gamedata/games/test_game/scripts/systems/gamaonyx.py
   trunk/gamedata/games/test_game/scripts/systems/ixis.py
   trunk/gamedata/games/test_game/scripts/systems/narike.py
   trunk/source/games/gdefender.cpp
   trunk/source/games/ggob.cpp
   trunk/source/games/ggob.h
   trunk/source/generated/tml_wrap.cpp
   trunk/source/melee.h
   trunk/source/melee/msprite.cpp
   trunk/source/tml/gameaction.cpp
   trunk/source/tml/gameaction.h
Log:
removed gob.dat

Modified: trunk/gamedata/games/test_game/scripts/systems/gamaonyx.py
===================================================================
--- trunk/gamedata/games/test_game/scripts/systems/gamaonyx.py	2006-05-08 11:32:42 UTC (rev 208)
+++ trunk/gamedata/games/test_game/scripts/systems/gamaonyx.py	2006-05-08 12:41:42 UTC (rev 209)
@@ -9,9 +9,8 @@
 
 gflag.gamaonyx_drax_station = tml.GameAction.add_orbiter_station('Gama Onyx',
                            'I',
-                           'gob.dat',
-                           'station0sprite',
-                           'gob.dat#station0picture.bmp',
+                           'images/stations/station0sprite.bmp',
+                           'images/stations/station0picture.bmp',
                            'dragr',
                            'dialogs/drax.xml')
 

Modified: trunk/gamedata/games/test_game/scripts/systems/ixis.py
===================================================================
--- trunk/gamedata/games/test_game/scripts/systems/ixis.py	2006-05-08 11:32:42 UTC (rev 208)
+++ trunk/gamedata/games/test_game/scripts/systems/ixis.py	2006-05-08 12:41:42 UTC (rev 209)
@@ -11,17 +11,15 @@
 
 gflag.ixis_mining_station = tml.GameAction.add_orbiter_station('Ixis',
                                                              'I',
-                                                             'gob.dat',
-                                                             'station0sprite',
-                                                             'gob.dat#station0picture.bmp',
+                                                             'images/stations/station0sprite.bmp',
+                                                             'images/stations/station0picture.bmp',
                                                              'earcr',
                                                              'dialogs/ixis_mining_station_commander.xml')
 
 gflag.ixis_chorali_station = tml.GameAction.add_orbiter_station('Ixis',
                                                              '2',
-                                                             'gob.dat',
-                                                             'station0sprite',
-                                                             'gob.dat#station0picture.bmp',
+                                                             'images/stations/station0sprite.bmp',
+                                                             'images/stations/station0picture.bmp',
                                                              'choex',
                                                              'dialogs/chorali_commander.xml')
 for i in xrange(20):

Modified: trunk/gamedata/games/test_game/scripts/systems/narike.py
===================================================================
--- trunk/gamedata/games/test_game/scripts/systems/narike.py	2006-05-08 11:32:42 UTC (rev 208)
+++ trunk/gamedata/games/test_game/scripts/systems/narike.py	2006-05-08 12:41:42 UTC (rev 209)
@@ -7,9 +7,8 @@
 tml.GameAction.add_planet('Narike','Silcuu', 0, 0)
 gflag.ixis_mining_station = tml.GameAction.add_orbiter_station('Narike',
                                                              'Silcuu',
-                                                             'gob.dat',
-                                                             'station0sprite',
-                                                             'gob.dat#station0picture.bmp',
+                                                             'images/stations/station0sprite.bmp',
+                                                             'images/stations/station0picture.bmp',
                                                              'earcr',
                                                              'dialogs/welcomecommander.xml')
 for i in xrange(20):

Deleted: trunk/gamedata/gob.dat
===================================================================
(Binary files differ)

Added: trunk/gamedata/images/defender.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/defender.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stations/station0picture.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stations/station0picture.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stations/station0sprite.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stations/station0sprite.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stations/station1picture.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stations/station1picture.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stations/station1sprite.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stations/station1sprite.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stations/station2picture.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stations/station2picture.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stations/station2sprite.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stations/station2sprite.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/source/games/gdefender.cpp
===================================================================
--- trunk/source/games/gdefender.cpp	2006-05-08 11:32:42 UTC (rev 208)
+++ trunk/source/games/gdefender.cpp	2006-05-08 12:41:42 UTC (rev 209)
@@ -269,13 +269,8 @@
   player = create_control ( channel_server, "Human" );
   add_focus(player);
   
-  DATAFILE *tmpdata; 
-  tmpdata = load_datafile_object(data_full_path("gob.dat").c_str(), "station0sprite");
-  if (!tmpdata) 
-    tw_error( "couldn't find gob.dat#station0sprite");
-  stationsprite = new SpaceSprite(tmpdata, 1, SpaceSprite::MASKED, 64);
+  stationsprite = new SpaceSprite("images/stations/station0sprite.bmp", SpaceSprite::MASKED, 64);
   stationsprite->permanent_phase_shift(8);
-  unload_datafile_object(tmpdata);
 
   this->change_view("Hero");  
   restart();

Modified: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2006-05-08 11:32:42 UTC (rev 208)
+++ trunk/source/games/ggob.cpp	2006-05-08 12:41:42 UTC (rev 209)
@@ -278,17 +278,10 @@
   */
 }
 
-SpaceSprite* GobGame::LoadStationSprite(std::string datafile, std::string name)
+SpaceSprite* GobGame::LoadStationSprite(std::string name)
 {
   STACKTRACE;
-  DATAFILE *tmpdata; 
-  tmpdata = load_datafile_object(datafile.c_str(), name.c_str());
-  if (!tmpdata) 
-    {
-      tw_error( (std::string("couldn't find ") + datafile +  " " + name).c_str() );
-    }
-  SpaceSprite* ss = new SpaceSprite(tmpdata, 1, SpaceSprite::MASKED | SpaceSprite::MIPMAPED, 64);
-  unload_datafile_object(tmpdata);
+  SpaceSprite* ss = new SpaceSprite(name, SpaceSprite::MASKED | SpaceSprite::MIPMAPED, 64);
   ss->permanent_phase_shift(8);  
   return ss;
 }
@@ -353,14 +346,7 @@
 GobGame::GobGame()
 {
   STACKTRACE;
-  DATAFILE *tmpdata; 
-  tmpdata = load_datafile_object(data_full_path("gob.dat").c_str(), "defender");
-  if (!tmpdata) 
-    tw_error ("couldn't find gob.dat#defender");
-  defenderSprite = new SpaceSprite(tmpdata, 1, SpaceSprite::MASKED | SpaceSprite::MIPMAPED);
-  unload_datafile_object(tmpdata);  
-
-  //  num_planets = 0;
+  defenderSprite = new SpaceSprite("images/defender.bmp", SpaceSprite::MASKED | SpaceSprite::MIPMAPED);
 }
 
 GobGame::~GobGame() {
@@ -406,7 +392,6 @@
 
 int GobGame::add_orbiter_station(const std::string& system, 
                  const std::string& planet, 
-                 const std::string& gatafile,
                  const std::string& station_sprite,
                  const std::string& background_picture,
                  const std::string& buildtype,
@@ -418,7 +403,7 @@
     {
       tw_error("Unable to find planet!!!");
     }
-  SpaceSprite *s_sprite = LoadStationSprite(data_full_path(gatafile), station_sprite);
+  SpaceSprite *s_sprite = LoadStationSprite(station_sprite);
   GobStation *gs = new GobStation(s_sprite, p, buildtype.c_str(), background_picture.c_str());
   gs->collide_flag_sameship = ALL_LAYERS;
   gs->collide_flag_sameteam = ALL_LAYERS;

Modified: trunk/source/games/ggob.h
===================================================================
--- trunk/source/games/ggob.h	2006-05-08 11:32:42 UTC (rev 208)
+++ trunk/source/games/ggob.h	2006-05-08 12:41:42 UTC (rev 209)
@@ -191,7 +191,7 @@
   SpaceSprite *defenderSprite;
 
  protected:
-  SpaceSprite* LoadStationSprite(std::string datafile, std::string name);
+  SpaceSprite* LoadStationSprite(std::string name);
   virtual bool handle_key(int k);
 
   /// Save game 
@@ -204,7 +204,6 @@
  public:
   int add_orbiter_station(const std::string& system, 
                const std::string& planet, 
-               const std::string& gatafile,
                const std::string& station_sprite,
                const std::string& background_picture,
                const std::string& buildtype,

Modified: trunk/source/generated/tml_wrap.cpp
===================================================================
--- trunk/source/generated/tml_wrap.cpp	2006-05-08 11:32:42 UTC (rev 208)
+++ trunk/source/generated/tml_wrap.cpp	2006-05-08 12:41:42 UTC (rev 209)
@@ -4303,7 +4303,6 @@
   std::string *arg4 = 0 ;
   std::string *arg5 = 0 ;
   std::string *arg6 = 0 ;
-  std::string *arg7 = 0 ;
   int result;
   int res1 = SWIG_OLDOBJ ;
   int res2 = SWIG_OLDOBJ ;
@@ -4311,16 +4310,14 @@
   int res4 = SWIG_OLDOBJ ;
   int res5 = SWIG_OLDOBJ ;
   int res6 = SWIG_OLDOBJ ;
-  int res7 = SWIG_OLDOBJ ;
   PyObject * obj0 = 0 ;
   PyObject * obj1 = 0 ;
   PyObject * obj2 = 0 ;
   PyObject * obj3 = 0 ;
   PyObject * obj4 = 0 ;
   PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
   
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:GameAction_add_orbiter_station",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
+  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:GameAction_add_orbiter_station",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
   {
     std::string *ptr = (std::string *)0;
     res1 = SWIG_AsPtr_std_string(obj0, &ptr);
@@ -4387,18 +4384,7 @@
     }
     arg6 = ptr;
   }
-  {
-    std::string *ptr = (std::string *)0;
-    res7 = SWIG_AsPtr_std_string(obj6, &ptr);
-    if (!SWIG_IsOK(res7)) {
-      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "GameAction_add_orbiter_station" "', argument " "7"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GameAction_add_orbiter_station" "', argument " "7"" of type '" "std::string const &""'"); 
-    }
-    arg7 = ptr;
-  }
-  result = (int)GameAction::add_orbiter_station((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,(std::string const &)*arg6,(std::string const &)*arg7);
+  result = (int)GameAction::add_orbiter_station((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,(std::string const &)*arg6);
   resultobj = SWIG_From_int(static_cast< int >(result));
   if (SWIG_IsNewObj(res1)) delete arg1;
   if (SWIG_IsNewObj(res2)) delete arg2;
@@ -4406,7 +4392,6 @@
   if (SWIG_IsNewObj(res4)) delete arg4;
   if (SWIG_IsNewObj(res5)) delete arg5;
   if (SWIG_IsNewObj(res6)) delete arg6;
-  if (SWIG_IsNewObj(res7)) delete arg7;
   return resultobj;
 fail:
   if (SWIG_IsNewObj(res1)) delete arg1;
@@ -4415,7 +4400,6 @@
   if (SWIG_IsNewObj(res4)) delete arg4;
   if (SWIG_IsNewObj(res5)) delete arg5;
   if (SWIG_IsNewObj(res6)) delete arg6;
-  if (SWIG_IsNewObj(res7)) delete arg7;
   return NULL;
 }
 

Modified: trunk/source/melee/msprite.cpp
===================================================================
--- trunk/source/melee/msprite.cpp	2006-05-08 11:32:42 UTC (rev 208)
+++ trunk/source/melee/msprite.cpp	2006-05-08 12:41:42 UTC (rev 209)
@@ -644,8 +644,7 @@
 }
 
 
-
-SpaceSprite::SpaceSprite(std::vector<std::string> bmplist, int sprite_count, int _attributes, int rotations)
+void SpaceSprite::create_sprite(std::vector<std::string> bmplist, int sprite_count, int _attributes, int rotations)
 {
   STACKTRACE;
   int i, j, obpp=0;
@@ -734,21 +733,6 @@
       return;//end of irregular/masked 
     }
   
-  /*
-  for(i = 1; i < sprite_count; i++) 
-    {
-      if ((w != ((BITMAP *)images[i].dat)->w) || 
-	  (h != ((BITMAP *)images[i].dat)->h) ) 
-	{
-	  tw_error("SpaceSprite - size changed");
-	}
-      if (bitmap_color_depth((BITMAP *)images[i].dat) != obpp) 
-	{
-	  tw_error("SpaceSprite - changing source color depth not yet allowed");
-	}
-    }
-  */
-
   m = new PMASK*[count];
   b[0] = new BITMAP*    [count];
   attributes  = new char [count];
@@ -808,6 +792,20 @@
   return;//end of normal/masked/autorotated
 }
 
+SpaceSprite::SpaceSprite(std::string bmp, int _attributes, int rotations)
+{
+  STACKTRACE;
+  std::vector<std::string> s;
+  s.push_back(bmp);
+  create_sprite(s, 1, _attributes, rotations);
+}
+
+SpaceSprite::SpaceSprite(std::vector<std::string> bmplist, int sprite_count, int _attributes, int rotations)
+{
+  STACKTRACE;
+  create_sprite(bmplist, sprite_count, _attributes, rotations);
+}
+
 void SpaceSprite::lock() 
 {
   STACKTRACE;

Modified: trunk/source/melee.h
===================================================================
--- trunk/source/melee.h	2006-05-08 11:32:42 UTC (rev 208)
+++ trunk/source/melee.h	2006-05-08 12:41:42 UTC (rev 209)
@@ -452,6 +452,10 @@
   /// (int)size.abs()*1000 + index  - key for bitmap
   std::map<int,BITMAP*> _cache;
 
+  void create_sprite(std::vector<std::string> bmplist, int sprite_count,  
+	       int _attributes = -1, 
+	       int rotations =1);
+	       
   int references;
   char *attributes;
   enum 
@@ -478,7 +482,8 @@
   SpaceSprite(BITMAP *image, int _attributes = -1);
   SpaceSprite(SpaceSprite &old);
  
-  SpaceSprite( std::vector<std::string> bmplist, int sprite_count,  
+  SpaceSprite(std::string bmplist, int _attributes = -1, int rotations =1);
+  SpaceSprite(std::vector<std::string> bmplist, int sprite_count,  
 	       int _attributes = -1, 
 	       int rotations =1);
   virtual ~SpaceSprite();

Modified: trunk/source/tml/gameaction.cpp
===================================================================
--- trunk/source/tml/gameaction.cpp	2006-05-08 11:32:42 UTC (rev 208)
+++ trunk/source/tml/gameaction.cpp	2006-05-08 12:41:42 UTC (rev 209)
@@ -54,14 +54,13 @@
 
 int GameAction::add_orbiter_station(const std::string& system, 
 			     const std::string& planet, 
-			     const std::string& gatafile,
 			     const std::string& station_sprite,
 			     const std::string& background_picture,
 			     const std::string& buildtype,
 			     const std::string& commander_dialog)
 {
   STACKTRACE;
-  return gobgame->add_orbiter_station(system, planet, gatafile,station_sprite, background_picture, buildtype,commander_dialog);
+  return gobgame->add_orbiter_station(system, planet, station_sprite, background_picture, buildtype,commander_dialog);
 }
 
 int GameAction::add_asteroid(const std::string& system, double x, double y, double oangle, double speed)

Modified: trunk/source/tml/gameaction.h
===================================================================
--- trunk/source/tml/gameaction.h	2006-05-08 11:32:42 UTC (rev 208)
+++ trunk/source/tml/gameaction.h	2006-05-08 12:41:42 UTC (rev 209)
@@ -58,7 +58,6 @@
   /// @return station id
   static int add_orbiter_station(const std::string& system, 
 			     const std::string& planet, 
-			     const std::string& gatafile,
 			     const std::string& station_sprite,
 			     const std::string& background_picture,
 			     const std::string& buildtype,



