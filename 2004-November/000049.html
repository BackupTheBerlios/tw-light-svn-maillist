<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Tw-light-svn] r101 - trunk/source/libraries/raknet
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/tw-light-svn/2004-November/index.html" >
   <LINK REL="made" HREF="mailto:tw-light-svn%40lists.berlios.de?Subject=Re%3A%20%5BTw-light-svn%5D%20r101%20-%20trunk/source/libraries/raknet&In-Reply-To=%3C200411281715.iASHFu0w014812%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000048.html">
   <LINK REL="Next"  HREF="000050.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Tw-light-svn] r101 - trunk/source/libraries/raknet</H1>
    <B>Yura Semashko at BerliOS</B> 
    <A HREF="mailto:tw-light-svn%40lists.berlios.de?Subject=Re%3A%20%5BTw-light-svn%5D%20r101%20-%20trunk/source/libraries/raknet&In-Reply-To=%3C200411281715.iASHFu0w014812%40sheep.berlios.de%3E"
       TITLE="[Tw-light-svn] r101 - trunk/source/libraries/raknet">yurand at sheep.berlios.de
       </A><BR>
    <I>Sun Nov 28 18:15:56 CET 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000048.html">[Tw-light-svn] r100 - in trunk: gamedata/default_ini source/util
</A></li>
        <LI>Next message: <A HREF="000050.html">[Tw-light-svn] r102 - trunk/source/libraries/raknet
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#49">[ date ]</a>
              <a href="thread.html#49">[ thread ]</a>
              <a href="subject.html#49">[ subject ]</a>
              <a href="author.html#49">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: yurand
Date: 2004-11-28 18:15:55 +0100 (Sun, 28 Nov 2004)
New Revision: 101

Modified:
   trunk/source/libraries/raknet/ArrayList.h
   trunk/source/libraries/raknet/AsynchronousFileIO.cpp
   trunk/source/libraries/raknet/BinarySearchTree.h
   trunk/source/libraries/raknet/BitStream.cpp
   trunk/source/libraries/raknet/BitStream.h
   trunk/source/libraries/raknet/ClientContextStruct.h
   trunk/source/libraries/raknet/DataBlockEncryptor.cpp
   trunk/source/libraries/raknet/DataBlockEncryptor.h
   trunk/source/libraries/raknet/DistributedNetworkObject.cpp
   trunk/source/libraries/raknet/DistributedNetworkObject.h
   trunk/source/libraries/raknet/DistributedNetworkObjectHeader.h
   trunk/source/libraries/raknet/DistributedNetworkObjectManager.cpp
   trunk/source/libraries/raknet/EncodeClassName.cpp
   trunk/source/libraries/raknet/GetTime.cpp
   trunk/source/libraries/raknet/GetTime.h
   trunk/source/libraries/raknet/HuffmanEncodingTree.cpp
   trunk/source/libraries/raknet/HuffmanEncodingTree.h
   trunk/source/libraries/raknet/InternalPacket.h
   trunk/source/libraries/raknet/InternalPacketPool.cpp
   trunk/source/libraries/raknet/LinkedList.h
   trunk/source/libraries/raknet/Multiplayer.h
   trunk/source/libraries/raknet/NetworkTypes.cpp
   trunk/source/libraries/raknet/NetworkTypes.h
   trunk/source/libraries/raknet/PacketEnumerations.h
   trunk/source/libraries/raknet/PacketPriority.h
   trunk/source/libraries/raknet/Queue.h
   trunk/source/libraries/raknet/RakClient.cpp
   trunk/source/libraries/raknet/RakClient.h
   trunk/source/libraries/raknet/RakClientInterface.h
   trunk/source/libraries/raknet/RakNetworkFactory.h
   trunk/source/libraries/raknet/RakPeer.cpp
   trunk/source/libraries/raknet/RakPeer.h
   trunk/source/libraries/raknet/RakPeerInterface.h
   trunk/source/libraries/raknet/RakServer.cpp
   trunk/source/libraries/raknet/RakServer.h
   trunk/source/libraries/raknet/RakServerInterface.h
   trunk/source/libraries/raknet/ReliabilityLayer.cpp
   trunk/source/libraries/raknet/ReliabilityLayer.h
   trunk/source/libraries/raknet/SHA1.h
   trunk/source/libraries/raknet/SimpleMutex.cpp
   trunk/source/libraries/raknet/SimpleMutex.h
   trunk/source/libraries/raknet/SocketLayer.cpp
   trunk/source/libraries/raknet/SocketLayer.h
   trunk/source/libraries/raknet/StringCompressor.cpp
   trunk/source/libraries/raknet/StringCompressor.h
Log:
Updating RakNet sources to latest version since they fixed some compile 
errors


Modified: trunk/source/libraries/raknet/ArrayList.h
===================================================================
--- trunk/source/libraries/raknet/ArrayList.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/ArrayList.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -125,11 +125,7 @@
 template &lt;class list_type&gt;
 inline list_type&amp; List&lt;list_type&gt;::operator[] (unsigned long position)
 {
-	if (position &gt;= list_size)
-	{
-		assert(0); // Reading past the end of the list
-		return array[0];
-	}
+	assert (position &lt; list_size);
 	return array[position];
 }
 

Modified: trunk/source/libraries/raknet/AsynchronousFileIO.cpp
===================================================================
--- trunk/source/libraries/raknet/AsynchronousFileIO.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/AsynchronousFileIO.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -269,7 +269,7 @@
 				{
 					assert(dwIoSize&gt;0);
 
-					ProcessNetworkPacket(lpOverlapped-&gt;playerId.binaryAddress, lpOverlapped-&gt;playerId.port, lpOverlapped-&gt;data, dwIoSize, lpOverlapped-&gt;rakPeer);
+					ProcessNetworkPacket(lpOverlapped-&gt;binaryAddress, lpOverlapped-&gt;port, lpOverlapped-&gt;data, dwIoSize, lpOverlapped-&gt;rakPeer);
 	
 					// Issue a new read so we always have one outstanding read per socket
 					// Finished a read.  Reuse the overlapped pointer

Modified: trunk/source/libraries/raknet/BinarySearchTree.h
===================================================================
--- trunk/source/libraries/raknet/BinarySearchTree.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/BinarySearchTree.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -52,6 +52,8 @@
 The assignment operator is defined between BinarySearchTree and AVLBalancedBinarySearchTree as long as they are of the same template type. However, passing a BinarySearchTree to an AVLBalancedBinarySearchTree will lose its structure unless it happened to be AVL balanced to begin with
 Requires queue_linked_list.cpp for the breadth first search used in the copy constructor, overloaded assignment operator, and display_breadth_first_search.
 
+9/04 Giblet - updated code to work with new compilers adhering more closely to ISO standard
+
 */
 
 #ifndef __BINARY_SEARCH_TREE_H
@@ -156,7 +158,7 @@
 				break;
 		}
 
-		if (current==root)
+		if (current==this-&gt;root)
 			break;
 
 		current=find_parent(*(current-&gt;item));
@@ -234,11 +236,11 @@
 	if (A)
 	{
 		// Direction was set by the last find_parent call
-		if (direction==LEFT) A-&gt;left=C;
+		if (this-&gt;direction==this-&gt;LEFT) A-&gt;left=C;
 			else A-&gt;right=C;
 	}
 	else
-		root=C;  // If B has no parent parent then B must have been the root node
+		this-&gt;root=C;  // If B has no parent parent then B must have been the root node
 
 	B-&gt;left = D;
 	C-&gt;right = B;
@@ -293,11 +295,11 @@
 	if (A)
 	{
 		// Direction was set by the last find_parent call
-		if (direction==LEFT) A-&gt;left=C;
+		if (this-&gt;direction==this-&gt;LEFT) A-&gt;left=C;
 			else A-&gt;right=C;
 	}
 	else
-		root=C;  // If B has no parent parent then B must have been the root node
+		this-&gt;root=C;  // If B has no parent parent then B must have been the root node
 
 	B-&gt;right = D;
 	C-&gt;left = B;
@@ -314,7 +316,7 @@
 template &lt;class BinarySearchTreeType&gt;
 AVLBalancedBinarySearchTree&lt;BinarySearchTreeType&gt;::~AVLBalancedBinarySearchTree()
 {
-	clear();
+	this-&gt;clear();
 }
 
 template &lt;class BinarySearchTreeType&gt;
@@ -358,7 +360,7 @@
 template &lt;class BinarySearchTreeType&gt;
 BinarySearchTree&lt;BinarySearchTreeType&gt;::~BinarySearchTree()
 {
-	clear();
+	this-&gt;clear();
 }
 
 template &lt;class BinarySearchTreeType&gt;
@@ -367,7 +369,7 @@
 	static typename BinarySearchTree::node* tempnode;
 	static BinarySearchTreeType* dummyptr=0;
 	tempnode = find (element, &amp;tempnode);
-	if (direction==NOT_FOUND)
+	if (this-&gt;direction==this-&gt;NOT_FOUND)
 		return dummyptr;
 
 	return tempnode-&gt;item;
@@ -378,24 +380,24 @@
 {
 	static typename BinarySearchTree::node* current;
 
-	current=root;
+	current=this-&gt;root;
 	*parent=0;
-	direction=ROOT;
+	this-&gt;direction=this-&gt;ROOT;
 
 	if (BinarySearchTree_size==0L) 
 	{
-		direction=NOT_FOUND;
+		this-&gt;direction=this-&gt;NOT_FOUND;
 		return current=0;
 	}
 
 	// Check if the item is at the root
-	if (element == *(current-&gt;item)) {direction=ROOT; return current;}
+	if (element == *(current-&gt;item)) {this-&gt;direction=this-&gt;ROOT; return current;}
 
 	while (true)
 	{	
 		// Move pointer
-		if (element &lt; *(current-&gt;item)) {*parent=current; direction=LEFT; current=current-&gt;left;}
-		else if (element &gt; *(current-&gt;item)) {*parent=current; direction=RIGHT; current=current-&gt;right;}
+		if (element &lt; *(current-&gt;item)) {*parent=current; this-&gt;direction=this-&gt;LEFT; current=current-&gt;left;}
+		else if (element &gt; *(current-&gt;item)) {*parent=current; this-&gt;direction=this-&gt;RIGHT; current=current-&gt;right;}
 		
 		if (current==0) break;
 
@@ -404,7 +406,7 @@
 	}
 	
 
-	direction=NOT_FOUND;
+	this-&gt;direction=this-&gt;NOT_FOUND;
 	return current=0;
 }
 

Modified: trunk/source/libraries/raknet/BitStream.cpp
===================================================================
--- trunk/source/libraries/raknet/BitStream.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/BitStream.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -26,6 +26,8 @@
 #include &lt;stdio.h&gt;
 #include &lt;string.h&gt;
 
+using namespace RakNet;
+
 BitStream::BitStream()
 {
 	numberOfBitsUsed=0;
@@ -35,7 +37,7 @@
 #ifdef _DEBUG
 	assert(data);
 #endif
-	memset(data, 0, 32);
+	//memset(data, 0, 32);
 	copyData=true;
 }
 
@@ -48,7 +50,7 @@
 	#ifdef _DEBUG
 	assert(data);
 	#endif
-	memset(data, 0, initialBytesToAllocate);
+//	memset(data, 0, initialBytesToAllocate);
 	copyData=true;
 }
 
@@ -92,14 +94,18 @@
 
 void BitStream::Reset(void)
 {
+	if (numberOfBitsUsed&gt;0)
+	{
+//		memset(data, 0, BITS_TO_BYTES(numberOfBitsUsed));
+	}
 	// Don't free memory here for speed efficiency
 	//free(data);  // Use realloc and free so we are more efficient than delete and new for resizing
 	numberOfBitsUsed=0;
 	//numberOfBitsAllocated=8;
 	readOffset=0;
 	//data=(unsigned char*)malloc(1);
-	if (numberOfBitsAllocated&gt;0)
-		memset(data, 0, BITS_TO_BYTES(numberOfBitsAllocated));
+//	if (numberOfBitsAllocated&gt;0)
+//		memset(data, 0, BITS_TO_BYTES(numberOfBitsAllocated));
 }
 
 // Write the native types to the end of the buffer
@@ -598,8 +604,11 @@
 {
 	AddBitsAndReallocate(1);
 
-	// New bits are set to 0 as default
-	numberOfBitsUsed++;
+	// New bytes need to be zeroed
+	if ((numberOfBitsUsed%8)==0)
+		data[numberOfBitsUsed&gt;&gt;3] = 0;
+
+	numberOfBitsUsed++; // This ++ was in the line above - but boundschecker didn't like that for some reason.
 }
 
  // Write a 1
@@ -607,7 +616,12 @@
 {
 	AddBitsAndReallocate(1);
 
-	data[numberOfBitsUsed&gt;&gt;3] |= 0x80 &gt;&gt; (numberOfBitsUsed%8); // Set the bit to 1
+	int numberOfBitsMod8 = numberOfBitsUsed%8;
+	if (numberOfBitsMod8==0)
+		data[numberOfBitsUsed&gt;&gt;3] = 0x80;
+	else
+		data[numberOfBitsUsed&gt;&gt;3] |= 0x80 &gt;&gt; (numberOfBitsMod8); // Set the bit to 1
+	
 	numberOfBitsUsed++; // This ++ was in the line above - but boundschecker didn't like that for some reason.
 }
 
@@ -681,8 +695,8 @@
 // Write numberToWrite bits from the input source
 void BitStream::WriteBits(unsigned char *input, int numberOfBitsToWrite, bool rightAlignedBits)
 {
-	if (numberOfBitsToWrite&lt;=0)
-		return;
+//	if (numberOfBitsToWrite&lt;=0)
+//		return;
 
 	AddBitsAndReallocate(numberOfBitsToWrite);
 	int offset=0;
@@ -691,19 +705,31 @@
 
 	numberOfBitsUsedMod8=numberOfBitsUsed%8;
 
-	do
+	// Faster to put the while at the top surprisingly enough
+	while(numberOfBitsToWrite&gt;0)
+	//do
 	{
 		dataByte = *(input+offset);
 		if (numberOfBitsToWrite&lt;8 &amp;&amp; rightAlignedBits) // rightAlignedBits means in the case of a partial byte, the bits are aligned from the right (bit 0) rather than the left (as in the normal internal representation)
 			dataByte&lt;&lt;=8-numberOfBitsToWrite;	 // shift left to get the bits on the left, as in our internal representation
 
-		// Copy over the new data.
-		*(data+(numberOfBitsUsed&gt;&gt;3)) |= dataByte &gt;&gt; (numberOfBitsUsedMod8); // First half
-		if (8 - (numberOfBitsUsedMod8) &lt; 8 &amp;&amp; 8 - (numberOfBitsUsedMod8) &lt; numberOfBitsToWrite) // If we didn't write it all out in the first half (8 - (numberOfBitsUsed%8) is the number we wrote in the first half)
-			*(data+(numberOfBitsUsed&gt;&gt;3) + 1) |= (unsigned char)(dataByte &lt;&lt; (8 - (numberOfBitsUsedMod8))); // Second half (overlaps byte boundary)
-	
+		// Writing to a new byte each time
+		if (numberOfBitsUsedMod8==0)
+			*(data+(numberOfBitsUsed&gt;&gt;3)) = dataByte;
+		else
+		{
+			// Copy over the new data.
+			*(data+(numberOfBitsUsed&gt;&gt;3)) |= dataByte &gt;&gt; (numberOfBitsUsedMod8); // First half
+			if (8 - (numberOfBitsUsedMod8) &lt; 8 &amp;&amp; 8 - (numberOfBitsUsedMod8) &lt; numberOfBitsToWrite) // If we didn't write it all out in the first half (8 - (numberOfBitsUsed%8) is the number we wrote in the first half)
+			{
+				*(data+(numberOfBitsUsed&gt;&gt;3) + 1) = (unsigned char)(dataByte &lt;&lt; (8 - (numberOfBitsUsedMod8))); // Second half (overlaps byte boundary)
+			}
+		}
+
 		if (numberOfBitsToWrite&gt;=8)
+		{
 			numberOfBitsUsed+= 8;
+		}
 		else
 		{
 			numberOfBitsUsed+= numberOfBitsToWrite;
@@ -711,8 +737,8 @@
 		numberOfBitsToWrite-= 8;
 		
 		offset++;
-	} while(numberOfBitsToWrite&gt;0);
-
+	}
+//	} while(numberOfBitsToWrite&gt;0);
 }
 
 // Set the stream to some initial data.  For internal use
@@ -760,7 +786,7 @@
 			Write(b);
 
 			WriteBits(input,(currentByte+1)&lt;&lt;3, true);
-			currentByte--;
+	//		currentByte--;
 
 	
 			return;
@@ -793,8 +819,8 @@
 	#ifdef _DEBUG
 	assert(numberOfBitsToRead&gt;0);
 	#endif
-	if (numberOfBitsToRead&lt;=0)
-		return false;
+//	if (numberOfBitsToRead&lt;=0)
+//		return false;
 
 	if (readOffset+numberOfBitsToRead &gt;numberOfBitsUsed)
 		return false;
@@ -806,7 +832,9 @@
 
 	readOffsetMod8=readOffset%8;
 
-	do
+//	do
+	// Faster to put the while at the top surprisingly enough
+	while(numberOfBitsToRead&gt;0)
 	{
 			*(output + offset) |= *(data+(readOffset&gt;&gt;3)) &lt;&lt; (readOffsetMod8); // First half
 
@@ -825,7 +853,8 @@
 
 			offset++;
 
-	} while(numberOfBitsToRead&gt;0);
+	}
+	//} while(numberOfBitsToRead&gt;0);
 
 	return true;
 }
@@ -920,7 +949,7 @@
 		#ifdef _DEBUG
 		assert(data); // Make sure realloc succeeded
 		#endif
-		memset(data+newByteOffset, 0,  ((newNumberOfBitsAllocated-1)&gt;&gt;3) - ((numberOfBitsAllocated-1)&gt;&gt;3)); // Set the new data block to 0
+//		memset(data+newByteOffset, 0,  ((newNumberOfBitsAllocated-1)&gt;&gt;3) - ((numberOfBitsAllocated-1)&gt;&gt;3)); // Set the new data block to 0
 	}
 
 	if (newNumberOfBitsAllocated &gt; numberOfBitsAllocated)

Modified: trunk/source/libraries/raknet/BitStream.h
===================================================================
--- trunk/source/libraries/raknet/BitStream.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/BitStream.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -10,6 +10,9 @@
 #ifndef  __BITSTREAM_H
 #define __BITSTREAM_H
 
+namespace RakNet
+{
+
 #define BITS_TO_BYTES(x) (((x)+7)&gt;&gt;3)
 
 class BitStream
@@ -168,4 +171,6 @@
 	bool copyData;
 };
 
+}
+
 #endif

Modified: trunk/source/libraries/raknet/ClientContextStruct.h
===================================================================
--- trunk/source/libraries/raknet/ClientContextStruct.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/ClientContextStruct.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -30,7 +30,8 @@
 	OVERLAPPED overlapped;
 	char data[MAXIMUM_MTU_SIZE]; // Used to hold data to send
 	int length; // Length of the actual data to send, always under MAXIMUM_MTU_SIZE
-	PlayerID playerId;
+	unsigned long binaryAddress;
+	unsigned short port;
 	RakPeer *rakPeer;
 	bool read; // Set to true for reads, false for writes
 };

Modified: trunk/source/libraries/raknet/DataBlockEncryptor.cpp
===================================================================
--- trunk/source/libraries/raknet/DataBlockEncryptor.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/DataBlockEncryptor.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -9,6 +9,9 @@
 {
 	keySet=false;
 }
+DataBlockEncryptor::~DataBlockEncryptor()
+{
+}
 bool DataBlockEncryptor::IsKeySet(void) const
 {
 	return keySet;
@@ -40,21 +43,22 @@
 
 	assert(input &amp;&amp; inputLength);
 
+
 	// randomChar will randomize the data so the same data sent twice will not look the same
 	randomChar=(unsigned char)randomMT();
 
-
 	// 16-(((x-1) % 16)+1) 
 
 	// # of padding bytes is 16 -(((input_length + extra_data -1) % 16)+1)
 	paddingBytes = (unsigned char)(16 -(((inputLength + sizeof(randomChar)+sizeof(checkSum)+sizeof(encodedPad) -1) % 16)+1));
-	*outputLength=inputLength + sizeof(randomChar)+sizeof(checkSum)+sizeof(encodedPad)+paddingBytes;
 
 	// Randomize the pad size variable
 	encodedPad=(unsigned char)randomMT();
 	encodedPad&lt;&lt;=4;
 	encodedPad|=paddingBytes;
 
+	*outputLength=inputLength + sizeof(randomChar)+sizeof(checkSum)+sizeof(encodedPad)+paddingBytes;
+
 	// Write the data first, in case we are overwriting ourselves
 	if (input==output)
 		memmove(output+sizeof(checkSum)+sizeof(randomChar)+sizeof(encodedPad)+paddingBytes, input, inputLength);
@@ -108,9 +112,6 @@
 	
 	if (input==0 || inputLength&lt;16 || (inputLength % 16) != 0)
 	{
-#ifdef _DEBUG
-		assert(0);
-#endif
 		return false;
 	}
 
@@ -121,7 +122,7 @@
 
 		for (byteIndex=0; byteIndex&lt;16; byteIndex++)
 		{
-			if (index+16==inputLength)
+			if (index+16==(unsigned)inputLength)
 				input[index+byteIndex]^=input[byteIndex];
 			else
 				input[index+byteIndex]^=input[index+16+byteIndex];
@@ -142,10 +143,11 @@
 	// Ignore the high 4 bytes
 	paddingBytes=encodedPad&amp;0x0F;
 
+
 	// Get the data length
 	*outputLength=inputLength - sizeof(randomChar)-sizeof(checkSum)-sizeof(encodedPad)-paddingBytes;
 
-	// Calculate the checksum on the data
+	// Calculate the checksum on the data.
 	checkSumCalculator.add(input+sizeof(checkSum), *outputLength+sizeof(randomChar)+sizeof(encodedPad)+paddingBytes);
 	if (checkSum != checkSumCalculator.get())
 		return false;
@@ -156,5 +158,6 @@
 	else
 		memcpy(output, input+sizeof(randomChar)+sizeof(checkSum)+sizeof(encodedPad)+paddingBytes, *outputLength);
 
+
 	return true;
 }

Modified: trunk/source/libraries/raknet/DataBlockEncryptor.h
===================================================================
--- trunk/source/libraries/raknet/DataBlockEncryptor.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/DataBlockEncryptor.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -7,6 +7,7 @@
 {
 public:
 	DataBlockEncryptor();
+	~DataBlockEncryptor();
 	bool IsKeySet(void) const;
 
 	void SetKey(const unsigned char key[16]);

Modified: trunk/source/libraries/raknet/DistributedNetworkObject.cpp
===================================================================
--- trunk/source/libraries/raknet/DistributedNetworkObject.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/DistributedNetworkObject.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -17,6 +17,7 @@
 #include &lt;string.h&gt;
 #include &quot;DistributedNetworkObjectManager.h&quot;
 
+
 DistributedNetworkObject::DistributedNetworkObject()
 {
 	maximumUpdateFrequency=50; // 50 ms by default
@@ -35,8 +36,8 @@
 	if (DistributedNetworkObjectManager::Instance()-&gt;GetRakServerInterface())
 	{
 		// These 3 lines of code will broadcast to destroy the object
-		BitStream bitStream;
-		SerializeClassHeader(&amp;bitStream, 0, false, false, 0);
+		RakNet::BitStream bitStream;
+		SerializeClassHeader(&amp;bitStream, 0, 0, false, 0);
 		BroadcastSerializedClass(&amp;bitStream);
 	}
 
@@ -55,8 +56,8 @@
 void DistributedNetworkObject::DestroyObjectOnNetwork(void)
 {
 	// These 3 lines of code will broadcast to destroy the object
-	BitStream bitStream;
-	SerializeClassHeader(&amp;bitStream, 0, false, false, 0);
+	RakNet::BitStream bitStream;
+	SerializeClassHeader(&amp;bitStream, 0, 0, false, 0);
 	BroadcastSerializedClass(&amp;bitStream);
 
 	DistributedNetworkObjectManager::Instance()-&gt;UnregisterNetworkObject(this);
@@ -68,7 +69,7 @@
 	}
 }
 
-void DistributedNetworkObject::SynchronizeMemory(unsigned char memoryBlockIndex, char* memoryBlock, int memoryBlockSize, bool serverAuthority)
+void DistributedNetworkObject::SynchronizeMemory(unsigned char memoryBlockIndex, char* memoryBlock, unsigned short memoryBlockSize, bool serverAuthority)
 {
 	// Was memory previously allocated?
 	if (heapNodeList[memoryBlockIndex].lastWriteValue)
@@ -96,7 +97,7 @@
 	heapNodeList[memoryBlockIndex].watchedData=memoryBlock;
 
 	// Initialize nextUpdateTime to the current time.
-	heapNodeList[memoryBlockIndex].nextUpdateTime=getTime();
+	heapNodeList[memoryBlockIndex].nextUpdateTime=RakNetGetTime();
 
 	// Set the authority
 	heapNodeList[memoryBlockIndex].serverAuthority=serverAuthority;
@@ -130,12 +131,12 @@
 }
 // Same as ProcessDistributedMemoryStack, but for the heapNodeList.
 // Returns true if data was written
-bool DistributedNetworkObject::WriteToBitstreamFromHeap(BitStream *bitStream, bool forceWrite)
+bool DistributedNetworkObject::WriteToBitstreamFromHeap(RakNet::BitStream *bitStream, bool forceWrite)
 {
     int heapNodeIndex;
 	unsigned long time;
-	BitStream heapData(256);
-	time=getTime();
+	RakNet::BitStream heapData(256);
+	time=RakNetGetTime();
 	unsigned char numberOfBlocksWritten;
 
 	numberOfBlocksWritten=0;
@@ -143,7 +144,7 @@
 	for (heapNodeIndex=0; heapNodeIndex &lt; 256; heapNodeIndex++)
 	{
 		// Is this a block we are responsible for updating, and it is time to update?
-		if (IsMemoryBlockIndexUsed(heapNodeIndex) &amp;&amp;
+		if (IsMemoryBlockIndexUsed((unsigned char)heapNodeIndex) &amp;&amp;
 			forceWrite ||
 			(time &gt;= heapNodeList[heapNodeIndex].nextUpdateTime &amp;&amp;
 			((DistributedNetworkObjectManager::Instance()-&gt;GetRakServerInterface() &amp;&amp; heapNodeList[heapNodeIndex].serverAuthority) ||
@@ -172,24 +173,35 @@
 
 	if (numberOfBlocksWritten&gt;0)
 	{
+		bitStream-&gt;Write(true);
 		bitStream-&gt;WriteCompressed(numberOfBlocksWritten);
 		bitStream-&gt;Write((char*)heapData.GetData(), heapData.GetNumberOfBytesUsed());
 		return true;
 	}
+	else
+		bitStream-&gt;Write(false);
 
+	if (forceWrite)
+		WriteCreationData(bitStream);
+
 	return false;
 }
 
-void DistributedNetworkObject::WriteToHeapFromBitstream(BitStream *bitStream)
+void DistributedNetworkObject::WriteToHeapFromBitstream(RakNet::BitStream *bitStream)
 {
 	int index;
 	unsigned char heapNodeIndex;
 	unsigned char numberOfBlocksWritten;
+	bool anyDataWritten;
 
 #ifdef _DEBUG
 	unsigned short usedBlockSize;
 #endif
 
+	bitStream-&gt;Read(anyDataWritten);
+	if (anyDataWritten==false)
+		return;
+
 	bitStream-&gt;ReadCompressed(numberOfBlocksWritten);
 
 	for (index=0; index &lt; numberOfBlocksWritten; index++)
@@ -230,7 +242,7 @@
 }
 
 // Writes to or reads from a bitstream for all distributed memory.  This function does not need to be modified by the end-user
-bool DistributedNetworkObject::ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)
+bool DistributedNetworkObject::ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)
 {
 	return false;
 }
@@ -256,7 +268,7 @@
 	 (DistributedNetworkObjectManager::Instance()-&gt;GetRakClientInterface() &amp;&amp; DistributedNetworkObjectManager::Instance()-&gt;GetRakClientInterface()-&gt;IsConnected()))
 	{
 		char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH];
-		BitStream bitStream;
+		RakNet::BitStream bitStream;
 
 		if (isClassIDEncoded)
 			memcpy(classIdentifier, classID, MAXIMUM_CLASS_IDENTIFIER_LENGTH);
@@ -267,24 +279,34 @@
 		// The only purpose of registering and unregistering network objects is so we can call SendAllDistributedObjects from
 		// DistributedNetworkObjectManager to new players
 		firstTimeAddedToRegistry = DistributedNetworkObjectManager::Instance()-&gt;RegisterNetworkObject(this,classIdentifier, localObjectIdentifier);
+		if (serverProcess &amp;&amp; firstTimeAddedToRegistry &amp;&amp; isClassIDEncoded==false)
+		{
+			// This is like a local echo - call OnDistributedObjectCreation for the server when it is not
+			// created by the network
+			if (OnDistributedObjectCreation(UNASSIGNED_PLAYER_ID)==false)
+			{
+				DistributedNetworkObjectManager::Instance()-&gt;UnregisterNetworkObject(this);
+				return;
+			}
+		}
 
 		// This logic is correct - ProcessDistributedMemoryStack has a side effect of updating network memory to the last send so you don't
 		// want to call it unnecessarily
 		if (firstTimeAddedToRegistry &amp;&amp; (localObject || DistributedNetworkObjectManager::Instance()-&gt;GetRakServerInterface()))
 		{
-			SerializeClassHeader(&amp;bitStream, classIdentifier, true, firstTimeAddedToRegistry &amp;&amp; DistributedNetworkObjectManager::Instance()-&gt;GetRakClientInterface(), localObjectIdentifier);
+			SerializeClassHeader(&amp;bitStream, classIdentifier, 2, firstTimeAddedToRegistry &amp;&amp; DistributedNetworkObjectManager::Instance()-&gt;GetRakClientInterface(), localObjectIdentifier);
 			ProcessDistributedMemoryStack(&amp;bitStream, true, true,serverProcess);
-			WriteToBitstreamFromHeap(&amp;bitStream, true);
+			WriteToBitstreamFromHeap(&amp;bitStream, true);	
 			BroadcastSerializedClass(&amp;bitStream);
 		}
 		else if ((localObject == false || DistributedNetworkObjectManager::Instance()-&gt;GetRakServerInterface()) &amp;&amp;
-			getTime() &gt; lastBroadcastTime + maximumUpdateFrequency)
+			RakNetGetTime() &gt; lastBroadcastTime + maximumUpdateFrequency)
 		{
-			SerializeClassHeader(&amp;bitStream, classIdentifier, true, firstTimeAddedToRegistry &amp;&amp; DistributedNetworkObjectManager::Instance()-&gt;GetRakClientInterface(), localObjectIdentifier);
+			SerializeClassHeader(&amp;bitStream, classIdentifier, 1, firstTimeAddedToRegistry &amp;&amp; DistributedNetworkObjectManager::Instance()-&gt;GetRakClientInterface(), localObjectIdentifier);
 			dataWritten1=ProcessDistributedMemoryStack(&amp;bitStream, true, false,serverProcess);
 			dataWritten2=WriteToBitstreamFromHeap(&amp;bitStream, false);
 			if (dataWritten1 || dataWritten2)
-			{					
+			{
 				BroadcastSerializedClass(&amp;bitStream);
 			}
 		}
@@ -293,12 +315,20 @@
 	InterpolateDistributedMemory(serverProcess);
 }
 
+void DistributedNetworkObject::WriteCreationData(RakNet::BitStream *initialData)
+{
+}
+
+void DistributedNetworkObject::ReadCreationData(RakNet::BitStream *initialData)
+{
+}
+
 void DistributedNetworkObject::SetMaximumUpdateFrequency(unsigned long frequency)
 {
 	maximumUpdateFrequency=frequency;
 }
 
-void DistributedNetworkObject::BroadcastSerializedClass(BitStream *bitStream)
+void DistributedNetworkObject::BroadcastSerializedClass(RakNet::BitStream *bitStream)
 {
 	if (DistributedNetworkObjectManager::Instance()-&gt;GetRakServerInterface() &amp;&amp; DistributedNetworkObjectManager::Instance()-&gt;GetRakServerInterface()-&gt;IsActive())
 	{
@@ -310,28 +340,28 @@
 		}
 
 		DistributedNetworkObjectManager::Instance()-&gt;GetRakServerInterface()-&gt;Send(bitStream, HIGH_PRIORITY, RELIABLE_ORDERED, 0, localClient, true);
-		lastBroadcastTime=getTime();
+		lastBroadcastTime=RakNetGetTime();
 	}
 	else if (DistributedNetworkObjectManager::Instance()-&gt;GetRakClientInterface() &amp;&amp; DistributedNetworkObjectManager::Instance()-&gt;GetRakClientInterface()-&gt;IsConnected())
 	{
 		// This sends a request to create or update the object
 		DistributedNetworkObjectManager::Instance()-&gt;GetRakClientInterface()-&gt;Send(bitStream, HIGH_PRIORITY, RELIABLE_ORDERED, 0);
-		lastBroadcastTime=getTime();
+		lastBroadcastTime=RakNetGetTime();
 	}
 }
 
-void DistributedNetworkObject::SerializeClassHeader(BitStream *bitStream, char *classIdentifier, bool construction, bool localObject, unsigned char localObjectIndex)
+void DistributedNetworkObject::SerializeClassHeader(RakNet::BitStream *bitStream, char *classIdentifier, int action, bool localObject, unsigned char localObjectIndex)
 {
 	static const unsigned char packetId = ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT;
 
 	bitStream-&gt;Write(packetId);
 
 	// Construction to true means we are creating or updating this object.  Otherwise it means we are destroying this object.
-	bitStream-&gt;Write(construction);
+	bitStream-&gt;WriteBits((unsigned char*)&amp;action, 2);
 
 	bitStream-&gt;Write(GetID());
 
-	if (construction)
+	if (action==2)
 	{
 		bitStream-&gt;Write(classIdentifier, classIdentifier[0]+1);
 	}
@@ -339,23 +369,39 @@
 	bitStream-&gt;Write(localObject);
 	if (localObject)
 		bitStream-&gt;Write(localObjectIndex);
+
+	if (action==2)
+	{
+		if (clientOwnerID==UNASSIGNED_PLAYER_ID)
+		{
+			bitStream-&gt;Write(false);
+		}
+		else
+		{
+			bitStream-&gt;Write(true);
+			bitStream-&gt;Write((char*)&amp;clientOwnerID, sizeof(PlayerID));
+		}
+	}
+
 }
 
-bool DistributedNetworkObject::DeserializeClassHeader(BitStream *bitStream, bool &amp;construction, ObjectID &amp;objectId, char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH], bool &amp;localObject, unsigned char &amp;localObjectIndex)
+bool DistributedNetworkObject::DeserializeClassHeader(RakNet::BitStream *bitStream, int &amp;action, ObjectID &amp;objectId, char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH], bool &amp;localObject, unsigned char &amp;localObjectIndex, PlayerID &amp;pid)
 {
 	unsigned char packetId;
+	bool hasClientOwnerID;
 	if (bitStream-&gt;Read(packetId)==false)
 		return false;
 
 	assert(packetId==ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT);
 
-	if (bitStream-&gt;Read(construction)==false)
+	action=0;
+	if (bitStream-&gt;ReadBits((unsigned char*)&amp;action,2)==false)
 		return false;
 
 	if (bitStream-&gt;Read(objectId)==false)
 		return false;
 
-	if (construction)
+	if (action==2)
 	{
 		unsigned char classNameLength;
 		if (bitStream-&gt;Read(classNameLength)==false)
@@ -365,6 +411,8 @@
 
 		classIdentifier[0]=classNameLength;
 	}
+	else
+		classIdentifier=0;
 
 	bool isLocalObjectInpacket;
 	if (bitStream-&gt;Read(isLocalObjectInpacket)==false)
@@ -375,6 +423,19 @@
 			return false;
 	}
 
+	if (action==2)
+	{
+		if (bitStream-&gt;Read(hasClientOwnerID)==false)
+			return false;
+		if (hasClientOwnerID)
+		{
+			if (bitStream-&gt;Read((char*)&amp;pid, sizeof(PlayerID))==false)
+				return false;
+		}
+		else
+			pid=UNASSIGNED_PLAYER_ID;
+	}	
+
 	return true;
 }
 
@@ -389,7 +450,6 @@
 
 bool DistributedNetworkObject::OnDistributedObjectCreation(PlayerID senderID)
 {
-	localObject=false;
 #ifdef _DEBUG
 	assert(GetID()!=UNASSIGNED_OBJECT_ID);
 #endif
@@ -430,3 +490,9 @@
 {
 	clientOwnerID=id;
 }
+
+void DistributedNetworkObject::SetLocalObject(bool b)
+{
+	localObject=b;
+}
+

Modified: trunk/source/libraries/raknet/DistributedNetworkObject.h
===================================================================
--- trunk/source/libraries/raknet/DistributedNetworkObject.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/DistributedNetworkObject.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -7,13 +7,13 @@
 
 // Refer to the appropriate license agreement for distribution, modification, and warranty rights.
 
+#ifndef __DISTRIBUTED_NETWORK_OBJECT
+#define __DISTRIBUTED_NETWORK_OBJECT
+
 #include &quot;NetworkObject.h&quot;
 #include &quot;EncodeClassName.h&quot;
-class BitStream;
+#include &quot;BitStream.h&quot;
 
-#ifndef __DISTRIBUTED_NETWORK_OBJECT
-#define __DISTRIBUTED_NETWORK_OBJECT
-
 class DistributedNetworkObject : public NetworkObject
 {
 public:
@@ -33,7 +33,6 @@
 	// If you wish to block deletion, override OnDistributedObjectDestruction
 	virtual void DestroyObjectOnNetwork(void);
 
-
 	// Server only function -
 	// By default, when a client creates an object only it can update the client authoritative members
 	// Of the class it creates.  You can also set this manually with SetClientOwnerID
@@ -55,7 +54,7 @@
 	
 	// Tags memory to be synchronized.  You can set the server or the client as the authority for this block.
 	// Only the authority will write this memory to the network when it is changed.
-	void SynchronizeMemory(unsigned char memoryBlockIndex, char* memoryBlock, int memoryBlockSize, bool serverAuthority);
+	void SynchronizeMemory(unsigned char memoryBlockIndex, char* memoryBlock, unsigned short memoryBlockSize, bool serverAuthority);
 
 	// Untags memory that was formerly synchronized.
 	void DesynchronizeMemory(unsigned char memoryBlockIndex);
@@ -73,7 +72,19 @@
 	// --------------------------------------------------------------------------
 	// Events
 	// --------------------------------------------------------------------------
+	// When object creation data is needed, WriteCreationData is called.
+	// This function is for you to write any data that is needed to create or initialize the object
+	// On remote systems
+	virtual void WriteCreationData(RakNet::BitStream *initialData);
 
+	// When an object is created, ReadCreationData is called immediately after a 
+	// successful call to OnDistributedObjectCreation
+	// This function is for you to read any data written from WriteCreationData
+	// on remote systems.  If the object is created by the client, this function is
+	// also called by the creator of the object when sent back from the server in case the
+	// server overrode any settings
+	virtual void ReadCreationData(RakNet::BitStream *initialData);
+
 	// When distributed data changes for an object, this function gets called.  Default behavior is to do nothing.
 	// Override it if you want to perform updates when data is changed
 	// On the server it is also important to override this to make sure the data the client just sent you is reasonable.
@@ -101,34 +112,37 @@
 
 	// You don't need to modify this
 	// Sends the bitstream to other systems
-	virtual void BroadcastSerializedClass(BitStream *bitStream);
+	virtual void BroadcastSerializedClass(RakNet::BitStream *bitStream);
 
 	// You don't need to modify this
 	// Writes the header identifying the class, objectID, and whether the object is being created or destroyed
-	virtual void SerializeClassHeader(BitStream *bitStream, char *classIdentifier, bool construction, bool localObject, unsigned char localObjectIndex);
-	static bool DeserializeClassHeader(BitStream *bitStream, bool &amp;construction, ObjectID &amp;objectId,char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH], bool &amp;localObject, unsigned char &amp;localObjectIndex);
+	// action of 0 means destruction, 1 means update, 2 means create
+	virtual void SerializeClassHeader(RakNet::BitStream *bitStream, char *classIdentifier, int action, bool localObject, unsigned char localObjectIndex);
+	static bool DeserializeClassHeader(RakNet::BitStream *bitStream, int &amp;action, ObjectID &amp;objectId,char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH], bool &amp;localObject, unsigned char &amp;localObjectIndex, PlayerID &amp;pid);
 
 	// You don't need to modify this
 	// Returns true if this object was locally created, as opposed to created by the network
 	bool IsLocalObject(void) const;
+	void SetLocalObject(bool b);
 
 	// Writes to or reads from a bitstream for all distributed memory on the stack.  This function does not need to be modified by the end-user
 	// Returns true if any data was written
-	virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative);
+	virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative);
 
 	// Same as ProcessDistributedMemoryStack with isWrite to false, but for the heapNodeList.
 	// Returns true if data was written
-	bool WriteToBitstreamFromHeap(BitStream *bitStream, bool forceWrite);
+	bool WriteToBitstreamFromHeap(RakNet::BitStream *bitStream, bool forceWrite);
 
 	// Same as ProcessDistributedMemoryStack with isWrite to true, but for the heapNodeList.
-	void WriteToHeapFromBitstream(BitStream *bitStream);
+	void WriteToHeapFromBitstream(RakNet::BitStream *bitStream);
 
 	// You don't need to modify this
 	// Returns the identifier for an object that has not yet had SetID called on it
 	unsigned char GetLocalObjectIdentifier(void) const;
 
-	// Server only - select which client can update the client authoritative members of this object.
-	// UNASSIGNED_PLAYER_ID no client owns the object, so any client can update the object.
+	// This is set to who created this object.
+	// On the server, this also determines who can update the client authoritative members of this object.
+	// You can manually set it to UNASSIGNED_PLAYER_ID so no client owns the object, so any client can update the object.
 	PlayerID GetClientOwnerID(void) const;
 	void SetClientOwnerID(PlayerID id);
 

Modified: trunk/source/libraries/raknet/DistributedNetworkObjectHeader.h
===================================================================
--- trunk/source/libraries/raknet/DistributedNetworkObjectHeader.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/DistributedNetworkObjectHeader.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -49,7 +49,7 @@
 	BaseClass::DistributedMemoryInit(isServerAuthoritative);	\
 	SynchronizationMethod1##_INTERPOLATION_MEMORY_INIT(VariableName1)	\
 }	\
-virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -70,7 +70,7 @@
 \
 virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	if (distributedMemoryInitialized==false)	\
 		DistributedMemoryInit(isServerAuthoritative);	\
 	SynchronizationMethod1##_INTERPOLATION_CODE(AuthoritativeNetwork1, VariableName1)	\
@@ -132,7 +132,7 @@
 	DOM_CORE_EXPANDED(AuthoritativeNetwork,VariableType,VariableName, ReadCode, ReadDummyCode, WriteCode, VariableName!=VariableName##_LastKnownValue)	\
 	if (isWrite==false &amp;&amp; dataChanged==true)	\
 	{	\
-		VariableName##_InterpolationStartTime=getTime();	\
+		VariableName##_InterpolationStartTime=RakNetGetTime();	\
 		VariableName##_InterpolationEndTime=VariableName##_InterpolationStartTime+maximumUpdateFrequency;	\
 		VariableName##_InitialValue=VariableName;	\
 		VariableName##_FinalValue=VariableName##_LastReadValue;	\
@@ -214,7 +214,7 @@
 	SynchronizationMethod1##_INTERPOLATION_MEMORY_INIT(VariableName1)	\
 	SynchronizationMethod2##_INTERPOLATION_MEMORY_INIT(VariableName2)	\
 }	\
-virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -234,7 +234,7 @@
 \
 virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 		DistributedMemoryInit(isServerAuthoritative);	\
@@ -260,7 +260,7 @@
 	SynchronizationMethod2##_INTERPOLATION_MEMORY_INIT(VariableName2)	\
 	SynchronizationMethod3##_INTERPOLATION_MEMORY_INIT(VariableName3)	\
 }	\
-virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -282,7 +282,7 @@
 \
 virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 		DistributedMemoryInit(isServerAuthoritative);	\
@@ -313,7 +313,7 @@
 	SynchronizationMethod3##_INTERPOLATION_MEMORY_INIT(VariableName3)	\
 	SynchronizationMethod4##_INTERPOLATION_MEMORY_INIT(VariableName4)	\
 }	\
-	virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+	virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -337,7 +337,7 @@
 	\
 	virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 	DistributedMemoryInit(isServerAuthoritative);	\
@@ -373,7 +373,7 @@
 	SynchronizationMethod4##_INTERPOLATION_MEMORY_INIT(VariableName4)	\
 	SynchronizationMethod5##_INTERPOLATION_MEMORY_INIT(VariableName5)	\
 }	\
-	virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+	virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -399,7 +399,7 @@
 	\
 	virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 	DistributedMemoryInit(isServerAuthoritative);	\
@@ -440,7 +440,7 @@
 	SynchronizationMethod5##_INTERPOLATION_MEMORY_INIT(VariableName5)	\
 	SynchronizationMethod6##_INTERPOLATION_MEMORY_INIT(VariableName6)	\
 }	\
-	virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+	virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -468,7 +468,7 @@
 	\
 	virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 	DistributedMemoryInit(isServerAuthoritative);	\

Modified: trunk/source/libraries/raknet/DistributedNetworkObjectManager.cpp
===================================================================
--- trunk/source/libraries/raknet/DistributedNetworkObjectManager.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/DistributedNetworkObjectManager.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -90,9 +90,14 @@
 DistributedNetworkObject *DistributedNetworkObjectManager::GetClassInstanceByIdentifier(char *classIdentifier)
 {
 	unsigned i;
+
+	if (classIdentifier[0]==0)
+		return 0;
+
 	for (i=0; i &lt; classList.size(); i++)
 	{
 		// Byte 0 of the class identifier holds the length of the remaining bytes
+		// The +1 is because we also compare the first byte
 		if (memcmp(classIdentifier, classList[i]-&gt;GetEncodedClassName(), classList[i]-&gt;GetEncodedClassName()[0]+1)==0)
 			return classList[i]-&gt;GetObject();
 	}
@@ -106,15 +111,17 @@
 	// Assert that the first byte of the packet is ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT
 
 	char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH];
-	BitStream bitStream(packet-&gt;data, packet-&gt;length, true);
+	RakNet::BitStream bitStream((char*)packet-&gt;data, packet-&gt;length, true);
 	ObjectID objectId;
 	DistributedNetworkObject* object=0;
-	bool construction;
+	int action;
+	PlayerID pid;
+	bool isLocalObject;
+	unsigned char localObjectIndex;
+	pid=UNASSIGNED_PLAYER_ID;
 
 
-	bool isLocalObject;
-	unsigned char localObjectIndex;
-	if (DistributedNetworkObject::DeserializeClassHeader(&amp;bitStream, construction, objectId, classIdentifier,isLocalObject,localObjectIndex)==false)
+	if (DistributedNetworkObject::DeserializeClassHeader(&amp;bitStream, action, objectId, classIdentifier,isLocalObject,localObjectIndex,pid)==false)
 		return 0; // Some kind of corrupted packet, or the server was active but not registered, or the client was active but not registered
 
 	bool serverProcess=true;
@@ -125,7 +132,7 @@
 			serverProcess=false;
 	}
 
-	if (construction)
+	if (action&gt;=1)
 	{
 		if (objectId!=UNASSIGNED_OBJECT_ID)
 		{
@@ -146,7 +153,10 @@
 
 			if (object==0)
 			{
-				assert(0); // Unknown class identifier
+				// If this assert hits then one system tried to create a class that was
+				// not registered with REGISTER_DISTRIBUTED_NETWORK_OBJECT on this system.
+				// Byte 0 of 0 means no class identifier was encoded
+				assert(classIdentifier[0]==0);
 				return 0;
 			}
 
@@ -154,6 +164,9 @@
 				DistributedNetworkObjectManager::Instance()-&gt;GetRakServerInterface()==0)
 				object-&gt;SetID(objectId);
 
+			if (DistributedNetworkObjectManager::Instance()-&gt;GetRakClientInterface() &amp;&amp; pid!=UNASSIGNED_PLAYER_ID)
+				object-&gt;SetClientOwnerID(pid); // So the client knows who is the owner of the object
+
 			object-&gt;ProcessDistributedMemoryStack(&amp;bitStream, false, false, serverProcess);
 			object-&gt;WriteToHeapFromBitstream(&amp;bitStream);
 
@@ -165,6 +178,11 @@
 					delete object;
 					object=0;
 				}
+				else
+				{
+					object-&gt;SetLocalObject(false);
+					object-&gt;ReadCreationData(&amp;bitStream);
+				}
 			}
 			else if (DistributedNetworkObjectManager::Instance()-&gt;GetRakServerInterface() &amp;&amp; DistributedNetworkObjectManager::Instance()-&gt;GetRakServerInterface()-&gt;IsActive())
 			{
@@ -176,7 +194,7 @@
 
 					// Tell the sender that the object creation was rejected
 					static const unsigned char objectRejectedID = ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_REJECTED;
-					BitStream rejectionBitStream;
+					RakNet::BitStream rejectionBitStream;
 					rejectionBitStream.Write(objectRejectedID);
 					rejectionBitStream.Write(localObjectIndex);
 
@@ -184,12 +202,16 @@
 				}
 				else
 				{
+					object-&gt;SetLocalObject(false);
+					object-&gt;ReadCreationData(&amp;bitStream);
+
 					// Receipt of this packet will set the object ID for the client so future data packets can be processed
 					static const unsigned char objectAcceptedID = ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_ACCEPTED;
-					BitStream acceptanceBitStream;
+					RakNet::BitStream acceptanceBitStream;
 					acceptanceBitStream.Write(objectAcceptedID);
 					acceptanceBitStream.Write(localObjectIndex);
 					acceptanceBitStream.Write(object-&gt;GetID());
+					acceptanceBitStream.Write((char*)&amp;packet-&gt;playerId, sizeof(PlayerID));
 
 					DistributedNetworkObjectManager::Instance()-&gt;GetRakServerInterface()-&gt;Send(&amp;acceptanceBitStream, HIGH_PRIORITY, RELIABLE_ORDERED, 0, packet-&gt;playerId, false);
 
@@ -202,11 +224,11 @@
 					object-&gt;BroadcastSerializedClass(&amp;bitStream);
 					*/
 
-					object-&gt;UpdateDistributedObject(classIdentifier, true);
-
 					// If the client creates the object, it is considered the owner
 					object-&gt;SetClientOwnerID(packet-&gt;playerId);
 
+					object-&gt;UpdateDistributedObject(classIdentifier, true);
+
 				}
 			}
 		}
@@ -234,7 +256,7 @@
 			if (DistributedNetworkObjectManager::Instance()-&gt;GetRakServerInterface() &amp;&amp; DistributedNetworkObjectManager::Instance()-&gt;GetRakServerInterface()-&gt;IsActive())
 			{
 				bitStream.Reset();
-				object-&gt;SerializeClassHeader(&amp;bitStream, classIdentifier, true, false, 0);
+				object-&gt;SerializeClassHeader(&amp;bitStream, classIdentifier, action, false, 0);
 				object-&gt;ProcessDistributedMemoryStack(&amp;bitStream, true, true,true);
 				object-&gt;WriteToBitstreamFromHeap(&amp;bitStream, true);
 				object-&gt;BroadcastSerializedClass(&amp;bitStream);
@@ -250,6 +272,17 @@
 			return 0;
 		}
 
+		// If this is the server and the client is trying to destroy it, make sure it is either the
+		// owner or no owner is set
+		if (serverProcess)
+		{
+			if (object-&gt;GetClientOwnerID()!=UNASSIGNED_PLAYER_ID &amp;&amp;
+				object-&gt;GetClientOwnerID()!=packet-&gt;playerId &amp;&amp;
+				object-&gt;AllowSpectatorUpdate(packet-&gt;playerId)==false)
+				// Client trying to update an object it does not own - and it was not allowed to
+				return 0;
+		}
+
 		object-&gt;OnDistributedObjectDestruction(packet-&gt;playerId);
 		object=0;
 	}
@@ -262,13 +295,16 @@
 	unsigned char localObjectIndex;
 	DistributedNetworkObject* object;
 	ObjectID objectID;
+	PlayerID pid;
 
-	BitStream bitStream(packet-&gt;data, packet-&gt;length, false);
+	RakNet::BitStream bitStream((char*)packet-&gt;data, packet-&gt;length, false);
 	bitStream.IgnoreBits(sizeof(unsigned char)*8); // Skip the packet identifier
 	if (bitStream.Read(localObjectIndex)==0)
 		return;
 	if (bitStream.Read(objectID)==0)
 		return;
+	if (bitStream.Read((char*)&amp;pid, sizeof(PlayerID))==0)
+		return;
 
 	// Find the object with this index
 	object = GetObjectByLocalObjectIndex(localObjectIndex);
@@ -286,6 +322,12 @@
 		delete object;
 		object=0;
 	}
+	else
+	{
+		object-&gt;SetLocalObject(false);
+		object-&gt;SetClientOwnerID(pid);
+	}
+
 }
 
 void DistributedNetworkObjectManager::HandleDistributedNetworkObjectPacketCreationRejected(Packet *packet)
@@ -293,7 +335,7 @@
 	unsigned char localObjectIndex;
 	DistributedNetworkObject* object;
 
-	BitStream bitStream(packet-&gt;data, packet-&gt;length, false);
+	RakNet::BitStream bitStream((char*)packet-&gt;data, packet-&gt;length, false);
 	bitStream.IgnoreBits(sizeof(unsigned char)*8); // Skip the packet identifier
 	if (bitStream.Read(localObjectIndex)==0)
 		return;
@@ -336,12 +378,12 @@
 			}
 		}
 
-		BitStream bitStream;
+		RakNet::BitStream bitStream;
 		unsigned i;
 		for (i=0; i &lt; distributedNetworkObjectInstanceRegistry.size(); i++)
 		{
 			bitStream.Reset();
-			distributedNetworkObjectInstanceRegistry[i]-&gt;object-&gt;SerializeClassHeader(&amp;bitStream, distributedNetworkObjectInstanceRegistry[i]-&gt;classIdentifier, true, false, 255);
+			distributedNetworkObjectInstanceRegistry[i]-&gt;object-&gt;SerializeClassHeader(&amp;bitStream, distributedNetworkObjectInstanceRegistry[i]-&gt;classIdentifier, 2, false, 255);
 
 			// Note to self - ProcessDistributedMemoryStack with write to true will update network memory.  During the next normal updates
 			// any changes that occured in the meantime won't be distributed.  Is this something to be concerned about?

Modified: trunk/source/libraries/raknet/EncodeClassName.cpp
===================================================================
--- trunk/source/libraries/raknet/EncodeClassName.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/EncodeClassName.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -13,7 +13,7 @@
 
 void EncodeClassName(char *name, char *identifier)
 {
-	BitStream bitStream;
+	RakNet::BitStream bitStream;
 	int index=0;
 	unsigned char byte;
 	while (index &lt; MAXIMUM_CLASS_IDENTIFIER_LENGTH-1)

Modified: trunk/source/libraries/raknet/GetTime.cpp
===================================================================
--- trunk/source/libraries/raknet/GetTime.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/GetTime.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -9,28 +9,43 @@
 
 #include &quot;GetTime.h&quot;
 
-////#include &quot;MemoryManager.h&quot;
+#ifdef _WIN32
+#include &lt;windows.h&gt;
+#else
+#include &lt;sys/time.h&gt;
+#endif
 
-GetTime GetTime::instance;
-
-GetTime::GetTime()
+unsigned long RakNetGetTime(void)
 {
-// For some reason this fails in the constructor
-//	QueryPerformanceFrequency(&amp;yo);
-//	counts = yo.QuadPart &gt;&gt; 10;
-	initialized=false;
-}
+#ifdef _WIN32
+	static LARGE_INTEGER yo;
+	static LONGLONG counts;
+#else
+	static timeval tp, initialTime;
+#endif
+	static bool initialized=false;
+	if (initialized==false)
+	{
+#ifdef _WIN32
+		QueryPerformanceFrequency(&amp;yo);
+		// The original code shifted right 10 bits
+		//counts = yo.QuadPart &gt;&gt; 10;
+		// It gives the wrong value since 2^10 is not 1000
+		counts = yo.QuadPart / 1000;
+#else
+		gettimeofday(&amp;initialTime, 0); 
+#endif
+		initialized=true; 
+	}
 
-void GetTime::Init(void)
-{
-	#ifdef _WIN32
-	QueryPerformanceFrequency(&amp;yo);
-	// The original code shifted right 10 bits
-	//counts = yo.QuadPart &gt;&gt; 10;
-	// It gives the wrong value since 2^10 is not 1000
-	counts = yo.QuadPart / 1000;
-	#else
-	gettimeofday(&amp;initialTime, 0); 
-	#endif
-	initialized=true; 
+#ifdef _WIN32
+	LARGE_INTEGER PerfVal;
+	QueryPerformanceCounter(&amp;PerfVal);
+	return (unsigned long)(PerfVal.QuadPart/counts);
+#else
+	gettimeofday(&amp;tp, 0);
+
+	// Seconds to ms and microseconds to ms
+	return (tp.tv_sec - initialTime.tv_sec) * 1000 + (tp.tv_usec - initialTime.tv_usec) / 1000;
+#endif
 }

Modified: trunk/source/libraries/raknet/GetTime.h
===================================================================
--- trunk/source/libraries/raknet/GetTime.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/GetTime.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -10,53 +10,7 @@
 #ifndef __GET_TIME_H
 #define __GET_TIME_H
 
-#ifdef _WIN32
-#include &lt;windows.h&gt;
-#else
-#include &lt;sys/time.h&gt;
-#endif
+extern unsigned long RakNetGetTime(void);
 
-// A utility class to get a more accurate time than timeGetTime()
-class GetTime
-{
-public:
-	// Call this before using the function.  It won't work in constructor calls though, so you have to call this in Winmain or main and
-	// not use the class in your constructors
-	void Init(void);
-
-	// Call this or use the #define getTime (below) to get the current time
-	inline unsigned long Time(void)
-	{
-		if (initialized==false) Init();
-
-		#ifdef _WIN32
-		LARGE_INTEGER PerfVal;
-		QueryPerformanceCounter(&amp;PerfVal);
-		return (unsigned long)(PerfVal.QuadPart/counts);
-		#else
-		gettimeofday(&amp;tp, 0);
-		// Seconds to ms and microseconds to ms
-		return (tp.tv_sec - initialTime.tv_sec) * 1000 + (tp.tv_usec - initialTime.tv_usec) / 1000;
-		#endif
-	}
-
-	~GetTime() {}
-	// static function because only static functions can access static members
-	static inline GetTime* Instance() {return &instance;}
-private:
-	static GetTime instance;
-	GetTime();
-    
-    	#ifdef _WIN32
-	LARGE_INTEGER yo;
-	LONGLONG counts;
-	#else
-	timeval tp, initialTime;
-	#endif
-	bool initialized;
-};
-
-#define getTime GetTime::Instance()-&gt;Time
-
 #endif
 

Modified: trunk/source/libraries/raknet/HuffmanEncodingTree.cpp
===================================================================
--- trunk/source/libraries/raknet/HuffmanEncodingTree.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/HuffmanEncodingTree.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -109,7 +109,7 @@
 	bool tempPath[256]; // Maximum path length is 256
 	unsigned short tempPathLength;
 	HuffmanEncodingTreeNode *currentNode;
-	BitStream bitStream;
+	RakNet::BitStream bitStream;
 
 	// Generate the encryption table. From before, we have an array of pointers to all the leaves which contain pointers to their parents.
 	// This can be done more efficiently but this isn't bad and it's way easier to program and debug
@@ -148,7 +148,7 @@
 }
 
 // Pass an array of bytes to array and a preallocated BitStream to receive the output
-void HuffmanEncodingTree::EncodeArray(unsigned char *input, int sizeInBytes, BitStream* output)
+void HuffmanEncodingTree::EncodeArray(unsigned char *input, int sizeInBytes, RakNet::BitStream * output)
 {
 	if (sizeInBytes&lt;=0)
 		return;
@@ -179,7 +179,7 @@
 	}
 }
 
-int HuffmanEncodingTree::DecodeArray(BitStream* input, int sizeInBits, int maxCharsToWrite, unsigned char *output)
+int HuffmanEncodingTree::DecodeArray(RakNet::BitStream * input, int sizeInBits, int maxCharsToWrite, unsigned char *output)
 {
 	HuffmanEncodingTreeNode *currentNode;
 
@@ -210,14 +210,14 @@
 }
 
 // Pass an array of encoded bytes to array and a preallocated BitStream to receive the output
-void HuffmanEncodingTree::DecodeArray(unsigned char *input, int sizeInBits, BitStream* output)
+void HuffmanEncodingTree::DecodeArray(unsigned char *input, int sizeInBits, RakNet::BitStream * output)
 {
 	HuffmanEncodingTreeNode *currentNode;
 
 	if (sizeInBits&lt;=0)
 		return;
 
-	BitStream bitStream(BITS_TO_BYTES(sizeInBits));
+	RakNet::BitStream bitStream(BITS_TO_BYTES(sizeInBits));
 	bitStream.SetData(input, sizeInBits); // Put the data in the BitStream class to make it easier to use
 
 	currentNode=root;

Modified: trunk/source/libraries/raknet/HuffmanEncodingTree.h
===================================================================
--- trunk/source/libraries/raknet/HuffmanEncodingTree.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/HuffmanEncodingTree.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -11,8 +11,8 @@
 #define __HUFFMAN_ENCODING_TREE
 
 #include &quot;HuffmanEncodingTreeNode.h&quot;
+#include &quot;BitStream.h&quot;
 
-class BitStream;
 #include &quot;LinkedList.h&quot;
 
 // This generates special cases of the huffman encoding tree using 8 bit keys with the additional condition that unused combinations of 8 bits are treated as a frequency of 1
@@ -23,12 +23,12 @@
 	~HuffmanEncodingTree();
 
 	// Pass an array of bytes to array and a preallocated BitStream to receive the output
-	void EncodeArray(unsigned char *input, int sizeInBytes, BitStream* output);
+	void EncodeArray(unsigned char *input, int sizeInBytes, RakNet::BitStream * output);
 
 	// Two versions that perform the same operation.
 	// The second version also the number of bytes in the stream, which may be greater than the max chars to write
-	int DecodeArray(BitStream* input, int sizeInBits, int maxCharsToWrite, unsigned char *output);
-	void DecodeArray(unsigned char *input, int sizeInBits, BitStream* output);
+	int DecodeArray(RakNet::BitStream * input, int sizeInBits, int maxCharsToWrite, unsigned char *output);
+	void DecodeArray(unsigned char *input, int sizeInBits, RakNet::BitStream * output);
 
 	// Given a frequency table of 256 elements, all with a frequency of 1 or more, generate the tree
 	void GenerateFromFrequencyTable(unsigned long frequencyTable[256]);

Modified: trunk/source/libraries/raknet/InternalPacket.h
===================================================================
--- trunk/source/libraries/raknet/InternalPacket.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/InternalPacket.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -20,11 +20,10 @@
 {
 	bool isAcknowledgement; // True if this is an acknowledgement packet
 	PacketNumberType packetNumber; // The number of this packet, used as an identifier
-	char sha1Code[SHA1_LENGTH]; // The sha1Code, used to verify packet data integrity
 	PacketPriority priority; // The priority level of this packet
 	PacketReliability reliability; // What type of reliability algorithm to use with this packet
-	unsigned char orderingStream; // What ordering stream this packet is on, if the reliability type uses ordering streams
-	unsigned char orderingIndex; // The ID used as identification for ordering streams
+	unsigned char orderingChannel; // What ordering channel this packet is on, if the reliability type uses ordering channels
+	unsigned char orderingIndex; // The ID used as identification for ordering channels
 	unsigned long splitPacketId; // The ID of the split packet, if we have split packets
 	unsigned long splitPacketIndex; // If this is a split packet, the index into the array of split packets
 	unsigned long splitPacketCount; // The size of the array of split packets

Modified: trunk/source/libraries/raknet/InternalPacketPool.cpp
===================================================================
--- trunk/source/libraries/raknet/InternalPacketPool.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/InternalPacketPool.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -15,6 +15,9 @@
 #ifdef _DEBUG
 	packetsReleased=0;
 #endif
+
+	// Speed things up by not reallocating at runtime when a mutex is locked.
+	pool.clearAndForceAllocation(1024);
 }
 
 InternalPacketPool::~InternalPacketPool()
@@ -49,6 +52,7 @@
 	poolMutex.Lock();
 	if (pool.size())
 		p=pool.pop();
+
 	poolMutex.Unlock();
 	if (p)
 		return p;

Modified: trunk/source/libraries/raknet/LinkedList.h
===================================================================
--- trunk/source/libraries/raknet/LinkedList.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/LinkedList.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -95,6 +95,7 @@
 	B++;
 	B.peek();  // Returns 30
 
+9/04 Giblet - updated code to work with new compilers adhering more closely to ISO standard
 
 */
 
@@ -176,15 +177,15 @@
 template &lt;class CircularLinkedListType&gt;
 inline void CircularLinkedList&lt;CircularLinkedListType&gt;::beginning(void)
 {
-	if (root)
-		position=root;
+	if (this-&gt;root)
+		this-&gt;position=this-&gt;root;
 }
 
 template &lt;class CircularLinkedListType&gt;
 inline void CircularLinkedList&lt;CircularLinkedListType&gt;::end(void)
 {
-	if (root)
-		position=root-&gt;previous;
+	if (this-&gt;root)
+		this-&gt;position=this-&gt;root-&gt;previous;
 }
 
 template &lt;class LinkedListType&gt;
@@ -195,71 +196,71 @@
 	if ((&amp;original_copy) != this)
 	{
 	
-	clear();
+	this-&gt;clear();
 
 
 	if (original_copy.list_size==0L) 
 	{
-		root=0;
-		position=0;
-		list_size=0L;
+		this-&gt;root=0;
+		this-&gt;position=0;
+		this-&gt;list_size=0L;
 	}
 	else if (original_copy.list_size==1L)
 	{
-		root= new typename LinkedList::node;
+		this-&gt;root= new typename LinkedList::node;
 		// root-&gt;item = new LinkedListType;
-		root-&gt;next=root;
-		root-&gt;previous=root;
-		list_size=1L;
-		position=root;
+		this-&gt;root-&gt;next=this-&gt;root;
+		this-&gt;root-&gt;previous=this-&gt;root;
+		this-&gt;list_size=1L;
+		this-&gt;position=this-&gt;root;
 		// *(root-&gt;item)=*((original_copy.root)-&gt;item);
-		root-&gt;item = original_copy.root-&gt;item;
+		this-&gt;root-&gt;item = original_copy.root-&gt;item;
 	}
 	else
 	{
 		// Setup the first part of the root node
 		original_copy_pointer=original_copy.root;
-		root = new typename LinkedList::node;
+		this-&gt;root = new typename LinkedList::node;
 		// root-&gt;item = new LinkedListType;
-		position = root;
+		this-&gt;position = this-&gt;root;
 		// *(root-&gt;item)=*((original_copy.root)-&gt;item);
-		root-&gt;item = original_copy.root-&gt;item;
-		if (original_copy_pointer == original_copy.position) save_position=position;
+		this-&gt;root-&gt;item = original_copy.root-&gt;item;
+		if (original_copy_pointer == original_copy.position) save_position=this-&gt;position;
 
 		do
 		{
 			
 
 			// Save the current element
-			last=position;
+			this-&gt;last=this-&gt;position;
 
 			// Point to the next node in the source list
 			original_copy_pointer=original_copy_pointer-&gt;next;
 
 			// Create a new node and point position to it
-			position = new typename LinkedList::node;
+			this-&gt;position = new typename LinkedList::node;
 			// position-&gt;item = new LinkedListType;
 
 			// Copy the item to the new node
 			// *(position-&gt;item)=*(original_copy_pointer-&gt;item);
-			position-&gt;item = original_copy_pointer-&gt;item;
-			if (original_copy_pointer == original_copy.position) save_position=position;
+			this-&gt;position-&gt;item = original_copy_pointer-&gt;item;
+			if (original_copy_pointer == original_copy.position) save_position=this-&gt;position;
 
 
 			// Set the previous pointer for the new node
-			(position-&gt;previous) = last;
+			(this-&gt;position-&gt;previous) = this-&gt;last;
 
 			// Set the next pointer for the old node to the new node
-			(last-&gt;next) =position;
+			(this-&gt;last-&gt;next) =this-&gt;position;
 
 		} while ((original_copy_pointer-&gt;next) != (original_copy.root));
 
 		// Complete the circle.  Set the next pointer of the newest node to the root and the previous pointer of the root to the newest node
-		position-&gt;next=root;
-		root-&gt;previous=position;
+		this-&gt;position-&gt;next=this-&gt;root;
+		this-&gt;root-&gt;previous=this-&gt;position;
 
-		list_size=original_copy.list_size;
-		position=save_position;
+		this-&gt;list_size=original_copy.list_size;
+		this-&gt;position=save_position;
 	}
 }
 
@@ -270,21 +271,21 @@
 template &lt;class CircularLinkedListType&gt;
 CircularLinkedList&lt;CircularLinkedListType&gt;::CircularLinkedList()
 {
-	root=0;
-	position=0;
-	list_size=0L;
+	this-&gt;root=0;
+	this-&gt;position=0;
+	this-&gt;list_size=0L;
 }
 
 template &lt;class CircularLinkedListType&gt;
 CircularLinkedList&lt;CircularLinkedListType&gt;::~CircularLinkedList()
 {
-	clear();
+	this-&gt;clear();
 }
 
 template &lt;class LinkedListType&gt;
 LinkedList&lt;LinkedListType&gt;::~LinkedList()
 {
-	clear();
+	this-&gt;clear();
 }
 
 template &lt;class LinkedListType&gt;
@@ -294,64 +295,64 @@
 
 	if (original_copy.list_size==0L) 
 	{
-		root=0;
-		position=0;
-		list_size=0L;
+		this-&gt;root=0;
+		this-&gt;position=0;
+		this-&gt;list_size=0L;
 		return;
 	}
 	else if (original_copy.list_size==1L)
 	{
-		root= new typename LinkedList::node;
+		this-&gt;root= new typename LinkedList::node;
 		// root-&gt;item = new CircularLinkedListType;
-		root-&gt;next=root;
-		root-&gt;previous=root;
-		list_size=1L;
-		position=root;
+		this-&gt;root-&gt;next=this-&gt;root;
+		this-&gt;root-&gt;previous=this-&gt;root;
+		this-&gt;list_size=1L;
+		this-&gt;position=this-&gt;root;
 		// *(root-&gt;item) = *((original_copy.root)-&gt;item);
-		root-&gt;item = original_copy.root-&gt;item;
+		this-&gt;root-&gt;item = original_copy.root-&gt;item;
 	}
 	else
 	{
 		// Setup the first part of the root node
 		original_copy_pointer=original_copy.root;
-		root = new typename LinkedList::node;
+		this-&gt;root = new typename LinkedList::node;
 		// root-&gt;item = new CircularLinkedListType;
-		position = root;
+		this-&gt;position = this-&gt;root;
 		// *(root-&gt;item)=*((original_copy.root)-&gt;item);
-		root-&gt;item = original_copy.root-&gt;item;
-		if (original_copy_pointer == original_copy.position) save_position=position;
+		this-&gt;root-&gt;item = original_copy.root-&gt;item;
+		if (original_copy_pointer == original_copy.position) save_position=this-&gt;position;
 
 		do
 		{
 			// Save the current element
-			last=position;
+			this-&gt;last=this-&gt;position;
 
 			// Point to the next node in the source list
 			original_copy_pointer=original_copy_pointer-&gt;next;
 
 			// Create a new node and point position to it
-			position = new typename LinkedList::node;
+			this-&gt;position = new typename LinkedList::node;
 			// position-&gt;item = new CircularLinkedListType;
 
 			// Copy the item to the new node
 			// *(position-&gt;item)=*(original_copy_pointer-&gt;item);
-			position-&gt;item = original_copy_pointer-&gt;item;
-			if (original_copy_pointer == original_copy.position) save_position=position;
+			this-&gt;position-&gt;item = original_copy_pointer-&gt;item;
+			if (original_copy_pointer == original_copy.position) save_position=this-&gt;position;
 
 			// Set the previous pointer for the new node
-			(position-&gt;previous) = last;
+			(this-&gt;position-&gt;previous) = last;
 
 			// Set the next pointer for the old node to the new node
-			(last-&gt;next) =position;
+			(this-&gt;last-&gt;next) =this-&gt;position;
 
 		} while ((original_copy_pointer-&gt;next) != (original_copy.root));
 
 		// Complete the circle.  Set the next pointer of the newest node to the root and the previous pointer of the root to the newest node
-		position-&gt;next=root;
-		root-&gt;previous=position;
+		this-&gt;position-&gt;next=this-&gt;root;
+		this-&gt;root-&gt;previous=this-&gt;position;
 
-		list_size=original_copy.list_size;
-		position=save_position;
+		this-&gt;list_size=original_copy.list_size;
+		this-&gt;position=save_position;
 	}
 }
 
@@ -362,66 +363,66 @@
 
 	if (original_copy.list_size==0L) 
 	{
-		root=0;
-		position=0;
-		list_size=0L;
+		this-&gt;root=0;
+		this-&gt;position=0;
+		this-&gt;list_size=0L;
 		return;
 	}
 	else if (original_copy.list_size==1L)
 	{
-		root= new typename CircularLinkedList::node;
+		this-&gt;root= new typename CircularLinkedList::node;
 		// root-&gt;item = new CircularLinkedListType;
-		root-&gt;next=root;
-		root-&gt;previous=root;
-		list_size=1L;
-		position=root;
+		this-&gt;root-&gt;next=this-&gt;root;
+		this-&gt;root-&gt;previous=this-&gt;root;
+		this-&gt;list_size=1L;
+		this-&gt;position=this-&gt;root;
 		// *(root-&gt;item) = *((original_copy.root)-&gt;item);
-		root-&gt;item = original_copy.root-&gt;item;
+		this-&gt;root-&gt;item = original_copy.root-&gt;item;
 	}
 	else
 	{
 		// Setup the first part of the root node
 		original_copy_pointer=original_copy.root;
-		root = new typename CircularLinkedList::node;
+		this-&gt;root = new typename CircularLinkedList::node;
 		// root-&gt;item = new CircularLinkedListType;
-		position = root;
+		this-&gt;position = this-&gt;root;
 		// *(root-&gt;item)=*((original_copy.root)-&gt;item);
-		root-&gt;item = original_copy.root-&gt;item;
-		if (original_copy_pointer == original_copy.position) save_position=position;
+		this-&gt;root-&gt;item = original_copy.root-&gt;item;
+		if (original_copy_pointer == original_copy.position) save_position=this-&gt;position;
 
 		do
 		{
 			
 
 			// Save the current element
-			last=position;
+			this-&gt;last=this-&gt;position;
 
 			// Point to the next node in the source list
 			original_copy_pointer=original_copy_pointer-&gt;next;
 
 			// Create a new node and point position to it
-			position = new typename CircularLinkedList::node;
+			this-&gt;position = new typename CircularLinkedList::node;
 			// position-&gt;item = new CircularLinkedListType;
 
 			// Copy the item to the new node
 			// *(position-&gt;item)=*(original_copy_pointer-&gt;item);
-			position-&gt;item = original_copy_pointer-&gt;item;
+			this-&gt;position-&gt;item = original_copy_pointer-&gt;item;
 			if (original_copy_pointer == original_copy.position) save_position=position;
 
 			// Set the previous pointer for the new node
-			(position-&gt;previous) = last;
+			(this-&gt;position-&gt;previous) = this-&gt;last;
 
 			// Set the next pointer for the old node to the new node
-			(last-&gt;next) =position;
+			(this-&gt;last-&gt;next) =this-&gt;position;
 
 		} while ((original_copy_pointer-&gt;next) != (original_copy.root));
 
 		// Complete the circle.  Set the next pointer of the newest node to the root and the previous pointer of the root to the newest node
-		position-&gt;next=root;
-		root-&gt;previous=position;
+		this-&gt;position-&gt;next=this-&gt;root;
+		this-&gt;root-&gt;previous=position;
 
-		list_size=original_copy.list_size;
-		position=save_position;
+		this-&gt;list_size=original_copy.list_size;
+		this-&gt;position=save_position;
 	}
 }
 
@@ -433,68 +434,68 @@
 	if ((&amp;original_copy) != this)
 	{
 	
-	clear();
+	this-&gt;clear();
 
 
 	if (original_copy.list_size==0L) 
 	{
-		root=0;
-		position=0;
-		list_size=0L;
+		this-&gt;root=0;
+		this-&gt;position=0;
+		this-&gt;list_size=0L;
 	}
 	else if (original_copy.list_size==1L)
 	{
-		root= new typename CircularLinkedList::node;
+		this-&gt;root= new typename CircularLinkedList::node;
 		// root-&gt;item = new CircularLinkedListType;
-		root-&gt;next=root;
-		root-&gt;previous=root;
-		list_size=1L;
-		position=root;
+		this-&gt;root-&gt;next=this-&gt;root;
+		this-&gt;root-&gt;previous=this-&gt;root;
+		this-&gt;list_size=1L;
+		this-&gt;position=this-&gt;root;
 		// *(root-&gt;item)=*((original_copy.root)-&gt;item);
-		root-&gt;item = original_copy.root-&gt;item;
+		this-&gt;root-&gt;item = original_copy.root-&gt;item;
 	}
 	else
 	{
 		// Setup the first part of the root node
 		original_copy_pointer=original_copy.root;
-		root = new typename CircularLinkedList::node;
+		this-&gt;root = new typename CircularLinkedList::node;
 		// root-&gt;item = new CircularLinkedListType;
-		position = root;
+		this-&gt;position = this-&gt;root;
 		// *(root-&gt;item)=*((original_copy.root)-&gt;item);
-		root-&gt;item = original_copy.root-&gt;item;
-		if (original_copy_pointer == original_copy.position) save_position=position;
+		this-&gt;root-&gt;item = original_copy.root-&gt;item;
+		if (original_copy_pointer == original_copy.position) save_position=this-&gt;position;
 
 		do
 		{
 			// Save the current element
-			last=position;
+			this-&gt;last=this-&gt;position;
 
 			// Point to the next node in the source list
 			original_copy_pointer=original_copy_pointer-&gt;next;
 
 			// Create a new node and point position to it
-			position = new typename CircularLinkedList::node;
+			this-&gt;position = new typename CircularLinkedList::node;
 			// position-&gt;item = new CircularLinkedListType;
 
 			// Copy the item to the new node
 			// *(position-&gt;item)=*(original_copy_pointer-&gt;item);
-			position-&gt;item = original_copy_pointer-&gt;item;
-			if (original_copy_pointer == original_copy.position) save_position=position;
+			this-&gt;position-&gt;item = original_copy_pointer-&gt;item;
+			if (original_copy_pointer == original_copy.position) save_position=this-&gt;position;
 
 			// Set the previous pointer for the new node
-			(position-&gt;previous) = last;
+			(this-&gt;position-&gt;previous) = this-&gt;last;
 
 			// Set the next pointer for the old node to the new node
-			(last-&gt;next) =position;
+			(this-&gt;last-&gt;next) =this-&gt;position;
 
 		} while ((original_copy_pointer-&gt;next) != (original_copy.root));
 
 		// Complete the circle.  Set the next pointer of the newest node to the root and the previous pointer of the root to the newest node
-		position-&gt;next=root;
-		root-&gt;previous=position;
+		this-&gt;position-&gt;next=this-&gt;root;
+		this-&gt;root-&gt;previous=this-&gt;position;
 
-		list_size=original_copy.list_size;
-		position=save_position;
+		this-&gt;list_size=original_copy.list_size;
+		this-&gt;position=save_position;
 	}
 }
 
@@ -508,28 +509,28 @@
 
 	if (list_size==0L)
 	{
-		root= new typename CircularLinkedList::node;
+		this-&gt;root= new typename CircularLinkedList::node;
 		// root-&gt;item = new CircularLinkedListType;
 		//*(root-&gt;item)=input;
-		root-&gt;item = input;
-		root-&gt;next=root;
-		root-&gt;previous=root;
-		list_size=1L;
-		position=root;
+		this-&gt;root-&gt;item = input;
+		this-&gt;root-&gt;next=this-&gt;root;
+		this-&gt;root-&gt;previous=this-&gt;root;
+		this-&gt;list_size=1L;
+		this-&gt;position=this-&gt;root;
 	}
 
 	else if (list_size==1L)
 	{
-		position= new typename CircularLinkedList::node;
+		this-&gt;position= new typename CircularLinkedList::node;
 		// position-&gt;item = new CircularLinkedListType;
-		root-&gt;next=position;
-		root-&gt;previous=position;
-		position-&gt;previous=root;
-		position-&gt;next=root;
+		this-&gt;root-&gt;next=this-&gt;position;
+		this-&gt;root-&gt;previous=this-&gt;position;
+		this-&gt;position-&gt;previous=this-&gt;root;
+		this-&gt;position-&gt;next=this-&gt;root;
 		// *(position-&gt;item)=input;
-		position-&gt;item = input;
-		root=position;  // Since we're inserting into a 1 element list the old root is now the second item
-		list_size=2L;
+		this-&gt;position-&gt;item = input;
+		this-&gt;root=this-&gt;position;  // Since we're inserting into a 1 element list the old root is now the second item
+		this-&gt;list_size=2L;
 	}
 
 	else
@@ -553,22 +554,22 @@
 		new_node-&gt;item = input;
 
 		// Point next of A to B
-		(position-&gt;previous)-&gt;next=new_node;
+		(this-&gt;position-&gt;previous)-&gt;next=new_node;
 
 		// Point last of B to A
-		new_node-&gt;previous=position-&gt;previous;
+		new_node-&gt;previous=this-&gt;position-&gt;previous;
 
 		// Point last of C to B
-		position-&gt;previous=new_node;
+		this-&gt;position-&gt;previous=new_node;
 
 		// Point next of B to C
-		new_node-&gt;next=position;
+		new_node-&gt;next=this-&gt;position;
 
 		 // Since the root pointer is bound to a node rather than an index this moves it back if you insert an element at the root
-		if (position==root) {root=new_node; position=root;}
+		if (this-&gt;position==this-&gt;root) {this-&gt;root=new_node; this-&gt;position=this-&gt;root;}
 
 		// Increase the recorded size of the list by one
-		list_size++;
+		this-&gt;list_size++;
 	}
 }
 
@@ -577,34 +578,34 @@
 {
 	node *new_node;
 
-	if (list_size==0L)
+	if (this-&gt;list_size==0L)
 	{
-		root= new typename CircularLinkedList::node;
+		this-&gt;root= new typename CircularLinkedList::node;
 		// root-&gt;item = new CircularLinkedListType;
 		// *(root-&gt;item)=input;
-		root-&gt;item=input;
-		root-&gt;next=root;
-		root-&gt;previous=root;
-		list_size=1L;
-		position=root;
+		this-&gt;root-&gt;item=input;
+		this-&gt;root-&gt;next=this-&gt;root;
+		this-&gt;root-&gt;previous=this-&gt;root;
+		this-&gt;list_size=1L;
+		this-&gt;position=this-&gt;root;
 		// return *(position-&gt;item);
-		return position-&gt;item;
+		return this-&gt;position-&gt;item;
 	}
 
 	else if (list_size==1L)
 	{
-		position= new typename CircularLinkedList::node;
+		this-&gt;position= new typename CircularLinkedList::node;
 		// position-&gt;item = new CircularLinkedListType;
-		root-&gt;next=position;
-		root-&gt;previous=position;
-		position-&gt;previous=root;
-		position-&gt;next=root;
+		this-&gt;root-&gt;next=this-&gt;position;
+		this-&gt;root-&gt;previous=this-&gt;position;
+		this-&gt;position-&gt;previous=this-&gt;root;
+		this-&gt;position-&gt;next=this-&gt;root;
 		// *(position-&gt;item)=input;
-		position-&gt;item = input;
-		list_size=2L;
-		position=root;  // Don't move the position from the root
+		this-&gt;position-&gt;item = input;
+		this-&gt;list_size=2L;
+		this-&gt;position=this-&gt;root;  // Don't move the position from the root
 		// return *(position-&gt;item);
-		return position-&gt;item;
+		return this-&gt;position-&gt;item;
 	}
 
 	else
@@ -628,19 +629,19 @@
 		new_node-&gt;item=input;
 
 		// Point last of B to A
-		new_node-&gt;previous=position;
+		new_node-&gt;previous=this-&gt;position;
 
 		// Point next of B to C
-		new_node-&gt;next=(position-&gt;next);
+		new_node-&gt;next=(this-&gt;position-&gt;next);
 
 		// Point last of C to B
-		(position-&gt;next)-&gt;previous=new_node;
+		(this-&gt;position-&gt;next)-&gt;previous=new_node;
 
 		// Point next of A to B
-		(position-&gt;next)=new_node;
+		(this-&gt;position-&gt;next)=new_node;
 
 		// Increase the recorded size of the list by one
-		list_size++;
+		this-&gt;list_size++;
 		
 		// return *(new_node-&gt;item);
 		return new_node-&gt;item;
@@ -650,9 +651,9 @@
 template &lt;class CircularLinkedListType&gt;
 inline void CircularLinkedList&lt;CircularLinkedListType&gt;::replace(const CircularLinkedListType&amp; input)
 {
-	if (list_size&gt;0L)
+	if (this-&gt;list_size&gt;0L)
 		// *(position-&gt;item)=input;
-		position-&gt;item=input;
+		this-&gt;position-&gt;item=input;
 }
 
 template &lt;class CircularLinkedListType&gt;
@@ -660,26 +661,26 @@
 {
 	node* new_position;
 
-	if (list_size==0L) return;
+	if (this-&gt;list_size==0L) return;
 
-	else if (list_size==1L)
+	else if (this-&gt;list_size==1L)
 	{
 		// delete root-&gt;item;
-		delete root;
-		root=position=0;
-		list_size=0L;
+		delete this-&gt;root;
+		this-&gt;root=this-&gt;position=0;
+		this-&gt;list_size=0L;
 	}
 
 	else
 	{
-		(position-&gt;previous)-&gt;next = position-&gt;next;
-		(position-&gt;next)-&gt;previous = position-&gt;previous;
-		new_position=position-&gt;next;
-		if (position==root) root=new_position;
+		(this-&gt;position-&gt;previous)-&gt;next = this-&gt;position-&gt;next;
+		(this-&gt;position-&gt;next)-&gt;previous = this-&gt;position-&gt;previous;
+		new_position=this-&gt;position-&gt;next;
+		if (this-&gt;position==this-&gt;root) this-&gt;root=new_position;
 		// delete position-&gt;item;
-		delete position;
-		position=new_position;
-		list_size--;
+		delete this-&gt;position;
+		this-&gt;position=new_position;
+		this-&gt;list_size--;
 	}
 }
 
@@ -688,10 +689,10 @@
 {
 	node *return_value,*old_position;
 	
-	old_position=position;
+	old_position=this-&gt;position;
  
 	return_value=find_pointer(input);
-	position=old_position;
+	this-&gt;position=old_position;
 
 	if (return_value!=0) return true;
 	else return false;	// Can't find the item don't do anything
@@ -704,7 +705,7 @@
  
 	return_value=find_pointer(input);
 
-	if (return_value!=0) {position=return_value; return true;}
+	if (return_value!=0) {this-&gt;position=return_value; return true;}
 	else return false;	// Can't find the item don't do anything
 }
 
@@ -713,8 +714,8 @@
 {
 	node* current;
 
-	if (list_size==0L) return 0;
-	current=root;
+	if (this-&gt;list_size==0L) return 0;
+	current=this-&gt;root;
 
 	// Search for the item starting from the root node and incrementing the pointer after every check
 	// If you wind up pointing at the root again you looped around the list so didn't find the item, in which case return 0
@@ -723,7 +724,7 @@
 		// if (*(current-&gt;item) == input) return current;
 		if (current-&gt;item == input) return current;
 		current=current-&gt;next;
-	} while (current != root);
+	} while (current != this-&gt;root);
 
 	return 0;
 	
@@ -732,14 +733,14 @@
 template &lt;class CircularLinkedListType&gt;
 inline unsigned long CircularLinkedList&lt;CircularLinkedListType&gt;::size(void)
 {
-	return list_size;
+	return this-&gt;list_size;
 }
 
 template &lt;class CircularLinkedListType&gt;
 inline CircularLinkedListType&amp; CircularLinkedList&lt;CircularLinkedListType&gt;::peek(void)
 {
 	// return *(position-&gt;item);
-	return position-&gt;item;
+	return this-&gt;position-&gt;item;
 }
 
 template &lt;class CircularLinkedListType&gt;
@@ -755,7 +756,7 @@
 template &lt;class CircularLinkedListType&gt;
 CircularLinkedList&lt;CircularLinkedListType&gt;&amp; CircularLinkedList&lt;CircularLinkedListType&gt;::operator++()
 {
-	if (list_size!=0L) position=position-&gt;next;
+	if (this-&gt;list_size!=0L) position=position-&gt;next;
 	return *this;
 }
 
@@ -774,14 +775,14 @@
 template &lt;class CircularLinkedListType&gt;
 CircularLinkedList&lt;CircularLinkedListType&gt;&amp; CircularLinkedList&lt;CircularLinkedListType&gt;::operator++(int)
 {
-	return operator++();
+	return this-&gt;operator++();
 }
 
 // Prefix
 template &lt;class CircularLinkedListType&gt;
 CircularLinkedList&lt;CircularLinkedListType&gt;&amp; CircularLinkedList&lt;CircularLinkedListType&gt;::operator--()
 {
-	if (list_size!=0L) position=position-&gt;previous;
+	if (this-&gt;list_size!=0L) this-&gt;position=this-&gt;position-&gt;previous;
 	return *this;
 }
 
@@ -800,21 +801,21 @@
 template &lt;class CircularLinkedListType&gt;
 CircularLinkedList&lt;CircularLinkedListType&gt;&amp; CircularLinkedList&lt;CircularLinkedListType&gt;::operator--(int)
 {
-	return operator--();
+	return this-&gt;operator--();
 }
 
 template &lt;class CircularLinkedListType&gt;
 void CircularLinkedList&lt;CircularLinkedListType&gt;::clear(void)
 {
-	if (list_size==0L) return;
-	else if (list_size==1L)// {delete root-&gt;item; delete root;}
-		{delete root;}
+	if (this-&gt;list_size==0L) return;
+	else if (this-&gt;list_size==1L)// {delete root-&gt;item; delete root;}
+		{delete this-&gt;root;}
 	else
 	{
 		node* current;
 		node* temp;
 
-		current=root;
+		current=this-&gt;root;
 
 		do
 		{
@@ -822,12 +823,12 @@
 			current=current-&gt;next;
 		//	delete temp-&gt;item;
 			delete temp;
-		} while (current!=root);
+		} while (current!=this-&gt;root);
 	}
 
-	list_size=0L;
-	root=0;
-	position=0;
+	this-&gt;list_size=0L;
+	this-&gt;root=0;
+	this-&gt;position=0;
 }
 
 template &lt;class CircularLinkedListType&gt;
@@ -837,10 +838,10 @@
 	node* ptr;
 
 	if (L.list_size == 0L) return;
-	if (list_size == 0L) *this = L;
+	if (this-&gt;list_size == 0L) *this = L;
 
 	ptr = L.root;
-	position=root-&gt;previous;
+	this-&gt;position=this-&gt;root-&gt;previous;
 	
 	// Cycle through each element in L and add it to the current list
 	for (counter = 0; counter &lt; L.list_size; counter++)
@@ -851,18 +852,18 @@
 
 		// Update pointers.  Moving ptr keeps the current pointer at the end of the list since the add function does not move the pointer
 		ptr=ptr-&gt;next;
-		position=position-&gt;next;
+		this-&gt;position=this-&gt;position-&gt;next;
 	}
 }
 
 template &lt;class CircularLinkedListType&gt;
 inline void CircularLinkedList&lt;CircularLinkedListType&gt;::sort(void)
 {
-	if (list_size&lt;=1L) return;
+	if (this-&gt;list_size&lt;=1L) return;
 
 	// Call equal operator to assign result of mergesort to current object
 	*this = mergesort(*this);
-	position=root;
+	this-&gt;position=this-&gt;root;
 }
 
 template &lt;class CircularLinkedListType&gt;
@@ -1015,7 +1016,7 @@
 template &lt;class LinkedListType&gt;
 LinkedList&lt;LinkedListType&gt;&amp; LinkedList&lt;LinkedListType&gt;::operator++()
 {
-	if ((list_size!=0L) &amp;&amp; (position-&gt;next!=root)) position=position-&gt;next;
+	if ((this-&gt;list_size!=0L) &amp;&amp; (this-&gt;position-&gt;next!=this-&gt;root)) this-&gt;position=this-&gt;position-&gt;next;
 	return *this;
 }
 /*
@@ -1033,14 +1034,14 @@
 template &lt;class LinkedListType&gt;
 LinkedList&lt;LinkedListType&gt;&amp; LinkedList&lt;LinkedListType&gt;::operator++(int)
 {
-	return operator++();
+	return this-&gt;operator++();
 }
 
 // Prefix
 template &lt;class LinkedListType&gt;
 LinkedList&lt;LinkedListType&gt;&amp; LinkedList&lt;LinkedListType&gt;::operator--()
 {
-	if ((list_size!=0L) &amp;&amp; (position!=root)) position=position-&gt;previous;
+	if ((this-&gt;list_size!=0L) &amp;&amp; (this-&gt;position!=this-&gt;root)) this-&gt;position=this-&gt;position-&gt;previous;
 	return *this;
 }
 /*
@@ -1059,7 +1060,7 @@
 template &lt;class LinkedListType&gt;
 LinkedList&lt;LinkedListType&gt;&amp; LinkedList&lt;LinkedListType&gt;::operator--(int)
 {
-	return operator--();
+	return this-&gt;operator--();
 }
 
 } // End namespace

Modified: trunk/source/libraries/raknet/Multiplayer.h
===================================================================
--- trunk/source/libraries/raknet/Multiplayer.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/Multiplayer.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -33,6 +33,7 @@
 	virtual void ReceiveRemoteConnectionLost(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveRemoteNewIncomingConnection(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveRemoteExistingConnection(Packet *packet,InterfaceType *interfaceType);
+	virtual void ReceiveRemoteStaticData(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveConnectionBanned(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveConnectionRequestAccepted(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveNewIncomingConnection(Packet *packet,InterfaceType *interfaceType);
@@ -46,6 +47,7 @@
 	virtual void ReceiveRemotePortRefused(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveVoicePacket(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceivePong(Packet *packet,InterfaceType *interfaceType);
+	virtual void ReceiveAdvertisedSystem(Packet *packet,InterfaceType *interfaceType);
 	// -----------------------------------------------------------------
 
 	// -----------------------------------------------------------------
@@ -133,6 +135,9 @@
 		case ID_REMOTE_EXISTING_CONNECTION:
 			ReceiveRemoteExistingConnection(p,interfaceType);
 		break;
+		case ID_REMOTE_STATIC_DATA:
+			ReceiveRemoteStaticData(p,interfaceType);
+		break;
 		case ID_CONNECTION_BANNED:
 			ReceiveConnectionBanned(p, interfaceType);
 		break;
@@ -169,6 +174,9 @@
 		case ID_PONG:
 			ReceivePong(p,interfaceType);
 			break;
+		case ID_ADVERTISE_SYSTEM:
+			ReceiveAdvertisedSystem(p,interfaceType);
+			break;
 		case ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT:
 			ReceiveDistributedNetworkObject(p,interfaceType);
 			break;
@@ -276,6 +284,17 @@
 }
 
 template &lt;class InterfaceType&gt;
+void Multiplayer&lt;InterfaceType&gt;::ReceiveRemoteStaticData(Packet *packet,InterfaceType *interfaceType)
+{
+	// A client got the remote static data for another system
+	//  Client only.
+#ifdef _DEBUG
+	printf(&quot;ID_REMOTE_STATIC_DATA from PlayerID:%u:%u on %p.\n&quot;,packet-&gt;playerId.binaryAddress, packet-&gt;playerId.port, interfaceType);
+#endif
+	//	ProcessUnhandledPacket(packet, ID_REMOTE_EXISTING_CONNECTION,interfaceType);
+}
+
+template &lt;class InterfaceType&gt;
 void Multiplayer&lt;InterfaceType&gt;::ReceiveConnectionBanned(Packet *packet,InterfaceType *interfaceType)
 {
 	// We are banned from connecting to the system specified in packet-&gt;playerId
@@ -410,14 +429,31 @@
 {
 	// Peer or client.  Response from a ping for an unconnected system.
 #ifdef _DEBUG
-	unsigned long time;
+	unsigned long time, dataLength;
 	memcpy((char*)&amp;time, packet-&gt;data+sizeof(unsigned char), sizeof(unsigned long));
-	printf(&quot;ID_PONG from PlayerID:%u:%u on %p. Value is %i\n&quot;,packet-&gt;playerId.binaryAddress, packet-&gt;playerId.port, interfaceType, time);
+	dataLength = packet-&gt;length - sizeof(unsigned char) - sizeof(unsigned long);
+	printf(&quot;ID_PONG from PlayerID:%u:%u on %p.\nPing is %i\nData is %i bytes long.\n&quot;,packet-&gt;playerId.binaryAddress, packet-&gt;playerId.port, interfaceType, time, dataLength);
+	if (dataLength &gt; 0)
+		printf(&quot;Data is %s\n&quot;, packet-&gt;data+sizeof(unsigned char)+sizeof(unsigned long));
 #endif
 	//	ProcessUnhandledPacket(packet, ID_PONG,interfaceType);
 }
 
 template &lt;class InterfaceType&gt;
+void Multiplayer&lt;InterfaceType&gt;::ReceiveAdvertisedSystem(Packet *packet,InterfaceType *interfaceType)
+{
+	// Got a packet from another RakNet system indicating that it exists.
+	// Currently this is used for the master server for the server to indicate its external
+	// IP to a client as well as open the NAT
+#ifdef _DEBUG
+	printf(&quot;ID_ADVERTISED_SYSTEM from PlayerID:%u:%u on %p.\nIf you are running a client connecting to a server behind a NAT, you should\ncall Disconnect and connect to the to the IP specified by packet-&gt;playerId instead\n&quot;,packet-&gt;playerId.binaryAddress, packet-&gt;playerId.port, interfaceType);
+#endif
+
+	// When you get this packet, you should disconnect if you are not already connected.  Then connect
+	// To the IP / port given by packet-&gt;playerID.  You can translate a PlayerID to an IP with PlayerIDToDottedIP
+}
+
+template &lt;class InterfaceType&gt;
 void Multiplayer&lt;InterfaceType&gt;::ReceiveDistributedNetworkObject(Packet *packet,InterfaceType *interfaceType)
 {
 	// Packet to create a distributed network object

Modified: trunk/source/libraries/raknet/NetworkTypes.cpp
===================================================================
--- trunk/source/libraries/raknet/NetworkTypes.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/NetworkTypes.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -27,4 +27,3 @@
 {
 	return left.binaryAddress&lt;right.binaryAddress || left.port&lt;right.port;
 }
-

Modified: trunk/source/libraries/raknet/NetworkTypes.h
===================================================================
--- trunk/source/libraries/raknet/NetworkTypes.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/NetworkTypes.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -12,6 +12,7 @@
 
 typedef unsigned short ObjectID;
 typedef unsigned char UniqueIDType;
+typedef unsigned short PlayerIndex;
 
 struct PlayerID
 {
@@ -24,6 +25,7 @@
 	friend int operator &lt; (const PlayerID&amp; left, const PlayerID&amp; right);
 };
 
+
 struct RequestedConnectionStruct
 {
 	PlayerID playerId; // Who we wanted to connect to
@@ -35,10 +37,11 @@
 
 struct Packet
 {
+	PlayerIndex playerIndex; // Server only - this is the index into the player array that this playerId maps to
 	PlayerID playerId;
 	unsigned long length;
 	unsigned long bitSize; // Same as length but represents bits.  Length is obsolete and retained for backwards compatibility
-	char* data;
+	unsigned char* data;
 };
 
 #pragma pack(push,1)
@@ -48,6 +51,7 @@
 	unsigned char typeId;
 	unsigned short remotePort;
 	PlayerID externalID; // We tell the remote system its own IP / port this way
+	PlayerIndex playerIndex; // For internal use
 };
 
 #pragma pack(1)
@@ -85,6 +89,7 @@
 
 #pragma pack(pop)
 
+const PlayerIndex UNASSIGNED_PLAYER_INDEX=65535;
 const PlayerID UNASSIGNED_PLAYER_ID={0xFFFFFFFF, 0xFFFF};
 const ObjectID UNASSIGNED_OBJECT_ID=65535;
 const int PING_TIMES_ARRAY_SIZE=5;

Modified: trunk/source/libraries/raknet/PacketEnumerations.h
===================================================================
--- trunk/source/libraries/raknet/PacketEnumerations.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/PacketEnumerations.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -17,29 +17,30 @@
 	//
 	// Ignore these:
 	ID_PING, // Ping (internal use only)
-	ID_PONG, // Pong.  Returned if we ping a system we are not connected so
+	ID_PING_OPEN_CONNECTIONS, // Only reply to the unconnected ping if we have open connections
 	ID_REQUEST_STATIC_DATA, // Someone asked for our static data (internal use only)
 	ID_CONNECTION_REQUEST, // Asking for a new connection (internal use only)
 	ID_SECURED_CONNECTION_RESPONSE, // Connecting to a secured server/peer
 	ID_SECURED_CONNECTION_CONFIRMATION, // Connecting to a secured server/peer
 	ID_RPC, // Remote procedure call (internal use only)
-	ID_RECEIVED_RELAYED_STATIC_DATA, // Server / Client only - Sending the static data for another system (internal use only)
 	ID_BROADCAST_PINGS, // Server / Client only - The server is broadcasting the pings of all players in the game (internal use only)
 	ID_SET_RANDOM_NUMBER_SEED, // Server / Client only - The server is broadcasting a random number seed (internal use only)
 	ID_RPC_WITH_TIMESTAMP, // Same as RPC, but treat the first 4 bytes as a timestamp
 	// Handle these below.  Possible recipients in [...]
+	ID_PONG, // [CLIENT|PEER] Pong.  Returned if we ping a system we are not connected so.  First byte is ID_PONG, second 4 bytes is the ping, following bytes is system specific enumeration data.
 	ID_RSA_PUBLIC_KEY_MISMATCH, // [CLIENT|PEER] We preset an RSA public key which does not match what the system we connected to is using.
 	ID_REMOTE_DISCONNECTION_NOTIFICATION, // [CLIENT] In a client/server enviroment, a client other than ourselves has disconnected gracefully.  Packet::playerID is modified to reflect the playerID of this client.
 	ID_REMOTE_CONNECTION_LOST, // [CLIENT] In a client/server enviroment, a client other than ourselves has been forcefully dropped.  Packet::playerID is modified to reflect the playerID of this client.
 	ID_REMOTE_NEW_INCOMING_CONNECTION, // [CLIENT] In a client/server enviroment, a client other than ourselves has connected.  Packet::playerID is modified to reflect the playerID of this client.
 	ID_REMOTE_EXISTING_CONNECTION, // [CLIENT] On our initial connection to the server, we are told of every other client in the game.  Packet::playerID is modified to reflect the playerID of this client.
+	ID_REMOTE_STATIC_DATA, // [CLIENT] - Got the data for another client
 	ID_CONNECTION_BANNED, // [PEER|CLIENT] We are banned from the system we attempted to connect to.
 	ID_CONNECTION_REQUEST_ACCEPTED, // [CLIENT] In a client/server enviroment, our connection request to the server has been accepted.
 	ID_NEW_INCOMING_CONNECTION, // [PEER|SERVER] A remote system has successfully connected.
 	ID_NO_FREE_INCOMING_CONNECTIONS, // [PEER|CLIENT] The system we attempted to connect to is not accepting new connections.
 	ID_DISCONNECTION_NOTIFICATION, // [PEER|SERVER|CLIENT] The system specified in Packet::playerID has disconnected from us.  For the client, this would mean the server has shutdown.
 	ID_CONNECTION_LOST, // [PEER|SERVER|CLIENT] Reliable packets cannot be delivered to the system specifed in Packet::playerID.  The connection to that system has been closed.
-	ID_TIMESTAMP, // [PEER|SERVER|CLIENT] The four bytes following this byte represent an unsigned long which is automatically modified by the difference in system times between the sender and the recipient.
+	ID_TIMESTAMP, // [PEER|SERVER|CLIENT] The four bytes following this byte represent an unsigned long which is automatically modified by the difference in system times between the sender and the recipient. Requires that you call StartOccasionalPing.
 	ID_RECEIVED_STATIC_DATA, // [PEER|SERVER|CLIENT] We got a bitstream containing static data.  You can now read this data.  This packet is transmitted automatically on connections, and can also be manually sent.
 	ID_INVALID_PASSWORD, // [PEER|CLIENT] The remote system is using a password and has refused our connection because we did not set the correct password.
 	ID_MODIFIED_PACKET, // [PEER|SERVER|CLIENT] A packet has been tampered with in transit.  The sender is contained in Packet::playerID.
@@ -57,9 +58,8 @@
 	ID_MASTER_SERVER_DELIST_SERVER, // [MASTERSERVER] Remove a game server from the master server.
 	ID_MASTER_SERVER_UPDATE_SERVER, // [MASTERSERVER|MASTERCLIENT] Add or update the information for a server.
 	ID_MASTER_SERVER_SET_SERVER, // [MASTERSERVER|MASTERCLIENT] Add or set the information for a server.
-	ID_RESERVED2, // For future versions
-	ID_RESERVED3, // For future versions
-	ID_RESERVED4, // For future versions
+	ID_RELAYED_CONNECTION_NOTIFICATION, // [MASTERSERVER|MASTERCLIENT] This message indicates a game client is connecting to a game server, and is relayed through the master server.
+	ID_ADVERTISE_SYSTEM, // [PEER|SERVER|CLIENT] Inform a remote system of our IP/Port.
 	ID_RESERVED5, // For future versions
 	ID_RESERVED6, // For future versions
 	ID_RESERVED7, // For future versions

Modified: trunk/source/libraries/raknet/PacketPriority.h
===================================================================
--- trunk/source/libraries/raknet/PacketPriority.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/PacketPriority.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -12,6 +12,7 @@
 
 enum PacketPriority
 {
+	SYSTEM_PRIORITY, // System priority is for system related messaging.  Don't use it.
 	HIGH_PRIORITY,
 	MEDIUM_PRIORITY,
 	LOW_PRIORITY,

Modified: trunk/source/libraries/raknet/Queue.h
===================================================================
--- trunk/source/libraries/raknet/Queue.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/Queue.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -29,6 +29,8 @@
 This function doubles the amount of memory allocated when the queue is filled
 This is better than the linked list version for a queue that doesn't go from one extreme to the other with size changes.
 
+9/04 Giblet - commented out body of compress() function, as it is invalid and breaks newer compilers
+
 */
 
 #ifndef __QUEUE_H
@@ -255,7 +257,7 @@
 template &lt;class queue_type&gt;
 void Queue&lt;queue_type&gt;::compress (void)
 {
-		queue_type* new_array;
+		/*queue_type* new_array;
 
 		if (allocation_size==0) return;
 
@@ -273,7 +275,7 @@
 		
 		// Delete the old array and move the pointer to the new array
 		delete []array;
-		array=new_array;
+		array=new_array;*/
 }
 
 template &lt;class queue_type&gt;

Modified: trunk/source/libraries/raknet/RakClient.cpp
===================================================================
--- trunk/source/libraries/raknet/RakClient.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakClient.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -28,13 +28,12 @@
 {
 }
 
-bool RakClient::Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, bool highPriorityThreads)
+bool RakClient::Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, int threadSleepTimer)
 {
-	if (highPriorityThreads)
-		RakPeer::Initialize(1, clientPort,1);
-	else
-		RakPeer::Initialize(1, clientPort,0);
+	RakPeer::Disconnect(100L);
 
+	RakPeer::Initialize(1, clientPort,threadSleepTimer);
+
 	if (host[0] &lt; '0' || host[0] &gt; '2')
 	{
 		host = (char*) SocketLayer::Instance()-&gt;DomainNameToIP(host);
@@ -52,20 +51,27 @@
 	return RakPeer::Connect(host, serverPort, password, (int)strlen(password));
 }
 
-void RakClient::Disconnect(void)
+void RakClient::Disconnect(unsigned long blockDuration)
 {
-	RakPeer::Disconnect();
+	RakPeer::Disconnect(blockDuration);
 }
 
-void RakClient::InitializeSecurity(unsigned short numberOfBytes, char *RSAe, char *RSAn)
+void RakClient::InitializeSecurity(char *pubKeyP, char *pubKeyQ)
 {
-	RakPeer::InitializeSecurity(numberOfBytes, 0, RSAe, RSAn);
+	RakPeer::InitializeSecurity(pubKeyP, pubKeyQ,0,0);
 }
 
 void RakClient::SetPassword(char *_password)
 {
-	_password[19]=0; // Limit the password length
-	RakPeer::SetIncomingPassword(_password, (int)strlen(_password)+1);
+	if (_password)
+	{
+		_password[19]=0; // Limit the password length
+		RakPeer::SetIncomingPassword(_password, (int)strlen(_password)+1);
+	}
+	else
+	{
+		RakPeer::SetIncomingPassword(0, 0);
+	}
 }
 
 bool RakClient::HasPassword(void) const
@@ -73,18 +79,18 @@
 	return password[0]!=0;
 }
 
-bool RakClient::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream)
+bool RakClient::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel)
 {
 	if (remoteSystemList==0)
 		return false;
-	return RakPeer::Send(data, length, priority, reliability, orderingStream, remoteSystemList[0].playerId, false);
+	return RakPeer::Send(data, length, priority, reliability, orderingChannel, remoteSystemList[0].playerId, false);
 }
 
-bool RakClient::Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream)
+bool RakClient::Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel)
 {
 	if (remoteSystemList==0)
 		return false;
-	return RakPeer::Send(bitStream, priority, reliability, orderingStream, remoteSystemList[0].playerId, false);
+	return RakPeer::Send(bitStream, priority, reliability, orderingChannel, remoteSystemList[0].playerId, false);
 }
 
 Packet* RakClient::Receive(void)
@@ -94,10 +100,16 @@
 	// Intercept specific client / server feature packets
 	if (packet)
 	{
-		BitStream bitStream(packet-&gt;data, packet-&gt;length, false);
+		RakNet::BitStream bitStream((char*)packet-&gt;data, packet-&gt;length, false);
 		bitStream.IgnoreBits(8); // Ignore identifier
 		int i;
-		if (
+		if (packet-&gt;data[0]==ID_CONNECTION_REQUEST_ACCEPTED)
+		{
+			ConnectionAcceptStruct* cas = (ConnectionAcceptStruct*) packet-&gt;data;
+			localPlayerIndex = cas-&gt;playerIndex;
+			packet-&gt;playerIndex=cas-&gt;playerIndex;
+		}
+		else if (
 			packet-&gt;data[0]==ID_REMOTE_NEW_INCOMING_CONNECTION ||
 			packet-&gt;data[0]==ID_REMOTE_EXISTING_CONNECTION ||
 			packet-&gt;data[0]==ID_REMOTE_DISCONNECTION_NOTIFICATION ||
@@ -105,29 +117,36 @@
 		{
 			bitStream.Read(packet-&gt;playerId.binaryAddress);
 			bitStream.Read(packet-&gt;playerId.port);
+			if (bitStream.Read((unsigned short&amp;)packet-&gt;playerIndex)==false)
+			{
+				DeallocatePacket(packet);
+				return 0;
+			}
 
-			i = GetOtherClientIndexByPlayerID(packet-&gt;playerId);
-			if (i&gt;=0)
-				otherClients[i].isActive=false;
+
+			if (packet-&gt;data[0]==ID_REMOTE_DISCONNECTION_NOTIFICATION ||
+				packet-&gt;data[0]==ID_REMOTE_CONNECTION_LOST)
+			{
+				i = GetOtherClientIndexByPlayerID(packet-&gt;playerId);
+				if (i&gt;=0)
+					otherClients[i].isActive=false;
+			}			
 		}
-		else if (packet-&gt;data[0]==ID_RECEIVED_RELAYED_STATIC_DATA)
+		else if (packet-&gt;data[0]==ID_REMOTE_STATIC_DATA)
 		{
-			PlayerID staticDataOriginator;
-			bitStream.Read(staticDataOriginator.binaryAddress);
-			bitStream.Read(staticDataOriginator.port);
+			bitStream.Read(packet-&gt;playerId.binaryAddress);
+			bitStream.Read(packet-&gt;playerId.port);
 
-			i = GetOtherClientIndexByPlayerID(staticDataOriginator);
+			i = GetOtherClientIndexByPlayerID(packet-&gt;playerId);
 			if (i &lt; 0)
 				i=GetFreeOtherClientIndex();
 			if (i&gt;=0)
 			{
-				otherClients[i].playerId=staticDataOriginator;
+				otherClients[i].playerId=packet-&gt;playerId;
 				otherClients[i].isActive=true;
 				otherClients[i].staticData.Reset();
 				// The static data is what is left over in the stream
 				otherClients[i].staticData.Write((char*)bitStream.GetData()+BITS_TO_BYTES(bitStream.GetReadOffset()), bitStream.GetNumberOfBytesUsed()-BITS_TO_BYTES(bitStream.GetReadOffset()));
-				DeallocatePacket(packet);
-				return 0;
 			}
 		}
 		else if (packet-&gt;data[0]==ID_BROADCAST_PINGS)
@@ -189,10 +208,10 @@
 	RakPeer::Ping(remoteSystemList[0].playerId);
 }
 
-void RakClient::PingServer(char* host, unsigned short serverPort, unsigned short clientPort)
+void RakClient::PingServer(char* host, unsigned short serverPort, unsigned short clientPort, bool onlyReplyOnAcceptingConnections)
 {
 	RakPeer::Initialize(1, clientPort,0);
-	RakPeer::Ping(host, serverPort);
+	RakPeer::Ping(host, serverPort, onlyReplyOnAcceptingConnections);
 }
 
 int RakClient::GetAveragePing(void)
@@ -245,7 +264,7 @@
 
 unsigned long RakClient::GetSynchronizedRandomInteger(void) const
 {
-	if (getTime() &gt; nextSeedUpdate)
+	if (RakNetGetTime() &gt; nextSeedUpdate)
 		return nextSeed;
 	else
 		return seed;
@@ -287,18 +306,18 @@
 	RakPeer::UnregisterAsRemoteProcedureCall(uniqueID);
 }
 
-bool RakClient::RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp)
+bool RakClient::RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp)
 {
 	if (remoteSystemList==0)
 		return false;
-	return RakPeer::RPC(uniqueID, data, bitLength, priority, reliability, orderingStream, remoteSystemList[0].playerId, false, shiftTimestamp);
+	return RakPeer::RPC(uniqueID, data, bitLength, priority, reliability, orderingChannel, remoteSystemList[0].playerId, false, shiftTimestamp);
 }
 
-bool RakClient::RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp)
+bool RakClient::RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp)
 {
 	if (remoteSystemList==0)
 		return false;
-	return RakPeer::RPC(uniqueID, parameters, priority, reliability, orderingStream, remoteSystemList[0].playerId, false, shiftTimestamp);
+	return RakPeer::RPC(uniqueID, parameters, priority, reliability, orderingChannel, remoteSystemList[0].playerId, false, shiftTimestamp);
 }
 
 /*
@@ -329,7 +348,7 @@
 	return RakPeer::GetDecompressionRatio();
 }
 
-BitStream* RakClient::GetStaticServerData(void)
+RakNet::BitStream * RakClient::GetStaticServerData(void)
 {
 	if (remoteSystemList==0)
 		return 0;
@@ -343,7 +362,7 @@
 	RakPeer::SetRemoteStaticData(remoteSystemList[0].playerId, data, length);
 }
 
-BitStream* RakClient::GetStaticClientData(PlayerID playerId)
+RakNet::BitStream * RakClient::GetStaticClientData(PlayerID playerId)
 {
 	int i;
 
@@ -433,71 +452,21 @@
 	return RakPeer::GetMTUSize();
 }
 
-double RakClient::GetPacketlossPercentile(void)
+void RakClient::AllowConnectionResponseIPMigration(bool allow)
 {
-	return RakPeer::GetPacketlossPercentile();
+	RakPeer::AllowConnectionResponseIPMigration(allow);
 }
 
-unsigned long RakClient::GetTransmittedPacketCount(void)
+void RakClient::AdvertiseSystem(char *host, unsigned short remotePort)
 {
-	return RakPeer::GetTransmittedPacketCount();
+	RakPeer::AdvertiseSystem(host, remotePort);
 }
 
-unsigned long RakClient::GetTransmittedFrameCount(void)
+RakNetStatisticsStruct* const RakClient::GetStatistics(void)
 {
-	return RakPeer::GetTransmittedFrameCount();
+	return RakPeer::GetStatistics(remoteSystemList[0].playerId);
 }
 
-unsigned long RakClient::GetLostPacketCount(void)
-{
-	return RakPeer::GetLostPacketCount();
-}
-
-unsigned long RakClient::GetReceivedPacketCount(void)
-{
-	return RakPeer::GetReceivedPacketCount();
-}
-
-unsigned long RakClient::GetBytesSent(void)
-{
-	return RakPeer::GetBytesSent();
-}
-
-unsigned long RakClient::GetBytesReceived(void)
-{
-	return RakPeer::GetBytesReceived();
-}
-
-unsigned long RakClient::GetUnacknowledgedSentPacketListSize(void)
-{
-	return RakPeer::GetUnacknowledgedSentPacketListSize();
-}
-
-unsigned long RakClient::GetBytesSentPerSecond(void) const
-{
-	return RakPeer::GetBytesSentPerSecond();
-}
-
-unsigned long RakClient::GetBytesReceivedPerSecond(void) const
-{
-	return RakPeer::GetBytesReceivedPerSecond();
-}
-
-unsigned long RakClient::GetMaximumWindowSize(void)
-{
-	return RakPeer::GetMaximumWindowSize();
-}
-
-unsigned long RakClient::GetPacketOutputBufferSize(void)
-{
-	return RakPeer::GetPacketOutputBufferSize();
-}
-
-unsigned long RakClient::GetConnectionTime(void)
-{
-	return RakPeer::GetConnectionTime(RakPeer::GetInternalID());
-}
-
 int RakClient::GetOtherClientIndexByPlayerID(PlayerID playerId)
 {
 	unsigned i;
@@ -520,3 +489,7 @@
 	return -1;
 }
 
+PlayerIndex RakClient::GetPlayerIndex(void)
+{
+	return localPlayerIndex;
+}

Modified: trunk/source/libraries/raknet/RakClient.h
===================================================================
--- trunk/source/libraries/raknet/RakClient.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakClient.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -1,4 +1,4 @@
-// This file is part of RakNet Copyright 2003, 2004 Rakkarsoft LLC and Kevin Jenkins.
+// This file is part of RarkNet Copyright 2003, 2004 Rakkarsoft LLC and Kevin Jenkins.
 
 // Usage of Raknet is subject to the appropriate licence agreement.
 // &quot;Shareware&quot; Licensees with Rakkarsoft LLC are subject to the shareware license found at <A HREF="http://www.rakkarsoft.com/shareWareLicense.html">http://www.rakkarsoft.com/shareWareLicense.html</A> which you agreed to upon purchase of a &quot;Shareware license&quot;
@@ -28,14 +28,15 @@
 	// serverPort is which port to connect to on the remote machine. clientPort is the port you want the client to use.
 	// Both ports must be open for UDP
 	// validationInteger is legacy and unused
-	// Set highPriorityThreads to true (recommended) for a real-time responsive client.  Set it to false
-	// for games where high pings don't matter, or if the network engine slows down the game too much
+	// _threadSleepTimer: &lt;0 for single threaded, &gt;=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	// Returns true on successful initiation, false otherwise
-	bool Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, bool highPriorityThreads);
+	bool Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, int threadSleepTimer);
 
 	// Stops the client, stops synchronized data, and resets all internal data. 
 	// Does nothing if the client is not connected to begin with
-	void Disconnect(void);
+	// blockDuration is how long you should wait for all remaining packets to go out
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	void Disconnect(unsigned long blockDuration);
 
 	// Description:
 	// Can be called to use specific public RSA keys. (e and n)
@@ -43,10 +44,8 @@
 	// If a key has been altered.
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	void InitializeSecurity(unsigned short numberOfBytes, char *RSAe, char *RSAn);
+	// pubKeyP, pubKeyQ - Public keys generated from the RSACrypt class.  See the Encryption sample.  Can be 0
+	void InitializeSecurity(char *pubKeyP, char *pubKeyQ);
 
 	// Set the password to use when connecting to a server.  The password persists between connections.
 	// Pass 0 for no password.
@@ -57,13 +56,13 @@
 
 	// This function only works while the client is connected (Use the Connect function).  Returns false on failure, true on success
 	// Sends the data stream of length length
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
-	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream);
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
+	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel);
 
 	// This function only works while the client is connected (Use the Connect function).  Returns false on failure, true on success
 	// Sends the BitStream
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
-	bool Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream);
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
+	bool Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel);
 
 	// Call this to get a packet from the incoming packet queue. Use DeallocatePacket to deallocate the packet after you are done with it.
 	// Check the Packet struct at the top of CoreNetworkStructures.h for the format of the struct
@@ -84,7 +83,10 @@
 	// networking system if it is not already initialized.  You can stop the networking system
 	// by calling Disconnect()
 	// The final ping time will be encoded in the following 4 bytes (2-5) as an unsigned long
-	void PingServer(char* host, unsigned short serverPort, unsigned short clientPort);
+	// You can specify if the server should only reply if it has an open connection or not
+	// This must be true for LAN broadcast server discovery on &quot;255.255.255.255&quot;
+	// or you will get replies from clients as well.
+	void PingServer(char* host, unsigned short serverPort, unsigned short clientPort, bool onlyReplyOnAcceptingConnections);
 
 	// Returns the average of all ping times read
 	int GetAveragePing(void);
@@ -183,8 +185,8 @@
 	// If you want that function to return data you should call RPC from that system in the same way
 	// Returns true on a successful packet send (this does not indicate the recipient performed the call), false on failure
 	// The uniqueID must be composed of a string with only characters from a-z and is not case sensitive
-	bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp);
-	bool RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp);
+	bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp);
+	bool RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp);
 
 	// Handles an RPC packet.  If you get a packet with the ID ID_RPC you should pass it to this function
 	// This is already done in Multiplayer.cpp, so if you use the Multiplayer class it is handled for you.
@@ -218,12 +220,12 @@
 	// The data is entered as an array and stored and returned as a BitStream.  
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...-&gt;GetStaticServerData(...);
+	// RakNet::BitStream *copy = ...-&gt;GetStaticServerData(...);
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
 	// Note that the server may change at any time the
 	// data contents and/or its length!
-	BitStream* GetStaticServerData(void);
+	RakNet::BitStream * GetStaticServerData(void);
 	void SetStaticServerData(char *data, const long length);
 
 	// The client internally maintains a data struct that is automatically sent to the server on connection
@@ -235,10 +237,10 @@
 	// The data is entered as an array and stored and returned as a BitStream.
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...-&gt;GetStaticServerData(...);
+	// RakNet::BitStream *copy = ...-&gt;GetStaticServerData(...);
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
-	BitStream* GetStaticClientData(PlayerID playerId);
+	RakNet::BitStream * GetStaticClientData(PlayerID playerId);
 	void SetStaticClientData(PlayerID playerId, char *data, const long length);
 
 	// Send the static server data to the server
@@ -285,21 +287,33 @@
 	// Returns the current MTU size
 	int GetMTUSize(void) const;
 
-	// Network statistics.
-	double GetPacketlossPercentile(void); // The average outgoing packetloss percentile
-	unsigned long GetTransmittedPacketCount(void); // How many packets were sent
-	unsigned long GetTransmittedFrameCount(void); // How many frames were sent	
-	unsigned long GetLostPacketCount(void); // How many packets were lost
-	unsigned long GetReceivedPacketCount(void); // How many packets were received
-	unsigned long GetBytesSent(void); // How many bytes have been sent.
-	unsigned long GetBytesReceived(void); // How many bytes have been received.
-	unsigned long GetUnacknowledgedSentPacketListSize(void); // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	unsigned long GetBytesSentPerSecond(void) const;  // How many bytes were sent in the last histogram block.
-	unsigned long GetBytesReceivedPerSecond(void) const; // How many bytes were received in the last histogram block.
-	unsigned long GetMaximumWindowSize(void); // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	unsigned long GetPacketOutputBufferSize(void); // Returns the number of waiting packets on the send queue
-	unsigned long GetConnectionTime(void); // Returns the time elapsed since you connected
+	// Description:
+	// Allow or disallow connection responses from any IP.  Normally this should be false, but may be necessary
+	// when connection to servers with multiple IP addresses.
+	//
+	// Parameters:
+	// allow - True to allow this behavior, false to not allow.  Defaults to false.  Value persists between connections
+	void AllowConnectionResponseIPMigration(bool allow);
 
+	// Description:
+	// Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system.
+	// This will tell the remote system our external IP outside the LAN, and can be used for NAT punch through
+	//
+	// host: Either a dotted IP address or a domain name
+	// remotePort: Which port to connect to on the remote machine.
+	void AdvertiseSystem(char *host, unsigned short remotePort);
+
+	// Description:
+	// Returns a structure containing a large set of network statistics for the server/client connection
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	RakNetStatisticsStruct * const GetStatistics(void);
+
+	// For internal use
+	PlayerIndex GetPlayerIndex(void);
+
 	private:
 
 	int GetOtherClientIndexByPlayerID(PlayerID playerId);
@@ -310,11 +324,12 @@
 	{
 		PlayerID playerId;
 		short ping;
-		BitStream staticData;
+		RakNet::BitStream staticData;
 		bool isActive;
 	} otherClients[32];
 	// Synchronized random integer
 	unsigned long seed, nextSeed, nextSeedUpdate;
+	PlayerIndex localPlayerIndex;
 	PlayerID externalPlayerID; // This is your external ID (and also IP) (returned from the server)
 };
 

Modified: trunk/source/libraries/raknet/RakClientInterface.h
===================================================================
--- trunk/source/libraries/raknet/RakClientInterface.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakClientInterface.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -13,7 +13,8 @@
 #include &quot;NetworkTypes.h&quot;
 #include &quot;PacketPriority.h&quot;
 #include &quot;RakPeerInterface.h&quot;
-class BitStream;
+#include &quot;BitStream.h&quot;
+#include &quot;RakNetStatistics.h&quot;
 
 class RakClientInterface
 {
@@ -27,14 +28,15 @@
 	// serverPort is which port to connect to on the remote machine. clientPort is the port you want the client to use.
 	// Both ports must be open for UDP
 	// validationInteger is legacy and unused
-	// Set highPriorityThreads to true (recommended) for a real-time responsive client.  Set it to false
-	// for games where high pings don't matter, or if the network engine slows down the game too much
+	// _threadSleepTimer: &lt;0 for single threaded, &gt;=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	// Returns true on successful initiation, false otherwise
-	virtual bool Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, bool highPriorityThreads)=0;
+	virtual bool Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, int threadSleepTimer)=0;
 
 	// Stops the client, stops synchronized data, and resets all internal data. 
 	// Does nothing if the client is not connected to begin with
-	virtual void Disconnect(void)=0;
+	// blockDuration is how long you should wait for all remaining packets to go out
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	virtual void Disconnect(unsigned long blockDuration)=0;
 
 	// Description:
 	// Can be called to use specific public RSA keys. (e and n)
@@ -42,10 +44,8 @@
 	// If a key has been altered.
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	virtual void InitializeSecurity(unsigned short numberOfBytes, char *RSAe, char *RSAn)=0;
+	// pubKeyP, pubKeyQ - Public keys generated from the RSACrypt class.  See the Encryption sample.  Can be 0
+	virtual void InitializeSecurity(char *pubKeyP, char *pubKeyQ)=0;
 
 	// Set the password to use when connecting to a server.  The password persists between connections.
 	// Pass 0 for no password.
@@ -56,13 +56,13 @@
 
 	// This function only works while the client is connected (Use the Connect function).  Returns false on failure, true on success
 	// Sends the data stream of length length
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
-	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream)=0;
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
+	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel)=0;
 
 	// This function only works while the client is connected (Use the Connect function).  Returns false on failure, true on success
 	// Sends the BitStream
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
-	virtual bool Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream)=0;
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
+	virtual bool Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel)=0;
 
 	// Call this to get a packet from the incoming packet queue. Use DeallocatePacket to deallocate the packet after you are done with it.
 	// Check the Packet struct at the top of CoreNetworkStructures.h for the format of the struct
@@ -83,7 +83,10 @@
 	// networking system if it is not already initialized.  You can stop the networking system
 	// by calling Disconnect()
 	// The final ping time will be encoded in the following 4 bytes (2-5) as an unsigned long
-	virtual void PingServer(char* host, unsigned short serverPort, unsigned short clientPort)=0;
+	// You can specify if the server should only reply if it has an open connection or not
+	// This must be true for LAN broadcast server discovery on &quot;255.255.255.255&quot;
+	// or you will get replies from clients as well.
+	virtual void PingServer(char* host, unsigned short serverPort, unsigned short clientPort, bool onlyReplyOnAcceptingConnections)=0;
 
 	// Returns the average of all ping times read
 	virtual int GetAveragePing(void)=0;
@@ -182,8 +185,8 @@
 	// If you want that function to return data you should call RPC from that system in the same way
 	// Returns true on a successful packet send (this does not indicate the recipient performed the call), false on failure
 	// The uniqueID must be composed of a string with only characters from a-z and is not case sensitive
-	virtual bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp)=0;
-	virtual bool RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp)=0;
 
 	// OBSOLETE - DONE AUTOMATICALLY
 	// Handles an RPC packet.  If you get a packet with the ID ID_RPC you should pass it to this function
@@ -218,12 +221,12 @@
 	// The data is entered as an array and stored and returned as a BitStream.  
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...-&gt;GetStaticServerData(...)=0;
+	// RakNet::BitStream *copy = ...-&gt;GetStaticServerData(...)=0;
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
 	// Note that the server may change at any time the
 	// data contents and/or its length!
-	virtual BitStream* GetStaticServerData(void)=0;
+	virtual RakNet::BitStream * GetStaticServerData(void)=0;
 	virtual void SetStaticServerData(char *data, const long length)=0;
 
 	// The client internally maintains a data struct that is automatically sent to the server on connection
@@ -235,10 +238,10 @@
 	// The data is entered as an array and stored and returned as a BitStream.
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...-&gt;GetStaticServerData(...)=0;
+	// RakNet::BitStream *copy = ...-&gt;GetStaticServerData(...)=0;
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
-	virtual BitStream* GetStaticClientData(PlayerID playerId)=0;
+	virtual RakNet::BitStream * GetStaticClientData(PlayerID playerId)=0;
 	virtual void SetStaticClientData(PlayerID playerId, char *data, const long length)=0;
 
 	// Send the static server data to the server
@@ -285,20 +288,32 @@
 	// Returns the current MTU size
 	virtual int GetMTUSize(void) const=0;
 
-	// Network statistics.
-	virtual double GetPacketlossPercentile(void)=0; // The average outgoing packetloss percentile
-	virtual unsigned long GetTransmittedPacketCount(void)=0; // How many packets were sent
-	virtual unsigned long GetTransmittedFrameCount(void)=0; // How many frames were sent	
-	virtual unsigned long GetLostPacketCount(void)=0; // How many packets were lost
-	virtual unsigned long GetReceivedPacketCount(void)=0; // How many packets were received
-	virtual unsigned long GetBytesSent(void)=0; // How many bytes have been sent.
-	virtual unsigned long GetBytesReceived(void)=0; // How many bytes have been received.
-	virtual unsigned long GetUnacknowledgedSentPacketListSize(void)=0; // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	virtual unsigned long GetBytesSentPerSecond(void) const=0;  // How many bytes were sent in the last histogram block.
-	virtual unsigned long GetBytesReceivedPerSecond(void) const=0; // How many bytes were received in the last histogram block.
-	virtual unsigned long GetMaximumWindowSize(void)=0; // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	virtual unsigned long GetPacketOutputBufferSize(void)=0; // Returns the number of waiting packets on the send queue
-	virtual unsigned long GetConnectionTime(void)=0; // Returns the time elapsed since you connected
+	// Description:
+	// Allow or disallow connection responses from any IP.  Normally this should be false, but may be necessary
+	// when connection to servers with multiple IP addresses.
+	//
+	// Parameters:
+	// allow - True to allow this behavior, false to not allow.  Defaults to false.  Value persists between connections
+	virtual void AllowConnectionResponseIPMigration(bool allow)=0;
+
+	// Description:
+	// Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system.
+	// This will tell the remote system our external IP outside the LAN, and can be used for NAT punch through
+	//
+	// host: Either a dotted IP address or a domain name
+	// remotePort: Which port to connect to on the remote machine.
+	virtual void AdvertiseSystem(char *host, unsigned short remotePort)=0;
+
+	// Description:
+	// Returns a structure containing a large set of network statistics for the server/client connection
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	virtual RakNetStatisticsStruct * const GetStatistics(void)=0;
+
+	// For internal use
+	virtual PlayerIndex GetPlayerIndex(void)=0;
 };
 
 #endif

Modified: trunk/source/libraries/raknet/RakNetworkFactory.h
===================================================================
--- trunk/source/libraries/raknet/RakNetworkFactory.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakNetworkFactory.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -14,16 +14,16 @@
 class RakPeerInterface;
 
 #ifdef _WIN32
-#define EXPORT __declspec(dllexport)
+#define RAK_DLL_EXPORT __declspec(dllexport)
 #else
 // Unix needs no export, but for name mangling, keep the function name
 // clean. If you omit the 'extern &quot;C&quot;', the .so names will be
 // compiler dependent.
-#define EXPORT extern &quot;C&quot;
+#define RAK_DLL_EXPORT extern &quot;C&quot;
 #endif
 
 #if defined(DLL_EXPORTS) || defined(_USRDLL)
-class EXPORT RakNetworkFactory
+class RAK_DLL_EXPORT RakNetworkFactory
 #else
 //class __declspec( dllimport ) RakNetworkFactory
 class RakNetworkFactory

Modified: trunk/source/libraries/raknet/RakPeer.cpp
===================================================================
--- trunk/source/libraries/raknet/RakPeer.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakPeer.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -27,20 +27,33 @@
 #include &quot;PacketEnumerations.h&quot;
 #include &quot;HuffmanEncodingTree.h&quot;
 #include &quot;PacketPool.h&quot;
-#include &quot;RSA.h&quot;
 #include &quot;Rand.h&quot;
 
+// alloca
+#ifdef _WIN32
+#include &lt;malloc.h&gt;
+#else
+#include &lt;stdlib.h&gt;
+#endif
+
 static const unsigned long SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION=5000;
 
+// UPDATE_THREAD_POLL_TIME is how often the update thread will poll to see
+// if receive wasn't called within UPDATE_THREAD_UPDATE_TIME.  If it wasn't called within that time,
+// the updating thread will activate and take over network communication until Receive is called again.
+//static const unsigned long UPDATE_THREAD_UPDATE_TIME=30;
+//static const unsigned long UPDATE_THREAD_POLL_TIME=30;
 
+//#define _TEST_AES
+
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 // Constructor
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 RakPeer::RakPeer()
 {
-	securedConnectionByteSize=0;
+	usingSecurity=false;
 	memset(frequencyTable, 0, sizeof(unsigned long) * 256);
-	rawBytesSent=rawBytesRecieved=compressedBytesSent=compressedBytesRecieved=0;
+	rawBytesSent=rawBytesReceived=compressedBytesSent=compressedBytesReceived=0;
 	outputTree=inputTree=0;
 	connectionSocket=INVALID_SOCKET;
 	MTUSize=DEFAULT_MTU_SIZE;
@@ -51,10 +64,11 @@
 	bytesSentPerSecond=bytesReceivedPerSecond=0;
 	endThreads=true;
 	isMainLoopThreadActive=false;
-	isRecvfromThreadActive=false;
-	occasionalPing=true;
+//	isRecvfromThreadActive=false;
+	occasionalPing=false;
 	connectionSocket=INVALID_SOCKET;
 	myPlayerId=UNASSIGNED_PLAYER_ID;
+	allowConnectionResponseIPMigration=false;
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -64,7 +78,7 @@
 {
 	unsigned i;
 
-	Disconnect();
+	Disconnect(0L);
 
 	// Clear out the lists:
 	for (i=0; i &lt; requestedConnectionsList.size(); i++)
@@ -86,12 +100,12 @@
 // - A pure client would set this to 1.  A pure server would set it to the number of allowed clients.
 // - A hybrid would set it to the sum of both types of connections
 // localPort: The port to listen for connections on.
-// _threadPriority: 0 for regular priority (0-8 players), 1 for high priority (High performance applications), and 2 for ultra-high priority (MMO server)
+// _threadSleepTimer: &lt;0 for single threaded, &gt;=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 //
 // Returns:
 // False on failure (can't create socket or thread), true on success.
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-bool RakPeer::Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadPriority)
+bool RakPeer::Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadSleepTimer)
 {
 	unsigned i;
 
@@ -108,13 +122,15 @@
 
 	if (maximumNumberOfPeers==0)
 	{
-		rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
+		if (threadSleepTimer&gt;=0)
+			rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
 		remoteSystemList = new RemoteSystemStruct[MaximumNumberOfPeers];
 		for (i=0; i &lt; MaximumNumberOfPeers; i++)
 		{
 			remoteSystemList[i].playerId=UNASSIGNED_PLAYER_ID;
 		}
-		rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Unlock();
+		if (threadSleepTimer&gt;=0)
+			rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Unlock();
 
 		// Don't allow more incoming connections than we have peers.
 		if (maximumIncomingConnections&gt;MaximumNumberOfPeers)
@@ -123,108 +139,93 @@
 		maximumNumberOfPeers=MaximumNumberOfPeers;
 	}
 
+	// For histogram statistics
+//	nextReadBytesTime=0;
+//	lastSentBytes=lastReceivedBytes=0;
+
 	if (endThreads)
 	{
+		lastUserUpdateCycle=0;
+
 		// Reset the frequency table that we use to save outgoing data
 		memset(frequencyTable, 0, sizeof(unsigned long) * 256);
 
 		// Reset the statistical data
-		rawBytesSent=rawBytesRecieved=compressedBytesSent=compressedBytesRecieved=0;
+		rawBytesSent=rawBytesReceived=compressedBytesSent=compressedBytesReceived=0;
 
+		updateCycleIsRunning=false;
 		endThreads=false;
 		// Create the threads
-		threadPriority=_threadPriority;
+		threadSleepTimer=_threadSleepTimer;
 
 		char ipList[10][16];
 		SocketLayer::Instance()-&gt;GetMyIP(ipList);
 		myPlayerId.port=localPort;
 		myPlayerId.binaryAddress=inet_addr(ipList[0]);
 
+		if (threadSleepTimer &gt;=0)
+		{
 #ifdef _WIN32
-		if (isMainLoopThreadActive==false)
-		{
-			unsigned ProcessPacketsThreadID=0;
-			processPacketsThreadHandle=(HANDLE)_beginthreadex(NULL, 0, UpdateNetworkLoop, this, 0, &amp;ProcessPacketsThreadID);
-			if (threadPriority==2 &amp;&amp; processPacketsThreadHandle)
-				SetThreadPriority(processPacketsThreadHandle, THREAD_PRIORITY_HIGHEST);
-			else if (processPacketsThreadHandle==0)
+			if (isMainLoopThreadActive==false)
 			{
-				Disconnect();
-				return false;
-			}
+				unsigned ProcessPacketsThreadID=0;
+				processPacketsThreadHandle=(HANDLE)_beginthreadex(NULL, 0, UpdateNetworkLoop, this, 0, &amp;ProcessPacketsThreadID);
 
-			CloseHandle(processPacketsThreadHandle);
-			processPacketsThreadHandle=0;
+				if (processPacketsThreadHandle==0)
+				{
+					Disconnect(0L);
+					return false;
+				}
 
-		}
+				//	SetThreadPriority(processPacketsThreadHandle, THREAD_PRIORITY_HIGHEST);
 
-		if (isRecvfromThreadActive==false)
-		{
-			unsigned recvfromThreadID=0;
-			recvfromThreadHandle=(HANDLE)_beginthreadex(NULL, 0, RecvFromNetworkLoop, this, 0, &amp;recvfromThreadID);
+				CloseHandle(processPacketsThreadHandle);
+				processPacketsThreadHandle=0;
 
-#ifndef __USE_IO_COMPLETION_PORTS
-			if (threadPriority==2 &amp;&amp; recvfromThreadHandle)
-				SetThreadPriority(recvfromThreadHandle, THREAD_PRIORITY_HIGHEST);
-#endif
-
-			if (recvfromThreadHandle==0)
-			{
-				Disconnect();
-				return false;
 			}
 
-			CloseHandle(recvfromThreadHandle);
-			recvfromThreadHandle=0;
-		}
-
 #else
-		pthread_attr_t attr;
+			pthread_attr_t attr;
 
-		pthread_attr_init( &amp;attr );
-		pthread_attr_setdetachstate( &amp;attr, PTHREAD_CREATE_DETACHED );
-		if (threadPriority==2)
-		{
-			sched_param sp;
-			sp.sched_priority = sched_get_priority_max(SCHED_OTHER);
-			pthread_attr_setschedparam(&amp;attr, &amp;sp);
-		}
+			pthread_attr_init( &amp;attr );
+			pthread_attr_setdetachstate( &amp;attr, PTHREAD_CREATE_DETACHED );
 
-		int error;
+			//		sched_param sp;
+			//		sp.sched_priority = sched_get_priority_max(SCHED_OTHER);
+			//		pthread_attr_setschedparam(&amp;attr, &amp;sp);
 
-		if (isMainLoopThreadActive==false)
-		{
-			error = pthread_create( &amp;processPacketsThreadHandle, &amp;attr, &amp;UpdateNetworkLoop, this );
-			if (error)
-			{
-				Disconnect();
-				return false;
-			}
-		}
+			int error;
 
-		if (	isRecvfromThreadActive==false)
-		{
-			error = pthread_create( &amp;recvfromThreadHandle, &amp;attr, &amp;RecvFromNetworkLoop, this );
-			if (error)
+			if (isMainLoopThreadActive==false)
 			{
-				Disconnect();
-				return false;
+				error = pthread_create( &amp;processPacketsThreadHandle, &amp;attr, &amp;UpdateNetworkLoop, this );
+				if (error)
+				{
+					Disconnect(0L);
+					return false;
+				}
 			}
-		}
-		pthread_attr_destroy( &amp;attr );
 
-		processPacketsThreadHandle=0;
+			processPacketsThreadHandle=0;
 #endif
 
-		// Wait for the threads to activate.  When they are active they will set these variables to true
-		while (isRecvfromThreadActive==false || isMainLoopThreadActive==false)
+
+			// Wait for the threads to activate.  When they are active they will set these variables to true
+			while (/*isRecvfromThreadActive==false || */isMainLoopThreadActive==false)
 #ifdef _WIN32
-			Sleep(10);
+				Sleep(10);
 #else
-			usleep(10 * 1000);
+				usleep(10 * 1000);
 #endif
 
-	}
+		}
+		else
+		{
+#ifdef __USE_IO_COMPLETION_PORTS
+			AsynchronousFileIO::Instance()-&gt;IncreaseUserCount();
+#endif
+		}
+	}		
 
 	return true;
 }
@@ -240,57 +241,61 @@
 // If you accept connections, you must call this or else secure connections will not be enabled
 // for incoming connections.
 // If you are connecting to another system, you can call this with values for the
-// (e and n) public keys before connecting to prevent MitM
+// (e and p,q) public keys before connecting to prevent MitM
 //
 // Parameters:
-// numberOfBytes:  How many bytes to use for each of the RSA keys.
-// RSAd - A pointer to the private key of length numberOfBytes.
-// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
+// pubKeyP, pubKeyQ - Public keys generated from the RSACrypt class.  See the Encryption sample
+// privKeyE, privKeyN - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+// If the private keys are 0, then a new key will be generated when this function is called
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-void RakPeer::InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn)
+void RakPeer::InitializeSecurity(char *pubKeyP, char *pubKeyQ, char *privKeyE, char *privKeyN)
 {
 	if (endThreads==false)
 		return;
 
-	// You can specify e and n, d and e and n, or none.  Any other combination is invalid
-	if (!((RSAe &amp;&amp; RSAn) || (RSAd==0 &amp;&amp; RSAe==0 &amp;&amp; RSAn==0)))
+	// Setting the client key is e,n,
+	// Setting the server key is p,q
+	// These are mutually exclusive
+	if ((pubKeyP &amp;&amp; pubKeyQ &amp;&amp; (privKeyE || privKeyN)) ||
+		(privKeyE &amp;&amp; privKeyN &amp;&amp; (pubKeyP || pubKeyQ)) ||
+		(pubKeyP &amp;&amp; pubKeyQ==0) ||
+		(pubKeyQ &amp;&amp; pubKeyP==0) ||
+		(privKeyE &amp;&amp; privKeyN==0) ||
+		(privKeyN &amp;&amp; privKeyE==0))
 	{
+		// Invalid parameters
 		assert(0);
-		return;
 	}
 
-	// For whatever reason the encoder / decoder fails randomly with data length 20 and bytes less than 32.
-	assert(numberOfBytes &gt;= 32);
-	if (numberOfBytes &lt; 32)
-	{
-		numberOfBytes=32;
-	}
+	seedMT(RakNetGetTime());
 
-	seedMT(getTime());
+	GenerateSYNCookieRandomNumber();
 
-	securedConnectionByteSize=numberOfBytes;
+	usingSecurity=true;
 
-	// Generate RSA keys
-	d.Init(numberOfBytes);
-	e.Init(numberOfBytes);
-	n.Init(numberOfBytes);
-
-	GenerateSYNCookieRandomNumber();
-
-	if (RSAd==0 &amp;&amp; RSAe==0 &amp;&amp; RSAn==0)
+	if (pubKeyP==0 &amp;&amp; pubKeyQ==0 &amp;&amp;privKeyE==0 &amp;&amp; privKeyN==0)
 	{
 		keysLocallyGenerated=true;
-		GenerateKeys(d,e,n);
+		rsacrypt.generateKeys();
 	}
 	else
 	{
+		if (pubKeyP &amp;&amp; pubKeyQ)
+		{
+			// Save public keys
+			memcpy((char*)&amp;publicKeyP, pubKeyP, sizeof(publicKeyP));
+			memcpy(publicKeyQ, pubKeyQ, sizeof(publicKeyQ));
+		}
+		else if (privKeyE &amp;&amp; privKeyN)
+		{
+			BIGHALFSIZE(RSA_BIT_SIZE, p);
+			BIGHALFSIZE(RSA_BIT_SIZE, q);
+			memcpy(p, privKeyE, sizeof(p));
+			memcpy(q, privKeyN, sizeof(q));
+			// Save private keys
+			rsacrypt.setPrivateKey(p, q);
+		}
 		keysLocallyGenerated=false;
-		if (RSAd)
-			memcpy(d.value, RSAd, numberOfBytes);
-		memcpy(e.value, RSAe, numberOfBytes);
-		memcpy(n.value, RSAn, numberOfBytes);
 	}
 }
 
@@ -304,7 +309,7 @@
 	if (endThreads==false)
 		return;
 
-	securedConnectionByteSize=0;
+	usingSecurity=false;
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -343,18 +348,20 @@
 void RakPeer::SetIncomingPassword(char* passwordData, int passwordDataLength)
 {
 	// Set the incoming password data
-	rakPeerMutexes[incomingPasswordBitStream_Mutex].Lock();
+	if (threadSleepTimer&gt;=0)
+		rakPeerMutexes[incomingPasswordBitStream_Mutex].Lock();
 	incomingPasswordBitStream.Reset();
 	if (passwordData &amp;&amp; passwordDataLength&gt;0)
 		incomingPasswordBitStream.Write(passwordData, passwordDataLength);
-	rakPeerMutexes[incomingPasswordBitStream_Mutex].Unlock();
+	if (threadSleepTimer&gt;=0)
+		rakPeerMutexes[incomingPasswordBitStream_Mutex].Unlock();
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 // Description:
 // Returns the password set by SetIncomingPassword in a BitStream
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-BitStream *RakPeer::GetIncomingPassword(void)
+RakNet::BitStream *RakPeer::GetIncomingPassword(void)
 {
 	return &incomingPasswordBitStream;
 }
@@ -364,7 +371,7 @@
 // Call this to connect to the specified host (ip or domain name) and server port.
 // Calling Connect and not calling SetMaximumIncomingConnections acts as a dedicated client.  Calling both acts as a true peer.
 // This is a non-blocking connection.  You know the connection is successful when IsConnected() returns true
-// or receive gets a packet with the type identifier ID_ENUMERATION_REPLY.  If the connection is not
+// or receive gets a packet with the type identifier ID_CONNECTION_ACCEPTED.  If the connection is not
 // successful, such as rejected connection or no response then neither of these things will happen.
 // Requires that you first call Initialize
 //
@@ -395,11 +402,13 @@
 		return false;
 
 	// Set the incoming password data
-	rakPeerMutexes[outgoingPasswordBitStream_Mutex].Lock();
+	if (threadSleepTimer&gt;=0)
+		rakPeerMutexes[outgoingPasswordBitStream_Mutex].Lock();
 	outgoingPasswordBitStream.Reset();
 	if (passwordData &amp;&amp; passwordDataLength&gt;0)
 		outgoingPasswordBitStream.Write(passwordData, passwordDataLength);
-	rakPeerMutexes[outgoingPasswordBitStream_Mutex].Unlock();
+	if (threadSleepTimer&gt;=0)
+		rakPeerMutexes[outgoingPasswordBitStream_Mutex].Unlock();
 
 	// If the host starts with something other than 0, 1, or 2 it's (probably) a domain name.
 	if (host[0] &lt; '0' || host[0] &gt; '2')
@@ -417,9 +426,10 @@
 			 Packet *p;
 			 p = PacketPool::Instance()-&gt;GetPointer();
 
-			 p-&gt;data = new char [1];
+			 p-&gt;data = new unsigned char [1];
 			 p-&gt;data[0]=(unsigned char)ID_NO_FREE_INCOMING_CONNECTIONS;
 			 p-&gt;playerId=myPlayerId;
+			 p-&gt;playerIndex=(PlayerIndex)GetIndexFromPlayerID(myPlayerId);
 			 p-&gt;length = 1;
 
 			#ifdef _DEBUG
@@ -455,7 +465,7 @@
 				 NewIncomingConnectionStruct newIncomingConnectionStruct;
 				 newIncomingConnectionStruct.typeId=ID_NEW_INCOMING_CONNECTION;
 				 newIncomingConnectionStruct.externalID=myPlayerId;
-				 Send((char*)&amp;newIncomingConnectionStruct, sizeof(newIncomingConnectionStruct), HIGH_PRIORITY, RELIABLE, 0, myPlayerId, false);
+				 Send((char*)&amp;newIncomingConnectionStruct, sizeof(newIncomingConnectionStruct), SYSTEM_PRIORITY, RELIABLE, 0, myPlayerId, false);
 
 				 return true;
 			 }
@@ -473,30 +483,47 @@
 // Description:
 // Stops the network threads and close all connections.  Multiple calls are ok.
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-void RakPeer::Disconnect(void)
+void RakPeer::Disconnect(unsigned long blockDuration)
 {
 	unsigned i;
-	unsigned short maxPeers=maximumNumberOfPeers;
+	unsigned short maxPeers=maximumNumberOfPeers; // This is done for threading reasons
 
 	// Call close connection in a loop for all open connections.
 	for (i=0; i &lt; maxPeers; i++)
 	{
 		// CloseConnection uses maximumNumberOfPeers
-		CloseConnection(remoteSystemList[i].playerId, true);
+		CloseConnection(remoteSystemList[i].playerId, true, blockDuration);
+	
 	}
 
 	// Setting this to 0 allows remoteSystemList to be reallocated in Initialize and prevents threads from accessing the reliability layer
 	maximumNumberOfPeers=0;
 
-	// Stop the threads
-	endThreads=true;
+	if (endThreads==false)
+	{
+		// Stop the threads
+		endThreads=true;
 
-	while(isMainLoopThreadActive)
+		// Normally the thread will call DecreaseUserCount on termination but if we aren't using threads just do it
+		// manually
+#ifdef __USE_IO_COMPLETION_PORTS
+		if (threadSleepTimer&lt;0)
+		{
+			AsynchronousFileIO::Instance()-&gt;DecreaseUserCount();
+		}
+#endif
+
+	}
+
+	if (threadSleepTimer&gt;=0)
+	{
+		while(isMainLoopThreadActive)
 #ifdef _WIN32
-		Sleep(10);
+			Sleep(10);
 #else
-		usleep(10 * 1000);
+			usleep(10 * 1000);
 #endif
+	}
 
 	if (connectionSocket != INVALID_SOCKET)
 	{
@@ -511,14 +538,14 @@
 //		SocketLayer::Instance()-&gt;SendTo(connectionSocket, &amp;c, 1, &quot;127.0.0.1&quot;, myPlayerId.port);
 //	}
 
-	while(isRecvfromThreadActive)
-#ifdef _WIN32
-		Sleep(10);
-#else
-		usleep(10 * 1000);
-#endif
+//	while(isRecvfromThreadActive)
+//#ifdef _WIN32
+//		Sleep(10);
+//#else
+//		usleep(10 * 1000);
+//#endif
 
-	isSocketLayerBlocking=false;
+//	isSocketLayerBlocking=false;
 
 //	if (connectionSocket != INVALID_SOCKET)
 //	{
@@ -539,7 +566,15 @@
 
 	bytesSentPerSecond=bytesReceivedPerSecond=0;
 
+	if (threadSleepTimer&gt;=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+	for (i=0; i &lt; requestedConnectionsList.size(); i++)
+		delete requestedConnectionsList[i];
+	requestedConnectionsList.clear();
+	if (threadSleepTimer&gt;=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 
+
 	// Clear out the reliabilty layer list in case we want to reallocate it in a successive call to Init.
 	RemoteSystemStruct * temp = remoteSystemList;
 	remoteSystemList=0;
@@ -574,14 +609,25 @@
 		return false;
 	}
 
-	for (count=0, index=0; (remoteSystems==0 || count &lt; *numberOfSystems) &amp;&amp; index &lt; maximumNumberOfPeers; ++index)
-		if (remoteSystemList[index].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			if (remoteSystems)
-				remoteSystems[count]=remoteSystemList[index].playerId;
-			++count;
-		}
+	// This is called a lot so unroll the loop
+	if (remoteSystems)
+	{
+		for (count=0, index=0; index &lt; maximumNumberOfPeers; ++index)
+			if (remoteSystemList[index].playerId!=UNASSIGNED_PLAYER_ID)
+			{
+				if (count &lt; *numberOfSystems)
+					remoteSystems[count]=remoteSystemList[index].playerId;
+				++count;
+			}
 
+	}
+	else
+	{
+		for (count=0, index=0; index &lt; maximumNumberOfPeers; ++index)
+			if (remoteSystemList[index].playerId!=UNASSIGNED_PLAYER_ID)
+				++count;
+	}
+
 	*numberOfSystems=(unsigned short)count;
 
 	return 0;
@@ -598,25 +644,31 @@
 // bitStream: The bitstream to send
 // priority: What priority level to send on.
 // reliability: How reliability to send this data
-// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 // - Packets are only ordered relative to other packets on the same stream
 // playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 // broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 // Returns:
 // False if we are not connected to the specified recipient.  True otherwise
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-bool RakPeer::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)
+bool RakPeer::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)
 {
+#ifdef _DEBUG
+	assert(data &amp;&amp; length&gt;0);
+#endif
 	if (data==0 || length &lt; 0)
 		return false;
 
-	BitStream temp(data, length, false);
-	return Send(&amp;temp, priority, reliability, orderingStream, playerId, broadcast);
+	RakNet::BitStream temp(data, length, false);
+	return Send(&amp;temp, priority, reliability, orderingChannel, playerId, broadcast);
 
 }
 
-bool RakPeer::Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)
+bool RakPeer::Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)
 {
+#ifdef _DEBUG
+	assert(bitStream-&gt;GetNumberOfBytesUsed()&gt;0);
+#endif
 	if (bitStream-&gt;GetNumberOfBytesUsed()==0)
 		return false;
 	if (remoteSystemList==0 || endThreads==true)
@@ -648,13 +700,13 @@
 
 			if (outputTree)
 			{
-				BitStream bitStreamCopy(bitStream-&gt;GetNumberOfBytesUsed());
+				RakNet::BitStream bitStreamCopy(bitStream-&gt;GetNumberOfBytesUsed());
 				outputTree-&gt;EncodeArray(bitStream-&gt;GetData(),bitStream-&gt;GetNumberOfBytesUsed(), &amp;bitStreamCopy);
 				compressedBytesSent+=bitStreamCopy.GetNumberOfBytesUsed();
-				remoteSystemList[remoteSystemIndex].reliabilityLayer.Send(&amp;bitStreamCopy, priority,reliability,orderingStream, true, MTUSize);
+				remoteSystemList[remoteSystemIndex].reliabilityLayer.Send(&amp;bitStreamCopy, priority,reliability,orderingChannel, true, MTUSize);
 			}
 			else
-				remoteSystemList[remoteSystemIndex].reliabilityLayer.Send(bitStream, priority,reliability,orderingStream, true, MTUSize);
+				remoteSystemList[remoteSystemIndex].reliabilityLayer.Send(bitStream, priority,reliability,orderingChannel, true, MTUSize);
 
 			if (broadcast==false)
 				return true;
@@ -677,8 +729,15 @@
 {
 	if (!(IsActive()))	return 0;
 
+	// Only one thread should call RunUpdateCycle at a time.  We don't need to delay calls so
+	// a mutex on the function is not necessary - only on the variable that indicates if the function is
+	// running
+//	lastUserUpdateCycle=RakNetGetTime();
+//	RunMutexedUpdateCycle();
+	
+
 	// Prepare to write out a bitstream containing all the synchronization data
-//	BitStream *bitStream=0;
+//	RakNet::BitStream *bitStream=0;
 /*
 	automaticVariableSynchronizationMutex.Lock();
 
@@ -759,7 +818,7 @@
 #endif
 
 		// Push the data into a bitstream for easy parsing
-		BitStream bitStream(data+1, length-1, false);
+		RakNet::BitStream bitStream(data+1, length-1, false);
 		UniqueIDType uniqueID;
 		bool hasSecondaryID;
 		ObjectID secondaryID;
@@ -828,18 +887,32 @@
 	Packet *val;
 	int offset;
 
-	incomingQueueMutex.Lock();
-	if (incomingPacketQueue.size() &gt; 0)
+	while (1)
 	{
-		val = incomingPacketQueue.pop();
-	}
-	else
-	{
+		incomingQueueMutex.Lock();
+		if (incomingPacketQueue.size() &gt; 0)
+		{
+			val = incomingPacketQueue.pop();
+		}
+		else
+		{
+			incomingQueueMutex.Unlock();
+			return 0;
+		}
+
 		incomingQueueMutex.Unlock();
-		return 0;
+
+		// Do RPC calls from the user thread, not the network update thread
+		if (val-&gt;data[0] == ID_RPC || val-&gt;data[0] == ID_RPC_WITH_TIMESTAMP)
+		{
+			HandleRPCPacket((char*)val-&gt;data, val-&gt;length, val-&gt;playerId);
+			DeallocatePacket(val);
+		}
+		else
+			break; // Send the packet to the user
 	}
-	incomingQueueMutex.Unlock();
 
+
 #ifdef _DEBUG
 	assert(val-&gt;data);
 #endif
@@ -848,7 +921,7 @@
 		((unsigned char)val-&gt;data[0] == ID_TIMESTAMP))
 	{
 		offset = sizeof(unsigned char);
-		ShiftIncomingTimestamp(val-&gt;data + offset, val-&gt;playerId);
+		ShiftIncomingTimestamp((char*)val-&gt;data + offset, val-&gt;playerId);
 	}
 
 	return val;
@@ -958,13 +1031,22 @@
 // bitStream: The bitstream to send
 // priority: What priority level to send on.
 // reliability: How reliability to send this data
-// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 // broadcast - Send this packet to everyone.
 // playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 // broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-bool RakPeer::RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)
+bool RakPeer::RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)
 {
+	RakNet::BitStream temp(data, BITS_TO_BYTES(bitLength), false);
+	if (data)
+		return RPC(uniqueID, &amp;temp, priority, reliability, orderingChannel, playerId, broadcast, shiftTimestamp);
+	else
+		return RPC(uniqueID, 0, priority, reliability, orderingChannel, playerId, broadcast, shiftTimestamp);
+}
+
+bool RakPeer::RPC(char* uniqueID, RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)
+{
 #ifdef _DEBUG
 	assert(uniqueID &amp;&amp; uniqueID[0]);
 #endif
@@ -976,13 +1058,13 @@
 		return false; // Unique ID is too long
 	}
 
-	if (shiftTimestamp &amp;&amp; (data==0 || bitLength &lt; 8 * sizeof(unsigned long)))
+	if (shiftTimestamp &amp;&amp; bitStream &amp;&amp; (bitStream-&gt;GetNumberOfBytesUsed() &lt; sizeof(unsigned long)))
 	{
 		assert(0); // Not enough bits to shift!
 		return false;
 	}
 
-	BitStream outgoingBitStream;
+	RakNet::BitStream outgoingBitStream;
 	unsigned char uniqueIDLength, ch;
 	uniqueIDLength = (unsigned char)strlen(uniqueID);
 
@@ -995,9 +1077,9 @@
 	for (int counter=0; uniqueID[counter]; counter++)
 	{
 		ch = (unsigned char)toupper(uniqueID[counter]);
-// Dev-C++ doesn't support toupper.  How lame.
-    //  if (uniqueID[counter] &gt; 'Z')
-  //      uniqueID[counter]-='a'-'A';
+		// Dev-C++ doesn't support toupper.  How lame.
+		//  if (uniqueID[counter] &gt; 'Z')
+		//      uniqueID[counter]-='a'-'A';
 
 		if (ch &lt; 'A' || ch &gt; 'Z')
 		{
@@ -1009,27 +1091,19 @@
 
 		// Make the range of the char from 0 to 32
 		ch-='A';
-		outgoingBitStream.WriteBits((unsigned char*)&amp;ch, 5, true); // Write the char with 5 bits
+		outgoingBitStream.WriteBits((unsigned char*)&amp;ch, 5); // Write the char with 5 bits
 	}
 
-	if (data==0)
-		bitLength=0;
+	outgoingBitStream.WriteCompressed(bitStream-&gt;GetNumberOfBitsUsed());
 
-	outgoingBitStream.WriteCompressed(bitLength);
-
 	// False to write the raw data from another bitstream, rather than shifting from user data
-	if (bitLength &gt; 0)
-		outgoingBitStream.WriteBits((unsigned char*)data, bitLength);
+	if (bitStream &amp;&amp; bitStream-&gt;GetNumberOfBitsUsed() &gt; 0)
+		outgoingBitStream.WriteBits(bitStream-&gt;GetData(), bitStream-&gt;GetNumberOfBitsUsed(), false);
 
-	return Send(&amp;outgoingBitStream, priority, reliability, orderingStream,playerId,broadcast);
-}
+	// For testing
+	//	HandleRPCPacket((char*)outgoingBitStream.GetData(), outgoingBitStream.GetNumberOfBytesUsed(), UNASSIGNED_PLAYER_ID);
 
-bool RakPeer::RPC(char* uniqueID, BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)
-{
-	if (bitStream &amp;&amp; bitStream-&gt;GetNumberOfBitsUsed()&gt;0)
-		return RPC(uniqueID, (char*)bitStream-&gt;GetData(), bitStream-&gt;GetNumberOfBitsUsed(), priority, reliability, orderingStream, playerId, broadcast,shiftTimestamp);
-	else
-		return RPC(uniqueID, 0,0, priority, reliability, orderingStream, playerId, broadcast,shiftTimestamp);
+	return Send(&amp;outgoingBitStream, priority, reliability, orderingChannel,playerId,broadcast);
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -1040,25 +1114,52 @@
 // target: Which connection to close
 // sendDisconnectionNotification: True to send ID_DISCONNECTION_NOTIFICATION to the recipient.  False to close it silently.
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-void RakPeer::CloseConnection(PlayerID target, bool sendDisconnectionNotification)
+void RakPeer::CloseConnection(PlayerID target, bool sendDisconnectionNotification, unsigned long blockDuration)
 {
+	unsigned i, stopWaitingTime;
 	if (remoteSystemList==0 || endThreads==true)
 		return;
 
 	if (sendDisconnectionNotification)
 	{
 		unsigned char c=ID_DISCONNECTION_NOTIFICATION;
-		Send((char*)&amp;c, sizeof(c), HIGH_PRIORITY, UNRELIABLE, 0, target, false);
+		Send((char*)&amp;c, sizeof(c), SYSTEM_PRIORITY, RELIABLE, 0, target, false);
+		lastUserUpdateCycle=RakNetGetTime();
+//		RunMutexedUpdateCycle();
 	}
-	
-	unsigned i;
-	rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
-	for (i=0; i &lt; maximumNumberOfPeers; i++)
+
+	i=0;
+	if (threadSleepTimer&gt;=0)
+		rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
+	for (; i &lt; maximumNumberOfPeers; i++)
 		if (remoteSystemList[i].playerId==target)
 		{
-			// One last update so the disconnect or other packets can go out
-			remoteSystemList[i].reliabilityLayer.Update(connectionSocket, remoteSystemList[i].playerId, MTUSize);
+			// Send out any last packets
+			// Update isn't thread safe to call outside of the internal thread
+			// remoteSystemList[i].reliabilityLayer.Update(connectionSocket, remoteSystemList[i].playerId, MTUSize);
 
+			if (blockDuration&gt;=0)
+			{
+				stopWaitingTime=RakNetGetTime() + blockDuration;
+
+				while (RakNetGetTime() &lt; stopWaitingTime)
+				{
+					// If this system is out of packets to send, then stop waiting
+					if (remoteSystemList[i].reliabilityLayer.GetStatistics()-&gt;messageSendBuffer[SYSTEM_PRIORITY]==0)
+						break;
+
+					// This will probably cause the update thread to run which will probably
+					// send the disconnection notification
+#ifdef _WIN32
+					Sleep(0);
+#else
+					usleep(0 * 1000);
+#endif
+//					lastUserUpdateCycle=RakNetGetTime();
+//					RunMutexedUpdateCycle();
+				}
+			}
+
 			// Reserve this reliability layer for ourselves
 			remoteSystemList[i].playerId=UNASSIGNED_PLAYER_ID; // This one line causes future incoming packets to go through the reliability layer
 
@@ -1067,7 +1168,8 @@
 			break;
 		}
 
-	rakPeerMutexes[remoteSystemList_Mutex].Unlock();
+		if (threadSleepTimer&gt;=0)
+			rakPeerMutexes[remoteSystemList_Mutex].Unlock();
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -1217,11 +1319,13 @@
 		return false;
 
 	banListIndex=0;
+	if (banList.size()==0)
+		return false; // Skip the mutex if possible
 	banListMutex.Lock();
 	for (; banListIndex &lt; banList.size(); banListIndex++)
 	{
 		characterIndex=0;
-		while (1)
+		while (true)
 		{
 			if (banList[banListIndex][characterIndex]==IP[characterIndex])
 			{
@@ -1275,9 +1379,9 @@
 
 	PingStruct ping;
 	ping.typeId=ID_PING;
-	ping.sendPingTime=getTime();
+	ping.sendPingTime=RakNetGetTime();
 
-	Send((char*)&amp;ping, sizeof(PingStruct), HIGH_PRIORITY, UNRELIABLE, 0, target, false);
+	Send((char*)&amp;ping, sizeof(PingStruct), SYSTEM_PRIORITY, UNRELIABLE, 0, target, false);
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -1290,10 +1394,11 @@
 // The sender and recipient must already be started via a successful call to Initialize
 //
 // Parameters:
-// host: Either a dotted IP address or a domain name
+// host: Either a dotted IP address or a domain name.  Can be 255.255.255.255 for LAN broadcast.
 // remotePort: Which port to connect to on the remote machine.
+// onlyReplyOnAcceptingConnections: Only request a reply if the remote system has open connections
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-void RakPeer::Ping(char* host, unsigned short remotePort)
+void RakPeer::Ping(char* host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections)
 {
 	if (host==0)
 		return;
@@ -1305,8 +1410,11 @@
 	}
 
 	UnconnectedPingStruct s;
-	s.typeId=ID_PING;
-	s.sendPingTime=getTime();
+	if (onlyReplyOnAcceptingConnections)
+		s.typeId=ID_PING_OPEN_CONNECTIONS;
+	else
+		s.typeId=ID_PING;
+	s.sendPingTime=RakNetGetTime();
 
 	SocketLayer::Instance()-&gt;SendTo(connectionSocket, (char*)&amp;s, sizeof(UnconnectedPingStruct), (char*)host, remotePort);
 }
@@ -1372,7 +1480,7 @@
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 // Description:
-// Ping the remote systems every so often.  This is on by default
+// Ping the remote systems every so often.  This is off by default
 // This will work anytime
 //
 // Parameters:
@@ -1557,7 +1665,7 @@
 // Returns:
 // The data passed to SetRemoteStaticData stored as a bitstream
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-BitStream* RakPeer::GetRemoteStaticData(PlayerID playerId)
+RakNet::BitStream * RakPeer::GetRemoteStaticData(PlayerID playerId)
 {
 	if (playerId==myPlayerId)
 		return &localStaticData;
@@ -1609,17 +1717,33 @@
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 void RakPeer::SendStaticData(PlayerID target)
 {
-	BitStream reply(sizeof(unsigned char) + localStaticData.GetNumberOfBytesUsed());
+	RakNet::BitStream reply(sizeof(unsigned char) + localStaticData.GetNumberOfBytesUsed());
 	reply.Write((unsigned char) ID_RECEIVED_STATIC_DATA);
 	reply.Write((char*)localStaticData.GetData(), localStaticData.GetNumberOfBytesUsed());
 	if (target==UNASSIGNED_PLAYER_ID)
-		Send(&amp;reply, HIGH_PRIORITY, RELIABLE, 0, target, true);
+		Send(&amp;reply, SYSTEM_PRIORITY, RELIABLE, 0, target, true);
 	else
-		Send(&amp;reply, HIGH_PRIORITY, RELIABLE, 0, target, false);
+		Send(&amp;reply, SYSTEM_PRIORITY, RELIABLE, 0, target, false);
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 // Description:
+// Sets the data to send with an  (LAN server discovery) /(offline ping) response
+// See the Ping sample project for how this is used.
+// data: a block of data to store, or 0 for none
+// length: The length of data in bytes, or 0 for none
+// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+void RakPeer::SetOfflinePingResponse(char *data, const unsigned long length)
+{
+	rakPeerMutexes[offlinePingResponse_Mutex].Lock();
+	offlinePingResponse.Reset();
+	if (data &amp;&amp; length &gt; 0)
+		offlinePingResponse.Write(data, length);
+	rakPeerMutexes[offlinePingResponse_Mutex].Unlock();
+}
+
+// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+// Description:
 // Return the unique PlayerID that represents you on the the network
 // Note that unlike in previous versions, this is a struct and is not sequential
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -1731,7 +1855,7 @@
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 const char* RakPeer::GetLocalIP(unsigned int index)
 {
-	char ipList[10][16];
+	static char ipList[10][16];
 	if (index &gt;=10)
 		index=9;
 	memset(ipList, 0, sizeof(char) * 16 * 10);
@@ -1741,6 +1865,42 @@
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 // Description:
+// Allow or disallow connection responses from any IP.  Normally this should be false, but may be necessary
+// when connection to servers with multiple IP addresses
+//
+// Parameters:
+// allow - True to allow this behavior, false to not allow.  Defaults to false.  Value persists between connections
+// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+void RakPeer::AllowConnectionResponseIPMigration(bool allow)
+{
+	allowConnectionResponseIPMigration=allow;
+}
+
+// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+// Description:
+// Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system.
+// This will tell the remote system our external IP outside the LAN, and can be used for NAT punch through
+//
+// Requires:
+// The sender and recipient must already be started via a successful call to Initialize
+//
+// host: Either a dotted IP address or a domain name
+// remotePort: Which port to connect to on the remote machine.
+// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+void RakPeer::AdvertiseSystem(char *host, unsigned short remotePort)
+{
+	// If the host starts with something other than 0, 1, or 2 it's (probably) a domain name.
+	if (host[0] &lt; '0' || host[0] &gt; '2')
+	{
+		host = (char*) SocketLayer::Instance()-&gt;DomainNameToIP(host);
+	}
+
+	unsigned char c = ID_ADVERTISE_SYSTEM;
+	SocketLayer::Instance()-&gt;SendTo(connectionSocket, (char*)&amp;c, sizeof(c), (char*)host, remotePort);	
+}
+
+// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+// Description:
 // Enables or disables our tracking of bytes input to and output from the network.
 // This is required to get a frequency table, which is used to generate a new compression layer.
 // You can call this at any time - however you SHOULD only call it when disconnected.  Otherwise you will only track
@@ -1873,9 +2033,9 @@
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 float RakPeer::GetDecompressionRatio(void) const
 {
-	if (rawBytesRecieved&gt;0L)
+	if (rawBytesReceived&gt;0L)
 	{
-		return (float)compressedBytesRecieved / (float)rawBytesRecieved;
+		return (float)compressedBytesReceived / (float)rawBytesReceived;
 	}
 	else return 0.0f;
 }
@@ -1913,224 +2073,19 @@
 #ifdef _DEBUG
 		assert(packet-&gt;data);
 #endif
-		incomingPacketQueue.push(packet);
+		incomingPacketQueue.pushAtHead(packet);
 	}
 }
-
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-double RakPeer::GetPacketlossPercentile(void) const
+RakNetStatisticsStruct *  const RakPeer::GetStatistics(PlayerID playerId)
 {
-	unsigned i;
-	double value=0.0f;
-	int count=0;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0;
-
-	for (i=0; i &lt; maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID &amp;&amp; remoteSystemList[i].reliabilityLayer.GetBytesSent()&gt;0)
-		{
-			count++;
-			value+=remoteSystemList[i].reliabilityLayer.GetPacketlossPercentile();
-		}
-	}
-
-	if (count&gt;0)
-		return value/(double)count;
-	else return 0.0;
+	RemoteSystemStruct *rss;
+	rss=GetRemoteSystemFromPlayerID(playerId);
+	if (rss)
+		return rss-&gt;reliabilityLayer.GetStatistics();
+	return 0;
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetTransmittedPacketCount(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i &lt; maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID &amp;&amp;remoteSystemList[i].reliabilityLayer.GetBytesSent()&gt;0)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetTransmittedPacketCount();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetTransmittedFrameCount(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i &lt; maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID &amp;&amp; remoteSystemList[i].reliabilityLayer.GetBytesSent()&gt;0)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetTransmittedFrameCount();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetLostPacketCount(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i &lt; maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID &amp;&amp; remoteSystemList[i].reliabilityLayer.GetBytesSent()&gt;0)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetLostPacketCount();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetReceivedPacketCount(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i &lt; maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID &amp;&amp; remoteSystemList[i].reliabilityLayer.GetBytesSent()&gt;0)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetReceivedPacketCount();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetBytesSent(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i &lt; maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetBytesSent();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetBytesReceived(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i &lt; maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetBytesReceived();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetUnacknowledgedSentPacketListSize(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i &lt; maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetUnacknowledgedSentPacketListSize();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetBytesSentPerSecond(void) const
-{
-	return bytesSentPerSecond;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetBytesReceivedPerSecond(void) const
-{
-	return bytesReceivedPerSecond;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetMaximumWindowSize(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i &lt; maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetMaximumWindowSize();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetPacketOutputBufferSize(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i &lt; maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetPacketOutputBufferSize();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetConnectionTime(PlayerID playerId) const
-{
-	RemoteSystemStruct *remoteSystem = GetRemoteSystemFromPlayerID(playerId);
-	if (remoteSystem)
-		return getTime() - remoteSystem-&gt;connectionTime;
-	else
-		return 0;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 void RakPeer::RecordConnectionAttempt(const char* host, unsigned short remotePort)
 {
 	PlayerID playerId;
@@ -2138,20 +2093,23 @@
 	s = new RequestedConnectionStruct;
 	IPToPlayerID(host, remotePort, &amp;playerId);
 	s-&gt;playerId=playerId;
-	s-&gt;time=getTime();
+	s-&gt;time=RakNetGetTime();
 	s-&gt;setAESKey=false;
 	s-&gt;nextRequestTime=s-&gt;time + 2000;
 
 	// Record that we tried to connect to this host
-	rakPeerMutexes[requestedConnections_MUTEX].Lock();
+	if (threadSleepTimer&gt;=0)
+		rakPeerMutexes[requestedConnections_MUTEX].Lock();
 	requestedConnectionsList.push(s);
-	rakPeerMutexes[requestedConnections_MUTEX].Unlock();
+	if (threadSleepTimer&gt;=0)
+		rakPeerMutexes[requestedConnections_MUTEX].Unlock();
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 void RakPeer::RemoveFromRequestedConnectionsList(PlayerID playerId)
 {
 	int i;
-	rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+	if (threadSleepTimer&gt;=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
 	for (i=0; i &lt; (int)requestedConnectionsList.size();)
 	{
 		if (requestedConnectionsList[i]-&gt;playerId==playerId)
@@ -2161,7 +2119,8 @@
 			break;
 		}
 	}
-	rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+	if (threadSleepTimer&gt;=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 bool RakPeer::SendConnectionRequest(const char* host, unsigned short remotePort)
@@ -2169,7 +2128,7 @@
 	int j;
 
 	const unsigned char c=ID_CONNECTION_REQUEST;
-	BitStream temp(sizeof(unsigned char) + outgoingPasswordBitStream.GetNumberOfBytesUsed());
+	RakNet::BitStream temp(sizeof(unsigned char) + outgoingPasswordBitStream.GetNumberOfBytesUsed());
 	temp.Write(c);
 	if (outgoingPasswordBitStream.GetNumberOfBytesUsed()&gt;0)
 		temp.Write((char*)outgoingPasswordBitStream.GetData(), outgoingPasswordBitStream.GetNumberOfBytesUsed());
@@ -2184,8 +2143,10 @@
 		temp.port=remotePort;
 		PushPortRefused(temp);
 		closesocket(connectionSocket);
-		rakPeerMutexes[requestedConnections_MUTEX].Lock();
+		if (threadSleepTimer&gt;=0)
+			rakPeerMutexes[requestedConnections_MUTEX].Lock();
 		delete requestedConnectionsList.pop();
+		if (threadSleepTimer&gt;=0)
 		rakPeerMutexes[requestedConnections_MUTEX].Unlock();
 	}
 #endif
@@ -2225,9 +2186,9 @@
 
 		if (remoteSystem==0)
 		{
-			// No reliability layer available
-			unsigned char c = ID_NO_FREE_INCOMING_CONNECTIONS;
-			SocketLayer::Instance()-&gt;SendTo(connectionSocket, (char*)&amp;c, sizeof(char), playerId);
+			// Already connected.  Ignore duplicate connection requests
+		//	unsigned char c = ID_NO_FREE_INCOMING_CONNECTIONS;
+		//	SocketLayer::Instance()-&gt;SendTo(connectionSocket, (char*)&amp;c, sizeof(char), playerId.binaryAddress, playerId.port);
 			return;
 		}
 
@@ -2255,19 +2216,20 @@
 		ds.remotePort = myPlayerId.port;
 		#endif
 		ds.externalID=playerId;
+		ds.playerIndex=(PlayerIndex)GetIndexFromPlayerID(playerId);
 		// Write using the new socket so the client knows what port to use
-		int result=SocketLayer::Instance()-&gt;SendTo(connectionSocket, (char*)&amp;ds, sizeof(ds), playerId);
+		int result=SocketLayer::Instance()-&gt;SendTo(connectionSocket, (char*)&amp;ds, sizeof(ds), playerId.binaryAddress, playerId.port);
 
 		if (result!=0)
 		{
-			CloseConnection(playerId, false);
+			CloseConnection(playerId, false,0L);
 			return;
 		}
 	}
 	else
 	{
 		unsigned char c = ID_NO_FREE_INCOMING_CONNECTIONS;
-		SocketLayer::Instance()-&gt;SendTo(connectionSocket, (char*)&amp;c, sizeof(char), playerId);
+		SocketLayer::Instance()-&gt;SendTo(connectionSocket, (char*)&amp;c, sizeof(char), playerId.binaryAddress, playerId.port);
 	}
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -2280,8 +2242,10 @@
 
 	numberOfIncomingConnections=0;
 	for (i=0; i &lt; maximumNumberOfPeers; i++)
+	{
 		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID &amp;&amp; remoteSystemList[i].weInitiatedTheConnection==false)
 			numberOfIncomingConnections++;
+	}
 
 	return numberOfIncomingConnections;
 }
@@ -2291,13 +2255,26 @@
 	RemoteSystemStruct *remoteSystem=0;
 	unsigned i;
 
-	rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
+	if (threadSleepTimer&gt;=0)
+		rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
+	// If this guy is already connected, return 0.  This needs to be checked inside the mutex
+	// because threads may call the connection routine multiple times at the same time
 	for (i=0; i &lt; maximumNumberOfPeers; i++)
+		if (remoteSystemList[i].playerId==playerId)
+		{
+			if (threadSleepTimer&gt;=0)
+				rakPeerMutexes[remoteSystemList_Mutex].Unlock();
+			return 0;
+		}
+
+	for (i=0; i &lt; maximumNumberOfPeers; i++)
 	{
 		if (remoteSystemList[i].playerId==UNASSIGNED_PLAYER_ID)
 		{
 			if (setAESKey)
 				(remoteSystemList[i]).reliabilityLayer.SetEncryptionKey(AESKey);
+			else
+				(remoteSystemList[i]).reliabilityLayer.SetEncryptionKey(0);
 			// Reserve this reliability layer for ourselves
 			(remoteSystemList[i]).playerId=playerId; // This one line causes future incoming packets to go through the reliability layer
 			remoteSystem=remoteSystemList+i;
@@ -2305,7 +2282,8 @@
 		}
 	}
 
-	rakPeerMutexes[remoteSystemList_Mutex].Unlock();
+	if (threadSleepTimer&gt;=0)
+		rakPeerMutexes[remoteSystemList_Mutex].Unlock();
 
 	return remoteSystem;
 }
@@ -2325,9 +2303,9 @@
 	remoteSystem-&gt;nextPingTime=0; // Ping immediately
 	remoteSystem-&gt;weInitiatedTheConnection=weInitiatedTheConnection;
 	remoteSystem-&gt;staticData.Reset();
-	remoteSystem-&gt;connectionTime=getTime();
+	remoteSystem-&gt;connectionTime=RakNetGetTime();
 	remoteSystem-&gt;myExternalPlayerId=UNASSIGNED_PLAYER_ID;
-//	remoteSystem-&gt;reliabilityLayer.Reset();
+	remoteSystem-&gt;reliabilityLayer.Reset();
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -2359,7 +2337,7 @@
 
 	for (counter=0; counter &lt; PING_TIMES_ARRAY_SIZE; counter++)
 	{
-		if (remoteSystem-&gt;pingAndClockDifferential[0].pingTime==-1)
+		if (remoteSystem-&gt;pingAndClockDifferential[counter].pingTime==-1)
 			break;
 
 		if (remoteSystem-&gt;pingAndClockDifferential[counter].pingTime &lt; lowestPingSoFar)
@@ -2392,11 +2370,12 @@
 	// Number of bits of the data (long)
 	// The data
 
-	BitStream incomingBitStream(data, length, false);
+	RakNet::BitStream incomingBitStream(data, length, false);
 	unsigned char uniqueIDLength, ch, packetID;
 	char uniqueIdentifier[256];
 	int counter;
-	long bitLength;
+	unsigned long bitLength;
+	char *userData;
 
 	if (incomingBitStream.Read(packetID)==false)
 	{
@@ -2480,17 +2459,18 @@
 		}
 
 		// We have to copy into a new data chunk because the user data might not be byte aligned.
-		char *userData = new char[BITS_TO_BYTES(incomingBitStream.GetNumberOfUnreadBits())];
+		//char *userData = new char[BITS_TO_BYTES(incomingBitStream.GetNumberOfUnreadBits())];
+		userData=(char*)alloca(BITS_TO_BYTES(incomingBitStream.GetNumberOfUnreadBits()));
 
 		// The false means read out the internal representation of the bitstream data rather than
-		// Aligning it as we normally would with user data.  This is so the end user can cast the data received
+		// aligning it as we normally would with user data.  This is so the end user can cast the data received
 		// into a bitstream for reading
 		if (incomingBitStream.ReadBits((unsigned char*)userData, bitLength, false)==false)
 		{
 #ifdef _DEBUG
 			assert(0);
 #endif
-			delete [] userData;
+		//	delete [] userData;
 			return false; // Not enough data to read
 		}
 
@@ -2499,7 +2479,7 @@
 		// Call the function callback
 		node-&gt;functionName(userData, bitLength, playerId);
 		// Free the memory
-		delete [] userData;
+//		delete [] userData;
 	}
 
 	return true;
@@ -2508,12 +2488,17 @@
 #ifdef __USE_IO_COMPLETION_PORTS
 bool RakPeer::SetupIOCompletionPortSocket(int index)
 {
-	SOCKET newSocket = SocketLayer::Instance()-&gt;CreateBoundSocket(myPlayerId.port+index+1, false);
-	SocketLayer::Instance()-&gt;Connect(newSocket, remoteSystemList[index].playerId); // port is the port of the client
+	SOCKET newSocket;
+
+	if (remoteSystemList[index].reliabilityLayer.GetSocket()!=INVALID_SOCKET)
+		closesocket(remoteSystemList[index].reliabilityLayer.GetSocket());
+
+	newSocket = SocketLayer::Instance()-&gt;CreateBoundSocket(myPlayerId.port+index+1, false);
+	SocketLayer::Instance()-&gt;Connect(newSocket, remoteSystemList[index].playerId.binaryAddress,remoteSystemList[index].playerId.port); // port is the port of the client
 	remoteSystemList[index].reliabilityLayer.SetSocket(newSocket);
 
 	// Associate our new socket with a completion port and do the first read
-	return SocketLayer::Instance()-&gt;AssociateSocketWithCompletionPortAndRead(newSocket, remoteSystemList[index].playerId, this);
+	return SocketLayer::Instance()-&gt;AssociateSocketWithCompletionPortAndRead(newSocket, remoteSystemList[index].playerId.binaryAddress,remoteSystemList[index].playerId.port, this);
 }
 #endif
 
@@ -2530,15 +2515,15 @@
 		memcpy(newRandomNumber+i, (char*)&amp;number, sizeof(number));
 	}
 
-	randomNumberExpirationTime = getTime() + SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION;
+	randomNumberExpirationTime = RakNetGetTime() + SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION;
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 void RakPeer::SecuredConnectionResponse(PlayerID playerId)
 {
 	CSHA1 sha1;
-	unsigned char *connectionRequestResponse;
-	// 20 bytes for the SHA1 hash
-	connectionRequestResponse = new unsigned char [1+sizeof(securedConnectionByteSize)+securedConnectionByteSize*2 + 20];
+	RSA_BIT_SIZE n;
+	big::u32 e;
+	unsigned char connectionRequestResponse[1+sizeof(big::u32) + sizeof(RSA_BIT_SIZE) + 20];
 	connectionRequestResponse[0]=ID_SECURED_CONNECTION_RESPONSE;
 
 	// Hash the SYN-Cookie
@@ -2552,54 +2537,63 @@
 	// Write the cookie
 	memcpy(connectionRequestResponse+1, sha1.GetHash(), 20);
 
-	// Write the byte size
-	memcpy(connectionRequestResponse+1+20, (char*)&amp;securedConnectionByteSize, securedConnectionByteSize);
-
 	// Write the public keys
-	memcpy(connectionRequestResponse+1+20+sizeof(securedConnectionByteSize), e.value, securedConnectionByteSize);
-	memcpy(connectionRequestResponse+1+20+sizeof(securedConnectionByteSize)+securedConnectionByteSize, n.value, securedConnectionByteSize);
+	rsacrypt.getPublicKey(e,n);
+	memcpy(connectionRequestResponse+1+20, (char*)&amp;e, sizeof(big::u32));
+	memcpy(connectionRequestResponse+1+20+sizeof(big::u32), n, sizeof(RSA_BIT_SIZE));
 
 	// s2c public key, syn-cookie
-	SocketLayer::Instance()-&gt;SendTo(connectionSocket, (char*)connectionRequestResponse, 1+sizeof(securedConnectionByteSize)+securedConnectionByteSize*2 + 20, playerId);
-	delete [] connectionRequestResponse;
+	SocketLayer::Instance()-&gt;SendTo(connectionSocket, (char*)connectionRequestResponse, 1+sizeof(big::u32) + sizeof(RSA_BIT_SIZE) + 20, playerId.binaryAddress, playerId.port);
 }
-void RakPeer::SecuredConnectionConfirmation(PlayerID playerId, char* data, int length)
+void RakPeer::SecuredConnectionConfirmation(PlayerID playerId, char* data)
 {
 	int i,j;
 	unsigned char randomNumber[20];
 	unsigned long number;
-	unsigned short rsaByteSize;
 	bool doSend;
 	Packet *packet;
-	mpuint source,result,packetE, packetN;
+	big::u32 e;
+	RSA_BIT_SIZE n, message,encryptedMessage;
+	big::RSACrypt&lt;RSA_BIT_SIZE&gt; pubKeyPncrypt;
 
-	doSend=false;
-	rsaByteSize=0;
+	// Make sure that we still want to connect
+	bool requestedConnection=false;
+	if (threadSleepTimer&gt;=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+	for (i=0; i &lt; (int)requestedConnectionsList.size();i++)
+	{
+		if (requestedConnectionsList[i]-&gt;playerId==playerId)
+		{
+			// We did request this connection
+			requestedConnection=true;
+			break;
+		}
+	}
+	if (threadSleepTimer&gt;=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 
-#ifdef _DEBUG
-	assert(sizeof(rsaByteSize)==sizeof(securedConnectionByteSize));
-#endif
+	if (requestedConnection==false)
+		return; // Don't want to connect
 
-	// Get the rsa byte size
-	memcpy((char*)&amp;rsaByteSize, data+1+20, sizeof(rsaByteSize));
+	doSend=false;
 
-	// If the packet length is wrong for this byte size, return
-	if (length != (int)(1+20+sizeof(rsaByteSize)+rsaByteSize*2))
-		return;
+	// Copy out e and n
+	memcpy((char*)&amp;e,data+1+20, sizeof(big::u32));
+	memcpy(n, data+1+20+sizeof(big::u32), sizeof(RSA_BIT_SIZE));
 
 	// If we preset a size and it doesn't match, or the keys do not match, then tell the user
-	if (securedConnectionByteSize &gt; 0 &amp;&amp; keysLocallyGenerated==false)
+	if (usingSecurity==true &amp;&amp; keysLocallyGenerated==false)
 	{
-		if (securedConnectionByteSize != rsaByteSize ||
-			memcmp(data+1+20+sizeof(rsaByteSize), e.value, rsaByteSize)!=0 ||
-			memcmp(data+1+20+sizeof(rsaByteSize)+rsaByteSize, n.value, rsaByteSize)!=0)
+		if (memcmp((char*)&amp;e, (char*)&amp;publicKeyP, sizeof(big::u32))!=0 ||
+			memcmp(n, publicKeyQ, sizeof(RSA_BIT_SIZE))!=0)
 		{
 			packet = PacketPool::Instance()-&gt;GetPointer();
-			packet-&gt;data = new char[1];
+			packet-&gt;data = new unsigned char[1];
 			packet-&gt;data[0]=ID_RSA_PUBLIC_KEY_MISMATCH;
 			packet-&gt;length=sizeof(char);
 			packet-&gt;bitSize=sizeof(char)*8;
 			packet-&gt;playerId=playerId;
+			packet-&gt;playerIndex=(PlayerIndex)GetIndexFromPlayerID(packet-&gt;playerId);
 			incomingQueueMutex.Lock();
 			incomingPacketQueue.push(packet);
 			incomingQueueMutex.Unlock();
@@ -2608,12 +2602,6 @@
 		}
 	}
 
-	// Copy the keys from the packet
-	packetE.Init(rsaByteSize);
-	packetN.Init(rsaByteSize);
-	memcpy(packetE.value,data+1+20+sizeof(rsaByteSize),rsaByteSize);
-	memcpy(packetN.value,data+1+20+sizeof(rsaByteSize)+rsaByteSize,rsaByteSize);
-
 	// Create a random number
 	for (i=0; i &lt; sizeof(randomNumber); i+=sizeof(number))
 	{
@@ -2621,16 +2609,14 @@
 		memcpy(randomNumber+i, (char*)&amp;number, sizeof(number));
 	}
 
-	// Encrypt the random number using RSA
-	source.Init(rsaByteSize);
-	result.Init(rsaByteSize);
+	memset(message, 0, sizeof(message));
+	assert(sizeof(message) &gt;= sizeof(randomNumber));
+	memcpy(message, randomNumber, sizeof(randomNumber));
+	pubKeyPncrypt.setPublicKey(e,n);
+	pubKeyPncrypt.encrypt(message,encryptedMessage);
 
-	// This crummy rsa encoder doesn't work reliably with full blocks so WriteAndFill block doesn't work.
-	// source.WriteAndFillBlock((char*)randomNumber, 20);
-	memcpy(source.value, randomNumber, 20);
-	EncryptDecrypt(result, source, packetE, packetN);
-
-	rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+	if (threadSleepTimer&gt;=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
 	for (i=0; i &lt; (int)requestedConnectionsList.size();)
 	{
 		if (requestedConnectionsList[i]-&gt;playerId==playerId)
@@ -2643,18 +2629,17 @@
 			break;
 		}
 	}
-	rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+	if (threadSleepTimer&gt;=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 
 	if (doSend)
 	{
-		char *reply;
-		reply = new char [1+20+rsaByteSize];
+		char reply[1+20+sizeof(RSA_BIT_SIZE)];
 		// c2s RSA(random number), same syn-cookie
 		reply[0]=ID_SECURED_CONNECTION_CONFIRMATION;
 		memcpy(reply+1, data+1, 20);  // Copy the syn-cookie
-		memcpy(reply+1+20, result.value, rsaByteSize); // Copy the encoded random number
-		SocketLayer::Instance()-&gt;SendTo(connectionSocket, reply, 1+20+rsaByteSize, playerId);
-		delete [] reply;
+		memcpy(reply+1+20, encryptedMessage, sizeof(RSA_BIT_SIZE)); // Copy the encoded random number
+		SocketLayer::Instance()-&gt;SendTo(connectionSocket, reply, 1+20+sizeof(RSA_BIT_SIZE), playerId.binaryAddress, playerId.port);
 	}
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -2663,10 +2648,11 @@
 	// Tell the game we can't connect to this host
 	Packet *p;
 	p = PacketPool::Instance()-&gt;GetPointer();
-	p-&gt;data=new char[1];
+	p-&gt;data=new unsigned char[1];
 	p-&gt;data[0]=ID_REMOTE_PORT_REFUSED;
 	p-&gt;length=sizeof(char);
 	p-&gt;playerId=target; // We don't know this!
+	p-&gt;playerIndex=(PlayerIndex)GetIndexFromPlayerID(p-&gt;playerId);
 
 	#ifdef _DEBUG
 	assert(p-&gt;data);
@@ -2678,6 +2664,7 @@
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+/*
 #ifdef _WIN32
 unsigned __stdcall RecvFromNetworkLoop(LPVOID arguments)
 #else
@@ -2739,7 +2726,7 @@
 #endif
 	return 0;
 }
-
+*/
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 #ifdef _WIN32
 void __stdcall ProcessNetworkPacket(unsigned long binaryAddress, unsigned short port, char *data, int length, RakPeer *rakPeer)
@@ -2756,18 +2743,33 @@
 	if (remoteSystem)
 	{
 		// Handle regular incoming data
+		// HandleSocketReceiveFromConnectedPlayer is only safe to be called from the same thread as Update,
+		// which is this thread
 		if (remoteSystem-&gt;reliabilityLayer.HandleSocketReceiveFromConnectedPlayer(data, length)==false)
 		{
-			// Cheater
-			Packet *packet = PacketPool::Instance()-&gt;GetPointer();
-			packet-&gt;data = new char[1];
-			packet-&gt;data[0]=ID_MODIFIED_PACKET;
-			packet-&gt;length=sizeof(char);
-			packet-&gt;bitSize=sizeof(char)*8;
-			packet-&gt;playerId=playerId;
-			rakPeer-&gt;incomingQueueMutex.Lock();
-			rakPeer-&gt;incomingPacketQueue.push(packet);
-			rakPeer-&gt;incomingQueueMutex.Unlock();
+			// These kinds of packets may have been duplicated and incorrectly determined to be
+			// cheat packets.  Anything else really is a cheat packet
+			if (!((unsigned char)(data)[0]==ID_CONNECTION_REQUEST ||
+				((unsigned char)(data)[0]==ID_PING &amp;&amp; length==sizeof(UnconnectedPingStruct)) ||
+				((unsigned char)(data)[0]==ID_PONG &amp;&amp; length&gt;=sizeof(UnconnectedPingStruct)) ||
+				((unsigned char)(data)[0]==ID_PING_OPEN_CONNECTIONS &amp;&amp; length==sizeof(UnconnectedPingStruct)) ||
+				((unsigned char)(data)[0]==ID_ADVERTISE_SYSTEM &amp;&amp; length==sizeof(unsigned char)) ||
+				((unsigned char)(data)[0]==ID_SECURED_CONNECTION_CONFIRMATION &amp;&amp; length==1+20+sizeof(RSA_BIT_SIZE))
+				))
+			{
+				// Cheater
+				Packet *packet = PacketPool::Instance()-&gt;GetPointer();
+				packet-&gt;data = new unsigned char[1];
+				packet-&gt;data[0]=ID_MODIFIED_PACKET;
+				packet-&gt;length=sizeof(char);
+				packet-&gt;bitSize=sizeof(char)*8;
+				packet-&gt;playerId=playerId;
+				packet-&gt;playerIndex=(PlayerIndex)rakPeer-&gt;GetIndexFromPlayerID(playerId);
+				rakPeer-&gt;incomingQueueMutex.Lock();
+				rakPeer-&gt;incomingPacketQueue.push(packet);
+				rakPeer-&gt;incomingQueueMutex.Unlock();
+			}
+			
 		}
 	}
 	else
@@ -2778,45 +2780,50 @@
 			if (rakPeer-&gt;GetNumberOfIncomingConnections() &gt;= rakPeer-&gt;GetMaximumIncomingConnections())
 			{
 				unsigned char c = ID_NO_FREE_INCOMING_CONNECTIONS;
-				SocketLayer::Instance()-&gt;SendTo(rakPeer-&gt;connectionSocket, (char*)&amp;c, sizeof(char), playerId);
+				SocketLayer::Instance()-&gt;SendTo(rakPeer-&gt;connectionSocket, (char*)&amp;c, sizeof(char), playerId.binaryAddress, playerId.port);
 			}
-			else if (rakPeer-&gt;securedConnectionByteSize==0)
+			char *password = data + sizeof(unsigned char);
+			int passwordLength = length - sizeof(unsigned char);
+			if (rakPeer-&gt;IsBanned(rakPeer-&gt;PlayerIDToDottedIP(playerId)))
 			{
-				char *password = data + sizeof(unsigned char);
-				int passwordLength = length - sizeof(unsigned char);
-				if (rakPeer-&gt;IsBanned(rakPeer-&gt;PlayerIDToDottedIP(playerId)))
+				// This one we only send once since we don't care if it arrives.
+				unsigned char c = ID_CONNECTION_BANNED;
+				SocketLayer::Instance()-&gt;SendTo(rakPeer-&gt;connectionSocket, (char*)&amp;c, sizeof(char), playerId.binaryAddress, playerId.port);
+			}
+			else if (rakPeer-&gt;incomingPasswordBitStream.GetNumberOfBytesUsed()==passwordLength &amp;&amp;
+				memcmp(password, rakPeer-&gt;incomingPasswordBitStream.GetData(), passwordLength)==0)
+			{
+				if (rakPeer-&gt;usingSecurity==false)
 				{
-					// This one we only send once since we don't care if it arrives.
-					unsigned char c = ID_CONNECTION_BANNED;
-					SocketLayer::Instance()-&gt;SendTo(rakPeer-&gt;connectionSocket, (char*)&amp;c, sizeof(char), playerId);
-				}
-				else if (rakPeer-&gt;incomingPasswordBitStream.GetNumberOfBytesUsed()==passwordLength &amp;&amp;
-					memcmp(password, rakPeer-&gt;incomingPasswordBitStream.GetData(), passwordLength)==0)
-				{
+#ifdef _TEST_AES
+					unsigned char AESKey[16];
+					// Save the AES key
+					for (i=0; i &lt; 16; i++)
+						AESKey[i]=i;
+					rakPeer-&gt;HandleConnectionRequest(playerId, AESKey, true);
+#else
 					// Connect this player assuming we have open slots
 					rakPeer-&gt;HandleConnectionRequest(playerId, 0, false);
+#endif
 				}
 				else
-				{
-					// This one we only send once since we don't care if it arrives.
-					unsigned char c = ID_INVALID_PASSWORD;
-					SocketLayer::Instance()-&gt;SendTo(rakPeer-&gt;connectionSocket, (char*)&amp;c, sizeof(char), playerId);
-				}
+					rakPeer-&gt;SecuredConnectionResponse(playerId);
+				
 			}
 			else
 			{
-				rakPeer-&gt;SecuredConnectionResponse(playerId);
+				// This one we only send once since we don't care if it arrives.
+				unsigned char c = ID_INVALID_PASSWORD;
+				SocketLayer::Instance()-&gt;SendTo(rakPeer-&gt;connectionSocket, (char*)&amp;c, sizeof(char), playerId.binaryAddress, playerId.port);
 			}
 		}
 		else if ((unsigned char)(data)[0]== ID_SECURED_CONNECTION_RESPONSE &amp;&amp;
-			// 20 SHA1 + 1 packet header + 4 public key + sizeof(securedConnectionByteSize)
-			length &gt;= 25 + sizeof(rakPeer-&gt;securedConnectionByteSize))
+			length==1+sizeof(big::u32) + sizeof(RSA_BIT_SIZE) + 20)
 		{
-			rakPeer-&gt;SecuredConnectionConfirmation(playerId, data, length);
+			rakPeer-&gt;SecuredConnectionConfirmation(playerId, data);
 		}
 		else if ((unsigned char)(data)[0]== ID_SECURED_CONNECTION_CONFIRMATION &amp;&amp;
-			// 20 Syn cookie + 1 packet header + 20 encoded random number
-			length &gt;= 41)
+			length==1+20+sizeof(RSA_BIT_SIZE))
 		{
 			CSHA1 sha1;
 			bool confirmedHash, newRandomNumber;
@@ -2841,7 +2848,7 @@
 				confirmedHash=true;
 				newRandomNumber=true;
 			}
-			else if (rakPeer-&gt;randomNumberExpirationTime &lt; getTime())
+			else if (rakPeer-&gt;randomNumberExpirationTime &lt; RakNetGetTime())
 			{
 				sha1.Reset();
 				sha1.Update((unsigned char*)&amp;playerId.binaryAddress, sizeof(playerId.binaryAddress));
@@ -2855,20 +2862,18 @@
 
 			if (confirmedHash)
 			{
-				mpuint source,result;
 				int i;
 				unsigned char AESKey[16];
+				RSA_BIT_SIZE message,encryptedMessage;
 
 				// On connection accept, AES key is c2s RSA_Decrypt(random number) XOR s2c syn-cookie
 				// Get the random number first
-				source.Init(rakPeer-&gt;securedConnectionByteSize);
-				result.Init(rakPeer-&gt;securedConnectionByteSize);
-				memcpy(source.value, data+1+20, rakPeer-&gt;securedConnectionByteSize);
-				EncryptDecrypt(result, source, rakPeer-&gt;d, rakPeer-&gt;n);
+				memcpy(encryptedMessage, data+1+20, sizeof(RSA_BIT_SIZE));
+				rakPeer-&gt;rsacrypt.decrypt(encryptedMessage, message);
 
 				// Save the AES key
 				for (i=0; i &lt; 16; i++)
-					AESKey[i]=data[1+i] ^ ((unsigned char*)(result.value))[i];
+					AESKey[i]=data[1+i] ^ ((unsigned char*)(message))[i];
 
 				// Connect this player assuming we have open slots
 				rakPeer-&gt;HandleConnectionRequest(playerId,AESKey, true);
@@ -2882,34 +2887,50 @@
 		{
 			 // Make sure this connection accept is from someone we wanted to connect to
 			bool requestedConnection;
-//			unsigned long time = getTime();
+//			unsigned long time = RakNetGetTime();
 			unsigned char AESKey[16];
 			bool setAESKey;
 			setAESKey=false;
-			requestedConnection=false;
-			rakPeer-&gt;rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
-			for (i=0; i &lt; rakPeer-&gt;requestedConnectionsList.size();i++)
+
+			if (rakPeer-&gt;allowConnectionResponseIPMigration==false)
 			{
-				if (rakPeer-&gt;requestedConnectionsList[i]-&gt;playerId==playerId)
+				requestedConnection=false;
+				if (rakPeer-&gt;threadSleepTimer&gt;=0)
+					rakPeer-&gt;rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+				for (i=0; i &lt; rakPeer-&gt;requestedConnectionsList.size();i++)
 				{
-					// We did request this connection
-					requestedConnection=true;
-					setAESKey=rakPeer-&gt;requestedConnectionsList[i]-&gt;setAESKey;
-					if (setAESKey)
-						memcpy(AESKey, rakPeer-&gt;requestedConnectionsList[i]-&gt;AESKey, 16);
-					delete rakPeer-&gt;requestedConnectionsList[i];
-					rakPeer-&gt;requestedConnectionsList.del(i);
-					break;
+					if (rakPeer-&gt;requestedConnectionsList[i]-&gt;playerId==playerId)
+					{
+						// We did request this connection
+						requestedConnection=true;
+						setAESKey=rakPeer-&gt;requestedConnectionsList[i]-&gt;setAESKey;
+						if (setAESKey)
+							memcpy(AESKey, rakPeer-&gt;requestedConnectionsList[i]-&gt;AESKey, 16);
+						delete rakPeer-&gt;requestedConnectionsList[i];
+						rakPeer-&gt;requestedConnectionsList.del(i);
+						break;
+					}
 				}
+				if (rakPeer-&gt;threadSleepTimer&gt;=0)
+					rakPeer-&gt;rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 			}
-			rakPeer-&gt;rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+			else
+				requestedConnection=true; // Don't bother checking who replied			
 
 			 if (requestedConnection)
 			 {
 				// Find a free remote system struct to use
 				ConnectionAcceptStruct* cas = (ConnectionAcceptStruct*) data;
 				playerId.port=cas-&gt;remotePort;
+
+#ifdef _TEST_AES
+				// Save the AES key
+				for (i=0; i &lt; 16; i++)
+					AESKey[i]=i;
+				remoteSystem=rakPeer-&gt;AssignPlayerIDToRemoteSystemList(playerId, AESKey,true);
+#else
 				remoteSystem=rakPeer-&gt;AssignPlayerIDToRemoteSystemList(playerId, AESKey,setAESKey);
+#endif
 
 				if (remoteSystem!=0)
 				{
@@ -2923,9 +2944,9 @@
 					// Create a new nonblocking socket
 					remoteSystem-&gt;reliabilityLayer.SetSocket(SocketLayer::Instance()-&gt;CreateBoundSocket(rakPeer-&gt;myPlayerId.port, false));
 
-					SocketLayer::Instance()-&gt;Connect(remoteSystem-&gt;reliabilityLayer.GetSocket(), playerId);
+					SocketLayer::Instance()-&gt;Connect(remoteSystem-&gt;reliabilityLayer.GetSocket(), playerId.binaryAddress, playerId.port);
 					// Associate our new socket with a completion port and do the first read
-					b=SocketLayer::Instance()-&gt;AssociateSocketWithCompletionPortAndRead(remoteSystem-&gt;reliabilityLayer.GetSocket(), playerId, rakPeer);
+					b=SocketLayer::Instance()-&gt;AssociateSocketWithCompletionPortAndRead(remoteSystem-&gt;reliabilityLayer.GetSocket(), playerId.binaryAddress, playerId.port, rakPeer);
 					//client-&gt;//reliabilityLayerMutex.Unlock();
 
 					if (b==false) // Some damn completion port error... windows is so unreliable
@@ -2939,11 +2960,13 @@
 
 					// Send the connection request complete to the game
 					Packet *packet = PacketPool::Instance()-&gt;GetPointer();
-					packet-&gt;data = new char[1];
-					packet-&gt;data[0]=ID_CONNECTION_REQUEST_ACCEPTED;
-					packet-&gt;length=sizeof(char);
-					packet-&gt;bitSize=sizeof(char)*8;
+					packet-&gt;data = new unsigned char[sizeof(ConnectionAcceptStruct)];
+					memcpy(packet-&gt;data, data, sizeof(ConnectionAcceptStruct));
+					// packet-&gt;data[0]=ID_CONNECTION_REQUEST_ACCEPTED;
+					packet-&gt;length=sizeof(ConnectionAcceptStruct);
+					packet-&gt;bitSize=sizeof(ConnectionAcceptStruct)*8;
 					packet-&gt;playerId=playerId;
+					packet-&gt;playerIndex=(PlayerIndex)rakPeer-&gt;GetIndexFromPlayerID(playerId);
 
 					#ifdef _DEBUG
 					assert(packet-&gt;data);
@@ -2956,7 +2979,7 @@
 					newIncomingConnectionStruct.typeId=ID_NEW_INCOMING_CONNECTION;
 					newIncomingConnectionStruct.externalID=playerId;
 
-					rakPeer-&gt;Send((char*)&amp;newIncomingConnectionStruct, sizeof(newIncomingConnectionStruct), HIGH_PRIORITY, RELIABLE, 0, playerId, false);
+					rakPeer-&gt;Send((char*)&amp;newIncomingConnectionStruct, sizeof(newIncomingConnectionStruct), SYSTEM_PRIORITY, RELIABLE, 0, playerId, false);
 					rakPeer-&gt;Ping(playerId);
 					rakPeer-&gt;SendStaticData(playerId);
 				}
@@ -2964,7 +2987,7 @@
 				{
 					// Cancel the connection attempt
 					char c = ID_DISCONNECTION_NOTIFICATION;
-					SocketLayer::Instance()-&gt;SendTo( rakPeer-&gt;connectionSocket, (char*)&amp;c, sizeof(char), playerId);
+					SocketLayer::Instance()-&gt;SendTo( rakPeer-&gt;connectionSocket, (char*)&amp;c, sizeof(char), playerId.binaryAddress, playerId.port);
 				}
 			}
 			 else
@@ -2974,26 +2997,48 @@
 #endif
 			 }
 		 }
-		 else if ((unsigned char)(data)[0]== ID_PING &amp;&amp; length==sizeof(UnconnectedPingStruct))
+		 else if (((unsigned char)(data)[0]==ID_PING || (unsigned char)(data)[0]==ID_PING_OPEN_CONNECTIONS)
+			 &amp;&amp; length==sizeof(UnconnectedPingStruct))
 		 {
+			 if ((unsigned char)(data)[0]==ID_PING_OPEN_CONNECTIONS &amp;&amp; rakPeer-&gt;GetMaximumIncomingConnections()==0)
+				 return; // Sender wanted to get replies only for systems accepting connections
 			 data[0]=ID_PONG;
-			 SocketLayer::Instance()-&gt;SendTo( rakPeer-&gt;connectionSocket, data, sizeof(UnconnectedPingStruct), playerId);
+			 RakNet::BitStream tempBitStream(sizeof(UnconnectedPingStruct));
+			 tempBitStream.Write(data, sizeof(UnconnectedPingStruct));
+			 rakPeer-&gt;rakPeerMutexes[RakPeer::offlinePingResponse_Mutex].Lock();
+			 tempBitStream.Write((char*)rakPeer-&gt;offlinePingResponse.GetData(), rakPeer-&gt;offlinePingResponse.GetNumberOfBytesUsed());
+			 rakPeer-&gt;rakPeerMutexes[RakPeer::offlinePingResponse_Mutex].Unlock();
+			 SocketLayer::Instance()-&gt;SendTo( rakPeer-&gt;connectionSocket, (char*) tempBitStream.GetData(), tempBitStream.GetNumberOfBytesUsed(), playerId.binaryAddress, playerId.port);
 		 }
-		 else if ((unsigned char)(data)[0]== ID_PONG &amp;&amp; length==sizeof(UnconnectedPingStruct))
+		 else if ((unsigned char)(data)[0]==ID_ADVERTISE_SYSTEM &amp;&amp; length==sizeof(unsigned char))
 		 {
+			 // Push this up to the game
 			 Packet *packet = PacketPool::Instance()-&gt;GetPointer();
+			 packet-&gt;data = new unsigned char [1 * sizeof(unsigned char)];
+			 packet-&gt;data[0]=ID_ADVERTISE_SYSTEM;
+			 packet-&gt;length=1 * sizeof(unsigned char);
+			 packet-&gt;bitSize=8 * sizeof(unsigned char);
+			 rakPeer-&gt;incomingQueueMutex.Lock();
+			 (rakPeer-&gt;incomingPacketQueue).push(packet);
+			 rakPeer-&gt;incomingQueueMutex.Unlock();
+		 }			 
+		 else if ((unsigned char)(data)[0]== ID_PONG &amp;&amp; length&gt;=sizeof(UnconnectedPingStruct))
+		 {
+			 Packet *packet = PacketPool::Instance()-&gt;GetPointer();
+			 unsigned long time;
 
-			 packet-&gt;data = new char [sizeof(UnconnectedPingStruct)];
-			 unsigned long time;
+			 // Write ID_PONG, then the time, then the unconnected data
+			 packet-&gt;data = new unsigned char [length];
+			 memcpy(packet-&gt;data, data, length);
+
 			 memcpy((char*)&amp;time, data+sizeof(unsigned char), sizeof(unsigned long));
-			 time = getTime() - time;
-			 packet-&gt;data[0]=ID_PONG;
+			 time = RakNetGetTime() - time;
 			 memcpy(packet-&gt;data+sizeof(unsigned char), (char*)&amp;time, sizeof(unsigned long));
 			 
-			 packet-&gt;length=sizeof(UnconnectedPingStruct);
-			 packet-&gt;bitSize=sizeof(UnconnectedPingStruct) * 8;
-
+			 packet-&gt;length=length;
+			 packet-&gt;bitSize=packet-&gt;length * 8;
 			 packet-&gt;playerId=playerId;
+			 packet-&gt;playerIndex=(PlayerIndex)rakPeer-&gt;GetIndexFromPlayerID(playerId);
 
 			 rakPeer-&gt;incomingQueueMutex.Lock();
 			 (rakPeer-&gt;incomingPacketQueue).push(packet);
@@ -3002,7 +3047,7 @@
 		 else if ((unsigned char)(data)[0]==ID_NO_FREE_INCOMING_CONNECTIONS &amp;&amp; length==sizeof(unsigned char))
 		 {
 			 Packet *packet = PacketPool::Instance()-&gt;GetPointer();
-			 packet-&gt;data = new char [1 * sizeof(unsigned char)];
+			 packet-&gt;data = new unsigned char [1 * sizeof(unsigned char)];
 			 packet-&gt;data[0]=ID_NO_FREE_INCOMING_CONNECTIONS;
 			 packet-&gt;length=1 * sizeof(unsigned char);
 			 packet-&gt;bitSize=8 * sizeof(unsigned char);
@@ -3013,7 +3058,7 @@
 		 else if ((unsigned char)(data)[0]==ID_CONNECTION_BANNED &amp;&amp; length==sizeof(unsigned char))
 		 {
 			 Packet *packet = PacketPool::Instance()-&gt;GetPointer();
-			 packet-&gt;data = new char [1 * sizeof(unsigned char)];
+			 packet-&gt;data = new unsigned char [1 * sizeof(unsigned char)];
 			 packet-&gt;data[0]=ID_CONNECTION_BANNED;
 			 packet-&gt;length=1 * sizeof(unsigned char);
 			 packet-&gt;bitSize=8 * sizeof(unsigned char);
@@ -3024,380 +3069,457 @@
 	}
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-#ifdef _WIN32
-unsigned __stdcall UpdateNetworkLoop(LPVOID arguments)
-#else
-void*  UpdateNetworkLoop( void*  arguments )
-#endif
+bool RakPeer::RunUpdateCycle(void)
 {
-	RakPeer *rakPeer = (RakPeer *)arguments;
-	RakPeer::RemoteSystemStruct* remoteSystemList=rakPeer-&gt;remoteSystemList;
 	RakPeer::RemoteSystemStruct* remoteSystem;
 	unsigned remoteSystemIndex;
 	Packet *packet;
 	long ping, lastPing;
-	bool anyPeersActive;
-	int currentSentBytes,currentReceivedBytes,lastSentBytes,lastReceivedBytes;
-	unsigned long time,nextReadBytesTime;
+//	int currentSentBytes,currentReceivedBytes;
 	unsigned numberOfBytesUsed;
 	unsigned numberOfBitsUsed;
 	//PlayerID authoritativeClientPlayerId;
-	BitStream dataBitStream(MAXIMUM_MTU_SIZE);
 	int bitSize, byteSize;
 	char *data;
-	unsigned short maximumNumberOfPeers;
+	int errorCode;
+	bool gotData;
+	unsigned long time;
 
-	// For histogram statistics
-	lastSentBytes=lastReceivedBytes=0;
-	nextReadBytesTime=0;
+	do
+	{
+		// Read a packet
+		gotData=SocketLayer::Instance()-&gt;RecvFrom(connectionSocket, this, &amp;errorCode);
 
-	maximumNumberOfPeers = rakPeer-&gt;maximumNumberOfPeers;
+		if (gotData==false)
+		{
 
-	rakPeer-&gt;isMainLoopThreadActive=true;
+#ifdef _WIN32
+			if (errorCode==WSAECONNRESET)
+			{
+				PushPortRefused(UNASSIGNED_PLAYER_ID);
+				//closesocket(peer-&gt;connectionSocket);
 
-	while(rakPeer-&gt;endThreads==false)
-	{
-		// We calculate this from the lowest numerical player ID
-		//authoritativeClientPlayerId=UNASSIGNED_PLAYER_ID;
+				//peer-&gt;connectionSocket = SocketLayer::Instance()-&gt;CreateBoundSocket(peer-&gt;myPlayerId.port, true);
+			}
+			else if (errorCode!=0 &amp;&amp; endThreads==false)
+			{
+#ifdef _DEBUG
+				printf(&quot;Server RecvFrom critical failure!\n&quot;);
+#endif
+				// Some kind of critical error
+				//	peer-&gt;isRecvfromThreadActive=false;
+				endThreads=true;
+				Disconnect(0L);
+				return false;
+			}
+#else
+			if (errorCode==-1)
+			{
+				//	isRecvfromThreadActive=false;
+				endThreads=true;
+				Disconnect(0L);
+				return false;
+			}
+#endif
+		}
+		if (endThreads)
+			return false;
+	} while (gotData); // Read until there is nothing left
 
-		// Get the current system time
-		time = getTime();
+	time = RakNetGetTime();
 
-		anyPeersActive=false;
-
-		// Update the requested connection list.
-		if (rakPeer-&gt;requestedConnectionsList.size()&gt;0)
+	// Update the requested connection list.
+	if (requestedConnectionsList.size()&gt;0)
+	{
+		remoteSystemIndex=0;
+		if (threadSleepTimer&gt;=0)
+			rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+		while (remoteSystemIndex &lt; requestedConnectionsList.size())
 		{
-			remoteSystemIndex=0;
-			rakPeer-&gt;rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
-			while (remoteSystemIndex &lt; rakPeer-&gt;requestedConnectionsList.size())
+			// After X seconds give up
+			if (time - requestedConnectionsList[remoteSystemIndex]-&gt;time &gt; SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION*2)
 			{
-				// After X seconds give up
-				if (time - rakPeer-&gt;requestedConnectionsList[remoteSystemIndex]-&gt;time &gt; SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION)
-				{
-                    delete rakPeer-&gt;requestedConnectionsList[remoteSystemIndex];
-					rakPeer-&gt;requestedConnectionsList.del(remoteSystemIndex);
-				}
-				else if (time &gt; rakPeer-&gt;requestedConnectionsList[remoteSystemIndex]-&gt;nextRequestTime)
-				{
-					rakPeer-&gt;SendConnectionRequest(
-						rakPeer-&gt;PlayerIDToDottedIP(rakPeer-&gt;requestedConnectionsList[remoteSystemIndex]-&gt;playerId),
-						rakPeer-&gt;requestedConnectionsList[remoteSystemIndex]-&gt;playerId.port);
+				delete requestedConnectionsList[remoteSystemIndex];
+				requestedConnectionsList.del(remoteSystemIndex);
+			}
+			else if (time &gt; requestedConnectionsList[remoteSystemIndex]-&gt;nextRequestTime)
+			{
+				SendConnectionRequest(
+					PlayerIDToDottedIP(requestedConnectionsList[remoteSystemIndex]-&gt;playerId),
+					requestedConnectionsList[remoteSystemIndex]-&gt;playerId.port);
 
-					// Send again 2 seconds later
-					rakPeer-&gt;requestedConnectionsList[remoteSystemIndex]-&gt;nextRequestTime=time + 2000;
-					remoteSystemIndex++;
-				}
-				else
-					remoteSystemIndex++;
+				// Send again 2 seconds later
+				requestedConnectionsList[remoteSystemIndex]-&gt;nextRequestTime=time + 2000;
+				remoteSystemIndex++;
 			}
-			rakPeer-&gt;rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+			else
+				remoteSystemIndex++;
 		}
+		if (threadSleepTimer&gt;=0)
+			rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+	}
 
-		for (remoteSystemIndex=0; remoteSystemIndex &lt; maximumNumberOfPeers; ++remoteSystemIndex)
+	for (remoteSystemIndex=0; remoteSystemIndex &lt; maximumNumberOfPeers; ++remoteSystemIndex)
+	{
+		if (remoteSystemList[remoteSystemIndex].playerId!=UNASSIGNED_PLAYER_ID)
 		{
-			if (remoteSystemList[remoteSystemIndex].playerId!=UNASSIGNED_PLAYER_ID)
+			// Found an active remote system
+			remoteSystem = remoteSystemList+remoteSystemIndex;
+			// Update is only safe to call from the same thread that calls HandleSocketReceiveFromConnectedPlayer,
+			// which is this thread
+			remoteSystem-&gt;reliabilityLayer.Update(connectionSocket, remoteSystem-&gt;playerId, MTUSize, time);
+
+			// Was the reliability layer unable to deliver a reliable packet?
+			if (remoteSystem-&gt;reliabilityLayer.IsDeadConnection())
 			{
-				// Found an active remote system
-				remoteSystem = remoteSystemList+remoteSystemIndex;
-				remoteSystem-&gt;reliabilityLayer.Update(rakPeer-&gt;connectionSocket, remoteSystem-&gt;playerId, rakPeer-&gt;MTUSize);
+				packet = PacketPool::Instance()-&gt;GetPointer();
 
-				anyPeersActive=true;
+				packet-&gt;data = new unsigned char [sizeof(char) + remoteSystem-&gt;staticData.GetNumberOfBytesUsed()];
+				packet-&gt;data[0]=ID_CONNECTION_LOST;
+				memcpy(packet-&gt;data+sizeof(char), remoteSystem-&gt;staticData.GetData(), remoteSystem-&gt;staticData.GetNumberOfBytesUsed());
 
-				// Was the reliability layer unable to deliver a reliable packet?
-				if (remoteSystem-&gt;reliabilityLayer.IsDeadConnection())
-				{
-					packet = PacketPool::Instance()-&gt;GetPointer();
+				packet-&gt;length=sizeof(char) + remoteSystem-&gt;staticData.GetNumberOfBytesUsed();
+				packet-&gt;bitSize=(sizeof(char) + remoteSystem-&gt;staticData.GetNumberOfBytesUsed()) * 8;
+				packet-&gt;playerId=remoteSystem-&gt;playerId;
+				packet-&gt;playerIndex=(PlayerIndex)remoteSystemIndex;
 
-					packet-&gt;data = new char [sizeof(char) + remoteSystem-&gt;staticData.GetNumberOfBytesUsed()];
-					packet-&gt;data[0]=ID_CONNECTION_LOST;
-					memcpy(packet-&gt;data+sizeof(char), remoteSystem-&gt;staticData.GetData(), remoteSystem-&gt;staticData.GetNumberOfBytesUsed());
+				incomingQueueMutex.Lock();
+				(incomingPacketQueue).push(packet);
+				incomingQueueMutex.Unlock();
 
-					packet-&gt;length=sizeof(char) + remoteSystem-&gt;staticData.GetNumberOfBytesUsed();
-					packet-&gt;bitSize=(sizeof(char) + remoteSystem-&gt;staticData.GetNumberOfBytesUsed()) * 8;
+				CloseConnection(remoteSystem-&gt;playerId, false, 0L);
+				continue;
+			}
 
-					packet-&gt;playerId=remoteSystem-&gt;playerId;
+			// Did the reliability layer detect a modified packet?
+			if (remoteSystem-&gt;reliabilityLayer.IsCheater())
+			{
+				packet = PacketPool::Instance()-&gt;GetPointer();
+				packet-&gt;length=1;
+				packet-&gt;data = new unsigned char [1];
+				packet-&gt;data[0] = (unsigned char)ID_MODIFIED_PACKET;
+				packet-&gt;playerId=remoteSystem-&gt;playerId;
+				packet-&gt;playerIndex=(PlayerIndex)remoteSystemIndex;
 
-					rakPeer-&gt;incomingQueueMutex.Lock();
-					(rakPeer-&gt;incomingPacketQueue).push(packet);
-					rakPeer-&gt;incomingQueueMutex.Unlock();
+				incomingQueueMutex.Lock();
+				(incomingPacketQueue).push(packet);
+				incomingQueueMutex.Unlock();
 
-					rakPeer-&gt;CloseConnection(remoteSystem-&gt;playerId, false);
-					continue;
-				}
+				continue;
+			}
 
-				// Did the reliability layer detect a modified packet?
-				if (remoteSystem-&gt;reliabilityLayer.IsCheater())
-				{
-					packet = PacketPool::Instance()-&gt;GetPointer();
-					packet-&gt;length=1;
-					packet-&gt;data = new char [1];
-					packet-&gt;data[0] = (unsigned char)ID_MODIFIED_PACKET;
-					packet-&gt;playerId=remoteSystem-&gt;playerId;
+			// Ping this guy if it is time to do so
+			if (time &gt; remoteSystem-&gt;nextPingTime &amp;&amp; (occasionalPing || remoteSystem-&gt;lowestPing==-1))
+			{
+				remoteSystem-&gt;nextPingTime = time + 5000;
+				Ping(remoteSystem-&gt;playerId);
+			}
 
-					rakPeer-&gt;incomingQueueMutex.Lock();
-					(rakPeer-&gt;incomingPacketQueue).push(packet);
-					rakPeer-&gt;incomingQueueMutex.Unlock();
+			// Find whoever has the lowest player ID
+			//if (remoteSystem-&gt;playerId &lt; authoritativeClientPlayerId)
+			//	authoritativeClientPlayerId=remoteSystem-&gt;playerId;
 
-					continue;
-				}
+			// Does the reliability layer have any packets waiting for us?
+			// To be thread safe, this has to be called in the same thread as HandleSocketReceiveFromConnectedPlayer
+			bitSize = remoteSystem-&gt;reliabilityLayer.Receive(&amp;data);
 
-				if (rakPeer-&gt;occasionalPing)
+			while (bitSize &gt; 0)
+			{
+				// Put the input through compression if necessary
+				if (inputTree)
 				{
-					// Ping this guy if it is time to do so
-					if (time &gt; remoteSystem-&gt;nextPingTime)
+					RakNet::BitStream dataBitStream(MAXIMUM_MTU_SIZE);
+					// Since we are decompressing input, we need to copy to a bitstream, decompress, then copy back to a probably
+					// larger data block.  It's slow, but the user should have known that anyway
+					dataBitStream.Reset();
+					dataBitStream.WriteAlignedBytes((unsigned char*)data, BITS_TO_BYTES(bitSize));
+					numberOfBytesUsed = dataBitStream.GetNumberOfBytesUsed();
+					numberOfBitsUsed = dataBitStream.GetNumberOfBitsUsed();
+					rawBytesReceived+=numberOfBytesUsed;
+					// Decompress the input data.
+
+#ifdef _DEBUG
+					assert(numberOfBitsUsed&gt;0);
+#endif
+					unsigned char *dataCopy = new unsigned char[numberOfBytesUsed];
+					memcpy(dataCopy, dataBitStream.GetData(), numberOfBytesUsed);
+					dataBitStream.Reset();
+					inputTree-&gt;DecodeArray(dataCopy,numberOfBitsUsed, &amp;dataBitStream);
+					compressedBytesReceived+=dataBitStream.GetNumberOfBytesUsed();
+					delete [] dataCopy;
+
+					byteSize = dataBitStream.GetNumberOfBytesUsed();
+					if (byteSize &gt; BITS_TO_BYTES(bitSize)) // Probably the case - otherwise why decompress?
 					{
-						remoteSystem-&gt;nextPingTime = time + 5000;
-						rakPeer-&gt;Ping(remoteSystem-&gt;playerId);
+						delete [] data;
+						data = new char [byteSize];
 					}
+					memcpy(data, dataBitStream.GetData(), byteSize);
 				}
+				else
+					// Fast and easy - just use the data that was returned
+					byteSize = BITS_TO_BYTES(bitSize);
 
-				// Find whoever has the lowest player ID
-				//if (remoteSystem-&gt;playerId &lt; authoritativeClientPlayerId)
-				//	authoritativeClientPlayerId=remoteSystem-&gt;playerId;
+				// Read any system packets
+				if ((unsigned char)data[0]==ID_PONG &amp;&amp; byteSize==sizeof(PingStruct))
+				{
+					// Copy into the ping times array the current time - the value returned
+					// First extract the sent ping
+					PingStruct *ps = (PingStruct *)data;
 
-				// Does the reliability layer have any packets waiting for us?
-				bitSize = remoteSystem-&gt;reliabilityLayer.Receive(&amp;data);
+					ping=time - ps-&gt;sendPingTime;
+					lastPing = remoteSystem-&gt;pingAndClockDifferential[remoteSystem-&gt;pingAndClockDifferentialWriteIndex].pingTime;
 
-				while (bitSize &gt; 0)
-				{
-					// Put the input through compression if necessary
-					if (rakPeer-&gt;inputTree)
+					// Ignore super high spikes in the average
+					if (lastPing &lt;= 0 || (((int)ping &lt; (lastPing * 3)) &amp;&amp; ping &lt; 1200))
 					{
-						// Since we are decompressing input, we need to copy to a bitstream, decompress, then copy back to a probably
-						// larger data block.  It's slow, but the user should have known that anyway
-						dataBitStream.Reset();
-						dataBitStream.WriteAlignedBytes((unsigned char*)data, BITS_TO_BYTES(bitSize));
-						numberOfBytesUsed = dataBitStream.GetNumberOfBytesUsed();
-						numberOfBitsUsed = dataBitStream.GetNumberOfBitsUsed();
-						rakPeer-&gt;rawBytesRecieved+=numberOfBytesUsed;
-						// Decompress the input data.
-						if (rakPeer-&gt;inputTree)
-						{
-#ifdef _DEBUG
-							assert(numberOfBitsUsed&gt;0);
-#endif
-							unsigned char *dataCopy = new unsigned char[numberOfBytesUsed];
-							memcpy(dataCopy, dataBitStream.GetData(), numberOfBytesUsed);
-							dataBitStream.Reset();
-							rakPeer-&gt;inputTree-&gt;DecodeArray(dataCopy,numberOfBitsUsed, &amp;dataBitStream);
-							rakPeer-&gt;compressedBytesRecieved+=dataBitStream.GetNumberOfBytesUsed();
-							delete [] dataCopy;
-						}
-						byteSize = dataBitStream.GetNumberOfBytesUsed();
-						if (byteSize &gt; BITS_TO_BYTES(bitSize)) // Probably the case - otherwise why decompress?
-						{
-							delete [] data;
-							data = new char [byteSize];
-						}
-						memcpy(data, dataBitStream.GetData(), byteSize);
+						remoteSystem-&gt;pingAndClockDifferential[remoteSystem-&gt;pingAndClockDifferentialWriteIndex].pingTime=(short)ping;
+						// Thanks to Chris Taylor (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">cat02e at fsu.edu</A>) for the improved timestamping algorithm
+						remoteSystem-&gt;pingAndClockDifferential[remoteSystem-&gt;pingAndClockDifferentialWriteIndex].clockDifferential=ps-&gt;sendPongTime - (time + ps-&gt;sendPingTime) / 2;
+						if (remoteSystem-&gt;lowestPing==-1 ||  remoteSystem-&gt;lowestPing &gt; ping)
+							remoteSystem-&gt;lowestPing = ping;
+						// Most packets should arrive by the ping time.
+						remoteSystem-&gt;reliabilityLayer.SetLostPacketResendDelay(ping*2);
+
+						if (++(remoteSystem-&gt;pingAndClockDifferentialWriteIndex) == PING_TIMES_ARRAY_SIZE)
+							remoteSystem-&gt;pingAndClockDifferentialWriteIndex=0;
 					}
-					else
-						// Fast and easy - just use the data that was returned
-						byteSize = BITS_TO_BYTES(bitSize);
 
-					// Read any system packets
-					if ((unsigned char)data[0]==ID_PONG &amp;&amp; byteSize==sizeof(PingStruct))
-					{
-						// Copy into the ping times array the current time - the value returned
-						// First extract the sent ping
-						PingStruct *ps = (PingStruct *)data;
+					delete [] data;
+				}
+				else if ((unsigned char)data[0]==ID_PING &amp;&amp; byteSize==sizeof(PingStruct))
+				{
+					PingStruct *ps = (PingStruct*)data;
+					ps-&gt;typeId=ID_PONG;
+					ps-&gt;sendPongTime=RakNetGetTime();
 
-						ping=time - ps-&gt;sendPingTime;
-						lastPing = remoteSystem-&gt;pingAndClockDifferential[remoteSystem-&gt;pingAndClockDifferentialWriteIndex].pingTime;
+					Send(data,byteSize, SYSTEM_PRIORITY, UNRELIABLE, 0, remoteSystem-&gt;playerId, false);
+					delete [] data;
+				}
+				else if ((unsigned char)data[0]==ID_NEW_INCOMING_CONNECTION &amp;&amp; byteSize==sizeof(NewIncomingConnectionStruct))
+				{
+					Ping(remoteSystem-&gt;playerId);
+					SendStaticData(remoteSystem-&gt;playerId);
 
-						// Ignore super high spikes in the average
-						if (lastPing &lt;= 0 || (((int)ping &lt; (lastPing * 3)) &amp;&amp; ping &lt; 1200))
-						{
-							remoteSystem-&gt;pingAndClockDifferential[remoteSystem-&gt;pingAndClockDifferentialWriteIndex].pingTime=(short)ping;
-							// Thanks to Chris Taylor (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">cat02e at fsu.edu</A>) for the improved timestamping algorithm
-							remoteSystem-&gt;pingAndClockDifferential[remoteSystem-&gt;pingAndClockDifferentialWriteIndex].clockDifferential=ps-&gt;sendPongTime - (time + ps-&gt;sendPingTime) / 2;
-							if (remoteSystem-&gt;lowestPing==-1 ||  remoteSystem-&gt;lowestPing &gt; ping)
-								remoteSystem-&gt;lowestPing = ping;
-							remoteSystem-&gt;reliabilityLayer.SetLostPacketResendDelay(ping * 6);
+					NewIncomingConnectionStruct *newIncomingConnectionStruct = (NewIncomingConnectionStruct *) data;
+					remoteSystem-&gt;myExternalPlayerId=newIncomingConnectionStruct-&gt;externalID;
 
-							if (++(remoteSystem-&gt;pingAndClockDifferentialWriteIndex) == PING_TIMES_ARRAY_SIZE)
-								remoteSystem-&gt;pingAndClockDifferentialWriteIndex=0;
-						}
+					// Send this info down to the game
+					packet = PacketPool::Instance()-&gt;GetPointer();
+					packet-&gt;data = (unsigned char*)data;
+					packet-&gt;length=byteSize;
+					packet-&gt;bitSize=bitSize;
+					packet-&gt;playerId=remoteSystem-&gt;playerId;
+					packet-&gt;playerIndex=(PlayerIndex)remoteSystemIndex;
 
-						delete [] data;
-					}
-					else if ((unsigned char)data[0]==ID_PING &amp;&amp; byteSize==sizeof(PingStruct))
+#ifdef _DEBUG
+					assert(packet-&gt;data);
+#endif
+					incomingQueueMutex.Lock();
+					incomingPacketQueue.push(packet);
+					incomingQueueMutex.Unlock();
+				}
+				/*
+				else if ((unsigned char)data[0]==ID_SYNCHRONIZE_MEMORY)
+				{
+				if (byteSize&gt;2)
+				{
+				packet = PacketPool::Instance()-&gt;GetPointer();
+				packet-&gt;data = data;
+				packet-&gt;length=byteSize;
+				packet-&gt;bitSize=bitSize;
+				packet-&gt;playerId=remoteSystem-&gt;playerId;
+
+				synchronizedMemoryQueueMutex.Lock();
+				synchronizedMemoryPacketQueue.push(packet);
+				synchronizedMemoryQueueMutex.Unlock();
+				}
+				else
+				delete [] data;
+				}
+				*/
+				else if ((unsigned char)data[0]==ID_DISCONNECTION_NOTIFICATION)
+				{
+					packet = PacketPool::Instance()-&gt;GetPointer();
+					if (remoteSystem-&gt;staticData.GetNumberOfBytesUsed()&gt;0)
 					{
-						PingStruct *ps = (PingStruct*)data;
-						ps-&gt;typeId=ID_PONG;
-						ps-&gt;sendPongTime=getTime();
+						packet-&gt;data = new unsigned char [sizeof(char) + remoteSystem-&gt;staticData.GetNumberOfBytesUsed()];
+						packet-&gt;data[0]=ID_DISCONNECTION_NOTIFICATION;
+						memcpy(packet-&gt;data+sizeof(char), remoteSystem-&gt;staticData.GetData(), remoteSystem-&gt;staticData.GetNumberOfBytesUsed());
 
-						rakPeer-&gt;Send(data,byteSize, HIGH_PRIORITY, UNRELIABLE, 0, remoteSystem-&gt;playerId, false);
+						packet-&gt;length=sizeof(char) + remoteSystem-&gt;staticData.GetNumberOfBytesUsed();
+						packet-&gt;bitSize=sizeof(char)*8 + remoteSystem-&gt;staticData.GetNumberOfBitsUsed();
+
 						delete [] data;
 					}
-					else if ((unsigned char)data[0]==ID_NEW_INCOMING_CONNECTION &amp;&amp; byteSize==sizeof(NewIncomingConnectionStruct))
+					else
 					{
-						rakPeer-&gt;Ping(remoteSystem-&gt;playerId);
-						rakPeer-&gt;SendStaticData(remoteSystem-&gt;playerId);
-
-						NewIncomingConnectionStruct *newIncomingConnectionStruct = (NewIncomingConnectionStruct *) data;
-						remoteSystem-&gt;myExternalPlayerId=newIncomingConnectionStruct-&gt;externalID;
-
-						// Send this info down to the game
-						packet = PacketPool::Instance()-&gt;GetPointer();
-						packet-&gt;data = data;
-						packet-&gt;length=byteSize;
+						packet-&gt;data=(unsigned char*)data;
 						packet-&gt;bitSize=bitSize;
-						packet-&gt;playerId=remoteSystem-&gt;playerId;
-
-#ifdef _DEBUG
-						assert(packet-&gt;data);
-#endif
-						rakPeer-&gt;incomingQueueMutex.Lock();
-						rakPeer-&gt;incomingPacketQueue.push(packet);
-						rakPeer-&gt;incomingQueueMutex.Unlock();
+						packet-&gt;length=1;
 					}
-					/*
-					else if ((unsigned char)data[0]==ID_SYNCHRONIZE_MEMORY)
-					{
-						if (byteSize&gt;2)
-						{
-							packet = PacketPool::Instance()-&gt;GetPointer();
-							packet-&gt;data = data;
-							packet-&gt;length=byteSize;
-							packet-&gt;bitSize=bitSize;
-							packet-&gt;playerId=remoteSystem-&gt;playerId;
 
-							rakPeer-&gt;synchronizedMemoryQueueMutex.Lock();
-							rakPeer-&gt;synchronizedMemoryPacketQueue.push(packet);
-							rakPeer-&gt;synchronizedMemoryQueueMutex.Unlock();
-						}
-						else
-							delete [] data;
-					}
-					*/
-					else if ((unsigned char)data[0]==ID_DISCONNECTION_NOTIFICATION)
-					{
-						packet = PacketPool::Instance()-&gt;GetPointer();
-						if (remoteSystem-&gt;staticData.GetNumberOfBytesUsed()&gt;0)
-						{
-							packet-&gt;data = new char [sizeof(char) + remoteSystem-&gt;staticData.GetNumberOfBytesUsed()];
-							packet-&gt;data[0]=ID_DISCONNECTION_NOTIFICATION;
-							memcpy(packet-&gt;data+sizeof(char), remoteSystem-&gt;staticData.GetData(), remoteSystem-&gt;staticData.GetNumberOfBytesUsed());
+					packet-&gt;playerId=remoteSystem-&gt;playerId;
+					packet-&gt;playerIndex=(PlayerIndex)remoteSystemIndex;
 
-							packet-&gt;length=sizeof(char) + remoteSystem-&gt;staticData.GetNumberOfBytesUsed();
-							packet-&gt;bitSize=sizeof(char)*8 + remoteSystem-&gt;staticData.GetNumberOfBitsUsed();
+					CloseConnection(remoteSystem-&gt;playerId, false, 0L);
 
-							delete [] data;
-						}
-						else
-						{
-							packet-&gt;data=data;
-							packet-&gt;bitSize=bitSize;
-							packet-&gt;length=1;
-						}
-
-						packet-&gt;playerId=remoteSystem-&gt;playerId;
-
-						rakPeer-&gt;CloseConnection(remoteSystem-&gt;playerId, false);
-
 #ifdef _DEBUG
-						assert(packet-&gt;data);
+					assert(packet-&gt;data);
 #endif
-						// Relay this message to the game
-						rakPeer-&gt;incomingQueueMutex.Lock();
-						rakPeer-&gt;incomingPacketQueue.push(packet);
-						rakPeer-&gt;incomingQueueMutex.Unlock();
+					// Relay this message to the game
+					incomingQueueMutex.Lock();
+					incomingPacketQueue.push(packet);
+					incomingQueueMutex.Unlock();
 
-					}
-					else if ((unsigned char)data[0]==ID_REQUEST_STATIC_DATA)
-					{
-						rakPeer-&gt;SendStaticData(remoteSystem-&gt;playerId);
-						delete [] data;
-					}
-					else if ((unsigned char)data[0] == ID_RECEIVED_STATIC_DATA)
-					{
-						remoteSystem-&gt;staticData.Reset();
-						remoteSystem-&gt;staticData.Write((char*)data+sizeof(unsigned char), byteSize-1);
+				}
+				else if ((unsigned char)data[0]==ID_REQUEST_STATIC_DATA)
+				{
+					SendStaticData(remoteSystem-&gt;playerId);
+					delete [] data;
+				}
+				else if ((unsigned char)data[0] == ID_RECEIVED_STATIC_DATA)
+				{
+					remoteSystem-&gt;staticData.Reset();
+					remoteSystem-&gt;staticData.Write((char*)data+sizeof(unsigned char), byteSize-1);
 
-						// Inform game server code that we got static data
-						packet = PacketPool::Instance()-&gt;GetPointer();
-						packet-&gt;data = data;
-						packet-&gt;length = byteSize;
-						packet-&gt;bitSize=bitSize;
-						packet-&gt;playerId = remoteSystem-&gt;playerId;
+					// Inform game server code that we got static data
+					packet = PacketPool::Instance()-&gt;GetPointer();
+					packet-&gt;data = (unsigned char*)data;
+					packet-&gt;length = byteSize;
+					packet-&gt;bitSize=bitSize;
+					packet-&gt;playerId = remoteSystem-&gt;playerId;
+					packet-&gt;playerIndex=(PlayerIndex)remoteSystemIndex;
 
 #ifdef _DEBUG
-						assert(packet-&gt;data);
+					assert(packet-&gt;data);
 #endif
-						rakPeer-&gt;incomingQueueMutex.Lock();
-						rakPeer-&gt;incomingPacketQueue.push(packet);
-						rakPeer-&gt;incomingQueueMutex.Unlock();
-					}
-					else if ((unsigned char)data[0] == ID_RPC || (unsigned char)data[0] == ID_RPC_WITH_TIMESTAMP)
-					{
-						rakPeer-&gt;HandleRPCPacket(data, byteSize, remoteSystem-&gt;playerId);
-						delete [] data;
-					}
-					else
-					{
-						packet = PacketPool::Instance()-&gt;GetPointer();
-						packet-&gt;data = data;
-						packet-&gt;length=byteSize;
-						packet-&gt;bitSize=bitSize;
-						packet-&gt;playerId=remoteSystem-&gt;playerId;
+					incomingQueueMutex.Lock();
+					incomingPacketQueue.push(packet);
+					incomingQueueMutex.Unlock();
+				}
+				else
+				{
+					packet = PacketPool::Instance()-&gt;GetPointer();
+					packet-&gt;data = (unsigned char*)data;
+					packet-&gt;length=byteSize;
+					packet-&gt;bitSize=bitSize;
+					packet-&gt;playerId=remoteSystem-&gt;playerId;
+					packet-&gt;playerIndex=(PlayerIndex)remoteSystemIndex;
 
 #ifdef _DEBUG
-						assert(packet-&gt;data);
+					assert(packet-&gt;data);
 #endif
-						rakPeer-&gt;incomingQueueMutex.Lock();
-						rakPeer-&gt;incomingPacketQueue.push(packet);
-						rakPeer-&gt;incomingQueueMutex.Unlock();
-					}
+					incomingQueueMutex.Lock();
+					incomingPacketQueue.push(packet);
+					incomingQueueMutex.Unlock();
+				}
 
-					// Does the reliability layer have any more packets waiting for us?
-					bitSize = remoteSystem-&gt;reliabilityLayer.Receive(&amp;data);
-				}
+				// Does the reliability layer have any more packets waiting for us?
+				// To be thread safe, this has to be called in the same thread as HandleSocketReceiveFromConnectedPlayer
+				bitSize = remoteSystem-&gt;reliabilityLayer.Receive(&amp;data);
 			}
 		}
+	}
 
 
-		// Statistics histogram
-		if (time &gt; nextReadBytesTime)
+	/*
+	// Statistics histogram
+	if (time &gt; nextReadBytesTime)
+	{
+		nextReadBytesTime = time + 1000L; // 1 second
+		for (remoteSystemIndex=0; remoteSystemIndex &lt; maximumNumberOfPeers; ++remoteSystemIndex)
 		{
-			nextReadBytesTime = time + 1000L; // 1 second
-			currentSentBytes = rakPeer-&gt;GetBytesSent();
-			currentReceivedBytes = rakPeer-&gt;GetBytesReceived();
-			rakPeer-&gt;bytesSentPerSecond = currentSentBytes - lastSentBytes;
-			rakPeer-&gt;bytesReceivedPerSecond = currentReceivedBytes - lastReceivedBytes;
-			lastSentBytes=currentSentBytes;
-			lastReceivedBytes=currentReceivedBytes;
-		}
+		currentSentBytes = GetBytesSent();
+		currentReceivedBytes = GetBytesReceived();
+		bytesSentPerSecond = currentSentBytes - lastSentBytes;
+		bytesReceivedPerSecond = currentReceivedBytes - lastReceivedBytes;
+		lastSentBytes=currentSentBytes;
+		lastReceivedBytes=currentReceivedBytes;
+	}
+	*/
 
-		// Context switch so other threads can run
-		if (rakPeer-&gt;threadPriority==0)
+	return true;
+}
+// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+#ifdef _WIN32
+unsigned __stdcall UpdateNetworkLoop(LPVOID arguments)
+#else
+void*  UpdateNetworkLoop( void*  arguments )
+#endif
+{
+	RakPeer *rakPeer = (RakPeer *)arguments;
+//	unsigned long time;
+
+#ifdef __USE_IO_COMPLETION_PORTS
+	AsynchronousFileIO::Instance()-&gt;IncreaseUserCount();
+#endif
+
+	rakPeer-&gt;isMainLoopThreadActive=true;
+
+	while(rakPeer-&gt;endThreads==false)
+	{
+		/*
+		time=RakNetGetTime();
+
+		// Dynamic threading - how long we sleep and if we update
+		// depends on whether or not the user thread is updating
+		if (time &gt; rakPeer-&gt;lastUserUpdateCycle &amp;&amp; time - rakPeer-&gt;lastUserUpdateCycle &gt; UPDATE_THREAD_UPDATE_TIME)
 		{
-			#ifdef _WIN32
-			Sleep(15);
-			#else
-			usleep(15 * 1000);
-			#endif
+			// Only one thread should call RunUpdateCycle at a time.  We don't need to delay calls so
+			// a mutex on the function is not necessary - only on the variable that indicates if the function is
+			// running
+			rakPeer-&gt;RunMutexedUpdateCycle();
+			
+
+			// User is not updating the network.  Sleep a short time
+#ifdef _WIN32
+				Sleep(rakPeer-&gt;threadSleepTimer);
+#else
+				usleep(rakPeer-&gt;threadSleepTimer * 1000);
+#endif
 		}
-		else if (rakPeer-&gt;threadPriority==1)
+		else
 		{
+			// User is actively updating the network.  Only occasionally poll
 #ifdef _WIN32
-			Sleep(0);
+			Sleep(UPDATE_THREAD_POLL_TIME);
 #else
-			usleep(0 * 1000);
+			usleep(UPDATE_THREAD_POLL_TIME * 1000);
 #endif
 		}
-
-		if (anyPeersActive==false)		
-		{
+		*/
+		rakPeer-&gt;RunUpdateCycle();
 #ifdef _WIN32
-			Sleep(30);
+		Sleep(rakPeer-&gt;threadSleepTimer);
 #else
-			usleep(30 * 1000);
+		usleep(rakPeer-&gt;threadSleepTimer * 1000);
 #endif
-		}
 	}
 	rakPeer-&gt;isMainLoopThreadActive=false;
 
+#ifdef __USE_IO_COMPLETION_PORTS
+	AsynchronousFileIO::Instance()-&gt;DecreaseUserCount();
+#endif
+
+
 	return 0;
 }
+
+/*
+void RakPeer::RunMutexedUpdateCycle(void)
+{
+	rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Lock();
+	if (updateCycleIsRunning==false)
+	{
+		updateCycleIsRunning=true;
+		rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Unlock();
+		RunUpdateCycle(); // Do one update per call to Receive
+		rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Lock();
+		updateCycleIsRunning=false;
+		rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Unlock();
+	}
+	else
+		rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Unlock();
+}
+*/

Modified: trunk/source/libraries/raknet/RakPeer.h
===================================================================
--- trunk/source/libraries/raknet/RakPeer.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakPeer.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -14,7 +14,8 @@
 #include &quot;RakPeerInterface.h&quot;
 #include &quot;BinarySearchTree.h&quot;
 #include &quot;RPCNode.h&quot;
-#include &quot;MPUInt.h&quot;
+#include &quot;RSACrypt.h&quot;
+#include &quot;BitStream.h&quot;
 
 class HuffmanEncodingTree;
 
@@ -42,11 +43,11 @@
 	// - A pure client would set this to 1.  A pure server would set it to the number of allowed clients.
 	// - A hybrid would set it to the sum of both types of connections
 	// localPort: The port to listen for connections on.
-	// _threadPriority: 0 for regular priority (0-8 players), 1 for high priority (High performance applications), and 2 for ultra-high priority (MMO server)
+	// _threadSleepTimer: &lt;0 for single threaded, &gt;=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	//
 	// Returns:
 	// False on failure (can't create socket or thread), true on success.
-	bool Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadPriority);
+	bool Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadSleepTimer);
 
 	// Description:
 	// Must be called while offline
@@ -58,15 +59,13 @@
 	// If you accept connections, you must call this or else secure connections will not be enabled
 	// for incoming connections.
 	// If you are connecting to another system, you can call this with values for the
-	// (e and n) public keys before connecting to prevent MitM
+	// (e and p,q) public keys before connecting to prevent MitM
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAd - A pointer to the private key of length numberOfBytes.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
-	void InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn);
+	// pubKeyP, pubKeyQ - Public keys generated from the RSACrypt class.  See the Encryption sample
+	// privKeyE, privKeyN - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+	// If the private keys are 0, then a new key will be generated when this function is called
+	void InitializeSecurity(char *pubKeyP, char *pubKeyQ, char *privKeyE, char *privKeyN);
 
 	// Description
 	// Must be called while offline
@@ -98,13 +97,13 @@
 
 	// Description:
 	// Returns the password set by SetIncomingPassword in a BitStream
-	BitStream *GetIncomingPassword(void);
+	RakNet::BitStream *GetIncomingPassword(void);
 
 	// Description:
 	// Call this to connect to the specified host (ip or domain name) and server port.
 	// Calling Connect and not calling SetMaximumIncomingConnections acts as a dedicated client.  Calling both acts as a true peer.
 	// This is a non-blocking connection.  You know the connection is successful when IsConnected() returns true
-	// or receive gets a packet with the type identifier ID_ENUMERATION_REPLY.  If the connection is not
+	// or receive gets a packet with the type identifier ID_CONNECTION_ACCEPTED.  If the connection is not
 	// successful, such as rejected connection or no response then neither of these things will happen.
 	// Requires that you first call Initialize
 	//
@@ -120,7 +119,11 @@
 
 	// Description:
 	// Stops the network threads and close all connections.  Multiple calls are ok.
-	void Disconnect(void);
+	//
+	// Parameters:
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	void Disconnect(unsigned long blockDuration);
 
 	// Description:
 	// Returns true if the network threads are running
@@ -145,14 +148,14 @@
 	// bitStream: The bitstream to send
 	// priority: What priority level to send on.
 	// reliability: How reliability to send this data
-	// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+	// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 	// - Packets are only ordered relative to other packets on the same stream
 	// playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 	// broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 	// Returns:
 	// False if we are not connected to the specified recipient.  True otherwise
-	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast);
-	bool Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast);
+	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast);
+	bool Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast);
 
 	// Description:
 	// Gets a packet from the incoming packet queue. Use DeallocatePacket to deallocate the packet after you are done with it.
@@ -207,13 +210,13 @@
 	// bitStream: The bitstream to send
 	// priority: What priority level to send on.
 	// reliability: How reliability to send this data
-	// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+	// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 	// broadcast - Send this packet to everyone.
 	// playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 	// broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 	// shiftTimestamp: True to treat the first 4 bytes as a timestamp and make it system relative on arrival (Same as ID_TIMESTAMP for a packet enumeration type)
-	bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp);
-	bool RPC(char* uniqueID, BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp);
+	bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp);
+	bool RPC(char* uniqueID, RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp);
 
 	// --------------------------------------------------------------------------------------------
 	// Player Management Functions
@@ -224,7 +227,9 @@
 	// Parameters:
 	// target: Which connection to close
 	// sendDisconnectionNotification: True to send ID_DISCONNECTION_NOTIFICATION to the recipient.  False to close it silently.
-	void CloseConnection(PlayerID target, bool sendDisconnectionNotification);
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	void CloseConnection(PlayerID target, bool sendDisconnectionNotification, unsigned long blockDuration);
 
 	// Description:
 	// Given a playerID, returns an index from 0 to the maximum number of players allowed - 1.
@@ -297,9 +302,10 @@
 	// The sender and recipient must already be started via a successful call to Initialize
 	//
 	// Parameters:
-	// host: Either a dotted IP address or a domain name
+	// host: Either a dotted IP address or a domain name.  Can be 255.255.255.255 for LAN broadcast.
 	// remotePort: Which port to connect to on the remote machine.
-	void Ping(char* host, unsigned short remotePort);
+	// onlyReplyOnAcceptingConnections: Only request a reply if the remote system is accepting connections
+	void Ping(char* host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections);
 
 	// Description:
 	// Returns the average of all ping times read for a specified target
@@ -323,7 +329,7 @@
 	int GetLowestPing(PlayerID target) const;
 
 	// Description:
-	// Ping the remote systems every so often.  This is on by default
+	// Ping the remote systems every so often.  This is off by default
 	// This will work anytime
 	//
 	// Parameters:
@@ -383,7 +389,7 @@
 	//
 	// Returns:
 	// The data passed to SetRemoteStaticData stored as a bitstream
-	BitStream* GetRemoteStaticData(PlayerID playerId);
+	RakNet::BitStream * GetRemoteStaticData(PlayerID playerId);
 
 	// Description:
 	// All systems have a block of data associated with them, for user use.  This block of data can be used to easily
@@ -404,6 +410,13 @@
 	// target: Who to send your static data to.  Specify UNASSIGNED_PLAYER_ID to broadcast to all
 	void SendStaticData(PlayerID target);
 
+	// Description:
+	// Sets the data to send with an  (LAN server discovery) /(offline ping) response
+	// See the Ping sample project for how this is used.
+	// data: a block of data to store, or 0 for none
+	// length: The length of data in bytes, or 0 for none
+	void SetOfflinePingResponse(char *data, const unsigned long length);
+
 	// --------------------------------------------------------------------------------------------
 	// Network Functions - Functions dealing with the network in general
 	// --------------------------------------------------------------------------------------------
@@ -463,9 +476,37 @@
 	const char* PlayerIDToDottedIP(PlayerID playerId) const;
 
 	// Description:
+	// Converts a dotted IP to a playerId
+	//
+	// Parameters:
+	// host: [input] Either a dotted IP address or a domain name
+	// remotePort: [input] Which port to connect to on the remote machine.
+	// playerId: [output] The result of this operation
+	void IPToPlayerID(const char* host, unsigned short remotePort, PlayerID *playerId);
+
+	// Description:
 	// Returns an IP address at index 0 to GetNumberOfAddresses-1
 	const char* GetLocalIP(unsigned int index);
 
+	// Description:
+	// Allow or disallow connection responses from any IP.  Normally this should be false, but may be necessary
+	// when connection to servers with multiple IP addresses.
+	//
+	// Parameters:
+	// allow - True to allow this behavior, false to not allow.  Defaults to false.  Value persists between connections
+	void AllowConnectionResponseIPMigration(bool allow);
+
+	// Description:
+	// Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system.
+	// This will tell the remote system our external IP outside the LAN, and can be used for NAT punch through
+	//
+	// Requires:
+	// The sender and recipient must already be started via a successful call to Initialize
+	//
+	// host: Either a dotted IP address or a domain name
+	// remotePort: Which port to connect to on the remote machine.
+	void AdvertiseSystem(char *host, unsigned short remotePort);
+
 	// --------------------------------------------------------------------------------------------
 	// Compression Functions - Functions related to the compression layer
 	// --------------------------------------------------------------------------------------------
@@ -554,29 +595,25 @@
 	// Statistical Functions - Functions dealing with API performance
 	// --------------------------------------------------------------------------------------------
 
-	// Network statistics.
-	double GetPacketlossPercentile(void) const; // The average outgoing packetloss percentile
-	unsigned long GetTransmittedPacketCount(void) const; // How many packets were sent
-	unsigned long GetTransmittedFrameCount(void) const; // How many frames were sent	
-	unsigned long GetLostPacketCount(void) const; // How many packets were lost
-	unsigned long GetReceivedPacketCount(void) const; // How many packets were received
-	unsigned long GetBytesSent(void) const; // How many bytes have been sent.
-	unsigned long GetBytesReceived(void) const; // How many bytes have been received.
-	unsigned long GetUnacknowledgedSentPacketListSize(void) const; // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	unsigned long GetBytesSentPerSecond(void) const;  // How many bytes were sent in the last histogram block.
-	unsigned long GetBytesReceivedPerSecond(void) const; // How many bytes were received in the last histogram block.
-	unsigned long GetMaximumWindowSize(void) const; // Returns the size of the flow control window, in packets.  Smaller values correlate with higher throughput and less packetloss
-	unsigned long GetPacketOutputBufferSize(void) const; // Returns the number of waiting packets on the send queue
-	unsigned long GetConnectionTime(PlayerID playerId) const; // Returns the time elapsed since this player connected
+	// Description:
+	// Returns a structure containing a large set of network statistics for the specified system
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Parameters
+	// playerId: Which connected system to get statistics for
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	RakNetStatisticsStruct * const GetStatistics(PlayerID playerId);
 
 protected:
 
 #ifdef _WIN32
-	friend unsigned __stdcall RecvFromNetworkLoop(LPVOID arguments);
+//	friend unsigned __stdcall RecvFromNetworkLoop(LPVOID arguments);
 	friend void __stdcall ProcessNetworkPacket(unsigned long binaryAddress, unsigned short port, char *data, int length, RakPeer *rakPeer);
 	friend unsigned __stdcall UpdateNetworkLoop(LPVOID arguments);
 #else
-	friend void*  RecvFromNetworkLoop( void*  arguments );
+//	friend void*  RecvFromNetworkLoop( void*  arguments );
 	friend void ProcessNetworkPacket(unsigned long binaryAddress, unsigned short port, char *data, int length, RakPeer *rakPeer);
 	friend void*  UpdateNetworkLoop( void*  arguments );
 #endif
@@ -596,15 +633,13 @@
 		int pingAndClockDifferentialWriteIndex; // The index we are writing into the pingAndClockDifferential circular buffer
 		int lowestPing;
 		unsigned long nextPingTime; // When to next ping this player
-		BitStream staticData;
+		RakNet::BitStream staticData;
 		unsigned long connectionTime;
 	};
 
 	void RecordConnectionAttempt(const char* host, unsigned short remotePort);
 	void RemoveFromRequestedConnectionsList(PlayerID playerId);
 	bool SendConnectionRequest(const char* host, unsigned short remotePort);
-	// Converts a dotted IP to a playerId
-	void IPToPlayerID(const char* host, unsigned short remotePort, PlayerID *playerId);
 	// Get the reliability layer associated with a playerID.  Returns 0 if none
 	RemoteSystemStruct *GetRemoteSystemFromPlayerID(PlayerID playerID) const;
 	// When we get a connection request from an ip / port, either accept or reject it
@@ -634,11 +669,12 @@
 	bool SetupIOCompletionPortSocket(int index);
 	#endif
 
-	bool endThreads, isMainLoopThreadActive, isRecvfromThreadActive; // Tracks thread states
+	bool endThreads, isMainLoopThreadActive;
+	// bool isRecvfromThreadActive; // Tracks thread states
 	bool occasionalPing; // Do we occasionally ping the other systems?
 	unsigned short maximumNumberOfPeers,maximumIncomingConnections;
 	// localStaticData necessary because we may not have a RemoteSystemStruct representing ourselves in the list
-	BitStream incomingPasswordBitStream, outgoingPasswordBitStream, localStaticData;
+	RakNet::BitStream incomingPasswordBitStream, outgoingPasswordBitStream, localStaticData, offlinePingResponse;
 	PlayerID myPlayerId;
 
 	// This is an array of pointers to RemoteSystemStruct
@@ -654,17 +690,21 @@
 		incomingPasswordBitStream_Mutex,
 		outgoingPasswordBitStream_Mutex,
 		remoteSystemList_Mutex, // This mutex is a writer lock for reserving player IDs only
+//		updateCycleIsRunning_Mutex,
+		offlinePingResponse_Mutex,
 		NUMBER_OF_RAKPEER_MUTEXES
 	};
 	SimpleMutex rakPeerMutexes[NUMBER_OF_RAKPEER_MUTEXES];
 
+	// RunUpdateCycle is not thread safe but we don't need to mutex calls.  Just skip calls if it is running already
+	bool updateCycleIsRunning;
 
 	// The list of people we have tried to connect to recently
 	BasicDataStructures::Queue&lt;RequestedConnectionStruct*&gt; requestedConnectionsList;
 
 	// Data that both the client and the server needs
 	unsigned long bytesSentPerSecond, bytesReceivedPerSecond;
-	bool isSocketLayerBlocking;
+//	bool isSocketLayerBlocking;
 	//bool continualPing,isRecvfromThreadActive,isMainLoopThreadActive, endThreads, isSocketLayerBlocking;
 	unsigned long validationInteger;
 #ifdef _WIN32
@@ -694,25 +734,41 @@
 	// Compression stuff
 	unsigned long frequencyTable[256];
 	HuffmanEncodingTree *inputTree, *outputTree;
-	unsigned long rawBytesSent, rawBytesRecieved, compressedBytesSent, compressedBytesRecieved;
-	//void DecompressInput(BitStream *bitStream);
-	//void UpdateOutgoingFrequencyTable(BitStream* bitStream);
+	unsigned long rawBytesSent, rawBytesReceived, compressedBytesSent, compressedBytesReceived;
+	//void DecompressInput(RakNet::BitStream *bitStream);
+	//void UpdateOutgoingFrequencyTable(RakNet::BitStream * bitStream);
 	void GenerateSYNCookieRandomNumber(void);
 	void SecuredConnectionResponse(PlayerID playerId);
-	void SecuredConnectionConfirmation(PlayerID playerId, char* data, int length);
+	void SecuredConnectionConfirmation(PlayerID playerId, char* data);
+	bool RunUpdateCycle(void);
+	//void RunMutexedUpdateCycle(void);
 
 	BasicDataStructures::AVLBalancedBinarySearchTree&lt;RPCNode&gt; rpcTree;
 	int MTUSize;
 	bool trackFrequencyTable;
-	int threadPriority;
+	int threadSleepTimer;
 
 	SOCKET connectionSocket;
 
-	mpuint d,e,n;
-	unsigned short securedConnectionByteSize;
-	bool keysLocallyGenerated;
+	// Histogram statistics
+	//unsigned long nextReadBytesTime;
+	//int lastSentBytes,lastReceivedBytes;
+
+	// Encryption and security
+	big::RSACrypt&lt;RSA_BIT_SIZE&gt; rsacrypt;
+	big::u32 publicKeyP;
+	RSA_BIT_SIZE publicKeyQ;
+	bool keysLocallyGenerated, usingSecurity;
 	unsigned long randomNumberExpirationTime;
 	unsigned char newRandomNumber[20], oldRandomNumber[20];
+
+	// How long it has been since things were updated by a call to receive
+	// Update thread uses this to determine how long to sleep for
+	unsigned long lastUserUpdateCycle;
+
+	// True to allow connection accepted packets from anyone.  False to only allow these packets from servers
+	// we requested a connection to.
+	bool allowConnectionResponseIPMigration;
 };
 
 #endif

Modified: trunk/source/libraries/raknet/RakPeerInterface.h
===================================================================
--- trunk/source/libraries/raknet/RakPeerInterface.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakPeerInterface.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -10,9 +10,10 @@
 #ifndef __RAK_PEER_INTERFACE_H
 #define __RAK_PEER_INTERFACE_H
 
-class BitStream;
 #include &quot;PacketPriority.h&quot;
 #include &quot;NetworkTypes.h&quot;
+#include &quot;BitStream.h&quot;
+#include &quot;RakNetStatistics.h&quot;
 
 class RakPeerInterface
 {
@@ -36,11 +37,11 @@
 	// - A pure client would set this to 1.  A pure server would set it to the number of allowed clients.
 	// - A hybrid would set it to the sum of both types of connections
 	// localPort: The port to listen for connections on.
-	// _threadPriority: 0 for regular priority (0-8 players), 1 for high priority (High performance applications), and 2 for ultra-high priority (MMO server)
+	// _threadSleepTimer: &lt;0 for single threaded, &gt;=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	//
 	// Returns:
 	// False on failure (can't create socket or thread), true on success.
-	virtual bool Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadPriority)=0;
+	virtual bool Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadSleepTimer)=0;
 
 	// Description:
 	// Must be called while offline
@@ -52,15 +53,13 @@
 	// If you accept connections, you must call this or else secure connections will not be enabled
 	// for incoming connections.
 	// If you are connecting to another system, you can call this with values for the
-	// (e and n) public keys before connecting to prevent MitM
+	// (e and p,q) public keys before connecting to prevent MitM
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.
-	// RSAd - A pointer to the private key of length numberOfBytes.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
-	virtual void InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn)=0;
+	// pubKeyP, pubKeyQ - Public keys generated from the RSACrypt class.  See the Encryption sample
+	// privKeyE, privKeyN - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+	// If the private keys are 0, then a new key will be generated when this function is called
+	virtual void InitializeSecurity(char *pubKeyP, char *pubKeyQ, char *privKeyE, char *privKeyN)=0;
 
 	// Description
 	// Must be called while offline
@@ -92,13 +91,13 @@
 
 	// Description:
 	// Returns the password set by SetIncomingPassword in a BitStream
-	BitStream *GetIncomingPassword(void);
+	RakNet::BitStream *GetIncomingPassword(void);
 
 	// Description:
 	// Call this to connect to the specified host (ip or domain name) and server port.
 	// Calling Connect and not calling SetMaximumIncomingConnections acts as a dedicated client.  Calling both acts as a true peer.
 	// This is a non-blocking connection.  You know the connection is successful when IsConnected() returns true
-	// or receive gets a packet with the type identifier ID_ENUMERATION_REPLY.  If the connection is not
+	// or receive gets a packet with the type identifier ID_CONNECTION_ACCEPTED.  If the connection is not
 	// successful, such as rejected connection or no response then neither of these things will happen.
 	// Requires that you first call Initialize
 	//
@@ -114,7 +113,11 @@
 
 	// Description:
 	// Stops the network threads and close all connections.  Multiple calls are ok.
-	virtual void Disconnect(void)=0;
+	//
+	// Parameters:
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	virtual void Disconnect(unsigned long blockDuration)=0;
 
 	// Description:
 	// Returns true if the network threads are running
@@ -138,14 +141,14 @@
 	// bitStream: The bitstream to send
 	// priority: What priority level to send on.
 	// reliability: How reliability to send this data
-	// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+	// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 	// - Packets are only ordered relative to other packets on the same stream
 	// playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 	// broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 	// Returns:
 	// False if we are not connected to the specified recipient.  True otherwise
-	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)=0;
-	virtual bool Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)=0;
+	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)=0;
+	virtual bool Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)=0;
 
 	// Description:
 	// Gets a packet from the incoming packet queue. Use DeallocatePacket to deallocate the packet after you are done with it.
@@ -200,13 +203,13 @@
 	// bitStream: The bitstream to send
 	// priority: What priority level to send on.
 	// reliability: How reliability to send this data
-	// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+	// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 	// broadcast - Send this packet to everyone.
 	// playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 	// broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 	// shiftTimestamp: True to treat the first 4 bytes as a timestamp and make it system relative on arrival (Same as ID_TIMESTAMP for a packet enumeration type)
-	virtual bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
-	virtual bool RPC(char* uniqueID, BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
 
 	// --------------------------------------------------------------------------------------------
 	// Player Management Functions
@@ -217,7 +220,9 @@
 	// Parameters:
 	// target: Which connection to close
 	// sendDisconnectionNotification: True to send ID_DISCONNECTION_NOTIFICATION to the recipient.  False to close it silently.
-	virtual void CloseConnection(PlayerID target, bool sendDisconnectionNotification)=0;
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	virtual void CloseConnection(PlayerID target, bool sendDisconnectionNotification, unsigned long blockDuration)=0;
 
 	// Description:
 	// Given a playerID, returns an index from 0 to the maximum number of players allowed - 1.
@@ -290,9 +295,10 @@
 	// The sender and recipient must already be started via a successful call to Initialize
 	//
 	// Parameters:
-	// host: Either a dotted IP address or a domain name
+	// host: Either a dotted IP address or a domain name.  Can be 255.255.255.255 for LAN broadcast.
 	// remotePort: Which port to connect to on the remote machine.
-	virtual void Ping(char* host, unsigned short remotePort)=0;
+	// onlyReplyOnAcceptingConnections: Only request a reply if the remote system is accepting connections
+	virtual void Ping(char* host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections)=0;
 
 	// Description:
 	// Returns the average of all ping times read for a specified target
@@ -316,7 +322,7 @@
 	virtual int GetLowestPing(PlayerID target) const=0;
 
 	// Description:
-	// Ping the remote systems every so often.  This is on by default
+	// Ping the remote systems every so often.  This is off by default
 	// This will work anytime
 	//
 	// Parameters:
@@ -375,7 +381,7 @@
 	//
 	// Returns:
 	// The data passed to SetRemoteStaticData stored as a bitstream
-	virtual BitStream* GetRemoteStaticData(PlayerID playerId)=0;
+	virtual RakNet::BitStream * GetRemoteStaticData(PlayerID playerId)=0;
 
 	// Description:
 	// All systems have a block of data associated with them, for user use.  This block of data can be used to easily
@@ -396,6 +402,13 @@
 	// target: Who to send your static data to.  Specify UNASSIGNED_PLAYER_ID to broadcast to all
 	virtual void SendStaticData(PlayerID target)=0;
 
+	// Description:
+	// Sets the data to send with an  (LAN server discovery) /(offline ping) response
+	// See the Ping sample project for how this is used.
+	// data: a block of data to store, or 0 for none
+	// length: The length of data in bytes, or 0 for none
+	virtual void SetOfflinePingResponse(char *data, const unsigned long length)=0;
+
 	// --------------------------------------------------------------------------------------------
 	// Network Functions - Functions dealing with the network in general
 	// --------------------------------------------------------------------------------------------
@@ -456,9 +469,34 @@
 	virtual const char* PlayerIDToDottedIP(PlayerID playerId) const=0;
 
 	// Description:
+	// Converts a dotted IP to a playerId
+	//
+	// Parameters:
+	// host: [input] Either a dotted IP address or a domain name
+	// remotePort: [input] Which port to connect to on the remote machine.
+	// playerId: [output] The result of this operation
+	virtual void IPToPlayerID(const char* host, unsigned short remotePort, PlayerID *playerId)=0;
+
+	// Description:
 	// Returns an IP address at index 0 to GetNumberOfAddresses-1
 	virtual const char* GetLocalIP(unsigned int index)=0;
 
+	// Description:
+	// Allow or disallow connection responses from any IP.  Normally this should be false, but may be necessary
+	// when connection to servers with multiple IP addresses.
+	//
+	// Parameters:
+	// allow - True to allow this behavior, false to not allow.  Defaults to false.  Value persists between connections
+	void AllowConnectionResponseIPMigration(bool allow);
+
+	// Description:
+	// Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system.
+	// This will tell the remote system our external IP outside the LAN, and can be used for NAT punch through
+	//
+	// host: Either a dotted IP address or a domain name
+	// remotePort: Which port to connect to on the remote machine.
+	virtual void AdvertiseSystem(char *host, unsigned short remotePort)=0;
+
 	// --------------------------------------------------------------------------------------------
 	// Compression Functions - Functions related to the compression layer
 	// --------------------------------------------------------------------------------------------
@@ -547,20 +585,16 @@
 	// Statistical Functions - Functions dealing with API performance
 	// --------------------------------------------------------------------------------------------
 
-	// Network statistics.
-	virtual double GetPacketlossPercentile(void) const=0; // The average outgoing packetloss percentile
-	virtual unsigned long GetTransmittedPacketCount(void) const=0; // How many packets were sent
-	virtual unsigned long GetTransmittedFrameCount(void) const=0; // How many frames were sent	
-	virtual unsigned long GetLostPacketCount(void) const=0; // How many packets were lost
-	virtual unsigned long GetReceivedPacketCount(void) const=0; // How many packets were received
-	virtual unsigned long GetBytesSent(void) const=0; // How many bytes have been sent.
-	virtual unsigned long GetBytesReceived(void) const=0; // How many bytes have been received.
-	virtual unsigned long GetUnacknowledgedSentPacketListSize(void) const=0; // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	virtual unsigned long GetBytesSentPerSecond(void) const=0;  // How many bytes were sent in the last histogram block.
-	virtual unsigned long GetBytesReceivedPerSecond(void) const=0; // How many bytes were received in the last histogram block.
-	virtual unsigned long GetMaximumWindowSize(void) const=0; // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	virtual unsigned long GetPacketOutputBufferSize(void) const=0; // Returns the number of waiting packets on the send queue
-	virtual unsigned long GetConnectionTime(PlayerID playerId) const=0; // Returns the time elapsed since this player connected
+	// Description:
+	// Returns a structure containing a large set of network statistics for the specified system
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Parameters
+	// playerId: Which connected system to get statistics for
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	virtual RakNetStatisticsStruct * const GetStatistics(PlayerID playerId)=0;
 };
 
 #endif

Modified: trunk/source/libraries/raknet/RakServer.cpp
===================================================================
--- trunk/source/libraries/raknet/RakServer.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakServer.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -28,9 +28,9 @@
 {
 }
 
-void RakServer::InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn)
+void RakServer::InitializeSecurity(char *privKeyE, char *privKeyN)
 {
-	RakPeer::InitializeSecurity(numberOfBytes, RSAd, RSAe, RSAn);
+	RakPeer::InitializeSecurity(0,0, privKeyE, privKeyN);
 }
 
 void RakServer::DisableSecurity(void)
@@ -38,19 +38,17 @@
 	RakPeer::DisableSecurity();
 }
 
-bool RakServer::Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, bool highPriorityThreads, unsigned short port)
+bool RakServer::Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, int threadSleepTimer, unsigned short port)
 {
 	bool init;
 
-	if (highPriorityThreads)
-		init=RakPeer::Initialize(AllowedPlayers, port,1);
-	else
-		init=RakPeer::Initialize(AllowedPlayers, port,0);
+	RakPeer::Disconnect(30L);
 
+	init=RakPeer::Initialize(AllowedPlayers, port,threadSleepTimer);
 	RakPeer::SetMaximumIncomingConnections(AllowedPlayers);
 
 	// Random number seed
-	long time = getTime();
+	long time = RakNetGetTime();
 	seedMT(time);
 	seed=randomMT();
 	if (seed % 2 == 0) // Even
@@ -64,8 +62,15 @@
 
 void RakServer::SetPassword(char *_password)
 {
-	_password[19]=0; // Limit the password length
-	RakPeer::SetIncomingPassword(_password, (int)strlen(_password)+1);
+	if (_password)
+	{
+		_password[19]=0; // Limit the password length
+		RakPeer::SetIncomingPassword(_password, (int)strlen(_password)+1);
+	}
+	else
+	{
+		RakPeer::SetIncomingPassword(0, 0);
+	}
 }
 
 bool RakServer::HasPassword(void)
@@ -73,19 +78,19 @@
 	return GetIncomingPassword()-&gt;GetNumberOfBytesUsed() &gt; 0;
 }
 
-void RakServer::Disconnect(void)
+void RakServer::Disconnect(unsigned long blockDuration)
 {
-	RakPeer::Disconnect();
+	RakPeer::Disconnect(blockDuration);
 }
 
-bool RakServer::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)
+bool RakServer::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)
 {
-	return RakPeer::Send(data, length, priority, reliability, orderingStream, playerId, broadcast);
+	return RakPeer::Send(data, length, priority, reliability, orderingChannel, playerId, broadcast);
 }
 
-bool RakServer::Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)
+bool RakServer::Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)
 {
-	return RakPeer::Send(bitStream, priority, reliability, orderingStream, playerId, broadcast);
+	return RakPeer::Send(bitStream, priority, reliability, orderingChannel, playerId, broadcast);
 }
 
 Packet* RakServer::Receive(void)
@@ -95,7 +100,7 @@
 	// This is just a regular time based update.  Nowhere else good to put it
 	if (RakPeer::IsActive() &amp;&amp; occasionalPing)
 	{
-		unsigned long time = getTime();
+		unsigned long time = RakNetGetTime();
 		if (time &gt; broadcastPingsTime || (packet &amp;&amp; packet-&gt;data[0]==ID_RECEIVED_STATIC_DATA))
 		{
 			if (time &gt; broadcastPingsTime)
@@ -103,7 +108,7 @@
 
 			unsigned i, count;
 			RemoteSystemStruct *remoteSystem;
-			BitStream bitStream((sizeof(PlayerID) + sizeof(short)) * 32 + sizeof(unsigned char));
+			RakNet::BitStream bitStream((sizeof(PlayerID) + sizeof(short)) * 32 + sizeof(unsigned char));
 			unsigned char typeId=ID_BROADCAST_PINGS;
 			bitStream.Write(typeId);
 			for (i=0, count=0; count &lt; 32 &amp;&amp; i &lt; maximumNumberOfPeers; i++)
@@ -121,9 +126,9 @@
 			if (count&gt;0) // If we wrote anything
 			{
 				if (packet &amp;&amp; packet-&gt;data[0]==ID_NEW_INCOMING_CONNECTION) // If this was a new connection
-					Send(&amp;bitStream, HIGH_PRIORITY, RELIABLE, 0, packet-&gt;playerId, false); // Send to the new connection
+					Send(&amp;bitStream, SYSTEM_PRIORITY, RELIABLE, 0, packet-&gt;playerId, false); // Send to the new connection
 				else
-					Send(&amp;bitStream, HIGH_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true); // Send to everyone
+					Send(&amp;bitStream, SYSTEM_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true); // Send to everyone
 			}
 		}
 	}
@@ -131,7 +136,7 @@
 	// This is just a regular time based update.  Nowhere else good to put it
 	if (RakPeer::IsActive() &amp;&amp; synchronizedRandomInteger)
 	{
-		unsigned long time = getTime();
+		unsigned long time = RakNetGetTime();
 		if (time &gt; nextSeedUpdate || (packet &amp;&amp; packet-&gt;data[0]==ID_NEW_INCOMING_CONNECTION))
 		{
 			if (time &gt; nextSeedUpdate)
@@ -144,39 +149,39 @@
 
 			SetRandomNumberSeedStruct s;
 			s.ts=ID_TIMESTAMP;
-			s.timeStamp=getTime();
+			s.timeStamp=RakNetGetTime();
 			s.typeId=ID_SET_RANDOM_NUMBER_SEED;
 			s.seed=seed;
 			s.nextSeed=nextSeed;
 
 			if (packet &amp;&amp; packet-&gt;data[0]==ID_NEW_INCOMING_CONNECTION)
-				Send((char*)&amp;s, sizeof(SetRandomNumberSeedStruct),  HIGH_PRIORITY, RELIABLE, 0, packet-&gt;playerId, false);
+				Send((char*)&amp;s, sizeof(SetRandomNumberSeedStruct),  SYSTEM_PRIORITY, RELIABLE, 0, packet-&gt;playerId, false);
 			else
-				Send((char*)&amp;s, sizeof(SetRandomNumberSeedStruct),  HIGH_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true);
+				Send((char*)&amp;s, sizeof(SetRandomNumberSeedStruct),  SYSTEM_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true);
 		}
 	}
 
 	if (packet)
-	{
+	{			
 		// Intercept specific client / server feature packets.  This will do an extra send and still pass on the data to the user
-		if (packet-&gt;data[0]==ID_RECEIVED_STATIC_DATA)
+		if (packet-&gt;data[0]==ID_REMOTE_STATIC_DATA)
 		{
 			if (relayStaticClientData)
 			{
 				// Relay static data to the other systems but the sender
-				BitStream bitStream(packet-&gt;length + sizeof(PlayerID));
-				unsigned char typeId=ID_RECEIVED_RELAYED_STATIC_DATA;
+				RakNet::BitStream bitStream(packet-&gt;length + sizeof(PlayerID));
+				unsigned char typeId=ID_REMOTE_STATIC_DATA;
 				bitStream.Write(typeId);
 				bitStream.Write(packet-&gt;playerId.binaryAddress);
 				bitStream.Write(packet-&gt;playerId.port);
-				bitStream.Write(packet-&gt;data+sizeof(unsigned char), packet-&gt;length-sizeof(unsigned char));
-				Send(&amp;bitStream, HIGH_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true);
+				bitStream.Write((char*)packet-&gt;data+sizeof(unsigned char), packet-&gt;length-sizeof(unsigned char));
+				Send(&amp;bitStream, SYSTEM_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true);
 			}			
 		}
 		else if (packet-&gt;data[0]==ID_DISCONNECTION_NOTIFICATION || packet-&gt;data[0]==ID_CONNECTION_LOST || packet-&gt;data[0]==ID_NEW_INCOMING_CONNECTION)
 		{
 			// Relay the disconnection
-			BitStream bitStream(packet-&gt;length + sizeof(PlayerID));
+			RakNet::BitStream bitStream(packet-&gt;length + sizeof(PlayerID));
 			unsigned char typeId;
 			if (packet-&gt;data[0]==ID_DISCONNECTION_NOTIFICATION)
 				typeId=ID_REMOTE_DISCONNECTION_NOTIFICATION;
@@ -187,7 +192,8 @@
 			bitStream.Write(typeId);
 			bitStream.Write(packet-&gt;playerId.binaryAddress);
 			bitStream.Write(packet-&gt;playerId.port);
-			Send(&amp;bitStream, HIGH_PRIORITY, RELIABLE, 0, packet-&gt;playerId, true);
+			bitStream.Write((unsigned short&amp;)packet-&gt;playerIndex);
+			Send(&amp;bitStream, SYSTEM_PRIORITY, RELIABLE, 0, packet-&gt;playerId, true);
 
 			if (packet-&gt;data[0]==ID_NEW_INCOMING_CONNECTION)
 			{
@@ -201,19 +207,20 @@
 						bitStream.Write(typeId);
 						bitStream.Write(remoteSystemList[i].playerId.binaryAddress);
 						bitStream.Write(remoteSystemList[i].playerId.port);
+						bitStream.Write((unsigned short)i);
 						// One send to tell them of the connection
-						Send(&amp;bitStream, HIGH_PRIORITY, RELIABLE, 0, packet-&gt;playerId, false);
+						Send(&amp;bitStream, SYSTEM_PRIORITY, RELIABLE, 0, packet-&gt;playerId, false);
 
 						if (relayStaticClientData)
 						{
 							bitStream.Reset();
-							typeId=ID_RECEIVED_RELAYED_STATIC_DATA;
+							typeId=ID_REMOTE_STATIC_DATA;
 							bitStream.Write(typeId);
 							bitStream.Write(remoteSystemList[i].playerId.binaryAddress);
 							bitStream.Write(remoteSystemList[i].playerId.port);
 							bitStream.Write((char*)remoteSystemList[i].staticData.GetData(), remoteSystemList[i].staticData.GetNumberOfBytesUsed());
 							// Another send to tell them of the static data
-							Send(&amp;bitStream, HIGH_PRIORITY, RELIABLE, 0, packet-&gt;playerId, false);
+							Send(&amp;bitStream, SYSTEM_PRIORITY, RELIABLE, 0, packet-&gt;playerId, false);
 						}
 					}
 				}
@@ -226,7 +233,7 @@
 
 void RakServer::Kick(PlayerID playerId)
 {
-	RakPeer::CloseConnection(playerId, true);
+	RakPeer::CloseConnection(playerId, true, 0L);
 }
 
 void RakServer::DeallocatePacket(Packet *packet)
@@ -346,14 +353,14 @@
 	RakPeer::UnregisterAsRemoteProcedureCall(uniqueID);
 }
 
-bool RakServer::RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)
+bool RakServer::RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)
 {
-		return RakPeer::RPC(uniqueID, data, bitLength, priority, reliability, orderingStream, playerId, broadcast, shiftTimestamp);
+		return RakPeer::RPC(uniqueID, data, bitLength, priority, reliability, orderingChannel, playerId, broadcast, shiftTimestamp);
 }
 
-bool RakServer::RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)
+bool RakServer::RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)
 {
-	return RakPeer::RPC(uniqueID, parameters, priority, reliability, orderingStream, playerId, broadcast, shiftTimestamp);
+	return RakPeer::RPC(uniqueID, parameters, priority, reliability, orderingChannel, playerId, broadcast, shiftTimestamp);
 }
 
 /*
@@ -382,7 +389,7 @@
 	return RakPeer::GetDecompressionRatio();
 }
 
-BitStream* RakServer::GetStaticServerData(void)
+RakNet::BitStream * RakServer::GetStaticServerData(void)
 {
 	return RakPeer::GetRemoteStaticData(myPlayerId);
 }
@@ -402,8 +409,13 @@
 	RakPeer::SendStaticData(playerId);
 }
 
-BitStream* RakServer::GetStaticClientData(PlayerID playerId)
+void RakServer::SetOfflinePingResponse(char *data, const unsigned long length)
 {
+	RakPeer::SetOfflinePingResponse(data,length);
+}
+
+RakNet::BitStream * RakServer::GetStaticClientData(PlayerID playerId)
+{
 	return RakPeer::GetRemoteStaticData(playerId);
 }
 
@@ -420,13 +432,13 @@
 		return; // No such playerChangedId
 
     // Relay static data to the other systems but the sender
-	BitStream bitStream(remoteSystem-&gt;staticData.GetNumberOfBytesUsed() + sizeof(PlayerID) + sizeof(unsigned char));
-	unsigned char typeId=ID_RECEIVED_RELAYED_STATIC_DATA;
+	RakNet::BitStream bitStream(remoteSystem-&gt;staticData.GetNumberOfBytesUsed() + sizeof(PlayerID) + sizeof(unsigned char));
+	unsigned char typeId=ID_REMOTE_STATIC_DATA;
 	bitStream.Write(typeId);
 	bitStream.Write(playerChangedId.binaryAddress);
 	bitStream.Write(playerChangedId.port);
 	bitStream.Write((char*)remoteSystem-&gt;staticData.GetData(), remoteSystem-&gt;staticData.GetNumberOfBytesUsed());
-	Send(&amp;bitStream, HIGH_PRIORITY, RELIABLE, 0, playerToSendToId, true);
+	Send(&amp;bitStream, SYSTEM_PRIORITY, RELIABLE, 0, playerToSendToId, true);
 }
 
 unsigned int RakServer::GetNumberOfAddresses(void)
@@ -489,68 +501,12 @@
 	return RakPeer::GetMTUSize();
 }
 
-double RakServer::GetPacketlossPercentile(void)
+void RakServer::AdvertiseSystem(char *host, unsigned short remotePort)
 {
-	return RakPeer::GetPacketlossPercentile();
+	RakPeer::AdvertiseSystem(host, remotePort);
 }
-	
-unsigned long RakServer::GetTransmittedPacketCount(void)
-{
-	return RakPeer::GetTransmittedPacketCount();
-}
 
-unsigned long RakServer::GetTransmittedFrameCount(void)
+RakNetStatisticsStruct * const RakServer::GetStatistics(PlayerID playerId)
 {
-	return RakPeer::GetTransmittedFrameCount();
+	return RakPeer::GetStatistics(playerId);
 }
-
-unsigned long RakServer::GetLostPacketCount(void)
-{
-	return RakPeer::GetLostPacketCount();
-}
-
-unsigned long RakServer::GetReceivedPacketCount(void)
-{
-	return RakPeer::GetReceivedPacketCount();
-}
-
-unsigned long RakServer::GetBytesSent(void)
-{
-	return RakPeer::GetBytesSent();
-}
-
-unsigned long RakServer::GetBytesReceived(void)
-{
-	return RakPeer::GetBytesReceived();
-}
-
-unsigned long RakServer::GetUnacknowledgedSentPacketListSize(void)
-{
-	return RakPeer::GetUnacknowledgedSentPacketListSize();
-}
-
-unsigned long RakServer::GetBytesSentPerSecond(void) const
-{
-	return RakPeer::GetBytesSentPerSecond();
-}
-
-unsigned long RakServer::GetBytesReceivedPerSecond(void) const
-{
-	return RakPeer::GetBytesReceivedPerSecond();
-}
-
-unsigned long RakServer::GetMaximumWindowSize(void)
-{
-	return RakPeer::GetMaximumWindowSize();
-}
-
-unsigned long RakServer::GetPacketOutputBufferSize(void)
-{
-	return RakPeer::GetPacketOutputBufferSize();
-}
-
-unsigned long RakServer::GetConnectionTime(PlayerID playerId)
-{
-	return RakPeer::GetConnectionTime(playerId);
-}
-

Modified: trunk/source/libraries/raknet/RakServer.h
===================================================================
--- trunk/source/libraries/raknet/RakServer.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakServer.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -25,12 +25,11 @@
 	// Call this to initiate the server with the number of players you want to be allowed connected at once
 	// Current maximum number of allowed players is 65535
 	// connectionValidationInteger is for legacy purposes and is unused
-	// Set highPriorityThreads to true for a real-time responsive server.  Set it to false
-	// for games where high pings don't matter, or if the network engine slows down the game too much
+	// _threadSleepTimer: &lt;0 for single threaded, &gt;=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	// Port is the port you want the server to read and write on
 	// Make sure this port is open for UDP
 	// Returns true on successful initiation, false otherwise
-	bool Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, bool highPriorityThreads, unsigned short port);
+	bool Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, int threadSleepTimer, unsigned short port);
 
 	// Description:
 	// Must be called while offline
@@ -43,12 +42,9 @@
 	// for incoming connections.
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAd - A pointer to the private key of length numberOfBytes.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
-	void InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn);
+	// privateKeyE, privateKeyN - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+	// If the private keys are 0, then a new key will be generated when this function is called
+	void InitializeSecurity(char *privateKeyE, char *privateKeyN);
 
 	// Description
 	// Must be called while offline
@@ -67,24 +63,28 @@
 	// since the server is stopped packet reliability is not enforced so the Kick network message may not actually
 	// arrive.  Those players will disconnect due to timeout. If you want to end the server more gracefully, you
 	// can manually Kick each player first. Does nothing if the server is not running to begin with
-	void Disconnect(void);
+	//
+	// Parameters:
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notifications probably won't arrive
+	void Disconnect(unsigned long blockDuration);
 
 	// This function only works while the server is active (Use the Start function).  Returns false on failure, true on success
 	// Send the data stream of length length to whichever playerId you specify.  Specify UNASSIGNED_PLAYER_ID for all players connected
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY, RELIABLE, 0 for ordering stream
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY, RELIABLE, 0 for ordering channel
 	// Set broadcast to true to broadcast to all connected clients EXCEPT the one specified in the playerId field.
 	// To broadcast to everyone specify UNASSIGNED_PLAYER_ID for the playerId field.
-	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast);
+	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast);
 
 	// This function only works while the server is active (Use the Start function).  Returns false on failure, true on success
 	// Send the bitstream to whichever playerId you specify.
 	// You can set the first byte to a packet identifier, however you will need to have TYPE_CHECKING undefined or the internal type checking
 	// will add extra data and make this not work.  If you want TYPE_CHECKING on, you will need to use BitStream::WriteBits to avoid the type checking.
 	// This interface will probably change to fix this in future versions.
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
 	// Set broadcast to true to broadcast to all connected clients EXCEPT the one specified in the playerId field.
 	// To broadcast to everyone specify UNASSIGNED_PLAYER_ID for the playerId field.
-	bool Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast);
+	bool Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast);
 
 	// Call this to get a packet from the incoming packet queue.  Use DeallocatePacket to deallocate the packet after you are done with it.
 	// Check the Packet struct at the top of CoreNetworkStructures.h for the format of the struct
@@ -222,8 +222,8 @@
 	// If you want that function to return data you should call RPC from that system in the same way
 	// Returns true on a successful packet send (this does not indicate the recipient performed the call), false on failure
 	// The uniqueID must be composed of a string with only characters from a-z and is not case sensitive
-	bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp);
-	bool RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp);
+	bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp);
+	bool RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp);
 
 	// Handles an RPC packet.  If you get a packet with the ID ID_RPC you should pass it to this function
 	// This is already done in Multiplayer.cpp, so if you use the Multiplayer class it is handled for you.
@@ -260,7 +260,7 @@
 	// The data is entered as an array and stored and returned as a BitStream.
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
-	BitStream* GetStaticServerData(void);
+	RakNet::BitStream * GetStaticServerData(void);
 	void SetStaticServerData(char *data, const long length);
 
 	// This sets to true or false whether we want to support relaying of static client data to other connected clients.
@@ -278,6 +278,13 @@
 	// The server must be active for this to have meaning
 	void SendStaticServerDataToClient(PlayerID playerId);
 
+	// Description:
+	// Sets the data to send with an (LAN server discovery) /(offline ping) response
+	// See the Ping sample project for how this is used.
+	// data: a block of data to store, or 0 for none
+	// length: The length of data in bytes, or 0 for none
+	void SetOfflinePingResponse(char *data, const unsigned long length);
+
 	// Returns a pointer to an attached client's character name specified by the playerId
 	// Returns 0 if no such player is connected
 	// Note that you can modify the client data here.  Changes won't be reflected on clients unless you force them to
@@ -286,12 +293,12 @@
 	// The data is entered as an array and stored and returned as a BitStream.  
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...-&gt;GetStaticServerData(...);
+	// RakNet::BitStream *copy = ...-&gt;GetStaticServerData(...);
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
 	// Note that the client may change at any time the
 	// data contents and/or its length!
-	BitStream* GetStaticClientData(PlayerID playerId);
+	RakNet::BitStream * GetStaticClientData(PlayerID playerId);
 	void SetStaticClientData(PlayerID playerId, char *data, const long length);
 
 	// This function is used to update the information on connected clients when the server effects a change
@@ -382,21 +389,25 @@
 	// Returns the current MTU size
 	int GetMTUSize(void) const;
 
-	// Network statistics.
-	double GetPacketlossPercentile(void); // The average outgoing packetloss percentile among all connected clients
-	unsigned long GetTransmittedPacketCount(void); // How many packets were sent among all connected clients
-	unsigned long GetTransmittedFrameCount(void); // How many frames were sent	
-	unsigned long GetLostPacketCount(void); // How many packets were lost among all connected clients
-	unsigned long GetReceivedPacketCount(void); // How many packets were received among all connected clients
-	unsigned long GetBytesSent(void); // How many bytes have been sent among all connected clients.
-	unsigned long GetBytesReceived(void); // How many bytes have been received among all connected clients.
-	unsigned long GetUnacknowledgedSentPacketListSize(void); // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	unsigned long GetBytesSentPerSecond(void) const;  // How many bytes were sent in the last histogram block.
-	unsigned long GetBytesReceivedPerSecond(void) const; // How many bytes were received in the last histogram block.
-	unsigned long GetMaximumWindowSize(void); // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	unsigned long GetPacketOutputBufferSize(void); // Returns the number of waiting packets on the send queue
-	unsigned long GetConnectionTime(PlayerID playerId); // Returns when this client connected or 0 if not connected
+	// Description:
+	// Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system.
+	// This will tell the remote system our external IP outside the LAN, and can be used for NAT punch through
+	//
+	// host: Either a dotted IP address or a domain name
+	// remotePort: Which port to connect to on the remote machine.
+	void AdvertiseSystem(char *host, unsigned short remotePort);
 
+	// Description:
+	// Returns a structure containing a large set of network statistics for the specified system
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Parameters
+	// playerId: Which connected system to get statistics for
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	RakNetStatisticsStruct * const GetStatistics(PlayerID playerId);
+
 	private:
 
 	// Synchronized random integer

Modified: trunk/source/libraries/raknet/RakServerInterface.h
===================================================================
--- trunk/source/libraries/raknet/RakServerInterface.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakServerInterface.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -13,7 +13,8 @@
 #include &quot;NetworkTypes.h&quot;
 #include &quot;PacketPriority.h&quot;
 #include &quot;RakPeerInterface.h&quot;
-class BitStream;
+#include &quot;BitStream.h&quot;
+#include &quot;RakNetStatistics.h&quot;
 
 class RakServerInterface
 {
@@ -24,12 +25,11 @@
 	// Call this to initiate the server with the number of players you want to be allowed connected at once
 	// Current maximum number of allowed players is 65535
 	// connectionValidationInteger is for legacy purposes and is unused
-	// Set highPriorityThreads to true for a real-time responsive server.  Set it to false
-	// for games where high pings don't matter, or if the network engine slows down the game too much
+	// _threadSleepTimer: &lt;0 for single threaded, &gt;=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	// Port is the port you want the server to read and write on
 	// Make sure this port is open for UDP
 	// Returns true on successful initiation, false otherwise
-	virtual bool Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, bool highPriorityThreads, unsigned short port)=0;
+	virtual bool Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, int threadSleepTimer, unsigned short port)=0;
 
 	// Description:
 	// Must be called while offline
@@ -42,12 +42,9 @@
 	// for incoming connections.
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAd - A pointer to the private key of length numberOfBytes.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
-	virtual void InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn)=0;
+	// privKeyE, privKeyN - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+	// If the private keys are 0, then a new key will be generated when this function is called
+	virtual void InitializeSecurity(char *privKeyE, char *privKeyN)=0;
 
 	// Description
 	// Must be called while offline
@@ -66,24 +63,28 @@
 	// since the server is stopped packet reliability is not enforced so the Kick network message may not actually
 	// arrive.  Those players will disconnect due to timeout. If you want to end the server more gracefully, you
 	// can manually Kick each player first. Does nothing if the server is not running to begin with
-	virtual void Disconnect(void)=0;
+	//
+	// Parameters:
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notifications probably won't arrive
+	virtual void Disconnect(unsigned long blockDuration)=0;
 
 	// This function only works while the server is active (Use the Start function).  Returns false on failure, true on success
 	// Send the data stream of length length to whichever playerId you specify.  Specify UNASSIGNED_PLAYER_ID for all players connected
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY, RELIABLE, 0 for ordering stream
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY, RELIABLE, 0 for ordering channel
 	// Set broadcast to true to broadcast to all connected clients EXCEPT the one specified in the playerId field.
 	// To broadcast to everyone specify UNASSIGNED_PLAYER_ID for the playerId field.
-	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)=0;
+	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)=0;
 
 	// This function only works while the server is active (Use the Start function).  Returns false on failure, true on success
 	// Send the bitstream to whichever playerId you specify.
 	// You can set the first byte to a packet identifier, however you will need to have TYPE_CHECKING undefined or the internal type checking
 	// will add extra data and make this not work.  If you want TYPE_CHECKING on, you will need to use BitStream::WriteBits to avoid the type checking.
 	// This interface will probably change to fix this in future versions.
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
 	// Set broadcast to true to broadcast to all connected clients EXCEPT the one specified in the playerId field.
 	// To broadcast to everyone specify UNASSIGNED_PLAYER_ID for the playerId field.
-	virtual bool Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)=0;
+	virtual bool Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)=0;
 
 	// Call this to get a packet from the incoming packet queue.  Use DeallocatePacket to deallocate the packet after you are done with it.
 	// Check the Packet struct at the top of CoreNetworkStructures.h for the format of the struct
@@ -221,8 +222,8 @@
 	// If you want that function to return data you should call RPC from that system in the same way
 	// Returns true on a successful packet send (this does not indicate the recipient performed the call), false on failure
 	// The uniqueID must be composed of a string with only characters from a-z and is not case sensitive
-	virtual bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
-	virtual bool RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
 
 	// OBSOLETE - DONE AUTOMATICALLY
 	// Handles an RPC packet.  If you get a packet with the ID ID_RPC you should pass it to this function
@@ -260,7 +261,7 @@
 	// The data is entered as an array and stored and returned as a BitStream.
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
-	virtual BitStream* GetStaticServerData(void)=0;
+	virtual RakNet::BitStream * GetStaticServerData(void)=0;
 	virtual void SetStaticServerData(char *data, const long length)=0;
 
 	// This sets to true or false whether we want to support relaying of static client data to other connected clients.
@@ -278,6 +279,13 @@
 	// The server must be active for this to have meaning
 	virtual void SendStaticServerDataToClient(PlayerID playerId)=0;
 
+	// Description:
+	// Sets the data to send with an  (LAN server discovery) /(offline ping) response
+	// See the Ping sample project for how this is used.
+	// data: a block of data to store, or 0 for none
+	// length: The length of data in bytes, or 0 for none
+	virtual void SetOfflinePingResponse(char *data, const unsigned long length)=0;
+
 	// Returns a pointer to an attached client's character name specified by the playerId
 	// Returns 0 if no such player is connected
 	// Note that you can modify the client data here.  Changes won't be reflected on clients unless you force them to
@@ -286,12 +294,12 @@
 	// The data is entered as an array and stored and returned as a BitStream.  
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...-&gt;GetStaticServerData(...)=0;
+	// RakNet::BitStream *copy = ...-&gt;GetStaticServerData(...)=0;
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
 	// Note that the client may change at any time the
 	// data contents and/or its length!
-	virtual BitStream* GetStaticClientData(PlayerID playerId)=0;
+	virtual RakNet::BitStream * GetStaticClientData(PlayerID playerId)=0;
 	virtual void SetStaticClientData(PlayerID playerId, char *data, const long length)=0;
 
 	// This function is used to update the information on connected clients when the server effects a change
@@ -382,20 +390,24 @@
 	// Returns the current MTU size
 	virtual int GetMTUSize(void) const=0;
 
-	// Network statistics.
-	virtual double GetPacketlossPercentile(void)=0; // The average outgoing packetloss percentile among all connected clients
-	virtual unsigned long GetTransmittedPacketCount(void)=0; // How many packets were sent among all connected clients
-	virtual unsigned long GetTransmittedFrameCount(void)=0; // How many frames were sent	
-	virtual unsigned long GetLostPacketCount(void)=0; // How many packets were lost among all connected clients
-	virtual unsigned long GetReceivedPacketCount(void)=0; // How many packets were received among all connected clients
-	virtual unsigned long GetBytesSent(void)=0; // How many bytes have been sent among all connected clients.
-	virtual unsigned long GetBytesReceived(void)=0; // How many bytes have been received among all connected clients.
-	virtual unsigned long GetUnacknowledgedSentPacketListSize(void)=0; // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	virtual unsigned long GetBytesSentPerSecond(void) const=0;  // How many bytes were sent in the last histogram block.
-	virtual unsigned long GetBytesReceivedPerSecond(void) const=0; // How many bytes were received in the last histogram block.
-	virtual unsigned long GetMaximumWindowSize(void)=0; // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	virtual unsigned long GetPacketOutputBufferSize(void)=0; // Returns the number of waiting packets on the send queue
-	virtual unsigned long GetConnectionTime(PlayerID playerId)=0; // Returns when this client connected or 0 if not connected
+	// Description:
+	// Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system.
+	// This will tell the remote system our external IP outside the LAN, and can be used for NAT punch through
+	//
+	// host: Either a dotted IP address or a domain name
+	// remotePort: Which port to connect to on the remote machine.
+	virtual void AdvertiseSystem(char *host, unsigned short remotePort)=0;
+
+	// Description:
+	// Returns a structure containing a large set of network statistics for the specified system
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Parameters
+	// playerId: Which connected system to get statistics for
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	virtual RakNetStatisticsStruct * const GetStatistics(PlayerID playerId)=0;
 };
 
 #endif

Modified: trunk/source/libraries/raknet/ReliabilityLayer.cpp
===================================================================
--- trunk/source/libraries/raknet/ReliabilityLayer.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/ReliabilityLayer.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -11,6 +11,14 @@
 #include &lt;assert.h&gt;
 #include &quot;GetTime.h&quot;
 #include &quot;SocketLayer.h&quot;
+
+// alloca
+#ifdef _WIN32
+#include &lt;malloc.h&gt;
+#else
+#include &lt;stdlib.h&gt;
+#endif
+
 //#include &quot;MemoryManager.h&quot;
 
 // Defined in rand.cpp
@@ -19,9 +27,20 @@
 extern inline float frandomMT(void);
 
 static const int ACK_BIT_LENGTH=sizeof(PacketNumberType)*8+1;
-static const int MAXIMUM_WINDOW_SIZE=(DEFAULT_MTU_SIZE-UDP_HEADER_SIZE)*8/ACK_BIT_LENGTH; // Sanity check - the most ack packets that could ever (usually) fit into a frame
-static const int MINIMUM_WINDOW_SIZE=10; // how many packets can be sent unacknowledged before waiting for an ack
+static const int MAXIMUM_WINDOW_SIZE=(DEFAULT_MTU_SIZE-UDP_HEADER_SIZE)*8/ACK_BIT_LENGTH; // Sanity check - the most ack packets that could ever (usually) fit into a frame.
+static const int MINIMUM_WINDOW_SIZE=5; // how many packets can be sent unacknowledged before waiting for an ack
 
+#ifdef _INTERNET_SIMULATOR
+// Lag
+struct DataAndTime
+{
+	char data[2000];
+	int length;
+	unsigned long sendTime;
+};
+static BasicDataStructures::List&lt;DataAndTime*&gt; delayList;
+#endif
+
 //-------------------------------------------------------------------------------------------------------
 // Constructor
 //-------------------------------------------------------------------------------------------------------
@@ -31,6 +50,7 @@
 	#ifdef __USE_IO_COMPLETION_PORTS
 	readWriteSocket=INVALID_SOCKET;
 	#endif
+	freeThreadedMemoryOnNextUpdate=false;
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -38,7 +58,7 @@
 //-------------------------------------------------------------------------------------------------------
 ReliabilityLayer::~ReliabilityLayer()
 {
-	FreeMemory();
+	FreeMemory(true); // Free all memory immediately
 	#ifdef __USE_IO_COMPLETION_PORTS
 	if (readWriteSocket!=INVALID_SOCKET)
 		closesocket(readWriteSocket);
@@ -50,9 +70,8 @@
 //-------------------------------------------------------------------------------------------------------
 void ReliabilityLayer::Reset(void)
 {
-	FreeMemory();
+	FreeMemory(false); // False because Reset can be called by any thread
 	InitializeVariables();
-	encryptor.UnsetKey();
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -100,10 +119,12 @@
 	memset(waitingForOrderedPacketWriteIndex, 0, NUMBER_OF_ORDERED_STREAMS);
 	memset(waitingForSequencedPacketWriteIndex, 0, NUMBER_OF_ORDERED_STREAMS);
 	memset(receivedPackets, 0, RECEIVED_PACKET_LOG_LENGTH * sizeof(unsigned long));
+	memset(&amp;statistics, 0, sizeof(statistics));
+	statistics.connectionStartTime=RakNetGetTime();
 	splitPacketId=0L;
 	packetNumber=0;
-	lastPacketSendTime=retransmittedPackets=sentPackets=sentFrames=receivedPacketsCount=bytesSent=bytesReceived=0;
-	lostPacketResendDelay=1000L;
+//	lastPacketSendTime=retransmittedFrames=sentPackets=sentFrames=receivedPacketsCount=bytesSent=bytesReceived=0;
+	SetLostPacketResendDelay(1000L);
 	deadConnection=cheater=false;
 	lastAckTime=0;
 	blockWindowIncreaseUntilTime=0;
@@ -111,110 +132,143 @@
 	windowSize=MINIMUM_WINDOW_SIZE;
 	lossyWindowSize=MAXIMUM_WINDOW_SIZE+1; // Infinite
 	lastWindowIncreaseSizeTime=0;
-	lastPacketReceivedTime=0;
+//	lastPacketReceivedTime=0;
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Frees all allocated memory
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::FreeMemory(void)
+void ReliabilityLayer::FreeMemory(bool freeAllImmediately)
 {
-	unsigned i,j;
+	if (freeAllImmediately)
+	{
+		FreeThreadedMemory();
+		FreeThreadSafeMemory();		
+	}
+	else
+	{
+		FreeThreadSafeMemory();
+		freeThreadedMemoryOnNextUpdate=true;
+	}
+	
+}
+void ReliabilityLayer::FreeThreadedMemory(void)
+{
+	unsigned i;
 	InternalPacket *internalPacket;
 
-//	if (bytesSent &gt; 0 || bytesReceived &gt; 0)
-//	{
-		reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
-		for (i=0; i &lt; splitPacketList.size(); i++)
-		{
-			delete [] splitPacketList[i]-&gt;data;
-			InternalPacketPool::Instance()-&gt;ReleasePointer(splitPacketList[i]);
-		}
-		splitPacketList.clear();
-		reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
-//	}
+	//	if (bytesSent &gt; 0 || bytesReceived &gt; 0)
+	//	{
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+	for (i=0; i &lt; splitPacketList.size(); i++)
+	{
+		delete [] splitPacketList[i]-&gt;data;
+		InternalPacketPool::Instance()-&gt;ReleasePointer(splitPacketList[i]);
+	}
+	splitPacketList.clear();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+	//	}
 
-//	if (bytesSent &gt; 0 || bytesReceived &gt; 0)
-//	{
-		reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
-		for (i=0; i &lt; NUMBER_OF_PRIORITIES; i++)
+
+	//	if (bytesSent &gt; 0 || bytesReceived &gt; 0)
+	//	{
+	//reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+	while (outputQueue.size()&gt;0)
+	{
+		internalPacket= outputQueue.pop();
+		delete [] internalPacket-&gt;data;
+		InternalPacketPool::Instance()-&gt;ReleasePointer(internalPacket);
+	}
+	outputQueue.clearAndForceAllocation(512);
+	//reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+	//	}
+
+	//	if (bytesSent &gt; 0 || bytesReceived &gt; 0)
+	//	{
+	//reliabilityLayerMutexes[orderingList_MUTEX].Lock();
+	for (i=0; i &lt; orderingList.size(); i++)
+	{
+		if (orderingList[i])
 		{
-			for (j=0; j &lt; sendQueue[i].size(); j++)
-			{
-				delete [] (sendQueue[i])[j]-&gt;data;
-				InternalPacketPool::Instance()-&gt;ReleasePointer((sendQueue[i])[j]);
-			}
-			sendQueue[i].clearAndForceAllocation(512); // Preallocate the send lists so we don't do a bunch of reallocations unnecessarily
-		}
-		reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
-//	}
+			BasicDataStructures::LinkedList&lt;InternalPacket*&gt;* theList = orderingList[i];
 
-//	if (bytesSent &gt; 0 || bytesReceived &gt; 0)
-//	{
-		reliabilityLayerMutexes[orderingList_MUTEX].Lock();
-		for (i=0; i &lt; orderingList.size(); i++)
-		{
-			if (orderingList[i])
+			if (theList)
 			{
-				BasicDataStructures::LinkedList&lt;InternalPacket*&gt;* theList = orderingList[i];
-
-				if (theList)
+				while (theList-&gt;size())
 				{
-					while (theList-&gt;size())
-					{
-						internalPacket = orderingList[i]-&gt;pop();
-						delete [] internalPacket-&gt;data;
-						InternalPacketPool::Instance()-&gt;ReleasePointer(internalPacket);
-					}
+					internalPacket = orderingList[i]-&gt;pop();
+					delete [] internalPacket-&gt;data;
+					InternalPacketPool::Instance()-&gt;ReleasePointer(internalPacket);
+				}
 
-					delete theList;
-				}
+				delete theList;
 			}
 		}
-		orderingList.clear();
-		reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
-//	}
+	}
+	orderingList.clear();
+	//reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
+	//	}
 
-//	if (bytesSent &gt; 0 || bytesReceived &gt; 0)
-//	{
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
-		while (acknowledgementQueue.size()&gt;0)
-			InternalPacketPool::Instance()-&gt;ReleasePointer(acknowledgementQueue.pop());
-		acknowledgementQueue.clearAndForceAllocation(64);
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
-//	}
+	//	if (bytesSent &gt; 0 || bytesReceived &gt; 0)
+	//	{
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+	while (acknowledgementQueue.size()&gt;0)
+		InternalPacketPool::Instance()-&gt;ReleasePointer(acknowledgementQueue.pop());
+	acknowledgementQueue.clearAndForceAllocation(64);
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+	//	}
 
-//	if (bytesSent &gt; 0 || bytesReceived &gt; 0)
-//	{
-		reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
-		while (outputQueue.size()&gt;0)
+
+	//	if (bytesSent &gt; 0 || bytesReceived &gt; 0)
+	//	{
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+	while (resendQueue.size())
+	{
+		// The resend Queue can have NULL pointer holes.  This is so we can deallocate blocks without having to compress the array
+		internalPacket= resendQueue.pop();
+		if (internalPacket)
 		{
-			internalPacket= outputQueue.pop();
 			delete [] internalPacket-&gt;data;
 			InternalPacketPool::Instance()-&gt;ReleasePointer(internalPacket);
 		}
-		outputQueue.clearAndForceAllocation(512);
-		reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
-//	}
+	}
+	resendQueue.clearAndForceAllocation(512);
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+	//	}
 
+	
+
+}
+void ReliabilityLayer::FreeThreadSafeMemory(void)
+{
+	unsigned i,j;
+//	InternalPacket *internalPacket;
+
 //	if (bytesSent &gt; 0 || bytesReceived &gt; 0)
 //	{
-		reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-		while (resendQueue.size())
+		
+		for (i=0; i &lt; NUMBER_OF_PRIORITIES; i++)
 		{
-			// The resend Queue can have NULL pointer holes.  This is so we can deallocate blocks without having to compress the array
-			internalPacket= resendQueue.pop();
-			if (internalPacket)
+			j=0;
+			reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Lock();
+			for (; j &lt; sendQueue[i].size(); j++)
 			{
-				delete [] internalPacket-&gt;data;
-				InternalPacketPool::Instance()-&gt;ReleasePointer(internalPacket);
+				delete [] (sendQueue[i])[j]-&gt;data;
+				InternalPacketPool::Instance()-&gt;ReleasePointer((sendQueue[i])[j]);
 			}
+			sendQueue[i].clearAndForceAllocation(512); // Preallocate the send lists so we don't do a bunch of reallocations unnecessarily
+			reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Unlock();
 		}
-		resendQueue.clearAndForceAllocation(512);
-		reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+		
 //	}
 
-	InternalPacketPool::Instance()-&gt;ClearPool();
+
+#ifdef _INTERNET_SIMULATOR
+	for (i=0; i &lt; delayList.size(); i++)
+		delete delayList[i];
+	delayList.clear();
+#endif
+
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -238,48 +292,59 @@
 	bool pushedPacket;
 	int count;
 
-	bytesReceived+=length + UDP_HEADER_SIZE;
+//	bytesReceived+=length + UDP_HEADER_SIZE;
+	
+	
 
 	// decode this whole chunk if the decoder is defined.
 	if (encryptor.IsKeySet())
 	{
 		if (encryptor.Decrypt((unsigned char*)buffer, length, (unsigned char*)buffer, &amp;length)==false)
+		{
+			statistics.bitsWithBadCRCReceived+=length*8;
+			statistics.packetsWithBadCRCRecieved++;
 			return false;
+		}
 	}
 
-	BitStream socketData(buffer, length, false); // Convert the incoming data to a bitstream for easy parsing
+	statistics.bitsReceived+=length*8;
+	statistics.packetsReceived++;
 
-	time = lastPacketReceivedTime = getTime();
+	RakNet::BitStream socketData(buffer, length, false); // Convert the incoming data to a bitstream for easy parsing
 
+//	time = lastPacketReceivedTime = RakNetGetTime();
+	time=RakNetGetTime();
+
 	//printf(&quot;In HandleSocketReceiveFromConnectedPlayer %i bytes\n&quot;,length);
 	//for (int ass=0; ass &lt; length &amp;&amp; ass &lt; 10; ass++)
 	//	printf(&quot;%i &quot;, ((char*)(socketData.GetData()))[ass]);
 	//printf(&quot;\n\n&quot;);
 
 	// Parse the bitstream to create an internal packet
-	InternalPacket* internalPacket = CreateInternalPacketFromBitStream(&amp;socketData);
+	InternalPacket* internalPacket = CreateInternalPacketFromBitStream(&amp;socketData,time);
 
-
 	while (internalPacket)
 	{
 		if (internalPacket-&gt;isAcknowledgement)
 		{
+		//	printf(&quot;Got ack at %i\n&quot;, RakNetGetTime());
+
 			numberOfAcksInFrame++;
-			reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 			if (resendQueue.size()==0)
 			{
-				reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();				
-				reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();				
+				//reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
 				lastAckTime=0;  // Not resending anything so clear this var so we don't drop the connection on not getting any more acks
-				reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
+				//reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
 			}
 			else
 			{
-				reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
-				reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
+				//reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
 				lastAckTime=time; // Just got an ack.  Record when we got it so we know the connection is alive
-				reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
+				//reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
 			}
 
 			// SHOW - ack received
@@ -290,11 +355,11 @@
 		}
 		else
 		{
-			receivedPacketsCount++;
+//			receivedPacketsCount++;
 
 			if (internalPacket-&gt;reliability==RELIABLE_SEQUENCED || internalPacket-&gt;reliability==RELIABLE_ORDERED || internalPacket-&gt;reliability==RELIABLE)
 			{
-				SendAcknowledgementPacket(internalPacket-&gt;packetNumber);
+				SendAcknowledgementPacket(internalPacket-&gt;packetNumber, time);
 			}
 
 			// If this packet number was recently used then it has already been received.
@@ -305,6 +370,8 @@
 			// then it must be a different packet
 			if (internalPacket-&gt;packetNumber &gt;= RECEIVED_PACKET_LOG_LENGTH)
 			{
+				statistics.invalidMessagesReceived++;
+
 				delete [] internalPacket-&gt;data;
 				InternalPacketPool::Instance()-&gt;ReleasePointer(internalPacket);
 				#ifdef _DEBUG
@@ -312,36 +379,59 @@
 				#endif
 				return true;
 			}
+
+			// testing
+	//		if (internalPacket-&gt;reliability==UNRELIABLE)
+	//			printf(&quot;Got unreliable packet number %i\n&quot;, internalPacket-&gt;packetNumber);
+	//		else if (internalPacket-&gt;reliability==RELIABLE_SEQUENCED || internalPacket-&gt;reliability==RELIABLE_ORDERED || internalPacket-&gt;reliability==RELIABLE)
+	//			printf(&quot;Got reliable packet number %i\n&quot;, internalPacket-&gt;packetNumber);
+
 			if (receivedPackets[internalPacket-&gt;packetNumber] &gt; time - TIMEOUT_TIME) 
 				// I can receive RECEIVED_PACKET_LOG_LENGTH packets per TIMEOUT_TIME seconds before overrun on timestamps
 			{
 				// SHOW - duplicate packets
-				//printf(&quot;Warning - got duplicate packet (%i).  Did RECEIVED_PACKET_LOG_LENGTH overrun?\n&quot;,internalPacket-&gt;packetNumber);
+#ifdef _DEBUG
+				printf(&quot;Warning - got duplicate packet (%i).  Did RECEIVED_PACKET_LOG_LENGTH overrun?\n&quot;,internalPacket-&gt;packetNumber);
+				// testing
+#endif
 
+				statistics.duplicateMessagesReceived++;
+
 				// Duplicate packet
 				delete [] internalPacket-&gt;data;
 				InternalPacketPool::Instance()-&gt;ReleasePointer(internalPacket);
 				goto CONTINUE_SOCKET_DATA_PARSE_LOOP;
 			}
 
+
+			statistics.messagesReceived++;
+
 			// Record that this particular packet was received at this time
 			receivedPackets[internalPacket-&gt;packetNumber]=time;
 
+			// Keep on top of deleting old unreliable split packets so they don't clog the list.
+			if (internalPacket-&gt;splitPacketCount&gt;0)
+				DeleteOldUnreliableSplitPackets(time);
+
 			if (internalPacket-&gt;reliability==RELIABLE_SEQUENCED || internalPacket-&gt;reliability==UNRELIABLE_SEQUENCED)
 			{
 				#ifdef _DEBUG
-				assert(internalPacket-&gt;orderingStream &lt; NUMBER_OF_ORDERED_STREAMS);
+				assert(internalPacket-&gt;orderingChannel &lt; NUMBER_OF_ORDERED_STREAMS);
 				#endif
-				if (internalPacket-&gt;orderingStream &gt;= NUMBER_OF_ORDERED_STREAMS)
+				if (internalPacket-&gt;orderingChannel &gt;= NUMBER_OF_ORDERED_STREAMS)
 				{
 					// Invalid packet
+#ifdef _DEBUG
+					printf(&quot;Got invalid packet\n&quot;);
+#endif
 					delete [] internalPacket-&gt;data;
 					InternalPacketPool::Instance()-&gt;ReleasePointer(internalPacket);
 					goto CONTINUE_SOCKET_DATA_PARSE_LOOP;
 				}
 
-				if (IsOlderOrderedPacket(internalPacket-&gt;orderingIndex, waitingForSequencedPacketReadIndex[internalPacket-&gt;orderingStream])==false)
+				if (IsOlderOrderedPacket(internalPacket-&gt;orderingIndex, waitingForSequencedPacketReadIndex[internalPacket-&gt;orderingChannel])==false)
 				{
+					statistics.sequencedMessagesInOrder++;
 
 					// Check for older packets in the output list.  Delete any found
 					// UPDATE:
@@ -351,12 +441,12 @@
 					// don't need the older ones because the odds are they will still arrive in order
 					/*
 					reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
-					DeleteSequencedPacketsInList(internalPacket-&gt;orderingStream, outputQueue);
+					DeleteSequencedPacketsInList(internalPacket-&gt;orderingChannel, outputQueue);
 					reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 
 					// Check for older packets in the split packet list.  Delete any found
 					reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
-					DeleteSequencedPacketsInList(internalPacket-&gt;orderingStream, splitPacketList, internalPacket-&gt;splitPacketId);
+					DeleteSequencedPacketsInList(internalPacket-&gt;orderingChannel, splitPacketList, internalPacket-&gt;splitPacketId);
 					reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 */
 					// Is this a split packet?
@@ -368,43 +458,42 @@
 						assert(internalPacket-&gt;splitPacketIndex &lt; internalPacket-&gt;splitPacketCount);
 						assert(internalPacket-&gt;dataBitLength &lt; MAXIMUM_MTU_SIZE*8);
 
-						reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+						//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 						// Make sure this is not a duplicate insertion.  If this assert hits then splitPacketId overflowed into existing waiting split packets (i.e. more than rangeof(splitPacketId) waiting) 
 						for (unsigned cnt=0; cnt &lt; splitPacketList.size(); cnt++)
 							assert (!(splitPacketList[cnt]-&gt;splitPacketIndex==internalPacket-&gt;splitPacketIndex &amp;&amp; splitPacketList[cnt]-&gt;splitPacketId==splitPacketId));
 						int splitPacketListSize = splitPacketList.size()+1;
-						reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+						//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 						#endif
 
 						// Check for a rebuilt packet
 						InsertIntoSplitPacketList(internalPacket);
 
 						// Sequenced
-						internalPacket = BuildPacketFromSplitPacketList(internalPacket-&gt;splitPacketId);
+						internalPacket = BuildPacketFromSplitPacketList(internalPacket-&gt;splitPacketId,time);
 
 						if (internalPacket)
 						{
 #ifdef _DEBUG
-							reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+							//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 							assert(splitPacketList.size() == splitPacketListSize-internalPacket-&gt;splitPacketCount );
-							reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+							//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 #endif
 							// Update our index to the newest packet
-							waitingForSequencedPacketReadIndex[internalPacket-&gt;orderingStream]=internalPacket-&gt;orderingIndex+1;
+							waitingForSequencedPacketReadIndex[internalPacket-&gt;orderingChannel]=internalPacket-&gt;orderingIndex+1;
 
 							// If there is a rebuilt packet, add it to the output queue
-							reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
-
+//							reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 							outputQueue.push(internalPacket);
-							reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//							reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 							internalPacket=0;
 						}
 #ifdef _DEBUG
 						else
 						{
-							reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+							//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 							assert(splitPacketList.size() == splitPacketListSize );
-							reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+							//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 						}
 #endif
 						// else don't have all the parts yet
@@ -412,18 +501,19 @@
 					else
 					{
 						// Update our index to the newest packet
-						waitingForSequencedPacketReadIndex[internalPacket-&gt;orderingStream]=internalPacket-&gt;orderingIndex+1;
+						waitingForSequencedPacketReadIndex[internalPacket-&gt;orderingChannel]=internalPacket-&gt;orderingIndex+1;
 
 						// Not a split packet. Add the packet to the output queue
-						reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
-
+//						reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 						outputQueue.push(internalPacket);
-						reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//						reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 						internalPacket=0;
 					}
 				}
 				else
 				{
+					statistics.sequencedMessagesOutOfOrder++;
+					
 					// Older sequenced packet.  Discard it
 					delete [] internalPacket-&gt;data;
 					InternalPacketPool::Instance()-&gt;ReleasePointer(internalPacket);
@@ -445,26 +535,26 @@
 
 				// Check for a rebuilt packet
 				if (internalPacket-&gt;reliability!=RELIABLE_ORDERED)
-					internalPacket-&gt;orderingStream=255; // Use 255 to designate not sequenced and not ordered
+					internalPacket-&gt;orderingChannel=255; // Use 255 to designate not sequenced and not ordered
 
 #ifdef _DEBUG
-				reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+				//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 				// Make sure this is not a duplicate insertion.  If this assert hits then splitPacketId overflowed into existing waiting split packets (i.e. more than rangeof(splitPacketId) waiting) 
 				for (unsigned cnt=0; cnt &lt; splitPacketList.size(); cnt++)
 					assert (!(splitPacketList[cnt]-&gt;splitPacketIndex==internalPacket-&gt;splitPacketIndex &amp;&amp; splitPacketList[cnt]-&gt;splitPacketId==internalPacket-&gt;splitPacketId));
 				int splitPacketListSize = splitPacketList.size()+1;
-				reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+				//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 #endif
 				InsertIntoSplitPacketList(internalPacket);
 
-				internalPacket = BuildPacketFromSplitPacketList(internalPacket-&gt;splitPacketId);
+				internalPacket = BuildPacketFromSplitPacketList(internalPacket-&gt;splitPacketId,time);
 
 				if (internalPacket==0)
 				{
 					#ifdef _DEBUG
-					reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+					//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 					assert(splitPacketList.size() == splitPacketListSize );
-					reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+					//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 					#endif
 
 					// Don't have all the parts yet
@@ -473,9 +563,9 @@
 				#ifdef _DEBUG
 				else
 				{
-					reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+					//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 					assert(splitPacketList.size() == splitPacketListSize-internalPacket-&gt;splitPacketCount );
-					reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+					//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 				}
 				#endif
 				// else continue down to handle RELIABLE_ORDERED
@@ -484,9 +574,9 @@
 			if (internalPacket-&gt;reliability==RELIABLE_ORDERED)
 			{
 				#ifdef _DEBUG
-				assert(internalPacket-&gt;orderingStream &lt; NUMBER_OF_ORDERED_STREAMS);
+				assert(internalPacket-&gt;orderingChannel &lt; NUMBER_OF_ORDERED_STREAMS);
 				#endif
-				if (internalPacket-&gt;orderingStream &gt;= NUMBER_OF_ORDERED_STREAMS)
+				if (internalPacket-&gt;orderingChannel &gt;= NUMBER_OF_ORDERED_STREAMS)
 				{
 					// Invalid packet
 					delete [] internalPacket-&gt;data;
@@ -494,27 +584,29 @@
 					goto CONTINUE_SOCKET_DATA_PARSE_LOOP;
 				}
 
-				if (waitingForOrderedPacketReadIndex[internalPacket-&gt;orderingStream]==internalPacket-&gt;orderingIndex)
+				if (waitingForOrderedPacketReadIndex[internalPacket-&gt;orderingChannel]==internalPacket-&gt;orderingIndex)
 				{
 					// Get the list to hold ordered packets for this stream
 					BasicDataStructures::LinkedList&lt;InternalPacket*&gt; *orderingListAtOrderingStream;
-					unsigned char orderingStreamCopy=internalPacket-&gt;orderingStream;
+					unsigned char orderingChannelCopy=internalPacket-&gt;orderingChannel;
 
+					statistics.orderedMessagesInOrder++;
+
 					// Push the packet for the user to read
-					reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+//					reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 					outputQueue.push(internalPacket);
-					reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//					reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 					internalPacket=0; // Don't reference this any longer since other threads access it
 
 					// Wait for the next ordered packet in sequence
-					waitingForOrderedPacketReadIndex[orderingStreamCopy]++; // This wraps at 255
+					waitingForOrderedPacketReadIndex[orderingChannelCopy]++; // This wraps at 255
 
-					reliabilityLayerMutexes[orderingList_MUTEX].Lock();
-					orderingListAtOrderingStream = GetOrderingListAtOrderingStream(orderingStreamCopy);
+					//reliabilityLayerMutexes[orderingList_MUTEX].Lock();
+					orderingListAtOrderingStream = GetOrderingListAtOrderingStream(orderingChannelCopy);
 
 					if (orderingListAtOrderingStream!=0)
 					{
-						// There is a list for this ordering stream that may contain waiting packets.  Pop them in order
+						// There is a list for this ordering channel that may contain waiting packets.  Pop them in order
 
 						// Scan the list and pop packets that were delayed due to ordering in order
 						while (orderingListAtOrderingStream-&gt;size()&gt;0)
@@ -524,18 +616,18 @@
 							pushedPacket=false;
 							while (count!=0)
 							{
-								if (orderingListAtOrderingStream-&gt;peek()-&gt;orderingIndex == waitingForOrderedPacketReadIndex[orderingStreamCopy])
+								if (orderingListAtOrderingStream-&gt;peek()-&gt;orderingIndex == waitingForOrderedPacketReadIndex[orderingChannelCopy])
 								{
 									// A packet was waiting, so output it in order.
 									// This is already mutexed above
 
 									// Push the packet for the user to read
-									reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+//									reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 									outputQueue.push(orderingListAtOrderingStream-&gt;pop());
-									reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//									reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 
 									// Wait for the next ordered packet in sequence
-									waitingForOrderedPacketReadIndex[orderingStreamCopy]++; // This wraps at 255
+									waitingForOrderedPacketReadIndex[orderingChannelCopy]++; // This wraps at 255
 
 									pushedPacket=true;
 
@@ -553,12 +645,14 @@
 						}
 
 					}
-					reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
+					//reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
 
 					internalPacket=0;
 				}
 				else
 				{
+					statistics.orderedMessagesOutOfOrder++;
+
 					// This is a newer ordered packet than we are waiting for.  Store it for future use
 					AddToOrderingList(internalPacket);
 				}
@@ -567,13 +661,13 @@
 			}
 
 			// Nothing special about this packet.  Add it to the output queue
-			reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+//			reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 			outputQueue.push(internalPacket); 
-			reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//			reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 
 			// Output queue fill rate test
 //			if (outputQueue.size()%50==0)
-//				printf(&quot;outputQueue.size()=%i Time=%i\n&quot;, outputQueue.size(), getTime());
+//				printf(&quot;outputQueue.size()=%i Time=%i\n&quot;, outputQueue.size(), RakNetGetTime());
 
 			internalPacket=0;
 		}
@@ -581,12 +675,15 @@
 		// Used for a goto to jump to the next packet immediately
 		CONTINUE_SOCKET_DATA_PARSE_LOOP:
 		// Parse the bitstream to create an internal packet
-		internalPacket = CreateInternalPacketFromBitStream(&amp;socketData);
+		internalPacket = CreateInternalPacketFromBitStream(&amp;socketData,time);
 	}
 
-	reliabilityLayerMutexes[windowSize_MUTEX].Lock();
-	if (numberOfAcksInFrame&gt;=windowSize &amp;&amp; sendQueue[HIGH_PRIORITY].size()&gt;0)
+
+	// numberOfAcksInFrame&gt;=windowSize is almost never true
+	if (numberOfAcksInFrame&gt;=windowSize &amp;&amp; (sendQueue[SYSTEM_PRIORITY].size()&gt;0 || sendQueue[HIGH_PRIORITY].size()&gt;0 || sendQueue[MEDIUM_PRIORITY].size()&gt;0))
 	{
+
+	//	reliabilityLayerMutexes[windowSize_MUTEX].Lock();
 		if (windowSize &lt; lossyWindowSize || time - lastWindowIncreaseSizeTime &gt; lostPacketResendDelay*2) // Increases the window size slowly, testing for packetloss
 		{
 			// If we get a frame which clears out the resend queue after handling one or more acks, and we have packets waiting to go out,
@@ -607,8 +704,8 @@
 			if (windowSize==MAXIMUM_WINDOW_SIZE || windowSize - lossyWindowSize &gt; 5)
 				lossyWindowSize++;
 		}
+	//	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
 	}
-	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
 
 	return true;
 }
@@ -620,14 +717,14 @@
 {
 	InternalPacket* internalPacket;
 
-	reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+//	reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 	if (outputQueue.size()&gt;0)
 	{
-//		#ifdef _DEBUG
-//		assert(bitStream-&gt;GetNumberOfBitsUsed()==0);
-//		#endif
+		//		#ifdef _DEBUG
+		//		assert(bitStream-&gt;GetNumberOfBitsUsed()==0);
+		//		#endif
 		internalPacket = outputQueue.pop();
-		reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//		reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 
 		//printf(&quot;In Receive %i bytes\n&quot;,(internalPacket-&gt;dataBitLength-1)/8+1);
 		//for (int ass=0; ass &lt; (internalPacket-&gt;dataBitLength-1)/8+1 &amp;&amp; ass &lt; 10; ass++)
@@ -644,9 +741,10 @@
 	}
 	else
 	{
-		reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+	//	reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 		return 0;
 	}
+	
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -654,14 +752,14 @@
 // bitStream contains the data to send
 // priority is what priority to send the data at
 // reliability is what reliability to use
-// ordering stream is from 0 to 255 and specifies what stream to use
+// ordering channel is from 0 to 255 and specifies what stream to use
 //-------------------------------------------------------------------------------------------------------
-bool ReliabilityLayer::Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, unsigned char orderingStream, bool makeDataCopy, int MTUSize)
+bool ReliabilityLayer::Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, unsigned char orderingChannel, bool makeDataCopy, int MTUSize)
 {
 	#ifdef _DEBUG
 	assert(!(reliability &gt; RELIABLE_SEQUENCED || reliability &lt; 0));
 	assert(!(priority &gt; NUMBER_OF_PRIORITIES || priority &lt; 0));
-	assert(!(orderingStream &lt; 0 || orderingStream &gt;= NUMBER_OF_ORDERED_STREAMS));
+	assert(!(orderingChannel &lt; 0 || orderingChannel &gt;= NUMBER_OF_ORDERED_STREAMS));
 	assert(bitStream-&gt;GetNumberOfBytesUsed()&gt;0);
 	#endif
 
@@ -677,8 +775,8 @@
 	if (priority &gt; NUMBER_OF_PRIORITIES || priority &lt; 0)
 		priority = HIGH_PRIORITY;
 
-	if (orderingStream &gt;= NUMBER_OF_ORDERED_STREAMS)
-		orderingStream=0;
+	if (orderingChannel &gt;= NUMBER_OF_ORDERED_STREAMS)
+		orderingChannel=0;
 
 	if (bitStream-&gt;GetNumberOfBytesUsed()==0)
 	{
@@ -694,7 +792,7 @@
 	memset(internalPacket, 255, sizeof(InternalPacket));
 #endif
 
-	internalPacket-&gt;creationTime=getTime();
+	internalPacket-&gt;creationTime=RakNetGetTime();
 	if (makeDataCopy)
 	{
 		internalPacket-&gt;data = new char [bitStream-&gt;GetNumberOfBytesUsed()];
@@ -722,13 +820,9 @@
 
 	// If a split packet, we might have to upgrade the reliability
 	if (splitPacket)
-	{
-		// Split packets must be sent reliably.  Otherwise not all the parts might arrive
-		if (internalPacket-&gt;reliability==UNRELIABLE)
-			internalPacket-&gt;reliability=RELIABLE;
-		else if (internalPacket-&gt;reliability==UNRELIABLE_SEQUENCED)
-			internalPacket-&gt;reliability=RELIABLE_SEQUENCED;
-	}
+		statistics.numberOfSplitMessages++;
+	else
+		statistics.numberOfUnsplitMessages++;
 
 	// Increment the cyclical receivedPacketsIndex for use by the next packet.
 	// This variable is used as the identifier of the packet on the remote machine.
@@ -742,13 +836,13 @@
 	if (internalPacket-&gt;reliability==RELIABLE_SEQUENCED || internalPacket-&gt;reliability==UNRELIABLE_SEQUENCED)
 	{
 		// Assign the sequence stream and index
-		internalPacket-&gt;orderingStream=orderingStream;
+		internalPacket-&gt;orderingChannel=orderingChannel;
 		reliabilityLayerMutexes[waitingForSequencedPacketWriteIndex_MUTEX].Lock();
-		internalPacket-&gt;orderingIndex=waitingForSequencedPacketWriteIndex[orderingStream]++;
+		internalPacket-&gt;orderingIndex=waitingForSequencedPacketWriteIndex[orderingChannel]++;
 		reliabilityLayerMutexes[waitingForSequencedPacketWriteIndex_MUTEX].Unlock();
 
-		// This packet supercedes all other sequenced packets on the same ordering stream
-		// Delete all packets in all send lists that are sequenced and on the same ordering stream
+		// This packet supercedes all other sequenced packets on the same ordering channel
+		// Delete all packets in all send lists that are sequenced and on the same ordering channel
 		// UPDATE:
 		// Disabled.  We don't have enough info to consistently do this.  Sometimes newer data does supercede
 		// older data such as with constantly declining health, but not in all cases.
@@ -758,17 +852,17 @@
 		for (int i=0; i &lt; NUMBER_OF_PRIORITIES; i++)
 		{
 			reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
-			DeleteSequencedPacketsInList(orderingStream, sendQueue[i]);
+			DeleteSequencedPacketsInList(orderingChannel, sendQueue[i]);
 			reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
 		}
 		*/
 	}
 	else if (internalPacket-&gt;reliability==RELIABLE_ORDERED)
 	{
-		// Assign the ordering stream and index
-		internalPacket-&gt;orderingStream=orderingStream;
+		// Assign the ordering channel and index
+		internalPacket-&gt;orderingChannel=orderingChannel;
 		reliabilityLayerMutexes[waitingForOrderedPacketWriteIndex_MUTEX].Lock();
-		internalPacket-&gt;orderingIndex=waitingForOrderedPacketWriteIndex[orderingStream]++;
+		internalPacket-&gt;orderingIndex=waitingForOrderedPacketWriteIndex[orderingChannel]++;
 		reliabilityLayerMutexes[waitingForOrderedPacketWriteIndex_MUTEX].Unlock();
 	}
 
@@ -779,9 +873,9 @@
 		return true;
 	}
 	
-	reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+	reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+internalPacket-&gt;priority].Lock();
     sendQueue[internalPacket-&gt;priority].push(internalPacket);
-	reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
+	reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+internalPacket-&gt;priority].Unlock();
 
 	return true;
 }
@@ -789,27 +883,35 @@
 //-------------------------------------------------------------------------------------------------------
 // Run this once per game cycle.  Handles internal lists and actually does the send
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::Update(SOCKET s, PlayerID playerId, int MTUSize)
+void ReliabilityLayer::Update(SOCKET s, PlayerID playerId, int MTUSize, unsigned long time)
 {
 #ifdef __USE_IO_COMPLETION_PORTS
 	if (readWriteSocket==INVALID_SOCKET)
 		return;
 #endif
-//	unsigned resendQueueSize;
+	//	unsigned resendQueueSize;
 	bool reliableDataSent;
 	unsigned long lastAck;
 
+	if (freeThreadedMemoryOnNextUpdate)
+	{
+		freeThreadedMemoryOnNextUpdate=false;
+		FreeThreadedMemory();
+	}
+
 	// Accuracy isn't important on this value, and since this is called so often the mutex is sometimes causing deadlock problems.
 	// So it is presently disabled
 //	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 //	resendQueueSize=resendQueue.size();
 //	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
-	reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
+//	reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
 	lastAck=lastAckTime;
-	reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
+//	reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
 
-	if (resendQueue.size()&gt;0 &amp;&amp; lastAck &amp;&amp; getTime() - lastAck &gt; TIMEOUT_TIME)
+	// Due to thread vagarities and the way I store the time to avoid slow calls to RakNetGetTime
+	// time may be less than lastAck
+	if (resendQueue.size()&gt;0 &amp;&amp; time &gt; lastAck &amp;&amp; lastAck &amp;&amp; time - lastAck &gt; TIMEOUT_TIME)
 	{
 		// SHOW - dead connection
 		// printf(&quot;The connection has been lost.\n&quot;);
@@ -818,7 +920,7 @@
 		return;
 	}
 
-	//if (outputWindowFullTime &amp;&amp; getTime() &gt; TIMEOUT_TIME + outputWindowFullTime)
+	//if (outputWindowFullTime &amp;&amp; RakNetGetTime() &gt; TIMEOUT_TIME + outputWindowFullTime)
 	//{
 	//	// We've waited a long time with no data from the other system.  Assume the connection is lost
 	//	deadConnection=true;
@@ -827,29 +929,60 @@
 
 	// Not a frame but a packet actually.
 	// However, in a sense it is a frame because we are filling multiple logical packets into one datagram
-	if (IsFrameReady())
+	//reliabilityLayerMutexes[updateBitStream_MUTEX].Lock();
+
+	// Keep sending to available bandwidth
+	while (IsFrameReady(time))
 	{
-		reliabilityLayerMutexes[updateBitStream_MUTEX].Lock();
+		updateBitStream.Reset();
+		GenerateFrame(&amp;updateBitStream, MTUSize, &amp;reliableDataSent,time);
+		if (updateBitStream.GetNumberOfBitsUsed()&gt;0)
+		{
+#ifndef _INTERNET_SIMULATOR
+			SendBitStream(s, playerId, &amp;updateBitStream);
+#else
+			// Delay the send to simulate lag
+			DataAndTime *dt;
+			dt=new DataAndTime;
+			memcpy(dt-&gt;data, updateBitStream.GetData(), updateBitStream.GetNumberOfBytesUsed());
+			dt-&gt;length=updateBitStream.GetNumberOfBytesUsed();
+			dt-&gt;sendTime=time+100+(randomMT()%100);
+			delayList.insert(dt);
+#endif
+		}
+		else
+			break;
+	}
+	
 
-		do
+#ifdef _INTERNET_SIMULATOR
+	// Do any lagged sends
+	unsigned i=0;
+	while (i &lt; delayList.size())
+	{
+		if (delayList[i]-&gt;sendTime&lt;time)
 		{
 			updateBitStream.Reset();
-			GenerateFrame(&amp;updateBitStream, MTUSize, &amp;reliableDataSent);
-			if (updateBitStream.GetNumberOfBitsUsed()&gt;0)
-			{
-				SendBitStream(s, playerId, &amp;updateBitStream);
-			}
+			updateBitStream.Write(delayList[i]-&gt;data, delayList[i]-&gt;length);
+			// Send it now
+			SendBitStream(s, playerId, &amp;updateBitStream);
 
-		} while (updateBitStream.GetNumberOfBitsUsed()&gt;0 &amp;&amp; IsFrameReady());
+			delete delayList[i];
+			delayList[i]=delayList[delayList.size()-1];
+			delayList.del();
+		}
+		else
+			i++;
+	}
+#endif
 
-		reliabilityLayerMutexes[updateBitStream_MUTEX].Unlock();
-	}
+	//reliabilityLayerMutexes[updateBitStream_MUTEX].Unlock();
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Writes a bitstream to the socket
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::SendBitStream(SOCKET s, PlayerID playerId, BitStream *bitStream)
+void ReliabilityLayer::SendBitStream(SOCKET s, PlayerID playerId, RakNet::BitStream *bitStream)
 {
  // SHOW - showing reliable flow
 //	if (bitStream-&gt;GetNumberOfBytesUsed()&gt;50)
@@ -857,15 +990,19 @@
 
 	int oldLength, length;
 
-	sentFrames++;
+//	sentFrames++;
 
 #ifdef _INTERNET_SIMULATOR
+
+	/*
 	// packetloss
-	if (randomMT() %100 &lt;=10)
+	if (windowSize&gt;MINIMUM_WINDOW_SIZE &amp;&amp; frandomMT() &lt;= (float)(windowSize-MINIMUM_WINDOW_SIZE)/(float)(MAXIMUM_WINDOW_SIZE-MINIMUM_WINDOW_SIZE))
 	{
-		lastPacketSendTime=getTime();
+		// printf(&quot;Frame %i lost\n&quot;, sentFrames);
+		lastPacketSendTime=RakNetGetTime();
 		return;
 	}
+	*/
 #endif
 
 
@@ -874,64 +1011,68 @@
 	{
 		length = bitStream-&gt;GetNumberOfBytesUsed();
 		oldLength = length;
+
 		encryptor.Encrypt((unsigned char*)bitStream-&gt;GetData(), length, (unsigned char*)bitStream-&gt;GetData(), &amp;length);
+		statistics.encryptionBitsSent=(length-oldLength)*8;
 
-		if (encryptor.IsKeySet())
-			bytesSent+=length - oldLength;
+		// TODO - put back in
+		assert((length % 16 )== 0);
 	}
 	else
 	{
 		length = bitStream-&gt;GetNumberOfBytesUsed();
 	}
 
-
 #ifdef __USE_IO_COMPLETION_PORTS
 	if (readWriteSocket==INVALID_SOCKET)
 	{
-		assert(0);
-		return;
+		assert(0);	return;
 	}
+	statistics.packetsSent++;
+	statistics.totalBitsSent+=length*8;
 	SocketLayer::Instance()-&gt;Write(readWriteSocket, (const char*)bitStream-&gt;GetData(), length);
 #else
-    SocketLayer::Instance()-&gt;SendTo(s, (char*)bitStream-&gt;GetData(), length, playerId);
-#endif
+	statistics.packetsSent++;
+	statistics.totalBitsSent+=length*8;
+	//printf(&quot;total bits=%i length=%i\n&quot;, BITS_TO_BYTES(statistics.totalBitsSent), length);
+    SocketLayer::Instance()-&gt;SendTo(s, (char*)bitStream-&gt;GetData(), length, playerId.binaryAddress, playerId.port);
+#endif // __USE_IO_COMPLETION_PORTS
 
-	lastPacketSendTime=getTime();
+//	lastPacketSendTime=time;
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Returns true if we can or should send a frame.  False if we should not
 //-------------------------------------------------------------------------------------------------------
-bool ReliabilityLayer::IsFrameReady(void)
+bool ReliabilityLayer::IsFrameReady(unsigned long time)
 {
 	if (IsSendThrottled()==false)
 		return true;
 
-	unsigned long time = getTime();
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
 
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
-
 	// Any acknowledgement packets waiting?  We will send these even if the send is throttled.
 	// Otherwise the throttle may never end
-	if (acknowledgementQueue.size()&gt;0 &amp;&amp;
-		(acknowledgementQueue.size() &gt;= MINIMUM_WINDOW_SIZE ||
-		acknowledgementQueue.peek()-&gt;nextActionTime &lt; time))
+	if (acknowledgementQueue.size() &gt;= MINIMUM_WINDOW_SIZE
+		// Try not waiting to send acks - will take more bandwidth but maybe less packetloss
+		// || acknowledgementQueue.peek()-&gt;nextActionTime &lt; time
+		)
 	{
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+		//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 		return true;
 	}
 	
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+//	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 
 	// Does the oldest packet need to be resent?  If so, send it.
 	// Otherwise the throttle may never end
-	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+//	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 	if (resendQueue.size()&gt;0 &amp;&amp; resendQueue.peek() &amp;&amp; resendQueue.peek()-&gt;nextActionTime &lt; time)
 	{
-		reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+//		reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 		return true;
 	}
-	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+//	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
 	// Send is throttled.  Don't send.
 	return false;
@@ -940,13 +1081,13 @@
 //-------------------------------------------------------------------------------------------------------
 // Generates a frame (coalesced packets)
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::GenerateFrame(BitStream *output, int MTUSize, bool *reliableDataSent)
+
+void ReliabilityLayer::GenerateFrame(RakNet::BitStream *output, int MTUSize, bool *reliableDataSent,unsigned long time)
 {
 	InternalPacket *internalPacket;
 	int maxDataBitSize;
 	int reliableBits=0;
 	int nextPacketBitLength;
-	unsigned long time;
 	unsigned i;
 	bool isReliable,onlySendUnreliable;
 	bool acknowledgementPacketsSent;
@@ -959,11 +1100,11 @@
 
 	acknowledgementPacketsSent=false;
 
-	time = getTime();
 	*reliableDataSent=false;
+	
 
 	// Packet acknowledgements always go out first if they are overdue or if there are a lot of them
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
 	//	reliabilityLayerMutexes[remoteFramesAwaitingAck_MUTEX].Lock();
 	if (acknowledgementQueue.size()&gt;0 &amp;&amp;
 		(acknowledgementQueue.size() &gt;=MINIMUM_WINDOW_SIZE ||
@@ -971,110 +1112,114 @@
 	{
 		do
 		{
-
 			//	reliabilityLayerMutexes[remoteFramesAwaitingAck_MUTEX].Unlock();
 			internalPacket = acknowledgementQueue.pop();
-			reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+			//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 
 			// Write the acknowledgement to the output bitstream
-			WriteToBitStreamFromInternalPacket(output, internalPacket);
+			statistics.acknowlegementsSent++;
+			statistics.acknowlegementBitsSent+=WriteToBitStreamFromInternalPacket(output, internalPacket);
 			acknowledgementPacketsSent=true;
 
 			// Delete the acknowledgement
 			InternalPacketPool::Instance()-&gt;ReleasePointer(internalPacket);
 
-			if (	output-&gt;GetNumberOfBitsUsed() + ACK_BIT_LENGTH &gt; maxDataBitSize)
+			if (output-&gt;GetNumberOfBitsUsed() + ACK_BIT_LENGTH &gt; maxDataBitSize)
 			{
-
 				// SHOW - show ack
-		//		printf(&quot;Sending FULL ack (%i) at time %i. acknowledgementQueue.size()=%i\n&quot;, output-&gt;GetNumberOfBytesUsed(), getTime(),acknowledgementQueue.size());
+				//printf(&quot;Sending FULL ack (%i) at time %i. acknowledgementQueue.size()=%i\n&quot;, output-&gt;GetNumberOfBytesUsed(), RakNetGetTime(),acknowledgementQueue.size());
 
+				statistics.packetsContainingOnlyAcknowlegements++;
 				goto END_OF_GENERATE_FRAME;
 			}
 
-			reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+	//		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
 		} while(acknowledgementQueue.size() &gt; 0);
 	}
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 
+	
+
 	// SHOW - show ack
 	//if (output-&gt;GetNumberOfBitsUsed()&gt;0)
-		//printf(&quot;Sending ack (%i) at time %i. acknowledgementQueue.size()=%i\n&quot;, output-&gt;GetNumberOfBytesUsed(), getTime(),acknowledgementQueue.size());
+	//	printf(&quot;Sending ack (%i) at time %i. acknowledgementQueue.size()=%i\n&quot;, output-&gt;GetNumberOfBytesUsed(), RakNetGetTime(),acknowledgementQueue.size());
 
-	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 
 	// The resend Queue can have NULL pointer holes.  This is so we can deallocate blocks without having to compress the array
-	while (resendQueue.size() &gt; 0 &amp;&amp; (resendQueue.peek()==0 || resendQueue.peek()-&gt;nextActionTime &lt; time))
+	while (resendQueue.size() &gt; 0)
 	{
-		// Copy the first packet out of the resend list
-		internalPacket = resendQueue.pop();
-
-		if (internalPacket==0)
+		if (resendQueue.peek()==0)
+		{
+			resendQueue.pop();
 			continue; // This was a hole
+		}
 
-		reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+		if (resendQueue.peek()-&gt;nextActionTime &lt; time)
+		{
+			internalPacket = resendQueue.pop();
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+			// Testing
+			//printf(&quot;Resending %i. queue size = %i\n&quot;, internalPacket-&gt;packetNumber, resendQueue.size());
 
-		nextPacketBitLength = GetBitStreamHeaderLength(internalPacket) + internalPacket-&gt;dataBitLength;
+			nextPacketBitLength = GetBitStreamHeaderLength(internalPacket) + internalPacket-&gt;dataBitLength;
 
-		if (	output-&gt;GetNumberOfBitsUsed() + nextPacketBitLength &gt; maxDataBitSize)
-		{
-			reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-			resendQueue.pushAtHead(internalPacket); // Not enough room to use this packet after all!
-			reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+			if (output-&gt;GetNumberOfBitsUsed() + nextPacketBitLength &gt; maxDataBitSize)
+			{
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+				resendQueue.pushAtHead(internalPacket); // Not enough room to use this packet after all!
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
-			if (anyPacketsLost)
-			{
-				// The window size will decrease everytime we have to retransmit a frame
-				reliabilityLayerMutexes[windowSize_MUTEX].Lock();
-				if (--windowSize &lt; MINIMUM_WINDOW_SIZE)
-					windowSize=MINIMUM_WINDOW_SIZE;
-				reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
-				lossyWindowSize=windowSize;
-				lastWindowIncreaseSizeTime=time;  // This will block the window size from increasing immediately
-				// SHOW - windowing
-				//printf(&quot;Frame lost.  New window size = %i.  Lossy window size = %i\n&quot;, windowSize, lossyWindowSize);
+				if (anyPacketsLost)
+				{
+					UpdatePacketloss(time);
+				}
+
+				goto END_OF_GENERATE_FRAME;
 			}
 
-			goto END_OF_GENERATE_FRAME;
-		}
+#ifdef _DEBUG
+			assert(internalPacket-&gt;priority&gt;=0);
+			assert(internalPacket-&gt;reliability&gt;=0);
+#endif
 
-		#ifdef _DEBUG
-		assert(internalPacket-&gt;priority&gt;=0);
-		assert(internalPacket-&gt;reliability&gt;=0);
-		#endif
+			// SHOW - show resends
+			//printf(&quot;Resending packet. resendQueue.size()=%i. Data=%s\n&quot;,resendQueue.size(), internalPacket-&gt;data);
 
-		// SHOW - show resends
-		//printf(&quot;Resending packet. resendQueue.size()=%i. Data=%s\n&quot;,resendQueue.size(), internalPacket-&gt;data);
+			// Write to the output bitstream
+//			sentPackets++;
+			statistics.messageResends++;
+			statistics.messageDataBitsResent+=internalPacket-&gt;dataBitLength;
 
-		// Write to the output bitstream
-		sentPackets++;
-		WriteToBitStreamFromInternalPacket(output, internalPacket);
-		*reliableDataSent=true;
+			statistics.messagesTotalBitsResent+=WriteToBitStreamFromInternalPacket(output, internalPacket);
+			*reliableDataSent=true;
 
-		// Update packetloss
-		UpdatePacketloss();
-		anyPacketsLost=true;
+			//		if (output-&gt;GetNumberOfBitsUsed() + ACK_BIT_LENGTH &gt; maxDataBitSize)
+			//			printf(&quot;Frame full of just acks and resends at time %i.\n&quot;, RakNetGetTime());
 
-		reliableBits+=internalPacket-&gt;dataBitLength;
-		internalPacket-&gt;nextActionTime = time + lostPacketResendDelay;
+			statistics.packetsContainingOnlyAcknowlegementsAndResends++;
 
-		// Put the packet back into the resend list at the correct spot
-		InsertPacketIntoResendQueue(internalPacket);
-		reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+			anyPacketsLost=true;
+			internalPacket-&gt;nextActionTime = time + lostPacketResendDelay;
+
+			// Put the packet back into the resend list at the correct spot
+			InsertPacketIntoResendQueue(internalPacket, time);
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+
+		}
+		else
+		{
+			break;
+		}
 	}
-	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
+	
+
 	if (anyPacketsLost)
 	{
-		// The window size will decrease everytime we have to retransmit a frame
-		reliabilityLayerMutexes[windowSize_MUTEX].Lock();
-		if (--windowSize &lt; MINIMUM_WINDOW_SIZE)
-			windowSize=MINIMUM_WINDOW_SIZE;
-		reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
-		lossyWindowSize=windowSize;
-		lastWindowIncreaseSizeTime=time; // This will block the window size from increasing immediately
-		// SHOW - windowing
-		//printf(&quot;Frame lost.  New window size = %i.  Lossy window size = %i\n&quot;, windowSize, lossyWindowSize);
+		// Update packetloss
+		UpdatePacketloss(time);
 	}
 
 	onlySendUnreliable=false;
@@ -1085,18 +1230,27 @@
 	// From highest to lowest priority, fill up the output bitstream from the send lists
 	for (i=0; i &lt; NUMBER_OF_PRIORITIES; i++)
 	{
-		reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+	//	if (i==LOW_PRIORITY &amp;&amp; sendQueue[LOW_PRIORITY].size() &gt; 0 &amp;&amp; (sendQueue[LOW_PRIORITY].size()%100)==0)
+	//	{
+	//		printf(&quot;%i\n&quot;, sendQueue[LOW_PRIORITY].size());
+	//	}
+
+		// Not mutexed - may give a wrong value if another thread is inserting something but it's ok
+		// Because we can avoid a slow mutex call a lot of the time
+		if (sendQueue[i].size()==0)
+			continue;
+		reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Lock();
 		while (sendQueue[i].size())
 		{
 			internalPacket = sendQueue[i].pop();
-			reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
+			reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Unlock();
 
 			nextPacketBitLength = GetBitStreamHeaderLength(internalPacket) + internalPacket-&gt;dataBitLength;
 
-			if (	output-&gt;GetNumberOfBitsUsed() + nextPacketBitLength &gt; maxDataBitSize)
+			if (output-&gt;GetNumberOfBitsUsed() + nextPacketBitLength &gt; maxDataBitSize)
 			{
 				// This output won't fit.
-				reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+				reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Lock();
 				sendQueue[i].pushAtHead(internalPacket); // Push this back at the head so it is the next thing to go out
 				break;
 			}
@@ -1107,14 +1261,17 @@
 				isReliable=false;
 
 			// Write to the output bitstream
-			sentPackets++;
-			WriteToBitStreamFromInternalPacket(output, internalPacket);
+//			sentPackets++;
+			statistics.messagesSent[i]++;
+			statistics.messageDataBitsSent[i]+=internalPacket-&gt;dataBitLength;
+			statistics.messageTotalBitsSent[i]+=WriteToBitStreamFromInternalPacket(output, internalPacket);
 			if (isReliable)
 			{
 				// Reliable packets are saved to resend later
 				reliableBits+=internalPacket-&gt;dataBitLength;
 				internalPacket-&gt;nextActionTime = time + lostPacketResendDelay;
-				InsertPacketIntoResendQueue(internalPacket);
+				//printf(&quot;Resending at %i\n&quot;, internalPacket-&gt;nextActionTime);
+				InsertPacketIntoResendQueue(internalPacket, time);
 
 				*reliableDataSent=true;
 			}
@@ -1125,44 +1282,48 @@
 				InternalPacketPool::Instance()-&gt;ReleasePointer(internalPacket);
 			}
 
-			reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+			reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Lock();
 		}
 
-		reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
+		reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Unlock();
 
 	}
 
 	// Optimization - if we sent data but didn't send an acknowledgement packet previously then send them now
 	if (acknowledgementPacketsSent==false &amp;&amp; output-&gt;GetNumberOfBitsUsed()&gt;0)
 	{
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
-		while(output-&gt;GetNumberOfBitsUsed() + ACK_BIT_LENGTH &lt; maxDataBitSize &amp;&amp; acknowledgementQueue.size() &gt; 0)
+		if (acknowledgementQueue.size() &gt; 0)
 		{
-			internalPacket = acknowledgementQueue.pop();
-			reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+			//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+			while(output-&gt;GetNumberOfBitsUsed() + ACK_BIT_LENGTH &lt; maxDataBitSize &amp;&amp; acknowledgementQueue.size() &gt; 0)
+			{
+				internalPacket = acknowledgementQueue.pop();
+				//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 
-			// Write the acknowledgement to the output bitstream
-			WriteToBitStreamFromInternalPacket(output, internalPacket);
+				// Write the acknowledgement to the output bitstream
+				WriteToBitStreamFromInternalPacket(output, internalPacket);
 
-			// Delete the acknowledgement
-			InternalPacketPool::Instance()-&gt;ReleasePointer(internalPacket);
+				// Delete the acknowledgement
+				InternalPacketPool::Instance()-&gt;ReleasePointer(internalPacket);
 
-			reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
-		} 
+				//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+			} 
 
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+			//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+		}
 	}
 
 END_OF_GENERATE_FRAME:
+;
 
-
-	if (output-&gt;GetNumberOfBitsUsed()&gt;0)
-	{
+//	if (output-&gt;GetNumberOfBitsUsed()&gt;0)
+//	{
 		// Update the throttle with the header
-		bytesSent+=output-&gt;GetNumberOfBytesUsed() + UDP_HEADER_SIZE;
-	}
+//		bytesSent+=output-&gt;GetNumberOfBytesUsed() + UDP_HEADER_SIZE;
+	//}
 }
 
+
 //-------------------------------------------------------------------------------------------------------
 // This will return true if we should not send at this time
 //-------------------------------------------------------------------------------------------------------
@@ -1170,9 +1331,9 @@
 {
 	int win;
 
-	reliabilityLayerMutexes[windowSize_MUTEX].Lock();
+//	reliabilityLayerMutexes[windowSize_MUTEX].Lock();
 	win = windowSize;
-	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
+//	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
 
 	return (int)resendQueue.size() &gt;=win;
 }
@@ -1180,9 +1341,9 @@
 //-------------------------------------------------------------------------------------------------------
 // We lost a packet
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::UpdatePacketloss(void)
+void ReliabilityLayer::UpdatePacketloss(unsigned long time)
 {
-//	unsigned long time = getTime();
+//	unsigned long time = RakNetGetTime();
 	/*
 	maximumWindowSize = (unsigned int)((double)maximumWindowSize * DECREASE_THROUGHPUT_DELTA);
 	if (maximumWindowSize &lt; MINIMUM_THROUGHPUT)
@@ -1197,7 +1358,18 @@
 
 
 //	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
-	retransmittedPackets++;
+//	retransmittedFrames++;
+
+	// The window size will decrease everytime we have to retransmit a frame
+	//reliabilityLayerMutexes[windowSize_MUTEX].Lock();
+	if (--windowSize &lt; MINIMUM_WINDOW_SIZE)
+		windowSize=MINIMUM_WINDOW_SIZE;
+	//reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
+	lossyWindowSize=windowSize;
+	lastWindowIncreaseSizeTime=time; // This will block the window size from increasing immediately
+	// SHOW - windowing
+//	if (resendQueue.size()&gt;0)
+//		printf(&quot;Frame lost.  New window size = %i.  Lossy window size = %i. Time=%i. Next send time=%i\n&quot;, windowSize, lossyWindowSize, RakNetGetTime(),resendQueue.peek()-&gt;nextActionTime);
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1207,46 +1379,52 @@
 {
 	InternalPacket *internalPacket;
 	PacketReliability reliability; // What type of reliability algorithm to use with this packet
-	unsigned char orderingStream; // What ordering stream this packet is on, if the reliability type uses ordering streams
-	unsigned char orderingIndex; // The ID used as identification for ordering streams
+	unsigned char orderingChannel; // What ordering channel this packet is on, if the reliability type uses ordering channels
+	unsigned char orderingIndex; // The ID used as identification for ordering channels
 
-	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+//	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 
 	for (unsigned i=0; i &lt; resendQueue.size(); i ++)
 	{
 		if (resendQueue[i] &amp;&amp; packetNumber==resendQueue[i]-&gt;packetNumber)
 		{
+			// Found what we wanted to ack
+			statistics.acknowlegementsReceived++;
+
 			if (i==0)
 				internalPacket=resendQueue.pop();
 			else
 			{
+				
 				// Generate a hole
 				internalPacket = resendQueue[i];
+				// testing
+			//	printf(&quot;Removing packet %i from resend\n&quot;, internalPacket-&gt;packetNumber);
 				resendQueue[i]=0;
 			}
 
-			reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
 			// Save some of the data of the packet
 			reliability=internalPacket-&gt;reliability;
-			orderingStream=internalPacket-&gt;orderingStream;
+			orderingChannel=internalPacket-&gt;orderingChannel;
 			orderingIndex=internalPacket-&gt;orderingIndex;
 
 			// Delete the packet
 			delete [] internalPacket-&gt;data;
 			InternalPacketPool::Instance()-&gt;ReleasePointer(internalPacket);
 
-			// If the deleted packet was reliable sequenced, also delete all older reliable sequenced resends on the same ordering stream.
+			// If the deleted packet was reliable sequenced, also delete all older reliable sequenced resends on the same ordering channel.
 			// This is because we no longer need to send these.
 			if (reliability==RELIABLE_SEQUENCED)
 			{
 				unsigned j=0;
 
-				reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 				while (j &lt; resendQueue.size())
 				{
 					internalPacket = resendQueue[j];
-					if (internalPacket &amp;&amp; internalPacket-&gt;reliability==RELIABLE_SEQUENCED &amp;&amp; internalPacket-&gt;orderingStream==orderingStream &amp;&amp; IsOlderOrderedPacket(internalPacket-&gt;orderingIndex, orderingIndex))
+					if (internalPacket &amp;&amp; internalPacket-&gt;reliability==RELIABLE_SEQUENCED &amp;&amp; internalPacket-&gt;orderingChannel==orderingChannel &amp;&amp; IsOlderOrderedPacket(internalPacket-&gt;orderingIndex, orderingIndex))
 					{
 						// Delete the packet
 						delete [] internalPacket-&gt;data;
@@ -1256,21 +1434,24 @@
 
 					j++;
 				}
-				reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+//				reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 			}
 
-			reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-			break;
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+			return;
 		}
 	}
 
-	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+
+	// Didn't find what we wanted to ack
+	statistics.duplicateAcknowlegementsReceived++;
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Acknowledge receipt of the packet with the specified packetNumber
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::SendAcknowledgementPacket(PacketNumberType packetNumber)
+void ReliabilityLayer::SendAcknowledgementPacket(PacketNumberType packetNumber, unsigned long time)
 {
 	InternalPacket *internalPacket;
 
@@ -1303,16 +1484,16 @@
 	internalPacket-&gt;packetNumber=packetNumber;
 	internalPacket-&gt;isAcknowledgement=true;
 
-	internalPacket-&gt;creationTime = getTime();
+	internalPacket-&gt;creationTime = time;
 	// We send this acknowledgement no later than 1/4 the time the remote 
 	//machine would send the original packet again
 	// DEBUG
-	internalPacket-&gt;nextActionTime = internalPacket-&gt;creationTime + lostPacketResendDelay/4;
+	internalPacket-&gt;nextActionTime = internalPacket-&gt;creationTime + (lostPacketResendDelay&gt;&gt;2);
 	//internalPacket-&gt;nextActionTime = internalPacket-&gt;creationTime;
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
 	acknowledgementQueue.push(internalPacket);
-//	printf(&quot;&lt;Server&gt;Adding ack at time %i. acknowledgementQueue.size=%i\n&quot;,getTime(), acknowledgementQueue.size());
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+//	printf(&quot;&lt;Server&gt;Adding ack at time %i. acknowledgementQueue.size=%i\n&quot;,RakNetGetTime(), acknowledgementQueue.size());
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1338,11 +1519,11 @@
 	//bitStream-&gt;WriteBits((unsigned char*)&amp;(internalPacket-&gt;reliability), 3, true);
 	bitLength+=3;
 
-	// If the reliability requires an ordering stream and ordering index, we Write those.
+	// If the reliability requires an ordering channel and ordering index, we Write those.
 	if (internalPacket-&gt;reliability==UNRELIABLE_SEQUENCED || internalPacket-&gt;reliability==RELIABLE_SEQUENCED || internalPacket-&gt;reliability==RELIABLE_ORDERED)
 	{
-		// ordering stream encoded in 5 bits (from 0 to 31)
-		//bitStream-&gt;WriteBits((unsigned char*)&amp;(internalPacket-&gt;orderingStream), 5, true);
+		// ordering channel encoded in 5 bits (from 0 to 31)
+		//bitStream-&gt;WriteBits((unsigned char*)&amp;(internalPacket-&gt;orderingChannel), 5, true);
 		// -- bitLength+=5;
 
 		// ordering index is one byte
@@ -1381,14 +1562,22 @@
 //-------------------------------------------------------------------------------------------------------
 // Parse an internalPacket and create a bitstream to represent this data
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::WriteToBitStreamFromInternalPacket(BitStream *bitStream, const InternalPacket *const internalPacket)
+int ReliabilityLayer::WriteToBitStreamFromInternalPacket(RakNet::BitStream *bitStream, const InternalPacket *const internalPacket)
 {
 	#ifdef _DEBUG
 	assert(bitStream &amp;&amp; internalPacket);
 	#endif
 
-	bitStream-&gt;AlignWriteToByteBoundary();
+	int start=bitStream-&gt;GetNumberOfBitsUsed();
 
+// testing
+//	if (internalPacket-&gt;reliability==UNRELIABLE)
+//		printf(&quot;Sending unreliable packet %i\n&quot;, internalPacket-&gt;packetNumber);
+//	else if (internalPacket-&gt;reliability==RELIABLE_SEQUENCED || internalPacket-&gt;reliability==RELIABLE_ORDERED || internalPacket-&gt;reliability==RELIABLE)
+//		printf(&quot;Sending reliable packet number %i\n&quot;, internalPacket-&gt;packetNumber);
+
+	//bitStream-&gt;AlignWriteToByteBoundary();
+
 	// Write the packet number (2 bytes)
 	bitStream-&gt;Write(internalPacket-&gt;packetNumber);
 
@@ -1396,7 +1585,9 @@
 	bitStream-&gt;Write(internalPacket-&gt;isAcknowledgement);
 	// Acknowledgement packets have no more data than the packetnumber and whether it is an acknowledgement
 	if (internalPacket-&gt;isAcknowledgement)
-		return;
+	{
+		return bitStream-&gt;GetNumberOfBitsUsed()-start;
+	}
 
 	#ifdef _DEBUG
 	assert(internalPacket-&gt;dataBitLength&gt;0);
@@ -1406,11 +1597,11 @@
 	unsigned char reliability = (unsigned char)internalPacket-&gt;reliability;
 	bitStream-&gt;WriteBits((unsigned char*)(&amp;(reliability)), 3, true);
 
-	// If the reliability requires an ordering stream and ordering index, we Write those.
+	// If the reliability requires an ordering channel and ordering index, we Write those.
 	if (internalPacket-&gt;reliability==UNRELIABLE_SEQUENCED || internalPacket-&gt;reliability==RELIABLE_SEQUENCED || internalPacket-&gt;reliability==RELIABLE_ORDERED)
 	{
-		// ordering stream encoded in 5 bits (from 0 to 31)
-		bitStream-&gt;WriteBits((unsigned char*)&amp;(internalPacket-&gt;orderingStream), 5, true);
+		// ordering channel encoded in 5 bits (from 0 to 31)
+		bitStream-&gt;WriteBits((unsigned char*)&amp;(internalPacket-&gt;orderingChannel), 5, true);
 
 		// ordering index is one byte
 		bitStream-&gt;Write(internalPacket-&gt;orderingIndex);
@@ -1433,30 +1624,35 @@
 	#endif
 	unsigned short length = (unsigned short) internalPacket-&gt;dataBitLength; // Ignore the 2 high bytes for WriteBits
 
-	bitStream-&gt;Write(length);
+	bitStream-&gt;WriteCompressed(length);
 
 	// Write the actual data.
 	bitStream-&gt;WriteAlignedBytes((unsigned char*)internalPacket-&gt;data, BITS_TO_BYTES(internalPacket-&gt;dataBitLength));
+	//bitStream-&gt;WriteBits((unsigned char*)internalPacket-&gt;data, internalPacket-&gt;dataBitLength);
+
+	return bitStream-&gt;GetNumberOfBitsUsed()-start;
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Parse a bitstream and create an internal packet to represent this data
 //-------------------------------------------------------------------------------------------------------
-InternalPacket* ReliabilityLayer::CreateInternalPacketFromBitStream(BitStream *bitStream)
+InternalPacket* ReliabilityLayer::CreateInternalPacketFromBitStream(RakNet::BitStream *bitStream, unsigned long time)
 {
-	if (bitStream-&gt;GetNumberOfUnreadBits() &lt; 8)
+	bool bitStreamSucceeded;
+	InternalPacket* internalPacket;
+
+	if (bitStream-&gt;GetNumberOfUnreadBits() &lt; sizeof(internalPacket-&gt;packetNumber)*8)
 		return 0; // leftover bits
-
-	bool bitStreamSucceeded;
-	InternalPacket* internalPacket = InternalPacketPool::Instance()-&gt;GetPointer();
+	
+	internalPacket = InternalPacketPool::Instance()-&gt;GetPointer();
 #ifdef _DEBUG
 	// Remove boundschecker accessing undefined memory error
 	memset(internalPacket, 255, sizeof(InternalPacket));
 #endif
 
-	internalPacket-&gt;creationTime=getTime();
+	internalPacket-&gt;creationTime=time;
 
-	bitStream-&gt;AlignReadToByteBoundary();
+	//bitStream-&gt;AlignReadToByteBoundary();
 
 	// Read the packet number (2 bytes)
 	bitStreamSucceeded = bitStream-&gt;Read(internalPacket-&gt;packetNumber);
@@ -1484,11 +1680,11 @@
 #endif
 	if (bitStreamSucceeded==false) {InternalPacketPool::Instance()-&gt;ReleasePointer(internalPacket); return 0;}
 
-	// If the reliability requires an ordering stream and ordering index, we read those.
+	// If the reliability requires an ordering channel and ordering index, we read those.
 	if (internalPacket-&gt;reliability==UNRELIABLE_SEQUENCED || internalPacket-&gt;reliability==RELIABLE_SEQUENCED || internalPacket-&gt;reliability==RELIABLE_ORDERED)
 	{
-		// ordering stream encoded in 5 bits (from 0 to 31)
-		bitStreamSucceeded = bitStream-&gt;ReadBits((unsigned char*)&amp;(internalPacket-&gt;orderingStream), 5);
+		// ordering channel encoded in 5 bits (from 0 to 31)
+		bitStreamSucceeded = bitStream-&gt;ReadBits((unsigned char*)&amp;(internalPacket-&gt;orderingChannel), 5);
 #ifdef _DEBUG
 		assert(bitStreamSucceeded);
 #endif
@@ -1511,7 +1707,7 @@
 	if (bitStreamSucceeded==false) {InternalPacketPool::Instance()-&gt;ReleasePointer(internalPacket); return 0;}
 	if (isSplitPacket)
 	{
-		// split packet indices are one byte (so one packet can be split up to 65535 times - maximum packet size would be about 500 * 65535)
+		// split packet indices are one byte (so one packet can be split ufp to 65535 times - maximum packet size would be about 500 * 65535)
 		bitStreamSucceeded = bitStream-&gt;Read(internalPacket-&gt;splitPacketId);
 #ifdef _DEBUG
 		assert(bitStreamSucceeded);
@@ -1538,7 +1734,7 @@
 
 	
 	unsigned short length;
-	bitStreamSucceeded = bitStream-&gt;Read(length);
+	bitStreamSucceeded = bitStream-&gt;ReadCompressed(length);
 	// Read into an unsigned short.  Otherwise the data would be offset too high by two bytes
 #ifdef _DEBUG
 	assert(bitStreamSucceeded);
@@ -1556,6 +1752,7 @@
 	internalPacket-&gt;data[BITS_TO_BYTES(internalPacket-&gt;dataBitLength)-1]=0;
 	// Read the data the packet holds
 	bitStreamSucceeded = bitStream-&gt;ReadAlignedBytes((unsigned char*)internalPacket-&gt;data, BITS_TO_BYTES(internalPacket-&gt;dataBitLength));
+	//bitStreamSucceeded = bitStream-&gt;ReadBits((unsigned char*)internalPacket-&gt;data, internalPacket-&gt;dataBitLength);
 	#ifdef _DEBUG
 	assert(bitStreamSucceeded);	if (bitStreamSucceeded==false) {delete [] internalPacket-&gt;data; InternalPacketPool::Instance()-&gt;ReleasePointer(internalPacket); return 0;}
 	#endif
@@ -1601,14 +1798,14 @@
 // Search the specified list for sequenced packets on the specified ordering 
 // stream, optionally skipping those with splitPacketId, and delete them
 //-------------------------------------------------------------------------------------------------------
-void  ReliabilityLayer::DeleteSequencedPacketsInList(unsigned char orderingStream, BasicDataStructures::List&lt;InternalPacket*&gt;&amp;theList, int splitPacketId)
+void  ReliabilityLayer::DeleteSequencedPacketsInList(unsigned char orderingChannel, BasicDataStructures::List&lt;InternalPacket*&gt;&amp;theList, int splitPacketId)
 {
 	unsigned i=0;
 
 	while (i &lt; theList.size())
 	{
 		if ((theList[i]-&gt;reliability==RELIABLE_SEQUENCED || theList[i]-&gt;reliability==UNRELIABLE_SEQUENCED) &amp;&amp;
-			theList[i]-&gt;orderingStream==orderingStream &amp;&amp; (splitPacketId==-1 || theList[i]-&gt;splitPacketId!=splitPacketId))
+			theList[i]-&gt;orderingChannel==orderingChannel &amp;&amp; (splitPacketId==-1 || theList[i]-&gt;splitPacketId!=splitPacketId))
 		{
 			InternalPacket *internalPacket = theList[i];
 			theList.del(i);
@@ -1624,7 +1821,7 @@
 // Search the specified list for sequenced packets with a value less than orderingIndex and delete them
 // Note - I added functionality so you can use the Queue as a list (in this case for searching) but it is less efficient to do so than a regular list
 //-------------------------------------------------------------------------------------------------------
-void  ReliabilityLayer::DeleteSequencedPacketsInList(unsigned char orderingStream, BasicDataStructures::Queue&lt;InternalPacket*&gt;&amp;theList)
+void  ReliabilityLayer::DeleteSequencedPacketsInList(unsigned char orderingChannel, BasicDataStructures::Queue&lt;InternalPacket*&gt;&amp;theList)
 {
 	InternalPacket *internalPacket;
 	int listSize=theList.size();
@@ -1632,7 +1829,7 @@
 
 	while (i &lt; listSize)
 	{
-		if ((theList[i]-&gt;reliability==RELIABLE_SEQUENCED || theList[i]-&gt;reliability==UNRELIABLE_SEQUENCED) &amp;&amp;	theList[i]-&gt;orderingStream==orderingStream)
+		if ((theList[i]-&gt;reliability==RELIABLE_SEQUENCED || theList[i]-&gt;reliability==UNRELIABLE_SEQUENCED) &amp;&amp;	theList[i]-&gt;orderingChannel==orderingChannel)
 		{
 			internalPacket = theList[i];
 			theList.del(i);
@@ -1690,7 +1887,6 @@
 	if (encryptor.IsKeySet())
 		maxDataSize-=16; // Extra data for the encryptor
 
-
 	#ifdef _DEBUG
 	// Make sure we need to split the packet to begin with
 	assert(dataByteLength &gt; maxDataSize - headerLength);
@@ -1705,8 +1901,11 @@
 	// Calculate how many packets we need to create
 	internalPacket-&gt;splitPacketCount = (unsigned short)((dataByteLength-1) / (maximumSendBlock) + 1);
 
+	statistics.totalSplits+=internalPacket-&gt;splitPacketCount;
+
 	// Optimization
-	internalPacketArray = new InternalPacket*[internalPacket-&gt;splitPacketCount];
+	// internalPacketArray = new InternalPacket*[internalPacket-&gt;splitPacketCount];
+	internalPacketArray = (InternalPacket**)alloca(sizeof(InternalPacket*)*internalPacket-&gt;splitPacketCount);
 	for (i=0; i &lt; (int)internalPacket-&gt;splitPacketCount; i++)
 	{
 		internalPacketArray[i]=InternalPacketPool::Instance()-&gt;GetPointer();
@@ -1759,16 +1958,16 @@
 	splitPacketId++; // It's ok if this wraps to 0
 
 	// Copy all the new packets into the split packet list
-	reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+	reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+internalPacket-&gt;priority].Lock();
 	for (i=0; i &lt; (int)internalPacket-&gt;splitPacketCount; i++)
 		sendQueue[internalPacket-&gt;priority].push(internalPacketArray[i]);
-	reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
+	reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+internalPacket-&gt;priority].Unlock();
 
 	// Delete the original
 	delete [] internalPacket-&gt;data;
 	InternalPacketPool::Instance()-&gt;ReleasePointer(internalPacket);
 
-	delete [] internalPacketArray;
+	//delete [] internalPacketArray;
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1776,9 +1975,9 @@
 //-------------------------------------------------------------------------------------------------------
 void ReliabilityLayer::InsertIntoSplitPacketList(InternalPacket * internalPacket)
 {
-	reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 	splitPacketList.insert(internalPacket);
-	reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1786,7 +1985,7 @@
 //reconstruct a packet.  If we can, allocate and return it.  Otherwise return 0
 // Optimized version
 //-------------------------------------------------------------------------------------------------------
-InternalPacket * ReliabilityLayer::BuildPacketFromSplitPacketList(unsigned long splitPacketId)
+InternalPacket * ReliabilityLayer::BuildPacketFromSplitPacketList(unsigned long splitPacketId,unsigned long time)
 {
 	int i,j,size;
 	// How much data all blocks but the last hold
@@ -1796,7 +1995,7 @@
 	int *indexList;
 	int indexListIndex;
 
-	reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 	size = splitPacketList.size();
 
 	for (i=0; i &lt; size; i++)
@@ -1806,19 +2005,21 @@
 			// Is there enough elements in the list to have all the parts?
 			if (splitPacketList[i]-&gt;splitPacketCount &gt; splitPacketList.size() - i)
 			{
-				if (splitPacketList.size() % 100 == 0)
-					printf(&quot;%i\n&quot;, splitPacketList.size());
-				reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+	//			if (splitPacketList.size() % 100 == 0 || splitPacketList[i]-&gt;splitPacketCount-splitPacketList.size()&lt;100)
+	//				printf(&quot;%i out of %i\n&quot;, splitPacketList.size(), splitPacketList[i]-&gt;splitPacketCount);
+				//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 				return 0;
 			}
 
+	//		printf(&quot;%i out of %i\n&quot;, splitPacketList.size(), splitPacketList[i]-&gt;splitPacketCount);
 			// Keep track of the indices of the elements through our first scan so we don't have to rescan to find them
 			indexListIndex=0;
 
 			numParts=1;
 			bitlength=splitPacketList[i]-&gt;dataBitLength;
 
-			indexList = new int[splitPacketList[i]-&gt;splitPacketCount];
+			// indexList = new int[splitPacketList[i]-&gt;splitPacketCount];
+			indexList = (int*) alloca(sizeof(int)*splitPacketList[i]-&gt;splitPacketCount);
 			indexList[indexListIndex++]=i;
 
 			maxDataSize=BITS_TO_BYTES(splitPacketList[i]-&gt;dataBitLength);
@@ -1838,7 +2039,7 @@
 			if (numParts==splitPacketList[i]-&gt;splitPacketCount)
 			{
 				// All the parts are here
-				InternalPacket *internalPacket=CreateInternalPacketCopy(splitPacketList[i],0,0);
+				InternalPacket *internalPacket=CreateInternalPacketCopy(splitPacketList[i],0,0,time);
 				internalPacket-&gt;data=new char[BITS_TO_BYTES(bitlength)];
 #ifdef _DEBUG
 				internalPacket-&gt;splitPacketCount = splitPacketList[i]-&gt;splitPacketCount;
@@ -1898,28 +2099,74 @@
 					else
 						j++;
 
-				reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+				//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 
-				delete [] indexList;
+			//	delete [] indexList;
 
 				return internalPacket;
 			}
 
-			delete [] indexList;
+		//	delete [] indexList;
 			break;
 		}
 	}
 
-	reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 
 	return 0;
 }
 
+// Delete any unreliable split packets that have long since expired
+void ReliabilityLayer::DeleteOldUnreliableSplitPackets(unsigned long time)
+{
+	unsigned size,i,orderingIndexToDelete;
+	unsigned long newestUnreliableSplitPacket;
+	bool found;
+	InternalPacket *temp;
+
+	// Scan through the list for split packets that were sent unreliably.
+	// If the newest unreliable split packet for a particular ID is more than 3000 ms old, then
+	// delete all of them of that id
+
+	size = splitPacketList.size();
+	newestUnreliableSplitPacket=0L;
+	found=false;
+
+	for (i=0; i &lt; size; i++)
+	{
+		if ((splitPacketList[i]-&gt;reliability==UNRELIABLE || splitPacketList[i]-&gt;reliability==UNRELIABLE_SEQUENCED) &amp;&amp;
+			splitPacketList[i]-&gt;creationTime &gt;= newestUnreliableSplitPacket)
+		{
+			orderingIndexToDelete=splitPacketList[i]-&gt;orderingIndex;
+			newestUnreliableSplitPacket=splitPacketList[i]-&gt;creationTime;
+			found=true;
+		}
+	}
+
+	if (found &amp;&amp; time-newestUnreliableSplitPacket &gt; 5000)
+	{
+		// Delete all split packets that use orderingIndexToDelete
+		i=0;
+		while (i &lt; splitPacketList.size())
+		{
+			if (splitPacketList[i]-&gt;orderingIndex==orderingIndexToDelete)
+			{
+				temp=splitPacketList[i];
+				splitPacketList[i]=splitPacketList[splitPacketList.size()-1];
+				splitPacketList.del(); // Removes the last element
+				InternalPacketPool::Instance()-&gt;ReleasePointer(temp);
+			}
+			else
+				i++;
+		}
+	}
+}
+
 //-------------------------------------------------------------------------------------------------------
 // Creates a copy of the specified internal packet with data copied from the original starting at dataByteOffset for dataByteLength bytes.
 // Does not copy any split data parameters as that information is always generated does not have any reason to be copied
 //-------------------------------------------------------------------------------------------------------
-InternalPacket * ReliabilityLayer::CreateInternalPacketCopy(InternalPacket *original, int dataByteOffset, int dataByteLength)
+InternalPacket * ReliabilityLayer::CreateInternalPacketCopy(InternalPacket *original, int dataByteOffset, int dataByteLength, unsigned long time)
 {
 	InternalPacket *copy = InternalPacketPool::Instance()-&gt;GetPointer();
 #ifdef _DEBUG
@@ -1936,11 +2183,11 @@
 		copy-&gt;data=0;
 
 	copy-&gt;dataBitLength=dataByteLength&lt;&lt;3;
-	copy-&gt;creationTime = getTime();
+	copy-&gt;creationTime = time;
 	copy-&gt;isAcknowledgement=original-&gt;isAcknowledgement;
 	copy-&gt;nextActionTime=0;
 	copy-&gt;orderingIndex=original-&gt;orderingIndex;
-	copy-&gt;orderingStream=original-&gt;orderingStream;
+	copy-&gt;orderingChannel=original-&gt;orderingChannel;
 	copy-&gt;packetNumber=original-&gt;packetNumber;
 	copy-&gt;priority=original-&gt;priority;
 	copy-&gt;reliability=original-&gt;reliability;
@@ -1952,12 +2199,12 @@
 // Get the specified ordering list
 // LOCK THIS WHOLE BLOCK WITH reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
 //-------------------------------------------------------------------------------------------------------
-BasicDataStructures::LinkedList&lt;InternalPacket*&gt; *ReliabilityLayer::GetOrderingListAtOrderingStream(unsigned char orderingStream)
+BasicDataStructures::LinkedList&lt;InternalPacket*&gt; *ReliabilityLayer::GetOrderingListAtOrderingStream(unsigned char orderingChannel)
 {
-	if (orderingStream &gt;= orderingList.size())
+	if (orderingChannel &gt;= orderingList.size())
 		return 0;
 
-	return orderingList[orderingStream];
+	return orderingList[orderingChannel];
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1966,37 +2213,37 @@
 void ReliabilityLayer::AddToOrderingList(InternalPacket * internalPacket)
 {
 	#ifdef _DEBUG
-	assert(internalPacket-&gt;orderingStream&lt; NUMBER_OF_ORDERED_STREAMS);
+	assert(internalPacket-&gt;orderingChannel&lt; NUMBER_OF_ORDERED_STREAMS);
 	#endif
-	if (internalPacket-&gt;orderingStream &gt;= NUMBER_OF_ORDERED_STREAMS)	
+	if (internalPacket-&gt;orderingChannel &gt;= NUMBER_OF_ORDERED_STREAMS)	
 		return;
 
-	reliabilityLayerMutexes[orderingList_MUTEX].Lock();
-	if (internalPacket-&gt;orderingStream &gt;= orderingList.size() || orderingList[internalPacket-&gt;orderingStream]==0)
+	//reliabilityLayerMutexes[orderingList_MUTEX].Lock();
+	if (internalPacket-&gt;orderingChannel &gt;= orderingList.size() || orderingList[internalPacket-&gt;orderingChannel]==0)
 	{
 		// Need a linked list in this index
-		orderingList.replace(new BasicDataStructures::LinkedList&lt;InternalPacket*&gt;, 0, internalPacket-&gt;orderingStream);
-		(orderingList[internalPacket-&gt;orderingStream])-&gt;add(internalPacket);
-		reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
+		orderingList.replace(new BasicDataStructures::LinkedList&lt;InternalPacket*&gt;, 0, internalPacket-&gt;orderingChannel);
+		(orderingList[internalPacket-&gt;orderingChannel])-&gt;add(internalPacket);
+		//reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
 		return;
 	}
 	else
 	{
 		// Have a linked list in this index
-		if (orderingList[internalPacket-&gt;orderingStream]-&gt;size()==0)
+		if (orderingList[internalPacket-&gt;orderingChannel]-&gt;size()==0)
 		{
 			// The linked list is empty
-			(orderingList[internalPacket-&gt;orderingStream])-&gt;add(internalPacket);
+			(orderingList[internalPacket-&gt;orderingChannel])-&gt;add(internalPacket);
 		}
 		else
 		{
 			BasicDataStructures::LinkedList&lt;InternalPacket*&gt; *theList;
-			theList = GetOrderingListAtOrderingStream(internalPacket-&gt;orderingStream);
+			theList = GetOrderingListAtOrderingStream(internalPacket-&gt;orderingChannel);
 			// Add this packet in no particular order
 			theList-&gt;beginning();
 			theList-&gt;insert(internalPacket);
 		}
-		reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
+		//reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
 	}
 }
 
@@ -2005,17 +2252,16 @@
 // THIS WHOLE FUNCTION SHOULD BE LOCKED WITH
 // reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::InsertPacketIntoResendQueue(InternalPacket *internalPacket)
+void ReliabilityLayer::InsertPacketIntoResendQueue(InternalPacket *internalPacket, unsigned long time)
 {
-	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-
-	reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
+	//reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
 	if (lastAckTime==0 || resendQueue.size()==0)
-		lastAckTime=getTime(); // Start the timer for the ack of this packet if we aren't already waiting for an ack
-	reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
+		lastAckTime=time; // Start the timer for the ack of this packet if we aren't already waiting for an ack
+	//reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
 
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 	resendQueue.push(internalPacket);
-	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -2031,36 +2277,30 @@
 //-------------------------------------------------------------------------------------------------------
 // How long to wait between packet resends
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::SetLostPacketResendDelay(unsigned long i) {if (i &gt; 0) lostPacketResendDelay=i; if (lostPacketResendDelay&lt;1000) lostPacketResendDelay=1000;}
+void ReliabilityLayer::SetLostPacketResendDelay(unsigned long i)
+{
+	if (i &gt; 0) lostPacketResendDelay=i;
+	if (lostPacketResendDelay&lt;150) // To avoid unnecessary packetloss, this value should be UPDATE_THREAD_UPDATE_TIME + UPDATE_THREAD_POLL_TIME at a minimum
+		lostPacketResendDelay=150;
+}
 
 //-------------------------------------------------------------------------------------------------------
 // Statistics
 //-------------------------------------------------------------------------------------------------------
-double ReliabilityLayer::GetPacketlossPercentile(void) const {if 
-(sentPackets&gt;0) return (double)retransmittedPackets / (double)sentPackets; 
-else return 0.0;}
-unsigned long ReliabilityLayer::GetTransmittedPacketCount(void) const 
-{return sentPackets;}
-unsigned long ReliabilityLayer::GetTransmittedFrameCount(void) const 
-{return sentFrames;}
-unsigned long ReliabilityLayer::GetLostPacketCount(void) const {return 
-retransmittedPackets;}
-unsigned long ReliabilityLayer::GetReceivedPacketCount(void) const {return 
-receivedPacketsCount;}
-unsigned long ReliabilityLayer::GetBytesSent(void) const {return bytesSent;}
-unsigned long ReliabilityLayer::GetBytesReceived(void) const {return 
-bytesReceived;}
-unsigned long ReliabilityLayer::GetUnacknowledgedSentPacketListSize(void) 
-{return resendQueue.size();}
-unsigned long ReliabilityLayer::GetPacketOutputBufferSize(void)
+RakNetStatisticsStruct * const ReliabilityLayer::GetStatistics(void)
 {
-	int val=0; 
-	reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
-	for (int count=0; count&lt;NUMBER_OF_PRIORITIES; count++)
-		val+= sendQueue[count].size();
-	reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
-	return val;
+	int i;
+	for (i=0; i &lt; NUMBER_OF_PRIORITIES; i++)
+	{
+		statistics.messageSendBuffer[i]=sendQueue[i].size();
+	}
+
+	statistics.acknowlegementsPending=acknowledgementQueue.size();
+	statistics.messagesWaitingForReassembly=splitPacketList.size();
+	statistics.internalOutputQueueSize=outputQueue.size();
+	statistics.windowSize=windowSize;
+	statistics.lossySize=lossyWindowSize==MAXIMUM_WINDOW_SIZE+1 ? 0 : lossyWindowSize;
+	statistics.messagesOnResendQueue=resendQueue.size();
+
+	return &statistics;
 }
-unsigned long ReliabilityLayer::GetMaximumWindowSize(void) const {return windowSize;}
-unsigned long ReliabilityLayer::GetLastPacketReceivedTime(void) const {return lastPacketReceivedTime;}
-

Modified: trunk/source/libraries/raknet/ReliabilityLayer.h
===================================================================
--- trunk/source/libraries/raknet/ReliabilityLayer.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/ReliabilityLayer.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -21,23 +21,24 @@
 #include &quot;InternalPacket.h&quot;
 #include &quot;InternalPacketPool.h&quot;
 #include &quot;DataBlockEncryptor.h&quot;
+#include &quot;RakNetStatistics.h&quot;
 
 #define UDP_HEADER_SIZE 28
 #define NUMBER_OF_ORDERED_STREAMS 32 // 2^5
 
-const unsigned long TIMEOUT_TIME = 20000; // If no response to a reliable packet for this long kill the connection
+const unsigned long TIMEOUT_TIME = 10000; // If no response to a reliable packet for this long kill the connection
 // -----------------------------------------------------------------------------------------------------------------
 // If you change MAX_AVERAGE_PACKETS_PER_SECOND or TIMEOUT_TIME,
 // you must make sure RECEIVED_PACKET_LOG_LENGTH &lt; the range of PacketNumberType (held in InternalPacket.h)
 // -----------------------------------------------------------------------------------------------------------------
  // *** Pay attention to the value of RECEIVED_PACKET_LOG_LENGTH when changing this! ***
-const int MAX_AVERAGE_PACKETS_PER_SECOND=400;
+const int MAX_AVERAGE_PACKETS_PER_SECOND=6553; // 6553.5 is the maximum for an unsigned short
  
 // *** This value must be less than the range of PacketNumberType. PacketNumberType is in InternalPacket.h  ***
 const int RECEIVED_PACKET_LOG_LENGTH=(TIMEOUT_TIME/1000)*MAX_AVERAGE_PACKETS_PER_SECOND;
 // -----------------------------------------------------------------------------------------------------------------
 
-class BitStream;
+#include &quot;BitStream.h&quot;
 
 class ReliabilityLayer
 {
@@ -48,18 +49,23 @@
 	// Destructor
 	~ReliabilityLayer();
 
-	// Resets the layer for reuse
+	// Resets the layer for reuse.
+	// Callable from multiple threads
 	void Reset(void);
 
 	// Sets up encryption
+	// Callable from multiple threads
 	void SetEncryptionKey(const unsigned char *key);
 
 	// Assign a socket for the reliability layer to use for writing
+	// Callable from multiple threads
 	void SetSocket(SOCKET s);
 
 	// Get the socket held by the reliability layer
+	// Callable from multiple threads
 	SOCKET GetSocket(void);
 
+	// Must be called by the same thread as update
 	// Packets are read directly from the socket layer and skip the reliability layer  because unconnected players do not use the reliability layer
 	// This function takes packet data after a player has been confirmed as connected.  The game should not use that data directly
 	// because some data is used internally, such as packet acknowledgement and split packets
@@ -67,17 +73,20 @@
 	bool HandleSocketReceiveFromConnectedPlayer(char *buffer, int length);
 
 	// This gets an end-user packet already parsed out. Returns number of BITS put into the buffer
+	// Callable from multiple threads
 	int Receive(char**data);
 
 	// Puts data on the send queue
 	// bitStream contains the data to send
 	// priority is what priority to send the data at
 	// reliability is what reliability to use
-	// ordering stream is from 0 to 31 and specifies what stream to use
-	bool Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, unsigned char orderingStream, bool makeDataCopy, int MTUSize);
+	// ordering channel is from 0 to 31 and specifies what stream to use
+	// Callable from multiple threads
+	bool Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, unsigned char orderingChannel, bool makeDataCopy, int MTUSize);
 
 	// Run this once per game cycle.  Handles internal lists and actually does the send
-	void Update(SOCKET s, PlayerID playerId, int MTUSize);
+	// Must be called by the same thread as HandleSocketReceiveFromConnectedPlayer
+	void Update(SOCKET s, PlayerID playerId, int MTUSize, unsigned long time);
 
 	// If Read returns -1 and this returns true then a modified packet was detected
 	bool IsCheater(void) const;
@@ -89,44 +98,36 @@
 	void SetLostPacketResendDelay(unsigned long i);
 
 	// Statistics
-	double GetPacketlossPercentile(void) const;
-	unsigned long GetTransmittedPacketCount(void) const;
-	unsigned long GetTransmittedFrameCount(void) const;
-	unsigned long GetLostPacketCount(void) const;
-	unsigned long GetReceivedPacketCount(void) const;
-	unsigned long GetBytesSent(void) const;
-	unsigned long GetBytesReceived(void) const;
-	unsigned long GetUnacknowledgedSentPacketListSize(void);
-	unsigned long GetPacketOutputBufferSize(void);
-	unsigned long GetMaximumWindowSize(void) const;
-	unsigned long GetLastPacketReceivedTime(void) const;
+	RakNetStatisticsStruct * const GetStatistics(void);
+
 private:
 	// Returns true if we can or should send a frame.  False if we should not
-	bool IsFrameReady(void);
+	bool IsFrameReady(unsigned long time);
 
 	// Generates a frame (coalesced packets)
-	void GenerateFrame(BitStream *output, int MTUSize, bool *reliableDataSent);
+	void GenerateFrame(RakNet::BitStream *output, int MTUSize, bool *reliableDataSent,unsigned long time);
 
 	// Writes a bitstream to the socket
-	void SendBitStream(SOCKET s, PlayerID playerId, BitStream *bitStream);
+	void SendBitStream(SOCKET s, PlayerID playerId, RakNet::BitStream *bitStream);
 
 	// Parse an internalPacket and create a bitstream to represent this data
-	void WriteToBitStreamFromInternalPacket(BitStream *bitStream, const InternalPacket *const internalPacket);
+	// Returns number of bits used
+	int WriteToBitStreamFromInternalPacket(RakNet::BitStream *bitStream, const InternalPacket *const internalPacket);
 
 	// Parse a bitstream and create an internal packet to represent this data
-	InternalPacket* CreateInternalPacketFromBitStream(BitStream *bitStream);
+	InternalPacket* CreateInternalPacketFromBitStream(RakNet::BitStream *bitStream, unsigned long time);
 
 	// Does what the function name says
 	void RemovePacketFromResendQueueAndDeleteOlderReliableSequenced(PacketNumberType packetNumber);
 
 	// Acknowledge receipt of the packet with the specified packetNumber
-	void SendAcknowledgementPacket(PacketNumberType packetNumber);
+	void SendAcknowledgementPacket(PacketNumberType packetNumber, unsigned long time);
 
 	// This will return true if we should not send at this time
 	bool IsSendThrottled(void);
 
 	// We lost a packet
-	void UpdatePacketloss(void);
+	void UpdatePacketloss(unsigned long time);
 
 	// Parse an internalPacket and figure out how many header bits would be written.  Returns that number
 	int GetBitStreamHeaderLength(const InternalPacket *const internalPacket);
@@ -137,10 +138,10 @@
 	// Check the SHA1 code
 	bool CheckSHA1(char code[SHA1_LENGTH], unsigned char * const buffer, unsigned long nbytes);
 
-	// Search the specified list for sequenced packets on the specified ordering stream, optionally skipping those with splitPacketId, and delete them
-	void  DeleteSequencedPacketsInList(unsigned char orderingStream, BasicDataStructures::List&lt;InternalPacket*&gt;&amp;theList, int splitPacketId=-1);
+	// Search the specified list for sequenced packets on the specified ordering channel, optionally skipping those with splitPacketId, and delete them
+	void  DeleteSequencedPacketsInList(unsigned char orderingChannel, BasicDataStructures::List&lt;InternalPacket*&gt;&amp;theList, int splitPacketId=-1);
 	// Search the specified list for sequenced packets with a value less than orderingIndex and delete them
-	void DeleteSequencedPacketsInList(unsigned char orderingStream, BasicDataStructures::Queue&lt;InternalPacket*&gt;&amp;theList);
+	void DeleteSequencedPacketsInList(unsigned char orderingChannel, BasicDataStructures::Queue&lt;InternalPacket*&gt;&amp;theList);
 
 	// Returns true if newPacketOrderingIndex is older than the waitingForPacketOrderingIndex
 	bool IsOlderOrderedPacket(unsigned char newPacketOrderingIndex, unsigned char waitingForPacketOrderingIndex);
@@ -152,15 +153,18 @@
 	void InsertIntoSplitPacketList(InternalPacket * internalPacket);
 
 	// Take all split chunks with the specified splitPacketId and try to reconstruct a packet.  If we can, allocate and return it.  Otherwise return 0
-	InternalPacket * BuildPacketFromSplitPacketList(unsigned long splitPacketId);
+	InternalPacket * BuildPacketFromSplitPacketList(unsigned long splitPacketId,unsigned long time);
 
+	// Delete any unreliable split packets that have long since expired
+	void DeleteOldUnreliableSplitPackets(unsigned long time);
+
 	// Creates a copy of the specified internal packet with data copied from the original starting at dataByteOffset for dataByteLength bytes.
 	// Does not copy any split data parameters as that information is always generated does not have any reason to be copied
-	InternalPacket * CreateInternalPacketCopy(InternalPacket *original, int dataByteOffset, int dataByteLength);
+	InternalPacket * CreateInternalPacketCopy(InternalPacket *original, int dataByteOffset, int dataByteLength, unsigned long time);
 
 	// Get the specified ordering list
 	// LOCK THIS WHOLE BLOCK WITH reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
-	BasicDataStructures::LinkedList&lt;InternalPacket*&gt; *GetOrderingListAtOrderingStream(unsigned char orderingStream);
+	BasicDataStructures::LinkedList&lt;InternalPacket*&gt; *GetOrderingListAtOrderingStream(unsigned char orderingChannel);
 
 	// Add the internal packet to the ordering list in order based on order index
 	void AddToOrderingList(InternalPacket * internalPacket);
@@ -168,10 +172,12 @@
 	// Inserts a packet into the resend list in order
 	// THIS WHOLE FUNCTION SHOULD BE LOCKED WITH
 	// reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-	void InsertPacketIntoResendQueue(InternalPacket *internalPacket);
+	void InsertPacketIntoResendQueue(InternalPacket *internalPacket, unsigned long time);
 
-	// Frees all allocated memory
-	void FreeMemory(void);
+	// Memory handling
+	void FreeMemory(bool freeAllImmediately);
+	void FreeThreadedMemory(void);
+	void FreeThreadSafeMemory(void);
 	
 	// Initialize the variables
 	void InitializeVariables(void);
@@ -179,16 +185,19 @@
 	// STUFF TO MUTEX HERE
 	enum
 	{
-		splitPacketList_MUTEX,
-		sendQueue_MUTEX,
-		resendQueue_MUTEX,
-		orderingList_MUTEX,
-		acknowledgementQueue_MUTEX,
-		outputQueue_MUTEX,
+		// splitPacketList_MUTEX, // We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		sendQueueSystemPriority_MUTEX,
+		sendQueueHighPriority_MUTEX,
+		sendQueueMediumPriority_MUTEX,
+		sendQueueLowPriority_MUTEX,
+		//resendQueue_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		//orderingList_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		//acknowledgementQueue_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		// outputQueue_MUTEX,// We don't have to mutex this as long as Recieve and HandleSocketReceiveFromConnectedPlayer are called by the same thread
 		packetNumber_MUTEX,
-		windowSize_MUTEX,
-		lastAckTime_MUTEX,
-		updateBitStream_MUTEX,
+		// windowSize_MUTEX, // Causes long delays for some reason
+		//lastAckTime_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		//updateBitStream_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
 		waitingForOrderedPacketWriteIndex_MUTEX,
 		waitingForSequencedPacketWriteIndex_MUTEX,
 		NUMBER_OF_RELIABILITY_LAYER_MUTEXES
@@ -202,7 +211,7 @@
 	PacketNumberType packetNumber;
 	//unsigned long windowSize;
 	unsigned long lastAckTime;
-	BitStream updateBitStream;
+	RakNet::BitStream updateBitStream;
 	unsigned char waitingForOrderedPacketWriteIndex[NUMBER_OF_ORDERED_STREAMS], waitingForSequencedPacketWriteIndex[NUMBER_OF_ORDERED_STREAMS];
 	// Used for flow control (changed to regular TCP sliding window)
 	//	unsigned long maximumWindowSize, bytesSentSinceAck;
@@ -211,11 +220,12 @@
 	// STUFF TO NOT MUTEX HERE (called from non-conflicting threads, or value is not important)
 	unsigned char waitingForOrderedPacketReadIndex[NUMBER_OF_ORDERED_STREAMS],waitingForSequencedPacketReadIndex[NUMBER_OF_ORDERED_STREAMS];
 	bool deadConnection, cheater;
-	unsigned long lastPacketSendTime,retransmittedPackets, sentPackets, sentFrames, receivedPacketsCount, bytesSent, bytesReceived,lastPacketReceivedTime;
+//	unsigned long lastPacketSendTime,retransmittedFrames, sentPackets, sentFrames, receivedPacketsCount, bytesSent, bytesReceived,lastPacketReceivedTime;
 	unsigned long lostPacketResendDelay;
 	unsigned long splitPacketId;
 	unsigned long receivedPackets[RECEIVED_PACKET_LOG_LENGTH];
 	unsigned long blockWindowIncreaseUntilTime;
+	RakNetStatisticsStruct statistics;
 
 	// Windowing algorithm:
 	// Start at a minimum size
@@ -231,6 +241,8 @@
 	#ifdef __USE_IO_COMPLETION_PORTS
 	SOCKET readWriteSocket;
 	#endif
+
+	bool freeThreadedMemoryOnNextUpdate; // This variable is so that free memory can be called by only the update thread so we don't have to mutex things so much
 };
 
 #endif

Modified: trunk/source/libraries/raknet/SHA1.h
===================================================================
--- trunk/source/libraries/raknet/SHA1.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/SHA1.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -21,11 +21,8 @@
 #include &lt;stdio.h&gt; // Needed for file access
 #include &lt;memory.h&gt; // Needed for memset and memcpy
 #include &lt;string.h&gt; // Needed for strcat and strcpy
+#include &quot;Types.h&quot;
 
-#ifdef _WINDOWS
-#define LITTLE_ENDIAN
-#endif
-
 #define MAX_FILE_READ_BUFFER 8000
 #define SHA1_LENGTH 20
 
@@ -33,7 +30,7 @@
 {
 public:
 	// Rotate x bits to the left
-	#define ROL32(value, bits) (((value)&lt;&lt;(bits))|((value)&gt;&gt;(32-(bits))))
+//	#define ROL32(value, bits) (((value)&lt;&lt;(bits))|((value)&gt;&gt;(32-(bits))))
 
 	#ifdef LITTLE_ENDIAN
 		#define SHABLK0(i) (block-&gt;l[i] = (ROL32(block-&gt;l[i],24) &amp; 0xFF00FF00) \

Modified: trunk/source/libraries/raknet/SimpleMutex.cpp
===================================================================
--- trunk/source/libraries/raknet/SimpleMutex.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/SimpleMutex.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -14,8 +14,9 @@
 SimpleMutex::SimpleMutex()
 {
 #ifdef _WIN32
-	hMutex = CreateMutex(NULL, FALSE, 0);
-	assert(hMutex);
+//	hMutex = CreateMutex(NULL, FALSE, 0);
+//	assert(hMutex);
+	InitializeCriticalSection(&amp;criticalSection);
 #else
 	int error = pthread_mutex_init(&amp;hMutex, 0);
 	assert(error==0);
@@ -25,7 +26,8 @@
 SimpleMutex::~SimpleMutex()
 {
 #ifdef _WIN32
-	CloseHandle(hMutex);
+//	CloseHandle(hMutex);
+	DeleteCriticalSection(&amp;criticalSection);
 #else
 	pthread_mutex_destroy(&amp;hMutex);
 #endif
@@ -40,6 +42,7 @@
 void SimpleMutex::Lock(void)
 {
 	#ifdef _WIN32
+	/*
 	DWORD d = WaitForSingleObject(hMutex, INFINITE);
 	#ifdef _DEBUG
 	if (d==WAIT_FAILED)
@@ -67,7 +70,9 @@
 	}
 
 	assert(d==WAIT_OBJECT_0);
-	#endif
+	*/
+	EnterCriticalSection(&amp;criticalSection);
+
 	#else
 	int error = pthread_mutex_lock(&amp;hMutex);
 	assert(error==0);
@@ -77,7 +82,8 @@
 void SimpleMutex::Unlock(void)
 {
 #ifdef _WIN32
-	ReleaseMutex(hMutex);
+//	ReleaseMutex(hMutex);
+	LeaveCriticalSection(&amp;criticalSection);
 #else
 	int error = pthread_mutex_unlock(&amp;hMutex);
 	assert(error==0);

Modified: trunk/source/libraries/raknet/SimpleMutex.h
===================================================================
--- trunk/source/libraries/raknet/SimpleMutex.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/SimpleMutex.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -26,7 +26,8 @@
 	void Unlock(void);
 private:
 	#ifdef _WIN32
-	HANDLE hMutex;
+	//HANDLE hMutex;
+	CRITICAL_SECTION criticalSection; // Docs say this is faster than a mutex for single process access
 	#else
 	pthread_mutex_t hMutex;
 	#endif

Modified: trunk/source/libraries/raknet/SocketLayer.cpp
===================================================================
--- trunk/source/libraries/raknet/SocketLayer.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/SocketLayer.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -17,6 +17,7 @@
 #else
 #include &lt;string.h&gt; // memcpy
 #include &lt;unistd.h&gt;
+#include &lt;fcntl.h&gt;
 #endif
 
 #include &quot;ExtendedOverlappedPool.h&quot;
@@ -75,14 +76,14 @@
 	}
 }
 
-SOCKET SocketLayer::Connect(SOCKET writeSocket, PlayerID playerId)
+SOCKET SocketLayer::Connect(SOCKET writeSocket, unsigned long binaryAddress, unsigned short port)
 {
 	assert(writeSocket!=INVALID_SOCKET);
 	sockaddr_in connectSocketAddress;
 
 	connectSocketAddress.sin_family = AF_INET;
-	connectSocketAddress.sin_port = htons(playerId.port);
-	connectSocketAddress.sin_addr.s_addr = playerId.binaryAddress;
+	connectSocketAddress.sin_port = htons(port);
+	connectSocketAddress.sin_addr.s_addr = binaryAddress;
 
 	if (connect(writeSocket, (struct sockaddr *)&amp;connectSocketAddress, sizeof(struct sockaddr)) != 0)
 	{
@@ -147,6 +148,38 @@
 		#endif
 	}
 
+	//Set non-blocking
+#ifdef _WIN32
+	unsigned long nonblocking = 1;
+	if (ioctlsocket(listenSocket, FIONBIO, &amp;nonblocking)!=0)
+	{
+		assert(0);
+		return INVALID_SOCKET;
+	}
+#else
+	if (fcntl(listenSocket, F_SETFL, O_NONBLOCK)!=0)
+	{
+		assert(0);
+		return INVALID_SOCKET;
+	}
+#endif
+
+	// Set broadcast capable
+	if ( setsockopt(listenSocket, SOL_SOCKET, SO_BROADCAST,(char *)&amp;sock_opt, sizeof(sock_opt)) == -1)
+	{
+#if defined(_WIN32) &amp;&amp; defined(_DEBUG)
+		DWORD dwIOError = GetLastError();
+		LPVOID messageBuffer;
+		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 	  FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 
+			NULL, dwIOError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),// Default language
+			(LPTSTR) &amp;messageBuffer, 0, NULL); 
+		// something has gone wrong here... 
+		printf(&quot;setsockopt(SO_BROADCAST) failed:Error code - %d\n%s&quot;,dwIOError, messageBuffer ); 
+		//Free the buffer. 
+		LocalFree(messageBuffer ); 
+#endif
+	}
+
 	// Listen on our designated Port#
 	listenerSocketAddress.sin_port = htons(port);
 
@@ -209,7 +242,7 @@
 }
 
 // Start an asynchronous read using the specified socket.
-bool SocketLayer::AssociateSocketWithCompletionPortAndRead(SOCKET readSocket, PlayerID playerId, RakPeer *rakPeer)
+bool SocketLayer::AssociateSocketWithCompletionPortAndRead(SOCKET readSocket, unsigned long binaryAddress, unsigned short port, RakPeer *rakPeer)
 {
 	#ifdef __USE_IO_COMPLETION_PORTS
 	assert(readSocket!=INVALID_SOCKET);
@@ -219,7 +252,8 @@
 
 	ExtendedOverlappedStruct* eos = ExtendedOverlappedPool::Instance()-&gt;GetPointer();
 	memset(&amp;(eos-&gt;overlapped), 0, sizeof(OVERLAPPED));
-	eos-&gt;playerId=playerId;
+	eos-&gt;binaryAddress=binaryAddress;
+	eos-&gt;port=port;
 	eos-&gt;rakPeer=rakPeer;
 	eos-&gt;length=MAXIMUM_MTU_SIZE;
 
@@ -239,13 +273,8 @@
 	return true;
 }
 
-int SocketLayer::RecvFrom(SOCKET s, RakPeer *rakPeer)
+bool SocketLayer::RecvFrom(SOCKET s, RakPeer *rakPeer, int *errorCode)
 {
-	if (s==INVALID_SOCKET)
-	{
-		return SOCKET_ERROR;
-	}
-
 	int len;
 	char data[MAXIMUM_MTU_SIZE];
 	sockaddr_in sa;
@@ -260,6 +289,12 @@
 	sa.sin_addr.s_addr=0;
 #endif
 
+	if (s==INVALID_SOCKET)
+	{
+		*errorCode=SOCKET_ERROR;
+		return false;
+	}
+
 	len = recvfrom(s, data, MAXIMUM_MTU_SIZE, 0, (sockaddr*)&amp;sa, (socklen_t*)&amp;len2);
 
 //	if (len&gt;0)
@@ -269,9 +304,10 @@
 	{
 #ifdef _DEBUG
 		printf(&quot;Error: recvfrom returned 0 on a connectionless blocking call\non port %i.  This is a bug with Zone Alarm.  Please turn off Zone Alarm.\n&quot;,ntohs(sa.sin_port));
-#endif
 		assert(0);
-		return 0;
+#endif		
+		*errorCode=SOCKET_ERROR;
+		return false;
 	}
 
 	if (len!=SOCKET_ERROR)
@@ -282,13 +318,20 @@
 		//	strcpy(ip, &quot;127.0.0.1&quot;);
         ProcessNetworkPacket(sa.sin_addr.s_addr, portnum,data, len, rakPeer);
 
-		return 0;
+		return true;
 	}
 	else
 	{
 
-#if defined(_WIN32)
+		*errorCode=0;
+
+#if defined(_WIN32) &amp;&amp; defined(_DEBUG)
 		DWORD dwIOError = WSAGetLastError();
+		
+		if (dwIOError == WSAEWOULDBLOCK)
+		{
+			return false;
+		}
 
 		if (dwIOError==WSAECONNRESET)
 		{
@@ -296,7 +339,8 @@
 			printf(&quot;A previous send operation resulted in an ICMP Port Unreachable message.\n&quot;);
 			#endif
 
-			return dwIOError;
+			*errorCode=dwIOError;
+			return false;
 		}
 		else
 		{
@@ -319,10 +363,10 @@
 #endif
 	}
 
-	return 0;
+	return false;
 }
 
-int SocketLayer::SendTo(SOCKET s, char *data, int length, PlayerID playerId)
+int SocketLayer::SendTo(SOCKET s, char *data, int length, unsigned long binaryAddress, unsigned short port)
 {
 	if (s==INVALID_SOCKET)
 	{
@@ -331,8 +375,8 @@
 
 	int len;
 	sockaddr_in sa;
-	sa.sin_port = htons(playerId.port);
-	sa.sin_addr.s_addr = playerId.binaryAddress;
+	sa.sin_port = htons(port);
+	sa.sin_addr.s_addr = binaryAddress;
 	sa.sin_family = AF_INET;
 	do {
 		len = sendto(s, data, length, 0, (const sockaddr*)&amp;sa, sizeof(struct sockaddr_in));
@@ -374,10 +418,9 @@
 
 int SocketLayer::SendTo(SOCKET s, char *data, int length, char ip[16], unsigned short port)
 {
-	PlayerID temp;
-	temp.binaryAddress=inet_addr(ip);
-	temp.port=port;
-	return SendTo(s,data,length,temp);
+	unsigned long binaryAddress;
+	binaryAddress=inet_addr(ip);
+	return SendTo(s,data,length,binaryAddress,port);
 }
 
 void SocketLayer::GetMyIP(char ipList[10][16])

Modified: trunk/source/libraries/raknet/SocketLayer.h
===================================================================
--- trunk/source/libraries/raknet/SocketLayer.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/SocketLayer.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -37,21 +37,20 @@
 	SocketLayer();
 	~SocketLayer();
 	static inline SocketLayer* Instance() {return &I;}
-	SOCKET Connect(SOCKET writeSocket, PlayerID playerId);
+	SOCKET Connect(SOCKET writeSocket, unsigned long binaryAddress, unsigned short port);
 	SOCKET CreateBoundSocket(unsigned short port, bool blockingSocket); // Creates a socket to listen for incoming connections on the specified port
 	const char* DomainNameToIP(const char *domainName);
 	#ifdef __USE_IO_COMPLETION_PORTS
 	void AssociateSocketWithCompletionPort(SOCKET socket, ClientContextStruct* completionKey);
 #endif
 	// Start an asynchronous read using the specified socket.  The callback will use the specified PlayerID (associated with this socket) and call either the client or the server callback (one or the other should be 0)
-	bool AssociateSocketWithCompletionPortAndRead(SOCKET readSocket, PlayerID playerId, RakPeer* rakPeer);
+	bool AssociateSocketWithCompletionPortAndRead(SOCKET readSocket, unsigned long binaryAddress, unsigned short port, RakPeer* rakPeer);
 	void Write(SOCKET writeSocket, const char* data, int length);
-	// Given a listen socket and an event object triggered when a new connection occurs, return the new socket of the new connection along with the IP and port of the caller
-	// Returns the error code on failure, 0 on success
-	int RecvFrom(SOCKET s, RakPeer *rakPeer);
+	// Returns true if you successfully read data
+	bool RecvFrom(SOCKET s, RakPeer *rakPeer, int *errorCode);
 	void GetMyIP(char ipList[10][16]);
 	int SendTo(SOCKET s, char *data, int length, char ip[16], unsigned short port);
-	int SendTo(SOCKET s, char *data, int length, PlayerID playerId);
+	int SendTo(SOCKET s, char *data, int length, unsigned long binaryAddress, unsigned short port);
 	
 	private:
 	static bool socketLayerStarted;

Modified: trunk/source/libraries/raknet/StringCompressor.cpp
===================================================================
--- trunk/source/libraries/raknet/StringCompressor.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/StringCompressor.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -3,10 +3,12 @@
 #include &quot;BitStream.h&quot;
 #include &lt;assert.h&gt;
 #include &lt;string.h&gt;
+#include &lt;memory.h&gt;
 
 StringCompressor StringCompressor::instance;
 
-unsigned long englishCharacterFrequencies[] =
+// Generated from various chat logs on the internet.
+unsigned long englishCharacterFrequencies[256] =
 {
 0,
 0,
@@ -18,9 +20,10 @@
 0,
 0,
 0,
-5655,
+722,
 0,
 0,
+2,
 0,
 0,
 0,
@@ -39,101 +42,101 @@
 0,
 0,
 0,
+11084,
+58,
+63,
+1,
 0,
-64995,
-2,
-515,
-3,
-3,
-5,
-13,
-125,
-289,
-294,
+31,
 0,
+317,
+64,
+64,
+44,
 0,
-1968,
-558,
-4849,
-91,
-244,
-795,
-459,
-323,
-379,
-210,
-155,
-138,
-280,
-590,
-150,
-46,
-4,
-3,
-4,
+695,
+62,
+980,
+266,
 69,
-28,
-595,
-161,
-950,
-364,
-430,
-326,
-221,
-308,
-712,
-189,
+67,
 56,
-181,
-318,
-426,
-256,
-676,
+7,
+73,
+3,
 14,
-458,
-1247,
-853,
-253,
-105,
-297,
-53,
-81,
 2,
-235,
-0,
-235,
-0,
+69,
+1,
+167,
+9,
+1,
 2,
+25,
+94,
 0,
-11400,
-2156,
-6665,
-5543,
-19692,
-3186,
-2759,
-5614,
-12742,
+195,
+139,
+34,
+96,
+48,
+103,
+56,
+125,
+653,
+21,
+5,
+23,
+64,
+85,
+44,
+34,
+7,
+92,
+76,
+147,
+12,
+14,
 57,
-1191,
-6009,
-4271,
-11288,
-13376,
-3619,
-106,
-10492,
-12069,
-14885,
-5462,
-1664,
-1850,
-265,
-3591,
-169,
+15,
+39,
+15,
+1,
+1,
+1,
+2,
+3,
 0,
+3611,
+845,
+1077,
+1884,
+5870,
+841,
+1057,
+2501,
+3212,
+164,
+531,
+2019,
+1330,
+3056,
+4037,
+848,
+47,
+2586,
+2919,
+4771,
+1707,
+535,
+1106,
+152,
+1243,
+100,
 0,
+2,
 0,
+10,
 0,
 0,
 0,
@@ -262,12 +265,12 @@
 0,
 0,
 0,
-0,
 0
 };
 
 StringCompressor::StringCompressor()
 {
+	huffmanEncodingTree=0;
 }
 
 void StringCompressor::GenerateHuffmanEncodingTree(void)
@@ -275,18 +278,41 @@
 	huffmanEncodingTree = new HuffmanEncodingTree;
 	huffmanEncodingTree-&gt;GenerateFromFrequencyTable(englishCharacterFrequencies);
 }
+void StringCompressor::GenerateTreeFromStrings(unsigned char *input, unsigned inputLength)
+{
+	unsigned index;
+	unsigned long frequencyTable[256];
+
+	if (inputLength==0)
+		return;
+
+	// Zero out the frequency table
+	memset(frequencyTable, 0, sizeof(frequencyTable));
+
+	// Generate the frequency table from the strings
+	for (index=0; index &lt; inputLength; index++);
+		frequencyTable[input[index]]++;
+
+	// Delete the old tree, if there is done
+	if (huffmanEncodingTree)
+		delete huffmanEncodingTree;
+
+	// Build the tree
+	huffmanEncodingTree = new HuffmanEncodingTree;
+	huffmanEncodingTree-&gt;GenerateFromFrequencyTable(frequencyTable);
+}
 StringCompressor::~StringCompressor()
 {
 	if (huffmanEncodingTree)
 		delete huffmanEncodingTree;
 }
 
-void StringCompressor::EncodeString(char *input, int maxCharsToWrite, BitStream *output)
+void StringCompressor::EncodeString(char *input, int maxCharsToWrite, RakNet::BitStream *output)
 {
 	if (input==0)
 		return;
 
-	BitStream encodedBitStream;
+	RakNet::BitStream encodedBitStream;
 	unsigned short stringBitLength;
 	int charsToWrite;
 
@@ -300,12 +326,12 @@
 
 	huffmanEncodingTree-&gt;EncodeArray((unsigned char*) input, charsToWrite, &amp;encodedBitStream);
 
-	stringBitLength = encodedBitStream.GetNumberOfBitsUsed();
+	stringBitLength = (unsigned short)encodedBitStream.GetNumberOfBitsUsed();
 	output-&gt;WriteCompressed(stringBitLength);
 	output-&gt;WriteBits(encodedBitStream.GetData(), stringBitLength);
 }
 
-void StringCompressor::DecodeString(char *output, int maxCharsToWrite, BitStream *input)
+bool StringCompressor::DecodeString(char *output, int maxCharsToWrite, RakNet::BitStream *input)
 {
 	unsigned short stringBitLength;
 	int bytesInStream;
@@ -315,14 +341,18 @@
 
 	output[0]=0;
 
-	
 	if (input-&gt;ReadCompressed(stringBitLength)==false)
-		return;
+		return false;
 
+	if (input-&gt;GetNumberOfUnreadBits() &lt; stringBitLength)
+		return false;
+
 	bytesInStream=huffmanEncodingTree-&gt;DecodeArray(input, stringBitLength, maxCharsToWrite, (unsigned char*) output);
 	if (bytesInStream &lt; maxCharsToWrite)
 		output[bytesInStream]=0;
 	else
 		output[maxCharsToWrite-1]=0;
+
+	return true;
 }
 

Modified: trunk/source/libraries/raknet/StringCompressor.h
===================================================================
--- trunk/source/libraries/raknet/StringCompressor.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/StringCompressor.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -3,8 +3,8 @@
 #ifndef __STRING_COMPRESSOR_H
 #define __STRING_COMPRESSOR_H
 
+#include &quot;BitStream.h&quot;
 class HuffmanEncodingTree;
-class BitStream;
 
 class StringCompressor
 {
@@ -14,12 +14,17 @@
 	// static function because only static functions can access static members
 	static inline StringCompressor* Instance() {return &instance;}
 
+	// Given an array of strings, such as a chat log, generate the optimal encoding tree for it.
+	// This function is optional and if it is not called a default tree will be used instead.
+	void GenerateTreeFromStrings(unsigned char *input, unsigned inputLength);
+
 	// Writes input to output, compressed.  Takes care of the null terminator for you
-	void EncodeString(char *input, int maxCharsToWrite, BitStream *output);
+	void EncodeString(char *input, int maxCharsToWrite, RakNet::BitStream *output);
 
 	// Writes input to output, uncompressed.  Takes care of the null terminator for you.
 	// maxCharsToWrite should be the allocated size of output
-	void DecodeString(char *output, int maxCharsToWrite, BitStream *input);
+	bool DecodeString(char *output, int maxCharsToWrite, RakNet::BitStream *input);
+
 private:
 	void GenerateHuffmanEncodingTree(void);
 	StringCompressor();


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000048.html">[Tw-light-svn] r100 - in trunk: gamedata/default_ini source/util
</A></li>
	<LI>Next message: <A HREF="000050.html">[Tw-light-svn] r102 - trunk/source/libraries/raknet
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#49">[ date ]</a>
              <a href="thread.html#49">[ thread ]</a>
              <a href="subject.html#49">[ subject ]</a>
              <a href="author.html#49">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/tw-light-svn">More information about the Tw-light-svn
mailing list</a><br>
</body></html>
