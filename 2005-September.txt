From yurand at berlios.de  Sun Sep 18 21:24:02 2005
From: yurand at berlios.de (Yura Semashko at BerliOS)
Date: Sun, 18 Sep 2005 21:24:02 +0200
Subject: [Tw-light-svn] r191 - trunk/source/melee
Message-ID: <200509181924.j8IJO2Ke026916@sheep.berlios.de>

Author: yurand
Date: 2005-09-18 21:23:58 +0200 (Sun, 18 Sep 2005)
New Revision: 191

Modified:
   trunk/source/melee/mview.cpp
Log:
Adding "dynamic" view, thanks to Corona688

Modified: trunk/source/melee/mview.cpp
===================================================================
--- trunk/source/melee/mview.cpp	2005-08-31 01:38:49 UTC (rev 190)
+++ trunk/source/melee/mview.cpp	2005-09-18 19:23:58 UTC (rev 191)
@@ -531,9 +531,80 @@
   return;
 }
 
+/**
+ * "Dynamic" view:  hero-centered intelligent zooming for multiple
+ * ships.
+ *
+ * It has a 'default' zoom level that it gravitates toward, which is
+ * fairly large.  Nearby ships draw the focus down to just it and the 
+ * player in a linear way -- when there are several nearby ships, the
+ * focii smoothly balance.
+ */
+class View_Dynamic : public View {
+  double cutoff;
+  double f,power;
+  double max, min;
+public:
+  virtual void calculate(Game *game);
+  virtual void init(View *old);  
+};
 
+void View_Dynamic::init(View *old)
+{ STACKTRACE
+  View::init(old);
+  power=5;
+  f = 2000;
+  min = 480;//480;
+  max = 480000;
+  cutoff=2500;
+  return;
+}
 
+void View_Dynamic::calculate (Game *game) {STACKTRACE
 
+  int i;
+  CameraPosition n = camera;
+  SpaceLocation *c = NULL;
+  if (game->num_focuses) c = game->focus[game->focus_index]->get_focus();
+
+  if (key_pressed(key_zoom_in))  f /= 1 + 0.002 * frame_time;
+  if (key_pressed(key_zoom_out)) f *= 1 + 0.002 * frame_time;
+
+  if(c!=NULL)
+  {
+    float z=f*power;     // The sum of the zooming factors
+    float tweight=power; // The sum of the factor weights
+
+    for(i=0; i<=game->gametargets.N; i++)
+    {
+      SpaceObject *obj;
+      if(i==game->gametargets.N)
+        obj=c->nearest_planet();
+      else
+        obj=game->gametargets.item[i];
+      if(obj==NULL) continue;
+
+      if((c != obj) &&(obj->isPlanet() || obj->isShip()))
+      {
+        float dist=c->distance(obj);
+        if(dist>cutoff) continue;
+        float weight=(22000*22000)/(dist*dist);
+
+        z+=(weight*dist*2);
+        tweight+=weight;
+      }
+    }
+
+    n.z=z/tweight;
+    if(n.z < min) n.z=min;
+    else if(n.z > max) n.z=max;
+  }
+
+  focus ( &n, c );
+  track ( n, frame_time );
+  return;
+}
+
 class View_Hero : public View {
   double f;
   double max, min;
@@ -551,6 +622,7 @@
   return;
 }
 
+
 void View_Hero::calculate (Game *game) {STACKTRACE
 					  CameraPosition n = camera;
  if (key_pressed(key_zoom_in))  n.z /= 1 + 0.002 * frame_time;
@@ -573,7 +645,6 @@
 
 
 
-
 class View_Enemy : public View {
 public:
   virtual void calculate(Game *game);
@@ -1047,4 +1118,4 @@
 REGISTER_VIEW ( View_Split3, "Split_3_Horizontal" );
 REGISTER_VIEW ( View_Split4, "Split_4_Quad" );
 REGISTER_VIEW ( View_Everything, "Everything" );
-
+REGISTER_VIEW ( View_Dynamic, "Dynamic" );



From yurand at berlios.de  Sun Sep 18 21:57:14 2005
From: yurand at berlios.de (Yura Semashko at BerliOS)
Date: Sun, 18 Sep 2005 21:57:14 +0200
Subject: [Tw-light-svn] r192 - in trunk: . gamedata/default_ini source source/libraries/jpgalleg source/other source/util
Message-ID: <200509181957.j8IJvEpQ028577@sheep.berlios.de>

Author: yurand
Date: 2005-09-18 21:57:13 +0200 (Sun, 18 Sep 2005)
New Revision: 192

Modified:
   trunk/gamedata/default_ini/client.ini
   trunk/gamedata/default_ini/fleets.ini
   trunk/gamedata/default_ini/server.ini
   trunk/makefile
   trunk/source/libraries/jpgalleg/decode.c
   trunk/source/libraries/jpgalleg/encode.c
   trunk/source/other/gup.cpp
   trunk/source/scp.cpp
   trunk/source/util/aastr.h
   trunk/source/util/aautil.c
   trunk/source/util/base.cpp
   trunk/source/util/net_tcp.cpp
   trunk/source/util/pmask.h
Log:
Applying Corona688 64-bit path with minor changes

Modified: trunk/gamedata/default_ini/client.ini
===================================================================
--- trunk/gamedata/default_ini/client.ini	2005-09-18 19:23:58 UTC (rev 191)
+++ trunk/gamedata/default_ini/client.ini	2005-09-18 19:57:13 UTC (rev 192)
@@ -31,7 +31,7 @@
 PlanetUsespec = 1
 
 [View]
-View = Enemy
+View = Dynamic
 ;determines = where the camera goes
 InterpolateFrames = 1
 ;0 = low quality, 1 = high quality

Modified: trunk/gamedata/default_ini/fleets.ini
===================================================================
--- trunk/gamedata/default_ini/fleets.ini	2005-09-18 19:23:58 UTC (rev 191)
+++ trunk/gamedata/default_ini/fleets.ini	2005-09-18 19:57:13 UTC (rev 192)
@@ -1,30 +1,30 @@
 [Player1]
 Slot0 = earcr
-Slot1 = thrto
-Slot2 = chebr
+Slot1 = kohma
+Slot2 = syrpe
 Slot3 = orzne
-Slot4 = druma
-Slot5 = meltr
-Slot6 = chmav
-Slot7 = kohma
-Slot8 = utwju
-Slot9 = andgu
-Slot10 = ilwav
-Slot11 = kzedr
-Slot12 = yehte
-Slot13 = syrpe
-Slot14 = spael
-Slot15 = vuxin
-Slot16 = umgdr
-Slot17 = supbl
-Slot18 = pkufu
-Slot19 = slypr
-Slot20 = arisk
-Slot21 = zfpst
-Slot22 = mycpo
-Slot23 = mmrxf
-Slot24 = shosc
-Size = 25
+Slot4 = zfpst
+Slot5 = chmav
+Slot6 = kzedr
+Slot7 = andgu
+Slot8 = tauda
+Slot9 = thrto
+Slot10 = spael
+Slot11 = conho
+Slot12 = druma
+Slot13 = vuxin
+Slot14 = slypr
+Slot15 = arisk
+Slot16 = yehte
+Slot17 = utwju
+Slot18 = umgdr
+Slot19 = shosc
+Slot20 = ilwav
+Slot21 = chebr
+Slot22 = meltr
+Slot23 = supbl
+Slot24 = mycpo
+Size = 27
 MaxFleetCost = 500
 Name = Player1
 Type = Keyboard/Joystick
@@ -32,6 +32,8 @@
 Channel = 12
 StartingFleetCost = 633
 StartingFleetSize = 24
+Slot25 = mmrxf
+Slot26 = pkufu
 
 [Player2]
 Slot0 = tauar

Modified: trunk/gamedata/default_ini/server.ini
===================================================================
--- trunk/gamedata/default_ini/server.ini	2005-09-18 19:23:58 UTC (rev 191)
+++ trunk/gamedata/default_ini/server.ini	2005-09-18 19:57:13 UTC (rev 192)
@@ -1,69 +1,69 @@
-[Network]
-Lag = 5
-
-[Game]
-SC2FrameRate = 20
-;used = in the conversion of all SC2 quantities except mass
-SC2TotalDistance = 8000
-;used = in the conversion of SC2 velocities & accelerations
-TicRate = 40
-; = the rate at which TimeWarps physics are done (units are cycles / second)
-Turbo = 1.0
-;1.0 = is normal, 0.5 is half-speed, 2.0 is double-speed, etc.
-F4Turbo = 4.0
-; = the value of turbo used when f4 is pressed
-FriendlyFire = 1
-; = 0 is no friendly fire, 1 is friendly fire
-ShotRelativity = 0.490000
-; = fraction of shooter velocity inherited by a shot, 0.5 recomended
-MapWidth = 3840
-MapHeight = 3840
-; = map size (3840x3840 is the norm)
-
-[View]
-; = value of 1 is not sc2-ish .. change it to 0 for sc2 mode
-CameraHidesCloakers = 1
-;ServerSideStars = 1 //not yet implemented
-
-[Stars]
-Width = 3000
-Height = 3000
-Number = 200
-;Number = of stars; should be between 100 and 500
-Layers = 15
-;Number = of layers the stars are in; should be between 3 and 15
-Depth = 127
-;3d = depth of starfield, should be between 0 and 255
-;TwinkleAmplitude = 1.0
-;TwinkleFrequency = 1.0
-
-
-[Planet]
-GravityForce = 1.5    ;strength of gravity
-GravityWhip = 0.5    ;increase in maxspeed in gravity well
-GravityWhip2 = 0.25   ;increase in maxspeed in gravity well
-GravityPower = 1     ;falloff: 2 = square, 1 = linear, 0 = flat, -1 = inverse, -2 = inverse square
-;note = that real gravity is inverse square, with 0 gravitywhip, 0 gravitywhip2, 0 mindist, and large range
-;however, = linear falloff seems to feel better for game purposes
-;I've = heard that SC1/2 used flat gravity
-GravityMinDist = 6      ;weakens strength of gravity at short range
-GravityRange = 18     ;cut-off range beyond which gravity stops
-
-[Sun]
-; = Sun follows the same format as Planet
-GravityForce = 6
-GravityWhip = 2.0
-GravityWhip = 2.0
-GravityPower = -1
-GravityMinDist = 6
-GravityRange = 20
-
-[Hyperspace]
-Friction = 0.0006
-Pholes = 0
-Nholes = 16
-hole_speed = 0.2
-
-[Gob]
-MaxEnemies = 64
-
+[Network]
+Lag = 5
+
+[Game]
+SC2FrameRate = 20
+;used = in the conversion of all SC2 quantities except mass
+SC2TotalDistance = 8000
+;used = in the conversion of SC2 velocities & accelerations
+TicRate = 40
+; = the rate at which TimeWarps physics are done (units are cycles / second)
+Turbo = 1.0
+;1.0 = is normal, 0.5 is half-speed, 2.0 is double-speed, etc.
+F4Turbo = 4.0
+; = the value of turbo used when f4 is pressed
+FriendlyFire = 1
+; = 0 is no friendly fire, 1 is friendly fire
+ShotRelativity = 0.490000
+; = fraction of shooter velocity inherited by a shot, 0.5 recomended
+MapWidth = 3840
+MapHeight = 3840
+; = map size (3840x3840 is the norm)
+
+[View]
+; = value of 1 is not sc2-ish .. change it to 0 for sc2 mode
+CameraHidesCloakers = 1
+;ServerSideStars = 1 //not yet implemented
+
+[Stars]
+Width = 3000
+Height = 3000
+Number = 200
+;Number = of stars; should be between 100 and 500
+Layers = 15
+;Number = of layers the stars are in; should be between 3 and 15
+Depth = 127
+;3d = depth of starfield, should be between 0 and 255
+;TwinkleAmplitude = 1.0
+;TwinkleFrequency = 1.0
+
+
+[Planet]
+GravityForce = 1.5    ;strength of gravity
+GravityWhip = 0.5    ;increase in maxspeed in gravity well
+GravityWhip2 = 0.25   ;increase in maxspeed in gravity well
+GravityPower = 1     ;falloff: 2 = square, 1 = linear, 0 = flat, -1 = inverse, -2 = inverse square
+;note = that real gravity is inverse square, with 0 gravitywhip, 0 gravitywhip2, 0 mindist, and large range
+;however, = linear falloff seems to feel better for game purposes
+;I've = heard that SC1/2 used flat gravity
+GravityMinDist = 6      ;weakens strength of gravity at short range
+GravityRange = 18     ;cut-off range beyond which gravity stops
+
+[Sun]
+; = Sun follows the same format as Planet
+GravityForce = 6
+GravityWhip = 2.0
+GravityWhip = 2.0
+GravityPower = -1
+GravityMinDist = 6
+GravityRange = 20
+
+[Hyperspace]
+Friction = 0.0006
+Pholes = 0
+Nholes = 16
+hole_speed = 0.2
+
+[Gob]
+MaxEnemies = 64
+

Modified: trunk/makefile
===================================================================
--- trunk/makefile	2005-09-18 19:23:58 UTC (rev 191)
+++ trunk/makefile	2005-09-18 19:57:13 UTC (rev 192)
@@ -101,7 +101,10 @@
 	ARCH := $(shell echo `arch`)
 	ifeq ($(ARCH),ppc)
 		ARCH    = powerpc
-endif
+	endif
+	ifeq ($(ARCH),x86_64)
+		ARCH	= k8
+	endif
 else
 	ARCH := i586
 endif
@@ -112,7 +115,7 @@
 	NAME   := ${addsuffix -debug,$(NAME)}
 	TEST=1
 else
-	CFLAGS += -Os -mcpu=$(ARCH) -s
+	CFLAGS += -Os -march=$(ARCH) -s
 endif
 
 ifdef win32

Modified: trunk/source/libraries/jpgalleg/decode.c
===================================================================
--- trunk/source/libraries/jpgalleg/decode.c	2005-09-18 19:23:58 UTC (rev 191)
+++ trunk/source/libraries/jpgalleg/decode.c	2005-09-18 19:57:13 UTC (rev 192)
@@ -33,8 +33,8 @@
 static int sampling, restart_interval, skip_count;
 static int spectrum_start, spectrum_end, successive_high, successive_low;
 static int scan_components, component[3];
-static void (*ycbcr2rgb)(int address, int y1, int cb1, int cr1, int y2, int cb2, int cr2);
-static void (*plot)(int addr, int pitch, short *y1, short *y2, short *y3, short *y4, short *cb, short *cr);
+static void (*ycbcr2rgb)(long address, int y1, int cb1, int cr1, int y2, int cb2, int cr2);
+static void (*plot)(long addr, int pitch, short *y1, short *y2, short *y3, short *y4, short *cb, short *cr);
 
 
 
@@ -548,7 +548,7 @@
  *  progressive mode decoding.
  */
 static int
-decode_progressive_block(int addr, int type, int *old_dc)
+decode_progressive_block(long addr, int type, int *old_dc)
 {
 	HUFFMAN_TABLE *dc_table, *ac_table;
 	short *block = (short *)addr;
@@ -716,7 +716,7 @@
  *  at a time.
  */
 static void
-_jpeg_c_ycbcr2rgb(int addr, int y1, int cb1, int cr1, int y2, int cb2, int cr2)
+_jpeg_c_ycbcr2rgb(long addr, int y1, int cb1, int cr1, int y2, int cb2, int cr2)
 {
 	int r, g, b;
 	unsigned int *ptr = (unsigned int *)addr;
@@ -737,7 +737,7 @@
  *  Plots an 8x8 MCU block for 444 mode. Also used to plot greyscale MUCs.
  */
 static void
-plot_444(int addr, int pitch, short *y1, short *y2, short *y3, short *y4, short *cb, short *cr)
+plot_444(long addr, int pitch, short *y1, short *y2, short *y3, short *y4, short *cb, short *cr)
 {
 	int x, y;
 	short *y1_ptr = y1, *cb_ptr = cb, *cr_ptr = cr;
@@ -775,7 +775,7 @@
  *  Plots a 16x8 MCU block for 422 mode.
  */
 static void
-plot_422(int addr, int pitch, short *y1, short *y2, short *y3, short *y4, short *cb, short *cr)
+plot_422(long addr, int pitch, short *y1, short *y2, short *y3, short *y4, short *cb, short *cr)
 {
 	int x, y;
 	short *y1_ptr = y1, *y2_ptr = y2, *cb_ptr = cb, *cr_ptr = cr;
@@ -804,7 +804,7 @@
  *  Plots a 16x16 MCU block for 411 mode.
  */
 static void
-plot_411(int addr, int pitch, short *y1, short *y2, short *y3, short *y4, short *cb, short *cr)
+plot_411(long addr, int pitch, short *y1, short *y2, short *y3, short *y4, short *cb, short *cr)
 {
 	int x, y;
 	short *y1_ptr = y1, *y2_ptr = y2, *y3_ptr = y3, *y4_ptr = y4, *cb_ptr = cb, *cr_ptr = cr;
@@ -846,7 +846,7 @@
 	short coefs_buffer[384], coefs[64], *coefs_ptr, *temp_ptr;
 	short *y1, *y2, *y3, *y4, *cb, *cr;
 	int workspace[64];
-	int addr, pitch, i, j;
+	long addr, pitch, i, j;
 	int block_x, block_y, block_max_x, block_max_y;
 	int blocks_per_row[3];
 	int blocks_in_mcu, block_component[6];
@@ -860,7 +860,7 @@
 	int depth;
 	PALETTE tmppal;
 	int want_palette = 1;
-	
+
 	if (!pal) {
 		want_palette = 0;
 		pal = tmppal;
@@ -889,12 +889,12 @@
 	y4 = coefs_buffer + 192;
 	cb = coefs_buffer + 256;
 	cr = coefs_buffer + 320;
-	
+
 	if (_jpeg_getw() != CHUNK_SOI) {
 		jpgalleg_error = JPG_ERROR_NOT_JFIF;
 		return NULL;
 	}
-	
+
 	/* Examine header */
 	do {
 		data = _jpeg_getc();
@@ -973,12 +973,12 @@
 			}
 		}
 	} while ((flags & JFIF_OK) != JFIF_OK);
-	
+
 	bmp = create_bitmap_ex(32, (jpeg_w + 15) & ~0xf, (jpeg_h + 15) & ~0xf);
 	if (!bmp)
 		return NULL;
 	pitch = (int)(bmp->line[1] - bmp->line[0]);
-	
+
 	block_x = block_y = 0;
 	restart_count = 0;
 	memset(data_buffer, 0, 3 * sizeof(DATA_BUFFER *));
@@ -1018,7 +1018,7 @@
 				if (decode_baseline_block(block_ptr[i], (block_component[i] == 0) ? LUMINANCE : CHROMINANCE, &old_dc[block_component[i]]))
 					goto exit_error;
 			}
-			addr = (int)bmp->line[block_y] + (block_x * 4);
+			addr = (long)bmp->line[block_y] + (block_x * 4);
 			plot(addr, pitch, y1, y2, y3, y4, cb, cr);
 			block_x += mcu_w;
 			if (block_x >= jpeg_w) {
@@ -1113,7 +1113,7 @@
 				}
 				for (i = 0; i < blocks_in_mcu; i++) {
 					c = block_component[i];
-					addr = (int)(data_buffer[c][((block_y * component_h[c]) * blocks_per_row[c]) + (block_y_ofs[i] * blocks_per_row[c]) + (block_x * component_w[c]) + block_x_ofs[i]].data);
+					addr = (long)(data_buffer[c][((block_y * component_h[c]) * blocks_per_row[c]) + (block_y_ofs[i] * blocks_per_row[c]) + (block_x * component_w[c]) + block_x_ofs[i]].data);
 					if (decode_progressive_block(addr, (c == 0) ? LUMINANCE : CHROMINANCE, &old_dc[c]))
 						goto exit_error;
 				}
@@ -1194,7 +1194,7 @@
 					apply_idct(coefs, coefs_ptr, (c == 0) ? luminance_quantization_table : chrominance_quantization_table, workspace);
 					coefs_ptr += 64;
 				}
-				addr = (int)bmp->line[block_y * mcu_h] + (block_x * mcu_w * 4);
+				addr = (long)bmp->line[block_y * mcu_h] + (block_x * mcu_w * 4);
 				plot(addr, pitch, y1, y2, y3, y4, cb, cr);
 			}
 		}

Modified: trunk/source/libraries/jpgalleg/encode.c
===================================================================
--- trunk/source/libraries/jpgalleg/encode.c	2005-09-18 19:23:58 UTC (rev 191)
+++ trunk/source/libraries/jpgalleg/encode.c	2005-09-18 19:57:13 UTC (rev 192)
@@ -118,7 +118,7 @@
 static HUFFMAN_TABLE huffman_dc_table[2];
 static int luminance_quant_table[64];
 static int chrominance_quant_table[64];
-static void (*rgb2ycbcr)(int address, short *y1, short *cb1, short *cr1, short *y2, short *cb2, short *cr2);
+static void (*rgb2ycbcr)(long address, short *y1, short *cb1, short *cr1, short *y2, short *cb2, short *cr2);
 
 
 
@@ -542,7 +542,7 @@
  *  at a time.
  */
 static void
-_jpeg_c_rgb2ycbcr(int addr, short *y1, short *cb1, short *cr1, short *y2, short *cb2, short *cr2)
+_jpeg_c_rgb2ycbcr(long addr, short *y1, short *cb1, short *cr1, short *y2, short *cb2, short *cr2)
 {
 	int r, g, b;
 	unsigned int *ptr = (unsigned int *)addr;
@@ -574,7 +574,7 @@
 	int dc_y, dc_cb, dc_cr;
 	int sampling, greyscale;
 	int block_x, block_y, x, y, i;
-	int addr, pitch;
+	long addr, pitch;
 	int error = 0;
 	BITMAP *fixed_bmp;
 	
@@ -625,7 +625,7 @@
 			case JPG_SAMPLING_411:
 				for (block_y = 0; block_y < bmp->h; block_y += 16) {
 					for (block_x = 0; block_x < bmp->w; block_x += 16) {
-						addr = (int)fixed_bmp->line[block_y] + (block_x * 4);
+						addr = (long)fixed_bmp->line[block_y] + (block_x * 4);
 						y1_ptr = y1;
 						y2_ptr = y2;
 						y3_ptr = y3;
@@ -689,7 +689,7 @@
 			case JPG_SAMPLING_422:
 				for (block_y = 0; block_y < bmp->h; block_y += 8) {
 					for (block_x = 0; block_x < bmp->w; block_x += 16) {
-						addr = (int)fixed_bmp->line[block_y] + (block_x * 4);
+						addr = (long)fixed_bmp->line[block_y] + (block_x * 4);
 						y1_ptr = y1;
 						y2_ptr = y2;
 						cb_ptr = cb;
@@ -725,7 +725,7 @@
 			case JPG_SAMPLING_444:
 				for (block_y = 0; block_y < bmp->h; block_y += 8) {
 					for (block_x = 0; block_x < bmp->w; block_x += 8) {
-						addr = (int)fixed_bmp->line[block_y] + (block_x * 4);
+						addr = (long)fixed_bmp->line[block_y] + (block_x * 4);
 						y1_ptr = y1;
 						cb_ptr = cb;
 						cr_ptr = cr;
@@ -752,7 +752,7 @@
 	else {
 		for (block_y = 0; block_y < bmp->h; block_y += 8) {
 			for (block_x = 0; block_x < bmp->w; block_x += 8) {
-				addr = (int)fixed_bmp->line[block_y] + (block_x * 4);
+				addr = (long)fixed_bmp->line[block_y] + (block_x * 4);
 				y1_ptr = y1;
 				for (y = 0; y < 8; y++) {
 					for (x = 0; x < 8; x += 2) {

Modified: trunk/source/other/gup.cpp
===================================================================
--- trunk/source/other/gup.cpp	2005-09-18 19:23:58 UTC (rev 191)
+++ trunk/source/other/gup.cpp	2005-09-18 19:57:13 UTC (rev 192)
@@ -2,6 +2,7 @@
 #include <allegro.h>
 #include "melee.h"
 
+#include "melee/mlog.h"
 #include "melee/mframe.h"
 #include "melee/mship.h"
 #include "melee/mcbodies.h"

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2005-09-18 19:23:58 UTC (rev 191)
+++ trunk/source/scp.cpp	2005-09-18 19:57:13 UTC (rev 192)
@@ -198,20 +198,20 @@
     {
     case Log::log_normal: 
       {
-	log = new Log();
-	log->init();
-	return log;
+    log = new Log();
+    log->init();
+    return log;
       }
     case Log::log_net1server: 
       {
-	netlog = new NetLog();
-	netlog->init();
-	netlog->type = Log::log_net1server;
-	return netlog;
+    netlog = new NetLog();
+    netlog->init();
+    netlog->type = Log::log_net1server;
+    return netlog;
       }
     default: 
       {
-	tw_error("that is not a valid log type");
+    tw_error("that is not a valid log type");
       }
     }
   return NULL;
@@ -298,7 +298,7 @@
   DIALOG_CONNECT_PORT,
   DIALOG_CONNECT_PORT_BOX,
   DIALOG_CONNECT_PORT_EDIT,
-  //	DIALOG_CONNECT_TWOLOCALS,
+  //    DIALOG_CONNECT_TWOLOCALS,
   DIALOG_CONNECT_OK,
   DIALOG_CONNECT_CANCEL,
   DIALOG_CONNECT_BLAH
@@ -322,7 +322,7 @@
 };
 
 int connect_menu(VideoWindow *window, char **address, int *port) { STACKTRACE
-								     int i = 0;
+                                     int i = 0;
 
  if (*address)
    strncpy(dialog_string[0], *address, 70);
@@ -363,10 +363,10 @@
   while ((p <= 0) || (p > 65535)) 
     {
       if (tw_popup_dialog(window, listen_dialog, 2) != DIALOG_LISTEN_OK) 
-	{
-	  //game->quit("Quit - game aborted from network \"listen\" menu");
-	  return -1;
-	}
+    {
+      //game->quit("Quit - game aborted from network \"listen\" menu");
+      return -1;
+    }
       p = atoi(dialog_string[1]);
     }
   return p;
@@ -395,22 +395,22 @@
   try 
     {
       if (game) 
-	{
-	  delete game;
-	  game = NULL;
-	}
+    {
+      delete game;
+      game = NULL;
+    }
     
       if (!_log) 
-	{
-	  _log = new Log();
-	  _log->init();
-	}
+    {
+      _log = new Log();
+      _log->init();
+    }
       
       GameType *type = gametype(gametype_name);
       if (type)
-		new_game = type->new_game();
+        new_game = type->new_game();
       else
-		tw_error("wait a sec... I can't find that game type");
+        tw_error("wait a sec... I can't find that game type");
     
       new_game->preinit();
       new_game->window = new VideoWindow;
@@ -431,29 +431,29 @@
   catch (int i) 
     {
       if (i == -1) 
-	throw;
+    throw;
       if (__error_flag & 1) 
-	throw;
+    throw;
       if (i != 0) 
-	caught_error ("%s %s caught int %d", __FILE__, __LINE__, i);
+    caught_error ("%s %s caught int %d", __FILE__, __LINE__, i);
       if (__error_flag & 1) 
-	throw;
+    throw;
     }
   catch (const char *str) 
     {
       if (__error_flag & 1) 
-	throw;
+    throw;
       caught_error("message: \"%s\"", str);
       if (__error_flag & 1) 
-	throw;
+    throw;
     }
   catch (...) 
     {
       if (__error_flag & 1) 
-	throw;
+    throw;
       caught_error("Ack(2)!!!\nAn error occured!\nBut I don't know what error!");
       if (__error_flag & 1) 
-	throw;
+    throw;
     }
 
   prepareTitleScreenAssets();
@@ -490,9 +490,9 @@
     free(addressaddress);
     if (i) 
       {
-	//						while (is_escape_pressed());
-	while (keypressed()) readkey();
-	tw_error("connection failed");
+    //                      while (is_escape_pressed());
+    while (keypressed()) readkey();
+    tw_error("connection failed");
       }
   }
   
@@ -606,7 +606,7 @@
 void MainMenu::enable() 
 {
   STACKTRACE;
-		   
+           
   if (!(state & 2)) 
     window->add_callback(this);
   state |= 3;
@@ -614,7 +614,7 @@
 
 void MainMenu::disable() 
 {
-  STACKTRACE;	   
+  STACKTRACE;      
   state &=~ 1;
 }
 
@@ -641,7 +641,7 @@
 void MainMenu::deinit() 
 {
   STACKTRACE;   
-		   
+           
   if (state & 2) 
     {
       window->remove_callback(this);
@@ -654,13 +654,13 @@
 void MainMenu::doit() 
 {
   STACKTRACE;
-		   
+           
   int i;
   char tmp[32];
   
   tw_set_config_file("scp.ini");
   if (!player_type) 
-    {		
+    {       
       MAX_PLAYERS        = get_config_int("Limits", "MaxPlayers", 12);
       MAX_CONFIGURATIONS = get_config_int("Limits", "MaxConfigurations", 4);
       MAX_TEAMS          = get_config_int("Limits", "MaxTeams", 6);
@@ -686,83 +686,84 @@
       mainRet = tw_do_dialog(window, mainDialog, MAIN_DIALOG_NEW_GAME);
       switch (mainRet) {
       case MAIN_DIALOG_MELEE:
-	disable();
-	play_game("Melee", "", NULL);
-	enable();
-	break;
+    disable();
+    play_game("Melee", "", NULL);
+    enable();
+    break;
       case MAIN_DIALOG_MULTIPLAYER:
-	disable();
-	multiplayer_menu();
-	enable();
-	break;
+    disable();
+    multiplayer_menu();
+    enable();
+    break;
       case MAIN_DIALOG_MELEE_EXTENDED:
-	disable();
-	extended_menu();
-	enable();
-	break;
+    disable();
+    extended_menu();
+    enable();
+    break;
       case MAIN_DIALOG_PREFERENCES:
-	showTitle();
-	options_menu(NULL);
-	break;
+    showTitle();
+    options_menu(NULL);
+    break;
       case MAIN_DIALOG_HELP:
-	show_file(data_full_path("ingame.txt").c_str());
-	break;
+    show_file(data_full_path("ingame.txt").c_str());
+    break;
       case MAIN_DIALOG_NEW_GAME:
-	{
-		disable();
-		std::auto_ptr<MainGame> maingame(new MainGame(""));
-		maingame->play();
-		enable();
-	  break;
-	}
-	case MAIN_DIALOG_ABOUT:
-	{
-	  // Show Intro
-	  RGB tmpPal[256];
-	  memcpy(tmpPal, palette_color, sizeof(RGB) * 256);
-	  set_palette((const RGB*)g_game_data[TW_FONT_PALETTE].dat);
+    {
+        disable();
+        std::auto_ptr<MainGame> maingame(new MainGame(""));
+        maingame->play();
+        enable();
+      break;
+    }
+    case MAIN_DIALOG_ABOUT:
+    {
+      // Show Intro
+      RGB tmpPal[256];
+      memcpy(tmpPal, palette_color, sizeof(RGB) * 256);
+      set_palette((const RGB*)g_game_data[TW_FONT_PALETTE].dat);
 
-	  std::vector<std::string> about;
-	  about.push_back("Team");
-	  about.push_back("");
-	  about.push_back("Programmers:");
-	  about.push_back("");
-	  about.push_back("  * Yura Semashko (Yurand)");
-	  about.push_back("  * Paul Forest (youBastrd)");
-	  about.push_back("");
-	  about.push_back("Content and Plot manager:");
-	  about.push_back("");
-	  about.push_back("  * Asaf Hamtzany (UAF)");
-	  about.push_back("");
-	  about.push_back("Dialog Writers");
-	  about.push_back("");
-	  about.push_back("  * Pelorki");
-	  about.push_back("");
-	  about.push_back("Graphic Designers");
-	  about.push_back("");
-	  about.push_back("  * Rick Bushie (Firehazurd)");
-	  about.push_back("");
-	  about.push_back("Music");
-	  about.push_back("");
-	  about.push_back("  * Robeter Productions (www.robeterproductions.com)");
-	  about.push_back("  * Mark Forest (Abe Froman)");
-	  about.push_back("");
-	  about.push_back("Special Thanks:");
-	  about.push_back("");
-	  about.push_back("  * Orz");
-	  about.push_back("  * Tau");
-	  about.push_back("  * GeomanNL");
-	  about.push_back("  * Officer Flubbo");
-	  about.push_back("  * Captain Maim");
-	  about.push_back("  * Jumping Peppers");
-	  about.push_back("  * Robeter Productions");
+      std::vector<std::string> about;
+      about.push_back("Team");
+      about.push_back("");
+      about.push_back("Programmers:");
+      about.push_back("");
+      about.push_back("  * Yura Semashko (Yurand)");
+      about.push_back("  * Paul Forest (youBastrd)");
+      about.push_back("");
+      about.push_back("Content and Plot manager:");
+      about.push_back("");
+      about.push_back("  * Asaf Hamtzany (UAF)");
+      about.push_back("");
+      about.push_back("Dialog Writers");
+      about.push_back("");
+      about.push_back("  * Pelorki");
+      about.push_back("");
+      about.push_back("Graphic Designers");
+      about.push_back("");
+      about.push_back("  * Rick Bushie (Firehazurd)");
+      about.push_back("  * Darryl Koster");
+      about.push_back("");
+      about.push_back("Music");
+      about.push_back("");
+      about.push_back("  * Robeter Productions (www.robeterproductions.com)");
+      about.push_back("  * Mark Forest (Abe Froman)");
+      about.push_back("");
+      about.push_back("Special Thanks:");
+      about.push_back("");
+      about.push_back("  * Orz");
+      about.push_back("  * Tau");
+      about.push_back("  * GeomanNL");
+      about.push_back("  * Officer Flubbo");
+      about.push_back("  * Captain Maim");
+      about.push_back("  * Jumping Peppers");
+      about.push_back("  * Robeter Productions");
 
-	  ScrollText(about,  D_FONT_ENGLISH, -1, "images/background.jpg", "l", 3);
+      ScrollText(about,  D_FONT_ENGLISH, -1, "images/background.jpg", "l", 3);
 
-	  videosystem->set_palette(tmpPal);
-	  videosystem->redraw();
-	  break;
-	}
+      videosystem->set_palette(tmpPal);
+      videosystem->redraw();
+      break;
+    }
       }
     } while((mainRet != MAIN_DIALOG_EXIT) && (mainRet != -1));
   
@@ -830,7 +831,7 @@
       int fullscreen = 0;
       
       auto_unload = get_config_int("System", "AutoUnload", 0);
-		
+        
       const AGUP_THEME *theme = agup_theme_by_name(get_config_string("Video", "GuiTheme", "Photon"));
       
       screen_bpp       = get_config_int("Video", "BitsPerPixel", 16);
@@ -852,125 +853,125 @@
       
       // parse command-line arguments
       for (i = 1; i < argc; i += 1) 
-	{
-	  if (!strcmp(argv[i], "-res") && (argc > i + 2)) 
-	    {
-	      log_debug("command-line argument -res\n");
-	      screen_width = atoi(argv[i+1]);
-	      screen_height = atoi(argv[i+2]);
-	      i += 2;
-	    }
-	  else if (!strcmp(argv[i], "-bpp") && (argc > i + 1)) 
-	    {
-	      log_debug("command-line argument -bpp\n");
-	      screen_bpp = atoi(argv[i+1]);
-	      i += 1;
-	    }
-	  else if (!strcmp(argv[i], "-fullscreen")) 
-	    {
-	      log_debug("command-line argument -fullscreen\n");
-	      fullscreen = true;
-	    }
-	  else if (!strcmp(argv[i], "-window")) 
-	    {
-	      log_debug("command-line argument -window\n");
-	      fullscreen = false;
-	    }
-	  else if(!strcmp(argv[i], "-nosound")) 
-	    {
-	      sound_enabled = false;
-	    }
-	  else if (!strcmp(argv[i], "-nokeyboard")) 
-	    {
-	      log_debug("command-line argument -nokeyboard\n");
-	      inputs &= ~1;
-	    }
-	  else if (!strcmp(argv[i], "-nomouse")) 
-	    {
-	      log_debug("command-line argument -nomouse\n");
-	      inputs &= ~2;
-	    }
-	  else if (!strcmp(argv[i], "-nojoystick")) 
-	    {
-	      log_debug("command-line argument -nojoystick\n");
-	      inputs &= ~4;
-	    }
-	  else if (!strcmp(argv[i], "-noidle")) 
-	    {
-	      log_debug("command-line argument -noidle\n");
-	      _no_idle = 1;
-	    }
-	  else if (strstr(argv[i], COMMAND_LINE_SERVER_LONG)) 
-	    {
-	      if (strlen(argv[i]) > strlen(COMMAND_LINE_SERVER_LONG)) 
-		{
-		  // users can use two formats for the address: an alphanumeric name, like
-		  // "localhost", or a dotted ip address, like a.b.c.d .  Further, users
-		  // can specify the port here as well, by adding a colon and the number to 
-		  // the end of the address.  
-		  const char * addressStart = strstr(argv[i], COMMAND_LINE_SERVER_LONG) + strlen(COMMAND_LINE_SERVER_LONG);
-		  const char * addressEnd = strstr(addressStart, ":");
-		  
-		  // user has added a colon, indicating the port.  The port starts at addressEnd
-		  // and goes to the end of argv[i]
-		  if (addressEnd && strlen(addressEnd) > 1) 
-		    { 
-		      // this is +1 to skip the ":"
-		      serverPort = atoi(addressEnd+1);
-		    }
-		  serverAddress.clear();
-		  serverAddress.append(addressStart, addressEnd-addressStart);
-		  
-		  log_debug("commandline specified server as : host=[%s], port=[%u]\n", serverAddress.c_str(), serverPort);
-		}
-	    }
-	  else if (strstr(argv[i], COMMAND_LINE_MAX_CLIENTS_LONG)) 
-	    {
-	      // this is the maximum number of computers that can connect to this program instance. 
-	      // Used in server mode only, no effect otherwise.
-	      if (strlen(argv[i]) > strlen(COMMAND_LINE_MAX_CLIENTS_LONG)) 
-		{
-		  const char * portStart = strstr(argv[i], COMMAND_LINE_MAX_CLIENTS_LONG) + strlen(COMMAND_LINE_MAX_CLIENTS_LONG);
-		  if (strlen(portStart) > 1) 
-		    {
-		      serverMaxClients = atoi(portStart);
-		    }
-		  log_debug("commandline specified max clients as: serverMaxClients=[%u]\n", serverMaxClients);
-		}
-	    }
-	  else if (strstr(argv[i], COMMAND_LINE_CLIENT_PORT_LONG) && (argc > i + 0)) 
-	    {
-	      // this specifies the port this client will listen on.
-	      // Used in client mode only, no effect otherwise.
-	      if (strlen(argv[i]) > strlen(COMMAND_LINE_CLIENT_PORT_LONG)) 
-		{
-		  const char * clientportStart = strstr(argv[i], COMMAND_LINE_CLIENT_PORT_LONG) + strlen(COMMAND_LINE_CLIENT_PORT_LONG);
-		  if (strlen(clientportStart) > 1) 
-		    {
-		      clientPort = atoi(clientportStart);
-		    }
-		  log_debug("commandline specified client port as : port=[%u]\n", clientPort);
-		}
-	    }
-	  else if (!strcmp(argv[i], "-play") && (argc > i + 2)) 
-	    {
-	      log_debug("command-line argument -play\n");
-	      auto_play = argv[i+1];
-	      auto_param = argv[i+2];
-	      i += 2;
-	      if ((argc > i + 0) && (argv[i][0] != '-')) 
-		{
-		  auto_port = atoi(argv[i]);
-		  i += 1;
-		}
-	    }
-	  else 
-	    {
-	      log_debug("unrecognized command-line argument:");
-	      log_debug(argv[i]);
-	      log_debug("\n");
-	    }
-	}
+    {
+      if (!strcmp(argv[i], "-res") && (argc > i + 2)) 
+        {
+          log_debug("command-line argument -res\n");
+          screen_width = atoi(argv[i+1]);
+          screen_height = atoi(argv[i+2]);
+          i += 2;
+        }
+      else if (!strcmp(argv[i], "-bpp") && (argc > i + 1)) 
+        {
+          log_debug("command-line argument -bpp\n");
+          screen_bpp = atoi(argv[i+1]);
+          i += 1;
+        }
+      else if (!strcmp(argv[i], "-fullscreen")) 
+        {
+          log_debug("command-line argument -fullscreen\n");
+          fullscreen = true;
+        }
+      else if (!strcmp(argv[i], "-window")) 
+        {
+          log_debug("command-line argument -window\n");
+          fullscreen = false;
+        }
+      else if(!strcmp(argv[i], "-nosound")) 
+        {
+          sound_enabled = false;
+        }
+      else if (!strcmp(argv[i], "-nokeyboard")) 
+        {
+          log_debug("command-line argument -nokeyboard\n");
+          inputs &= ~1;
+        }
+      else if (!strcmp(argv[i], "-nomouse")) 
+        {
+          log_debug("command-line argument -nomouse\n");
+          inputs &= ~2;
+        }
+      else if (!strcmp(argv[i], "-nojoystick")) 
+        {
+          log_debug("command-line argument -nojoystick\n");
+          inputs &= ~4;
+        }
+      else if (!strcmp(argv[i], "-noidle")) 
+        {
+          log_debug("command-line argument -noidle\n");
+          _no_idle = 1;
+        }
+      else if (strstr(argv[i], COMMAND_LINE_SERVER_LONG)) 
+        {
+          if (strlen(argv[i]) > strlen(COMMAND_LINE_SERVER_LONG)) 
+        {
+          // users can use two formats for the address: an alphanumeric name, like
+          // "localhost", or a dotted ip address, like a.b.c.d .  Further, users
+          // can specify the port here as well, by adding a colon and the number to 
+          // the end of the address.  
+          const char * addressStart = strstr(argv[i], COMMAND_LINE_SERVER_LONG) + strlen(COMMAND_LINE_SERVER_LONG);
+          const char * addressEnd = strstr(addressStart, ":");
+          
+          // user has added a colon, indicating the port.  The port starts at addressEnd
+          // and goes to the end of argv[i]
+          if (addressEnd && strlen(addressEnd) > 1) 
+            { 
+              // this is +1 to skip the ":"
+              serverPort = atoi(addressEnd+1);
+            }
+          serverAddress.clear();
+          serverAddress.append(addressStart, addressEnd-addressStart);
+          
+          log_debug("commandline specified server as : host=[%s], port=[%u]\n", serverAddress.c_str(), serverPort);
+        }
+        }
+      else if (strstr(argv[i], COMMAND_LINE_MAX_CLIENTS_LONG)) 
+        {
+          // this is the maximum number of computers that can connect to this program instance. 
+          // Used in server mode only, no effect otherwise.
+          if (strlen(argv[i]) > strlen(COMMAND_LINE_MAX_CLIENTS_LONG)) 
+        {
+          const char * portStart = strstr(argv[i], COMMAND_LINE_MAX_CLIENTS_LONG) + strlen(COMMAND_LINE_MAX_CLIENTS_LONG);
+          if (strlen(portStart) > 1) 
+            {
+              serverMaxClients = atoi(portStart);
+            }
+          log_debug("commandline specified max clients as: serverMaxClients=[%u]\n", serverMaxClients);
+        }
+        }
+      else if (strstr(argv[i], COMMAND_LINE_CLIENT_PORT_LONG) && (argc > i + 0)) 
+        {
+          // this specifies the port this client will listen on.
+          // Used in client mode only, no effect otherwise.
+          if (strlen(argv[i]) > strlen(COMMAND_LINE_CLIENT_PORT_LONG)) 
+        {
+          const char * clientportStart = strstr(argv[i], COMMAND_LINE_CLIENT_PORT_LONG) + strlen(COMMAND_LINE_CLIENT_PORT_LONG);
+          if (strlen(clientportStart) > 1) 
+            {
+              clientPort = atoi(clientportStart);
+            }
+          log_debug("commandline specified client port as : port=[%u]\n", clientPort);
+        }
+        }
+      else if (!strcmp(argv[i], "-play") && (argc > i + 2)) 
+        {
+          log_debug("command-line argument -play\n");
+          auto_play = argv[i+1];
+          auto_param = argv[i+2];
+          i += 2;
+          if ((argc > i + 0) && (argv[i][0] != '-')) 
+        {
+          auto_port = atoi(argv[i]);
+          i += 1;
+        }
+        }
+      else 
+        {
+          log_debug("unrecognized command-line argument:");
+          log_debug(argv[i]);
+          log_debug("\n");
+        }
+    }
     
       log_debug("command-line arguments parsed\n");
     
@@ -981,7 +982,7 @@
       register_bitmap_file_type("jpg", load_jpg, NULL);
     
       if(!theme)
-	theme = agup_theme_by_name("Photon");
+    theme = agup_theme_by_name("Photon");
       agup_init(theme);    
       gui_shadow_box_proc = d_agup_shadow_box_proc;
       gui_ctext_proc = d_agup_ctext_proc;
@@ -1006,20 +1007,20 @@
       init_fleet();
     
       if (auto_play) {// FIX ME
-	if (!strcmp(auto_play, "game")) play_game(auto_param, NULL);
+    if (!strcmp(auto_play, "game")) play_game(auto_param, NULL);
       }
       else {
-	mainmenu.preinit();
-	mainmenu.init(&videosystem->window);
-	mainmenu.doit();
-	mainmenu.deinit();
+    mainmenu.preinit();
+    mainmenu.init(&videosystem->window);
+    mainmenu.doit();
+    mainmenu.deinit();
       }
 
       if(game)
-	{
-	  delete game;
-	  game = NULL;
-	}
+    {
+      delete game;
+      game = NULL;
+    }
       disable_input(); 
     }
   catch (int i) {
@@ -1029,9 +1030,9 @@
       throw;
     if (i != 0) 
       {
-	char t[256];
-	sprintf(t, "caught int %d", i);
-	tw_error(t);
+    char t[256];
+    sprintf(t, "caught int %d", i);
+    tw_error(t);
       }
     if (__error_flag & 1) 
       throw;
@@ -1073,12 +1074,12 @@
     return;
   window->lock();
   stretch_blit(src, window->surface, 
-	       0,0,src->w,src->h,
-	       window->x, window->y, window->w, window->h);
+           0,0,src->w,src->h,
+           window->x, window->y, window->w, window->h);
 
   textout_right(screen, font, tw_version().c_str(), 
-		screen->w - 0*text_length(font, tw_version().c_str()), screen->h - 1*text_height(font), 
-		palette_color[15]);
+        screen->w - 0*text_length(font, tw_version().c_str()), screen->h - 1*text_height(font), 
+        palette_color[15]);
   window->unlock();
   return;
 }
@@ -1112,17 +1113,17 @@
     case -1:
     case MELEE_MULTIPLAYER_DIALOG_EXIT: 
       {
-	return;
+    return;
       }
       break;
     case MELEE_MULTIPLAYER_DIALOG_PLAY_NET1SERVER: 
       {
-	play_net1server();
+    play_net1server();
       }
       break;
     case MELEE_MULTIPLAYER_DIALOG_PLAY_NET1CLIENT: 
       {
-	play_net1client();
+    play_net1client();
       }
       break;
     }
@@ -1148,7 +1149,7 @@
     {
       const char *gname = select_game_menu();
       if (gname)
-	play_game(gname, "", NULL);
+    play_game(gname, "", NULL);
     }
     break;
   case MELEE_EX_DIALOG_DIAGNOSTICS: {
@@ -1188,37 +1189,37 @@
       
       a = tw_do_dialog(NULL, teamsDialog, 0);
       if((a == TEAMS_DIALOG_SELECTCONTROL) || (a == TEAMS_DIALOG_CONTROLLIST)) 
-	{
-	  player_type[teamsDialog[TEAMS_DIALOG_PLAYERLIST].d1] =
-	    control_name[teamsDialog[TEAMS_DIALOG_CONTROLLIST].d1];
-	  teamsDialog[TEAMS_DIALOG_PLAYERLIST].d1 += 1;
-	}
+    {
+      player_type[teamsDialog[TEAMS_DIALOG_PLAYERLIST].d1] =
+        control_name[teamsDialog[TEAMS_DIALOG_CONTROLLIST].d1];
+      teamsDialog[TEAMS_DIALOG_PLAYERLIST].d1 += 1;
+    }
       else if ((a == TEAMS_DIALOG_SETUP) || (a == TEAMS_DIALOG_PLAYERLIST)) 
-	{
-	  Control *tmpc = load_player(teamsDialog[TEAMS_DIALOG_PLAYERLIST].d1);
-	  if (tmpc) 
-	    {
-	      showTitle();
-	      tmpc->setup();
-	      delete tmpc;
-	      showTitle();
-	    }
-	}
+    {
+      Control *tmpc = load_player(teamsDialog[TEAMS_DIALOG_PLAYERLIST].d1);
+      if (tmpc) 
+        {
+          showTitle();
+          tmpc->setup();
+          delete tmpc;
+          showTitle();
+        }
+    }
       else if (a == TEAMS_DIALOG_TEAM_NUM) 
-	{
-	  player_team[teamsDialog[TEAMS_DIALOG_PLAYERLIST].d1] += 1;
-	  player_team[teamsDialog[TEAMS_DIALOG_PLAYERLIST].d1] %= MAX_TEAMS;
-	}
+    {
+      player_team[teamsDialog[TEAMS_DIALOG_PLAYERLIST].d1] += 1;
+      player_team[teamsDialog[TEAMS_DIALOG_PLAYERLIST].d1] %= MAX_TEAMS;
+    }
       else if (a == TEAMS_DIALOG_CONFIG_NUM) 
-	{
-	  player_config[teamsDialog[TEAMS_DIALOG_PLAYERLIST].d1] += 1;
-	  player_config[teamsDialog[TEAMS_DIALOG_PLAYERLIST].d1] %= MAX_CONFIGURATIONS;
-	}
+    {
+      player_config[teamsDialog[TEAMS_DIALOG_PLAYERLIST].d1] += 1;
+      player_config[teamsDialog[TEAMS_DIALOG_PLAYERLIST].d1] %= MAX_CONFIGURATIONS;
+    }
       else if (a == TEAMS_DIALOG_FLEET) 
-	{
-	  edit_fleet(teamsDialog[TEAMS_DIALOG_PLAYERLIST].d1);
-	  showTitle();
-	}
+    {
+      edit_fleet(teamsDialog[TEAMS_DIALOG_PLAYERLIST].d1);
+      showTitle();
+    }
       else break;
     }
   
@@ -1247,8 +1248,8 @@
 
 
 char *numeric_string[] = {"Zero", "One", "Two", "Three", "Four", 
-			  "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", 
-			  "Twelve"};
+              "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", 
+              "Twelve"};
 
 char fleetPlayer[18];
 char fleetTitleString[100];
@@ -1262,31 +1263,31 @@
 {
   if (msg == MSG_CLICK)
     {
-		
+        
       /* track the mouse until it is released */
       while (gui_mouse_b()) {
-	//			state2 = ((gui_mouse_x() >= d->x) && (gui_mouse_y() >= d->y) &&
-	//				(gui_mouse_x() < d->x + d->w) && (gui_mouse_y() < d->y + d->h));
-			
-	/* let other objects continue to animate */
-	broadcast_dialog_message(MSG_IDLE, 0);
+    //          state2 = ((gui_mouse_x() >= d->x) && (gui_mouse_y() >= d->y) &&
+    //              (gui_mouse_x() < d->x + d->w) && (gui_mouse_y() < d->y + d->h));
+            
+    /* let other objects continue to animate */
+    broadcast_dialog_message(MSG_IDLE, 0);
       }
-		
+        
       /* should we close the dialog? */
       // imo the following mucho better/ simplere than that messy stuff in the allegro routine
       // ... check d_button_proc in guiproc.c in the allegro sources...
 
       if (d->flags & D_SELECTED)
-	d->flags &= ~D_SELECTED;
+    d->flags &= ~D_SELECTED;
       else
-	d->flags |= D_SELECTED;
+    d->flags |= D_SELECTED;
 
       if ( d->flags & D_EXIT)
-	return D_CLOSE;
+    return D_CLOSE;
 
       return D_O_K; 
     }
-	
+    
   return d_agup_check_proc(msg, d, 0);
 }
 
@@ -1296,7 +1297,7 @@
 
 // FLEET - dialog function
 void edit_fleet(int player) {STACKTRACE
-			       char tmp[40];
+                   char tmp[40];
  char path[80];
  char fleetCostString[80] = "";
  char maxFleetCostString[80] = "";
@@ -1323,7 +1324,7 @@
  fleetDialog[FLEET_DIALOG_CURRENT_POINTS_VALUE].dp = fleetCostString;
  fleetDialog[FLEET_DIALOG_POINT_LIMIT_BUTTON].dp = maxFleetCostString;
     
- //	// the reference_fleet is used in the list in a hardcoded way, so over"load" it
+ // // the reference_fleet is used in the list in a hardcoded way, so over"load" it
  //    Fleet *old_reference_fleet = reference_fleet;
 
  do {
@@ -1341,7 +1342,7 @@
      fleetDialog[FLEET_DIALOG_CURRENT_POINTS_VALUE].bg = 0;
 
    sprintf(maxFleetCostString,"%d %s", fleet->getMaxCost(), 
-	   Fleet::getFleetCostName(fleet->getMaxCost()));
+       Fleet::getFleetCostName(fleet->getMaxCost()));
 
    if (sortAscending1)
      fleetDialog[FLEET_DIALOG_SORTBY_ASCENDING1].dp = (void *)"^";
@@ -1364,19 +1365,19 @@
      for (int c=0; c<num_shiptypes; c++) {
        switch (shiptypes[c].origin) { 
        case SHIP_ORIGIN_TW:
-	 if (fleetDialog[FLEET_DIALOG_TW_OFFICIAL_TOGGLE].flags & D_SELECTED)
-	   reference_fleet->addShipType(&shiptypes[c]);
-	 break;
+     if (fleetDialog[FLEET_DIALOG_TW_OFFICIAL_TOGGLE].flags & D_SELECTED)
+       reference_fleet->addShipType(&shiptypes[c]);
+     break;
                 
        case SHIP_ORIGIN_UQM:
-	 if (fleetDialog[FLEET_DIALOG_TW_EXP_TOGGLE].flags & D_SELECTED)
-	   reference_fleet->addShipType(&shiptypes[c]);
-	 break;
+     if (fleetDialog[FLEET_DIALOG_TW_EXP_TOGGLE].flags & D_SELECTED)
+       reference_fleet->addShipType(&shiptypes[c]);
+     break;
 
        case SHIP_ORIGIN_TW_SPECIAL:
-	 if (fleetDialog[FLEET_DIALOG_TW_SPECIAL_TOGGLE].flags & D_SELECTED)
-	   reference_fleet->addShipType(&shiptypes[c]);
-	 break;
+     if (fleetDialog[FLEET_DIALOG_TW_SPECIAL_TOGGLE].flags & D_SELECTED)
+       reference_fleet->addShipType(&shiptypes[c]);
+     break;
        }
      }
      reference_fleet->Sort( sortMethod1, sortAscending1 );
@@ -1524,33 +1525,33 @@
       d->d1 = reference_fleet->getNextFleetEntryByCharacter( d->d1, typed);
       shouldConsumeChar = true;
       if (d->d1 != old_d1) {
-	
-	int size = reference_fleet->getSize();
-	int height = (d->h-4) / text_height(font);
-	
-	ret = D_USED_CHAR; 
-	d->flags |= D_DIRTY;
-	
-	//scroll such that the selection is shown.
-	//only change the scroll if the selection is not already shown,
-	//and the number of ships in the list is greater than the number
-	//of slots that can be shown simultaneously.
-	if ( (size > height) &&
-	     ( (d->d1 < d->d2) ||
-	       (d->d1 >= d->d2 + height))) 
-	  {
-	    if (d->d1 <= (height/2))
-	      d->d2 = 0;
-	    else {
-	      
-	      if (d->d1 >= (size - height))
-		d->d2 = (size - height);
-	      else {
-		d->d2 = d->d1 - height/2;
-	      }
-	    }
-	  }
+    
+    int size = reference_fleet->getSize();
+    int height = (d->h-4) / text_height(font);
+    
+    ret = D_USED_CHAR; 
+    d->flags |= D_DIRTY;
+    
+    //scroll such that the selection is shown.
+    //only change the scroll if the selection is not already shown,
+    //and the number of ships in the list is greater than the number
+    //of slots that can be shown simultaneously.
+    if ( (size > height) &&
+         ( (d->d1 < d->d2) ||
+           (d->d1 >= d->d2 + height))) 
+      {
+        if (d->d1 <= (height/2))
+          d->d2 = 0;
+        else {
+          
+          if (d->d1 >= (size - height))
+        d->d2 = (size - height);
+          else {
+        d->d2 = d->d1 - height/2;
+          }
+        }
       }
+      }
     }
   }
   ret = d_agup_text_list_proc( msg, d, c );
@@ -1559,11 +1560,11 @@
     ret = D_USED_CHAR;
   
   static BITMAP* panel = create_bitmap(fleetDialog[FLEET_DIALOG_SHIP_PICTURE_BITMAP].w,
-				       fleetDialog[FLEET_DIALOG_SHIP_PICTURE_BITMAP].h);
+                       fleetDialog[FLEET_DIALOG_SHIP_PICTURE_BITMAP].h);
   fleetDialog[FLEET_DIALOG_SHIP_PICTURE_BITMAP].dp = panel;
   
   static BITMAP * sprite = create_bitmap(fleetDialog[FLEET_DIALOG_SHIP_PICTURE_BITMAP].w,
-					 fleetDialog[FLEET_DIALOG_SHIP_PICTURE_BITMAP].h);
+                     fleetDialog[FLEET_DIALOG_SHIP_PICTURE_BITMAP].h);
   static int rotationFrame = 0;
   
   //selection has changed
@@ -1575,8 +1576,8 @@
     
     if (type && type->data) {
       if (type->data->spriteShip) {
-	
-	fractionRotated = (float)((float)rotationFrame / (float)(type->data->spriteShip->frames()));
+    
+    fractionRotated = (float)((float)rotationFrame / (float)(type->data->spriteShip->frames()));
       }
       type->data->unlock();
     }}
@@ -1587,7 +1588,7 @@
     if (type && type->data) {
       type->data->lock();
       if (type->data->spriteShip)
-	rotationFrame = (int)(fractionRotated * type->data->spriteShip->frames());
+    rotationFrame = (int)(fractionRotated * type->data->spriteShip->frames());
     }}
   }
   
@@ -1605,15 +1606,15 @@
     if (type && type->data && type->data->spriteShip) {
       
       type->data->spriteShip->draw(
-				   Vector2(fleetDialog[FLEET_DIALOG_SHIP_PICTURE_BITMAP].w/2,
-					   fleetDialog[FLEET_DIALOG_SHIP_PICTURE_BITMAP].h/2) - type->data->spriteShip->size()/2, 
-				   type->data->spriteShip->size(), 
-				   rotationFrame, sprite 
-				   );
+                   Vector2(fleetDialog[FLEET_DIALOG_SHIP_PICTURE_BITMAP].w/2,
+                       fleetDialog[FLEET_DIALOG_SHIP_PICTURE_BITMAP].h/2) - type->data->spriteShip->size()/2, 
+                   type->data->spriteShip->size(), 
+                   rotationFrame, sprite 
+                   );
       
       rotationFrame++;
       if (rotationFrame >= type->data->spriteShip->frames())
-	rotationFrame = 0;
+    rotationFrame = 0;
     }
     stretch_blit(sprite, panel, 0, 0, sprite->w, sprite->h, 0, 0, panel->w, panel->h);
     safeToDrawPreview = true;
@@ -1679,101 +1680,101 @@
     
       // update ship selection - begin
       if ((r == 0) || (r == SHIPVIEW_DIALOG_LIST)) 
-	{
-	  si = shipviewDialog[SHIPVIEW_DIALOG_LIST].d1;
-	  sname = shipListboxGetter(si, NULL);
-	  if (!sname) 
-	    {
-	      sprintf(dialog_string[0], "(Null)");
-	      sprintf(dialog_string[1], "(Null)");
-	    }
-	  else 
-	    {
-	      ShipType *type = fleet->getShipType(si);
+    {
+      si = shipviewDialog[SHIPVIEW_DIALOG_LIST].d1;
+      sname = shipListboxGetter(si, NULL);
+      if (!sname) 
+        {
+          sprintf(dialog_string[0], "(Null)");
+          sprintf(dialog_string[1], "(Null)");
+        }
+      else 
+        {
+          ShipType *type = fleet->getShipType(si);
 
-	      if (sprite)
-		destroy_bitmap(sprite);
-	      sprite = NULL;
-	      type->data->lock();
-	      if (type->data->spriteShip) 
-		{
-		  sprite = create_bitmap(180, 180);
-		  clear_to_color(sprite, 0);
-		  type->data->spriteShip->draw( 
-					       Vector2(90,90) - type->data->spriteShip->size()/2, 
-					       type->data->spriteShip->size(), 
-					       0, sprite 
-					       );
-		}
-	      type->data->unlock();
-	      
-	      // read ship text file contents
-	      shipviewDialog[SHIPVIEW_DIALOG_TXTFILE].dp = (char*)textFile;
-	      {
-		PACKFILE * f = pack_fopen(type->text, F_READ);
-		if (!f) {
-		  sprintf(textFile, "Failed to load file \"%s\"", type->text);
-		}
-		else {
-		  unsigned long textFileSize = file_size(type->text);
-		  if (textFileSize > MAX_SHIP_TEXT_FILE_SIZE)
-		    textFileSize = MAX_SHIP_TEXT_FILE_SIZE;
-		  i = pack_fread(textFile, textFileSize, f);
-		  pack_fclose(f);
-		  textFile[i] = '\0';
-		}
-	      }
-	      
-	      // read ship ini file contents
-	      char * inifile = "";     // ship ini file contents
-	      {
-		PACKFILE * f = pack_fopen(type->file, F_READ);
-		if (!f) {
-		  inifile = (char*) malloc(strlen("Failed to load file \"\"") + strlen(type->file) + 1);
-		  sprintf(inifile, "Failed to load file \"%s\"", type->file);
-		}
-		else {
-		  unsigned long iniFileSize = file_size(type->file);
-		  inifile = (char*) malloc(iniFileSize +1 );
-		  i = pack_fread(inifile, iniFileSize, f);
-		  pack_fclose(f);
-		  inifile[i] = '\0';
-		}
-	      }
-	      
-	      // display ship description contents
-	      char *c = (char*)malloc( strlen("Name: \n") + strlen(type->name) +
-				       strlen("ID: \n")+strlen(type->id) +
-				       strlen("Cost: \n")+3+
-				       strlen("\n\n\n\nINI file: ()\n")+strlen(type->file) +
-				       strlen("-------------------------\n")+strlen(inifile) );
-	      char * description = c;
-	      
-	      c += sprintf(c, "Name: %s\n", type->name);
-	      c += sprintf(c, "ID: %s\n", type->id);
-	      c += sprintf(c, "Cost: %d\n", type->cost);
-	      c += sprintf(c, "\n\n\n\nINI file: (%s)\n", type->file);
-	      c += sprintf(c, "-------------------------\n%s", inifile);
-				
-	      if (shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp &&
-		  strlen((char*)(shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp))>0 )
-		{
-		  free(shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp);
-		  shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp = (char*)"";
-		}
-	      shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp = description;
-				
-	      if (strlen(inifile) >0)
-		free(inifile);
-	    }
-	  shipviewDialog[SHIPVIEW_DIALOG_PICTURES+0].dp = sprite;
-	}
+          if (sprite)
+        destroy_bitmap(sprite);
+          sprite = NULL;
+          type->data->lock();
+          if (type->data->spriteShip) 
+        {
+          sprite = create_bitmap(180, 180);
+          clear_to_color(sprite, 0);
+          type->data->spriteShip->draw( 
+                           Vector2(90,90) - type->data->spriteShip->size()/2, 
+                           type->data->spriteShip->size(), 
+                           0, sprite 
+                           );
+        }
+          type->data->unlock();
+          
+          // read ship text file contents
+          shipviewDialog[SHIPVIEW_DIALOG_TXTFILE].dp = (char*)textFile;
+          {
+        PACKFILE * f = pack_fopen(type->text, F_READ);
+        if (!f) {
+          sprintf(textFile, "Failed to load file \"%s\"", type->text);
+        }
+        else {
+          unsigned long textFileSize = file_size(type->text);
+          if (textFileSize > MAX_SHIP_TEXT_FILE_SIZE)
+            textFileSize = MAX_SHIP_TEXT_FILE_SIZE;
+          i = pack_fread(textFile, textFileSize, f);
+          pack_fclose(f);
+          textFile[i] = '\0';
+        }
+          }
+          
+          // read ship ini file contents
+          char * inifile = "";     // ship ini file contents
+          {
+        PACKFILE * f = pack_fopen(type->file, F_READ);
+        if (!f) {
+          inifile = (char*) malloc(strlen("Failed to load file \"\"") + strlen(type->file) + 1);
+          sprintf(inifile, "Failed to load file \"%s\"", type->file);
+        }
+        else {
+          unsigned long iniFileSize = file_size(type->file);
+          inifile = (char*) malloc(iniFileSize +1 );
+          i = pack_fread(inifile, iniFileSize, f);
+          pack_fclose(f);
+          inifile[i] = '\0';
+        }
+          }
+          
+          // display ship description contents
+          char *c = (char*)malloc( strlen("Name: \n") + strlen(type->name) +
+                       strlen("ID: \n")+strlen(type->id) +
+                       strlen("Cost: \n")+3+
+                       strlen("\n\n\n\nINI file: ()\n")+strlen(type->file) +
+                       strlen("-------------------------\n")+strlen(inifile) );
+          char * description = c;
+          
+          c += sprintf(c, "Name: %s\n", type->name);
+          c += sprintf(c, "ID: %s\n", type->id);
+          c += sprintf(c, "Cost: %d\n", type->cost);
+          c += sprintf(c, "\n\n\n\nINI file: (%s)\n", type->file);
+          c += sprintf(c, "-------------------------\n%s", inifile);
+                
+          if (shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp &&
+          strlen((char*)(shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp))>0 )
+        {
+          free(shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp);
+          shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp = (char*)"";
+        }
+          shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp = description;
+                
+          if (strlen(inifile) >0)
+        free(inifile);
+        }
+      shipviewDialog[SHIPVIEW_DIALOG_PICTURES+0].dp = sprite;
+    }
 
       // change font size - begin
       if (r == SHIPVIEW_DIALOG_FONT) {
-	i = shipviewDialog[SHIPVIEW_DIALOG_TWYIELD+1].d1;
-	i = (((i/2) + 2) % 3) - 1;
-	shipviewDialog[SHIPVIEW_DIALOG_TWYIELD+1].d1 = i*2;
+    i = shipviewDialog[SHIPVIEW_DIALOG_TWYIELD+1].d1;
+    i = (((i/2) + 2) % 3) - 1;
+    shipviewDialog[SHIPVIEW_DIALOG_TWYIELD+1].d1 = i*2;
       }
       // change font size - end
 
@@ -1789,7 +1790,7 @@
       shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp = NULL;
       free(shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp);
     }
-	
+    
   videosystem->redraw();
   return;
 }
@@ -1802,26 +1803,26 @@
 int get_diagnostics_string ( char *dest ) {//returns length of string
   char * tmp = dest;
 
-#	if defined _DEBUG
+#   if defined _DEBUG
   tmp += sprintf(tmp, "DEBUGGING BUILD!\n");
-#	endif
+#   endif
   tmp += sprintf(tmp, "ALLEGRO (.h) version   = Allegro %s, %s\n", 
-		 ALLEGRO_VERSION_STR, ALLEGRO_PLATFORM_STR);
+         ALLEGRO_VERSION_STR, ALLEGRO_PLATFORM_STR);
   tmp += sprintf(tmp, "ALLEGRO (.dll) version = %s\n", allegro_id);
   tmp += sprintf(tmp, "Compiler = ");
-#	if defined __MINGW32__
+#   if defined __MINGW32__
   tmp += sprintf(tmp, "MINGW (gcc)\n");
-#	elif defined __BORLANDC__
+#   elif defined __BORLANDC__
   tmp += sprintf(tmp, "Borland\n");
-#	elif defined _MSC_VER
+#   elif defined _MSC_VER
   tmp += sprintf(tmp, "Microsoft Visual C++\n");
-#	elif defined DJGPP
+#   elif defined DJGPP
   tmp += sprintf(tmp, "DJGPP (gcc)\n");
-#	elif defined __GNUC__
+#   elif defined __GNUC__
   tmp += sprintf(tmp, "gcc\n");
-#	else
+#   else
   tmp += sprintf(tmp, "???\n");
-#	endif
+#   endif
   tmp += sprintf(tmp, "Version = %s\n", tw_version().c_str());
   return tmp - dest;
 }
@@ -1879,30 +1880,30 @@
   while (!key[KEY_F10] && !key[KEY_ESC]) 
     {
       if (videosystem->poll_redraw()) 
-	{
-	  scare_mouse();
-	  videosystem->window.lock();
-	  clear_to_color(videosystem->window.surface, 0);
-	  textprintf(screen, font, 40, 20, palette_color[15], "Press the keys combinations you wish to test");
-	  textprintf(screen, font, 40, 40, palette_color[15], "When you're finished, press ESCAPE or F10");
-	  videosystem->window.unlock();
-	  unscare_mouse();
-	}
+    {
+      scare_mouse();
+      videosystem->window.lock();
+      clear_to_color(videosystem->window.surface, 0);
+      textprintf(screen, font, 40, 20, palette_color[15], "Press the keys combinations you wish to test");
+      textprintf(screen, font, 40, 40, palette_color[15], "When you're finished, press ESCAPE or F10");
+      videosystem->window.unlock();
+      unscare_mouse();
+    }
       rectfill(screen, 50, 60, 500, 60 + 20 * j, palette_color[0]);
       j = 0;
       poll_input();
       for (i = 0; (i < 32767) && (j < 16); i += 1) {
-	if (key_pressed(i)) 
-	  {
-	    key_to_description(i, blah);
-	    scare_mouse();
-	    acquire_screen();
-	    textprintf(screen, font, 50, 60+j*20, palette_color[15], "%s", blah);
-	    release_screen();
-	    unscare_mouse();
-	    j += 1;
-	  }
+    if (key_pressed(i)) 
+      {
+        key_to_description(i, blah);
+        scare_mouse();
+        acquire_screen();
+        textprintf(screen, font, 50, 60+j*20, palette_color[15], "%s", blah);
+        release_screen();
+        unscare_mouse();
+        j += 1;
       }
+      }
       idle(20);
     }
   showTitle();
@@ -1965,7 +1966,7 @@
   if(home == NULL)
     {
       if(strstr(path.c_str(), datafile_path.c_str()))
-	return path;
+    return path;
       std::string pth = append_filename(dest, datafile_path.c_str(), "default_ini", 2039);
       append_filename(dest, pth.c_str(), path.c_str(), 2039);
       return std::string(dest);
@@ -1973,7 +1974,7 @@
   else
     {
       if(strstr(path.c_str(), home))
-	return path;
+    return path;
       return std::string(home) + std::string("/.tw-light/") + path;
     }
 }
@@ -2008,7 +2009,7 @@
       readed = fread(buffer, 1, 1024, fsrc);
       int written = fwrite(buffer, 1, readed,ftrg);
       if(readed != written)
-	tw_error("ACK!!! copy file failed");
+    tw_error("ACK!!! copy file failed");
     }
   fclose(fsrc);
   fclose(ftrg);
@@ -2046,27 +2047,27 @@
   curFile = home_ini_full_path("client.ini"); 
   if(!exists(curFile.c_str()))
     CopyFile(data_full_path("default_ini/client.ini").c_str(),
-	     curFile.c_str());
+         curFile.c_str());
   
   curFile = home_ini_full_path("fleets.ini"); 
   if(!exists(curFile.c_str()))
     CopyFile(data_full_path("default_ini/fleets.ini").c_str(),
-	     curFile.c_str());
+         curFile.c_str());
   
   curFile = home_ini_full_path("scp.ini"); 
   if(!exists(curFile.c_str()))
     CopyFile(data_full_path("default_ini/scp.ini").c_str(),
-	     curFile.c_str());
+         curFile.c_str());
   
   curFile = home_ini_full_path("server.ini"); 
   if(!exists(curFile.c_str()))
     CopyFile(data_full_path("default_ini/server.ini").c_str(),
-	     curFile.c_str());
+         curFile.c_str());
 
   curFile = home_ini_full_path("vobject.ini"); 
   if(!exists(curFile.c_str()))
     CopyFile(data_full_path("default_ini/vobject.ini").c_str(),
-	     curFile.c_str());
+         curFile.c_str());
   
   curFile = home_ini_full_path("ships");
   if(!file_exists(curFile.c_str(), 0, NULL))
@@ -2074,8 +2075,8 @@
   
   std::string path = data_full_path("")+std::string("default_ini/ships/shp*.ini");
   for_each_file( path.c_str(), 
-		 FA_ARCH|FA_RDONLY, 
-		 _copy_ship_ini, 0);
+         FA_ARCH|FA_RDONLY, 
+         _copy_ship_ini, 0);
   return 0;
 }
 

Modified: trunk/source/util/aastr.h
===================================================================
--- trunk/source/util/aastr.h	2005-09-18 19:23:58 UTC (rev 191)
+++ trunk/source/util/aastr.h	2005-09-18 19:57:13 UTC (rev 192)
@@ -200,15 +200,15 @@
 
   // Rotation.  
 void aa_rotate_scaled_bitmap (BITMAP* src, BITMAP* dst,
-		int x, int y, long angle,
-		long scalex, long scaley);
+		int x, int y, fixed angle,
+		fixed scalex, fixed scaley);
 void aa_rotate_scaled_sprite (BITMAP* dst, BITMAP* src,
-		int x, int y, long angle,
-		long scalex, long scaley);
+		int x, int y, fixed angle,
+		fixed scalex, fixed scaley);
 void aa_rotate_bitmap (BITMAP* src, BITMAP* dst,
-		int x, int y, long angle);
+		int x, int y, fixed angle);
 void aa_rotate_sprite (BITMAP* dst, BITMAP* src,
-		int x, int y, long angle);
+		int x, int y, fixed angle);
 
 
 
@@ -222,8 +222,8 @@
 //parameters are long point (32-aa_BITS.aa_BITS) numbers
 
 void _aa_rotate_bitmap (BITMAP *_src, BITMAP *_dst, 
-		int _x, int _y, long _angle,
-		long _scalex, long _scaley, 
+		int _x, int _y, fixed _angle,
+		fixed _scalex, fixed _scaley, 
 		int _mode);
 //destination is in integer format
 //rotation does not yet support the following new features:

Modified: trunk/source/util/aautil.c
===================================================================
--- trunk/source/util/aautil.c	2005-09-18 19:23:58 UTC (rev 191)
+++ trunk/source/util/aautil.c	2005-09-18 19:57:13 UTC (rev 192)
@@ -17,6 +17,9 @@
  * Copyright (C) 1998, 1999  Michael Bukin
  */
 
+#include <stdio.h>
+#include <stdlib.h>
+
 #include "types.h"
 #include "aautil.h"
 #include "aastr.h"
@@ -92,6 +95,7 @@
 #define BLENDER32_WITH_N(bpp,bpp2)    {int c2;c=makecol24(r,g,b);c2=bmp_read##bpp(_addr+_x*((bpp+7)/8));c=_blender_func_24(makecol24(getr##bpp2(c2),getg##bpp2(c2),getb##bpp2(c2)), c, (_aa.trans * _aa.blender_n) >> 8);r=getr24(c);g=getg24(c);b=getb32(c);
 #define BLENDER32_WITH_A(bpp,bpp2)    {int c2;c=makecol24(r,g,b);c2=bmp_read##bpp(_addr+_x*((bpp+7)/8));c=_blender_func_24(makecol24(getr##bpp2(c2),getg##bpp2(c2),getb##bpp2(c2)), c, (_aa.trans * _aa.trans) >> 8);r=getr24(c);g=getg24(c);b=getb32(c);
 
+
 //these macros output the color to the screen
 #define PUT(bpp,bpp2)             bmp_write##bpp(_addr+_x*((bpp+7)/8), c);
 #define PUT_8X(bpp,bpp2)          outportw(0x3C4, (0x100<<(_x&3))|2); bmp_write8(_addr + (_x>>2), c);
@@ -183,20 +187,8 @@
 //no dither-notrans
 //no alpha-dither-notrans
 
-#ifdef GFX_MODEX
-//macro       name                         bpp/2 ALPHA  DITHER     NOTRANS PUT
-MAKE_PUTFUNC( _aa_put_modex_8              ,8,8, NONE,  NO_DITHER, NONE,   PUT_8X)
-MAKE_PUTFUNC( _aa_put_modex_dither_8       ,8,8, NONE,  DITHER,    NONE,   PUT_8X)
-MAKE_PUTFUNC( _aa_put_modex_alpha_8        ,8,8, ALPHA, NO_DITHER, NONE,   PUT_8X)
-MAKE_PUTFUNC( _aa_put_modex_alpha_dither_8 ,8,8, ALPHA, DITHER,    NONE,   PUT_8X)
-PUT_TYPE *put_array_modex[4] = {
-	_aa_put_modex_8,
-	_aa_put_modex_dither_8,
-	_aa_put_modex_alpha_8,
-	_aa_put_modex_alpha_dither_8
-};
-#endif
 
+
 #ifdef ALLEGRO_COLOR16
 MAKE_PUTFUNC( _aa_put_15                       ,16,15, NONE   ,NO_DITHER ,NONE   ,PUT)
 MAKE_PUTFUNC( _aa_put_alpha_15                 ,16,15, ALPHA  ,NO_DITHER ,NONE   ,PUT)

Modified: trunk/source/util/base.cpp
===================================================================
--- trunk/source/util/base.cpp	2005-09-18 19:23:58 UTC (rev 191)
+++ trunk/source/util/base.cpp	2005-09-18 19:57:13 UTC (rev 192)
@@ -7,8 +7,8 @@
 COMPILE_TIME_ASSERT(sizeof(char)==1);
 COMPILE_TIME_ASSERT(sizeof(short)==2);
 COMPILE_TIME_ASSERT(sizeof(int)==4);
-COMPILE_TIME_ASSERT(sizeof(long)==4);
 
+
 __call_before_main::__call_before_main ( void (*func)() ) {
 	func();
 }

Modified: trunk/source/util/net_tcp.cpp
===================================================================
--- trunk/source/util/net_tcp.cpp	2005-09-18 19:23:58 UTC (rev 191)
+++ trunk/source/util/net_tcp.cpp	2005-09-18 19:57:13 UTC (rev 192)
@@ -185,7 +185,8 @@
 #	elif defined NETWORK_BSD
 #		if defined NETWORK_WEIRD_SIGNEDNESS
 			//WTF!?! 
-			size_t tmp; 
+//			size_t tmp; 
+			socklen_t tmp;
 			//some linuxes (but not the version superdave uses (slackware of some 
 			//kind)) require this, even though some linux documentation contradicts 
 			//it and it differs from the BSD standard, and it's incompatible with some 

Modified: trunk/source/util/pmask.h
===================================================================
--- trunk/source/util/pmask.h	2005-09-18 19:23:58 UTC (rev 191)
+++ trunk/source/util/pmask.h	2005-09-18 19:57:13 UTC (rev 192)
@@ -1,6 +1,7 @@
 #ifndef __PMASK_H__
 #define __PMASK_H__
 
+#include <limits.h>
 /*
 This is the Pixel MASK library, which does pixel-perfect collisions using
 bit masks.
@@ -48,9 +49,20 @@
 //e.g. 4 for 16-bit ints, 5 for 32-bit ints, 6 for 64-bit ints
 //don't worry about setting it incorrectly
 //you'll get a compile error if you do, not a run-time error
+
+#if ULONG_MAX == 0xFFFFFFFFUL
 #define MASK_WORD_BITBITS 5
+#else
+#define MASK_WORD_BITBITS 6
+#endif
 
+//#ifdef NATIVE_64
+//#define MASK_WORD_BITBITS 6
+//#else
+//#define MASK_WORD_BITBITS 5
+//#endif
 
+
 //if SINGLE_MEMORY_BLOCK is defined
 //then each mask will be allocated as
 //only a single memory block.  



From yurand at berlios.de  Sat Sep 24 07:43:00 2005
From: yurand at berlios.de (Yura Semashko at BerliOS)
Date: Sat, 24 Sep 2005 07:43:00 +0200
Subject: [Tw-light-svn] r193 - in trunk: . mingw-libs/include msvc-libs/include source/libraries source/libraries/boost source/libraries/boost/config source/libraries/boost/config/abi source/libraries/boost/config/compiler source/libraries/boost/config/platform source/libraries/boost/config/stdlib source/libraries/boost/detail
Message-ID: <200509240543.j8O5h0Dt013684@sheep.berlios.de>

Author: yurand
Date: 2005-09-24 07:41:48 +0200 (Sat, 24 Sep 2005)
New Revision: 193

Added:
   trunk/source/libraries/boost/
   trunk/source/libraries/boost/assert.hpp
   trunk/source/libraries/boost/checked_delete.hpp
   trunk/source/libraries/boost/config.hpp
   trunk/source/libraries/boost/config/
   trunk/source/libraries/boost/config/abi/
   trunk/source/libraries/boost/config/abi/borland_prefix.hpp
   trunk/source/libraries/boost/config/abi/borland_suffix.hpp
   trunk/source/libraries/boost/config/abi/msvc_prefix.hpp
   trunk/source/libraries/boost/config/abi/msvc_suffix.hpp
   trunk/source/libraries/boost/config/abi_prefix.hpp
   trunk/source/libraries/boost/config/abi_suffix.hpp
   trunk/source/libraries/boost/config/auto_link.hpp
   trunk/source/libraries/boost/config/compiler/
   trunk/source/libraries/boost/config/compiler/borland.hpp
   trunk/source/libraries/boost/config/compiler/comeau.hpp
   trunk/source/libraries/boost/config/compiler/common_edg.hpp
   trunk/source/libraries/boost/config/compiler/compaq_cxx.hpp
   trunk/source/libraries/boost/config/compiler/digitalmars.hpp
   trunk/source/libraries/boost/config/compiler/gcc.hpp
   trunk/source/libraries/boost/config/compiler/greenhills.hpp
   trunk/source/libraries/boost/config/compiler/hp_acc.hpp
   trunk/source/libraries/boost/config/compiler/intel.hpp
   trunk/source/libraries/boost/config/compiler/kai.hpp
   trunk/source/libraries/boost/config/compiler/metrowerks.hpp
   trunk/source/libraries/boost/config/compiler/mpw.hpp
   trunk/source/libraries/boost/config/compiler/sgi_mipspro.hpp
   trunk/source/libraries/boost/config/compiler/sunpro_cc.hpp
   trunk/source/libraries/boost/config/compiler/vacpp.hpp
   trunk/source/libraries/boost/config/compiler/visualc.hpp
   trunk/source/libraries/boost/config/platform/
   trunk/source/libraries/boost/config/platform/aix.hpp
   trunk/source/libraries/boost/config/platform/amigaos.hpp
   trunk/source/libraries/boost/config/platform/beos.hpp
   trunk/source/libraries/boost/config/platform/bsd.hpp
   trunk/source/libraries/boost/config/platform/cygwin.hpp
   trunk/source/libraries/boost/config/platform/hpux.hpp
   trunk/source/libraries/boost/config/platform/irix.hpp
   trunk/source/libraries/boost/config/platform/linux.hpp
   trunk/source/libraries/boost/config/platform/macos.hpp
   trunk/source/libraries/boost/config/platform/solaris.hpp
   trunk/source/libraries/boost/config/platform/win32.hpp
   trunk/source/libraries/boost/config/posix_features.hpp
   trunk/source/libraries/boost/config/requires_threads.hpp
   trunk/source/libraries/boost/config/select_compiler_config.hpp
   trunk/source/libraries/boost/config/select_platform_config.hpp
   trunk/source/libraries/boost/config/select_stdlib_config.hpp
   trunk/source/libraries/boost/config/stdlib/
   trunk/source/libraries/boost/config/stdlib/dinkumware.hpp
   trunk/source/libraries/boost/config/stdlib/libcomo.hpp
   trunk/source/libraries/boost/config/stdlib/libstdcpp3.hpp
   trunk/source/libraries/boost/config/stdlib/modena.hpp
   trunk/source/libraries/boost/config/stdlib/msl.hpp
   trunk/source/libraries/boost/config/stdlib/roguewave.hpp
   trunk/source/libraries/boost/config/stdlib/sgi.hpp
   trunk/source/libraries/boost/config/stdlib/stlport.hpp
   trunk/source/libraries/boost/config/stdlib/vacpp.hpp
   trunk/source/libraries/boost/config/suffix.hpp
   trunk/source/libraries/boost/config/user.hpp
   trunk/source/libraries/boost/detail/
   trunk/source/libraries/boost/detail/lightweight_mutex.hpp
   trunk/source/libraries/boost/detail/lwm_pthreads.hpp
   trunk/source/libraries/boost/detail/lwm_win32.hpp
   trunk/source/libraries/boost/detail/lwm_win32_cs.hpp
   trunk/source/libraries/boost/detail/lwm_win32_nt.hpp
   trunk/source/libraries/boost/detail/shared_count.hpp
   trunk/source/libraries/boost/detail/workaround.hpp
   trunk/source/libraries/boost/non_type.hpp
   trunk/source/libraries/boost/scoped_array.hpp
   trunk/source/libraries/boost/scoped_ptr.hpp
   trunk/source/libraries/boost/shared_array.hpp
   trunk/source/libraries/boost/shared_container_iterator.hpp
   trunk/source/libraries/boost/shared_ptr.hpp
   trunk/source/libraries/boost/smart_ptr.hpp
   trunk/source/libraries/boost/throw_exception.hpp
   trunk/source/libraries/boost/type.hpp
   trunk/source/libraries/boost/weak_ptr.hpp
Removed:
   trunk/mingw-libs/include/boost/
   trunk/msvc-libs/include/boost/
Modified:
   trunk/SConstruct
   trunk/makefile
   trunk/sources.lst
Log:
fixed make command
removed boost depend

Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/SConstruct	2005-09-24 05:41:48 UTC (rev 193)
@@ -251,7 +251,7 @@
                        'TW_SVNVERSION=\\"' + SVNVERSION+ '\\"'])
 
 env.Append(LIBS =  ["alleg", "winmm", "ws2_32", "SDL","SDLmain","SDL_mixer","python24","z"])
-env.Append(CPPPATH=["#source"])
+env.Append(CPPPATH=["#source","#source/libraries"])
 
 tw = env.Program("tw-light", twsource)
 

Modified: trunk/makefile
===================================================================
--- trunk/makefile	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/makefile	2005-09-24 05:41:48 UTC (rev 193)
@@ -178,9 +178,8 @@
 
 source/generated/tml_wrap.cpp: source/python/game.i source/tml/gameaction.h source/util/sound.h source/tml/gameconfig.h source/tml/gamedialog.h source/tml/eventmanager.h
 	$(SWIG) -c++ -python -o source/generated/tml_wrap.cpp -outdir source/generated/ source/python/game.i
-	cp source/generated/tml.py $(DATAPATH)/python/
+	cp source/generated/tml.py gamedata/python/
 
-
 $(OBJDIR)/%.o: %.cpp
 	$(CX) -MMD $(CFLAGS) -c $< -o $@
 
@@ -227,6 +226,7 @@
 install:
 	./install-sh -c -m 755 $(NAME) $(EXECPATH)/$(NAME)
 	CPPROG="cp -r" ./install-sh -c gamedata $(DATAPATH)
+	cp source/generated/tml.py $(DATAPATH)/python/
 
 uninstall:
 	$(RM) $(EXECPATH)/$(NAME)

Added: trunk/source/libraries/boost/assert.hpp
===================================================================
--- trunk/source/libraries/boost/assert.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/assert.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,38 @@
+//
+//  boost/assert.hpp - BOOST_ASSERT(expr)
+//
+//  Copyright (c) 2001, 2002 Peter Dimov and Multi Media Ltd.
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided "as is" without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  Note: There are no include guards. This is intentional.
+//
+//  See http://www.boost.org/libs/utility/assert.html for documentation.
+//
+
+#undef BOOST_ASSERT
+
+#if defined(BOOST_DISABLE_ASSERTS)
+
+# define BOOST_ASSERT(expr) ((void)0)
+
+#elif defined(BOOST_ENABLE_ASSERT_HANDLER)
+
+#include <boost/current_function.hpp>
+
+namespace boost
+{
+
+void assertion_failed(char const * expr, char const * function, char const * file, long line); // user defined
+
+} // namespace boost
+
+#define BOOST_ASSERT(expr) ((expr)? ((void)0): ::boost::assertion_failed(#expr, BOOST_CURRENT_FUNCTION, __FILE__, __LINE__))
+
+#else
+# include <assert.h>
+# define BOOST_ASSERT(expr) assert(expr)
+#endif

Added: trunk/source/libraries/boost/checked_delete.hpp
===================================================================
--- trunk/source/libraries/boost/checked_delete.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/checked_delete.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,71 @@
+#ifndef BOOST_CHECKED_DELETE_HPP_INCLUDED
+#define BOOST_CHECKED_DELETE_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  boost/checked_delete.hpp
+//
+//  Copyright (c) 1999, 2000, 2001, 2002 boost.org
+//  Copyright (c) 2002, 2003 Peter Dimov
+//  Copyright (c) 2003 Daniel Frey
+//  Copyright (c) 2003 Howard Hinnant
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided "as is" without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  See http://www.boost.org/libs/utility/checked_delete.html for documentation.
+//
+
+namespace boost
+{
+
+// verify that types are complete for increased safety
+
+template<class T> inline void checked_delete(T * x)
+{
+    // intentionally complex - simplification causes regressions
+    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
+    (void) sizeof(type_must_be_complete);
+    delete x;
+}
+
+template<class T> inline void checked_array_delete(T * x)
+{
+    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
+    (void) sizeof(type_must_be_complete);
+    delete [] x;
+}
+
+template<class T> struct checked_deleter
+{
+    typedef void result_type;
+    typedef T * argument_type;
+
+    void operator()(T * x) const
+    {
+        // boost:: disables ADL
+        boost::checked_delete(x);
+    }
+};
+
+template<class T> struct checked_array_deleter
+{
+    typedef void result_type;
+    typedef T * argument_type;
+
+    void operator()(T * x) const
+    {
+        boost::checked_array_delete(x);
+    }
+};
+
+} // namespace boost
+
+#endif  // #ifndef BOOST_CHECKED_DELETE_HPP_INCLUDED

Added: trunk/source/libraries/boost/config/abi/borland_prefix.hpp
===================================================================
--- trunk/source/libraries/boost/config/abi/borland_prefix.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/abi/borland_prefix.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,27 @@
+//  (C) Copyright John Maddock 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  for C++ Builder the following options effect the ABI:
+//
+//  -b (on or off - effect emum sizes)
+//  -Vx  (on or off - empty members)
+//  -Ve (on or off - empty base classes)
+//  -aX (alignment - 5 options).
+//  -pX (Calling convention - 4 options)
+//  -VmX (member pointer size and layout - 5 options)
+//  -VC (on or off, changes name mangling)
+//  -Vl (on or off, changes struct layout).
+
+//  In addition the following warnings are sufficiently annoying (and
+//  unfixable) to have them turned off by default:
+//
+//  8027 - functions containing [for|while] loops are not expanded inline
+//  8026 - functions taking class by value arguments are not expanded inline
+
+#pragma nopushoptwarn
+#  pragma option push -Vx -Ve -a8 -b -pc -Vmv -VC- -Vl- -w-8027 -w-8026
+
+
+

Added: trunk/source/libraries/boost/config/abi/borland_suffix.hpp
===================================================================
--- trunk/source/libraries/boost/config/abi/borland_suffix.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/abi/borland_suffix.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,12 @@
+//  (C) Copyright John Maddock 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#  pragma option pop
+#pragma nopushoptwarn
+
+
+
+
+

Added: trunk/source/libraries/boost/config/abi/msvc_prefix.hpp
===================================================================
--- trunk/source/libraries/boost/config/abi/msvc_prefix.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/abi/msvc_prefix.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,8 @@
+//  (C) Copyright John Maddock 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#pragma pack(push,8)
+
+

Added: trunk/source/libraries/boost/config/abi/msvc_suffix.hpp
===================================================================
--- trunk/source/libraries/boost/config/abi/msvc_suffix.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/abi/msvc_suffix.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,8 @@
+//  (C) Copyright John Maddock 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#pragma pack(pop)
+
+

Added: trunk/source/libraries/boost/config/abi_prefix.hpp
===================================================================
--- trunk/source/libraries/boost/config/abi_prefix.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/abi_prefix.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,20 @@
+//  abi_prefix header  -------------------------------------------------------//
+
+// ? Copyright John Maddock 2003
+   
+// Use, modification and distribution are subject to the Boost Software License,
+// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt).
+
+#ifndef BOOST_CONFIG_ABI_PREFIX_HPP
+# define BOOST_CONFIG_ABI_PREFIX_HPP
+#else
+# error double inclusion of header boost/config/abi_prefix.hpp is an error
+#endif
+
+#include <boost/config.hpp>
+
+// this must occur after all other includes and before any code appears:
+#ifdef BOOST_HAS_ABI_HEADERS
+#  include BOOST_ABI_PREFIX
+#endif

Added: trunk/source/libraries/boost/config/abi_suffix.hpp
===================================================================
--- trunk/source/libraries/boost/config/abi_suffix.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/abi_suffix.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,23 @@
+//  abi_sufffix header  -------------------------------------------------------//
+
+// ? Copyright John Maddock 2003
+   
+// Use, modification and distribution are subject to the Boost Software License,
+// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt).
+
+// This header should be #included AFTER code that was preceded by a #include
+// <boost/config/abi_prefix.hpp>.
+
+#ifndef BOOST_CONFIG_ABI_PREFIX_HPP
+# error Header boost/config/abi_prefix.hpp must only be used after boost/config/abi_prefix.hpp
+#else
+# undef BOOST_CONFIG_ABI_PREFIX_HPP
+#endif
+
+// the suffix header occurs after all of our code:
+#ifdef BOOST_HAS_ABI_HEADERS
+#  include BOOST_ABI_SUFFIX
+#endif
+
+

Added: trunk/source/libraries/boost/config/auto_link.hpp
===================================================================
--- trunk/source/libraries/boost/config/auto_link.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/auto_link.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,331 @@
+//  (C) Copyright John Maddock 2003.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+ /*
+  *   LOCATION:    see http://www.boost.org for most recent version.
+  *   FILE         auto_link.hpp
+  *   VERSION      see <boost/version.hpp>
+  *   DESCRIPTION: Automatic library inclusion for Borland/Microsoft compilers.
+  */
+
+/*************************************************************************
+
+USAGE:
+~~~~~~
+
+Before including this header you must define one or more of define the following macros:
+
+BOOST_LIB_NAME:       Required: A string containing the basename of the library,
+                      for example boost_regex.
+BOOST_DYN_LINK:       Optional: when set link to dll rather than static library.
+BOOST_LIB_DIAGNOSTIC: Optional: when set the header will print out the name
+                      of the library selected (useful for debugging).
+
+These macros will be undef'ed at the end of the header, further this header
+has no include guards - so be sure to include it only once from your library!
+
+Algorithm:
+~~~~~~~~~~
+
+Libraries for Borland and Microsoft compilers are automatically
+selected here, the name of the lib is selected according to the following
+formula:
+
+BOOST_LIB_PREFIX
+   + BOOST_LIB_NAME
+   + "_"
+   + BOOST_LIB_TOOLSET
+   + BOOST_LIB_THREAD_OPT
+   + BOOST_LIB_RT_OPT
+   "-"
+   + BOOST_LIB_VERSION
+
+These are defined as:
+
+BOOST_LIB_PREFIX:     "lib" for static libraries otherwise "".
+
+BOOST_LIB_NAME:       The base name of the lib ( for example boost_regex).
+
+BOOST_LIB_TOOLSET:    The compiler toolset name (vc6, vc7, bcb5 etc).
+
+BOOST_LIB_THREAD_OPT: "-mt" for multithread builds, otherwise nothing.
+
+BOOST_LIB_RT_OPT:     A suffix that indicates the runtime library used,
+                      contains one or more of the following letters after
+                      a hiphen:
+
+                      s      static runtime (dynamic if not present).
+                      d      debug build (release if not present).
+                      g      debug/diagnostic runtime (release if not present).
+                      p      STLPort Build.
+
+BOOST_LIB_VERSION:    The Boost version, in the form x_y, for Boost version x.y.
+
+
+***************************************************************************/
+
+#ifdef __cplusplus
+#  ifndef BOOST_CONFIG_HPP
+#     include <boost/config.hpp>
+#  endif
+#elif defined(_MSC_VER) && !defined(__MWERKS__) && !defined(__EDG_VERSION__)
+//
+// C language compatability (no, honestly)
+//
+#  define BOOST_MSVC _MSC_VER
+#  define BOOST_STRINGIZE(X) BOOST_DO_STRINGIZE(X)
+#  define BOOST_DO_STRINGIZE(X) #X
+#endif
+//
+// Only include what follows for known and supported compilers:
+//
+#if (defined(BOOST_MSVC) && defined(_MSC_EXTENSIONS)) \
+    || defined(__BORLANDC__) \
+    || (defined(__MWERKS__) && defined(_WIN32) && (__MWERKS__ >= 0x3000)) \
+    || (defined(__ICL) && defined(_MSC_EXTENSIONS) && (_MSC_VER >= 1200))
+
+#ifndef BOOST_VERSION_HPP
+#  include <boost/version.hpp>
+#endif
+
+#ifndef BOOST_LIB_NAME
+#  error "Macro BOOST_LIB_NAME not set (internal error)"
+#endif
+
+//
+// error check:
+//
+#if defined(__MSVC_RUNTIME_CHECKS) && !defined(_DEBUG)
+#  pragma message("Using the /RTC option without specifying a debug runtime will lead to linker errors")
+#  pragma message("Hint: go to the code generation options and switch to one of the debugging runtimes")
+#  error "Incompatible build options"
+#endif
+//
+// select toolset:
+//
+#if defined(BOOST_MSVC) && (BOOST_MSVC == 1200)
+
+   // vc6:
+#  define BOOST_LIB_TOOLSET "vc6"
+
+#elif defined(BOOST_MSVC) && (BOOST_MSVC == 1300)
+
+   // vc7:
+#  define BOOST_LIB_TOOLSET "vc7"
+
+#elif defined(BOOST_MSVC) && (BOOST_MSVC >= 1310)
+
+   // vc71:
+#  define BOOST_LIB_TOOLSET "vc71"
+
+#elif defined(__BORLANDC__)
+
+   // CBuilder 6:
+#  define BOOST_LIB_TOOLSET "bcb"
+
+#elif defined(__ICL)
+
+   // Intel C++, no version number:
+#  define BOOST_LIB_TOOLSET "iw"
+
+#elif defined(__MWERKS__) && (__MWERKS__ <= 0x31FF )
+
+   // Metrowerks CodeWarrior 8.x
+#  define BOOST_LIB_TOOLSET "cw8"
+
+#elif defined(__MWERKS__) && (__MWERKS__ <= 0x32FF )
+
+   // Metrowerks CodeWarrior 9.x
+#  define BOOST_LIB_TOOLSET "cw9"
+
+#endif
+
+//
+// select thread opt:
+//
+#if defined(_MT) || defined(__MT__)
+#  define BOOST_LIB_THREAD_OPT "-mt"
+#else
+#  define BOOST_LIB_THREAD_OPT
+#endif
+
+#if defined(_MSC_VER) || defined(__MWERKS__)
+
+#  ifdef _DLL
+
+#     if (defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)) && (defined(_STLP_OWN_IOSTREAMS) || defined(__STL_OWN_IOSTREAMS))
+
+#        if defined(_DEBUG) && (defined(__STL_DEBUG) || defined(_STLP_DEBUG))
+#            define BOOST_LIB_RT_OPT "-gdp"
+#        elif defined(_DEBUG)
+#            define BOOST_LIB_RT_OPT "-gdp"
+#            pragma message("warning: STLPort debug versions are built with /D_STLP_DEBUG=1")
+#            error "Build options aren't compatible with pre-built libraries"
+#        else
+#            define BOOST_LIB_RT_OPT "-p"
+#        endif
+
+#     elif defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)
+
+#        if defined(_DEBUG) && (defined(__STL_DEBUG) || defined(_STLP_DEBUG))
+#            define BOOST_LIB_RT_OPT "-gdpn"
+#        elif defined(_DEBUG)
+#            define BOOST_LIB_RT_OPT "-gdpn"
+#            pragma message("warning: STLPort debug versions are built with /D_STLP_DEBUG=1")
+#            error "Build options aren't compatible with pre-built libraries"
+#        else
+#            define BOOST_LIB_RT_OPT "-pn"
+#        endif
+
+#     else
+
+#        if defined(_DEBUG)
+#            define BOOST_LIB_RT_OPT "-gd"
+#        else
+#            define BOOST_LIB_RT_OPT
+#        endif
+
+#     endif
+
+#  else
+
+#     if (defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)) && (defined(_STLP_OWN_IOSTREAMS) || defined(__STL_OWN_IOSTREAMS))
+
+#        if defined(_DEBUG) && (defined(__STL_DEBUG) || defined(_STLP_DEBUG))
+#            define BOOST_LIB_RT_OPT "-sgdp"
+#        elif defined(_DEBUG)
+#             define BOOST_LIB_RT_OPT "-sgdp"
+#            pragma message("warning: STLPort debug versions are built with /D_STLP_DEBUG=1")
+#            error "Build options aren't compatible with pre-built libraries"
+#        else
+#            define BOOST_LIB_RT_OPT "-sp"
+#        endif
+
+#     elif defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)
+
+#        if defined(_DEBUG) && (defined(__STL_DEBUG) || defined(_STLP_DEBUG))
+#            define BOOST_LIB_RT_OPT "-sgdpn"
+#        elif defined(_DEBUG)
+#             define BOOST_LIB_RT_OPT "-sgdpn"
+#            pragma message("warning: STLPort debug versions are built with /D_STLP_DEBUG=1")
+#            error "Build options aren't compatible with pre-built libraries"
+#        else
+#            define BOOST_LIB_RT_OPT "-spn"
+#        endif
+
+#     else
+
+#        if defined(_DEBUG)
+#             define BOOST_LIB_RT_OPT "-sgd"
+#        else
+#            define BOOST_LIB_RT_OPT "-s"
+#        endif
+
+#     endif
+
+#  endif
+
+#elif defined(__BORLANDC__)
+
+//
+// figure out whether we want the debug builds or not:
+//
+#pragma defineonoption BOOST_BORLAND_DEBUG -v
+//
+// sanity check:
+//
+#if defined(__STL_DEBUG) || defined(_STLP_DEBUG)
+#error "Pre-built versions of the Boost libraries are not provided in STLPort-debug form"
+#endif
+
+#  ifdef _RTLDLL
+
+#     ifdef BOOST_BORLAND_DEBUG
+#         define BOOST_LIB_RT_OPT "-d"
+#     else
+#         define BOOST_LIB_RT_OPT
+#     endif
+
+#  else
+
+#     ifdef BOOST_BORLAND_DEBUG
+#         define BOOST_LIB_RT_OPT "-sd"
+#     else
+#         define BOOST_LIB_RT_OPT "-s"
+#     endif
+
+#  endif
+
+#endif
+
+//
+// select linkage opt:
+//
+#if (defined(_DLL) || defined(_RTLDLL)) && defined(BOOST_DYN_LINK)
+#  define BOOST_LIB_PREFIX
+#elif defined(BOOST_DYN_LINK)
+#  error "Mixing a dll boost library with a static runtime is a really bad idea..."
+#else
+#  define BOOST_LIB_PREFIX "lib"
+#endif
+
+//
+// now include the lib:
+//
+#if defined(BOOST_LIB_NAME) \
+      && defined(BOOST_LIB_PREFIX) \
+      && defined(BOOST_LIB_TOOLSET) \
+      && defined(BOOST_LIB_THREAD_OPT) \
+      && defined(BOOST_LIB_RT_OPT) \
+      && defined(BOOST_LIB_VERSION)
+
+#  pragma comment(lib, BOOST_LIB_PREFIX BOOST_STRINGIZE(BOOST_LIB_NAME) "-" BOOST_LIB_TOOLSET BOOST_LIB_THREAD_OPT BOOST_LIB_RT_OPT "-" BOOST_LIB_VERSION ".lib")
+#ifdef BOOST_LIB_DIAGNOSTIC
+#  pragma message ("Linking to lib file: " BOOST_LIB_PREFIX BOOST_STRINGIZE(BOOST_LIB_NAME) "-" BOOST_LIB_TOOLSET BOOST_LIB_THREAD_OPT BOOST_LIB_RT_OPT "-" BOOST_LIB_VERSION ".lib")
+#endif
+
+#else
+#  error "some required macros where not defined (internal logic error)."
+#endif
+
+
+#endif // _MSC_VER || __BORLANDC__
+
+//
+// finally undef any macros we may have set:
+//
+#ifdef BOOST_LIB_PREFIX
+#  undef BOOST_LIB_PREFIX
+#endif
+#if defined(BOOST_LIB_NAME)
+#  undef BOOST_LIB_NAME
+#endif
+#if defined(BOOST_LIB_TOOLSET)
+#  undef BOOST_LIB_TOOLSET
+#endif
+#if defined(BOOST_LIB_THREAD_OPT)
+#  undef BOOST_LIB_THREAD_OPT
+#endif
+#if defined(BOOST_LIB_RT_OPT)
+#  undef BOOST_LIB_RT_OPT
+#endif
+#if defined(BOOST_LIB_LINK_OPT)
+#  undef BOOST_LIB_LINK_OPT
+#endif
+#if defined(BOOST_LIB_DEBUG_OPT)
+#  undef BOOST_LIB_DEBUG_OPT
+#endif
+#if defined(BOOST_DYN_LINK)
+#  undef BOOST_DYN_LINK
+#endif
+
+
+
+
+
+
+
+
+

Added: trunk/source/libraries/boost/config/compiler/borland.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/borland.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/borland.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,167 @@
+//  (C) Copyright John Maddock 2001 - 2003.
+//  (C) Copyright David Abrahams 2002 - 2003.
+//  (C) Copyright Aleksey Gurtovoy 2002.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Borland C++ compiler setup:
+
+// Version 5.0 and below:
+#   if __BORLANDC__ <= 0x0550
+// Borland C++Builder 4 and 5:
+#     define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#     if __BORLANDC__ == 0x0550
+// Borland C++Builder 5, command-line compiler 5.5:
+#       define BOOST_NO_OPERATORS_IN_NAMESPACE
+#     endif
+#   endif
+
+// Version 5.51 and below:
+#if (__BORLANDC__ <= 0x551)
+#  define BOOST_NO_CV_SPECIALIZATIONS
+#  define BOOST_NO_CV_VOID_SPECIALIZATIONS
+#  define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#  define BOOST_NO_DEDUCED_TYPENAME
+#endif
+
+#if (__BORLANDC__ <= 0x564)
+#  define BOOST_NO_SFINAE
+#endif
+
+// Version 7.0 (Kylix) and below:
+#if (__BORLANDC__ <= 0x570)
+#  define BOOST_NO_INTEGRAL_INT64_T
+#  define BOOST_NO_DEPENDENT_NESTED_DERIVATIONS
+#  define BOOST_NO_PRIVATE_IN_AGGREGATE
+#  define BOOST_NO_USING_TEMPLATE
+#  define BOOST_BCB_PARTIAL_SPECIALIZATION_BUG
+#  define BOOST_NO_TEMPLATE_TEMPLATES
+#  define BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE
+   // we shouldn't really need this - but too many things choke
+   // without it, this needs more investigation:
+#  define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#  define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
+#  ifdef NDEBUG
+      // fix broken <cstring> so that Boost.test works:
+#     include <cstring>
+#     undef strcmp
+#  endif
+
+//
+// new bug in 5.61:
+#if (__BORLANDC__ >= 0x561) && (__BORLANDC__ <= 0x570)
+   // this seems to be needed by the command line compiler, but not the IDE:
+#  define BOOST_NO_MEMBER_FUNCTION_SPECIALIZATIONS
+#endif
+
+#  ifdef _WIN32
+#     define BOOST_NO_SWPRINTF
+#  elif defined(linux) || defined(__linux__) || defined(__linux)
+      // we should really be able to do without this
+      // but the wcs* functions aren't imported into std::
+#     define BOOST_NO_STDC_NAMESPACE
+      // _CPPUNWIND doesn't get automatically set for some reason:
+#     pragma defineonoption BOOST_CPPUNWIND -x
+#  endif
+#endif
+
+//
+// Post 0x561 we have long long and stdint.h:
+#if __BORLANDC__ >= 0x561
+#  ifndef __NO_LONG_LONG
+#     define BOOST_HAS_LONG_LONG
+#  endif
+   // On non-Win32 platforms let the platform config figure this out:
+#  ifdef _WIN32
+#      define BOOST_HAS_STDINT_H
+#  endif
+#endif
+
+// Borland C++Builder 6 defaults to using STLPort.  If _USE_OLD_RW_STL is
+// defined, then we have 0x560 or greater with the Rogue Wave implementation
+// which presumably has the std::DBL_MAX bug.
+#if ((__BORLANDC__ >= 0x550) && (__BORLANDC__ < 0x560)) || defined(_USE_OLD_RW_STL)
+// <climits> is partly broken, some macros define symbols that are really in
+// namespace std, so you end up having to use illegal constructs like
+// std::DBL_MAX, as a fix we'll just include float.h and have done with:
+#include <float.h>
+#endif
+//
+// __int64:
+//
+#if (__BORLANDC__ >= 0x530) && !defined(__STRICT_ANSI__)
+#  define BOOST_HAS_MS_INT64
+#endif
+//
+// check for exception handling support:
+//
+#if !defined(_CPPUNWIND) && !defined(BOOST_CPPUNWIND) && !defined(__EXCEPTIONS)
+#  define BOOST_NO_EXCEPTIONS
+#endif
+//
+// all versions have a <dirent.h>:
+//
+#ifndef __STRICT_ANSI__
+#  define BOOST_HAS_DIRENT_H
+#endif
+//
+// all versions support __declspec:
+//
+#ifndef __STRICT_ANSI__
+#  define BOOST_HAS_DECLSPEC
+#endif
+//
+// ABI fixing headers:
+//
+#if __BORLANDC__ < 0x600 // not implemented for version 6 compiler yet
+#ifndef BOOST_ABI_PREFIX
+#  define BOOST_ABI_PREFIX "boost/config/abi/borland_prefix.hpp"
+#endif
+#ifndef BOOST_ABI_SUFFIX
+#  define BOOST_ABI_SUFFIX "boost/config/abi/borland_suffix.hpp"
+#endif
+#endif
+//
+// Disable Win32 support in ANSI mode:
+//
+#if __BORLANDC__ < 0x600
+#  pragma defineonoption BOOST_DISABLE_WIN32 -A
+#elif defined(__STRICT_ANSI__)
+#  define BOOST_DISABLE_WIN32
+#endif
+//
+// MSVC compatibility mode does some nasty things:
+//
+#if defined(_MSC_VER) && (_MSC_VER <= 1200)
+#  define BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP
+#  define BOOST_NO_VOID_RETURNS
+#endif
+
+#define BOOST_COMPILER "Borland C++ version " BOOST_STRINGIZE(__BORLANDC__)
+
+//
+// versions check:
+// we don't support Borland prior to version 5.4:
+#if __BORLANDC__ < 0x540
+#  error "Compiler not supported or configured - please reconfigure"
+#endif
+//
+// last known and checked version is 1536 (Builder X preview):
+#if (__BORLANDC__ > 1536)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error "Unknown compiler version - please run the configure tests and report the results"
+#  else
+#     pragma message( "Unknown compiler version - please run the configure tests and report the results")
+#  endif
+#endif
+
+
+
+
+
+
+
+

Added: trunk/source/libraries/boost/config/compiler/comeau.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/comeau.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/comeau.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,64 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright Douglas Gregor 2001. 
+//  (C) Copyright Peter Dimov 2001. 
+//  (C) Copyright Aleksey Gurtovoy 2003. 
+//  (C) Copyright Beman Dawes 2003. 
+//  (C) Copyright Jens Maurer 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Comeau C++ compiler setup:
+
+#include "boost/config/compiler/common_edg.hpp"
+
+#if (__COMO_VERSION__ <= 4245) || !defined(BOOST_STRICT_CONFIG)
+
+#  ifdef _WIN32
+#     define BOOST_NO_SWPRINTF
+#  endif
+
+#  if defined(_MSC_VER) && _MSC_VER <= 1300
+#     define BOOST_NO_STDC_NAMESPACE
+#     if _MSC_VER > 100
+         // only set this in non-strict mode:
+#        define BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP
+#     endif
+#  endif
+
+// Void returns don't work when emulating VC 6 (Peter Dimov)
+
+#  if defined(_MSC_VER) && (_MSC_VER == 1200)
+#     define BOOST_NO_VOID_RETURNS
+#  endif
+
+#endif  // version 4245
+
+//
+// enable __int64 support in VC emulation mode
+//
+#  if defined(_MSC_VER) && (_MSC_VER >= 1200)
+#     define BOOST_HAS_MS_INT64
+#  endif
+
+#define BOOST_COMPILER "Comeau compiler version " BOOST_STRINGIZE(__COMO_VERSION__)
+
+//
+// versions check:
+// we don't know Comeau prior to version 4245:
+#if __COMO_VERSION__ < 4245
+#  error "Compiler not configured - please reconfigure"
+#endif
+//
+// last known and checked version is 4245:
+#if (__COMO_VERSION__ > 4245)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error "Unknown compiler version - please run the configure tests and report the results"
+#  endif
+#endif
+
+
+
+

Added: trunk/source/libraries/boost/config/compiler/common_edg.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/common_edg.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/common_edg.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,53 @@
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  (C) Copyright Jens Maurer 2001. 
+//  (C) Copyright David Abrahams 2002. 
+//  (C) Copyright Aleksey Gurtovoy 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//
+// Options common to all edg based compilers.
+//
+// This is included from within the individual compiler mini-configs.
+
+#ifndef  __EDG_VERSION__
+#  error This file requires that __EDG_VERSION__ be defined.
+#endif
+
+#if (__EDG_VERSION__ <= 238)
+#   define BOOST_NO_INTEGRAL_INT64_T
+#   define BOOST_NO_SFINAE
+#endif
+
+#if (__EDG_VERSION__ <= 240)
+#   define BOOST_NO_VOID_RETURNS
+#endif
+
+#if (__EDG_VERSION__ <= 241) && !defined(BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP)
+#   define BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP
+#endif
+
+#if (__EDG_VERSION__ <= 244) && !defined(BOOST_NO_TEMPLATE_TEMPLATES)
+#   define BOOST_NO_TEMPLATE_TEMPLATES
+#endif 
+
+// See also kai.hpp which checks a Kai-specific symbol for EH
+# if !defined(__KCC) && !defined(__EXCEPTIONS)
+#     define BOOST_NO_EXCEPTIONS
+# endif
+
+# if !defined(__NO_LONG_LONG)
+#     define BOOST_HAS_LONG_LONG
+# endif
+
+#ifdef c_plusplus
+// EDG has "long long" in non-strict mode
+// However, some libraries have insufficient "long long" support
+// #define BOOST_HAS_LONG_LONG
+#endif
+
+
+

Added: trunk/source/libraries/boost/config/compiler/compaq_cxx.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/compaq_cxx.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/compaq_cxx.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,19 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Dec Alpha True64 C++ compiler setup:
+
+#define BOOST_COMPILER "Dec Alpha True64 " BOOST_STRINGIZE(__DECCXX_VER)
+
+#include "boost/config/compiler/common_edg.hpp"
+
+//
+// versions check:
+// Nothing to do here?
+
+
+

Added: trunk/source/libraries/boost/config/compiler/digitalmars.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/digitalmars.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/digitalmars.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,31 @@
+//  Copyright (C) Christof Meerwald 2003
+//  Copyright (C) Dan Watkins 2003
+//
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  Digital Mars C++ compiler setup:
+#define BOOST_COMPILER __DMC_VERSION_STRING__
+
+#define BOOST_HAS_LONG_LONG
+#define BOOST_HAS_PRAGMA_ONCE
+
+#define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
+#define BOOST_NO_OPERATORS_IN_NAMESPACE
+#define BOOST_NO_SFINAE
+#define BOOST_NO_TEMPLATE_TEMPLATES
+#define BOOST_NO_USING_TEMPLATE
+#define BOOST_NEEDS_TOKEN_PASTING_OP_FOR_TOKENS_JUXTAPOSING
+#define BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS
+
+// check for exception handling support:
+#ifndef _CPPUNWIND
+#  define BOOST_NO_EXCEPTIONS
+#endif
+
+#if (__DMC__ < 0x833)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error "Unknown compiler version - please run the configure tests and report the results"
+#  endif
+#endif

Added: trunk/source/libraries/boost/config/compiler/gcc.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/gcc.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/gcc.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,96 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Darin Adler 2001 - 2002. 
+//  (C) Copyright Jens Maurer 2001 - 2002. 
+//  (C) Copyright Beman Dawes 2001 - 2003. 
+//  (C) Copyright Douglas Gregor 2002. 
+//  (C) Copyright David Abrahams 2002 - 2003. 
+//  (C) Copyright Synge Todo 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  GNU C++ compiler setup:
+
+#   if __GNUC__ == 2 && __GNUC_MINOR__ == 91
+       // egcs 1.1 won't parse shared_ptr.hpp without this:
+#      define BOOST_NO_AUTO_PTR
+#   endif
+#   if __GNUC__ == 2 && __GNUC_MINOR__ < 95
+      //
+      // Prior to gcc 2.95 member templates only partly
+      // work - define BOOST_MSVC6_MEMBER_TEMPLATES
+      // instead since inline member templates mostly work.
+      //
+#     define BOOST_NO_MEMBER_TEMPLATES
+#     if __GNUC_MINOR__ >= 9
+#       define BOOST_MSVC6_MEMBER_TEMPLATES
+#     endif
+#   endif
+
+#   if __GNUC__ == 2 && __GNUC_MINOR__ < 96
+#     define BOOST_NO_SFINAE
+#   endif
+
+#   if __GNUC__ == 2 && __GNUC_MINOR__ <= 97
+#     define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#     define BOOST_NO_OPERATORS_IN_NAMESPACE
+#   endif
+
+#   if __GNUC__ < 3
+#      define BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE
+#      define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
+#   endif
+
+#ifndef __EXCEPTIONS
+# define BOOST_NO_EXCEPTIONS
+#endif
+
+//
+// Bug specific to gcc 3.1 and 3.2:
+//
+#if (__GNUC__ == 3) && ((__GNUC_MINOR__ == 1) || (__GNUC_MINOR__ == 2))
+#  define BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS
+#endif
+
+//
+// Threading support: Turn this on unconditionally here (except for
+// those platforms where we can know for sure). It will get turned off again
+// later if no threading API is detected.
+//
+#if !defined(__MINGW32__) && !defined(linux) && !defined(__linux) && !defined(__linux__)
+# define BOOST_HAS_THREADS
+#endif 
+
+//
+// gcc has "long long"
+//
+#define BOOST_HAS_LONG_LONG
+
+//
+// gcc implements the named return value optimization since version 3.1
+//
+#if __GNUC__ > 3 || ( __GNUC__ == 3 && __GNUC_MINOR__ >= 1 )
+#define BOOST_HAS_NRVO
+#endif
+
+#define BOOST_COMPILER "GNU C++ version " __VERSION__
+
+//
+// versions check:
+// we don't know gcc prior to version 2.90:
+#if (__GNUC__ == 2) && (__GNUC_MINOR__ < 90)
+#  error "Compiler not configured - please reconfigure"
+#endif
+//
+// last known and checked version is 3.4:
+#if (__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ > 4))
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error "Unknown compiler version - please run the configure tests and report the results"
+#  else
+#     warning "Unknown compiler version - please run the configure tests and report the results"
+#  endif
+#endif
+
+

Added: trunk/source/libraries/boost/config/compiler/greenhills.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/greenhills.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/greenhills.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,28 @@
+//  (C) Copyright John Maddock 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Greenhills C++ compiler setup:
+
+#define BOOST_COMPILER "Greenhills C++ version " BOOST_STRINGIZE(__ghs)
+
+#include "boost/config/compiler/common_edg.hpp"
+
+//
+// versions check:
+// we don't support Greenhills prior to version 0:
+#if __ghs < 0
+#  error "Compiler not supported or configured - please reconfigure"
+#endif
+//
+// last known and checked version is 0:
+#if (__ghs > 0)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error "Unknown compiler version - please run the configure tests and report the results"
+#  endif
+#endif
+
+

Added: trunk/source/libraries/boost/config/compiler/hp_acc.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/hp_acc.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/hp_acc.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,67 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2001 - 2003. 
+//  (C) Copyright Aleksey Gurtovoy 2002. 
+//  (C) Copyright David Abrahams 2002 - 2003. 
+//  (C) Copyright Toon Knapen 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  HP aCC C++ compiler setup:
+
+#if (__HP_aCC <= 33100)
+#    define BOOST_NO_INTEGRAL_INT64_T
+#    define BOOST_NO_OPERATORS_IN_NAMESPACE
+#  if !defined(_NAMESPACE_STD)
+#     define BOOST_NO_STD_LOCALE
+#     define BOOST_NO_STRINGSTREAM
+#  endif
+#endif
+
+#if (__HP_aCC <= 33300)
+// member templates are sufficiently broken that we disable them for now
+#    define BOOST_NO_MEMBER_TEMPLATES
+#    define BOOST_NO_DEPENDENT_NESTED_DERIVATIONS
+#    define BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE
+#endif
+
+#if (__HP_aCC <= 33900) || !defined(BOOST_STRICT_CONFIG)
+#    define BOOST_NO_UNREACHABLE_RETURN_DETECTION
+#    define BOOST_NO_TEMPLATE_TEMPLATES
+#    define BOOST_NO_SWPRINTF
+#    define BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS
+//     std lib config should set this one already:
+//#    define BOOST_NO_STD_ALLOCATOR
+#endif 
+
+// optional features rather than defects:
+#if (__HP_aCC >= 33900)
+#    define BOOST_HAS_LONG_LONG
+#    define BOOST_HAS_PARTIAL_STD_ALLOCATOR
+#endif
+
+#if (__HP_aCC <= 53800 )
+#    define BOOST_NO_MEMBER_TEMPLATE_KEYWORD
+#endif
+
+#define BOOST_COMPILER "HP aCC version " BOOST_STRINGIZE(__HP_aCC)
+
+//
+// versions check:
+// we don't support HP aCC prior to version 0:
+#if __HP_aCC < 33000
+#  error "Compiler not supported or configured - please reconfigure"
+#endif
+//
+// last known and checked version is 0:
+#if (__HP_aCC > 53800)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error "Unknown compiler version - please run the configure tests and report the results"
+#  endif
+#endif
+
+
+
+

Added: trunk/source/libraries/boost/config/compiler/intel.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/intel.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/intel.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,114 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright Peter Dimov 2001. 
+//  (C) Copyright Jens Maurer 2001. 
+//  (C) Copyright David Abrahams 2002 - 2003. 
+//  (C) Copyright Aleksey Gurtovoy 2002 - 2003. 
+//  (C) Copyright Guillaume Melquiond 2002 - 2003. 
+//  (C) Copyright Beman Dawes 2003. 
+//  (C) Copyright Martin Wille 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Intel compiler setup:
+
+#include "boost/config/compiler/common_edg.hpp"
+
+#if defined(__INTEL_COMPILER)
+#  define BOOST_INTEL_CXX_VERSION __INTEL_COMPILER
+#elif defined(__ICL)
+#  define BOOST_INTEL_CXX_VERSION __ICL
+#elif defined(__ICC)
+#  define BOOST_INTEL_CXX_VERSION __ICC
+#elif defined(__ECC)
+#  define BOOST_INTEL_CXX_VERSION __ECC
+#endif
+
+#define BOOST_COMPILER "Intel C++ version " BOOST_STRINGIZE(BOOST_INTEL_CXX_VERSION)
+#define BOOST_INTEL BOOST_INTEL_CXX_VERSION
+
+#if (BOOST_INTEL_CXX_VERSION <= 500) && defined(_MSC_VER)
+#  define BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS
+#  define BOOST_NO_TEMPLATE_TEMPLATES
+#endif
+
+#if (BOOST_INTEL_CXX_VERSION <= 600) || !defined(BOOST_STRICT_CONFIG)
+
+#  if defined(_MSC_VER) && (_MSC_VER <= 1300) // added check for <= VC 7 (Peter Dimov)
+
+// Boost libraries assume strong standard conformance unless otherwise
+// indicated by a config macro. As configured by Intel, the EDG front-end
+// requires certain compiler options be set to achieve that strong conformance.
+// Particularly /Qoption,c,--arg_dep_lookup (reported by Kirk Klobe & Thomas Witt)
+// and /Zc:wchar_t,forScope. See boost-root/tools/build/intel-win32-tools.jam for
+// details as they apply to particular versions of the compiler. When the
+// compiler does not predefine a macro indicating if an option has been set,
+// this config file simply assumes the option has been set.
+// Thus BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP will not be defined, even if
+// the compiler option is not enabled.
+
+#     define BOOST_NO_SWPRINTF
+#  endif
+
+// Void returns, 64 bit integrals don't work when emulating VC 6 (Peter Dimov)
+
+#  if defined(_MSC_VER) && (_MSC_VER <= 1200)
+#     define BOOST_NO_VOID_RETURNS
+#     define BOOST_NO_INTEGRAL_INT64_T
+#  endif
+
+#endif
+
+// See http://aspn.activestate.com/ASPN/Mail/Message/boost/1614864
+#if BOOST_INTEL_CXX_VERSION < 700
+#  define BOOST_NO_INTRINSIC_WCHAR_T
+#else
+// _WCHAR_T_DEFINED is the Win32 spelling
+// _WCHAR_T is the Linux spelling
+#  if !defined(_WCHAR_T_DEFINED) && !defined(_WCHAR_T)
+#    define BOOST_NO_INTRINSIC_WCHAR_T
+#  endif
+#endif
+
+#if (BOOST_INTEL_CXX_VERSION <= 800) || !defined(BOOST_STRICT_CONFIG)
+#  define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
+#endif
+
+#if _MSC_VER+0 >= 1000
+#  if _MSC_VER >= 1200
+#     define BOOST_HAS_MS_INT64
+#  endif
+#  define BOOST_NO_SWPRINTF
+#elif defined(_WIN32)
+#  define BOOST_DISABLE_WIN32
+#endif
+
+// I checked version 6.0 build 020312Z, it implements the NRVO.
+// Correct this as you find out which version of the compiler
+// implemented the NRVO first.  (Daniel Frey)
+#if (BOOST_INTEL_CXX_VERSION >= 600)
+#  define BOOST_HAS_NRVO
+#endif
+
+//
+// versions check:
+// we don't support Intel prior to version 5.0:
+#if BOOST_INTEL_CXX_VERSION < 500
+#  error "Compiler not supported or configured - please reconfigure"
+#endif
+//
+// last known and checked version:
+#if (BOOST_INTEL_CXX_VERSION > 800)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error "Unknown compiler version - please run the configure tests and report the results"
+#  elif defined(_MSC_VER)
+#     pragma message("Unknown compiler version - please run the configure tests and report the results")
+#  endif
+#endif
+
+
+
+
+

Added: trunk/source/libraries/boost/config/compiler/kai.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/kai.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/kai.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,35 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright David Abrahams 2002. 
+//  (C) Copyright Aleksey Gurtovoy 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Kai C++ compiler setup:
+
+#include "boost/config/compiler/common_edg.hpp"
+
+#   if (__KCC_VERSION <= 4001) || !defined(BOOST_STRICT_CONFIG)
+      // at least on Sun, the contents of <cwchar> is not in namespace std
+#     define BOOST_NO_STDC_NAMESPACE
+#   endif
+
+// see also common_edg.hpp which needs a special check for __KCC
+# if !defined(_EXCEPTIONS)
+#     define BOOST_NO_EXCEPTIONS
+# endif
+
+#define BOOST_COMPILER "Kai C++ version " BOOST_STRINGIZE(__KCC_VERSION)
+
+//
+// last known and checked version is 4001:
+#if (__KCC_VERSION > 4001)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error "Unknown compiler version - please run the configure tests and report the results"
+#  endif
+#endif
+
+
+

Added: trunk/source/libraries/boost/config/compiler/metrowerks.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/metrowerks.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/metrowerks.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,94 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright Darin Adler 2001. 
+//  (C) Copyright Peter Dimov 2001. 
+//  (C) Copyright David Abrahams 2001 - 2002. 
+//  (C) Copyright Beman Dawes 2001 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Metrowerks C++ compiler setup:
+
+// locale support is disabled when linking with the dynamic runtime
+#   ifdef _MSL_NO_LOCALE
+#     define BOOST_NO_STD_LOCALE
+#   endif 
+
+#   if __MWERKS__ <= 0x2301  // 5.3
+#     define BOOST_NO_FUNCTION_TEMPLATE_ORDERING
+#     define BOOST_NO_POINTER_TO_MEMBER_CONST
+#     define BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS
+#     define BOOST_NO_MEMBER_TEMPLATE_KEYWORD
+#   endif
+
+#   if __MWERKS__ <= 0x2401  // 6.2
+//#     define BOOST_NO_FUNCTION_TEMPLATE_ORDERING
+#   endif
+
+#   if(__MWERKS__ <= 0x2407)  // 7.x
+#     define BOOST_NO_MEMBER_FUNCTION_SPECIALIZATIONS
+#     define BOOST_NO_UNREACHABLE_RETURN_DETECTION
+#   endif
+
+#   if(__MWERKS__ <= 0x3003)  // 8.x
+#     define BOOST_NO_SFINAE
+#    endif
+
+#   if(__MWERKS__ <= 0x3202)  // 9.2
+#     define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#    endif
+
+#if !__option(wchar_type)
+#   define BOOST_NO_INTRINSIC_WCHAR_T
+#endif
+
+#if !__option(exceptions)
+#   define BOOST_NO_EXCEPTIONS
+#endif
+
+#if (__INTEL__ && _WIN32) || (__POWERPC__ && macintosh)
+#   if __MWERKS__ == 0x3000
+#     define BOOST_COMPILER_VERSION 8.0
+#   elif __MWERKS__ == 0x3001
+#     define BOOST_COMPILER_VERSION 8.1
+#   elif __MWERKS__ == 0x3002
+#     define BOOST_COMPILER_VERSION 8.2
+#   elif __MWERKS__ == 0x3003
+#     define BOOST_COMPILER_VERSION 8.3
+#   elif __MWERKS__ == 0x3200
+#     define BOOST_COMPILER_VERSION 9.0
+#   elif __MWERKS__ == 0x3201
+#     define BOOST_COMPILER_VERSION 9.1
+#   elif __MWERKS__ == 0x3202
+#     define BOOST_COMPILER_VERSION 9.2
+#   else
+#     define BOOST_COMPILER_VERSION __MWERKS__
+#   endif
+#else
+#  define BOOST_COMPILER_VERSION __MWERKS__
+#endif
+
+#define BOOST_COMPILER "Metrowerks CodeWarrior C++ version " BOOST_STRINGIZE(BOOST_COMPILER_VERSION)
+
+//
+// versions check:
+// we don't support Metrowerks prior to version 5.3:
+#if __MWERKS__ < 0x2301
+#  error "Compiler not supported or configured - please reconfigure"
+#endif
+//
+// last known and checked version:
+#if (__MWERKS__ > 0x3202)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error "Unknown compiler version - please run the configure tests and report the results"
+#  endif
+#endif
+
+
+
+
+
+
+

Added: trunk/source/libraries/boost/config/compiler/mpw.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/mpw.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/mpw.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,51 @@
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  (C) Copyright Aleksey Gurtovoy 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  MPW C++ compilers setup:
+
+#   if    defined(__SC__)
+#     define BOOST_COMPILER "MPW SCpp version " BOOST_STRINGIZE(__SC__)
+#   elif defined(__MRC__)
+#     define BOOST_COMPILER "MPW MrCpp version " BOOST_STRINGIZE(__MRC__)
+#   else
+#     error "Using MPW compiler configuration by mistake.  Please update."
+#   endif
+
+//
+// MPW 8.90:
+//
+#if (MPW_CPLUS <= 0x890) || !defined(BOOST_STRICT_CONFIG)
+#  define BOOST_NO_CV_SPECIALIZATIONS
+#  define BOOST_NO_DEPENDENT_NESTED_DERIVATIONS
+#  define BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS
+#  define BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+#  define BOOST_NO_INTRINSIC_WCHAR_T
+#  define BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#  define BOOST_NO_USING_TEMPLATE
+
+#  define BOOST_NO_CWCHAR
+#  define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+
+#  define BOOST_NO_STD_ALLOCATOR /* actually a bug with const reference overloading */
+#endif
+
+//
+// versions check:
+// we don't support MPW prior to version 8.9:
+#if MPW_CPLUS < 0x890
+#  error "Compiler not supported or configured - please reconfigure"
+#endif
+//
+// last known and checked version is 0x890:
+#if (MPW_CPLUS > 0x890)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error "Unknown compiler version - please run the configure tests and report the results"
+#  endif
+#endif
+
+

Added: trunk/source/libraries/boost/config/compiler/sgi_mipspro.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/sgi_mipspro.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/sgi_mipspro.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,24 @@
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  SGI C++ compiler setup:
+
+#define BOOST_COMPILER "SGI Irix compiler version " BOOST_STRINGIZE(_COMPILER_VERSION)
+
+#include "boost/config/compiler/common_edg.hpp"
+
+//
+// Threading support:
+// Turn this on unconditionally here, it will get turned off again later
+// if no threading API is detected.
+//
+#define BOOST_HAS_THREADS
+//
+// version check:
+// probably nothing to do here?
+
+

Added: trunk/source/libraries/boost/config/compiler/sunpro_cc.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/sunpro_cc.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/sunpro_cc.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,89 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright Jens Maurer 2001 - 2003. 
+//  (C) Copyright Peter Dimov 2002. 
+//  (C) Copyright Aleksey Gurtovoy 2002 - 2003. 
+//  (C) Copyright David Abrahams 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Sun C++ compiler setup:
+
+#    if __SUNPRO_CC <= 0x500
+#      define BOOST_NO_MEMBER_TEMPLATES
+#      define BOOST_NO_FUNCTION_TEMPLATE_ORDERING
+#    endif
+
+#    if (__SUNPRO_CC <= 0x520)
+       //
+       // Sunpro 5.2 and earler:
+       //
+       // although sunpro 5.2 supports the syntax for
+       // inline initialization it often gets the value
+       // wrong, especially where the value is computed
+       // from other constants (J Maddock 6th May 2001)
+#      define BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+
+       // Although sunpro 5.2 supports the syntax for
+       // partial specialization, it often seems to
+       // bind to the wrong specialization.  Better
+       // to disable it until suppport becomes more stable
+       // (J Maddock 6th May 2001).
+#      define BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#    endif
+
+#    if (__SUNPRO_CC <= 0x530) || !defined(BOOST_STRICT_CONFIG)
+       // Requesting debug info (-g) with Boost.Python results
+       // in an internal compiler error for "static const"
+       // initialized in-class.
+       //    >> Assertion:   (../links/dbg_cstabs.cc, line 611)
+       //         while processing ../test.cpp at line 0.
+       // (Jens Maurer according to Gottfried Gan?auge 04 Mar 2002)
+#      define BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+
+       // SunPro 5.3 has better support for partial specialization,
+       // but breaks when compiling std::less<shared_ptr<T> >
+       // (Jens Maurer 4 Nov 2001).
+
+       // std::less specialization fixed as reported by George
+       // Heintzelman; partial specialization re-enabled
+       // (Peter Dimov 17 Jan 2002)
+
+//#      define BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+       // integral constant expressions with 64 bit numbers fail
+#      define BOOST_NO_INTEGRAL_INT64_T
+#    endif
+
+#    if (__SUNPRO_CC <= 0x540) || !defined(BOOST_STRICT_CONFIG)
+#      define BOOST_NO_TEMPLATE_TEMPLATES
+       // see http://lists.boost.org/MailArchives/boost/msg47184.php
+       // and http://lists.boost.org/MailArchives/boost/msg47220.php
+#      define BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+#      define BOOST_NO_SFINAE
+#      define BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS
+#    endif
+
+#define BOOST_COMPILER "Sun compiler version " BOOST_STRINGIZE(__SUNPRO_CC)
+
+//
+// versions check:
+// we don't support sunpro prior to version 4:
+#if __SUNPRO_CC < 0x400
+#error "Compiler not supported or configured - please reconfigure"
+#endif
+//
+// last known and checked version is 0x530:
+#if (__SUNPRO_CC > 0x530)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error "Unknown compiler version - please run the configure tests and report the results"
+#  endif
+#endif
+
+
+
+
+
+

Added: trunk/source/libraries/boost/config/compiler/vacpp.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/vacpp.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/vacpp.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,56 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Toon Knapen 2001 - 2003. 
+//  (C) Copyright Lie-Quan Lee 2001. 
+//  (C) Copyright Markus Sch?pflin 2002 - 2003. 
+//  (C) Copyright Beman Dawes 2002 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Visual Age (IBM) C++ compiler setup:
+
+#if __IBMCPP__ <= 501
+#  define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#  define BOOST_NO_MEMBER_FUNCTION_SPECIALIZATIONS
+#endif
+
+#if (__IBMCPP__ <= 502) 
+// Actually the compiler supports inclass member initialization but it
+// requires a definition for the class member and it doesn't recognize
+// it as an integral constant expression when used as a template argument.
+#  define BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+#  define BOOST_NO_INTEGRAL_INT64_T
+#  define BOOST_NO_MEMBER_TEMPLATE_KEYWORD
+#endif
+
+#if (__IBMCPP__ <= 600) || !defined(BOOST_STRICT_CONFIG)
+#endif
+
+//
+// On AIX thread support seems to be indicated by _THREAD_SAFE:
+//
+#ifdef _THREAD_SAFE
+#  define BOOST_HAS_THREADS
+#endif
+
+#define BOOST_COMPILER "IBM Visual Age version " BOOST_STRINGIZE(__IBMCPP__)
+
+//
+// versions check:
+// we don't support Visual age prior to version 5:
+#if __IBMCPP__ < 500
+#error "Compiler not supported or configured - please reconfigure"
+#endif
+//
+// last known and checked version is 600:
+#if (__IBMCPP__ > 600)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error "Unknown compiler version - please run the configure tests and report the results"
+#  endif
+#endif
+
+
+
+

Added: trunk/source/libraries/boost/config/compiler/visualc.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/visualc.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/visualc.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,146 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Darin Adler 2001 - 2002. 
+//  (C) Copyright Peter Dimov 2001. 
+//  (C) Copyright Aleksey Gurtovoy 2002. 
+//  (C) Copyright David Abrahams 2002 - 2003. 
+//  (C) Copyright Beman Dawes 2002 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Microsoft Visual C++ compiler setup:
+
+#define BOOST_MSVC _MSC_VER
+
+// turn off the warnings before we #include anything
+#pragma warning( disable : 4503 ) // warning: decorated name length exceeded
+
+#if _MSC_VER <= 1200  // 1200 == VC++ 6.0
+#pragma warning( disable : 4786 ) // ident trunc to '255' chars in debug info
+#  define BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS
+#  define BOOST_NO_VOID_RETURNS
+#  define BOOST_NO_EXCEPTION_STD_NAMESPACE
+   // disable min/max macro defines on vc6:
+   //
+#endif
+
+#if (_MSC_VER <= 1300)  // 1300 == VC++ 7.0
+
+#if !defined(_MSC_EXTENSIONS) && !defined(BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS)      // VC7 bug with /Za
+#  define BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS
+#endif
+
+#  define BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS
+#  define BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+#  define BOOST_NO_PRIVATE_IN_AGGREGATE
+#  define BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP
+#  define BOOST_NO_INTEGRAL_INT64_T
+#  define BOOST_NO_DEDUCED_TYPENAME
+#  define BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE
+
+//    VC++ 6/7 has member templates but they have numerous problems including
+//    cases of silent failure, so for safety we define:
+#  define BOOST_NO_MEMBER_TEMPLATES
+//    For VC++ experts wishing to attempt workarounds, we define:
+#  define BOOST_MSVC6_MEMBER_TEMPLATES
+
+#  define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#  define BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#  define BOOST_NO_CV_VOID_SPECIALIZATIONS
+#  define BOOST_NO_FUNCTION_TEMPLATE_ORDERING
+#  define BOOST_NO_USING_TEMPLATE
+#  define BOOST_NO_SWPRINTF
+#  define BOOST_NO_TEMPLATE_TEMPLATES
+#  define BOOST_NO_SFINAE
+#  if (_MSC_VER > 1200)
+#     define BOOST_NO_MEMBER_FUNCTION_SPECIALIZATIONS
+#  endif
+
+#endif
+
+#if _MSC_VER < 1310 // 1310 == VC++ 7.1
+#  define BOOST_NO_SWPRINTF
+#endif
+
+#if _MSC_VER <= 1310
+#  define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#endif
+
+#ifndef _NATIVE_WCHAR_T_DEFINED
+#  define BOOST_NO_INTRINSIC_WCHAR_T
+#endif
+
+//   
+// check for exception handling support:   
+#ifndef _CPPUNWIND   
+#  define BOOST_NO_EXCEPTIONS   
+#endif 
+
+//
+// __int64 support:
+//
+#if (_MSC_VER >= 1200)
+#   define BOOST_HAS_MS_INT64
+#endif
+#if (_MSC_VER >= 1310) && defined(_MSC_EXTENSIONS)
+#   define BOOST_HAS_LONG_LONG
+#endif
+//
+// disable Win32 API's if compiler extentions are
+// turned off:
+//
+#ifndef _MSC_EXTENSIONS
+#  define BOOST_DISABLE_WIN32
+#endif
+
+//
+// all versions support __declspec:
+//
+#define BOOST_HAS_DECLSPEC
+//
+// prefix and suffix headers:
+//
+#ifndef BOOST_ABI_PREFIX
+#  define BOOST_ABI_PREFIX "boost/config/abi/msvc_prefix.hpp"
+#endif
+#ifndef BOOST_ABI_SUFFIX
+#  define BOOST_ABI_SUFFIX "boost/config/abi/msvc_suffix.hpp"
+#endif
+
+# if _MSC_VER == 1200
+#   define BOOST_COMPILER_VERSION 6.0
+# elif _MSC_VER == 1300
+#   define BOOST_COMPILER_VERSION 7.0
+# elif _MSC_VER == 1310
+#   define BOOST_COMPILER_VERSION 7.1
+# else
+#   define BOOST_COMPILER_VERSION _MSC_VER
+# endif
+
+#define BOOST_COMPILER "Microsoft Visual C++ version " BOOST_STRINGIZE(BOOST_COMPILER_VERSION)
+
+//
+// versions check:
+// we don't support Visual C++ prior to version 6:
+#if _MSC_VER < 1200
+#error "Compiler not supported or configured - please reconfigure"
+#endif
+//
+// last known and checked version is 1310:
+#if (_MSC_VER > 1310)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error "Unknown compiler version - please run the configure tests and report the results"
+#  else
+#     pragma message("Unknown compiler version - please run the configure tests and report the results")
+#  endif
+#endif
+
+
+
+
+
+
+
+

Added: trunk/source/libraries/boost/config/platform/aix.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/aix.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/aix.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,33 @@
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  IBM/Aix specific config options:
+
+#define BOOST_PLATFORM "IBM Aix"
+
+#define BOOST_HAS_UNISTD_H
+#define BOOST_HAS_NL_TYPES_H
+#define BOOST_HAS_NANOSLEEP
+#define BOOST_HAS_CLOCK_GETTIME
+
+// This needs support in "boost/cstdint.hpp" exactly like FreeBSD.
+// This platform has header named <inttypes.h> which includes all
+// the things needed.
+#define BOOST_HAS_STDINT_H
+
+// Threading API's:
+#define BOOST_HAS_PTHREADS
+#define BOOST_HAS_PTHREAD_DELAY_NP
+#define BOOST_HAS_SCHED_YIELD
+//#define BOOST_HAS_PTHREAD_YIELD
+
+// boilerplate code:
+#include <boost/config/posix_features.hpp>
+
+
+
+

Added: trunk/source/libraries/boost/config/platform/amigaos.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/amigaos.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/amigaos.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,15 @@
+//  (C) Copyright John Maddock 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+#define BOOST_PLATFORM "AmigaOS"
+
+#define BOOST_DISABLE_THREADS
+#define BOOST_NO_CWCHAR
+#define BOOST_NO_STD_WSTRING
+#define BOOST_NO_INTRINSIC_WCHAR_T
+ 
+

Added: trunk/source/libraries/boost/config/platform/beos.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/beos.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/beos.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,26 @@
+//  (C) Copyright John Maddock 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  BeOS specific config options:
+
+#define BOOST_PLATFORM "BeOS"
+
+#define BOOST_NO_CWCHAR
+#define BOOST_NO_CWCTYPE
+#define BOOST_HAS_UNISTD_H
+
+#define BOOST_HAS_BETHREADS
+
+#ifndef BOOST_DISABLE_THREADS
+#  define BOOST_HAS_THREADS
+#endif
+
+// boilerplate code:
+#include <boost/config/posix_features.hpp>
+ 
+
+

Added: trunk/source/libraries/boost/config/platform/bsd.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/bsd.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/bsd.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,68 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Darin Adler 2001. 
+//  (C) Copyright Douglas Gregor 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  generic BSD config options:
+
+#if !defined(__FreeBSD__) && !defined(__NetBSD__) && !defined(__OpenBSD__)
+#error "This platform is not BSD"
+#endif
+
+#ifdef __FreeBSD__
+#define BOOST_PLATFORM "FreeBSD " BOOST_STRINGIZE(__FreeBSD__)
+#elif defined(__NetBSD__)
+#define BOOST_PLATFORM "NetBSD " BOOST_STRINGIZE(__NetBSD__)
+#elif defined(__OpenBSD__)
+#define BOOST_PLATFORM "OpenBSD " BOOST_STRINGIZE(__OpenBSD__)
+#endif
+
+//
+// is this the correct version check?
+// FreeBSD has <nl_types.h> but does not
+// advertise the fact in <unistd.h>:
+//
+#if defined(__FreeBSD__) && (__FreeBSD__ >= 3)
+#  define BOOST_HAS_NL_TYPES_H
+#endif
+
+//
+// FreeBSD 3.x has pthreads support, but defines _POSIX_THREADS in <pthread.h>
+// and not in <unistd.h>
+//
+#if defined(__FreeBSD__) && (__FreeBSD__ <= 3)
+#  define BOOST_HAS_PTHREADS
+#endif
+
+//
+// No wide character support in the BSD header files:
+//
+#define BOOST_NO_CWCHAR
+
+//
+// The BSD <ctype.h> has macros only, no functions:
+//
+#define BOOST_NO_CTYPE_FUNCTIONS
+
+//
+// thread API's not auto detected:
+//
+#define BOOST_HAS_SCHED_YIELD
+#define BOOST_HAS_NANOSLEEP
+#define BOOST_HAS_GETTIMEOFDAY
+#define BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#define BOOST_HAS_SIGACTION
+
+// boilerplate code:
+#define BOOST_HAS_UNISTD_H
+#include <boost/config/posix_features.hpp>
+
+
+
+
+
+

Added: trunk/source/libraries/boost/config/platform/cygwin.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/cygwin.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/cygwin.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,48 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  cygwin specific config options:
+
+#define BOOST_PLATFORM "Cygwin"
+#define BOOST_NO_CWCTYPE
+#define BOOST_NO_CWCHAR
+#define BOOST_NO_SWPRINTF
+#define BOOST_HAS_DIRENT_H
+
+//
+// Threading API:
+// See if we have POSIX threads, if we do use them, otherwise
+// revert to native Win threads.
+#define BOOST_HAS_UNISTD_H
+#include <unistd.h>
+#if defined(_POSIX_THREADS) && (_POSIX_THREADS+0 >= 0) && !defined(BOOST_HAS_WINTHREADS)
+#  define BOOST_HAS_PTHREADS
+#  define BOOST_HAS_SCHED_YIELD
+#  define BOOST_HAS_GETTIMEOFDAY
+#  define BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#  define BOOST_HAS_SIGACTION
+#else
+#  if !defined(BOOST_HAS_WINTHREADS)
+#     define BOOST_HAS_WINTHREADS
+#  endif
+#  define BOOST_HAS_FTIME
+#endif
+
+//
+// find out if we have a stdint.h, there should be a better way to do this:
+//
+#include <sys/types.h>
+#ifdef _STDINT_H
+#define BOOST_HAS_STDINT_H
+#endif
+
+// boilerplate code:
+#include <boost/config/posix_features.hpp>
+ 
+
+
+

Added: trunk/source/libraries/boost/config/platform/hpux.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/hpux.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/hpux.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,62 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2001 - 2003. 
+//  (C) Copyright David Abrahams 2002. 
+//  (C) Copyright Toon Knapen 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  hpux specific config options:
+
+#define BOOST_PLATFORM "HP-UX"
+
+// In principle, HP-UX has a nice <stdint.h> under the name <inttypes.h>
+// However, it has the following problem:
+// Use of UINT32_C(0) results in "0u l" for the preprocessed source
+// (verifyable with gcc 2.95.3, assumed for HP aCC)
+// #define BOOST_HAS_STDINT_H
+
+#define BOOST_NO_SWPRINTF 
+#define BOOST_NO_CWCTYPE
+
+#ifdef __GNUC__
+   // GNU C on HP-UX does not support threads (checked up to gcc 3.3)
+#  define BOOST_DISABLE_THREADS
+#endif
+
+// boilerplate code:
+#define BOOST_HAS_UNISTD_H
+#include <boost/config/posix_features.hpp>
+
+// the following are always available:
+#ifndef BOOST_HAS_GETTIMEOFDAY
+#  define BOOST_HAS_GETTIMEOFDAY
+#endif
+#ifndef BOOST_HAS_SCHED_YIELD
+#    define BOOST_HAS_SCHED_YIELD
+#endif
+#ifndef BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#    define BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#endif
+#ifndef BOOST_HAS_NL_TYPES_H
+#    define BOOST_HAS_NL_TYPES_H
+#endif
+#ifndef BOOST_HAS_NANOSLEEP
+#    define BOOST_HAS_NANOSLEEP
+#endif
+#ifndef BOOST_HAS_GETTIMEOFDAY
+#    define BOOST_HAS_GETTIMEOFDAY
+#endif
+#ifndef BOOST_HAS_DIRENT_H
+#    define BOOST_HAS_DIRENT_H
+#endif
+#ifndef BOOST_HAS_CLOCK_GETTIME
+#    define BOOST_HAS_CLOCK_GETTIME
+#endif
+#ifndef BOOST_HAS_SIGACTION
+#  define BOOST_HAS_SIGACTION
+#endif
+
+

Added: trunk/source/libraries/boost/config/platform/irix.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/irix.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/irix.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,31 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+
+//  See http://www.boost.org for most recent version.
+
+//  SGI Irix specific config options:
+
+#define BOOST_PLATFORM "SGI Irix"
+
+#define BOOST_NO_SWPRINTF 
+//
+// these are not auto detected by POSIX feature tests:
+//
+#define BOOST_HAS_GETTIMEOFDAY
+#define BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+
+#ifdef __GNUC__
+   // GNU C on IRIX does not support threads (checked up to gcc 3.3)
+#  define BOOST_DISABLE_THREADS
+#endif
+
+// boilerplate code:
+#define BOOST_HAS_UNISTD_H
+#include <boost/config/posix_features.hpp>
+
+
+

Added: trunk/source/libraries/boost/config/platform/linux.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/linux.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/linux.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,98 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2001 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  linux specific config options:
+
+#define BOOST_PLATFORM "linux"
+
+// make sure we have __GLIBC_PREREQ if available at all
+#include <cstdlib>
+
+//
+// <stdint.h> added to glibc 2.1.1
+// We can only test for 2.1 though:
+//
+#if defined(__GLIBC__) && ((__GLIBC__ > 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ >= 1)))
+   // <stdint.h> defines int64_t unconditionally, but <sys/types.h> defines
+   // int64_t only if __GNUC__.  Thus, assume a fully usable <stdint.h>
+   // only when using GCC.
+#  if defined __GNUC__
+#    define BOOST_HAS_STDINT_H
+#  endif
+#endif
+
+#if defined(__LIBCOMO__)
+   //
+   // como on linux doesn't have std:: c functions:
+   // NOTE: versions of libcomo prior to beta28 have octal version numbering,
+   // e.g. version 25 is 21 (dec)
+   //
+#  if __LIBCOMO_VERSION__ <= 20
+#    define BOOST_NO_STDC_NAMESPACE
+#  endif
+
+#  if __LIBCOMO_VERSION__ <= 21
+#    define BOOST_NO_SWPRINTF
+#  endif
+
+#endif
+
+//
+// If glibc is past version 2 then we definitely have
+// gettimeofday, earlier versions may or may not have it:
+//
+#if defined(__GLIBC__) && (__GLIBC__ >= 2)
+#  define BOOST_HAS_GETTIMEOFDAY
+#endif
+
+#ifdef __USE_POSIX199309
+#  define BOOST_HAS_NANOSLEEP
+#endif
+
+#if defined(__GLIBC__) && defined(__GLIBC_PREREQ)
+// __GLIBC_PREREQ is available since 2.1.2
+
+   // swprintf is available since glibc 2.2.0
+#  if !__GLIBC_PREREQ(2,2) || (!defined(__USE_ISOC99) && !defined(__USE_UNIX98))
+#    define BOOST_NO_SWPRINTF
+#  endif
+#else
+#  define BOOST_NO_SWPRINTF
+#endif
+
+// boilerplate code:
+#define BOOST_HAS_UNISTD_H
+#include <boost/config/posix_features.hpp>
+
+#ifndef __GNUC__
+//
+// if the compiler is not gcc we still need to be able to parse
+// the GNU system headers, some of which (mainly <stdint.h>)
+// use GNU specific extensions:
+//
+#  ifndef __extension__
+#     define __extension__
+#  endif
+#  ifndef __const__
+#     define __const__ const
+#  endif
+#  ifndef __volatile__
+#     define __volatile__ volatile
+#  endif
+#  ifndef __signed__
+#     define __signed__ signed
+#  endif
+#  ifndef __typeof__
+#     define __typeof__ typeof
+#  endif
+#  ifndef __inline__
+#     define __inline__ inline
+#  endif
+#endif
+
+

Added: trunk/source/libraries/boost/config/platform/macos.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/macos.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/macos.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,70 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Darin Adler 2001 - 2002. 
+//  (C) Copyright Bill Kempf 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Mac OS specific config options:
+
+#define BOOST_PLATFORM "Mac OS"
+
+#if __MACH__ && !defined(_MSL_USING_MSL_C)
+
+// Using the Mac OS X system BSD-style C library.
+
+#  define BOOST_NO_CTYPE_FUNCTIONS
+#  define BOOST_NO_CWCHAR
+#  ifndef BOOST_HAS_UNISTD_H
+#    define BOOST_HAS_UNISTD_H
+#  endif
+// boilerplate code:
+#  ifndef TARGET_CARBON
+#     include <boost/config/posix_features.hpp>
+#  endif
+#  ifndef BOOST_HAS_STDINT_H
+#     define BOOST_HAS_STDINT_H
+#  endif
+
+//
+// BSD runtime has pthreads, sigaction, sched_yield and gettimeofday,
+// of these only pthreads are advertised in <unistd.h>, so set the 
+// other options explicitly:
+//
+#  define BOOST_HAS_SCHED_YIELD
+#  define BOOST_HAS_GETTIMEOFDAY
+#  define BOOST_HAS_SIGACTION
+
+#  if (__GNUC__ < 3) && !defined( __APPLE_CC__)
+
+// GCC strange "ignore std" mode works better if you pretend everything
+// is in the std namespace, for the most part.
+
+#    define BOOST_NO_STDC_NAMESPACE
+#  endif
+
+#else
+
+// Using the MSL C library.
+
+// We will eventually support threads in non-Carbon builds, but we do
+// not support this yet.
+#  if TARGET_CARBON
+
+#    define BOOST_HAS_MPTASKS
+
+// The MP task implementation of Boost Threads aims to replace MP-unsafe
+// parts of the MSL, so we turn on threads unconditionally.
+#    define BOOST_HAS_THREADS
+
+// The remote call manager depends on this.
+#    define BOOST_BIND_ENABLE_PASCAL
+
+#  endif
+
+#endif
+
+
+

Added: trunk/source/libraries/boost/config/platform/solaris.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/solaris.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/solaris.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,21 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  sun specific config options:
+
+#define BOOST_PLATFORM "Sun Solaris"
+
+#define BOOST_HAS_GETTIMEOFDAY
+
+// boilerplate code:
+#define BOOST_HAS_UNISTD_H
+#include <boost/config/posix_features.hpp>
+
+
+
+

Added: trunk/source/libraries/boost/config/platform/win32.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/win32.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/win32.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,86 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Bill Kempf 2001. 
+//  (C) Copyright Aleksey Gurtovoy 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Win32 specific config options:
+
+#define BOOST_PLATFORM "Win32"
+
+#if defined(__GNUC__) && !defined(BOOST_NO_SWPRINTF)
+#  define BOOST_NO_SWPRINTF
+#endif
+
+#if !defined(__GNUC__) && !defined(BOOST_HAS_DECLSPEC)
+#  define BOOST_HAS_DECLSPEC
+#endif
+
+#if defined(__MINGW32__) && ((__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 2)))
+#  define BOOST_HAS_STDINT_H
+#  define __STDC_LIMIT_MACROS
+#endif
+
+//
+// Win32 will normally be using native Win32 threads,
+// but there is a pthread library avaliable as an option,
+// we used to disable this when BOOST_DISABLE_WIN32 was 
+// defined but no longer - this should allow some
+// files to be compiled in strict mode - while maintaining
+// a consistent setting of BOOST_HAS_THREADS across
+// all translation units (needed for shared_ptr etc).
+//
+#ifndef BOOST_HAS_PTHREADS
+#  define BOOST_HAS_WINTHREADS
+#endif
+
+#ifndef BOOST_DISABLE_WIN32
+// WEK: Added
+#define BOOST_HAS_FTIME
+
+#endif
+
+//
+// disable min/max macros:
+//
+#ifdef min
+#  undef min
+#endif
+#ifdef max
+#  undef max
+#endif
+#ifndef NOMINMAX
+#  define NOMINMAX
+#endif
+
+#ifdef BOOST_MSVC
+#include <algorithm> // for existing std::min and std::max
+namespace std{
+  // Apparently, something in the Microsoft libraries requires the "long"
+  // overload, because it calls the min/max functions with arguments of
+  // slightly different type.  (If this proves to be incorrect, this
+  // whole "BOOST_MSVC" section can be removed.)
+  inline long min(long __a, long __b) {
+    return __b < __a ? __b : __a;
+  }
+  inline long max(long __a, long __b) {
+    return  __a < __b ? __b : __a;
+  }
+  // The "long double" overload is required, otherwise user code calling
+  // min/max for floating-point numbers will use the "long" overload.
+  // (SourceForge bug #495495)
+  inline long double min(long double __a, long double __b) {
+    return __b < __a ? __b : __a;
+  }
+  inline long double max(long double __a, long double __b) {
+    return  __a < __b ? __b : __a;
+  }
+}
+using std::min;
+using std::max;
+#     endif
+
+

Added: trunk/source/libraries/boost/config/posix_features.hpp
===================================================================
--- trunk/source/libraries/boost/config/posix_features.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/posix_features.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,87 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+
+//  See http://www.boost.org for most recent version.
+
+// All POSIX feature tests go in this file,
+// Note that we test _POSIX_C_SOURCE and _XOPEN_SOURCE as well
+// _POSIX_VERSION and _XOPEN_VERSION: on some systems POSIX API's
+// may be present but none-functional unless _POSIX_C_SOURCE and
+// _XOPEN_SOURCE have been defined to the right value (it's up
+// to the user to do this *before* including any header, although
+// in most cases the compiler will do this for you).
+
+#  if defined(BOOST_HAS_UNISTD_H)
+#     include <unistd.h>
+
+      // XOpen has <nl_types.h>, but is this the correct version check?
+#     if defined(_XOPEN_VERSION) && (_XOPEN_VERSION >= 3)
+#        define BOOST_HAS_NL_TYPES_H
+#     endif
+
+      // POSIX version 6 requires <stdint.h>
+#     if defined(_POSIX_VERSION) && (_POSIX_VERSION >= 200100)
+#        define BOOST_HAS_STDINT_H
+#     endif
+
+      // POSIX version 2 requires <dirent.h>
+#     if defined(_POSIX_VERSION) && (_POSIX_VERSION >= 199009L)
+#        define BOOST_HAS_DIRENT_H
+#     endif
+
+      // POSIX version 3 requires <signal.h> to have sigaction:
+#     if defined(_POSIX_VERSION) && (_POSIX_VERSION >= 199506L)
+#        define BOOST_HAS_SIGACTION
+#     endif
+      // POSIX defines _POSIX_THREADS > 0 for pthread support,
+      // however some platforms define _POSIX_THREADS without
+      // a value, hence the (_POSIX_THREADS+0 >= 0) check.
+      // Strictly speaking this may catch platforms with a
+      // non-functioning stub <pthreads.h>, but such occurrences should
+      // occur very rarely if at all.
+#     if defined(_POSIX_THREADS) && (_POSIX_THREADS+0 >= 0) && !defined(BOOST_HAS_WINTHREADS) && !defined(BOOST_HAS_MPTASKS)
+#        define BOOST_HAS_PTHREADS
+#     endif
+
+      // BOOST_HAS_NANOSLEEP:
+      // This is predicated on _POSIX_TIMERS or _XOPEN_REALTIME:
+#     if (defined(_POSIX_TIMERS) && (_POSIX_TIMERS+0 >= 0)) \
+             || (defined(_XOPEN_REALTIME) && (_XOPEN_REALTIME+0 >= 0))
+#        define BOOST_HAS_NANOSLEEP
+#     endif
+
+      // BOOST_HAS_CLOCK_GETTIME:
+      // This is predicated on _POSIX_TIMERS (also on _XOPEN_REALTIME
+      // but at least one platform - linux - defines that flag without
+      // defining clock_gettime):
+#     if (defined(_POSIX_TIMERS) && (_POSIX_TIMERS+0 >= 0))
+#        define BOOST_HAS_CLOCK_GETTIME
+#     endif
+
+      // BOOST_HAS_SCHED_YIELD:
+      // This is predicated on _POSIX_PRIORITY_SCHEDULING or
+      // on _POSIX_THREAD_PRIORITY_SCHEDULING or on _XOPEN_REALTIME.
+#     if defined(_POSIX_PRIORITY_SCHEDULING) && (_POSIX_PRIORITY_SCHEDULING+0 > 0)\
+            || (defined(_POSIX_THREAD_PRIORITY_SCHEDULING) && (_POSIX_THREAD_PRIORITY_SCHEDULING+0 > 0))\
+            || (defined(_XOPEN_REALTIME) && (_XOPEN_REALTIME+0 >= 0))
+#        define BOOST_HAS_SCHED_YIELD
+#     endif
+
+      // BOOST_HAS_GETTIMEOFDAY:
+      // BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE:
+      // These are predicated on _XOPEN_VERSION, and appears to be first released
+      // in issue 4, version 2 (_XOPEN_VERSION > 500).
+#     if defined(_XOPEN_VERSION) && (_XOPEN_VERSION+0 >= 500)
+#        define BOOST_HAS_GETTIMEOFDAY
+#        if defined(_XOPEN_SOURCE) && (_XOPEN_SOURCE >= 500)
+#           define BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#        endif
+#     endif
+
+#  endif
+
+
+

Added: trunk/source/libraries/boost/config/requires_threads.hpp
===================================================================
--- trunk/source/libraries/boost/config/requires_threads.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/requires_threads.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,92 @@
+//  (C) Copyright John Maddock 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+
+#ifndef BOOST_CONFIG_REQUIRES_THREADS_HPP
+#define BOOST_CONFIG_REQUIRES_THREADS_HPP
+
+#ifndef BOOST_CONFIG_HPP
+#  include <boost/config.hpp>
+#endif
+
+#if defined(BOOST_DISABLE_THREADS)
+
+//
+// special case to handle versions of gcc which don't currently support threads:
+//
+#if defined(__GNUC__) && ((__GNUC__ < 3) || (__GNUC_MINOR__ <= 3) || !defined(BOOST_STRICT_CONFIG))
+//
+// this is checked up to gcc 3.3:
+//
+#if defined(__sgi) || defined(__hpux)
+#  error "Multi-threaded programs are not supported by gcc on HPUX or Irix (last checked with gcc 3.3)"
+#endif
+
+#endif
+
+#  error "Threading support unavaliable: it has been explicitly disabled with BOOST_DISABLE_THREADS"
+
+#elif !defined(BOOST_HAS_THREADS)
+
+# if defined __COMO__
+//  Comeau C++
+#   error "Compiler threading support is not turned on. Please set the correct command line options for threading: -D_MT (Windows) or -D_REENTRANT (Unix)"
+
+#elif defined(__INTEL_COMPILER) || defined(__ICL) || defined(__ICC) || defined(__ECC)
+//  Intel
+#ifdef _WIN32
+#  error "Compiler threading support is not turned on. Please set the correct command line options for threading: either /MT /MTd /MD or /MDd"
+#else
+#   error "Compiler threading support is not turned on. Please set the correct command line options for threading: -openmp"
+#endif
+
+# elif defined __GNUC__
+//  GNU C++:
+#   error "Compiler threading support is not turned on. Please set the correct command line options for threading: -pthread (Linux), -pthreads (Solaris) or -mthreads (Mingw32)"
+
+#elif defined __sgi
+//  SGI MIPSpro C++
+#   error "Compiler threading support is not turned on. Please set the correct command line options for threading: -D_SGI_MP_SOURCE"
+
+#elif defined __DECCXX
+//  Compaq Tru64 Unix cxx
+#   error "Compiler threading support is not turned on. Please set the correct command line options for threading: -pthread"
+
+#elif defined __BORLANDC__
+//  Borland
+#   error "Compiler threading support is not turned on. Please set the correct command line options for threading: -tWM"
+
+#elif defined  __MWERKS__
+//  Metrowerks CodeWarrior
+#   error "Compiler threading support is not turned on. Please set the correct command line options for threading: either -runtime sm, -runtime smd, -runtime dm, or -runtime dmd"
+
+#elif defined  __SUNPRO_CC
+//  Sun Workshop Compiler C++
+#   error "Compiler threading support is not turned on. Please set the correct command line options for threading: -mt"
+
+#elif defined __HP_aCC
+//  HP aCC
+#   error "Compiler threading support is not turned on. Please set the correct command line options for threading: -mt"
+
+#elif defined(__IBMCPP__)
+//  IBM Visual Age
+#   error "Compiler threading support is not turned on. Please compile the code with the xlC_r compiler"
+
+#elif defined _MSC_VER
+//  Microsoft Visual C++
+//
+//  Must remain the last #elif since some other vendors (Metrowerks, for
+//  example) also #define _MSC_VER
+#  error "Compiler threading support is not turned on. Please set the correct command line options for threading: either /MT /MTd /MD or /MDd"
+
+#else
+
+#  error "Compiler threading support is not turned on.  Please consult your compiler's documentation for the appropriate options to use"
+
+#endif // compilers
+
+#endif // BOOST_HAS_THREADS
+
+#endif // BOOST_CONFIG_REQUIRES_THREADS_HPP

Added: trunk/source/libraries/boost/config/select_compiler_config.hpp
===================================================================
--- trunk/source/libraries/boost/config/select_compiler_config.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/select_compiler_config.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,83 @@
+//  Boost compiler configuration selection header file
+
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Martin Wille 2003.
+//  (C) Copyright Guillaume Melquiond 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+// locate which compiler we are using and define
+// BOOST_COMPILER_CONFIG as needed: 
+
+# if defined __COMO__
+//  Comeau C++
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/comeau.hpp"
+
+#elif defined __DMC__
+//  Digital Mars C++
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/digitalmars.hpp"
+
+#elif defined(__INTEL_COMPILER) || defined(__ICL) || defined(__ICC) || defined(__ECC)
+//  Intel
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/intel.hpp"
+
+# elif defined __GNUC__
+//  GNU C++:
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/gcc.hpp"
+
+#elif defined __KCC
+//  Kai C++
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/kai.hpp"
+
+#elif defined __sgi
+//  SGI MIPSpro C++
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/sgi_mipspro.hpp"
+
+#elif defined __DECCXX
+//  Compaq Tru64 Unix cxx
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/compaq_cxx.hpp"
+
+#elif defined __ghs
+//  Greenhills C++
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/greenhills.hpp"
+
+#elif defined __BORLANDC__
+//  Borland
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/borland.hpp"
+
+#elif defined  __MWERKS__
+//  Metrowerks CodeWarrior
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/metrowerks.hpp"
+
+#elif defined  __SUNPRO_CC
+//  Sun Workshop Compiler C++
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/sunpro_cc.hpp"
+
+#elif defined __HP_aCC
+//  HP aCC
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/hp_acc.hpp"
+
+#elif defined(__MRC__) || defined(__SC__)
+//  MPW MrCpp or SCpp
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/mpw.hpp"
+
+#elif defined(__IBMCPP__)
+//  IBM Visual Age
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/vacpp.hpp"
+
+#elif defined _MSC_VER
+//  Microsoft Visual C++
+//
+//  Must remain the last #elif since some other vendors (Metrowerks, for
+//  example) also #define _MSC_VER
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/visualc.hpp"
+
+#elif defined (BOOST_ASSERT_CONFIG)
+// this must come last - generate an error if we don't
+// recognise the compiler:
+#  error "Unknown compiler - please configure (http://www.boost.org/libs/config/config.htm#configuring) and report the results to the main boost mailing list (http://www.boost.org/more/mailing_lists.htm#main)"
+
+#endif

Added: trunk/source/libraries/boost/config/select_platform_config.hpp
===================================================================
--- trunk/source/libraries/boost/config/select_platform_config.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/select_platform_config.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,86 @@
+//  Boost compiler configuration selection header file
+
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  (C) Copyright Jens Maurer 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+// locate which platform we are on and define BOOST_PLATFORM_CONFIG as needed.
+// Note that we define the headers to include using "header_name" not
+// <header_name> in order to prevent macro expansion within the header
+// name (for example "linux" is a macro on linux systems).
+
+#if defined(linux) || defined(__linux) || defined(__linux__)
+// linux:
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/linux.hpp"
+
+#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
+// BSD:
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/bsd.hpp"
+
+#elif defined(sun) || defined(__sun)
+// solaris:
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/solaris.hpp"
+
+#elif defined(__sgi)
+// SGI Irix:
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/irix.hpp"
+
+#elif defined(__hpux)
+// hp unix:
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/hpux.hpp"
+
+#elif defined(__CYGWIN__)
+// cygwin is not win32:
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/cygwin.hpp"
+
+#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
+// win32:
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/win32.hpp"
+
+#elif defined(__BEOS__)
+// BeOS
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/beos.hpp"
+
+#elif defined(macintosh) || defined(__APPLE__) || defined(__APPLE_CC__)
+// MacOS
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/macos.hpp"
+
+#elif defined(__IBMCPP__)
+// IBM
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/aix.hpp"
+
+#elif defined(__amigaos__)
+// AmigaOS
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/amigaos.hpp"
+
+#else
+
+#  if defined(unix) \
+      || defined(__unix) \
+      || defined(_XOPEN_SOURCE) \
+      || defined(_POSIX_SOURCE)
+
+   // generic unix platform:
+
+#  ifndef BOOST_HAS_UNISTD_H
+#     define BOOST_HAS_UNISTD_H
+#  endif
+
+#  include <boost/config/posix_features.hpp>
+
+#  endif
+
+#  if defined (BOOST_ASSERT_CONFIG)
+      // this must come last - generate an error if we don't
+      // recognise the platform:
+#     error "Unknown platform - please configure and report the results to boost.org"
+#  endif
+
+#endif
+
+
+

Added: trunk/source/libraries/boost/config/select_stdlib_config.hpp
===================================================================
--- trunk/source/libraries/boost/config/select_stdlib_config.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/select_stdlib_config.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,68 @@
+//  Boost compiler configuration selection header file
+
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2001 - 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+
+//  See http://www.boost.org for most recent version.
+
+// locate which std lib we are using and define BOOST_STDLIB_CONFIG as needed:
+
+// we need to include a std lib header here in order to detect which
+// library is in use, use <utility> as it's about the smallest
+// of the std lib headers - do not rely on this header being included -
+// users can short-circuit this header if they know whose std lib
+// they are using.
+
+#include <utility>
+
+#if defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)
+// STLPort library; this _must_ come first, otherwise since
+// STLport typically sits on top of some other library, we
+// can end up detecting that first rather than STLport:
+#  define BOOST_STDLIB_CONFIG "boost/config/stdlib/stlport.hpp"
+
+#elif defined(__LIBCOMO__)
+// Comeau STL:
+#define BOOST_STDLIB_CONFIG "boost/config/stdlib/libcomo.hpp"
+
+#elif defined(__STD_RWCOMPILER_H__) || defined(_RWSTD_VER)
+// Rogue Wave library:
+#  define BOOST_STDLIB_CONFIG "boost/config/stdlib/roguewave.hpp"
+
+#elif defined(__GLIBCPP__)
+// GNU libstdc++ 3
+#  define BOOST_STDLIB_CONFIG "boost/config/stdlib/libstdcpp3.hpp"
+
+#elif defined(__STL_CONFIG_H)
+// generic SGI STL
+#  define BOOST_STDLIB_CONFIG "boost/config/stdlib/sgi.hpp"
+
+#elif defined(__MSL_CPP__)
+// MSL standard lib:
+#  define BOOST_STDLIB_CONFIG "boost/config/stdlib/msl.hpp"
+
+#elif defined(__IBMCPP__)
+// take the default VACPP std lib
+#  define BOOST_STDLIB_CONFIG "boost/config/stdlib/vacpp.hpp"
+
+#elif defined(MSIPL_COMPILE_H)
+// Modena C++ standard library
+#  define BOOST_STDLIB_CONFIG "boost/config/stdlib/modena.hpp"
+
+#elif (defined(_YVALS) && !defined(__IBMCPP__)) || defined(_CPPLIB_VER)
+// Dinkumware Library (this has to appear after any possible replacement libraries):
+#  define BOOST_STDLIB_CONFIG "boost/config/stdlib/dinkumware.hpp"
+
+#elif defined (BOOST_ASSERT_CONFIG)
+// this must come last - generate an error if we don't
+// recognise the library:
+#  error "Unknown standard library - please configure and report the results to boost.org"
+
+#endif
+
+
+

Added: trunk/source/libraries/boost/config/stdlib/dinkumware.hpp
===================================================================
--- trunk/source/libraries/boost/config/stdlib/dinkumware.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/stdlib/dinkumware.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,96 @@
+//  (C) Copyright John Maddock 2001 - 2003.
+//  (C) Copyright Jens Maurer 2001.
+//  (C) Copyright Peter Dimov 2001.
+//  (C) Copyright David Abrahams 2002.
+//  (C) Copyright Guillaume Melquiond 2003.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Dinkumware standard library config:
+
+#if !defined(_YVALS) && !defined(_CPPLIB_VER)
+#include <utility>
+#if !defined(_YVALS) && !defined(_CPPLIB_VER)
+#error This is not the Dinkumware lib!
+#endif
+#endif
+
+
+#if defined(_CPPLIB_VER) && (_CPPLIB_VER >= 306)
+   // full dinkumware 3.06 and above
+   // fully conforming provided the compiler supports it:
+#  if !(defined(_GLOBAL_USING) && (_GLOBAL_USING+0 > 0)) && !defined(__BORLANDC__) && !defined(_STD) && !(defined(__ICC) && (__ICC >= 700))   // can be defined in yvals.h
+#     define BOOST_NO_STDC_NAMESPACE
+#  endif
+#  if !(defined(_HAS_MEMBER_TEMPLATES_REBIND) && (_HAS_MEMBER_TEMPLATES_REBIND+0 > 0)) && !(defined(_MSC_VER) && (_MSC_VER > 1300)) && defined(BOOST_MSVC)
+#     define BOOST_NO_STD_ALLOCATOR
+#  endif
+#  define BOOST_HAS_PARTIAL_STD_ALLOCATOR
+#  if (defined(_MSC_VER) && (_MSC_VER < 1300)) && !defined(__BORLANDC__)
+      // if this lib version is set up for vc6 then there is no std::use_facet:
+#     define BOOST_NO_STD_USE_FACET
+#     define BOOST_HAS_TWO_ARG_USE_FACET
+      // C lib functions aren't in namespace std either:
+#     define BOOST_NO_STDC_NAMESPACE
+      // and nor is <exception>
+#     define BOOST_NO_EXCEPTION_STD_NAMESPACE
+#  endif
+// There's no numeric_limits<long long> support unless _LONGLONG is defined:
+#  if !defined(_LONGLONG) && (_CPPLIB_VER <= 310)
+#     define BOOST_NO_MS_INT64_NUMERIC_LIMITS
+#  endif
+// 3.06 appears to have (non-sgi versions of) <hash_set> & <hash_map>,
+// and no <slist> at all
+#else
+#  define BOOST_MSVC_STD_ITERATOR 1
+#  define BOOST_NO_STD_ITERATOR
+#  define BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS
+#  define BOOST_NO_STD_ALLOCATOR
+#  define BOOST_NO_STDC_NAMESPACE
+#  define BOOST_NO_STD_USE_FACET
+#  define BOOST_NO_STD_OUTPUT_ITERATOR_ASSIGN
+#  define BOOST_HAS_MACRO_USE_FACET
+#  ifndef _CPPLIB_VER
+      // Updated Dinkum library defines this, and provides
+      // its own min and max definitions.
+#     define BOOST_NO_STD_MIN_MAX
+#     define BOOST_NO_MS_INT64_NUMERIC_LIMITS
+#  endif
+#endif
+
+
+#if (defined(_MSC_VER) && (_MSC_VER <= 1300) && !defined(__BORLANDC__)) || !defined(_CPPLIB_VER) || (_CPPLIB_VER < 306)
+   // if we're using a dinkum lib that's
+   // been configured for VC6/7 then there is
+   // no iterator traits (true even for icl)
+#  define BOOST_NO_STD_ITERATOR_TRAITS
+#endif
+
+#if defined(__ICL) && defined(_CPPLIB_VER) && (_CPPLIB_VER <= 310)
+// Intel C++ chokes over any non-trivial use of <locale>
+// this may be an overly restrictive define, but regex fails without it:
+#  define BOOST_NO_STD_LOCALE
+#endif
+
+#ifdef _CPPLIB_VER
+#  define BOOST_DINKUMWARE_STDLIB _CPPLIB_VER
+#else
+#  define BOOST_DINKUMWARE_STDLIB 1
+#endif
+
+#ifdef _CPPLIB_VER
+#  define BOOST_STDLIB "Dinkumware standard library version " BOOST_STRINGIZE(_CPPLIB_VER)
+#else
+#  define BOOST_STDLIB "Dinkumware standard library version 1.x"
+#endif
+
+
+
+
+
+
+
+

Added: trunk/source/libraries/boost/config/stdlib/libcomo.hpp
===================================================================
--- trunk/source/libraries/boost/config/stdlib/libcomo.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/stdlib/libcomo.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,37 @@
+//  (C) Copyright John Maddock 2002 - 2003. 
+//  (C) Copyright Jens Maurer 2002 - 2003. 
+//  (C) Copyright Beman Dawes 2002 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Comeau STL:
+
+#if !defined(__LIBCOMO__)
+#  include <utility>
+#  if !defined(__LIBCOMO__)
+#      error "This is not the Comeau STL!"
+#  endif
+#endif
+
+//
+// std::streambuf<wchar_t> is non-standard
+// NOTE: versions of libcomo prior to beta28 have octal version numbering,
+// e.g. version 25 is 21 (dec)
+#if __LIBCOMO_VERSION__ <= 22
+#  define BOOST_NO_STD_WSTREAMBUF
+#endif
+
+//
+// Intrinsic type_traits support.
+// The SGI STL has it's own __type_traits class, which
+// has intrinsic compiler support with SGI's compilers.
+// Whatever map SGI style type traits to boost equivalents:
+//
+#define BOOST_HAS_SGI_TYPE_TRAITS
+
+#define BOOST_STDLIB "Comeau standard library " BOOST_STRINGIZE(__LIBCOMO_VERSION__)
+
+

Added: trunk/source/libraries/boost/config/stdlib/libstdcpp3.hpp
===================================================================
--- trunk/source/libraries/boost/config/stdlib/libstdcpp3.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/stdlib/libstdcpp3.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,27 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright Jens Maurer 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  config for libstdc++ v3
+//  not much to go in here:
+
+#define BOOST_STDLIB "GNU libstdc++ version " BOOST_STRINGIZE(__GLIBCPP__)
+
+#ifndef _GLIBCPP_USE_WCHAR_T
+#  define BOOST_NO_CWCHAR
+#  define BOOST_NO_CWCTYPE
+#  define BOOST_NO_STD_WSTRING
+#  define BOOST_NO_STD_WSTREAMBUF
+#endif
+ 
+#ifndef _GLIBCPP_USE_LONG_LONG
+// May have been set by compiler/*.hpp, but "long long" without library
+// support is useless.
+#  undef BOOST_HAS_LONG_LONG
+#endif
+
+

Added: trunk/source/libraries/boost/config/stdlib/modena.hpp
===================================================================
--- trunk/source/libraries/boost/config/stdlib/modena.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/stdlib/modena.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,30 @@
+//  (C) Copyright Jens Maurer 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Modena C++ standard library (comes with KAI C++)
+
+#if !defined(MSIPL_COMPILE_H)
+#  include <utility>
+#  if !defined(__MSIPL_COMPILE_H)
+#      error "This is not the Modena C++ library!"
+#  endif
+#endif
+
+#ifndef MSIPL_NL_TYPES
+#define BOOST_NO_STD_MESSAGES
+#endif
+
+#ifndef MSIPL_WCHART
+#define BOOST_NO_STD_WSTRING
+#endif
+
+#define BOOST_STDLIB "Modena C++ standard library"
+
+
+
+
+

Added: trunk/source/libraries/boost/config/stdlib/msl.hpp
===================================================================
--- trunk/source/libraries/boost/config/stdlib/msl.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/stdlib/msl.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,52 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright Darin Adler 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Metrowerks standard library:
+
+#ifndef __MSL_CPP__
+#  include <utility>
+#  ifndef __MSL_CPP__
+#     error This is not the MSL standard library!
+#  endif
+#endif
+
+#if __MSL_CPP__ >= 0x6000  // Pro 6
+#  define BOOST_HAS_HASH
+#  define BOOST_STD_EXTENSION_NAMESPACE Metrowerks
+#endif
+#define BOOST_HAS_SLIST
+
+#if __MSL_CPP__ < 0x6209
+#  define BOOST_NO_STD_MESSAGES
+#endif
+
+// check C lib version for <stdint.h>
+#include <cstddef>
+
+#if defined(__MSL__) && (__MSL__ >= 0x5000)
+#  define BOOST_HAS_STDINT_H
+#  define BOOST_HAS_UNISTD_H
+   // boilerplate code:
+#  include <boost/config/posix_features.hpp>
+#endif
+
+#if defined(_MWMT) || _MSL_THREADSAFE
+#  define BOOST_HAS_THREADS
+#endif
+
+
+#define BOOST_STDLIB "Metrowerks Standard Library version " BOOST_STRINGIZE(__MSL_CPP__)
+
+
+
+
+
+
+
+
+

Added: trunk/source/libraries/boost/config/stdlib/roguewave.hpp
===================================================================
--- trunk/source/libraries/boost/config/stdlib/roguewave.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/stdlib/roguewave.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,121 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2001. 
+//  (C) Copyright David Abrahams 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Rogue Wave std lib:
+
+#if !defined(__STD_RWCOMPILER_H__) && !defined(_RWSTD_VER)
+#  include <utility>
+#  if !defined(__STD_RWCOMPILER_H__) && !defined(_RWSTD_VER)
+#     error This is not the Rogue Wave standard library
+#  endif
+#endif
+//
+// figure out a consistent version number:
+//
+#ifndef _RWSTD_VER
+#  define BOOST_RWSTD_VER 0x010000
+#elif _RWSTD_VER < 0x010000
+#  define BOOST_RWSTD_VER (_RWSTD_VER << 8)
+#else
+#  define BOOST_RWSTD_VER _RWSTD_VER
+#endif
+
+#ifndef _RWSTD_VER
+#  define BOOST_STDLIB "Rogue Wave standard library version (Unknown version)"
+#else
+#  define BOOST_STDLIB "Rogue Wave standard library version " BOOST_STRINGIZE(_RWSTD_VER)
+#endif
+
+//
+// Prior to version 2.2.0 the primary template for std::numeric_limits
+// does not have compile time constants, even though specializations of that
+// template do:
+//
+#if BOOST_RWSTD_VER < 0x020200
+#  define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#endif
+
+#if BOOST_RWSTD_VER <= 0x020101
+#  define BOOST_NO_LONG_LONG_NUMERIC_LIMITS
+# endif
+
+//
+// Borland version of numeric_limits lacks __int64 specialisation:
+//
+#ifdef __BORLANDC__
+#  define BOOST_NO_MS_INT64_NUMERIC_LIMITS
+#endif
+
+//
+// No std::iterator if it can't figure out default template args:
+//
+#if defined(_RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES) || defined(RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES) || (BOOST_RWSTD_VER < 0x020000)
+#  define BOOST_NO_STD_ITERATOR
+#endif
+
+//
+// No iterator traits without partial specialization:
+//
+#if defined(_RWSTD_NO_CLASS_PARTIAL_SPEC) || defined(RWSTD_NO_CLASS_PARTIAL_SPEC)
+#  define BOOST_NO_STD_ITERATOR_TRAITS
+#endif
+
+//
+// Prior to version 2.0, std::auto_ptr was buggy, and there were no
+// new-style iostreams, and no conformant std::allocator:
+//
+#if (BOOST_RWSTD_VER < 0x020000)
+#  define BOOST_NO_AUTO_PTR
+#  define BOOST_NO_STRINGSTREAM
+#  define BOOST_NO_STD_ALLOCATOR
+#  define BOOST_NO_STD_LOCALE
+#endif
+
+//
+// No template iterator constructors without member template support:
+//
+#if defined(RWSTD_NO_MEMBER_TEMPLATES) || defined(_RWSTD_NO_MEMBER_TEMPLATES)
+#  define BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS
+#endif
+
+//
+// RW defines _RWSTD_ALLOCATOR if the allocator is conformant and in use
+// (the or _HPACC_ part is a hack - the library seems to define _RWSTD_ALLOCATOR
+// on HP aCC systems even though the allocator is in fact broken):
+//
+#if !defined(_RWSTD_ALLOCATOR) || (defined(__HP_aCC) && __HP_aCC <= 33100)
+#  define BOOST_NO_STD_ALLOCATOR
+#endif
+
+//
+// If we have a std::locale, we still may not have std::use_facet:
+//
+#if defined(_RWSTD_NO_TEMPLATE_ON_RETURN_TYPE) && !defined(BOOST_NO_STD_LOCALE)
+#  define BOOST_NO_STD_USE_FACET
+#  define BOOST_HAS_TWO_ARG_USE_FACET
+#endif
+
+//
+// There's no std::distance prior to version 2, or without
+// partial specialization support:
+//
+#if (BOOST_RWSTD_VER < 0x020000) || defined(_RWSTD_NO_CLASS_PARTIAL_SPEC)
+    #define BOOST_NO_STD_DISTANCE
+#endif
+
+//
+// Some versions of the rogue wave library don't have assignable
+// OutputIterators:
+//
+#if BOOST_RWSTD_VER < 0x020100
+#  define BOOST_NO_STD_OUTPUT_ITERATOR_ASSIGN
+#endif
+
+
+

Added: trunk/source/libraries/boost/config/stdlib/sgi.hpp
===================================================================
--- trunk/source/libraries/boost/config/stdlib/sgi.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/stdlib/sgi.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,111 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Darin Adler 2001. 
+//  (C) Copyright Jens Maurer 2001 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  generic SGI STL:
+
+#if !defined(__STL_CONFIG_H)
+#  include <utility>
+#  if !defined(__STL_CONFIG_H)
+#      error "This is not the SGI STL!"
+#  endif
+#endif
+
+//
+// No std::iterator traits without partial specialisation:
+//
+#if !defined(__STL_CLASS_PARTIAL_SPECIALIZATION)
+#  define BOOST_NO_STD_ITERATOR_TRAITS
+#endif
+
+//
+// No std::stringstream with gcc < 3
+//
+#if defined(__GNUC__) && (__GNUC__ < 3) && \
+     ((__GNUC_MINOR__ < 95) || (__GNUC_MINOR__ == 96)) && \
+     !defined(__STL_USE_NEW_IOSTREAMS) || \
+   defined(__APPLE_CC__)
+   // Note that we only set this for GNU C++ prior to 2.95 since the
+   // latest patches for that release do contain a minimal <sstream>
+   // If you are running a 2.95 release prior to 2.95.3 then this will need
+   // setting, but there is no way to detect that automatically (other
+   // than by running the configure script).
+   // Also, the unofficial GNU C++ 2.96 included in RedHat 7.1 doesn't
+   // have <sstream>.
+#  define BOOST_NO_STRINGSTREAM
+#endif
+
+//
+// Assume no std::locale without own iostreams (this may be an
+// incorrect assumption in some cases):
+//
+#if !defined(__SGI_STL_OWN_IOSTREAMS) && !defined(__STL_USE_NEW_IOSTREAMS)
+#  define BOOST_NO_STD_LOCALE
+#endif
+
+//
+// Original native SGI streams have non-standard std::messages facet:
+//
+#if defined(__sgi) && (_COMPILER_VERSION <= 650) && !defined(__SGI_STL_OWN_IOSTREAMS)
+#  define BOOST_NO_STD_LOCALE
+#endif
+
+//
+// SGI's new iostreams have missing "const" in messages<>::open
+//
+#if defined(__sgi) && (_COMPILER_VERSION <= 740) && defined(__STL_USE_NEW_IOSTREAMS)
+#  define BOOST_NO_STD_MESSAGES
+#endif
+
+//
+// No template iterator constructors, or std::allocator
+// without member templates:
+//
+#if !defined(__STL_MEMBER_TEMPLATES)
+#  define BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS
+#  define BOOST_NO_STD_ALLOCATOR
+#endif
+
+//
+// We always have SGI style hash_set, hash_map, and slist:
+//
+#define BOOST_HAS_HASH
+#define BOOST_HAS_SLIST
+
+//
+// If this is GNU libstdc++2, then no <limits> and no std::wstring:
+//
+#if (defined(__GNUC__) && (__GNUC__ < 3))
+#  include <string>
+#  if defined(__BASTRING__)
+#     define BOOST_NO_LIMITS
+// Note: <boost/limits.hpp> will provide compile-time constants
+#     undef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#     define BOOST_NO_STD_WSTRING
+#  endif
+#endif
+
+//
+// There is no standard iterator unless we have namespace support:
+//
+#if !defined(__STL_USE_NAMESPACES)
+#  define BOOST_NO_STD_ITERATOR
+#endif
+
+//
+// Intrinsic type_traits support.
+// The SGI STL has it's own __type_traits class, which
+// has intrinsic compiler support with SGI's compilers.
+// Whatever map SGI style type traits to boost equivalents:
+//
+#define BOOST_HAS_SGI_TYPE_TRAITS
+
+#define BOOST_STDLIB "SGI standard library"
+
+
+

Added: trunk/source/libraries/boost/config/stdlib/stlport.hpp
===================================================================
--- trunk/source/libraries/boost/config/stdlib/stlport.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/stdlib/stlport.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,169 @@
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  (C) Copyright Darin Adler 2001. 
+//  (C) Copyright Jens Maurer 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  STLPort standard library config:
+
+#if !defined(__SGI_STL_PORT) && !defined(_STLPORT_VERSION)
+#  include <utility>
+#  if !defined(__SGI_STL_PORT) && !defined(_STLPORT_VERSION)
+#      error "This is not STLPort!"
+#  endif
+#endif
+
+//
+// __STL_STATIC_CONST_INIT_BUG implies BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+// for versions prior to 4.1(beta)
+//
+#if (defined(__STL_STATIC_CONST_INIT_BUG) || defined(_STLP_STATIC_CONST_INIT_BUG)) && (__SGI_STL_PORT <= 0x400)
+#  define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#endif
+
+//
+// If STLport thinks that there is no partial specialisation, then there is no
+// std::iterator traits:
+//
+#if !(defined(_STLP_CLASS_PARTIAL_SPECIALIZATION) || defined(__STL_CLASS_PARTIAL_SPECIALIZATION))
+#  define BOOST_NO_STD_ITERATOR_TRAITS
+#endif
+
+//
+// No new style iostreams on GCC without STLport's iostreams enabled:
+//
+#if (defined(__GNUC__) && (__GNUC__ < 3)) && !(defined(__SGI_STL_OWN_IOSTREAMS) || defined(_STLP_OWN_IOSTREAMS))
+#  define BOOST_NO_STRINGSTREAM
+#endif
+
+//
+// No new iostreams implies no std::locale, and no std::stringstream:
+//
+#if defined(__STL_NO_IOSTREAMS) || defined(__STL_NO_NEW_IOSTREAMS) || defined(_STLP_NO_IOSTREAMS) || defined(_STLP_NO_NEW_IOSTREAMS)
+#  define BOOST_NO_STD_LOCALE
+#  define BOOST_NO_STRINGSTREAM
+#endif
+
+//
+// If the streams are not native, and we have a "using ::x" compiler bug
+// then the io stream facets are not available in namespace std::
+//
+#ifdef _STLPORT_VERSION
+#  if !defined(_STLP_OWN_IOSTREAMS) && defined(_STLP_USE_NAMESPACES) && defined(BOOST_NO_USING_TEMPLATE) && !defined(__BORLANDC__)
+#     define BOOST_NO_STD_LOCALE
+#  endif
+#else
+#  if !defined(__SGI_STL_OWN_IOSTREAMS) && defined(__STL_USE_NAMESPACES) && defined(BOOST_NO_USING_TEMPLATE) && !defined(__BORLANDC__)
+#     define BOOST_NO_STD_LOCALE
+#  endif
+#endif
+
+//
+// Without member template support enabled, their are no template
+// iterate constructors, and no std::allocator:
+//
+#if !(defined(__STL_MEMBER_TEMPLATES) || defined(_STLP_MEMBER_TEMPLATES))
+#  define BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS
+#  define BOOST_NO_STD_ALLOCATOR
+#endif
+//
+// however we always have at least a partial allocator:
+//
+#define BOOST_HAS_PARTIAL_STD_ALLOCATOR
+
+#if !defined(_STLP_MEMBER_TEMPLATE_CLASSES)
+#  define BOOST_NO_STD_ALLOCATOR
+#endif
+
+#if defined(_STLP_NO_MEMBER_TEMPLATE_KEYWORD) && defined(BOOST_MSVC) && (BOOST_MSVC <= 1300)
+#  define BOOST_NO_STD_ALLOCATOR
+#endif
+
+//
+// We always have SGI style hash_set, hash_map, and slist:
+//
+#define BOOST_HAS_HASH
+#define BOOST_HAS_SLIST
+
+//
+// STLport does a good job of importing names into namespace std::,
+// but doesn't always get them all, define BOOST_NO_STDC_NAMESPACE, since our
+// workaround does not conflict with STLports:
+//
+//
+// Harold Howe says:
+// Borland switched to STLport in BCB6. Defining BOOST_NO_STDC_NAMESPACE with
+// BCB6 does cause problems. If we detect C++ Builder, then don't define 
+// BOOST_NO_STDC_NAMESPACE
+//
+#if !defined(__BORLANDC__) && !defined(__DMC__)
+//
+// If STLport is using it's own namespace, and the real names are in
+// the global namespace, then we duplicate STLport's using declarations
+// (by defining BOOST_NO_STDC_NAMESPACE), we do this because STLport doesn't
+// necessarily import all the names we need into namespace std::
+// 
+#  if (defined(__STL_IMPORT_VENDOR_CSTD) \
+         || defined(__STL_USE_OWN_NAMESPACE) \
+         || defined(_STLP_IMPORT_VENDOR_CSTD) \
+         || defined(_STLP_USE_OWN_NAMESPACE)) \
+      && (defined(__STL_VENDOR_GLOBAL_CSTD) || defined (_STLP_VENDOR_GLOBAL_CSTD))
+#     define BOOST_NO_STDC_NAMESPACE
+#     define BOOST_NO_EXCEPTION_STD_NAMESPACE
+#  endif
+#elif defined(__BORLANDC__) && __BORLANDC__ < 0x560
+// STLport doesn't import std::abs correctly:
+#include <stdlib.h>
+namespace std { using ::abs; }
+// and strcmp/strcpy don't get imported either ('cos they are macros)
+#include <string.h>
+#ifdef strcpy
+#  undef strcpy
+#endif
+#ifdef strcmp
+#  undef strcmp
+#endif
+#ifdef _STLP_VENDOR_CSTD
+namespace std{ using _STLP_VENDOR_CSTD::strcmp; using _STLP_VENDOR_CSTD::strcpy; }
+#endif
+#endif
+
+//
+// std::use_facet may be non-standard, uses a class instead:
+//
+#if defined(__STL_NO_EXPLICIT_FUNCTION_TMPL_ARGS) || defined(_STLP_NO_EXPLICIT_FUNCTION_TMPL_ARGS)
+#  define BOOST_NO_STD_USE_FACET
+#  define BOOST_HAS_STLP_USE_FACET
+#endif
+
+//
+// If STLport thinks there are no wide functions, <cwchar> etc. is not working; but
+// only if BOOST_NO_STDC_NAMESPACE is not defined (if it is then we do the import 
+// into std:: ourselves).
+//
+#if defined(_STLP_NO_NATIVE_WIDE_FUNCTIONS) && !defined(BOOST_NO_STDC_NAMESPACE)
+#  define BOOST_NO_CWCHAR
+#  define BOOST_NO_CWCTYPE
+#endif
+
+//
+// Borland ships a version of STLport with C++ Builder 6 that lacks
+// hashtables and the like:
+//
+#if defined(__BORLANDC__) && (__BORLANDC__ == 0x560)
+#  undef BOOST_HAS_HASH
+#endif
+
+
+#define BOOST_STDLIB "STLPort standard library version " BOOST_STRINGIZE(__SGI_STL_PORT)
+
+
+
+
+
+
+
+

Added: trunk/source/libraries/boost/config/stdlib/vacpp.hpp
===================================================================
--- trunk/source/libraries/boost/config/stdlib/vacpp.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/stdlib/vacpp.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,17 @@
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+#if __IBMCPP__ <= 501
+#  define BOOST_NO_STD_ALLOCATOR
+#endif
+
+#define BOOST_HAS_MACRO_USE_FACET
+
+#define BOOST_STDLIB "Visual Age default standard library"
+
+
+

Added: trunk/source/libraries/boost/config/suffix.hpp
===================================================================
--- trunk/source/libraries/boost/config/suffix.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/suffix.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,508 @@
+//  Boost config.hpp configuration header file  ------------------------------//
+
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Darin Adler 2001. 
+//  (C) Copyright Peter Dimov 2001. 
+//  (C) Copyright Bill Kempf 2002. 
+//  (C) Copyright Jens Maurer 2002. 
+//  (C) Copyright David Abrahams 2002 - 2003. 
+//  (C) Copyright Gennaro Prota 2003. 
+//  (C) Copyright Eric Friedman 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Boost config.hpp policy and rationale documentation has been moved to
+//  http://www.boost.org/libs/config
+//
+//  This file is intended to be stable, and relatively unchanging.
+//  It should contain boilerplate code only - no compiler specific
+//  code unless it is unavoidable - no changes unless unavoidable.
+
+#ifndef BOOST_CONFIG_SUFFIX_HPP
+#define BOOST_CONFIG_SUFFIX_HPP
+
+//
+// look for long long by looking for the appropriate macros in <limits.h>.
+// Note that we use limits.h rather than climits for maximal portability,
+// remember that since these just declare a bunch of macros, there should be
+// no namespace issues from this.
+//
+#include <limits.h>
+# if !defined(BOOST_HAS_LONG_LONG)                                              \
+   && !(defined(BOOST_MSVC) && BOOST_MSVC <=1300) && !defined(__BORLANDC__)     \
+   && (defined(ULLONG_MAX) || defined(ULONG_LONG_MAX) || defined(ULONGLONG_MAX))
+#  define BOOST_HAS_LONG_LONG
+#endif
+#if !defined(BOOST_HAS_LONG_LONG) && !defined(BOOST_NO_INTEGRAL_INT64_T)
+#  define BOOST_NO_INTEGRAL_INT64_T
+#endif
+
+// GCC 3.x will clean up all of those nasty macro definitions that
+// BOOST_NO_CTYPE_FUNCTIONS is intended to help work around, so undefine
+// it under GCC 3.x.
+#if defined(__GNUC__) && (__GNUC__ >= 3) && defined(BOOST_NO_CTYPE_FUNCTIONS)
+#  undef BOOST_NO_CTYPE_FUNCTIONS
+#endif
+
+
+//
+// Assume any extensions are in namespace std:: unless stated otherwise:
+//
+#  ifndef BOOST_STD_EXTENSION_NAMESPACE
+#    define BOOST_STD_EXTENSION_NAMESPACE std
+#  endif
+
+//
+// If cv-qualified specializations are not allowed, then neither are cv-void ones:
+//
+#  if defined(BOOST_NO_CV_SPECIALIZATIONS) \
+      && !defined(BOOST_NO_CV_VOID_SPECIALIZATIONS)
+#     define BOOST_NO_CV_VOID_SPECIALIZATIONS
+#  endif
+
+//
+// If there is no numeric_limits template, then it can't have any compile time
+// constants either!
+//
+#  if defined(BOOST_NO_LIMITS) \
+      && !defined(BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS)
+#     define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#     define BOOST_NO_MS_INT64_NUMERIC_LIMITS
+#     define BOOST_NO_LONG_LONG_NUMERIC_LIMITS
+#  endif
+
+//
+// if there is no long long then there is no specialisation
+// for numeric_limits<long long> either:
+//
+#if !defined(BOOST_HAS_LONG_LONG) && !defined(BOOST_NO_LONG_LONG_NUMERIC_LIMITS)
+#  define BOOST_NO_LONG_LONG_NUMERIC_LIMITS
+#endif
+
+//
+// if there is no __int64 then there is no specialisation
+// for numeric_limits<__int64> either:
+//
+#if !defined(BOOST_HAS_MS_INT64) && !defined(BOOST_NO_MS_INT64_NUMERIC_LIMITS)
+#  define BOOST_NO_MS_INT64_NUMERIC_LIMITS
+#endif
+
+//
+// if member templates are supported then so is the
+// VC6 subset of member templates:
+//
+#  if !defined(BOOST_NO_MEMBER_TEMPLATES) \
+       && !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+#     define BOOST_MSVC6_MEMBER_TEMPLATES
+#  endif
+
+//
+// Without partial specialization, can't test for partial specialisation bugs:
+//
+#  if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+      && !defined(BOOST_BCB_PARTIAL_SPECIALIZATION_BUG)
+#     define BOOST_BCB_PARTIAL_SPECIALIZATION_BUG
+#  endif
+
+//
+// Without partial specialization, we can't have array-type partial specialisations:
+//
+#  if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+      && !defined(BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS)
+#     define BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS
+#  endif
+
+//
+// Without partial specialization, std::iterator_traits can't work:
+//
+#  if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+      && !defined(BOOST_NO_STD_ITERATOR_TRAITS)
+#     define BOOST_NO_STD_ITERATOR_TRAITS
+#  endif
+
+//
+// Without member template support, we can't have template constructors
+// in the standard library either:
+//
+#  if defined(BOOST_NO_MEMBER_TEMPLATES) \
+      && !defined(BOOST_MSVC6_MEMBER_TEMPLATES) \
+      && !defined(BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS)
+#     define BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS
+#  endif
+
+//
+// Without member template support, we can't have a conforming
+// std::allocator template either:
+//
+#  if defined(BOOST_NO_MEMBER_TEMPLATES) \
+      && !defined(BOOST_MSVC6_MEMBER_TEMPLATES) \
+      && !defined(BOOST_NO_STD_ALLOCATOR)
+#     define BOOST_NO_STD_ALLOCATOR
+#  endif
+
+//
+// without ADL support then using declarations will break ADL as well:
+//
+#if defined(BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP) && !defined(BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL)
+#  define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
+#endif
+
+//
+// If we have a standard allocator, then we have a partial one as well:
+//
+#if !defined(BOOST_NO_STD_ALLOCATOR)
+#  define BOOST_HAS_PARTIAL_STD_ALLOCATOR
+#endif
+
+//
+// We can't have a working std::use_facet if there is no std::locale:
+//
+#  if defined(BOOST_NO_STD_LOCALE) && !defined(BOOST_NO_STD_USE_FACET)
+#     define BOOST_NO_STD_USE_FACET
+#  endif
+
+//
+// We can't have a std::messages facet if there is no std::locale:
+//
+#  if defined(BOOST_NO_STD_LOCALE) && !defined(BOOST_NO_STD_MESSAGES)
+#     define BOOST_NO_STD_MESSAGES
+#  endif
+
+//
+// We can't have a working std::wstreambuf if there is no std::locale:
+//
+#  if defined(BOOST_NO_STD_LOCALE) && !defined(BOOST_NO_STD_WSTREAMBUF)
+#     define BOOST_NO_STD_WSTREAMBUF
+#  endif
+
+//
+// We can't have a <cwctype> if there is no <cwchar>:
+//
+#  if defined(BOOST_NO_CWCHAR) && !defined(BOOST_NO_CWCTYPE)
+#     define BOOST_NO_CWCTYPE
+#  endif
+
+//
+// We can't have a swprintf if there is no <cwchar>:
+//
+#  if defined(BOOST_NO_CWCHAR) && !defined(BOOST_NO_SWPRINTF)
+#     define BOOST_NO_SWPRINTF
+#  endif
+
+//
+// If Win32 support is turned off, then we must turn off
+// threading support also, unless there is some other
+// thread API enabled:
+//
+#if defined(BOOST_DISABLE_WIN32) && defined(_WIN32) \
+   && !defined(BOOST_DISABLE_THREADS) && !defined(BOOST_HAS_PTHREADS)
+#  define BOOST_DISABLE_THREADS
+#endif
+
+//
+// Turn on threading support if the compiler thinks that it's in
+// multithreaded mode.  We put this here because there are only a
+// limited number of macros that identify this (if there's any missing
+// from here then add to the appropriate compiler section):
+//
+#if (defined(__MT__) || defined(_MT) || defined(_REENTRANT) \
+    || defined(_PTHREADS)) && !defined(BOOST_HAS_THREADS)
+#  define BOOST_HAS_THREADS
+#endif
+
+//
+// Turn threading support off if BOOST_DISABLE_THREADS is defined:
+//
+#if defined(BOOST_DISABLE_THREADS) && defined(BOOST_HAS_THREADS)
+#  undef BOOST_HAS_THREADS
+#endif
+
+//
+// Turn threading support off if we don't recognise the threading API:
+//
+#if defined(BOOST_HAS_THREADS) && !defined(BOOST_HAS_PTHREADS)\
+      && !defined(BOOST_HAS_WINTHREADS) && !defined(BOOST_HAS_BETHREADS)\
+      && !defined(BOOST_HAS_MPTASKS)
+#  undef BOOST_HAS_THREADS
+#endif
+
+//
+// Turn threading detail macros off if we don't (want to) use threading
+//
+#ifndef BOOST_HAS_THREADS
+#  undef BOOST_HAS_PTHREADS
+#  undef BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#  undef BOOST_HAS_WINTHREADS
+#  undef BOOST_HAS_BETHREADS
+#  undef BOOST_HAS_MPTASKS
+#endif
+
+//
+// If the compiler claims to be C99 conformant, then it had better
+// have a <stdint.h>:
+//
+#  if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901)
+#     define BOOST_HAS_STDINT_H
+#  endif
+
+//
+// Define BOOST_NO_SLIST and BOOST_NO_HASH if required.
+// Note that this is for backwards compatibility only.
+//
+#  ifndef BOOST_HAS_SLIST
+#     define BOOST_NO_SLIST
+#  endif
+
+#  ifndef BOOST_HAS_HASH
+#     define BOOST_NO_HASH
+#  endif
+
+//  BOOST_HAS_ABI_HEADERS
+//  This macro gets set if we have headers that fix the ABI,
+//  and prevent ODR violations when linking to external libraries:
+#if defined(BOOST_ABI_PREFIX) && defined(BOOST_ABI_SUFFIX) && !defined(BOOST_HAS_ABI_HEADERS)
+#  define BOOST_HAS_ABI_HEADERS
+#endif
+
+#if defined(BOOST_HAS_ABI_HEADERS) && defined(BOOST_DISABLE_ABI_HEADERS)
+#  undef BOOST_HAS_ABI_HEADERS
+#endif
+
+//  BOOST_NO_STDC_NAMESPACE workaround  --------------------------------------//
+//  Because std::size_t usage is so common, even in boost headers which do not
+//  otherwise use the C library, the <cstddef> workaround is included here so
+//  that ugly workaround code need not appear in many other boost headers.
+//  NOTE WELL: This is a workaround for non-conforming compilers; <cstddef> 
+//  must still be #included in the usual places so that <cstddef> inclusion
+//  works as expected with standard conforming compilers.  The resulting
+//  double inclusion of <cstddef> is harmless.
+
+# ifdef BOOST_NO_STDC_NAMESPACE
+#   include <cstddef>
+    namespace std { using ::ptrdiff_t; using ::size_t; }
+# endif
+
+//  BOOST_NO_STD_MIN_MAX workaround  -----------------------------------------//
+
+#  ifdef BOOST_NO_STD_MIN_MAX
+
+namespace std {
+  template <class _Tp>
+  inline const _Tp& min(const _Tp& __a, const _Tp& __b) {
+    return __b < __a ? __b : __a;
+  }
+  template <class _Tp>
+  inline const _Tp& max(const _Tp& __a, const _Tp& __b) {
+    return  __a < __b ? __b : __a;
+  }
+}
+
+#  endif
+
+// BOOST_STATIC_CONSTANT workaround --------------------------------------- //
+// On compilers which don't allow in-class initialization of static integral
+// constant members, we must use enums as a workaround if we want the constants
+// to be available at compile-time. This macro gives us a convenient way to
+// declare such constants.
+
+#  ifdef BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+#       define BOOST_STATIC_CONSTANT(type, assignment) enum { assignment }
+#  else
+#     define BOOST_STATIC_CONSTANT(type, assignment) static const type assignment
+#  endif
+
+// BOOST_USE_FACET workaround ----------------------------------------------//
+// When the standard library does not have a conforming std::use_facet there
+// are various workarounds available, but they differ from library to library.
+// This macro provides a consistent way to access a locale's facets.
+// Usage:
+//    replace
+//       std::use_facet<Type>(loc);
+//    with
+//       BOOST_USE_FACET(Type, loc);
+//    Note do not add a std:: prefix to the front of BOOST_USE_FACET!
+
+#if defined(BOOST_NO_STD_USE_FACET)
+#  ifdef BOOST_HAS_TWO_ARG_USE_FACET
+#     define BOOST_USE_FACET(Type, loc) std::use_facet(loc, static_cast<Type*>(0))
+#  elif defined(BOOST_HAS_MACRO_USE_FACET)
+#     define BOOST_USE_FACET(Type, loc) std::_USE(loc, Type)
+#  elif defined(BOOST_HAS_STLP_USE_FACET)
+#     define BOOST_USE_FACET(Type, loc) (*std::_Use_facet<Type >(loc))
+#  endif
+#else
+#  define BOOST_USE_FACET(Type, loc) std::use_facet< Type >(loc)
+#endif
+
+// BOOST_NESTED_TEMPLATE workaround ------------------------------------------//
+// Member templates are supported by some compilers even though they can't use
+// the A::template member<U> syntax, as a workaround replace:
+//
+// typedef typename A::template rebind<U> binder;
+//
+// with:
+//
+// typedef typename A::BOOST_NESTED_TEMPLATE rebind<U> binder;
+
+#ifndef BOOST_NO_MEMBER_TEMPLATE_KEYWORD
+#  define BOOST_NESTED_TEMPLATE template
+#else
+#  define BOOST_NESTED_TEMPLATE
+#endif
+
+// BOOST_UNREACHABLE_RETURN(x) workaround -------------------------------------//
+// Normally evaluates to nothing, unless BOOST_NO_UNREACHABLE_RETURN_DETECTION
+// is defined, in which case it evaluates to return x; Use when you have a return
+// statement that can never be reached.
+
+#ifdef BOOST_NO_UNREACHABLE_RETURN_DETECTION
+#  define BOOST_UNREACHABLE_RETURN(x) return x;
+#else
+#  define BOOST_UNREACHABLE_RETURN(x)
+#endif
+
+// BOOST_DEDUCED_TYPENAME workaround ------------------------------------------//
+//
+// Some compilers don't support the use of `typename' for dependent
+// types in deduced contexts, e.g.
+//
+//     template <class T> void f(T, typename T::type);
+//                                  ^^^^^^^^
+// Replace these declarations with:
+//
+//     template <class T> void f(T, BOOST_DEDUCED_TYPENAME T::type);
+
+#ifndef BOOST_NO_DEDUCED_TYPENAME
+#  define BOOST_DEDUCED_TYPENAME typename
+#else 
+#  define BOOST_DEDUCED_TYPENAME
+#endif
+
+// BOOST_[APPEND_]EXPLICIT_TEMPLATE_[NON_]TYPE macros --------------------------//
+//
+// Some compilers have problems with function templates whose
+// template parameters don't appear in the function parameter
+// list (basically they just link one instantiation of the
+// template in the final executable). These macros provide a
+// uniform way to cope with the problem with no effects on the
+// calling syntax.
+
+// Example:
+//
+//  #include <iostream>
+//  #include <ostream>
+//  #include <typeinfo>
+//
+//  template <int n>
+//  void f() { std::cout << n << ' '; }
+//
+//  template <typename T>
+//  void g() { std::cout << typeid(T).name() << ' '; }
+//
+//  int main() {
+//    f<1>();
+//    f<2>();
+//
+//    g<int>();
+//    g<double>();
+//  }
+//
+// With VC++ 6.0 the output is:
+//
+//   2 2 double double
+//
+// To fix it, write
+//
+//   template <int n>
+//   void f(BOOST_EXPLICIT_TEMPLATE_NON_TYPE(int, n)) { ... }
+//
+//   template <typename T>
+//   void g(BOOST_EXPLICIT_TEMPLATE_TYPE(T)) { ... }
+//
+
+
+#if defined BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS
+
+#  include "boost/type.hpp"
+#  include "boost/non_type.hpp"
+
+#  define BOOST_EXPLICIT_TEMPLATE_TYPE(t)         boost::type<t>* = 0
+#  define BOOST_EXPLICIT_TEMPLATE_TYPE_SPEC(t)    boost::type<t>*
+#  define BOOST_EXPLICIT_TEMPLATE_NON_TYPE(t, v)  boost::non_type<t, v>* = 0
+#  define BOOST_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)  boost::non_type<t, v>*
+
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE(t)         \
+             , BOOST_EXPLICIT_TEMPLATE_TYPE(t)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE_SPEC(t)    \
+             , BOOST_EXPLICIT_TEMPLATE_TYPE_SPEC(t)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE(t, v)  \
+             , BOOST_EXPLICIT_TEMPLATE_NON_TYPE(t, v)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)  \
+             , BOOST_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)
+
+#else
+
+// no workaround needed: expand to nothing
+
+#  define BOOST_EXPLICIT_TEMPLATE_TYPE(t)
+#  define BOOST_EXPLICIT_TEMPLATE_TYPE_SPEC(t)
+#  define BOOST_EXPLICIT_TEMPLATE_NON_TYPE(t, v)
+#  define BOOST_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)
+
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE(t)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE_SPEC(t)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE(t, v)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)
+
+
+#endif // defined BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS
+
+
+// ---------------------------------------------------------------------------//
+
+//
+// Helper macro BOOST_STRINGIZE:
+// Converts the parameter X to a string after macro replacement
+// on X has been performed.
+//
+#define BOOST_STRINGIZE(X) BOOST_DO_STRINGIZE(X)
+#define BOOST_DO_STRINGIZE(X) #X
+
+//
+// Helper macro BOOST_JOIN:
+// The following piece of macro magic joins the two 
+// arguments together, even when one of the arguments is
+// itself a macro (see 16.3.1 in C++ standard).  The key
+// is that macro expansion of macro arguments does not
+// occur in BOOST_DO_JOIN2 but does in BOOST_DO_JOIN.
+//
+#define BOOST_JOIN( X, Y ) BOOST_DO_JOIN( X, Y )
+#define BOOST_DO_JOIN( X, Y ) BOOST_DO_JOIN2(X,Y)
+#define BOOST_DO_JOIN2( X, Y ) X##Y
+
+//
+// Set some default values for compiler/library/platform names.
+// These are for debugging config setup only:
+//
+#  ifndef BOOST_COMPILER
+#     define BOOST_COMPILER "Unknown ISO C++ Compiler"
+#  endif
+#  ifndef BOOST_STDLIB
+#     define BOOST_STDLIB "Unknown ISO standard library"
+#  endif
+#  ifndef BOOST_PLATFORM
+#     if defined(unix) || defined(__unix) || defined(_XOPEN_SOURCE) \
+         || defined(_POSIX_SOURCE)
+#        define BOOST_PLATFORM "Generic Unix"
+#     else
+#        define BOOST_PLATFORM "Unknown"
+#     endif
+#  endif
+
+#endif
+
+
+

Added: trunk/source/libraries/boost/config/user.hpp
===================================================================
--- trunk/source/libraries/boost/config/user.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/user.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,124 @@
+//  boost/config/user.hpp  ---------------------------------------------------//
+
+//  (C) Copyright John Maddock 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  Do not check in modified versions of this file,
+//  This file may be customized by the end user, but not by boost.
+
+//
+//  Use this file to define a site and compiler specific
+//  configuration policy:
+//
+
+// define this to locate a compiler config file:
+// #define BOOST_COMPILER_CONFIG <myheader>
+
+// define this to locate a stdlib config file:
+// #define BOOST_STDLIB_CONFIG   <myheader>
+
+// define this to locate a platform config file:
+// #define BOOST_PLATFORM_CONFIG <myheader>
+
+// define this to disable compiler config,
+// use if your compiler config has nothing to set:
+// #define BOOST_NO_COMPILER_CONFIG
+
+// define this to disable stdlib config,
+// use if your stdlib config has nothing to set:
+// #define BOOST_NO_STDLIB_CONFIG
+
+// define this to disable platform config,
+// use if your platform config has nothing to set:
+// #define BOOST_NO_PLATFORM_CONFIG
+
+// define this to disable all config options,
+// excluding the user config.  Use if your
+// setup is fully ISO compliant, and has no
+// useful extensions, or for autoconf generated
+// setups:
+// #define BOOST_NO_CONFIG
+
+// define this to make the config "optimistic"
+// about unknown compiler versions.  Normally
+// unknown compiler versions are assumed to have
+// all the defects of the last known version, however
+// setting this flag, causes the config to assume
+// that unknown compiler versions are fully conformant
+// with the standard:
+// #define BOOST_STRICT_CONFIG
+
+// define this to cause the config to halt compilation
+// with an #error if it encounters anything unknown --
+// either an unknown compiler version or an unknown
+// compiler/platform/library:
+// #define BOOST_ASSERT_CONFIG
+
+
+// define if you want to disable threading support, even
+// when available:
+// #define BOOST_DISABLE_THREADS
+
+// define when you want to disable Win32 specific features
+// even when available:
+// #define BOOST_DISABLE_WIN32
+
+// BOOST_DISABLE_ABI_HEADERS: Stops boost headers from including any 
+// prefix/suffix headers that normally control things like struct 
+// packing and alignment. 
+// #define BOOST_DISABLE_ABI_HEADERS
+
+// BOOST_ABI_PREFIX: A prefix header to include in place of whatever
+// boost.config would normally select, any replacement should set up 
+// struct packing and alignment options as required. 
+// #define BOOST_ABI_PREFIX my-header-name
+
+// BOOST_ABI_SUFFIX: A suffix header to include in place of whatever 
+// boost.config would normally select, any replacement should undo 
+// the effects of the prefix header. 
+// #define BOOST_ABI_SUFFIX my-header-name
+
+// BOOST_ALL_DYN_LINK: Forces all libraries that have separate source, 
+// to be linked as dll's rather than static libraries on Microsoft Windows 
+// (this macro is used to turn on __declspec(dllimport) modifiers, so that 
+// the compiler knows which symbols to look for in a dll rather than in a 
+// static library).  Note that there may be some libraries that can only 
+// be statically linked (Boost.Test for example) and others which may only 
+// be dynamically linked (Boost.Threads for example), in these cases this 
+// macro has no effect.
+// #define BOOST_ALL_DYN_LINK
+ 
+// BOOST_WHATEVER_DYN_LINK: Forces library "whatever" to be linked as a dll 
+// rather than a static library on Microsoft Windows: replace the WHATEVER 
+// part of the macro name with the name of the library that you want to 
+// dynamically link to, for example use BOOST_DATE_TIME_DYN_LINK or 
+// BOOST_REGEX_DYN_LINK etc (this macro is used to turn on __declspec(dllimport) 
+// modifiers, so that the compiler knows which symbols to look for in a dll 
+// rather than in a static library).  
+// Note that there may be some libraries that can only be statically linked 
+// (Boost.Test for example) and others which may only be dynamically linked 
+// (Boost.Threads for example), in these cases this macro is unsupported.
+// #define BOOST_WHATEVER_DYN_LINK
+ 
+// BOOST_ALL_NO_LIB: Tells the config system not to automatically select 
+// which libraries to link against.  
+// Normally if a compiler supports #pragma lib, then the correct library 
+// build variant will be automatically selected and linked against, 
+// simply by the act of including one of that library's headers.  
+// This macro turns that feature off.
+// #define BOOST_ALL_NO_LIB
+ 
+// BOOST_WHATEVER_NO_LIB: Tells the config system not to automatically 
+// select which library to link against for library "whatever", 
+// replace WHATEVER in the macro name with the name of the library; 
+// for example BOOST_DATE_TIME_NO_LIB or BOOST_REGEX_NO_LIB.  
+// Normally if a compiler supports #pragma lib, then the correct library 
+// build variant will be automatically selected and linked against, simply 
+// by the act of including one of that library's headers.  This macro turns 
+// that feature off.
+// #define BOOST_WHATEVER_NO_LIB
+ 
+
+

Added: trunk/source/libraries/boost/config.hpp
===================================================================
--- trunk/source/libraries/boost/config.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,70 @@
+//  Boost config.hpp configuration header file  ------------------------------//
+
+//  (C) Copyright John Maddock 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org/libs/config for most recent version.
+
+//  Boost config.hpp policy and rationale documentation has been moved to
+//  http://www.boost.org/libs/config
+//
+//  CAUTION: This file is intended to be completely stable -
+//           DO NOT MODIFY THIS FILE!
+//
+
+#ifndef BOOST_CONFIG_HPP
+#define BOOST_CONFIG_HPP
+
+// if we don't have a user config, then use the default location:
+#if !defined(BOOST_USER_CONFIG) && !defined(BOOST_NO_USER_CONFIG)
+#  define BOOST_USER_CONFIG <boost/config/user.hpp>
+#endif
+// include it first:
+#ifdef BOOST_USER_CONFIG
+#  include BOOST_USER_CONFIG
+#endif
+
+// if we don't have a compiler config set, try and find one:
+#if !defined(BOOST_COMPILER_CONFIG) && !defined(BOOST_NO_COMPILER_CONFIG) && !defined(BOOST_NO_CONFIG)
+#  include <boost/config/select_compiler_config.hpp>
+#endif
+// if we have a compiler config, include it now:
+#ifdef BOOST_COMPILER_CONFIG
+#  include BOOST_COMPILER_CONFIG
+#endif
+
+// if we don't have a std library config set, try and find one:
+#if !defined(BOOST_STDLIB_CONFIG) && !defined(BOOST_NO_STDLIB_CONFIG) && !defined(BOOST_NO_CONFIG)
+#  include <boost/config/select_stdlib_config.hpp>
+#endif
+// if we have a std library config, include it now:
+#ifdef BOOST_STDLIB_CONFIG
+#  include BOOST_STDLIB_CONFIG
+#endif
+
+// if we don't have a platform config set, try and find one:
+#if !defined(BOOST_PLATFORM_CONFIG) && !defined(BOOST_NO_PLATFORM_CONFIG) && !defined(BOOST_NO_CONFIG)
+#  include <boost/config/select_platform_config.hpp>
+#endif
+// if we have a platform config, include it now:
+#ifdef BOOST_PLATFORM_CONFIG
+#  include BOOST_PLATFORM_CONFIG
+#endif
+
+// get config suffix code:
+#include <boost/config/suffix.hpp>
+
+#endif  // BOOST_CONFIG_HPP
+
+
+
+
+
+
+
+
+
+
+

Added: trunk/source/libraries/boost/detail/lightweight_mutex.hpp
===================================================================
--- trunk/source/libraries/boost/detail/lightweight_mutex.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/detail/lightweight_mutex.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,99 @@
+#ifndef BOOST_DETAIL_LIGHTWEIGHT_MUTEX_HPP_INCLUDED
+#define BOOST_DETAIL_LIGHTWEIGHT_MUTEX_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  boost/detail/lightweight_mutex.hpp - lightweight mutex
+//
+//  Copyright (c) 2002, 2003 Peter Dimov and Multi Media Ltd.
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided "as is" without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  typedef <unspecified> boost::detail::lightweight_mutex;
+//
+//  boost::detail::lightweight_mutex meets a subset of the Mutex concept
+//  requirements: http://www.boost.org/libs/thread/doc/mutex_concept.html#Mutex
+//
+//  * Used by the smart pointer library
+//  * Performance oriented
+//  * Header-only implementation
+//  * Small memory footprint
+//  * Not a general purpose mutex, use boost::mutex, CRITICAL_SECTION or
+//    pthread_mutex instead.
+//  * Never spin in a tight lock/do-something/unlock loop, since
+//    lightweight_mutex does not guarantee fairness.
+//  * Never keep a lightweight_mutex locked for long periods.
+//
+//  The current implementation can use a pthread_mutex, a CRITICAL_SECTION,
+//  or a platform-specific spinlock.
+//
+//  You can force a particular implementation by defining BOOST_LWM_USE_PTHREADS,
+//  BOOST_LWM_USE_CRITICAL_SECTION, or BOOST_LWM_USE_SPINLOCK.
+//
+//  If neither macro has been defined, the default is to use a spinlock on Win32,
+//  and a pthread_mutex otherwise.
+//
+//  Note that a spinlock is not a general synchronization primitive. In particular,
+//  it is not guaranteed to be a memory barrier, and it is possible to "livelock"
+//  if a lower-priority thread has acquired the spinlock but a higher-priority
+//  thread is spinning trying to acquire the same lock.
+//
+//  For these reasons, spinlocks have been disabled by default except on Windows,
+//  where a spinlock can be several orders of magnitude faster than a CRITICAL_SECTION.
+
+
+//  Note: lwm_linux.hpp has been disabled by default; see the comments
+//        inside for more info.
+
+
+#include <boost/config.hpp>
+
+//  Note to implementors: if you write a platform-specific spinlock
+//  for a platform that supports pthreads, be sure to test its performance
+//  against the pthreads-based version using shared_ptr_timing_test.cpp and
+//  shared_ptr_mt_test.cpp. Custom versions are usually not worth the trouble
+//  _unless_ the performance gains are substantial.
+//
+//  Be sure to compare against a "real" pthreads library;
+//  shared_ptr_timing_test.cpp will compile succesfully with a stub do-nothing
+//  pthreads library, since it doesn't create any threads.
+
+#if (defined(WIN32) || defined(_WIN32) || defined(__WIN32__)) && !defined(BOOST_LWM_USE_CRITICAL_SECTION) && !defined(BOOST_LWM_USE_PTHREADS)
+# define BOOST_LWM_WIN32
+#endif
+
+#if !defined(BOOST_HAS_THREADS)
+#  if defined(BOOST_LWM_WIN32)
+#    include <boost/detail/lwm_win32_nt.hpp>
+#  else
+#    include <boost/detail/lwm_nop.hpp>
+#  endif
+#elif defined(BOOST_LWM_USE_SPINLOCK) && defined(BOOST_USE_ASM_ATOMIC_H)
+#  include <boost/detail/lwm_linux.hpp>
+#elif defined(BOOST_LWM_USE_CRITICAL_SECTION)
+#  include <boost/detail/lwm_win32_cs.hpp>
+#elif defined(BOOST_LWM_USE_PTHREADS)
+#  include <boost/detail/lwm_pthreads.hpp>
+#elif defined(BOOST_LWM_WIN32)
+#  include <boost/detail/lwm_win32.hpp>
+#elif defined(BOOST_LWM_USE_SPINLOCK) && defined(__sgi)
+#  include <boost/detail/lwm_irix.hpp>
+#elif defined(BOOST_LWM_USE_SPINLOCK) && defined(__GLIBCPP__)
+#  include <boost/detail/lwm_gcc.hpp>
+#elif defined(BOOST_HAS_PTHREADS)
+#  define BOOST_LWM_USE_PTHREADS
+#  include <boost/detail/lwm_pthreads.hpp>
+#else
+// Use #define BOOST_DISABLE_THREADS to avoid the error
+#  error Unrecognized threading platform
+#endif
+
+#endif // #ifndef BOOST_DETAIL_LIGHTWEIGHT_MUTEX_HPP_INCLUDED

Added: trunk/source/libraries/boost/detail/lwm_pthreads.hpp
===================================================================
--- trunk/source/libraries/boost/detail/lwm_pthreads.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/detail/lwm_pthreads.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,87 @@
+#ifndef BOOST_DETAIL_LWM_PTHREADS_HPP_INCLUDED
+#define BOOST_DETAIL_LWM_PTHREADS_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  boost/detail/lwm_pthreads.hpp
+//
+//  Copyright (c) 2002 Peter Dimov and Multi Media Ltd.
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided "as is" without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+
+#include <pthread.h>
+
+namespace boost
+{
+
+namespace detail
+{
+
+class lightweight_mutex
+{
+private:
+
+    pthread_mutex_t m_;
+
+    lightweight_mutex(lightweight_mutex const &);
+    lightweight_mutex & operator=(lightweight_mutex const &);
+
+public:
+
+    lightweight_mutex()
+    {
+
+// HPUX 10.20 / DCE has a nonstandard pthread_mutex_init
+
+#if defined(__hpux) && defined(_DECTHREADS_)
+        pthread_mutex_init(&m_, pthread_mutexattr_default);
+#else
+        pthread_mutex_init(&m_, 0);
+#endif
+    }
+
+    ~lightweight_mutex()
+    {
+        pthread_mutex_destroy(&m_);
+    }
+
+    class scoped_lock;
+    friend class scoped_lock;
+
+    class scoped_lock
+    {
+    private:
+
+        pthread_mutex_t & m_;
+
+        scoped_lock(scoped_lock const &);
+        scoped_lock & operator=(scoped_lock const &);
+
+    public:
+
+        scoped_lock(lightweight_mutex & m): m_(m.m_)
+        {
+            pthread_mutex_lock(&m_);
+        }
+
+        ~scoped_lock()
+        {
+            pthread_mutex_unlock(&m_);
+        }
+    };
+};
+
+} // namespace detail
+
+} // namespace boost
+
+#endif // #ifndef BOOST_DETAIL_LWM_PTHREADS_HPP_INCLUDED

Added: trunk/source/libraries/boost/detail/lwm_win32.hpp
===================================================================
--- trunk/source/libraries/boost/detail/lwm_win32.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/detail/lwm_win32.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,123 @@
+#ifndef BOOST_DETAIL_LWM_WIN32_HPP_INCLUDED
+#define BOOST_DETAIL_LWM_WIN32_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  boost/detail/lwm_win32.hpp
+//
+//  Copyright (c) 2002, 2003 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided "as is" without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+
+#ifdef BOOST_USE_WINDOWS_H
+#  include <windows.h>
+#endif
+
+#ifdef __BORLANDC__
+# pragma warn -8027     // Functions containing while are not expanded inline
+#endif
+
+namespace boost
+{
+
+namespace detail
+{
+
+#ifndef BOOST_USE_WINDOWS_H
+
+#ifdef _WIN64
+
+// Intel 6.0 on Win64 version, posted by Tim Fenders to [boost-users]
+
+extern "C" long_type __cdecl _InterlockedExchange(long volatile *, long);
+
+#pragma intrinsic(_InterlockedExchange)
+
+inline long InterlockedExchange(long volatile* lp, long l)
+{
+    return _InterlockedExchange(lp, l);
+}
+
+#else  // _WIN64
+
+extern "C" __declspec(dllimport) long __stdcall InterlockedExchange(long volatile *, long);
+
+#endif // _WIN64
+
+extern "C" __declspec(dllimport) void __stdcall Sleep(unsigned long);
+
+#endif // #ifndef BOOST_USE_WINDOWS_H
+
+class lightweight_mutex
+{
+private:
+
+    long l_;
+
+    lightweight_mutex(lightweight_mutex const &);
+    lightweight_mutex & operator=(lightweight_mutex const &);
+
+public:
+
+    lightweight_mutex(): l_(0)
+    {
+    }
+
+    class scoped_lock;
+    friend class scoped_lock;
+
+    class scoped_lock
+    {
+    private:
+
+        lightweight_mutex & m_;
+
+        scoped_lock(scoped_lock const &);
+        scoped_lock & operator=(scoped_lock const &);
+
+    public:
+
+        explicit scoped_lock(lightweight_mutex & m): m_(m)
+        {
+            while( InterlockedExchange(&m_.l_, 1) )
+            {
+                // Note: changed to Sleep(1) from Sleep(0).
+                // According to MSDN, Sleep(0) will never yield
+                // to a lower-priority thread, whereas Sleep(1)
+                // will. Performance seems not to be affected.
+
+                Sleep(1);
+            }
+        }
+
+        ~scoped_lock()
+        {
+            InterlockedExchange(&m_.l_, 0);
+
+            // Note: adding a yield here will make
+            // the spinlock more fair and will increase the overall
+            // performance of some applications substantially in
+            // high contention situations, but will penalize the
+            // low contention / single thread case up to 5x
+        }
+    };
+};
+
+} // namespace detail
+
+} // namespace boost
+
+#ifdef __BORLANDC__
+# pragma warn .8027     // Functions containing while are not expanded inline
+#endif
+
+#endif // #ifndef BOOST_DETAIL_LWM_WIN32_HPP_INCLUDED

Added: trunk/source/libraries/boost/detail/lwm_win32_cs.hpp
===================================================================
--- trunk/source/libraries/boost/detail/lwm_win32_cs.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/detail/lwm_win32_cs.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,105 @@
+#ifndef BOOST_DETAIL_LWM_WIN32_CS_HPP_INCLUDED
+#define BOOST_DETAIL_LWM_WIN32_CS_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  boost/detail/lwm_win32_cs.hpp
+//
+//  Copyright (c) 2002, 2003 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided "as is" without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+
+#ifdef BOOST_USE_WINDOWS_H
+#  include <windows.h>
+#endif
+
+namespace boost
+{
+
+namespace detail
+{
+
+#ifndef BOOST_USE_WINDOWS_H
+
+struct CRITICAL_SECTION
+{
+    struct critical_section_debug * DebugInfo;
+    long LockCount;
+    long RecursionCount;
+    void * OwningThread;
+    void * LockSemaphore;
+#if defined(_WIN64)
+    unsigned __int64 SpinCount;
+#else
+    unsigned long SpinCount;
+#endif
+};
+
+extern "C" __declspec(dllimport) void __stdcall InitializeCriticalSection(CRITICAL_SECTION *);
+extern "C" __declspec(dllimport) void __stdcall EnterCriticalSection(CRITICAL_SECTION *);
+extern "C" __declspec(dllimport) void __stdcall LeaveCriticalSection(CRITICAL_SECTION *);
+extern "C" __declspec(dllimport) void __stdcall DeleteCriticalSection(CRITICAL_SECTION *);
+
+#endif // #ifndef BOOST_USE_WINDOWS_H
+
+class lightweight_mutex
+{
+private:
+
+    CRITICAL_SECTION cs_;
+
+    lightweight_mutex(lightweight_mutex const &);
+    lightweight_mutex & operator=(lightweight_mutex const &);
+
+public:
+
+    lightweight_mutex()
+    {
+        InitializeCriticalSection(&cs_);
+    }
+
+    ~lightweight_mutex()
+    {
+        DeleteCriticalSection(&cs_);
+    }
+
+    class scoped_lock;
+    friend class scoped_lock;
+
+    class scoped_lock
+    {
+    private:
+
+        lightweight_mutex & m_;
+
+        scoped_lock(scoped_lock const &);
+        scoped_lock & operator=(scoped_lock const &);
+
+    public:
+
+        explicit scoped_lock(lightweight_mutex & m): m_(m)
+        {
+            EnterCriticalSection(&m_.cs_);
+        }
+
+        ~scoped_lock()
+        {
+            LeaveCriticalSection(&m_.cs_);
+        }
+    };
+};
+
+} // namespace detail
+
+} // namespace boost
+
+#endif // #ifndef BOOST_DETAIL_LWM_WIN32_CS_HPP_INCLUDED

Added: trunk/source/libraries/boost/detail/lwm_win32_nt.hpp
===================================================================
--- trunk/source/libraries/boost/detail/lwm_win32_nt.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/detail/lwm_win32_nt.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,64 @@
+#ifndef BOOST_DETAIL_LWM_WIN32_NT_HPP_INCLUDED
+#define BOOST_DETAIL_LWM_WIN32_NT_HPP_INCLUDED
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  boost/detail/lwm_win32_nt.hpp
+//
+//  Copyright (c) 2002, 2003 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided "as is" without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  "No threads" version of lwm_win32.hpp; binary compatible but no-op.
+//
+
+namespace boost
+{
+
+namespace detail
+{
+
+class lightweight_mutex
+{
+private:
+
+    long l_;
+
+    lightweight_mutex(lightweight_mutex const &);
+    lightweight_mutex & operator=(lightweight_mutex const &);
+
+public:
+
+    lightweight_mutex(): l_(0)
+    {
+    }
+
+    class scoped_lock;
+    friend class scoped_lock;
+
+    class scoped_lock
+    {
+    private:
+
+        scoped_lock(scoped_lock const &);
+        scoped_lock & operator=(scoped_lock const &);
+
+    public:
+
+        explicit scoped_lock(lightweight_mutex &)
+        {
+        }
+    };
+};
+
+} // namespace detail
+
+} // namespace boost
+
+#endif // #ifndef BOOST_DETAIL_LWM_WIN32_NT_HPP_INCLUDED

Added: trunk/source/libraries/boost/detail/shared_count.hpp
===================================================================
--- trunk/source/libraries/boost/detail/shared_count.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/detail/shared_count.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,555 @@
+#ifndef BOOST_DETAIL_SHARED_COUNT_HPP_INCLUDED
+#define BOOST_DETAIL_SHARED_COUNT_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  detail/shared_count.hpp
+//
+//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided "as is" without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+
+#include <boost/config.hpp>
+
+#if defined(BOOST_SP_USE_STD_ALLOCATOR) && defined(BOOST_SP_USE_QUICK_ALLOCATOR)
+# error BOOST_SP_USE_STD_ALLOCATOR and BOOST_SP_USE_QUICK_ALLOCATOR are incompatible.
+#endif
+
+#include <boost/checked_delete.hpp>
+#include <boost/throw_exception.hpp>
+#include <boost/detail/lightweight_mutex.hpp>
+
+#if defined(BOOST_SP_USE_QUICK_ALLOCATOR)
+#include <boost/detail/quick_allocator.hpp>
+#endif
+
+#include <memory>           // std::auto_ptr, std::allocator
+#include <functional>       // std::less
+#include <exception>        // std::exception
+#include <new>              // std::bad_alloc
+#include <typeinfo>         // std::type_info in get_deleter
+#include <cstddef>          // std::size_t
+
+#ifdef __BORLANDC__
+# pragma warn -8026     // Functions with excep. spec. are not expanded inline
+# pragma warn -8027     // Functions containing try are not expanded inline
+#endif
+
+namespace boost
+{
+
+// Debug hooks
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+
+void sp_scalar_constructor_hook(void * px, std::size_t size, void * pn);
+void sp_array_constructor_hook(void * px);
+void sp_scalar_destructor_hook(void * px, std::size_t size, void * pn);
+void sp_array_destructor_hook(void * px);
+
+#endif
+
+
+// The standard library that comes with Borland C++ 5.5.1
+// defines std::exception and its members as having C calling
+// convention (-pc). When the definition of bad_weak_ptr
+// is compiled with -ps, the compiler issues an error.
+// Hence, the temporary #pragma option -pc below. The version
+// check is deliberately conservative.
+
+#if defined(__BORLANDC__) && __BORLANDC__ == 0x551
+# pragma option push -pc
+#endif
+
+class bad_weak_ptr: public std::exception
+{
+public:
+
+    virtual char const * what() const throw()
+    {
+        return "boost::bad_weak_ptr";
+    }
+};
+
+#if defined(__BORLANDC__) && __BORLANDC__ == 0x551
+# pragma option pop
+#endif
+
+namespace detail
+{
+
+class sp_counted_base
+{
+private:
+
+    typedef detail::lightweight_mutex mutex_type;
+
+public:
+
+    sp_counted_base(): use_count_(1), weak_count_(1)
+    {
+    }
+
+    virtual ~sp_counted_base() // nothrow
+    {
+    }
+
+    // dispose() is called when use_count_ drops to zero, to release
+    // the resources managed by *this.
+
+    virtual void dispose() = 0; // nothrow
+
+    // destruct() is called when weak_count_ drops to zero.
+
+    virtual void destruct() // nothrow
+    {
+        delete this;
+    }
+
+    virtual void * get_deleter(std::type_info const & ti) = 0;
+
+    void add_ref_copy()
+    {
+#if defined(BOOST_HAS_THREADS)
+        mutex_type::scoped_lock lock(mtx_);
+#endif
+        ++use_count_;
+    }
+
+    void add_ref_lock()
+    {
+#if defined(BOOST_HAS_THREADS)
+        mutex_type::scoped_lock lock(mtx_);
+#endif
+        if(use_count_ == 0) boost::throw_exception(boost::bad_weak_ptr());
+        ++use_count_;
+    }
+
+    void release() // nothrow
+    {
+        {
+#if defined(BOOST_HAS_THREADS)
+            mutex_type::scoped_lock lock(mtx_);
+#endif
+            long new_use_count = --use_count_;
+
+            if(new_use_count != 0) return;
+        }
+
+        dispose();
+        weak_release();
+    }
+
+    void weak_add_ref() // nothrow
+    {
+#if defined(BOOST_HAS_THREADS)
+        mutex_type::scoped_lock lock(mtx_);
+#endif
+        ++weak_count_;
+    }
+
+    void weak_release() // nothrow
+    {
+        long new_weak_count;
+
+        {
+#if defined(BOOST_HAS_THREADS)
+            mutex_type::scoped_lock lock(mtx_);
+#endif
+            new_weak_count = --weak_count_;
+        }
+
+        if(new_weak_count == 0)
+        {
+            destruct();
+        }
+    }
+
+    long use_count() const // nothrow
+    {
+#if defined(BOOST_HAS_THREADS)
+        mutex_type::scoped_lock lock(mtx_);
+#endif
+        return use_count_;
+    }
+
+private:
+
+    sp_counted_base(sp_counted_base const &);
+    sp_counted_base & operator= (sp_counted_base const &);
+
+    long use_count_;        // #shared
+    long weak_count_;       // #weak + (#shared != 0)
+
+#if defined(BOOST_HAS_THREADS) || defined(BOOST_LWM_WIN32)
+    mutable mutex_type mtx_;
+#endif
+};
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+
+template<class T> void cbi_call_constructor_hook(sp_counted_base * pn, T * px, checked_deleter<T> const &, int)
+{
+    boost::sp_scalar_constructor_hook(px, sizeof(T), pn);
+}
+
+template<class T> void cbi_call_constructor_hook(sp_counted_base *, T * px, checked_array_deleter<T> const &, int)
+{
+    boost::sp_array_constructor_hook(px);
+}
+
+template<class P, class D> void cbi_call_constructor_hook(sp_counted_base *, P const &, D const &, long)
+{
+}
+
+template<class T> void cbi_call_destructor_hook(sp_counted_base * pn, T * px, checked_deleter<T> const &, int)
+{
+    boost::sp_scalar_destructor_hook(px, sizeof(T), pn);
+}
+
+template<class T> void cbi_call_destructor_hook(sp_counted_base *, T * px, checked_array_deleter<T> const &, int)
+{
+    boost::sp_array_destructor_hook(px);
+}
+
+template<class P, class D> void cbi_call_destructor_hook(sp_counted_base *, P const &, D const &, long)
+{
+}
+
+#endif
+
+//
+// Borland's Codeguard trips up over the -Vx- option here:
+//
+#ifdef __CODEGUARD__
+# pragma option push -Vx-
+#endif
+
+template<class P, class D> class sp_counted_base_impl: public sp_counted_base
+{
+private:
+
+    P ptr; // copy constructor must not throw
+    D del; // copy constructor must not throw
+
+    sp_counted_base_impl(sp_counted_base_impl const &);
+    sp_counted_base_impl & operator= (sp_counted_base_impl const &);
+
+    typedef sp_counted_base_impl<P, D> this_type;
+
+public:
+
+    // pre: initial_use_count <= initial_weak_count, d(p) must not throw
+
+    sp_counted_base_impl(P p, D d): ptr(p), del(d)
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        detail::cbi_call_constructor_hook(this, p, d, 0);
+#endif
+    }
+
+    virtual void dispose() // nothrow
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        detail::cbi_call_destructor_hook(this, ptr, del, 0);
+#endif
+        del(ptr);
+    }
+
+    virtual void * get_deleter(std::type_info const & ti)
+    {
+        return ti == typeid(D)? &del: 0;
+    }
+
+#if defined(BOOST_SP_USE_STD_ALLOCATOR)
+
+    void * operator new(std::size_t)
+    {
+        return std::allocator<this_type>().allocate(1, static_cast<this_type *>(0));
+    }
+
+    void operator delete(void * p)
+    {
+        std::allocator<this_type>().deallocate(static_cast<this_type *>(p), 1);
+    }
+
+#endif
+
+#if defined(BOOST_SP_USE_QUICK_ALLOCATOR)
+
+    void * operator new(std::size_t)
+    {
+        return quick_allocator<this_type>::alloc();
+    }
+
+    void operator delete(void * p)
+    {
+        quick_allocator<this_type>::dealloc(p);
+    }
+
+#endif
+};
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+
+int const shared_count_id = 0x2C35F101;
+int const   weak_count_id = 0x298C38A4;
+
+#endif
+
+class weak_count;
+
+class shared_count
+{
+private:
+
+    sp_counted_base * pi_;
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+    int id_;
+#endif
+
+    friend class weak_count;
+
+public:
+
+    shared_count(): pi_(0) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+    }
+
+    template<class P, class D> shared_count(P p, D d): pi_(0)
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+#ifndef BOOST_NO_EXCEPTIONS
+
+        try
+        {
+            pi_ = new sp_counted_base_impl<P, D>(p, d);
+        }
+        catch(...)
+        {
+            d(p); // delete p
+            throw;
+        }
+
+#else
+
+        pi_ = new sp_counted_base_impl<P, D>(p, d);
+
+        if(pi_ == 0)
+        {
+            d(p); // delete p
+            boost::throw_exception(std::bad_alloc());
+        }
+
+#endif
+    }
+
+#ifndef BOOST_NO_AUTO_PTR
+
+    // auto_ptr<Y> is special cased to provide the strong guarantee
+
+    template<class Y>
+    explicit shared_count(std::auto_ptr<Y> & r): pi_(new sp_counted_base_impl< Y *, checked_deleter<Y> >(r.get(), checked_deleter<Y>()))
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+        r.release();
+    }
+
+#endif 
+
+    ~shared_count() // nothrow
+    {
+        if(pi_ != 0) pi_->release();
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        id_ = 0;
+#endif
+    }
+
+    shared_count(shared_count const & r): pi_(r.pi_) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+        if(pi_ != 0) pi_->add_ref_copy();
+    }
+
+    explicit shared_count(weak_count const & r); // throws bad_weak_ptr when r.use_count() == 0
+
+    shared_count & operator= (shared_count const & r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+        if(tmp != 0) tmp->add_ref_copy();
+        if(pi_ != 0) pi_->release();
+        pi_ = tmp;
+
+        return *this;
+    }
+
+    void swap(shared_count & r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+        r.pi_ = pi_;
+        pi_ = tmp;
+    }
+
+    long use_count() const // nothrow
+    {
+        return pi_ != 0? pi_->use_count(): 0;
+    }
+
+    bool unique() const // nothrow
+    {
+        return use_count() == 1;
+    }
+
+    friend inline bool operator==(shared_count const & a, shared_count const & b)
+    {
+        return a.pi_ == b.pi_;
+    }
+
+    friend inline bool operator<(shared_count const & a, shared_count const & b)
+    {
+        return std::less<sp_counted_base *>()(a.pi_, b.pi_);
+    }
+
+    void * get_deleter(std::type_info const & ti) const
+    {
+        return pi_? pi_->get_deleter(ti): 0;
+    }
+};
+
+#ifdef __CODEGUARD__
+# pragma option pop
+#endif
+
+
+class weak_count
+{
+private:
+
+    sp_counted_base * pi_;
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+    int id_;
+#endif
+
+    friend class shared_count;
+
+public:
+
+    weak_count(): pi_(0) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(weak_count_id)
+#endif
+    {
+    }
+
+    weak_count(shared_count const & r): pi_(r.pi_) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+        if(pi_ != 0) pi_->weak_add_ref();
+    }
+
+    weak_count(weak_count const & r): pi_(r.pi_) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+        if(pi_ != 0) pi_->weak_add_ref();
+    }
+
+    ~weak_count() // nothrow
+    {
+        if(pi_ != 0) pi_->weak_release();
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        id_ = 0;
+#endif
+    }
+
+    weak_count & operator= (shared_count const & r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+        if(tmp != 0) tmp->weak_add_ref();
+        if(pi_ != 0) pi_->weak_release();
+        pi_ = tmp;
+
+        return *this;
+    }
+
+    weak_count & operator= (weak_count const & r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+        if(tmp != 0) tmp->weak_add_ref();
+        if(pi_ != 0) pi_->weak_release();
+        pi_ = tmp;
+
+        return *this;
+    }
+
+    void swap(weak_count & r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+        r.pi_ = pi_;
+        pi_ = tmp;
+    }
+
+    long use_count() const // nothrow
+    {
+        return pi_ != 0? pi_->use_count(): 0;
+    }
+
+    friend inline bool operator==(weak_count const & a, weak_count const & b)
+    {
+        return a.pi_ == b.pi_;
+    }
+
+    friend inline bool operator<(weak_count const & a, weak_count const & b)
+    {
+        return std::less<sp_counted_base *>()(a.pi_, b.pi_);
+    }
+};
+
+inline shared_count::shared_count(weak_count const & r): pi_(r.pi_)
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+{
+    if(pi_ != 0)
+    {
+        pi_->add_ref_lock();
+    }
+    else
+    {
+        boost::throw_exception(boost::bad_weak_ptr());
+    }
+}
+
+} // namespace detail
+
+} // namespace boost
+
+#ifdef __BORLANDC__
+# pragma warn .8027     // Functions containing try are not expanded inline
+# pragma warn .8026     // Functions with excep. spec. are not expanded inline
+#endif
+
+#endif  // #ifndef BOOST_DETAIL_SHARED_COUNT_HPP_INCLUDED

Added: trunk/source/libraries/boost/detail/workaround.hpp
===================================================================
--- trunk/source/libraries/boost/detail/workaround.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/detail/workaround.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,74 @@
+// Copyright David Abrahams 2002. Permission to copy, use,
+// modify, sell and distribute this software is granted provided this
+// copyright notice appears in all copies. This software is provided
+// "as is" without express or implied warranty, and with no claim as
+// to its suitability for any purpose.
+#ifndef WORKAROUND_DWA2002126_HPP
+# define WORKAROUND_DWA2002126_HPP
+
+// Compiler/library version workaround macro
+//
+// Usage:
+//
+//     #if BOOST_WORKAROUND(BOOST_MSVC, <= 1200)
+//        ... // workaround code here
+//     #endif
+//
+// When BOOST_STRICT_CONFIG is defined, expands to 0. Otherwise, the
+// first argument must be undefined or expand to a numeric
+// value. The above expands to:
+//
+//     (BOOST_MSVC) != 0 && (BOOST_MSVC) <= 1200
+//
+// When used for workarounds that apply to the latest known version 
+// and all earlier versions of a compiler, the following convention 
+// should be observed:
+//
+//     #if BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1301))
+//
+// The version number in this case corresponds to the last version in
+// which the workaround was known to have been required. When
+// BOOST_DETECT_OUTDATED_WORKAROUNDS is not the defined, the macro
+// BOOST_TESTED_AT(x) expands to "!= 0", which effectively activates
+// the workaround for any version of the compiler. When
+// BOOST_DETECT_OUTDATED_WORKAROUNDS is defined, a compiler warning or
+// error will be issued if the compiler version exceeds the argument
+// to BOOST_TESTED_AT().  This can be used to locate workarounds which
+// may be obsoleted by newer versions.
+
+# ifndef BOOST_STRICT_CONFIG
+
+#  define BOOST_WORKAROUND(symbol, test)                \
+        ((symbol != 0) && (1 % (( (symbol test) ) + 1)))
+//                              ^ ^           ^ ^
+// The extra level of parenthesis nesting above, along with the
+// BOOST_OPEN_PAREN indirection below, is required to satisfy the
+// broken preprocessor in MWCW 8.3 and earlier.
+//
+// The basic mechanism works as follows:
+//      (symbol test) + 1        =>   if (symbol test) then 2 else 1
+//      1 % ((symbol test) + 1)  =>   if (symbol test) then 1 else 0
+//
+// The complication with % is for cooperation with BOOST_TESTED_AT().
+// When "test" is BOOST_TESTED_AT(x) and
+// BOOST_DETECT_OUTDATED_WORKAROUNDS is #defined,
+//
+//      symbol test              =>   if (symbol <= x) then 1 else -1
+//      (symbol test) + 1        =>   if (symbol <= x) then 2 else 0
+//      1 % ((symbol test) + 1)  =>   if (symbol <= x) then 1 else divide-by-zero
+//
+
+#  ifdef BOOST_DETECT_OUTDATED_WORKAROUNDS
+#   define BOOST_OPEN_PAREN (
+#   define BOOST_TESTED_AT(value)  > value) ?(-1): BOOST_OPEN_PAREN 1
+#  else
+#   define BOOST_TESTED_AT(value) != ((value)-(value))
+#  endif
+
+# else
+
+#  define BOOST_WORKAROUND(symbol, test) 0
+
+# endif 
+
+#endif // WORKAROUND_DWA2002126_HPP

Added: trunk/source/libraries/boost/non_type.hpp
===================================================================
--- trunk/source/libraries/boost/non_type.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/non_type.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,24 @@
+// (C) Copyright Gennaro Prota 2003. Permission to copy, use,
+// modify, sell and distribute this software is granted provided this
+// copyright notice appears in all copies. This software is provided
+// "as is" without express or implied warranty, and with no claim as
+// to its suitability for any purpose.
+
+
+#ifndef BOOST_NON_TYPE_HPP_GP_20030417
+#define BOOST_NON_TYPE_HPP_GP_20030417
+
+
+namespace boost {
+
+  // Just a simple "envelope" for non-type template parameters. Useful
+  // to work around some MSVC deficiencies.
+
+ template <typename T, T n>
+ struct non_type { };
+
+
+}
+
+
+#endif // include guard

Added: trunk/source/libraries/boost/scoped_array.hpp
===================================================================
--- trunk/source/libraries/boost/scoped_array.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/scoped_array.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,136 @@
+#ifndef BOOST_SCOPED_ARRAY_HPP_INCLUDED
+#define BOOST_SCOPED_ARRAY_HPP_INCLUDED
+
+//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
+//  Copyright (c) 2001, 2002 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided "as is" without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  http://www.boost.org/libs/smart_ptr/scoped_array.htm
+//
+
+#include <boost/assert.hpp>
+#include <boost/checked_delete.hpp>
+#include <boost/config.hpp>   // in case ptrdiff_t not in std
+
+#include <boost/detail/workaround.hpp>
+
+#include <cstddef>            // for std::ptrdiff_t
+
+namespace boost
+{
+
+// Debug hooks
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+
+void sp_array_constructor_hook(void * p);
+void sp_array_destructor_hook(void * p);
+
+#endif
+
+//  scoped_array extends scoped_ptr to arrays. Deletion of the array pointed to
+//  is guaranteed, either on destruction of the scoped_array or via an explicit
+//  reset(). Use shared_array or std::vector if your needs are more complex.
+
+template<class T> class scoped_array // noncopyable
+{
+private:
+
+    T * ptr;
+
+    scoped_array(scoped_array const &);
+    scoped_array & operator=(scoped_array const &);
+
+    typedef scoped_array<T> this_type;
+
+public:
+
+    typedef T element_type;
+
+    explicit scoped_array(T * p = 0) : ptr(p) // never throws
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_array_constructor_hook(ptr);
+#endif
+    }
+
+    ~scoped_array() // never throws
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_array_destructor_hook(ptr);
+#endif
+        boost::checked_array_delete(ptr);
+    }
+
+    void reset(T * p = 0) // never throws
+    {
+        BOOST_ASSERT(p == 0 || p != ptr); // catch self-reset errors
+        this_type(p).swap(*this);
+    }
+
+    T & operator[](std::ptrdiff_t i) const // never throws
+    {
+        BOOST_ASSERT(ptr != 0);
+        BOOST_ASSERT(i >= 0);
+        return ptr[i];
+    }
+
+    T * get() const // never throws
+    {
+        return ptr;
+    }
+
+    // implicit conversion to "bool"
+
+#if defined(__SUNPRO_CC) && BOOST_WORKAROUND(__SUNPRO_CC, <= 0x530)
+
+    operator bool () const
+    {
+        return ptr != 0;
+    }
+
+#elif defined(__MWERKS__) && BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3003))
+    typedef T * (this_type::*unspecified_bool_type)() const;
+    
+    operator unspecified_bool_type() const // never throws
+    {
+        return ptr == 0? 0: &this_type::get;
+    }
+
+#else 
+
+    typedef T * this_type::*unspecified_bool_type;
+
+    operator unspecified_bool_type() const // never throws
+    {
+        return ptr == 0? 0: &this_type::ptr;
+    }
+
+#endif
+
+    bool operator! () const // never throws
+    {
+        return ptr == 0;
+    }
+
+    void swap(scoped_array & b) // never throws
+    {
+        T * tmp = b.ptr;
+        b.ptr = ptr;
+        ptr = tmp;
+    }
+
+};
+
+template<class T> inline void swap(scoped_array<T> & a, scoped_array<T> & b) // never throws
+{
+    a.swap(b);
+}
+
+} // namespace boost
+
+#endif  // #ifndef BOOST_SCOPED_ARRAY_HPP_INCLUDED

Added: trunk/source/libraries/boost/scoped_ptr.hpp
===================================================================
--- trunk/source/libraries/boost/scoped_ptr.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/scoped_ptr.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,158 @@
+#ifndef BOOST_SCOPED_PTR_HPP_INCLUDED
+#define BOOST_SCOPED_PTR_HPP_INCLUDED
+
+//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
+//  Copyright (c) 2001, 2002 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided "as is" without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  http://www.boost.org/libs/smart_ptr/scoped_ptr.htm
+//
+
+#include <boost/assert.hpp>
+#include <boost/checked_delete.hpp>
+#include <boost/detail/workaround.hpp>
+
+#ifndef BOOST_NO_AUTO_PTR
+# include <memory>          // for std::auto_ptr
+#endif
+
+namespace boost
+{
+
+// Debug hooks
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+
+void sp_scalar_constructor_hook(void * p);
+void sp_scalar_destructor_hook(void * p);
+
+#endif
+
+//  scoped_ptr mimics a built-in pointer except that it guarantees deletion
+//  of the object pointed to, either on destruction of the scoped_ptr or via
+//  an explicit reset(). scoped_ptr is a simple solution for simple needs;
+//  use shared_ptr or std::auto_ptr if your needs are more complex.
+
+template<class T> class scoped_ptr // noncopyable
+{
+private:
+
+    T * ptr;
+
+    scoped_ptr(scoped_ptr const &);
+    scoped_ptr & operator=(scoped_ptr const &);
+
+    typedef scoped_ptr<T> this_type;
+
+public:
+
+    typedef T element_type;
+
+    explicit scoped_ptr(T * p = 0): ptr(p) // never throws
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_scalar_constructor_hook(ptr);
+#endif
+    }
+
+#ifndef BOOST_NO_AUTO_PTR
+
+    explicit scoped_ptr(std::auto_ptr<T> p): ptr(p.release()) // never throws
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_scalar_constructor_hook(ptr);
+#endif
+    }
+
+#endif
+
+    ~scoped_ptr() // never throws
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_scalar_destructor_hook(ptr);
+#endif
+        boost::checked_delete(ptr);
+    }
+
+    void reset(T * p = 0) // never throws
+    {
+        BOOST_ASSERT(p == 0 || p != ptr); // catch self-reset errors
+        this_type(p).swap(*this);
+    }
+
+    T & operator*() const // never throws
+    {
+        BOOST_ASSERT(ptr != 0);
+        return *ptr;
+    }
+
+    T * operator->() const // never throws
+    {
+        BOOST_ASSERT(ptr != 0);
+        return ptr;
+    }
+
+    T * get() const // never throws
+    {
+        return ptr;
+    }
+
+    // implicit conversion to "bool"
+
+#if defined(__SUNPRO_CC) && BOOST_WORKAROUND(__SUNPRO_CC, <= 0x530)
+
+    operator bool () const
+    {
+        return ptr != 0;
+    }
+
+#elif defined(__MWERKS__) && BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3003))
+    typedef T * (this_type::*unspecified_bool_type)() const;
+    
+    operator unspecified_bool_type() const // never throws
+    {
+        return ptr == 0? 0: &this_type::get;
+    }
+
+#else 
+    typedef T * this_type::*unspecified_bool_type;
+
+    operator unspecified_bool_type() const // never throws
+    {
+        return ptr == 0? 0: &this_type::ptr;
+    }
+
+#endif
+
+    bool operator! () const // never throws
+    {
+        return ptr == 0;
+    }
+
+    void swap(scoped_ptr & b) // never throws
+    {
+        T * tmp = b.ptr;
+        b.ptr = ptr;
+        ptr = tmp;
+    }
+};
+
+template<class T> inline void swap(scoped_ptr<T> & a, scoped_ptr<T> & b) // never throws
+{
+    a.swap(b);
+}
+
+// get_pointer(p) is a generic way to say p.get()
+
+template<class T> inline T * get_pointer(scoped_ptr<T> const & p)
+{
+    return p.get();
+}
+
+} // namespace boost
+
+#endif // #ifndef BOOST_SCOPED_PTR_HPP_INCLUDED

Added: trunk/source/libraries/boost/shared_array.hpp
===================================================================
--- trunk/source/libraries/boost/shared_array.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/shared_array.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,176 @@
+#ifndef BOOST_SHARED_ARRAY_HPP_INCLUDED
+#define BOOST_SHARED_ARRAY_HPP_INCLUDED
+
+//
+//  shared_array.hpp
+//
+//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
+//  Copyright (c) 2001, 2002 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided "as is" without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  See http://www.boost.org/libs/smart_ptr/shared_array.htm for documentation.
+//
+
+#include <boost/config.hpp>   // for broken compiler workarounds
+
+#if defined(BOOST_NO_MEMBER_TEMPLATES) && !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+#include <boost/detail/shared_array_nmt.hpp>
+#else
+
+#include <boost/assert.hpp>
+#include <boost/checked_delete.hpp>
+
+#include <boost/detail/shared_count.hpp>
+#include <boost/detail/workaround.hpp>
+
+#include <cstddef>            // for std::ptrdiff_t
+#include <algorithm>          // for std::swap
+#include <functional>         // for std::less
+
+namespace boost
+{
+
+//
+//  shared_array
+//
+//  shared_array extends shared_ptr to arrays.
+//  The array pointed to is deleted when the last shared_array pointing to it
+//  is destroyed or reset.
+//
+
+template<class T> class shared_array
+{
+private:
+
+    // Borland 5.5.1 specific workarounds
+    typedef checked_array_deleter<T> deleter;
+    typedef shared_array<T> this_type;
+
+public:
+
+    typedef T element_type;
+
+    explicit shared_array(T * p = 0): px(p), pn(p, deleter())
+    {
+    }
+
+    //
+    // Requirements: D's copy constructor must not throw
+    //
+    // shared_array will release p by calling d(p)
+    //
+
+    template<class D> shared_array(T * p, D d): px(p), pn(p, d)
+    {
+    }
+
+//  generated copy constructor, assignment, destructor are fine
+
+    void reset(T * p = 0)
+    {
+        BOOST_ASSERT(p == 0 || p != px);
+        this_type(p).swap(*this);
+    }
+
+    template <class D> void reset(T * p, D d)
+    {
+        this_type(p, d).swap(*this);
+    }
+
+    T & operator[] (std::ptrdiff_t i) const // never throws
+    {
+        BOOST_ASSERT(px != 0);
+        BOOST_ASSERT(i >= 0);
+        return px[i];
+    }
+    
+    T * get() const // never throws
+    {
+        return px;
+    }
+
+    // implicit conversion to "bool"
+
+#if defined(__SUNPRO_CC) && BOOST_WORKAROUND(__SUNPRO_CC, <= 0x530)
+
+    operator bool () const
+    {
+        return px != 0;
+    }
+
+#elif defined(__MWERKS__) && BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3003))
+    typedef T * (this_type::*unspecified_bool_type)() const;
+    
+    operator unspecified_bool_type() const // never throws
+    {
+        return px == 0? 0: &this_type::get;
+    }
+
+#else 
+
+    typedef T * this_type::*unspecified_bool_type;
+
+    operator unspecified_bool_type() const // never throws
+    {
+        return px == 0? 0: &this_type::px;
+    }
+
+#endif
+
+    bool operator! () const // never throws
+    {
+        return px == 0;
+    }
+
+    bool unique() const // never throws
+    {
+        return pn.unique();
+    }
+
+    long use_count() const // never throws
+    {
+        return pn.use_count();
+    }
+
+    void swap(shared_array<T> & other) // never throws
+    {
+        std::swap(px, other.px);
+        pn.swap(other.pn);
+    }
+
+private:
+
+    T * px;                     // contained pointer
+    detail::shared_count pn;    // reference counter
+
+};  // shared_array
+
+template<class T> inline bool operator==(shared_array<T> const & a, shared_array<T> const & b) // never throws
+{
+    return a.get() == b.get();
+}
+
+template<class T> inline bool operator!=(shared_array<T> const & a, shared_array<T> const & b) // never throws
+{
+    return a.get() != b.get();
+}
+
+template<class T> inline bool operator<(shared_array<T> const & a, shared_array<T> const & b) // never throws
+{
+    return std::less<T*>()(a.get(), b.get());
+}
+
+template<class T> void swap(shared_array<T> & a, shared_array<T> & b) // never throws
+{
+    a.swap(b);
+}
+
+} // namespace boost
+
+#endif  // #if defined(BOOST_NO_MEMBER_TEMPLATES) && !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+
+#endif  // #ifndef BOOST_SHARED_ARRAY_HPP_INCLUDED

Added: trunk/source/libraries/boost/shared_container_iterator.hpp
===================================================================
--- trunk/source/libraries/boost/shared_container_iterator.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/shared_container_iterator.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,62 @@
+// (C) Copyright Ronald Garcia 2002. Permission to copy, use, modify, sell and
+// distribute this software is granted provided this copyright notice appears
+// in all copies. This software is provided "as is" without express or implied
+// warranty, and with no claim as to its suitability for any purpose.
+
+// See http://www.boost.org/libs/utility/shared_container_iterator.html for documentation.
+
+#ifndef SHARED_CONTAINER_ITERATOR_RG08102002_HPP
+#define SHARED_CONTAINER_ITERATOR_RG08102002_HPP
+
+#include "boost/iterator_adaptors.hpp"
+#include "boost/shared_ptr.hpp"
+#include <utility>
+
+namespace boost {
+
+template <typename Container>
+class shared_container_iterator : public iterator_adaptor<
+                                    shared_container_iterator<Container>,
+                                    typename Container::iterator> {
+
+  typedef iterator_adaptor<
+    shared_container_iterator<Container>,
+    typename Container::iterator> super_t;
+
+  typedef typename Container::iterator iterator_t;
+  typedef boost::shared_ptr<Container> container_ref_t;
+
+  container_ref_t container_ref;
+public:
+  shared_container_iterator() { }
+
+  shared_container_iterator(iterator_t const& x,container_ref_t const& c) :
+    super_t(x), container_ref(c) { }
+
+
+};
+
+template <typename Container>
+shared_container_iterator<Container>
+make_shared_container_iterator(typename Container::iterator iter,
+                               boost::shared_ptr<Container> const& container) {
+  typedef shared_container_iterator<Container> iterator;
+  return iterator(iter,container);
+}
+
+
+
+template <typename Container>
+std::pair<
+  shared_container_iterator<Container>,
+  shared_container_iterator<Container> >
+make_shared_container_range(boost::shared_ptr<Container> const& container) {
+  return
+    std::make_pair(
+      make_shared_container_iterator(container->begin(),container),
+      make_shared_container_iterator(container->end(),container));
+}
+
+
+} // namespace boost
+#endif  // SHARED_CONTAINER_ITERATOR_RG08102002_HPP

Added: trunk/source/libraries/boost/shared_ptr.hpp
===================================================================
--- trunk/source/libraries/boost/shared_ptr.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/shared_ptr.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,474 @@
+#ifndef BOOST_SHARED_PTR_HPP_INCLUDED
+#define BOOST_SHARED_PTR_HPP_INCLUDED
+
+//
+//  shared_ptr.hpp
+//
+//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
+//  Copyright (c) 2001, 2002, 2003 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided "as is" without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  See http://www.boost.org/libs/smart_ptr/shared_ptr.htm for documentation.
+//
+
+#include <boost/config.hpp>   // for broken compiler workarounds
+
+#if defined(BOOST_NO_MEMBER_TEMPLATES) && !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+#include <boost/detail/shared_ptr_nmt.hpp>
+#else
+
+#include <boost/assert.hpp>
+#include <boost/checked_delete.hpp>
+#include <boost/throw_exception.hpp>
+#include <boost/detail/shared_count.hpp>
+#include <boost/detail/workaround.hpp>
+
+#include <memory>               // for std::auto_ptr
+#include <algorithm>            // for std::swap
+#include <functional>           // for std::less
+#include <typeinfo>             // for std::bad_cast
+#include <iosfwd>               // for std::basic_ostream
+
+#ifdef BOOST_MSVC  // moved here to work around VC++ compiler crash
+# pragma warning(push)
+# pragma warning(disable:4284) // odd return type for operator->
+#endif
+
+namespace boost
+{
+
+template<class T> class weak_ptr;
+template<class T> class enable_shared_from_this;
+
+namespace detail
+{
+
+struct static_cast_tag {};
+struct const_cast_tag {};
+struct dynamic_cast_tag {};
+struct polymorphic_cast_tag {};
+
+template<class T> struct shared_ptr_traits
+{
+    typedef T & reference;
+};
+
+template<> struct shared_ptr_traits<void>
+{
+    typedef void reference;
+};
+
+#if !defined(BOOST_NO_CV_VOID_SPECIALIZATIONS)
+
+template<> struct shared_ptr_traits<void const>
+{
+    typedef void reference;
+};
+
+template<> struct shared_ptr_traits<void volatile>
+{
+    typedef void reference;
+};
+
+template<> struct shared_ptr_traits<void const volatile>
+{
+    typedef void reference;
+};
+
+#endif
+
+// enable_shared_from_this support
+
+template<class T, class Y> void sp_enable_shared_from_this(boost::enable_shared_from_this<T> * pe, Y * px, shared_count const & pn)
+{
+    if(pe != 0) pe->_internal_weak_this._internal_assign(px, pn);
+}
+
+inline void sp_enable_shared_from_this(void const volatile *, void const volatile *, shared_count const &)
+{
+}
+
+} // namespace detail
+
+
+//
+//  shared_ptr
+//
+//  An enhanced relative of scoped_ptr with reference counted copy semantics.
+//  The object pointed to is deleted when the last shared_ptr pointing to it
+//  is destroyed or reset.
+//
+
+template<class T> class shared_ptr
+{
+private:
+
+    // Borland 5.5.1 specific workaround
+    typedef shared_ptr<T> this_type;
+
+public:
+
+    typedef T element_type;
+    typedef T value_type;
+    typedef T * pointer;
+    typedef typename detail::shared_ptr_traits<T>::reference reference;
+
+    shared_ptr(): px(0), pn() // never throws in 1.30+
+    {
+    }
+
+    template<class Y>
+    explicit shared_ptr(Y * p): px(p), pn(p, checked_deleter<Y>()) // Y must be complete
+    {
+        detail::sp_enable_shared_from_this(p, p, pn);
+    }
+
+    //
+    // Requirements: D's copy constructor must not throw
+    //
+    // shared_ptr will release p by calling d(p)
+    //
+
+    template<class Y, class D> shared_ptr(Y * p, D d): px(p), pn(p, d)
+    {
+        detail::sp_enable_shared_from_this(p, p, pn);
+    }
+
+//  generated copy constructor, assignment, destructor are fine...
+
+//  except that Borland C++ has a bug, and g++ with -Wsynth warns
+#if defined(__BORLANDC__) || defined(__GNUC__)
+
+    shared_ptr & operator=(shared_ptr const & r) // never throws
+    {
+        px = r.px;
+        pn = r.pn; // shared_count::op= doesn't throw
+        return *this;
+    }
+
+#endif
+
+    template<class Y>
+    explicit shared_ptr(weak_ptr<Y> const & r): pn(r.pn) // may throw
+    {
+        // it is now safe to copy r.px, as pn(r.pn) did not throw
+        px = r.px;
+    }
+
+    template<class Y>
+    shared_ptr(shared_ptr<Y> const & r): px(r.px), pn(r.pn) // never throws
+    {
+    }
+
+    template<class Y>
+    shared_ptr(shared_ptr<Y> const & r, detail::static_cast_tag): px(static_cast<element_type *>(r.px)), pn(r.pn)
+    {
+    }
+
+    template<class Y>
+    shared_ptr(shared_ptr<Y> const & r, detail::const_cast_tag): px(const_cast<element_type *>(r.px)), pn(r.pn)
+    {
+    }
+
+    template<class Y>
+    shared_ptr(shared_ptr<Y> const & r, detail::dynamic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
+    {
+        if(px == 0) // need to allocate new counter -- the cast failed
+        {
+            pn = detail::shared_count();
+        }
+    }
+
+    template<class Y>
+    shared_ptr(shared_ptr<Y> const & r, detail::polymorphic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
+    {
+        if(px == 0)
+        {
+            boost::throw_exception(std::bad_cast());
+        }
+    }
+
+#ifndef BOOST_NO_AUTO_PTR
+
+    template<class Y>
+    explicit shared_ptr(std::auto_ptr<Y> & r): px(r.get()), pn()
+    {
+        Y * tmp = r.get();
+        pn = detail::shared_count(r);
+        detail::sp_enable_shared_from_this(tmp, tmp, pn);
+    }
+
+#endif
+
+#if !defined(BOOST_MSVC) || (BOOST_MSVC > 1200)
+
+    template<class Y>
+    shared_ptr & operator=(shared_ptr<Y> const & r) // never throws
+    {
+        px = r.px;
+        pn = r.pn; // shared_count::op= doesn't throw
+        return *this;
+    }
+
+#endif
+
+#ifndef BOOST_NO_AUTO_PTR
+
+    template<class Y>
+    shared_ptr & operator=(std::auto_ptr<Y> & r)
+    {
+        this_type(r).swap(*this);
+        return *this;
+    }
+
+#endif
+
+    void reset() // never throws in 1.30+
+    {
+        this_type().swap(*this);
+    }
+
+    template<class Y> void reset(Y * p) // Y must be complete
+    {
+        BOOST_ASSERT(p == 0 || p != px); // catch self-reset errors
+        this_type(p).swap(*this);
+    }
+
+    template<class Y, class D> void reset(Y * p, D d)
+    {
+        this_type(p, d).swap(*this);
+    }
+
+    reference operator* () const // never throws
+    {
+        BOOST_ASSERT(px != 0);
+        return *px;
+    }
+
+    T * operator-> () const // never throws
+    {
+        BOOST_ASSERT(px != 0);
+        return px;
+    }
+    
+    T * get() const // never throws
+    {
+        return px;
+    }
+
+    // implicit conversion to "bool"
+
+#if defined(__SUNPRO_CC) && BOOST_WORKAROUND(__SUNPRO_CC, <= 0x530)
+
+    operator bool () const
+    {
+        return px != 0;
+    }
+
+#elif defined(__MWERKS__) && BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3003))
+    typedef T * (this_type::*unspecified_bool_type)() const;
+    
+    operator unspecified_bool_type() const // never throws
+    {
+        return px == 0? 0: &this_type::get;
+    }
+
+#else 
+
+    typedef T * this_type::*unspecified_bool_type;
+
+    operator unspecified_bool_type() const // never throws
+    {
+        return px == 0? 0: &this_type::px;
+    }
+
+#endif
+
+    // operator! is redundant, but some compilers need it
+
+    bool operator! () const // never throws
+    {
+        return px == 0;
+    }
+
+    bool unique() const // never throws
+    {
+        return pn.unique();
+    }
+
+    long use_count() const // never throws
+    {
+        return pn.use_count();
+    }
+
+    void swap(shared_ptr<T> & other) // never throws
+    {
+        std::swap(px, other.px);
+        pn.swap(other.pn);
+    }
+
+    template<class Y> bool _internal_less(shared_ptr<Y> const & rhs) const
+    {
+        return pn < rhs.pn;
+    }
+
+    void * _internal_get_deleter(std::type_info const & ti) const
+    {
+        return pn.get_deleter(ti);
+    }
+
+// Tasteless as this may seem, making all members public allows member templates
+// to work in the absence of member template friends. (Matthew Langston)
+
+#ifndef BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+
+private:
+
+    template<class Y> friend class shared_ptr;
+    template<class Y> friend class weak_ptr;
+
+
+#endif
+
+    T * px;                     // contained pointer
+    detail::shared_count pn;    // reference counter
+
+};  // shared_ptr
+
+template<class T, class U> inline bool operator==(shared_ptr<T> const & a, shared_ptr<U> const & b)
+{
+    return a.get() == b.get();
+}
+
+template<class T, class U> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<U> const & b)
+{
+    return a.get() != b.get();
+}
+
+#if __GNUC__ == 2 && __GNUC_MINOR__ <= 96
+
+// Resolve the ambiguity between our op!= and the one in rel_ops
+
+template<class T> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<T> const & b)
+{
+    return a.get() != b.get();
+}
+
+#endif
+
+template<class T, class U> inline bool operator<(shared_ptr<T> const & a, shared_ptr<U> const & b)
+{
+    return a._internal_less(b);
+}
+
+template<class T> inline void swap(shared_ptr<T> & a, shared_ptr<T> & b)
+{
+    a.swap(b);
+}
+
+template<class T, class U> shared_ptr<T> static_pointer_cast(shared_ptr<U> const & r)
+{
+    return shared_ptr<T>(r, detail::static_cast_tag());
+}
+
+template<class T, class U> shared_ptr<T> const_pointer_cast(shared_ptr<U> const & r)
+{
+    return shared_ptr<T>(r, detail::const_cast_tag());
+}
+
+template<class T, class U> shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const & r)
+{
+    return shared_ptr<T>(r, detail::dynamic_cast_tag());
+}
+
+// shared_*_cast names are deprecated. Use *_pointer_cast instead.
+
+template<class T, class U> shared_ptr<T> shared_static_cast(shared_ptr<U> const & r)
+{
+    return shared_ptr<T>(r, detail::static_cast_tag());
+}
+
+template<class T, class U> shared_ptr<T> shared_dynamic_cast(shared_ptr<U> const & r)
+{
+    return shared_ptr<T>(r, detail::dynamic_cast_tag());
+}
+
+template<class T, class U> shared_ptr<T> shared_polymorphic_cast(shared_ptr<U> const & r)
+{
+    return shared_ptr<T>(r, detail::polymorphic_cast_tag());
+}
+
+template<class T, class U> shared_ptr<T> shared_polymorphic_downcast(shared_ptr<U> const & r)
+{
+    BOOST_ASSERT(dynamic_cast<T *>(r.get()) == r.get());
+    return shared_static_cast<T>(r);
+}
+
+// get_pointer() enables boost::mem_fn to recognize shared_ptr
+
+template<class T> inline T * get_pointer(shared_ptr<T> const & p)
+{
+    return p.get();
+}
+
+// operator<<
+
+#if defined(__GNUC__) &&  (__GNUC__ < 3)
+
+template<class Y> std::ostream & operator<< (std::ostream & os, shared_ptr<Y> const & p)
+{
+    os << p.get();
+    return os;
+}
+
+#else
+
+# if defined(BOOST_MSVC) && BOOST_WORKAROUND(BOOST_MSVC, <= 1200 && __SGI_STL_PORT)
+// MSVC6 has problems finding std::basic_ostream through the using declaration in namespace _STL
+using std::basic_ostream;
+template<class E, class T, class Y> basic_ostream<E, T> & operator<< (basic_ostream<E, T> & os, shared_ptr<Y> const & p)
+# else
+template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, shared_ptr<Y> const & p)
+# endif 
+{
+    os << p.get();
+    return os;
+}
+
+#endif
+
+// get_deleter (experimental)
+
+#if (defined(__GNUC__) &&  (__GNUC__ < 3)) || (defined(__EDG_VERSION__) && (__EDG_VERSION__ <= 238))
+
+// g++ 2.9x doesn't allow static_cast<X const *>(void *)
+// apparently EDG 2.38 also doesn't accept it
+
+template<class D, class T> D * get_deleter(shared_ptr<T> const & p)
+{
+    void const * q = p._internal_get_deleter(typeid(D));
+    return const_cast<D *>(static_cast<D const *>(q));
+}
+
+#else
+
+template<class D, class T> D * get_deleter(shared_ptr<T> const & p)
+{
+    return static_cast<D *>(p._internal_get_deleter(typeid(D)));
+}
+
+#endif
+
+} // namespace boost
+
+#ifdef BOOST_MSVC
+# pragma warning(pop)
+#endif    
+
+#endif  // #if defined(BOOST_NO_MEMBER_TEMPLATES) && !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+
+#endif  // #ifndef BOOST_SHARED_PTR_HPP_INCLUDED

Added: trunk/source/libraries/boost/smart_ptr.hpp
===================================================================
--- trunk/source/libraries/boost/smart_ptr.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/smart_ptr.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,29 @@
+//
+//  smart_ptr.hpp
+//
+//  For convenience, this header includes the rest of the smart
+//  pointer library headers.
+//
+//  Copyright (c) 1998-2002 boost.org
+//  Copyright (c) 2003 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided "as is" without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  http://www.boost.org/libs/smart_ptr/smart_ptr.htm
+//
+
+#include <boost/config.hpp>
+
+#include <boost/scoped_ptr.hpp>
+#include <boost/scoped_array.hpp>
+#include <boost/shared_ptr.hpp>
+#include <boost/shared_array.hpp>
+
+#if !defined(BOOST_NO_MEMBER_TEMPLATES) || defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+# include <boost/weak_ptr.hpp>
+# include <boost/intrusive_ptr.hpp>
+# include <boost/enable_shared_from_this.hpp>
+#endif

Added: trunk/source/libraries/boost/throw_exception.hpp
===================================================================
--- trunk/source/libraries/boost/throw_exception.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/throw_exception.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,47 @@
+#ifndef BOOST_THROW_EXCEPTION_HPP_INCLUDED
+#define BOOST_THROW_EXCEPTION_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  boost/throw_exception.hpp
+//
+//  Copyright (c) 2002 Peter Dimov and Multi Media Ltd.
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided "as is" without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  http://www.boost.org/libs/utility/throw_exception.html
+//
+
+#include <boost/config.hpp>
+
+#ifdef BOOST_NO_EXCEPTIONS
+# include <exception>
+#endif
+
+namespace boost
+{
+
+#ifdef BOOST_NO_EXCEPTIONS
+
+void throw_exception(std::exception const & e); // user defined
+
+#else
+
+template<class E> void throw_exception(E const & e)
+{
+    throw e;
+}
+
+#endif
+
+} // namespace boost
+
+#endif // #ifndef BOOST_THROW_EXCEPTION_HPP_INCLUDED

Added: trunk/source/libraries/boost/type.hpp
===================================================================
--- trunk/source/libraries/boost/type.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/type.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,19 @@
+// (C) Copyright David Abrahams 2001. Permission to copy, use,
+// modify, sell and distribute this software is granted provided this
+// copyright notice appears in all copies. This software is provided
+// "as is" without express or implied warranty, and with no claim as
+// to its suitability for any purpose.
+
+#ifndef BOOST_TYPE_DWA20010120_HPP
+# define BOOST_TYPE_DWA20010120_HPP
+
+namespace boost {
+
+  // Just a simple "type envelope". Useful in various contexts, mostly to work
+  // around some MSVC deficiencies.
+  template <class T>
+  struct type {};
+
+}
+
+#endif // BOOST_TYPE_DWA20010120_HPP

Added: trunk/source/libraries/boost/weak_ptr.hpp
===================================================================
--- trunk/source/libraries/boost/weak_ptr.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/weak_ptr.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,193 @@
+#ifndef BOOST_WEAK_PTR_HPP_INCLUDED
+#define BOOST_WEAK_PTR_HPP_INCLUDED
+
+//
+//  weak_ptr.hpp
+//
+//  Copyright (c) 2001, 2002, 2003 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided "as is" without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  See http://www.boost.org/libs/smart_ptr/weak_ptr.htm for documentation.
+//
+
+#include <boost/shared_ptr.hpp>
+
+#ifdef BOOST_MSVC  // moved here to work around VC++ compiler crash
+# pragma warning(push)
+# pragma warning(disable:4284) // odd return type for operator->
+#endif
+
+namespace boost
+{
+
+template<class T> class weak_ptr
+{
+private:
+
+    // Borland 5.5.1 specific workarounds
+    typedef weak_ptr<T> this_type;
+
+public:
+
+    typedef T element_type;
+
+    weak_ptr(): px(0), pn() // never throws in 1.30+
+    {
+    }
+
+//  generated copy constructor, assignment, destructor are fine
+
+
+//
+//  The "obvious" converting constructor implementation:
+//
+//  template<class Y>
+//  weak_ptr(weak_ptr<Y> const & r): px(r.px), pn(r.pn) // never throws
+//  {
+//  }
+//
+//  has a serious problem.
+//
+//  r.px may already have been invalidated. The px(r.px)
+//  conversion may require access to *r.px (virtual inheritance).
+//
+//  It is not possible to avoid spurious access violations since
+//  in multithreaded programs r.px may be invalidated at any point.
+//
+
+    template<class Y>
+    weak_ptr(weak_ptr<Y> const & r): pn(r.pn) // never throws
+    {
+        px = r.lock().get();
+    }
+
+    template<class Y>
+    weak_ptr(shared_ptr<Y> const & r): px(r.px), pn(r.pn) // never throws
+    {
+    }
+
+#if !defined(BOOST_MSVC) || (BOOST_MSVC > 1200)
+
+    template<class Y>
+    weak_ptr & operator=(weak_ptr<Y> const & r) // never throws
+    {
+        px = r.lock().get();
+        pn = r.pn;
+        return *this;
+    }
+
+    template<class Y>
+    weak_ptr & operator=(shared_ptr<Y> const & r) // never throws
+    {
+        px = r.px;
+        pn = r.pn;
+        return *this;
+    }
+
+#endif
+
+    shared_ptr<T> lock() const // never throws
+    {
+#if defined(BOOST_HAS_THREADS)
+
+        // optimization: avoid throw overhead
+        if(expired())
+        {
+            return shared_ptr<element_type>();
+        }
+
+        try
+        {
+            return shared_ptr<element_type>(*this);
+        }
+        catch(bad_weak_ptr const &)
+        {
+            // Q: how can we get here?
+            // A: another thread may have invalidated r after the use_count test above.
+            return shared_ptr<element_type>();
+        }
+
+#else
+
+        // optimization: avoid try/catch overhead when single threaded
+        return expired()? shared_ptr<element_type>(): shared_ptr<element_type>(*this);
+
+#endif
+    }
+
+    long use_count() const // never throws
+    {
+        return pn.use_count();
+    }
+
+    bool expired() const // never throws
+    {
+        return pn.use_count() == 0;
+    }
+
+    void reset() // never throws in 1.30+
+    {
+        this_type().swap(*this);
+    }
+
+    void swap(this_type & other) // never throws
+    {
+        std::swap(px, other.px);
+        pn.swap(other.pn);
+    }
+
+    void _internal_assign(T * px2, detail::shared_count const & pn2)
+    {
+        px = px2;
+        pn = pn2;
+    }
+
+    template<class Y> bool _internal_less(weak_ptr<Y> const & rhs) const
+    {
+        return pn < rhs.pn;
+    }
+
+// Tasteless as this may seem, making all members public allows member templates
+// to work in the absence of member template friends. (Matthew Langston)
+
+#ifndef BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+
+private:
+
+    template<class Y> friend class weak_ptr;
+    template<class Y> friend class shared_ptr;
+
+#endif
+
+    T * px;                     // contained pointer
+    detail::weak_count pn;      // reference counter
+
+};  // weak_ptr
+
+template<class T, class U> inline bool operator<(weak_ptr<T> const & a, weak_ptr<U> const & b)
+{
+    return a._internal_less(b);
+}
+
+template<class T> void swap(weak_ptr<T> & a, weak_ptr<T> & b)
+{
+    a.swap(b);
+}
+
+// deprecated, provided for backward compatibility
+template<class T> shared_ptr<T> make_shared(weak_ptr<T> const & r)
+{
+    return r.lock();
+}
+
+} // namespace boost
+
+#ifdef BOOST_MSVC
+# pragma warning(pop)
+#endif    
+
+#endif  // #ifndef BOOST_WEAK_PTR_HPP_INCLUDED

Modified: trunk/sources.lst
===================================================================
--- trunk/sources.lst	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/sources.lst	2005-09-24 05:41:48 UTC (rev 193)
@@ -1,6 +1,6 @@
-source/python/python_class.cpp
 source/python/game.cpp
 source/other/starmap.cpp
+source/python/python_class.cpp
 source/other/planet3d.cpp
 source/other/gobwarpouttrail.cpp
 source/other/fontmorph.cpp



From yurand at berlios.de  Mon Sep 26 20:13:41 2005
From: yurand at berlios.de (Yura Semashko at BerliOS)
Date: Mon, 26 Sep 2005 20:13:41 +0200
Subject: [Tw-light-svn] r194 - trunk/source/melee
Message-ID: <200509261813.j8QIDfD6022171@sheep.berlios.de>

Author: yurand
Date: 2005-09-26 20:13:38 +0200 (Mon, 26 Sep 2005)
New Revision: 194

Modified:
   trunk/source/melee/mframe.cpp
   trunk/source/melee/mframe.h
   trunk/source/melee/mview.cpp
Log:
Updating Corona688 dynamic view


Modified: trunk/source/melee/mframe.cpp
===================================================================
--- trunk/source/melee/mframe.cpp	2005-09-24 05:41:48 UTC (rev 193)
+++ trunk/source/melee/mframe.cpp	2005-09-26 18:13:38 UTC (rev 194)
@@ -545,6 +545,15 @@
 	  );
 }
 
+Vector2 SpaceLocation::rel_pos(SpaceLocation *l) const
+{
+   Vector2 p1,p2;
+   p1=normal_pos();
+   p2=l->normal_pos();
+   return(Vector2(min_delta(p1.x,p2.x,map_size.x),
+       min_delta(p1.y,p2.y,map_size.y)) );
+}
+
 double SpaceLocation::distance(SpaceLocation *l)
 {
   return(distance_from(normal_pos(), l->normal_pos()));

Modified: trunk/source/melee/mframe.h
===================================================================
--- trunk/source/melee/mframe.h	2005-09-24 05:41:48 UTC (rev 193)
+++ trunk/source/melee/mframe.h	2005-09-26 18:13:38 UTC (rev 194)
@@ -283,6 +283,8 @@
 
   virtual SpaceLocation *get_focus();
 
+  /// Returns the shortest relative vector to an object
+  Vector2 rel_pos(SpaceLocation *l) const;
   /// returns the x,y coordinates, and normalizes it (0 <= pos.x < map_size.x), (0 <= pos.y < map_size.y)
   Vector2 normal_pos() const;          
   Vector2 nearest_pos(SpaceLocation *l) const;

Modified: trunk/source/melee/mview.cpp
===================================================================
--- trunk/source/melee/mview.cpp	2005-09-24 05:41:48 UTC (rev 193)
+++ trunk/source/melee/mview.cpp	2005-09-26 18:13:38 UTC (rev 194)
@@ -532,6 +532,67 @@
 }
 
 /**
+ * Weighted-average camera class.  Takes average of values and weights
+ * of values fed into it.
+ */
+class CCameraPosition:public CameraPosition
+{
+   double totalweight;
+public:
+   inline CCameraPosition() { Reset(); }
+
+   inline CCameraPosition(const CameraPosition &cp)
+   {
+       totalweight=1.0f;
+       pos=cp.pos;
+       vel=cp.vel;
+       z=cp.z;
+   }
+
+   inline void Set(Vector2 ipos, Vector2 ivel, float iz, float weight)
+   {
+       totalweight=weight;
+       pos=ipos*weight;
+       vel=ivel*weight;
+       z=iz*weight;
+   }
+
+   inline void Accumulate(Vector2 ipos, Vector2 ivel,
+       float iz, float weight)
+   {
+       pos+=(ipos*weight);
+       vel+=(ivel*weight);
+       z+=(iz*weight);
+       totalweight+=weight;
+   }
+
+   /* Take weighted average to get final values */
+   inline void Finalize()
+   {
+       pos/=totalweight;
+       vel/=totalweight;
+       z  /=totalweight;
+       totalweight=1.0f;
+   }
+
+   inline void operator=(const CameraPosition &cp)
+   {
+       totalweight=1.0f;
+       pos=cp.pos;
+       vel=cp.vel;
+       z=cp.z;
+   }
+
+   inline void Reset()
+   {
+       totalweight=0.0f;
+       pos.x=pos.y=0.0f;
+       vel.x=vel.y=0.0f;
+       z          =0.0f;
+   }
+};
+
+/**
  * "Dynamic" view:  hero-centered intelligent zooming for multiple
  * ships.
  *
@@ -544,6 +605,17 @@
   double cutoff;
   double f,power;
   double max, min;
+
+  // Z-value as a function of distance from hero
+  inline float zcurve(float dist) const { return dist*2.0f; }
+  // Weight/influence as a function of distance from hero
+  inline float wcurve(float dist) const
+  {
+    // Logarithmic curves seem the most natural-looking.
+    // We use the negative part of the curve from (0,1], scaled to
+    // (0,cutoff]
+    return((-50.0f)*log(dist/cutoff));
+  }
 public:
   virtual void calculate(Game *game);
   virtual void init(View *old);  
@@ -561,8 +633,50 @@
 }
 
 void View_Dynamic::calculate (Game *game) {STACKTRACE
+   int i;
+   CCameraPosition cpos=camera;
+   SpaceLocation *c=NULL;
 
-  int i;
+   if(game->num_focuses) c=game->focus[game->focus_index]->get_focus();
+
+   if (key_pressed(key_zoom_in))  f /= 1 + 0.002 * frame_time;
+   if (key_pressed(key_zoom_out)) f *= 1 + 0.002 * frame_time;
+
+   if(c!=NULL)
+   {
+       cpos.Set(c->pos,c->vel,f,power);
+
+       for(i=0; i<=game->gametargets.N; i++)
+       {
+           float dist;
+           SpaceObject *obj;
+           if(i==game->gametargets.N)
+               obj=c->nearest_planet();
+           else
+               obj=game->gametargets.item[i];
+
+           if((obj==NULL)||(obj==c)) continue;
+           if(!(obj->isPlanet() || obj->isShip())) continue;
+
+           dist=c->distance(obj);
+           if(dist > cutoff) continue;
+
+           cpos.Accumulate( c->pos - (c->rel_pos(obj)/2),
+               (c->vel + obj->vel)/2,
+               zcurve(dist),
+               wcurve(dist));
+
+       }
+
+       cpos.Finalize();
+       if(cpos.z < min) cpos.z=min;
+       else if(cpos.z > max) cpos.z=max;
+   }
+
+   focus(&cpos,NULL);
+   track(cpos,frame_time);
+
+/*  int i;
   CameraPosition n = camera;
   SpaceLocation *c = NULL;
   if (game->num_focuses) c = game->focus[game->focus_index]->get_focus();
@@ -602,7 +716,7 @@
 
   focus ( &n, c );
   track ( n, frame_time );
-  return;
+  return;*/
 }
 
 class View_Hero : public View {



From yurand at berlios.de  Mon Sep 26 20:25:09 2005
From: yurand at berlios.de (Yura Semashko at BerliOS)
Date: Mon, 26 Sep 2005 20:25:09 +0200
Subject: [Tw-light-svn] r195 - trunk/source/util
Message-ID: <200509261825.j8QIP9Ii022920@sheep.berlios.de>

Author: yurand
Date: 2005-09-26 20:25:09 +0200 (Mon, 26 Sep 2005)
New Revision: 195

Modified:
   trunk/source/util/aautil.c
Log:
Fixed 64-bit issue

Modified: trunk/source/util/aautil.c
===================================================================
--- trunk/source/util/aautil.c	2005-09-26 18:13:38 UTC (rev 194)
+++ trunk/source/util/aautil.c	2005-09-26 18:25:09 UTC (rev 195)
@@ -356,12 +356,14 @@
 	if (options & AA_DITHER)  j += 2;
 	if (options & AA_MASKED_DEST) j += 4;
 
+#if 0
 #	ifdef GFX_MODEX
 		if (is_planar_bitmap(destination)) {
 			if (bpp != 8) return NULL;
 			return put_array_modex[j & 3];
 		}
 #	endif
+#endif
 
 	if (options & AA_RAW_ALPHA) {
 		if (bpp == 32) return &_aa_put_raw_32a;



